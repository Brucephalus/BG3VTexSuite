
// C:\WINDOWS\Microsoft.NET\assembly\GAC_MSIL\System.Management\v4.0_4.0.0.0__b03f5f7f11d50a3a\System.Management.dll
// System.Management, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v4.0.30319
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.Design.Serialization;
using System.Configuration.Install;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Management.Instrumentation;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Permissions;
using System.Security.Principal;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using Microsoft.CSharp;
using Microsoft.JScript;
using Microsoft.VisualBasic;
using Microsoft.Win32;

[assembly: CompilationRelaxations(8)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: ComVisible(false)]
[assembly: CLSCompliant(true)]
[assembly: AssemblyTitle("System.Management.dll")]
[assembly: AssemblyDescription("System.Management.dll")]
[assembly: AssemblyDefaultAlias("System.Management.dll")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyFileVersion("4.8.9037.0")]
[assembly: AssemblyInformationalVersion("4.8.9037.0")]
[assembly: SatelliteContractVersion("4.0.0.0")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: AssemblyDelaySign(true)]
[assembly: AssemblyKeyFile("f:\\dd\\tools\\devdiv\\FinalPublicKey.snk")]
[assembly: AssemblySignatureKey("002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3", "a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d")]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: DefaultDllImportSearchPaths(DllImportSearchPath.System32 | DllImportSearchPath.AssemblyDirectory)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, UnmanagedCode = true)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("4.0.0.0")]
[module: UnverifiableCode]
internal static class FXAssembly
{
	internal const string Version = "4.0.0.0";
}
internal static class ThisAssembly
{
	internal const string Title = "System.Management.dll";

	internal const string Description = "System.Management.dll";

	internal const string DefaultAlias = "System.Management.dll";

	internal const string Copyright = "© Microsoft Corporation.  All rights reserved.";

	internal const string Version = "4.0.0.0";

	internal const string InformationalVersion = "4.8.9037.0";

	internal const string DailyBuildNumberStr = "30319";

	internal const string BuildRevisionStr = "0";

	internal const int DailyBuildNumber = 30319;
}
internal static class AssemblyRef
{
	internal const string EcmaPublicKey = "b77a5c561934e089";

	internal const string EcmaPublicKeyToken = "b77a5c561934e089";

	internal const string EcmaPublicKeyFull = "00000000000000000400000000000000";

	internal const string SilverlightPublicKey = "31bf3856ad364e35";

	internal const string SilverlightPublicKeyToken = "31bf3856ad364e35";

	internal const string SilverlightPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9";

	internal const string SilverlightPlatformPublicKey = "7cec85d7bea7798e";

	internal const string SilverlightPlatformPublicKeyToken = "7cec85d7bea7798e";

	internal const string SilverlightPlatformPublicKeyFull = "00240000048000009400000006020000002400005253413100040000010001008D56C76F9E8649383049F383C44BE0EC204181822A6C31CF5EB7EF486944D032188EA1D3920763712CCB12D75FB77E9811149E6148E5D32FBAAB37611C1878DDC19E20EF135D0CB2CFF2BFEC3D115810C3D9069638FE4BE215DBF795861920E5AB6F7DB2E2CEEF136AC23D5DD2BF031700AEC232F6C6B1C785B4305C123B37AB";

	internal const string PlatformPublicKey = "b77a5c561934e089";

	internal const string PlatformPublicKeyToken = "b77a5c561934e089";

	internal const string PlatformPublicKeyFull = "00000000000000000400000000000000";

	internal const string Mscorlib = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemData = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemDataOracleClient = "System.Data.OracleClient, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string System = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemCore = "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemNumerics = "System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemRuntimeRemoting = "System.Runtime.Remoting, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemThreadingTasksDataflow = "System.Threading.Tasks.Dataflow, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWindowsForms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemXml = "System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string MicrosoftPublicKey = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyToken = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyFull = "002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293";

	internal const string SharedLibPublicKey = "31bf3856ad364e35";

	internal const string SharedLibPublicKeyToken = "31bf3856ad364e35";

	internal const string SharedLibPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9";

	internal const string SystemComponentModelDataAnnotations = "System.ComponentModel.DataAnnotations, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemConfiguration = "System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemConfigurationInstall = "System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDeployment = "System.Deployment, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDesign = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDirectoryServices = "System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawingDesign = "System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemEnterpriseServices = "System.EnterpriseServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemManagement = "System.Management, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemMessaging = "System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemNetHttp = "System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemNetHttpWebRequest = "System.Net.Http.WebRequest, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemRuntimeSerializationFormattersSoap = "System.Runtime.Serialization.Formatters.Soap, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemRuntimeWindowsRuntime = "System.Runtime.WindowsRuntime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemRuntimeWindowsRuntimeUIXaml = "System.Runtime.WindowsRuntimeUIXaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemSecurity = "System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemServiceModelWeb = "System.ServiceModel.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemServiceProcess = "System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWeb = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebAbstractions = "System.Web.Abstractions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebDynamicData = "System.Web.DynamicData, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebDynamicDataDesign = "System.Web.DynamicData.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebEntityDesign = "System.Web.Entity.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWebExtensions = "System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebExtensionsDesign = "System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebMobile = "System.Web.Mobile, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRegularExpressions = "System.Web.RegularExpressions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRouting = "System.Web.Routing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebServices = "System.Web.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string WindowsBase = "WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string MicrosoftVisualStudio = "Microsoft.VisualStudio, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWindowsForms = "Microsoft.VisualStudio.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string VJSharpCodeProvider = "VJSharpCodeProvider, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string ASPBrowserCapsPublicKey = "b7bd7678b977bd8f";

	internal const string ASPBrowserCapsFactory = "ASP.BrowserCapsFactory, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b7bd7678b977bd8f";

	internal const string MicrosoftVSDesigner = "Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWeb = "Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftWebDesign = "Microsoft.Web.Design.Client, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVSDesignerMobile = "Microsoft.VSDesigner.Mobile, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftJScript = "Microsoft.JScript, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
}
namespace System.Management
{
	/// <summary>Describes the possible text formats that can be used with <see cref="M:System.Management.ManagementBaseObject.GetText(System.Management.TextFormat)" />.</summary>
	public enum TextFormat
	{
		/// <summary>Managed Object Format</summary>
		Mof,
		/// <summary>XML DTD that corresponds to CIM DTD version 2.0.</summary>
		CimDtd20,
		/// <summary>XML WMI DTD that corresponds to CIM DTD version 2.0. Using this value enables a few WMI-specific extensions, like embedded objects.</summary>
		WmiDtd20
	}
	/// <summary>Describes the possible CIM types for properties, qualifiers, or method parameters.</summary>
	public enum CimType
	{
		/// <summary>A null value.</summary>
		None = 0,
		/// <summary>A signed 8-bit integer. This value maps to the <see cref="T:System.SByte" /> type.</summary>
		SInt8 = 16,
		/// <summary>An unsigned 8-bit integer. This value maps to the <see cref="T:System.Byte" /> type.</summary>
		UInt8 = 17,
		/// <summary>A signed 16-bit integer. This value maps to the <see cref="T:System.Int16" /> type.</summary>
		SInt16 = 2,
		/// <summary>An unsigned 16-bit integer. This value maps to the <see cref="T:System.UInt16" /> type.</summary>
		UInt16 = 18,
		/// <summary>A signed 32-bit integer. This value maps to the <see cref="T:System.Int32" /> type.</summary>
		SInt32 = 3,
		/// <summary>An unsigned 32-bit integer. This value maps to the <see cref="T:System.UInt32" /> type.</summary>
		UInt32 = 19,
		/// <summary>A signed 64-bit integer. This value maps to the <see cref="T:System.Int64" /> type.</summary>
		SInt64 = 20,
		/// <summary>An unsigned 64-bit integer. This value maps to the <see cref="T:System.UInt64" /> type.</summary>
		UInt64 = 21,
		/// <summary>A floating-point 32-bit number. This value maps to the <see cref="T:System.Single" /> type.</summary>
		Real32 = 4,
		/// <summary>A floating point 64-bit number. This value maps to the <see cref="T:System.Double" /> type.</summary>
		Real64 = 5,
		/// <summary>A Boolean. This value maps to the <see cref="T:System.Boolean" /> type.</summary>
		Boolean = 11,
		/// <summary>A string. This value maps to the <see cref="T:System.String" /> type.</summary>
		String = 8,
		/// <summary>A date or time value, represented in a string in DMTF date/time format: yyyymmddHHMMSS.mmmmmmsUUU, where yyyymmdd is the date in year/month/day; HHMMSS is the time in hours/minutes/seconds; mmmmmm is the number of microseconds in 6 digits; and sUUU is a sign (+ or -) and a 3-digit UTC offset. This value maps to the <see cref="T:System.DateTime" /> type.</summary>
		DateTime = 101,
		/// <summary>A reference to another object. This is represented by a string containing the path to the referenced object. This value maps to the <see cref="T:System.Int16" /> type.</summary>
		Reference = 102,
		/// <summary>A 16-bit character. This value maps to the <see cref="T:System.Char" /> type.</summary>
		Char16 = 103,
		/// <summary>An embedded object. Note that embedded objects differ from references in that the embedded object does not have a path and its lifetime is identical to the lifetime of the containing object. This value maps to the <see cref="T:System.Object" /> type.</summary>
		Object = 13
	}
	/// <summary>Describes the object comparison modes that can be used with <see cref="M:System.Management.ManagementBaseObject.CompareTo(System.Management.ManagementBaseObject,System.Management.ComparisonSettings)" />. Note that these values may be combined.</summary>
	[Flags]
	public enum ComparisonSettings
	{
		/// <summary>A mode that compares all elements of the compared objects. Value: 0.</summary>
		IncludeAll = 0,
		/// <summary>A mode that compares the objects, ignoring qualifiers. Value: 1.</summary>
		IgnoreQualifiers = 1,
		/// <summary>A mode that ignores the source of the objects, namely the server and the namespace they came from, in comparison to other objects. Value: 2.</summary>
		IgnoreObjectSource = 2,
		/// <summary>A mode that ignores the default values of properties. This value is only meaningful when comparing classes. Value: 4.</summary>
		IgnoreDefaultValues = 4,
		/// <summary>A mode that assumes that the objects being compared are instances of the same class. Consequently, this value causes comparison of instance-related information only. Use this flag to optimize performance. If the objects are not of the same class, the results are undefined. Value: 8.</summary>
		IgnoreClass = 8,
		/// <summary>A mode that compares string values in a case-insensitive manner. This applies to strings and to qualifier values. Property and qualifier names are always compared in a case-insensitive manner whether this flag is specified or not. Value: 16.</summary>
		IgnoreCase = 0x10,
		/// <summary>A mode that ignores qualifier flavors. This flag still takes qualifier values into account, but ignores flavor distinctions such as propagation rules and override restrictions. Value: 32.</summary>
		IgnoreFlavor = 0x20
	}
	internal enum QualifierType
	{
		ObjectQualifier,
		PropertyQualifier,
		MethodQualifier
	}
	/// <summary>Contains the basic elements of a management object. It serves as a base class to more specific management object classes.</summary>
	[Serializable]
	[ToolboxItem(false)]
	public class ManagementBaseObject : Component, ICloneable, ISerializable
	{
		private static WbemContext lockOnFastProx = (WMICapabilities.IsWindowsXPOrHigher() ? null : new WbemContext());

		internal IWbemClassObjectFreeThreaded _wbemObject;

		private PropertyDataCollection properties;

		private PropertyDataCollection systemProperties;

		private QualifierDataCollection qualifiers;

		internal IWbemClassObjectFreeThreaded wbemObject
		{
			get
			{
				if (_wbemObject == null)
				{
					Initialize(getObject: true);
				}
				return _wbemObject;
			}
			set
			{
				_wbemObject = value;
			}
		}

		/// <summary>Gets a collection of <see cref="T:System.Management.PropertyData" /> objects describing the properties of the management object.</summary>
		/// <returns>A collection that holds the properties for the management object.</returns>
		public virtual PropertyDataCollection Properties
		{
			get
			{
				Initialize(getObject: true);
				if (properties == null)
				{
					properties = new PropertyDataCollection(this, isSystem: false);
				}
				return properties;
			}
		}

		/// <summary>Gets  the collection of WMI system properties of the management object (for example, the class name, server, and namespace). WMI system property names begin with "__".</summary>
		/// <returns>A collection that contains the system properties for a management object.</returns>
		public virtual PropertyDataCollection SystemProperties
		{
			get
			{
				Initialize(getObject: false);
				if (systemProperties == null)
				{
					systemProperties = new PropertyDataCollection(this, isSystem: true);
				}
				return systemProperties;
			}
		}

		/// <summary>Gets the collection of <see cref="T:System.Management.QualifierData" /> objects defined on the management object. Each element in the collection holds information such as the qualifier name, value, and flavor.</summary>
		/// <returns>A collection that holds the qualifiers for the management object.</returns>
		public virtual QualifierDataCollection Qualifiers
		{
			get
			{
				Initialize(getObject: true);
				if (qualifiers == null)
				{
					qualifiers = new QualifierDataCollection(this);
				}
				return qualifiers;
			}
		}

		/// <summary>Gets the path to the management object's class.</summary>
		/// <returns>The class path to the management object's class.</returns>
		public virtual ManagementPath ClassPath
		{
			get
			{
				object pVal = null;
				object pVal2 = null;
				object pVal3 = null;
				int pType = 0;
				int plFlavor = 0;
				int num = 0;
				num = wbemObject.Get_("__SERVER", 0, ref pVal, ref pType, ref plFlavor);
				if (num == 0)
				{
					num = wbemObject.Get_("__NAMESPACE", 0, ref pVal2, ref pType, ref plFlavor);
					if (num == 0)
					{
						num = wbemObject.Get_("__CLASS", 0, ref pVal3, ref pType, ref plFlavor);
					}
				}
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				ManagementPath managementPath = new ManagementPath();
				managementPath.Server = string.Empty;
				managementPath.NamespacePath = string.Empty;
				managementPath.ClassName = string.Empty;
				try
				{
					managementPath.Server = (string)((pVal is DBNull) ? "" : pVal);
					managementPath.NamespacePath = (string)((pVal2 is DBNull) ? "" : pVal2);
					managementPath.ClassName = (string)((pVal3 is DBNull) ? "" : pVal3);
					return managementPath;
				}
				catch
				{
					return managementPath;
				}
			}
		}

		/// <summary>Gets access to property values through [] notation. This property is the indexer for the <see cref="T:System.Management.ManagementBaseObject" /> class. You can use the default indexed properties defined by a type, but you cannot explicitly define your own. However, specifying the expando attribute on a class automatically provides a default indexed property whose type is Object and whose index type is String.</summary>
		/// <param name="propertyName">The name of the property of interest.</param>
		/// <returns>The management object for a specific class property.</returns>
		public object this[string propertyName]
		{
			get
			{
				return GetPropertyValue(propertyName);
			}
			set
			{
				Initialize(getObject: true);
				try
				{
					SetPropertyValue(propertyName, value);
				}
				catch (COMException e)
				{
					ManagementException.ThrowWithExtendedInfo(e);
				}
			}
		}

		internal string ClassName
		{
			get
			{
				object pVal = null;
				int pType = 0;
				int plFlavor = 0;
				int num = 0;
				num = wbemObject.Get_("__CLASS", 0, ref pVal, ref pType, ref plFlavor);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				if (pVal is DBNull)
				{
					return string.Empty;
				}
				return (string)pVal;
			}
		}

		internal bool IsClass => _IsClass(wbemObject);

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementBaseObject" /> class that is serializable.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" /> ) for this serialization.</param>
		protected ManagementBaseObject(SerializationInfo info, StreamingContext context)
		{
			_wbemObject = info.GetValue("wbemObject", typeof(IWbemClassObjectFreeThreaded)) as IWbemClassObjectFreeThreaded;
			if (_wbemObject == null)
			{
				throw new SerializationException();
			}
			properties = null;
			systemProperties = null;
			qualifiers = null;
		}

		/// <summary>Releases the unmanaged resources used by the ManagementBaseObject.</summary>
		public new void Dispose()
		{
			if (_wbemObject != null)
			{
				_wbemObject.Dispose();
				_wbemObject = null;
			}
			base.Dispose();
			GC.SuppressFinalize(this);
		}

		/// <summary>Provides the internal WMI object represented by a <see cref="T:System.Management.ManagementObject" />.</summary>
		/// <param name="managementObject">The <see cref="T:System.Management.ManagementBaseObject" /> that references the requested WMI object.</param>
		/// <returns>An <see cref="T:System.IntPtr" /> representing the internal WMI object.</returns>
		public static explicit operator IntPtr(ManagementBaseObject managementObject)
		{
			if (managementObject == null)
			{
				return IntPtr.Zero;
			}
			return managementObject.wbemObject;
		}

		/// <summary>Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and returns the data needed to serialize the <see cref="T:System.Management.ManagementBaseObject" />.</summary>
		/// <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> containing the information required to serialize the <see cref="T:System.Management.ManagementBaseObject" />.</param>
		/// <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> containing the source and destination of the serialized stream associated with the <see cref="T:System.Management.ManagementBaseObject" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="info" /> is <see langword="null" />.</exception>
		[SecurityPermission(SecurityAction.LinkDemand, SerializationFormatter = true)]
		void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
		{
			info.AddValue("wbemObject", wbemObject, typeof(IWbemClassObjectFreeThreaded));
			info.AssemblyName = typeof(ManagementBaseObject).Assembly.FullName;
			info.FullTypeName = typeof(ManagementBaseObject).ToString();
		}

		/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data necessary to deserialize the field represented by this instance.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" /> ) for this serialization.</param>
		protected virtual void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			((ISerializable)this).GetObjectData(info, context);
		}

		internal static ManagementBaseObject GetBaseObject(IWbemClassObjectFreeThreaded wbemObject, ManagementScope scope)
		{
			ManagementBaseObject managementBaseObject = null;
			if (_IsClass(wbemObject))
			{
				return ManagementClass.GetManagementClass(wbemObject, scope);
			}
			return ManagementObject.GetManagementObject(wbemObject, scope);
		}

		internal ManagementBaseObject(IWbemClassObjectFreeThreaded wbemObject)
		{
			this.wbemObject = wbemObject;
			properties = null;
			systemProperties = null;
			qualifiers = null;
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The new cloned object.</returns>
		public virtual object Clone()
		{
			IWbemClassObjectFreeThreaded ppCopy = null;
			int num = wbemObject.Clone_(out ppCopy);
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return new ManagementBaseObject(ppCopy);
		}

		internal virtual void Initialize(bool getObject)
		{
		}

		/// <summary>Gets an equivalent accessor to a property's value.</summary>
		/// <param name="propertyName">The name of the property of interest.</param>
		/// <returns>The value of the specified property.</returns>
		public object GetPropertyValue(string propertyName)
		{
			if (propertyName == null)
			{
				throw new ArgumentNullException("propertyName");
			}
			if (propertyName.StartsWith("__", StringComparison.Ordinal))
			{
				return SystemProperties[propertyName].Value;
			}
			return Properties[propertyName].Value;
		}

		/// <summary>Gets the value of the specified qualifier.</summary>
		/// <param name="qualifierName">The name of the qualifier of interest.</param>
		/// <returns>The value of the specified qualifier.</returns>
		public object GetQualifierValue(string qualifierName)
		{
			return Qualifiers[qualifierName].Value;
		}

		/// <summary>Sets the value of the named qualifier.</summary>
		/// <param name="qualifierName">The name of the qualifier to set. This parameter cannot be null.</param>
		/// <param name="qualifierValue">The value to set.</param>
		public void SetQualifierValue(string qualifierName, object qualifierValue)
		{
			Qualifiers[qualifierName].Value = qualifierValue;
		}

		/// <summary>Returns the value of the specified property qualifier.</summary>
		/// <param name="propertyName">The name of the property to which the qualifier belongs.</param>
		/// <param name="qualifierName">The name of the property qualifier of interest.</param>
		/// <returns>The value of the specified qualifier.</returns>
		public object GetPropertyQualifierValue(string propertyName, string qualifierName)
		{
			return Properties[propertyName].Qualifiers[qualifierName].Value;
		}

		/// <summary>Sets the value of the specified property qualifier.</summary>
		/// <param name="propertyName">The name of the property to which the qualifier belongs.</param>
		/// <param name="qualifierName">The name of the property qualifier of interest.</param>
		/// <param name="qualifierValue">The new value for the qualifier.</param>
		public void SetPropertyQualifierValue(string propertyName, string qualifierName, object qualifierValue)
		{
			Properties[propertyName].Qualifiers[qualifierName].Value = qualifierValue;
		}

		/// <summary>Returns a textual representation of the object in the specified format.</summary>
		/// <param name="format">The requested textual format.</param>
		/// <returns>The textual representation of the object in the specified format.</returns>
		public string GetText(TextFormat format)
		{
			string pstrObjectText = null;
			int num = 0;
			switch (format)
			{
			case TextFormat.Mof:
				num = wbemObject.GetObjectText_(0, out pstrObjectText);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				return pstrObjectText;
			case TextFormat.CimDtd20:
			case TextFormat.WmiDtd20:
			{
				IWbemObjectTextSrc wbemObjectTextSrc = (IWbemObjectTextSrc)new WbemObjectTextSrc();
				IWbemContext wbemContext = (IWbemContext)new WbemContext();
				object pValue = true;
				wbemContext.SetValue_("IncludeQualifiers", 0, ref pValue);
				wbemContext.SetValue_("IncludeClassOrigin", 0, ref pValue);
				if (wbemObjectTextSrc != null)
				{
					num = wbemObjectTextSrc.GetText_(0, (IWbemClassObject_DoNotMarshal)Marshal.GetObjectForIUnknown(wbemObject), (uint)format, wbemContext, out pstrObjectText);
					if (num < 0)
					{
						if ((num & 0xFFFFF000u) == 2147749888u)
						{
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
						}
						else
						{
							Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
						}
					}
				}
				return pstrObjectText;
			}
			default:
				return null;
			}
		}

		/// <summary>Compares two management objects.</summary>
		/// <param name="obj">An object to compare with this instance.</param>
		/// <returns>
		///   <see langword="true" /> if this is an instance of <see cref="T:System.Management.ManagementBaseObject" /> and represents the same object as this instance; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			bool flag = false;
			try
			{
				if (obj is ManagementBaseObject)
				{
					return CompareTo((ManagementBaseObject)obj, ComparisonSettings.IncludeAll);
				}
				return false;
			}
			catch (ManagementException ex)
			{
				if (ex.ErrorCode == ManagementStatus.NotFound && this is ManagementObject && obj is ManagementObject)
				{
					int num = string.Compare(((ManagementObject)this).Path.Path, ((ManagementObject)obj).Path.Path, StringComparison.OrdinalIgnoreCase);
					return num == 0;
				}
				return false;
			}
			catch
			{
				return false;
			}
		}

		/// <summary>Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table.</summary>
		/// <returns>A hash code for the current object.</returns>
		public override int GetHashCode()
		{
			int num = 0;
			try
			{
				return GetText(TextFormat.Mof).GetHashCode();
			}
			catch (ManagementException)
			{
				return string.Empty.GetHashCode();
			}
			catch (COMException)
			{
				return string.Empty.GetHashCode();
			}
		}

		/// <summary>Compares this object to another, based on specified options.</summary>
		/// <param name="otherObject">The object to which to compare this object.</param>
		/// <param name="settings">Options on how to compare the objects.</param>
		/// <returns>
		///   <see langword="true" /> if the objects compared are equal according to the given options; otherwise, <see langword="false" />.</returns>
		public bool CompareTo(ManagementBaseObject otherObject, ComparisonSettings settings)
		{
			if (otherObject == null)
			{
				throw new ArgumentNullException("otherObject");
			}
			bool result = false;
			if (wbemObject != null)
			{
				int num = 0;
				num = wbemObject.CompareTo_((int)settings, otherObject.wbemObject);
				if (262147 == num)
				{
					result = false;
				}
				else if (num == 0)
				{
					result = true;
				}
				else if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else if (num < 0)
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return result;
		}

		private static bool _IsClass(IWbemClassObjectFreeThreaded wbemObject)
		{
			object pVal = null;
			int pType = 0;
			int plFlavor = 0;
			int num = wbemObject.Get_("__GENUS", 0, ref pVal, ref pType, ref plFlavor);
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return (int)pVal == 1;
		}

		/// <summary>Sets the value of the named property.</summary>
		/// <param name="propertyName">The name of the property to be changed.</param>
		/// <param name="propertyValue">The new value for this property.</param>
		public void SetPropertyValue(string propertyName, object propertyValue)
		{
			if (propertyName == null)
			{
				throw new ArgumentNullException("propertyName");
			}
			if (propertyName.StartsWith("__", StringComparison.Ordinal))
			{
				SystemProperties[propertyName].Value = propertyValue;
			}
			else
			{
				Properties[propertyName].Value = propertyValue;
			}
		}
	}
	/// <summary>Represents a Common Information Model (CIM) management class. A management class is a WMI class such as Win32_LogicalDisk, which can represent a disk drive, and Win32_Process, which represents a process such as Notepad.exe. The members of this class enable you to access WMI data using a specific WMI class path. For more information, see "Win32 Classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</summary>
	[Serializable]
	public class ManagementClass : ManagementObject
	{
		private MethodDataCollection methods;

		/// <summary>Gets or sets the path of the WMI class to which the <see cref="T:System.Management.ManagementClass" /> object is bound.</summary>
		/// <returns>The path of the object's class.</returns>
		public override ManagementPath Path
		{
			get
			{
				return base.Path;
			}
			set
			{
				if (value == null || value.IsClass || value.IsEmpty)
				{
					base.Path = value;
					return;
				}
				throw new ArgumentOutOfRangeException("value");
			}
		}

		/// <summary>Gets an array containing all WMI classes in the inheritance hierarchy from this class to the top of the hierarchy.</summary>
		/// <returns>A string collection containing the names of all WMI classes in the inheritance hierarchy of this class.</returns>
		public StringCollection Derivation
		{
			get
			{
				StringCollection stringCollection = new StringCollection();
				int pType = 0;
				int plFlavor = 0;
				object pVal = null;
				int num = base.wbemObject.Get_("__DERIVATION", 0, ref pVal, ref pType, ref plFlavor);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				if (pVal != null)
				{
					stringCollection.AddRange((string[])pVal);
				}
				return stringCollection;
			}
		}

		/// <summary>Gets or sets a collection of <see cref="T:System.Management.MethodData" /> objects that represent the methods defined in the WMI class.</summary>
		/// <returns>A <see cref="T:System.Management.MethodDataCollection" /> representing the methods defined in the WMI class.</returns>
		public MethodDataCollection Methods
		{
			get
			{
				Initialize(getObject: true);
				if (methods == null)
				{
					methods = new MethodDataCollection(this);
				}
				return methods;
			}
		}

		/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data necessary to deserialize the field represented by this instance.</summary>
		/// <param name="info">The object to be populated with serialization information.</param>
		/// <param name="context">The location where serialized data will be stored and retrieved.</param>
		protected override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
		}

		internal static ManagementClass GetManagementClass(IWbemClassObjectFreeThreaded wbemObject, ManagementClass mgObj)
		{
			ManagementClass managementClass = new ManagementClass();
			managementClass.wbemObject = wbemObject;
			if (mgObj != null)
			{
				managementClass.scope = ManagementScope._Clone(mgObj.scope);
				ManagementPath managementPath = mgObj.Path;
				if (managementPath != null)
				{
					managementClass.path = ManagementPath._Clone(managementPath);
				}
				object pVal = null;
				int pType = 0;
				int num = wbemObject.Get_("__CLASS", 0, ref pVal, ref pType, ref pType);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				if (pVal != DBNull.Value)
				{
					managementClass.path.internalClassName = (string)pVal;
				}
				ObjectGetOptions objectGetOptions = mgObj.Options;
				if (objectGetOptions != null)
				{
					managementClass.options = ObjectGetOptions._Clone(objectGetOptions);
				}
			}
			return managementClass;
		}

		internal static ManagementClass GetManagementClass(IWbemClassObjectFreeThreaded wbemObject, ManagementScope scope)
		{
			ManagementClass managementClass = new ManagementClass();
			managementClass.path = new ManagementPath(ManagementPath.GetManagementPath(wbemObject));
			if (scope != null)
			{
				managementClass.scope = ManagementScope._Clone(scope);
			}
			managementClass.wbemObject = wbemObject;
			return managementClass;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementClass" /> class. This is the default constructor.</summary>
		public ManagementClass()
			: this((ManagementScope)null, (ManagementPath)null, (ObjectGetOptions)null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementClass" /> class. The class represents a Common Information Model (CIM) management class from WMI such as Win32_LogicalDisk, which can represent a disk drive, and Win32_Process, which represents a process such as Notepad.exe. For more information, see "Win32 Classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</summary>
		/// <param name="path">A <see cref="T:System.Management.ManagementPath" /> specifying the WMI class to which to bind. The parameter must specify a WMI class path. The class represents a CIM management class from WMI. CIM classes represent management information including hardware, software, processes, and so on. For more information about the CIM classes available in Windows, see "Win32 classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</param>
		public ManagementClass(ManagementPath path)
			: this(null, path, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementClass" /> class initialized to the given path. The class represents a Common Information Model (CIM) management class from WMI such as Win32_LogicalDisk, which can represent a disk drive, and Win32_Process, which represents a process such as Notepad.exe. For more information, see "Win32 Classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</summary>
		/// <param name="path">The path to the WMI class. The class represents a CIM management class from WMI. CIM classes represent management information including hardware, software, processes, and so on. For more information about the CIM classes available in Windows, see "Win32 classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</param>
		public ManagementClass(string path)
			: this(null, new ManagementPath(path), null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementClass" /> class initialized to the given WMI class path using the specified options. The class represents a Common Information Model (CIM) management class from WMI such as Win32_LogicalDisk, which can represent a disk drive, and Win32_Process, which represents a process such as Notepad.exe. For more information, see "Win32 Classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</summary>
		/// <param name="path">A <see cref="T:System.Management.ManagementPath" /> instance representing the WMI class path. The class represents a CIM management class from WMI. CIM classes represent management information including hardware, software, processes, and so on. For more information about the CIM classes available in Windows, see "Win32 classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</param>
		/// <param name="options">An <see cref="T:System.Management.ObjectGetOptions" /> representing the options to use when retrieving this class.</param>
		public ManagementClass(ManagementPath path, ObjectGetOptions options)
			: this(null, path, options)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementClass" /> class initialized to the given WMI class path using the specified options. The class represents a Common Information Model (CIM) management class from WMI such as Win32_LogicalDisk, which can represent a disk drive, and Win32_Process, which represents a process such as Notepad.exe. For more information, see "Win32 Classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</summary>
		/// <param name="path">The path to the WMI class. The class represents a CIM management class from WMI. CIM classes represent management information including hardware, software, processes, and so on. For more information about the CIM classes available in Windows, see "Win32 classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</param>
		/// <param name="options">An <see cref="T:System.Management.ObjectGetOptions" /> representing the options to use when retrieving the WMI class.</param>
		public ManagementClass(string path, ObjectGetOptions options)
			: this(null, new ManagementPath(path), options)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementClass" /> class for the specified WMI class in the specified scope and with the specified options. The class represents a Common Information Model (CIM) management class from WMI such as Win32_LogicalDisk, which can represent a disk drive, and Win32_Process, which represents a process such as Notepad.exe. For more information, see "Win32 Classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</summary>
		/// <param name="scope">A <see cref="T:System.Management.ManagementScope" /> that specifies the scope (server and namespace) where the WMI class resides.</param>
		/// <param name="path">A <see cref="T:System.Management.ManagementPath" /> that represents the path to the WMI class in the specified scope. The class represents a CIM management class from WMI. CIM classes represent management information including hardware, software, processes, and so on. For more information about the CIM classes available in Windows, see "Win32 classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</param>
		/// <param name="options">An <see cref="T:System.Management.ObjectGetOptions" /> that specifies the options to use when retrieving the WMI class.</param>
		public ManagementClass(ManagementScope scope, ManagementPath path, ObjectGetOptions options)
			: base(scope, path, options)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementClass" /> class for the specified WMI class, in the specified scope, and with the specified options. The class represents a Common Information Model (CIM) management class from WMI such as Win32_LogicalDisk, which can represent a disk drive, and Win32_Process, which represents a process such as Notepad.exe. For more information, see "Win32 Classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</summary>
		/// <param name="scope">The scope in which the WMI class resides.</param>
		/// <param name="path">The path to the WMI class within the specified scope. The class represents a CIM management class from WMI. CIM classes represent management information including hardware, software, processes, and so on. For more information about the CIM classes available in Windows, see "Win32 classes" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</param>
		/// <param name="options">An <see cref="T:System.Management.ObjectGetOptions" /> that specifies the options to use when retrieving the WMI class.</param>
		public ManagementClass(string scope, string path, ObjectGetOptions options)
			: base(new ManagementScope(scope), new ManagementPath(path), options)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementClass" /> class from the specified instances of the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and <see cref="T:System.Runtime.Serialization.StreamingContext" /> classes.</summary>
		/// <param name="info">An instance of the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> class containing the information required to serialize the new <see cref="T:System.Management.ManagementClass" />.</param>
		/// <param name="context">An instance of the <see cref="T:System.Runtime.Serialization.StreamingContext" /> class containing the source of the serialized stream associated with the new <see cref="T:System.Management.ManagementClass" />.</param>
		protected ManagementClass(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		/// <summary>Returns the collection of all instances of the class.</summary>
		/// <returns>A collection of the <see cref="T:System.Management.ManagementObject" /> objects representing the instances of the class.</returns>
		public ManagementObjectCollection GetInstances()
		{
			return GetInstances((EnumerationOptions)null);
		}

		/// <summary>Returns the collection of all instances of the class using the specified options.</summary>
		/// <param name="options">The additional operation options.</param>
		/// <returns>A collection of the <see cref="T:System.Management.ManagementObject" /> objects representing the instances of the class, according to the specified options.</returns>
		public ManagementObjectCollection GetInstances(EnumerationOptions options)
		{
			if (Path == null || Path.Path == null || Path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			Initialize(getObject: false);
			IEnumWbemClassObject ppEnum = null;
			EnumerationOptions enumerationOptions = ((options == null) ? new EnumerationOptions() : ((EnumerationOptions)options.Clone()));
			enumerationOptions.EnsureLocatable = false;
			enumerationOptions.PrototypeOnly = false;
			SecurityHandler securityHandler = null;
			int num = 0;
			try
			{
				securityHandler = base.Scope.GetSecurityHandler();
				num = scope.GetSecuredIWbemServicesHandler(base.Scope.GetIWbemServices()).CreateInstanceEnum_(base.ClassName, enumerationOptions.Flags, enumerationOptions.GetContext(), ref ppEnum);
			}
			finally
			{
				securityHandler?.Reset();
			}
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return new ManagementObjectCollection(base.Scope, enumerationOptions, ppEnum);
		}

		/// <summary>Returns the collection of all instances of the class, asynchronously.</summary>
		/// <param name="watcher">The object to handle the asynchronous operation's progress.</param>
		public void GetInstances(ManagementOperationObserver watcher)
		{
			GetInstances(watcher, null);
		}

		/// <summary>Returns the collection of all instances of the class, asynchronously, using the specified options.</summary>
		/// <param name="watcher">The object to handle the asynchronous operation's progress.</param>
		/// <param name="options">The specified additional options for getting the instances.</param>
		public void GetInstances(ManagementOperationObserver watcher, EnumerationOptions options)
		{
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			if (Path == null || Path.Path == null || Path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			Initialize(getObject: false);
			EnumerationOptions enumerationOptions = ((options == null) ? new EnumerationOptions() : ((EnumerationOptions)options.Clone()));
			enumerationOptions.EnsureLocatable = false;
			enumerationOptions.PrototypeOnly = false;
			enumerationOptions.ReturnImmediately = false;
			if (watcher.HaveListenersForProgress)
			{
				enumerationOptions.SendStatus = true;
			}
			WmiEventSink newSink = watcher.GetNewSink(base.Scope, enumerationOptions.Context);
			SecurityHandler securityHandler = null;
			int num = 0;
			securityHandler = base.Scope.GetSecurityHandler();
			num = scope.GetSecuredIWbemServicesHandler(base.Scope.GetIWbemServices()).CreateInstanceEnumAsync_(base.ClassName, enumerationOptions.Flags, enumerationOptions.GetContext(), newSink.Stub);
			securityHandler?.Reset();
			if (num < 0)
			{
				watcher.RemoveSink(newSink);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Returns the collection of all subclasses for the class.</summary>
		/// <returns>A collection of the <see cref="T:System.Management.ManagementObject" /> objects that represent the subclasses of the WMI class.</returns>
		public ManagementObjectCollection GetSubclasses()
		{
			return GetSubclasses((EnumerationOptions)null);
		}

		/// <summary>Retrieves the subclasses of the class using the specified options.</summary>
		/// <param name="options">The specified additional options for retrieving subclasses of the class.</param>
		/// <returns>A collection of the <see cref="T:System.Management.ManagementObject" /> objects representing the subclasses of the WMI class, according to the specified options.</returns>
		public ManagementObjectCollection GetSubclasses(EnumerationOptions options)
		{
			if (Path == null)
			{
				throw new InvalidOperationException();
			}
			Initialize(getObject: false);
			IEnumWbemClassObject ppEnum = null;
			EnumerationOptions enumerationOptions = ((options == null) ? new EnumerationOptions() : ((EnumerationOptions)options.Clone()));
			enumerationOptions.EnsureLocatable = false;
			enumerationOptions.PrototypeOnly = false;
			SecurityHandler securityHandler = null;
			int num = 0;
			try
			{
				securityHandler = base.Scope.GetSecurityHandler();
				num = scope.GetSecuredIWbemServicesHandler(base.Scope.GetIWbemServices()).CreateClassEnum_(base.ClassName, enumerationOptions.Flags, enumerationOptions.GetContext(), ref ppEnum);
			}
			finally
			{
				securityHandler?.Reset();
			}
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return new ManagementObjectCollection(base.Scope, enumerationOptions, ppEnum);
		}

		/// <summary>Returns the collection of all classes derived from this class, asynchronously.</summary>
		/// <param name="watcher">The object to handle the asynchronous operation's progress.</param>
		public void GetSubclasses(ManagementOperationObserver watcher)
		{
			GetSubclasses(watcher, null);
		}

		/// <summary>Retrieves all classes derived from this class, asynchronously, using the specified options.</summary>
		/// <param name="watcher">The object to handle the asynchronous operation's progress.</param>
		/// <param name="options">The specified additional options to use in the derived class retrieval.</param>
		public void GetSubclasses(ManagementOperationObserver watcher, EnumerationOptions options)
		{
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			if (Path == null)
			{
				throw new InvalidOperationException();
			}
			Initialize(getObject: false);
			EnumerationOptions enumerationOptions = ((options == null) ? new EnumerationOptions() : ((EnumerationOptions)options.Clone()));
			enumerationOptions.EnsureLocatable = false;
			enumerationOptions.PrototypeOnly = false;
			enumerationOptions.ReturnImmediately = false;
			if (watcher.HaveListenersForProgress)
			{
				enumerationOptions.SendStatus = true;
			}
			WmiEventSink newSink = watcher.GetNewSink(base.Scope, enumerationOptions.Context);
			SecurityHandler securityHandler = null;
			int num = 0;
			securityHandler = base.Scope.GetSecurityHandler();
			num = scope.GetSecuredIWbemServicesHandler(base.Scope.GetIWbemServices()).CreateClassEnumAsync_(base.ClassName, enumerationOptions.Flags, enumerationOptions.GetContext(), newSink.Stub);
			securityHandler?.Reset();
			if (num < 0)
			{
				watcher.RemoveSink(newSink);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Derives a new class from this class.</summary>
		/// <param name="newClassName">The name of the new class to be derived.</param>
		/// <returns>A new <see cref="T:System.Management.ManagementClass" /> that represents a new WMI class derived from the original class.</returns>
		public ManagementClass Derive(string newClassName)
		{
			ManagementClass result = null;
			if (newClassName == null)
			{
				throw new ArgumentNullException("newClassName");
			}
			ManagementPath managementPath = new ManagementPath();
			try
			{
				managementPath.ClassName = newClassName;
			}
			catch
			{
				throw new ArgumentOutOfRangeException("newClassName");
			}
			if (!managementPath.IsClass)
			{
				throw new ArgumentOutOfRangeException("newClassName");
			}
			if (base.PutButNotGot)
			{
				Get();
				base.PutButNotGot = false;
			}
			IWbemClassObjectFreeThreaded ppNewClass = null;
			int num = base.wbemObject.SpawnDerivedClass_(0, out ppNewClass);
			if (num >= 0)
			{
				object pVal = newClassName;
				num = ppNewClass.Put_("__CLASS", 0, ref pVal, 0);
				if (num >= 0)
				{
					result = GetManagementClass(ppNewClass, this);
				}
			}
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return result;
		}

		/// <summary>Initializes a new instance of the WMI class.</summary>
		/// <returns>A <see cref="T:System.Management.ManagementObject" /> that represents a new instance of the WMI class.</returns>
		public ManagementObject CreateInstance()
		{
			ManagementObject result = null;
			if (base.PutButNotGot)
			{
				Get();
				base.PutButNotGot = false;
			}
			IWbemClassObjectFreeThreaded ppNewInstance = null;
			int num = base.wbemObject.SpawnInstance_(0, out ppNewInstance);
			if (num >= 0)
			{
				result = ManagementObject.GetManagementObject(ppNewInstance, base.Scope);
			}
			else if ((num & 0xFFFFF000u) == 2147749888u)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
			}
			else
			{
				Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
			}
			return result;
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The cloned object.</returns>
		public override object Clone()
		{
			IWbemClassObjectFreeThreaded ppCopy = null;
			int num = base.wbemObject.Clone_(out ppCopy);
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return GetManagementClass(ppCopy, this);
		}

		/// <summary>Retrieves classes related to the WMI class.</summary>
		/// <returns>A collection of the <see cref="T:System.Management.ManagementClass" /> or <see cref="T:System.Management.ManagementObject" /> objects that represents WMI classes or instances related to the WMI class.</returns>
		public ManagementObjectCollection GetRelatedClasses()
		{
			return GetRelatedClasses((string)null);
		}

		/// <summary>Retrieves classes related to the WMI class.</summary>
		/// <param name="relatedClass">The class from which resulting classes have to be derived.</param>
		/// <returns>A collection of classes related to this class.</returns>
		public ManagementObjectCollection GetRelatedClasses(string relatedClass)
		{
			return GetRelatedClasses(relatedClass, null, null, null, null, null, null);
		}

		/// <summary>Retrieves classes related to the WMI class based on the specified options.</summary>
		/// <param name="relatedClass">The class from which resulting classes have to be derived.</param>
		/// <param name="relationshipClass">The relationship type which resulting classes must have with the source class.</param>
		/// <param name="relationshipQualifier">This qualifier must be present on the relationship.</param>
		/// <param name="relatedQualifier">This qualifier must be present on the resulting classes.</param>
		/// <param name="relatedRole">The resulting classes must have this role in the relationship.</param>
		/// <param name="thisRole">The source class must have this role in the relationship.</param>
		/// <param name="options">The options for retrieving the resulting classes.</param>
		/// <returns>A collection of classes related to this class.</returns>
		public ManagementObjectCollection GetRelatedClasses(string relatedClass, string relationshipClass, string relationshipQualifier, string relatedQualifier, string relatedRole, string thisRole, EnumerationOptions options)
		{
			if (Path == null || Path.Path == null || Path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			Initialize(getObject: false);
			IEnumWbemClassObject ppEnum = null;
			EnumerationOptions enumerationOptions = ((options != null) ? ((EnumerationOptions)options.Clone()) : new EnumerationOptions());
			enumerationOptions.EnumerateDeep = true;
			RelatedObjectQuery relatedObjectQuery = new RelatedObjectQuery(isSchemaQuery: true, Path.Path, relatedClass, relationshipClass, relatedQualifier, relationshipQualifier, relatedRole, thisRole);
			SecurityHandler securityHandler = null;
			int num = 0;
			try
			{
				securityHandler = base.Scope.GetSecurityHandler();
				num = scope.GetSecuredIWbemServicesHandler(base.Scope.GetIWbemServices()).ExecQuery_(relatedObjectQuery.QueryLanguage, relatedObjectQuery.QueryString, enumerationOptions.Flags, enumerationOptions.GetContext(), ref ppEnum);
			}
			finally
			{
				securityHandler?.Reset();
			}
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return new ManagementObjectCollection(base.Scope, enumerationOptions, ppEnum);
		}

		/// <summary>Retrieves classes related to the WMI class, asynchronously.</summary>
		/// <param name="watcher">The object to handle the asynchronous operation's progress.</param>
		public void GetRelatedClasses(ManagementOperationObserver watcher)
		{
			GetRelatedClasses(watcher, null);
		}

		/// <summary>Retrieves classes related to the WMI class, asynchronously, given the related class name.</summary>
		/// <param name="watcher">The object to handle the asynchronous operation's progress.</param>
		/// <param name="relatedClass">The name of the related class.</param>
		public void GetRelatedClasses(ManagementOperationObserver watcher, string relatedClass)
		{
			GetRelatedClasses(watcher, relatedClass, null, null, null, null, null, null);
		}

		/// <summary>Retrieves classes related to the WMI class, asynchronously, using the specified options.</summary>
		/// <param name="watcher">Handler for progress and results of the asynchronous operation.</param>
		/// <param name="relatedClass">The class from which resulting classes have to be derived.</param>
		/// <param name="relationshipClass">The relationship type which resulting classes must have with the source class.</param>
		/// <param name="relationshipQualifier">This qualifier must be present on the relationship.</param>
		/// <param name="relatedQualifier">This qualifier must be present on the resulting classes.</param>
		/// <param name="relatedRole">The resulting classes must have this role in the relationship.</param>
		/// <param name="thisRole">The source class must have this role in the relationship.</param>
		/// <param name="options">The options for retrieving the resulting classes.</param>
		public void GetRelatedClasses(ManagementOperationObserver watcher, string relatedClass, string relationshipClass, string relationshipQualifier, string relatedQualifier, string relatedRole, string thisRole, EnumerationOptions options)
		{
			if (Path == null || Path.Path == null || Path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			Initialize(getObject: true);
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			EnumerationOptions enumerationOptions = ((options != null) ? ((EnumerationOptions)options.Clone()) : new EnumerationOptions());
			enumerationOptions.EnumerateDeep = true;
			enumerationOptions.ReturnImmediately = false;
			if (watcher.HaveListenersForProgress)
			{
				enumerationOptions.SendStatus = true;
			}
			WmiEventSink newSink = watcher.GetNewSink(base.Scope, enumerationOptions.Context);
			RelatedObjectQuery relatedObjectQuery = new RelatedObjectQuery(isSchemaQuery: true, Path.Path, relatedClass, relationshipClass, relatedQualifier, relationshipQualifier, relatedRole, thisRole);
			SecurityHandler securityHandler = null;
			int num = 0;
			securityHandler = base.Scope.GetSecurityHandler();
			num = scope.GetSecuredIWbemServicesHandler(base.Scope.GetIWbemServices()).ExecQueryAsync_(relatedObjectQuery.QueryLanguage, relatedObjectQuery.QueryString, enumerationOptions.Flags, enumerationOptions.GetContext(), newSink.Stub);
			securityHandler?.Reset();
			if (num < 0)
			{
				watcher.RemoveSink(newSink);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Retrieves relationship classes that relate the class to others.</summary>
		/// <returns>A collection of association classes that relate the class to any other class.</returns>
		public ManagementObjectCollection GetRelationshipClasses()
		{
			return GetRelationshipClasses((string)null);
		}

		/// <summary>Retrieves relationship classes that relate the class to others, where the endpoint class is the specified class.</summary>
		/// <param name="relationshipClass">The endpoint class for all relationship classes returned.</param>
		/// <returns>A collection of association classes that relate the class to the specified class. For more information about relationship classes, see "ASSOCIATORS OF Statement" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</returns>
		public ManagementObjectCollection GetRelationshipClasses(string relationshipClass)
		{
			return GetRelationshipClasses(relationshipClass, null, null, null);
		}

		/// <summary>Retrieves relationship classes that relate this class to others, according to specified options.</summary>
		/// <param name="relationshipClass">All resulting relationship classes must derive from this class.</param>
		/// <param name="relationshipQualifier">Resulting relationship classes must have this qualifier.</param>
		/// <param name="thisRole">The source class must have this role in the resulting relationship classes.</param>
		/// <param name="options">Specifies options for retrieving the results.</param>
		/// <returns>A collection of association classes that relate this class to others, according to the specified options. For more information about relationship classes, see "ASSOCIATORS OF Statement" in the Windows Management Instrumentation documentation in the MSDN Library at http://msdn.microsoft.com/library.</returns>
		public ManagementObjectCollection GetRelationshipClasses(string relationshipClass, string relationshipQualifier, string thisRole, EnumerationOptions options)
		{
			if (Path == null || Path.Path == null || Path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			Initialize(getObject: false);
			IEnumWbemClassObject ppEnum = null;
			EnumerationOptions enumerationOptions = ((options != null) ? options : new EnumerationOptions());
			enumerationOptions.EnumerateDeep = true;
			RelationshipQuery relationshipQuery = new RelationshipQuery(isSchemaQuery: true, Path.Path, relationshipClass, relationshipQualifier, thisRole);
			SecurityHandler securityHandler = null;
			int num = 0;
			try
			{
				securityHandler = base.Scope.GetSecurityHandler();
				num = scope.GetSecuredIWbemServicesHandler(base.Scope.GetIWbemServices()).ExecQuery_(relationshipQuery.QueryLanguage, relationshipQuery.QueryString, enumerationOptions.Flags, enumerationOptions.GetContext(), ref ppEnum);
			}
			finally
			{
				securityHandler?.Reset();
			}
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return new ManagementObjectCollection(base.Scope, enumerationOptions, ppEnum);
		}

		/// <summary>Retrieves relationship classes that relate the class to others, asynchronously.</summary>
		/// <param name="watcher">The object to handle the asynchronous operation's progress.</param>
		public void GetRelationshipClasses(ManagementOperationObserver watcher)
		{
			GetRelationshipClasses(watcher, null);
		}

		/// <summary>Retrieves relationship classes that relate the class to the specified WMI class, asynchronously.</summary>
		/// <param name="watcher">The object to handle the asynchronous operation's progress.</param>
		/// <param name="relationshipClass">The WMI class to which all returned relationships should point.</param>
		public void GetRelationshipClasses(ManagementOperationObserver watcher, string relationshipClass)
		{
			GetRelationshipClasses(watcher, relationshipClass, null, null, null);
		}

		/// <summary>Retrieves relationship classes that relate the class according to the specified options, asynchronously.</summary>
		/// <param name="watcher">The handler for progress and results of the asynchronous operation.</param>
		/// <param name="relationshipClass">The class from which all resulting relationship classes must derive.</param>
		/// <param name="relationshipQualifier">The qualifier which the resulting relationship classes must have.</param>
		/// <param name="thisRole">The role which the source class must have in the resulting relationship classes.</param>
		/// <param name="options">The options for retrieving the results.</param>
		public void GetRelationshipClasses(ManagementOperationObserver watcher, string relationshipClass, string relationshipQualifier, string thisRole, EnumerationOptions options)
		{
			if (Path == null || Path.Path == null || Path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			Initialize(getObject: true);
			EnumerationOptions enumerationOptions = ((options != null) ? ((EnumerationOptions)options.Clone()) : new EnumerationOptions());
			enumerationOptions.EnumerateDeep = true;
			enumerationOptions.ReturnImmediately = false;
			if (watcher.HaveListenersForProgress)
			{
				enumerationOptions.SendStatus = true;
			}
			WmiEventSink newSink = watcher.GetNewSink(base.Scope, enumerationOptions.Context);
			RelationshipQuery relationshipQuery = new RelationshipQuery(isSchemaQuery: true, Path.Path, relationshipClass, relationshipQualifier, thisRole);
			SecurityHandler securityHandler = null;
			int num = 0;
			securityHandler = base.Scope.GetSecurityHandler();
			num = scope.GetSecuredIWbemServicesHandler(base.Scope.GetIWbemServices()).ExecQueryAsync_(relationshipQuery.QueryLanguage, relationshipQuery.QueryString, enumerationOptions.Flags, enumerationOptions.GetContext(), newSink.Stub);
			securityHandler?.Reset();
			if (num < 0)
			{
				watcher.RemoveSink(newSink);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Generates a strongly-typed class for a given WMI class.</summary>
		/// <param name="includeSystemClassInClassDef">
		///   <see langword="true" /> to include the class for managing system properties; otherwise, <see langword="false" />.</param>
		/// <param name="systemPropertyClass">
		///   <see langword="true" /> to have the generated class manage system properties; otherwise, <see langword="false" />.</param>
		/// <returns>A <see cref="T:System.CodeDom.CodeTypeDeclaration" /> representing the declaration for the strongly-typed class.</returns>
		public CodeTypeDeclaration GetStronglyTypedClassCode(bool includeSystemClassInClassDef, bool systemPropertyClass)
		{
			Get();
			ManagementClassGenerator managementClassGenerator = new ManagementClassGenerator(this);
			return managementClassGenerator.GenerateCode(includeSystemClassInClassDef, systemPropertyClass);
		}

		/// <summary>Generates a strongly-typed class for a given WMI class. This function generates code for Visual Basic, C#, JScript, J#, or C++ depending on the input parameters.</summary>
		/// <param name="lang">The language of the code to be generated. This code language comes from the <see cref="T:System.Management.CodeLanguage" /> enumeration.</param>
		/// <param name="filePath">The path of the file where the code is to be written.</param>
		/// <param name="classNamespace">The.NET namespace into which the class should be generated. If this is empty, the namespace will be generated from the WMI namespace.</param>
		/// <returns>
		///   <see langword="true" />, if the method succeeded; otherwise, <see langword="false" />.</returns>
		public bool GetStronglyTypedClassCode(CodeLanguage lang, string filePath, string classNamespace)
		{
			Get();
			ManagementClassGenerator managementClassGenerator = new ManagementClassGenerator(this);
			return managementClassGenerator.GenerateCode(lang, filePath, classNamespace);
		}
	}
	/// <summary>Provides methods to convert DMTF datetime and time intervals to CLR-compliant <see cref="T:System.DateTime" /> and <see cref="T:System.TimeSpan" /> format and vice versa.</summary>
	public sealed class ManagementDateTimeConverter
	{
		private const int SIZEOFDMTFDATETIME = 25;

		private const int MAXSIZE_UTC_DMTF = 999;

		private const long MAXDATE_INTIMESPAN = 99999999L;

		private ManagementDateTimeConverter()
		{
		}

		/// <summary>Converts a given DMTF datetime to <see cref="T:System.DateTime" />. The returned <see cref="T:System.DateTime" /> will be in the current time zone of the system.</summary>
		/// <param name="dmtfDate">A string representing the datetime in DMTF format.</param>
		/// <returns>A <see cref="T:System.DateTime" /> that represents the given DMTF datetime.</returns>
		public static DateTime ToDateTime(string dmtfDate)
		{
			int num = DateTime.MinValue.Year;
			int num2 = DateTime.MinValue.Month;
			int num3 = DateTime.MinValue.Day;
			int num4 = DateTime.MinValue.Hour;
			int num5 = DateTime.MinValue.Minute;
			int num6 = DateTime.MinValue.Second;
			int millisecond = 0;
			DateTime minValue = DateTime.MinValue;
			if (dmtfDate == null)
			{
				throw new ArgumentOutOfRangeException("dmtfDate");
			}
			if (dmtfDate.Length == 0)
			{
				throw new ArgumentOutOfRangeException("dmtfDate");
			}
			if (dmtfDate.Length != 25)
			{
				throw new ArgumentOutOfRangeException("dmtfDate");
			}
			IFormatProvider provider = (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int));
			long num7 = 0L;
			try
			{
				string empty = string.Empty;
				empty = dmtfDate.Substring(0, 4);
				if ("****" != empty)
				{
					num = int.Parse(empty, provider);
				}
				empty = dmtfDate.Substring(4, 2);
				if ("**" != empty)
				{
					num2 = int.Parse(empty, provider);
				}
				empty = dmtfDate.Substring(6, 2);
				if ("**" != empty)
				{
					num3 = int.Parse(empty, provider);
				}
				empty = dmtfDate.Substring(8, 2);
				if ("**" != empty)
				{
					num4 = int.Parse(empty, provider);
				}
				empty = dmtfDate.Substring(10, 2);
				if ("**" != empty)
				{
					num5 = int.Parse(empty, provider);
				}
				empty = dmtfDate.Substring(12, 2);
				if ("**" != empty)
				{
					num6 = int.Parse(empty, provider);
				}
				empty = dmtfDate.Substring(15, 6);
				if ("******" != empty)
				{
					num7 = long.Parse(empty, (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(long))) * 10;
				}
				if (num < 0 || num2 < 0 || num3 < 0 || num4 < 0 || num5 < 0 || num6 < 0 || num7 < 0)
				{
					throw new ArgumentOutOfRangeException("dmtfDate");
				}
			}
			catch
			{
				throw new ArgumentOutOfRangeException("dmtfDate");
			}
			minValue = new DateTime(num, num2, num3, num4, num5, num6, millisecond).AddTicks(num7);
			TimeZone currentTimeZone = TimeZone.CurrentTimeZone;
			long num8 = currentTimeZone.GetUtcOffset(minValue).Ticks / 600000000;
			int num9 = 0;
			string text = dmtfDate.Substring(22, 3);
			long num10 = 0L;
			if ("***" != text)
			{
				text = dmtfDate.Substring(21, 4);
				try
				{
					num9 = int.Parse(text, provider);
				}
				catch
				{
					throw new ArgumentOutOfRangeException();
				}
				num10 = num9 - num8;
				minValue = minValue.AddMinutes(num10 * -1);
			}
			return minValue;
		}

		/// <summary>Converts a given <see cref="T:System.DateTime" /> to DMTF datetime format.</summary>
		/// <param name="date">A <see cref="T:System.DateTime" /> representing the datetime to be converted to DMTF datetime.</param>
		/// <returns>A string that represents the DMTF datetime for the given <see cref="T:System.DateTime" />.</returns>
		public static string ToDmtfDateTime(DateTime date)
		{
			string empty = string.Empty;
			TimeZone currentTimeZone = TimeZone.CurrentTimeZone;
			TimeSpan utcOffset = currentTimeZone.GetUtcOffset(date);
			long value = utcOffset.Ticks / 600000000;
			IFormatProvider formatProvider = (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int));
			if (Math.Abs(value) > 999)
			{
				date = date.ToUniversalTime();
				empty = "+000";
			}
			else if (utcOffset.Ticks >= 0)
			{
				empty = "+" + (utcOffset.Ticks / 600000000).ToString(formatProvider).PadLeft(3, '0');
			}
			else
			{
				string text = value.ToString(formatProvider);
				empty = "-" + text.Substring(1, text.Length - 1).PadLeft(3, '0');
			}
			string text2 = date.Year.ToString(formatProvider).PadLeft(4, '0');
			text2 += date.Month.ToString(formatProvider).PadLeft(2, '0');
			text2 += date.Day.ToString(formatProvider).PadLeft(2, '0');
			text2 += date.Hour.ToString(formatProvider).PadLeft(2, '0');
			text2 += date.Minute.ToString(formatProvider).PadLeft(2, '0');
			text2 += date.Second.ToString(formatProvider).PadLeft(2, '0');
			text2 += ".";
			DateTime dateTime = new DateTime(date.Year, date.Month, date.Day, date.Hour, date.Minute, date.Second, 0);
			string text3 = ((date.Ticks - dateTime.Ticks) * 1000 / 10000).ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(long)));
			if (text3.Length > 6)
			{
				text3 = text3.Substring(0, 6);
			}
			text2 += text3.PadLeft(6, '0');
			return text2 + empty;
		}

		/// <summary>Converts a given DMTF time interval to a <see cref="T:System.TimeSpan" />.</summary>
		/// <param name="dmtfTimespan">A string representation of the DMTF time interval.</param>
		/// <returns>A <see cref="T:System.TimeSpan" /> that represents the given DMTF time interval.</returns>
		public static TimeSpan ToTimeSpan(string dmtfTimespan)
		{
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			IFormatProvider provider = (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int));
			TimeSpan minValue = TimeSpan.MinValue;
			if (dmtfTimespan == null)
			{
				throw new ArgumentOutOfRangeException("dmtfTimespan");
			}
			if (dmtfTimespan.Length == 0)
			{
				throw new ArgumentOutOfRangeException("dmtfTimespan");
			}
			if (dmtfTimespan.Length != 25)
			{
				throw new ArgumentOutOfRangeException("dmtfTimespan");
			}
			if (dmtfTimespan.Substring(21, 4) != ":000")
			{
				throw new ArgumentOutOfRangeException("dmtfTimespan");
			}
			long num5 = 0L;
			try
			{
				string empty = string.Empty;
				empty = dmtfTimespan.Substring(0, 8);
				num = int.Parse(empty, provider);
				empty = dmtfTimespan.Substring(8, 2);
				num2 = int.Parse(empty, provider);
				empty = dmtfTimespan.Substring(10, 2);
				num3 = int.Parse(empty, provider);
				empty = dmtfTimespan.Substring(12, 2);
				num4 = int.Parse(empty, provider);
				empty = dmtfTimespan.Substring(15, 6);
				num5 = long.Parse(empty, (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(long))) * 10;
			}
			catch
			{
				throw new ArgumentOutOfRangeException("dmtfTimespan");
			}
			if (num < 0 || num2 < 0 || num3 < 0 || num4 < 0 || num5 < 0)
			{
				throw new ArgumentOutOfRangeException("dmtfTimespan");
			}
			minValue = new TimeSpan(num, num2, num3, num4, 0);
			TimeSpan timeSpan = TimeSpan.FromTicks(num5);
			return minValue + timeSpan;
		}

		/// <summary>Converts a given <see cref="T:System.TimeSpan" /> to DMTF time interval.</summary>
		/// <param name="timespan">A <see cref="T:System.TimeSpan" /> representing the datetime to be converted to DMTF time interval.</param>
		/// <returns>A string that represents the DMTF time interval for the given <see cref="T:System.TimeSpan" />.</returns>
		public static string ToDmtfTimeInterval(TimeSpan timespan)
		{
			string text = timespan.Days.ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int))).PadLeft(8, '0');
			IFormatProvider formatProvider = (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int));
			if ((long)timespan.Days > 99999999L || timespan < TimeSpan.Zero)
			{
				throw new ArgumentOutOfRangeException();
			}
			text += timespan.Hours.ToString(formatProvider).PadLeft(2, '0');
			text += timespan.Minutes.ToString(formatProvider).PadLeft(2, '0');
			text += timespan.Seconds.ToString(formatProvider).PadLeft(2, '0');
			text += ".";
			TimeSpan timeSpan = new TimeSpan(timespan.Days, timespan.Hours, timespan.Minutes, timespan.Seconds, 0);
			string text2 = ((timespan.Ticks - timeSpan.Ticks) * 1000 / 10000).ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(long)));
			if (text2.Length > 6)
			{
				text2 = text2.Substring(0, 6);
			}
			text += text2.PadLeft(6, '0');
			return text + ":000";
		}
	}
	internal class IdentifierChangedEventArgs : EventArgs
	{
		internal IdentifierChangedEventArgs()
		{
		}
	}
	internal class InternalObjectPutEventArgs : EventArgs
	{
		private ManagementPath path;

		internal ManagementPath Path => path;

		internal InternalObjectPutEventArgs(ManagementPath path)
		{
			this.path = path.Clone();
		}
	}
	/// <summary>Represents the virtual base class to hold event data for WMI events.</summary>
	public abstract class ManagementEventArgs : EventArgs
	{
		private object context;

		/// <summary>Gets the operation context echoed back from the operation that triggered the event.</summary>
		/// <returns>The operation context.</returns>
		public object Context => context;

		internal ManagementEventArgs(object context)
		{
			this.context = context;
		}
	}
	/// <summary>Holds event data for the <see cref="E:System.Management.ManagementOperationObserver.ObjectReady" /> event.</summary>
	public class ObjectReadyEventArgs : ManagementEventArgs
	{
		private ManagementBaseObject wmiObject;

		/// <summary>Gets the newly-returned object.</summary>
		/// <returns>Returns a <see cref="T:System.Management.ManagementBaseObject" /> containing the newly-returned object.</returns>
		public ManagementBaseObject NewObject => wmiObject;

		internal ObjectReadyEventArgs(object context, ManagementBaseObject wmiObject)
			: base(context)
		{
			this.wmiObject = wmiObject;
		}
	}
	/// <summary>Holds event data for the <see cref="E:System.Management.ManagementOperationObserver.Completed" /> event.</summary>
	public class CompletedEventArgs : ManagementEventArgs
	{
		private readonly int status;

		private readonly ManagementBaseObject wmiObject;

		/// <summary>Gets additional status information within a WMI object. This may be <see langword="null" />.</summary>
		/// <returns>Additional status information about the completion of an operation.</returns>
		public ManagementBaseObject StatusObject => wmiObject;

		/// <summary>Gets the completion status of the operation.</summary>
		/// <returns>One of the enumeration values that indicates the completion status of the operation.</returns>
		public ManagementStatus Status => (ManagementStatus)status;

		internal CompletedEventArgs(object context, int status, ManagementBaseObject wmiStatusObject)
			: base(context)
		{
			wmiObject = wmiStatusObject;
			this.status = status;
		}
	}
	/// <summary>Holds event data for the <see cref="E:System.Management.ManagementOperationObserver.ObjectPut" /> event.</summary>
	public class ObjectPutEventArgs : ManagementEventArgs
	{
		private ManagementPath wmiPath;

		/// <summary>Gets the identity of the object that has been put.</summary>
		/// <returns>Returns a <see cref="T:System.Management.ManagementPath" /> containing the path of the object that has been put.</returns>
		public ManagementPath Path => wmiPath;

		internal ObjectPutEventArgs(object context, ManagementPath path)
			: base(context)
		{
			wmiPath = path;
		}
	}
	/// <summary>Holds event data for the <see cref="E:System.Management.ManagementOperationObserver.Progress" /> event.</summary>
	public class ProgressEventArgs : ManagementEventArgs
	{
		private int upperBound;

		private int current;

		private string message;

		/// <summary>Gets the total amount of work required to be done by the operation.</summary>
		/// <returns>Returns an <see cref="T:System.Int32" /> value representing the total amount of work to be done by the operation.</returns>
		public int UpperBound => upperBound;

		/// <summary>Gets the current amount of work done by the operation. This is always less than or equal to <see cref="P:System.Management.ProgressEventArgs.UpperBound" />.</summary>
		/// <returns>Returns an <see cref="T:System.Int32" /> value representing the current amount of work already completed by the operation.</returns>
		public int Current => current;

		/// <summary>Gets or sets optional additional information regarding the operation's progress.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing information regarding the operation's progress.</returns>
		public string Message
		{
			get
			{
				if (message == null)
				{
					return string.Empty;
				}
				return message;
			}
		}

		internal ProgressEventArgs(object context, int upperBound, int current, string message)
			: base(context)
		{
			this.upperBound = upperBound;
			this.current = current;
			this.message = message;
		}
	}
	/// <summary>Holds event data for the <see cref="E:System.Management.ManagementEventWatcher.EventArrived" /> event.</summary>
	public class EventArrivedEventArgs : ManagementEventArgs
	{
		private ManagementBaseObject eventObject;

		/// <summary>Gets the WMI event that was delivered.</summary>
		/// <returns>The delivered WMI event.</returns>
		public ManagementBaseObject NewEvent => eventObject;

		internal EventArrivedEventArgs(object context, ManagementBaseObject eventObject)
			: base(context)
		{
			this.eventObject = eventObject;
		}
	}
	/// <summary>Holds event data for the <see cref="E:System.Management.ManagementEventWatcher.Stopped" /> event.</summary>
	public class StoppedEventArgs : ManagementEventArgs
	{
		private int status;

		/// <summary>Gets the completion status of the operation.</summary>
		/// <returns>The status of the operation.</returns>
		public ManagementStatus Status => (ManagementStatus)status;

		internal StoppedEventArgs(object context, int status)
			: base(context)
		{
			this.status = status;
		}
	}
	/// <summary>Represents the method that will handle the <see cref="E:System.Management.ManagementEventWatcher.EventArrived" /> event.</summary>
	/// <param name="sender">The instance of the object for which to invoke this method.</param>
	/// <param name="e">The <see cref="T:System.Management.EventArrivedEventArgs" /> that specifies the reason the event was invoked.</param>
	public delegate void EventArrivedEventHandler(object sender, EventArrivedEventArgs e);
	/// <summary>Represents the method that will handle the <see cref="E:System.Management.ManagementEventWatcher.Stopped" /> event.</summary>
	/// <param name="sender">The instance of the object for which to invoke this method.</param>
	/// <param name="e">The <see cref="T:System.Management.StoppedEventArgs" /> that specifies the reason the event was invoked.</param>
	public delegate void StoppedEventHandler(object sender, StoppedEventArgs e);
	/// <summary>Subscribes to temporary event notifications based on a specified event query.</summary>
	[ToolboxItem(false)]
	public class ManagementEventWatcher : Component
	{
		private ManagementScope scope;

		private EventQuery query;

		private EventWatcherOptions options;

		private IEnumWbemClassObject enumWbem;

		private IWbemClassObjectFreeThreaded[] cachedObjects;

		private uint cachedCount;

		private uint cacheIndex;

		private SinkForEventQuery sink;

		private WmiDelegateInvoker delegateInvoker;

		/// <summary>Gets or sets the scope in which to watch for events (namespace or scope).</summary>
		/// <returns>The scope in which to watch for events.</returns>
		public ManagementScope Scope
		{
			get
			{
				return scope;
			}
			set
			{
				if (value != null)
				{
					ManagementScope managementScope = scope;
					scope = value.Clone();
					if (managementScope != null)
					{
						managementScope.IdentifierChanged -= HandleIdentifierChange;
					}
					scope.IdentifierChanged += HandleIdentifierChange;
					HandleIdentifierChange(this, null);
					return;
				}
				throw new ArgumentNullException("value");
			}
		}

		/// <summary>Gets or sets the criteria to apply to events.</summary>
		/// <returns>The query to apply to events.</returns>
		public EventQuery Query
		{
			get
			{
				return query;
			}
			set
			{
				if (value != null)
				{
					ManagementQuery managementQuery = query;
					query = (EventQuery)value.Clone();
					if (managementQuery != null)
					{
						managementQuery.IdentifierChanged -= HandleIdentifierChange;
					}
					query.IdentifierChanged += HandleIdentifierChange;
					HandleIdentifierChange(this, null);
					return;
				}
				throw new ArgumentNullException("value");
			}
		}

		/// <summary>Gets or sets the options used to watch for events.</summary>
		/// <returns>The event options used to watch for events.</returns>
		public EventWatcherOptions Options
		{
			get
			{
				return options;
			}
			set
			{
				if (value != null)
				{
					EventWatcherOptions eventWatcherOptions = options;
					options = (EventWatcherOptions)value.Clone();
					if (eventWatcherOptions != null)
					{
						eventWatcherOptions.IdentifierChanged -= HandleIdentifierChange;
					}
					cachedObjects = new IWbemClassObjectFreeThreaded[options.BlockSize];
					options.IdentifierChanged += HandleIdentifierChange;
					HandleIdentifierChange(this, null);
					return;
				}
				throw new ArgumentNullException("value");
			}
		}

		/// <summary>Occurs when a new event arrives.</summary>
		public event EventArrivedEventHandler EventArrived;

		/// <summary>Occurs when a subscription is canceled.</summary>
		public event StoppedEventHandler Stopped;

		private void HandleIdentifierChange(object sender, IdentifierChangedEventArgs e)
		{
			Stop();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementEventWatcher" /> class. For further initialization, set the properties on the object. This is the default constructor.</summary>
		public ManagementEventWatcher()
			: this((ManagementScope)null, (EventQuery)null, (EventWatcherOptions)null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementEventWatcher" /> class when given a WMI event query.</summary>
		/// <param name="query">An <see cref="T:System.Management.EventQuery" /> representing a WMI event query, which determines the events for which the watcher will listen.</param>
		public ManagementEventWatcher(EventQuery query)
			: this(null, query, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementEventWatcher" /> class when given a WMI event query in the form of a string.</summary>
		/// <param name="query">A WMI event query, which defines the events for which the watcher will listen.</param>
		public ManagementEventWatcher(string query)
			: this(null, new EventQuery(query), null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementEventWatcher" /> class that listens for events conforming to the given WMI event query.</summary>
		/// <param name="scope">A <see cref="T:System.Management.ManagementScope" /> representing the scope (namespace) in which the watcher will listen for events.</param>
		/// <param name="query">An <see cref="T:System.Management.EventQuery" /> representing a WMI event query, which determines the events for which the watcher will listen.</param>
		public ManagementEventWatcher(ManagementScope scope, EventQuery query)
			: this(scope, query, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementEventWatcher" /> class that listens for events conforming to the given WMI event query. For this variant, the query and the scope are specified as strings.</summary>
		/// <param name="scope">The management scope (namespace) in which the watcher will listen for events.</param>
		/// <param name="query">The query that defines the events for which the watcher will listen.</param>
		public ManagementEventWatcher(string scope, string query)
			: this(new ManagementScope(scope), new EventQuery(query), null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementEventWatcher" /> class that listens for events conforming to the given WMI event query, according to the specified options. For this variant, the query and the scope are specified as strings. The options object can specify options such as a time-out and context information.</summary>
		/// <param name="scope">The management scope (namespace) in which the watcher will listen for events.</param>
		/// <param name="query">The query that defines the events for which the watcher will listen.</param>
		/// <param name="options">An <see cref="T:System.Management.EventWatcherOptions" /> representing additional options used to watch for events.</param>
		public ManagementEventWatcher(string scope, string query, EventWatcherOptions options)
			: this(new ManagementScope(scope), new EventQuery(query), options)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementEventWatcher" /> class that listens for events conforming to the given WMI event query, according to the specified options. For this variant, the query and the scope are specified objects. The options object can specify options such as time-out and context information.</summary>
		/// <param name="scope">A <see cref="T:System.Management.ManagementScope" /> representing the scope (namespace) in which the watcher will listen for events.</param>
		/// <param name="query">An <see cref="T:System.Management.EventQuery" /> representing a WMI event query, which determines the events for which the watcher will listen.</param>
		/// <param name="options">An <see cref="T:System.Management.EventWatcherOptions" /> representing additional options used to watch for events.</param>
		public ManagementEventWatcher(ManagementScope scope, EventQuery query, EventWatcherOptions options)
		{
			if (scope != null)
			{
				this.scope = ManagementScope._Clone(scope, HandleIdentifierChange);
			}
			else
			{
				this.scope = ManagementScope._Clone(null, HandleIdentifierChange);
			}
			if (query != null)
			{
				this.query = (EventQuery)query.Clone();
			}
			else
			{
				this.query = new EventQuery();
			}
			this.query.IdentifierChanged += HandleIdentifierChange;
			if (options != null)
			{
				this.options = (EventWatcherOptions)options.Clone();
			}
			else
			{
				this.options = new EventWatcherOptions();
			}
			this.options.IdentifierChanged += HandleIdentifierChange;
			enumWbem = null;
			cachedCount = 0u;
			cacheIndex = 0u;
			sink = null;
			delegateInvoker = new WmiDelegateInvoker(this);
		}

		/// <summary>Ensures that outstanding calls are cleared. This is the destructor for the object. In C#, finalizers are expressed using destructor syntax.</summary>
		~ManagementEventWatcher()
		{
			StopInternal(inEventWatcherFinalizer: true);
			if (scope != null)
			{
				scope.IdentifierChanged -= HandleIdentifierChange;
			}
			if (options != null)
			{
				options.IdentifierChanged -= HandleIdentifierChange;
			}
			if (query != null)
			{
				query.IdentifierChanged -= HandleIdentifierChange;
			}
		}

		/// <summary>Waits for the next event that matches the specified query to arrive, and then returns it.</summary>
		/// <returns>A <see cref="T:System.Management.ManagementBaseObject" /> representing the newly arrived event.</returns>
		public ManagementBaseObject WaitForNextEvent()
		{
			ManagementBaseObject result = null;
			Initialize();
			lock (this)
			{
				SecurityHandler securityHandler = Scope.GetSecurityHandler();
				int num = 0;
				try
				{
					if (enumWbem == null)
					{
						num = scope.GetSecuredIWbemServicesHandler(Scope.GetIWbemServices()).ExecNotificationQuery_(query.QueryLanguage, query.QueryString, options.Flags, options.GetContext(), ref enumWbem);
					}
					if (num >= 0)
					{
						if (cachedCount - cacheIndex == 0)
						{
							IWbemClassObject_DoNotMarshal[] array = new IWbemClassObject_DoNotMarshal[options.BlockSize];
							int lTimeout = ((ManagementOptions.InfiniteTimeout == options.Timeout) ? (-1) : ((int)options.Timeout.TotalMilliseconds));
							num = scope.GetSecuredIEnumWbemClassObjectHandler(enumWbem).Next_(lTimeout, (uint)options.BlockSize, array, ref cachedCount);
							cacheIndex = 0u;
							if (num >= 0)
							{
								if (cachedCount == 0)
								{
									ManagementException.ThrowWithExtendedInfo(ManagementStatus.Timedout);
								}
								for (int i = 0; i < cachedCount; i++)
								{
									cachedObjects[i] = new IWbemClassObjectFreeThreaded(Marshal.GetIUnknownForObject(array[i]));
								}
							}
						}
						if (num >= 0)
						{
							result = new ManagementBaseObject(cachedObjects[cacheIndex]);
							cacheIndex++;
						}
					}
				}
				finally
				{
					securityHandler.Reset();
				}
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
						return result;
					}
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					return result;
				}
				return result;
			}
		}

		/// <summary>Subscribes to events with the given query and delivers them, asynchronously, through the <see cref="E:System.Management.ManagementEventWatcher.EventArrived" /> event.</summary>
		public void Start()
		{
			Initialize();
			Stop();
			SecurityHandler securityHandler = Scope.GetSecurityHandler();
			IWbemServices iWbemServices = scope.GetIWbemServices();
			try
			{
				sink = new SinkForEventQuery(this, options.Context, iWbemServices);
				if (sink.Status < 0)
				{
					Marshal.ThrowExceptionForHR(sink.Status, WmiNetUtilsHelper.GetErrorInfo_f());
				}
				int num = scope.GetSecuredIWbemServicesHandler(iWbemServices).ExecNotificationQueryAsync_(query.QueryLanguage, query.QueryString, 0, options.GetContext(), sink.Stub);
				if (num < 0)
				{
					if (sink != null)
					{
						sink.ReleaseStub();
						sink = null;
					}
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}
			finally
			{
				securityHandler.Reset();
			}
		}

		/// <summary>Cancels the subscription whether it is synchronous or asynchronous.</summary>
		public void Stop()
		{
			StopInternal(inEventWatcherFinalizer: false);
		}

		private void StopInternal(bool inEventWatcherFinalizer)
		{
			if (enumWbem != null)
			{
				Marshal.ReleaseComObject(enumWbem);
				enumWbem = null;
				FireStopped(new StoppedEventArgs(options.Context, 262150));
			}
			if (sink != null)
			{
				sink.CancelInternal(inEventWatcherFinalizer);
				sink = null;
			}
		}

		private void Initialize()
		{
			if (query == null)
			{
				throw new InvalidOperationException();
			}
			if (options == null)
			{
				Options = new EventWatcherOptions();
			}
			lock (this)
			{
				if (scope == null)
				{
					Scope = new ManagementScope();
				}
				if (cachedObjects == null)
				{
					cachedObjects = new IWbemClassObjectFreeThreaded[options.BlockSize];
				}
			}
			lock (scope)
			{
				scope.Initialize();
			}
		}

		internal void FireStopped(StoppedEventArgs args)
		{
			try
			{
				delegateInvoker.FireEventToDelegates(this.Stopped, args);
			}
			catch
			{
			}
		}

		internal void FireEventArrived(EventArrivedEventArgs args)
		{
			try
			{
				delegateInvoker.FireEventToDelegates(this.EventArrived, args);
			}
			catch
			{
			}
		}
	}
	internal class SinkForEventQuery : IWmiEventSource
	{
		private ManagementEventWatcher eventWatcher;

		private object context;

		private IWbemServices services;

		private IWbemObjectSink stub;

		private int status;

		private bool isLocal;

		public int Status
		{
			get
			{
				return status;
			}
			set
			{
				status = value;
			}
		}

		internal IWbemObjectSink Stub => stub;

		public SinkForEventQuery(ManagementEventWatcher eventWatcher, object context, IWbemServices services)
		{
			this.services = services;
			this.context = context;
			this.eventWatcher = eventWatcher;
			status = 0;
			isLocal = false;
			if (string.Compare(eventWatcher.Scope.Path.Server, ".", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(eventWatcher.Scope.Path.Server, Environment.MachineName, StringComparison.OrdinalIgnoreCase) == 0)
			{
				isLocal = true;
			}
			if (MTAHelper.IsNoContextMTA())
			{
				HackToCreateStubInMTA(this);
				return;
			}
			ThreadDispatch threadDispatch = new ThreadDispatch((ThreadDispatch.ThreadWorkerMethodWithParam)HackToCreateStubInMTA);
			threadDispatch.Parameter = this;
			threadDispatch.Start();
		}

		private void HackToCreateStubInMTA(object param)
		{
			SinkForEventQuery sinkForEventQuery = (SinkForEventQuery)param;
			object ppIUnknown = null;
			sinkForEventQuery.Status = WmiNetUtilsHelper.GetDemultiplexedStub_f(sinkForEventQuery, sinkForEventQuery.isLocal, out ppIUnknown);
			sinkForEventQuery.stub = (IWbemObjectSink)ppIUnknown;
		}

		public void Indicate(IntPtr pWbemClassObject)
		{
			Marshal.AddRef(pWbemClassObject);
			IWbemClassObjectFreeThreaded wbemObject = new IWbemClassObjectFreeThreaded(pWbemClassObject);
			try
			{
				EventArrivedEventArgs args = new EventArrivedEventArgs(context, new ManagementBaseObject(wbemObject));
				eventWatcher.FireEventArrived(args);
			}
			catch
			{
			}
		}

		public void SetStatus(int flags, int hResult, string message, IntPtr pErrObj)
		{
			try
			{
				eventWatcher.FireStopped(new StoppedEventArgs(context, hResult));
				if (hResult != -2147217358 && hResult != 262150)
				{
					ThreadPool.QueueUserWorkItem(Cancel2);
				}
			}
			catch
			{
			}
		}

		private void Cancel2(object o)
		{
			try
			{
				Cancel();
			}
			catch
			{
			}
		}

		internal void Cancel()
		{
			CancelInternal(inEventWatcherFinalizer: false);
		}

		internal void CancelInternal(bool inEventWatcherFinalizer)
		{
			if (stub == null)
			{
				return;
			}
			lock (this)
			{
				if (stub == null)
				{
					return;
				}
				int num = services.CancelAsyncCall_(stub);
				ReleaseStub();
				if (num < 0 && (!inEventWatcherFinalizer || !Environment.HasShutdownStarted || AppDomain.CurrentDomain.IsFinalizingForUnload()))
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}
		}

		internal void ReleaseStub()
		{
			if (stub == null)
			{
				return;
			}
			lock (this)
			{
				if (stub != null)
				{
					try
					{
						Marshal.ReleaseComObject(stub);
						stub = null;
						return;
					}
					catch
					{
						return;
					}
				}
			}
		}
	}
	/// <summary>Describes the enumeration of all WMI error codes that are currently defined.</summary>
	public enum ManagementStatus
	{
		/// <summary>The operation was successful.</summary>
		NoError = 0,
		/// <summary>This value is returned when no more objects are available, the number of objects returned is less than the number requested, or at the end of an enumeration. It is also returned when the method is called with a value of 0 for the parameter.</summary>
		False = 1,
		/// <summary>An overridden property was deleted. This value is returned to signal that the original, non-overridden value has been restored as a result of the deletion.</summary>
		ResetToDefault = 262146,
		/// <summary>The compared items (such as objects and classes) are not identical.</summary>
		Different = 262147,
		/// <summary>A call timed out. This is not an error condition; therefore, some results may have been returned.</summary>
		Timedout = 262148,
		/// <summary>No more data is available from the enumeration; the user should terminate the enumeration.</summary>
		NoMoreData = 262149,
		/// <summary>The operation was canceled.</summary>
		OperationCanceled = 262150,
		/// <summary>A request is still in progress; however, the results are not yet available.</summary>
		Pending = 262151,
		/// <summary>More than one copy of the same object was detected in the result set of an enumeration.</summary>
		DuplicateObjects = 262152,
		/// <summary>The user did not receive all of the requested objects because of inaccessible resources (other than security violations).</summary>
		PartialResults = 262160,
		/// <summary>The call failed.</summary>
		Failed = -2147217407,
		/// <summary>The object could not be found.</summary>
		NotFound = -2147217406,
		/// <summary>The current user does not have permission to perform the action.</summary>
		AccessDenied = -2147217405,
		/// <summary>The provider failed after initialization.</summary>
		ProviderFailure = -2147217404,
		/// <summary>A type mismatch occurred.</summary>
		TypeMismatch = -2147217403,
		/// <summary>There was not enough memory for the operation.</summary>
		OutOfMemory = -2147217402,
		/// <summary>The context object is not valid.</summary>
		InvalidContext = -2147217401,
		/// <summary>One of the parameters to the call is not correct.</summary>
		InvalidParameter = -2147217400,
		/// <summary>The resource, typically a remote server, is not currently available.</summary>
		NotAvailable = -2147217399,
		/// <summary>An internal, critical, and unexpected error occurred. Report this error to Microsoft Technical Support.</summary>
		CriticalError = -2147217398,
		/// <summary>One or more network packets were corrupted during a remote session.</summary>
		InvalidStream = -2147217397,
		/// <summary>The feature or operation is not supported.</summary>
		NotSupported = -2147217396,
		/// <summary>The specified superclass is not valid.</summary>
		InvalidSuperclass = -2147217395,
		/// <summary>The specified namespace could not be found.</summary>
		InvalidNamespace = -2147217394,
		/// <summary>The specified instance is not valid.</summary>
		InvalidObject = -2147217393,
		/// <summary>The specified class is not valid.</summary>
		InvalidClass = -2147217392,
		/// <summary>A provider referenced in the schema does not have a corresponding registration.</summary>
		ProviderNotFound = -2147217391,
		/// <summary>A provider referenced in the schema has an incorrect or incomplete registration.</summary>
		InvalidProviderRegistration = -2147217390,
		/// <summary>COM cannot locate a provider referenced in the schema.</summary>
		ProviderLoadFailure = -2147217389,
		/// <summary>A component, such as a provider, failed to initialize for internal reasons.</summary>
		InitializationFailure = -2147217388,
		/// <summary>A networking error that prevents normal operation has occurred.</summary>
		TransportFailure = -2147217387,
		/// <summary>The requested operation is not valid. This error usually applies to invalid attempts to delete classes or properties.</summary>
		InvalidOperation = -2147217386,
		/// <summary>The query was not syntactically valid.</summary>
		InvalidQuery = -2147217385,
		/// <summary>The requested query language is not supported.</summary>
		InvalidQueryType = -2147217384,
		/// <summary>In a put operation, the wbemChangeFlagCreateOnly flag was specified, but the instance already exists.</summary>
		AlreadyExists = -2147217383,
		/// <summary>The add operation cannot be performed on the qualifier because the owning object does not permit overrides.</summary>
		OverrideNotAllowed = -2147217382,
		/// <summary>The user attempted to delete a qualifier that was not owned. The qualifier was inherited from a parent class.</summary>
		PropagatedQualifier = -2147217381,
		/// <summary>The user attempted to delete a property that was not owned. The property was inherited from a parent class.</summary>
		PropagatedProperty = -2147217380,
		/// <summary>The client made an unexpected and illegal sequence of calls.</summary>
		Unexpected = -2147217379,
		/// <summary>The user requested an illegal operation, such as spawning a class from an instance.</summary>
		IllegalOperation = -2147217378,
		/// <summary>There was an illegal attempt to specify a key qualifier on a property that cannot be a key. The keys are specified in the class definition for an object and cannot be altered on a per-instance basis.</summary>
		CannotBeKey = -2147217377,
		/// <summary>The current object is not a valid class definition. Either it is incomplete, or it has not been registered with WMI using <see cref="M:System.Management.ManagementObject.Put" />().</summary>
		IncompleteClass = -2147217376,
		/// <summary>Reserved for future use.</summary>
		InvalidSyntax = -2147217375,
		/// <summary>Reserved for future use.</summary>
		NondecoratedObject = -2147217374,
		/// <summary>The property that you are attempting to modify is read-only.</summary>
		ReadOnly = -2147217373,
		/// <summary>The provider cannot perform the requested operation, such as requesting a query that is too complex, retrieving an instance, creating or updating a class, deleting a class, or enumerating a class.</summary>
		ProviderNotCapable = -2147217372,
		/// <summary>An attempt was made to make a change that would invalidate a derived class.</summary>
		ClassHasChildren = -2147217371,
		/// <summary>An attempt has been made to delete or modify a class that has instances.</summary>
		ClassHasInstances = -2147217370,
		/// <summary>Reserved for future use.</summary>
		QueryNotImplemented = -2147217369,
		/// <summary>A value of null was specified for a property that may not be null, such as one that is marked by a Key, Indexed, or Not_Null qualifier.</summary>
		IllegalNull = -2147217368,
		/// <summary>The value provided for a qualifier was not a legal qualifier type.</summary>
		InvalidQualifierType = -2147217367,
		/// <summary>The CIM type specified for a property is not valid.</summary>
		InvalidPropertyType = -2147217366,
		/// <summary>The request was made with an out-of-range value, or is incompatible with the type.</summary>
		ValueOutOfRange = -2147217365,
		/// <summary>An illegal attempt was made to make a class singleton, such as when the class is derived from a non-singleton class.</summary>
		CannotBeSingleton = -2147217364,
		/// <summary>The CIM type specified is not valid.</summary>
		InvalidCimType = -2147217363,
		/// <summary>The requested method is not available.</summary>
		InvalidMethod = -2147217362,
		/// <summary>The parameters provided for the method are not valid.</summary>
		InvalidMethodParameters = -2147217361,
		/// <summary>There was an attempt to get qualifiers on a system property.</summary>
		SystemProperty = -2147217360,
		/// <summary>The property type is not recognized.</summary>
		InvalidProperty = -2147217359,
		/// <summary>An asynchronous process has been canceled internally or by the user. Note that because of the timing and nature of the asynchronous operation, the operation may not have been truly canceled.</summary>
		CallCanceled = -2147217358,
		/// <summary>The user has requested an operation while WMI is in the process of closing.</summary>
		ShuttingDown = -2147217357,
		/// <summary>An attempt was made to reuse an existing method name from a superclass, and the signatures did not match.</summary>
		PropagatedMethod = -2147217356,
		/// <summary>One or more parameter values, such as a query text, is too complex or unsupported. WMI is requested to retry the operation with simpler parameters.</summary>
		UnsupportedParameter = -2147217355,
		/// <summary>A parameter was missing from the method call.</summary>
		MissingParameterID = -2147217354,
		/// <summary>A method parameter has an invalid ID qualifier.</summary>
		InvalidParameterID = -2147217353,
		/// <summary>One or more of the method parameters have ID qualifiers that are out of sequence.</summary>
		NonconsecutiveParameterIDs = -2147217352,
		/// <summary>The return value for a method has an ID qualifier.</summary>
		ParameterIDOnRetval = -2147217351,
		/// <summary>The specified object path was invalid.</summary>
		InvalidObjectPath = -2147217350,
		/// <summary>There is not enough free disk space to continue the operation.</summary>
		OutOfDiskSpace = -2147217349,
		/// <summary>The supplied buffer was too small to hold all the objects in the enumerator or to read a string property.</summary>
		BufferTooSmall = -2147217348,
		/// <summary>The provider does not support the requested put operation.</summary>
		UnsupportedPutExtension = -2147217347,
		/// <summary>An object with an incorrect type or version was encountered during marshaling.</summary>
		UnknownObjectType = -2147217346,
		/// <summary>A packet with an incorrect type or version was encountered during marshaling.</summary>
		UnknownPacketType = -2147217345,
		/// <summary>The packet has an unsupported version.</summary>
		MarshalVersionMismatch = -2147217344,
		/// <summary>The packet is corrupted.</summary>
		MarshalInvalidSignature = -2147217343,
		/// <summary>An attempt has been made to mismatch qualifiers, such as putting [ManagementKey] on an object instead of a property.</summary>
		InvalidQualifier = -2147217342,
		/// <summary>A duplicate parameter has been declared in a CIM method.</summary>
		InvalidDuplicateParameter = -2147217341,
		/// <summary>Reserved for future use.</summary>
		TooMuchData = -2147217340,
		/// <summary>The delivery of an event has failed. The provider may choose to re-raise the event.</summary>
		ServerTooBusy = -2147217339,
		/// <summary>The specified flavor was invalid.</summary>
		InvalidFlavor = -2147217338,
		/// <summary>An attempt has been made to create a reference that is circular (for example, deriving a class from itself).</summary>
		CircularReference = -2147217337,
		/// <summary>The specified class is not supported.</summary>
		UnsupportedClassUpdate = -2147217336,
		/// <summary>An attempt was made to change a key when instances or derived classes are already using the key.</summary>
		CannotChangeKeyInheritance = -2147217335,
		/// <summary>An attempt was made to change an index when instances or derived classes are already using the index.</summary>
		CannotChangeIndexInheritance = -2147217328,
		/// <summary>An attempt was made to create more properties than the current version of the class supports.</summary>
		TooManyProperties = -2147217327,
		/// <summary>A property was redefined with a conflicting type in a derived class.</summary>
		UpdateTypeMismatch = -2147217326,
		/// <summary>An attempt was made in a derived class to override a non-overrideable qualifier.</summary>
		UpdateOverrideNotAllowed = -2147217325,
		/// <summary>A method was redeclared with a conflicting signature in a derived class.</summary>
		UpdatePropagatedMethod = -2147217324,
		/// <summary>An attempt was made to execute a method not marked with [implemented] in any relevant class.</summary>
		MethodNotImplemented = -2147217323,
		/// <summary>An attempt was made to execute a method marked with [disabled].</summary>
		MethodDisabled = -2147217322,
		/// <summary>The refresher is busy with another operation.</summary>
		RefresherBusy = -2147217321,
		/// <summary>The filtering query is syntactically invalid.</summary>
		UnparsableQuery = -2147217320,
		/// <summary>The FROM clause of a filtering query references a class that is not an event class.</summary>
		NotEventClass = -2147217319,
		/// <summary>A GROUP BY clause was used without the corresponding GROUP WITHIN clause.</summary>
		MissingGroupWithin = -2147217318,
		/// <summary>A GROUP BY clause was used. Aggregation on all properties is not supported.</summary>
		MissingAggregationList = -2147217317,
		/// <summary>Dot notation was used on a property that is not an embedded object.</summary>
		PropertyNotAnObject = -2147217316,
		/// <summary>A GROUP BY clause references a property that is an embedded object without using dot notation.</summary>
		AggregatingByObject = -2147217315,
		/// <summary>An event provider registration query (__EventProviderRegistration) did not specify the classes for which events were provided.</summary>
		UninterpretableProviderQuery = -2147217313,
		/// <summary>An request was made to back up or restore the repository while WinMgmt.exe was using it.</summary>
		BackupRestoreWinmgmtRunning = -2147217312,
		/// <summary>The asynchronous delivery queue overflowed from the event consumer being too slow.</summary>
		QueueOverflow = -2147217311,
		/// <summary>The operation failed because the client did not have the necessary security privilege.</summary>
		PrivilegeNotHeld = -2147217310,
		/// <summary>The operator is not valid for this property type.</summary>
		InvalidOperator = -2147217309,
		/// <summary>The user specified a user name, password, or authority on a local connection. The user must use an empty user name and password and rely on default security.</summary>
		LocalCredentials = -2147217308,
		/// <summary>The class was made abstract when its superclass is not abstract.</summary>
		CannotBeAbstract = -2147217307,
		/// <summary>An amended object was used in a put operation without the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag being specified.</summary>
		AmendedObject = -2147217306,
		/// <summary>The client was not retrieving objects quickly enough from an enumeration.</summary>
		ClientTooSlow = -2147217305,
		/// <summary>The provider registration overlaps with the system event domain.</summary>
		RegistrationTooBroad = -2147213311,
		/// <summary>A WITHIN clause was not used in this query.</summary>
		RegistrationTooPrecise = -2147213310
	}
	/// <summary>Represents management exceptions.</summary>
	[Serializable]
	public class ManagementException : SystemException
	{
		private ManagementBaseObject errorObject;

		private ManagementStatus errorCode;

		/// <summary>Gets the extended error object provided by WMI.</summary>
		/// <returns>The extended error information.</returns>
		public ManagementBaseObject ErrorInformation => errorObject;

		/// <summary>Gets the error code reported by WMI, which caused this exception.</summary>
		/// <returns>One of the enumeration values that indicates the error code.</returns>
		public ManagementStatus ErrorCode => errorCode;

		internal static void ThrowWithExtendedInfo(ManagementStatus errorCode)
		{
			ManagementBaseObject managementBaseObject = null;
			string text = null;
			IWbemClassObjectFreeThreaded errorInfo = WbemErrorInfo.GetErrorInfo();
			if (errorInfo != null)
			{
				managementBaseObject = new ManagementBaseObject(errorInfo);
			}
			if ((text = GetMessage(errorCode)) == null && managementBaseObject != null)
			{
				try
				{
					text = (string)managementBaseObject["Description"];
				}
				catch
				{
				}
			}
			throw new ManagementException(errorCode, text, managementBaseObject);
		}

		internal static void ThrowWithExtendedInfo(Exception e)
		{
			ManagementBaseObject managementBaseObject = null;
			string text = null;
			IWbemClassObjectFreeThreaded errorInfo = WbemErrorInfo.GetErrorInfo();
			if (errorInfo != null)
			{
				managementBaseObject = new ManagementBaseObject(errorInfo);
			}
			if ((text = GetMessage(e)) == null && managementBaseObject != null)
			{
				try
				{
					text = (string)managementBaseObject["Description"];
				}
				catch
				{
				}
			}
			throw new ManagementException(e, text, managementBaseObject);
		}

		internal ManagementException(ManagementStatus errorCode, string msg, ManagementBaseObject errObj)
			: base(msg)
		{
			this.errorCode = errorCode;
			errorObject = errObj;
		}

		internal ManagementException(Exception e, string msg, ManagementBaseObject errObj)
			: base(msg, e)
		{
			try
			{
				if (e is ManagementException)
				{
					errorCode = ((ManagementException)e).ErrorCode;
					if (errorObject != null)
					{
						errorObject = (ManagementBaseObject)((ManagementException)e).errorObject.Clone();
					}
					else
					{
						errorObject = null;
					}
				}
				else if (e is COMException)
				{
					errorCode = (ManagementStatus)((COMException)e).ErrorCode;
				}
				else
				{
					errorCode = (ManagementStatus)base.HResult;
				}
			}
			catch
			{
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementException" /> class that is serializable.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> destination for this serialization.</param>
		protected ManagementException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			errorCode = (ManagementStatus)info.GetValue("errorCode", typeof(ManagementStatus));
			errorObject = info.GetValue("errorObject", typeof(ManagementBaseObject)) as ManagementBaseObject;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementException" /> class.</summary>
		public ManagementException()
			: this(ManagementStatus.Failed, "", null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementException" /> class with a specified error message.</summary>
		/// <param name="message">The message that describes the error.</param>
		public ManagementException(string message)
			: this(ManagementStatus.Failed, message, null)
		{
		}

		/// <summary>Initializes an empty new instance of the <see cref="T:System.Management.ManagementException" /> class. If the <paramref name="innerException" /> parameter is not <see langword="null" />, the current exception is raised in a catch block that handles the inner exception.</summary>
		/// <param name="message">The message that describes the error.</param>
		/// <param name="innerException">The exception that is the cause of the current exception.</param>
		public ManagementException(string message, Exception innerException)
			: this(innerException, message, null)
		{
			if (!(innerException is ManagementException))
			{
				errorCode = ManagementStatus.Failed;
			}
		}

		/// <summary>Populates the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the <see cref="T:System.Management.ManagementException" />.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> destination for this serialization.</param>
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("errorCode", errorCode);
			info.AddValue("errorObject", errorObject);
		}

		private static string GetMessage(Exception e)
		{
			string text = null;
			if (e is COMException)
			{
				text = GetMessage((ManagementStatus)((COMException)e).ErrorCode);
			}
			if (text == null)
			{
				text = e.Message;
			}
			return text;
		}

		private static string GetMessage(ManagementStatus errorCode)
		{
			string MessageText = null;
			IWbemStatusCodeText wbemStatusCodeText = null;
			wbemStatusCodeText = (IWbemStatusCodeText)new WbemStatusCodeText();
			if (wbemStatusCodeText != null)
			{
				try
				{
					if (wbemStatusCodeText.GetErrorCodeText_((int)errorCode, 0u, 1, out MessageText) == 0)
					{
						return MessageText;
					}
					int errorCodeText_ = wbemStatusCodeText.GetErrorCodeText_((int)errorCode, 0u, 0, out MessageText);
					return MessageText;
				}
				catch
				{
					return MessageText;
				}
			}
			return MessageText;
		}
	}
	/// <summary>Represents a collection of named values suitable for use as context information to WMI operations. The names are case-insensitive.</summary>
	public class ManagementNamedValueCollection : NameObjectCollectionBase
	{
		/// <summary>Gets the value associated with the specified name from this collection. In C#, this property is the indexer for the <see cref="T:System.Management.ManagementNamedValueCollection" /> class.</summary>
		/// <param name="name">The name of the value to be returned.</param>
		/// <returns>An object that is associated with the specified name from this collection.</returns>
		public object this[string name] => BaseGet(name);

		internal event IdentifierChangedEventHandler IdentifierChanged;

		private void FireIdentifierChanged()
		{
			if (this.IdentifierChanged != null)
			{
				this.IdentifierChanged(this, null);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementNamedValueCollection" /> class, which is empty. This is the default constructor.</summary>
		public ManagementNamedValueCollection()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementNamedValueCollection" /> class that is serializable and uses the specified <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" /> ) for this serialization.</param>
		protected ManagementNamedValueCollection(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		internal IWbemContext GetContext()
		{
			IWbemContext wbemContext = null;
			if (0 < Count)
			{
				int num = 0;
				try
				{
					wbemContext = (IWbemContext)new WbemContext();
					IEnumerator enumerator = GetEnumerator();
					try
					{
						while (enumerator.MoveNext())
						{
							string text = (string)enumerator.Current;
							object pValue = BaseGet(text);
							num = wbemContext.SetValue_(text, 0, ref pValue);
							if ((num & 0x80000000u) != 0L)
							{
								return wbemContext;
							}
						}
						return wbemContext;
					}
					finally
					{
						IDisposable disposable = enumerator as IDisposable;
						if (disposable != null)
						{
							disposable.Dispose();
						}
					}
				}
				catch
				{
					return wbemContext;
				}
			}
			return wbemContext;
		}

		/// <summary>Adds a single-named value to the collection.</summary>
		/// <param name="name">The name of the new value.</param>
		/// <param name="value">The value to be associated with the name.</param>
		public void Add(string name, object value)
		{
			try
			{
				BaseRemove(name);
			}
			catch
			{
			}
			BaseAdd(name, value);
			FireIdentifierChanged();
		}

		/// <summary>Removes a single-named value from the collection. If the collection does not contain an element with the specified name, the collection remains unchanged and no exception is thrown.</summary>
		/// <param name="name">The name of the value to be removed.</param>
		public void Remove(string name)
		{
			BaseRemove(name);
			FireIdentifierChanged();
		}

		/// <summary>Removes all entries from the collection.</summary>
		public void RemoveAll()
		{
			BaseClear();
			FireIdentifierChanged();
		}

		/// <summary>Creates a clone of the collection. Individual values are cloned. If a value does not support cloning, then a <see cref="T:System.NotSupportedException" /> is thrown.</summary>
		/// <returns>The new copy of the collection.</returns>
		public ManagementNamedValueCollection Clone()
		{
			ManagementNamedValueCollection managementNamedValueCollection = new ManagementNamedValueCollection();
			IEnumerator enumerator = GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					string name = (string)enumerator.Current;
					object obj = BaseGet(name);
					if (obj != null)
					{
						Type type = obj.GetType();
						if (type.IsByRef)
						{
							try
							{
								object value = ((ICloneable)obj).Clone();
								managementNamedValueCollection.Add(name, value);
							}
							catch
							{
								throw new NotSupportedException();
							}
						}
						else
						{
							managementNamedValueCollection.Add(name, obj);
						}
					}
					else
					{
						managementNamedValueCollection.Add(name, null);
					}
				}
				return managementNamedValueCollection;
			}
			finally
			{
				IDisposable disposable = enumerator as IDisposable;
				if (disposable != null)
				{
					disposable.Dispose();
				}
			}
		}
	}
	internal delegate void IdentifierChangedEventHandler(object sender, IdentifierChangedEventArgs e);
	internal delegate void InternalObjectPutEventHandler(object sender, InternalObjectPutEventArgs e);
	/// <summary>Represents a WMI instance.</summary>
	[Serializable]
	public class ManagementObject : ManagementBaseObject, ICloneable
	{
		internal const string ID = "ID";

		internal const string RETURNVALUE = "RETURNVALUE";

		private IWbemClassObjectFreeThreaded wmiClass;

		internal ManagementScope scope;

		internal ManagementPath path;

		internal ObjectGetOptions options;

		private bool putButNotGot;

		internal bool PutButNotGot
		{
			get
			{
				return putButNotGot;
			}
			set
			{
				putButNotGot = value;
			}
		}

		internal bool IsBound => _wbemObject != null;

		/// <summary>Gets or sets the scope in which this object resides.</summary>
		/// <returns>The scope in which this object resides.</returns>
		public ManagementScope Scope
		{
			get
			{
				if (scope == null)
				{
					return scope = ManagementScope._Clone(null);
				}
				return scope;
			}
			set
			{
				if (value != null)
				{
					if (scope != null)
					{
						scope.IdentifierChanged -= HandleIdentifierChange;
					}
					scope = ManagementScope._Clone(value, HandleIdentifierChange);
					FireIdentifierChanged();
					return;
				}
				throw new ArgumentNullException("value");
			}
		}

		/// <summary>Gets or sets the object's WMI path.</summary>
		/// <returns>A <see cref="T:System.Management.ManagementPath" /> representing the object's path.</returns>
		public virtual ManagementPath Path
		{
			get
			{
				if (path == null)
				{
					return path = ManagementPath._Clone(null);
				}
				return path;
			}
			set
			{
				ManagementPath managementPath = ((value != null) ? value : new ManagementPath());
				string namespacePath = managementPath.GetNamespacePath(8);
				if (namespacePath.Length > 0 && scope != null && scope.IsDefaulted)
				{
					Scope = new ManagementScope(namespacePath);
				}
				if ((GetType() == typeof(ManagementObject) && managementPath.IsInstance) || (GetType() == typeof(ManagementClass) && managementPath.IsClass) || managementPath.IsEmpty)
				{
					if (path != null)
					{
						path.IdentifierChanged -= HandleIdentifierChange;
					}
					path = ManagementPath._Clone(value, HandleIdentifierChange);
					FireIdentifierChanged();
					return;
				}
				throw new ArgumentOutOfRangeException("value");
			}
		}

		/// <summary>Gets or sets additional information to use when retrieving the object.</summary>
		/// <returns>An <see cref="T:System.Management.ObjectGetOptions" /> to use when retrieving the object.</returns>
		public ObjectGetOptions Options
		{
			get
			{
				if (options == null)
				{
					return options = ObjectGetOptions._Clone(null);
				}
				return options;
			}
			set
			{
				if (value != null)
				{
					if (options != null)
					{
						options.IdentifierChanged -= HandleIdentifierChange;
					}
					options = ObjectGetOptions._Clone(value, HandleIdentifierChange);
					FireIdentifierChanged();
					return;
				}
				throw new ArgumentNullException("value");
			}
		}

		/// <summary>Gets or sets the path to the object's class.</summary>
		/// <returns>A <see cref="T:System.Management.ManagementPath" /> representing the path to the object's class.</returns>
		public override ManagementPath ClassPath
		{
			get
			{
				object pVal = null;
				object pVal2 = null;
				object pVal3 = null;
				int pType = 0;
				int plFlavor = 0;
				if (PutButNotGot)
				{
					Get();
					PutButNotGot = false;
				}
				int num = base.wbemObject.Get_("__SERVER", 0, ref pVal, ref pType, ref plFlavor);
				if (num >= 0)
				{
					num = base.wbemObject.Get_("__NAMESPACE", 0, ref pVal2, ref pType, ref plFlavor);
					if (num >= 0)
					{
						num = base.wbemObject.Get_("__CLASS", 0, ref pVal3, ref pType, ref plFlavor);
					}
				}
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				ManagementPath managementPath = new ManagementPath();
				managementPath.Server = string.Empty;
				managementPath.NamespacePath = string.Empty;
				managementPath.ClassName = string.Empty;
				try
				{
					managementPath.Server = (string)((pVal is DBNull) ? "" : pVal);
					managementPath.NamespacePath = (string)((pVal2 is DBNull) ? "" : pVal2);
					managementPath.ClassName = (string)((pVal3 is DBNull) ? "" : pVal3);
					return managementPath;
				}
				catch
				{
					return managementPath;
				}
			}
		}

		internal event IdentifierChangedEventHandler IdentifierChanged;

		/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data necessary to deserialize the field represented by this instance.</summary>
		/// <param name="info">The object to be populated with serialization information.</param>
		/// <param name="context">The location where serialized data will be stored and retrieved.</param>
		protected override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
		}

		/// <summary>Releases all resources used by the Component.</summary>
		public new void Dispose()
		{
			if (wmiClass != null)
			{
				wmiClass.Dispose();
				wmiClass = null;
			}
			base.Dispose();
			GC.SuppressFinalize(this);
		}

		internal void FireIdentifierChanged()
		{
			if (this.IdentifierChanged != null)
			{
				this.IdentifierChanged(this, null);
			}
		}

		private void HandleIdentifierChange(object sender, IdentifierChangedEventArgs e)
		{
			base.wbemObject = null;
		}

		internal static ManagementObject GetManagementObject(IWbemClassObjectFreeThreaded wbemObject, ManagementObject mgObj)
		{
			ManagementObject managementObject = new ManagementObject();
			managementObject.wbemObject = wbemObject;
			if (mgObj != null)
			{
				managementObject.scope = ManagementScope._Clone(mgObj.scope);
				if (mgObj.path != null)
				{
					managementObject.path = ManagementPath._Clone(mgObj.path);
				}
				if (mgObj.options != null)
				{
					managementObject.options = ObjectGetOptions._Clone(mgObj.options);
				}
			}
			return managementObject;
		}

		internal static ManagementObject GetManagementObject(IWbemClassObjectFreeThreaded wbemObject, ManagementScope scope)
		{
			ManagementObject managementObject = new ManagementObject();
			managementObject.wbemObject = wbemObject;
			managementObject.path = new ManagementPath(ManagementPath.GetManagementPath(wbemObject));
			managementObject.path.IdentifierChanged += managementObject.HandleIdentifierChange;
			managementObject.scope = ManagementScope._Clone(scope, managementObject.HandleIdentifierChange);
			return managementObject;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObject" /> class. This is the default constructor.</summary>
		public ManagementObject()
			: this((ManagementScope)null, (ManagementPath)null, (ObjectGetOptions)null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObject" /> class for the specified WMI object path. The path is provided as a <see cref="T:System.Management.ManagementPath" />.</summary>
		/// <param name="path">A <see cref="T:System.Management.ManagementPath" /> that contains a path to a WMI object.</param>
		public ManagementObject(ManagementPath path)
			: this(null, path, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObject" /> class for the specified WMI object path. The path is provided as a string.</summary>
		/// <param name="path">A WMI path.</param>
		public ManagementObject(string path)
			: this(null, new ManagementPath(path), null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObject" /> class bound to the specified WMI path, including the specified additional options.</summary>
		/// <param name="path">A <see cref="T:System.Management.ManagementPath" /> containing the WMI path.</param>
		/// <param name="options">An <see cref="T:System.Management.ObjectGetOptions" /> containing additional options for binding to the WMI object. This parameter could be null if default options are to be used.</param>
		public ManagementObject(ManagementPath path, ObjectGetOptions options)
			: this(null, path, options)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObject" /> class bound to the specified WMI path, including the specified additional options. In this variant, the path can be specified as a string.</summary>
		/// <param name="path">The WMI path to the object.</param>
		/// <param name="options">An <see cref="T:System.Management.ObjectGetOptions" /> representing options to get the specified WMI object.</param>
		public ManagementObject(string path, ObjectGetOptions options)
			: this(new ManagementPath(path), options)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObject" /> class bound to the specified WMI path that includes the specified options.</summary>
		/// <param name="scope">A <see cref="T:System.Management.ManagementScope" /> representing the scope in which the WMI object resides. In this version, scopes can only be WMI namespaces.</param>
		/// <param name="path">A <see cref="T:System.Management.ManagementPath" /> representing the WMI path to the manageable object.</param>
		/// <param name="options">An <see cref="T:System.Management.ObjectGetOptions" /> specifying additional options for getting the object.</param>
		public ManagementObject(ManagementScope scope, ManagementPath path, ObjectGetOptions options)
			: base(null)
		{
			ManagementObjectCTOR(scope, path, options);
		}

		private void ManagementObjectCTOR(ManagementScope scope, ManagementPath path, ObjectGetOptions options)
		{
			string text = string.Empty;
			if (path != null && !path.IsEmpty)
			{
				if (GetType() == typeof(ManagementObject) && path.IsClass)
				{
					throw new ArgumentOutOfRangeException("path");
				}
				if (GetType() == typeof(ManagementClass) && path.IsInstance)
				{
					throw new ArgumentOutOfRangeException("path");
				}
				text = path.GetNamespacePath(8);
				if (scope != null && scope.Path.NamespacePath.Length > 0)
				{
					path = new ManagementPath(path.RelativePath);
					path.NamespacePath = scope.Path.GetNamespacePath(8);
				}
				if (path.IsClass || path.IsInstance)
				{
					this.path = ManagementPath._Clone(path, HandleIdentifierChange);
				}
				else
				{
					this.path = ManagementPath._Clone(null, HandleIdentifierChange);
				}
			}
			if (options != null)
			{
				this.options = ObjectGetOptions._Clone(options, HandleIdentifierChange);
			}
			if (scope != null)
			{
				this.scope = ManagementScope._Clone(scope, HandleIdentifierChange);
			}
			else if (text.Length > 0)
			{
				this.scope = new ManagementScope(text);
				this.scope.IdentifierChanged += HandleIdentifierChange;
			}
			IdentifierChanged += HandleIdentifierChange;
			putButNotGot = false;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObject" /> class bound to the specified WMI path, and includes the specified options. The scope and the path are specified as strings.</summary>
		/// <param name="scopeString">The scope for the WMI object.</param>
		/// <param name="pathString">The WMI object path.</param>
		/// <param name="options">An <see cref="T:System.Management.ObjectGetOptions" /> representing additional options for getting the WMI object.</param>
		public ManagementObject(string scopeString, string pathString, ObjectGetOptions options)
			: this(new ManagementScope(scopeString), new ManagementPath(pathString), options)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObject" /> class that is serializable.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
		protected ManagementObject(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			ManagementObjectCTOR(null, null, null);
		}

		/// <summary>Binds WMI class information to the management object.</summary>
		public void Get()
		{
			IWbemClassObjectFreeThreaded ppObject = null;
			Initialize(getObject: false);
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			ObjectGetOptions objectGetOptions = ((options == null) ? new ObjectGetOptions() : options);
			SecurityHandler securityHandler = null;
			int num = 0;
			try
			{
				securityHandler = scope.GetSecurityHandler();
				num = scope.GetSecuredIWbemServicesHandler(scope.GetIWbemServices()).GetObject_(path.RelativePath, objectGetOptions.Flags, objectGetOptions.GetContext(), ref ppObject, IntPtr.Zero);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				base.wbemObject = ppObject;
			}
			finally
			{
				securityHandler?.Reset();
			}
		}

		/// <summary>Binds to the management object asynchronously.</summary>
		/// <param name="watcher">The object to receive the results of the operation as events.</param>
		public void Get(ManagementOperationObserver watcher)
		{
			Initialize(getObject: false);
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			IWbemServices iWbemServices = scope.GetIWbemServices();
			ObjectGetOptions objectGetOptions = ObjectGetOptions._Clone(options);
			WmiGetEventSink newGetSink = watcher.GetNewGetSink(scope, objectGetOptions.Context, this);
			if (watcher.HaveListenersForProgress)
			{
				objectGetOptions.SendStatus = true;
			}
			SecurityHandler securityHandler = null;
			int num = 0;
			securityHandler = scope.GetSecurityHandler();
			num = scope.GetSecuredIWbemServicesHandler(iWbemServices).GetObjectAsync_(path.RelativePath, objectGetOptions.Flags, objectGetOptions.GetContext(), newGetSink.Stub);
			securityHandler?.Reset();
			if (num < 0)
			{
				watcher.RemoveSink(newGetSink);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Gets a collection of objects related to the object (associators).</summary>
		/// <returns>A <see cref="T:System.Management.ManagementObjectCollection" /> containing the related objects.</returns>
		public ManagementObjectCollection GetRelated()
		{
			return GetRelated((string)null);
		}

		/// <summary>Gets a collection of objects related to the object (associators).</summary>
		/// <param name="relatedClass">A class of related objects.</param>
		/// <returns>A <see cref="T:System.Management.ManagementObjectCollection" /> containing the related objects.</returns>
		public ManagementObjectCollection GetRelated(string relatedClass)
		{
			return GetRelated(relatedClass, null, null, null, null, null, classDefinitionsOnly: false, null);
		}

		/// <summary>Gets a collection of objects related to the object (associators).</summary>
		/// <param name="relatedClass">The class of the related objects.</param>
		/// <param name="relationshipClass">The relationship class of interest.</param>
		/// <param name="relationshipQualifier">The qualifier required to be present on the relationship class.</param>
		/// <param name="relatedQualifier">The qualifier required to be present on the related class.</param>
		/// <param name="relatedRole">The role that the related class is playing in the relationship.</param>
		/// <param name="thisRole">The role that this class is playing in the relationship.</param>
		/// <param name="classDefinitionsOnly">When this method returns, it contains only class definitions for the instances that match the query.</param>
		/// <param name="options">Extended options for how to execute the query.</param>
		/// <returns>A <see cref="T:System.Management.ManagementObjectCollection" /> containing the related objects.</returns>
		public ManagementObjectCollection GetRelated(string relatedClass, string relationshipClass, string relationshipQualifier, string relatedQualifier, string relatedRole, string thisRole, bool classDefinitionsOnly, EnumerationOptions options)
		{
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			Initialize(getObject: false);
			IEnumWbemClassObject ppEnum = null;
			EnumerationOptions enumerationOptions = ((options != null) ? options : new EnumerationOptions());
			RelatedObjectQuery relatedObjectQuery = new RelatedObjectQuery(path.Path, relatedClass, relationshipClass, relationshipQualifier, relatedQualifier, relatedRole, thisRole, classDefinitionsOnly);
			enumerationOptions.EnumerateDeep = true;
			SecurityHandler securityHandler = null;
			int num = 0;
			try
			{
				securityHandler = scope.GetSecurityHandler();
				num = scope.GetSecuredIWbemServicesHandler(scope.GetIWbemServices()).ExecQuery_(relatedObjectQuery.QueryLanguage, relatedObjectQuery.QueryString, enumerationOptions.Flags, enumerationOptions.GetContext(), ref ppEnum);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}
			finally
			{
				securityHandler?.Reset();
			}
			return new ManagementObjectCollection(scope, enumerationOptions, ppEnum);
		}

		/// <summary>Gets a collection of objects related to the object (associators) asynchronously. This call returns immediately, and a delegate is called when the results are available.</summary>
		/// <param name="watcher">The object to use to return results.</param>
		public void GetRelated(ManagementOperationObserver watcher)
		{
			GetRelated(watcher, null);
		}

		/// <summary>Gets a collection of objects related to the object (associators).</summary>
		/// <param name="watcher">The object to use to return results.</param>
		/// <param name="relatedClass">The class of related objects.</param>
		public void GetRelated(ManagementOperationObserver watcher, string relatedClass)
		{
			GetRelated(watcher, relatedClass, null, null, null, null, null, classDefinitionsOnly: false, null);
		}

		/// <summary>Gets a collection of objects related to the object (associators).</summary>
		/// <param name="watcher">The object to use to return results.</param>
		/// <param name="relatedClass">The class of the related objects.</param>
		/// <param name="relationshipClass">The relationship class of interest.</param>
		/// <param name="relationshipQualifier">The qualifier required to be present on the relationship class.</param>
		/// <param name="relatedQualifier">The qualifier required to be present on the related class.</param>
		/// <param name="relatedRole">The role that the related class is playing in the relationship.</param>
		/// <param name="thisRole">The role that this class is playing in the relationship.</param>
		/// <param name="classDefinitionsOnly">Return only class definitions for the instances that match the query.</param>
		/// <param name="options">Extended options for how to execute the query.</param>
		public void GetRelated(ManagementOperationObserver watcher, string relatedClass, string relationshipClass, string relationshipQualifier, string relatedQualifier, string relatedRole, string thisRole, bool classDefinitionsOnly, EnumerationOptions options)
		{
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			Initialize(getObject: true);
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			EnumerationOptions enumerationOptions = ((options != null) ? ((EnumerationOptions)options.Clone()) : new EnumerationOptions());
			enumerationOptions.ReturnImmediately = false;
			if (watcher.HaveListenersForProgress)
			{
				enumerationOptions.SendStatus = true;
			}
			WmiEventSink newSink = watcher.GetNewSink(scope, enumerationOptions.Context);
			RelatedObjectQuery relatedObjectQuery = new RelatedObjectQuery(path.Path, relatedClass, relationshipClass, relationshipQualifier, relatedQualifier, relatedRole, thisRole, classDefinitionsOnly);
			enumerationOptions.EnumerateDeep = true;
			SecurityHandler securityHandler = null;
			int num = 0;
			securityHandler = scope.GetSecurityHandler();
			num = scope.GetSecuredIWbemServicesHandler(scope.GetIWbemServices()).ExecQueryAsync_(relatedObjectQuery.QueryLanguage, relatedObjectQuery.QueryString, enumerationOptions.Flags, enumerationOptions.GetContext(), newSink.Stub);
			securityHandler.Reset();
			if (num < 0)
			{
				watcher.RemoveSink(newSink);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Gets a collection of associations to the object.</summary>
		/// <returns>A <see cref="T:System.Management.ManagementObjectCollection" /> containing the association objects.</returns>
		public ManagementObjectCollection GetRelationships()
		{
			return GetRelationships((string)null);
		}

		/// <summary>Gets a collection of associations to the object.</summary>
		/// <param name="relationshipClass">The associations to include.</param>
		/// <returns>A <see cref="T:System.Management.ManagementObjectCollection" /> containing the association objects.</returns>
		public ManagementObjectCollection GetRelationships(string relationshipClass)
		{
			return GetRelationships(relationshipClass, null, null, classDefinitionsOnly: false, null);
		}

		/// <summary>Gets a collection of associations to the object.</summary>
		/// <param name="relationshipClass">The type of relationship of interest.</param>
		/// <param name="relationshipQualifier">The qualifier to be present on the relationship.</param>
		/// <param name="thisRole">The role of this object in the relationship.</param>
		/// <param name="classDefinitionsOnly">When this method returns, it contains only the class definitions for the result set.</param>
		/// <param name="options">The extended options for the query execution.</param>
		/// <returns>A <see cref="T:System.Management.ManagementObjectCollection" /> containing the association objects.</returns>
		public ManagementObjectCollection GetRelationships(string relationshipClass, string relationshipQualifier, string thisRole, bool classDefinitionsOnly, EnumerationOptions options)
		{
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			Initialize(getObject: false);
			IEnumWbemClassObject ppEnum = null;
			EnumerationOptions enumerationOptions = ((options != null) ? options : new EnumerationOptions());
			RelationshipQuery relationshipQuery = new RelationshipQuery(path.Path, relationshipClass, relationshipQualifier, thisRole, classDefinitionsOnly);
			enumerationOptions.EnumerateDeep = true;
			SecurityHandler securityHandler = null;
			int num = 0;
			try
			{
				securityHandler = scope.GetSecurityHandler();
				num = scope.GetSecuredIWbemServicesHandler(scope.GetIWbemServices()).ExecQuery_(relationshipQuery.QueryLanguage, relationshipQuery.QueryString, enumerationOptions.Flags, enumerationOptions.GetContext(), ref ppEnum);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}
			finally
			{
				securityHandler?.Reset();
			}
			return new ManagementObjectCollection(scope, enumerationOptions, ppEnum);
		}

		/// <summary>Gets a collection of associations to the object.</summary>
		/// <param name="watcher">The object to use to return results.</param>
		public void GetRelationships(ManagementOperationObserver watcher)
		{
			GetRelationships(watcher, null);
		}

		/// <summary>Gets a collection of associations to the object.</summary>
		/// <param name="watcher">The object to use to return results.</param>
		/// <param name="relationshipClass">The associations to include.</param>
		public void GetRelationships(ManagementOperationObserver watcher, string relationshipClass)
		{
			GetRelationships(watcher, relationshipClass, null, null, classDefinitionsOnly: false, null);
		}

		/// <summary>Gets a collection of associations to the object.</summary>
		/// <param name="watcher">The object to use to return results.</param>
		/// <param name="relationshipClass">The type of relationship of interest.</param>
		/// <param name="relationshipQualifier">The qualifier to be present on the relationship.</param>
		/// <param name="thisRole">The role of this object in the relationship.</param>
		/// <param name="classDefinitionsOnly">When this method returns, it contains only the class definitions for the result set.</param>
		/// <param name="options">The extended options for the query execution.</param>
		public void GetRelationships(ManagementOperationObserver watcher, string relationshipClass, string relationshipQualifier, string thisRole, bool classDefinitionsOnly, EnumerationOptions options)
		{
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			Initialize(getObject: false);
			EnumerationOptions enumerationOptions = ((options != null) ? ((EnumerationOptions)options.Clone()) : new EnumerationOptions());
			enumerationOptions.ReturnImmediately = false;
			if (watcher.HaveListenersForProgress)
			{
				enumerationOptions.SendStatus = true;
			}
			WmiEventSink newSink = watcher.GetNewSink(scope, enumerationOptions.Context);
			RelationshipQuery relationshipQuery = new RelationshipQuery(path.Path, relationshipClass, relationshipQualifier, thisRole, classDefinitionsOnly);
			enumerationOptions.EnumerateDeep = true;
			SecurityHandler securityHandler = null;
			int num = 0;
			securityHandler = scope.GetSecurityHandler();
			num = scope.GetSecuredIWbemServicesHandler(scope.GetIWbemServices()).ExecQueryAsync_(relationshipQuery.QueryLanguage, relationshipQuery.QueryString, enumerationOptions.Flags, enumerationOptions.GetContext(), newSink.Stub);
			securityHandler?.Reset();
			if (num < 0)
			{
				watcher.RemoveSink(newSink);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Commits the changes to the object.</summary>
		/// <returns>A <see cref="T:System.Management.ManagementPath" /> containing the path to the committed object.</returns>
		public ManagementPath Put()
		{
			return Put((PutOptions)null);
		}

		/// <summary>Commits the changes to the object.</summary>
		/// <param name="options">The options for how to commit the changes.</param>
		/// <returns>A <see cref="T:System.Management.ManagementPath" /> containing the path to the committed object.</returns>
		public ManagementPath Put(PutOptions options)
		{
			ManagementPath managementPath = null;
			Initialize(getObject: true);
			PutOptions putOptions = ((options != null) ? options : new PutOptions());
			IWbemServices iWbemServices = scope.GetIWbemServices();
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IWbemCallResult wbemCallResult = null;
			SecurityHandler securityHandler = null;
			int num = 0;
			try
			{
				securityHandler = scope.GetSecurityHandler();
				intPtr = Marshal.AllocHGlobal(IntPtr.Size);
				Marshal.WriteIntPtr(intPtr, IntPtr.Zero);
				if (base.IsClass)
				{
					num = scope.GetSecuredIWbemServicesHandler(iWbemServices).PutClass_(base.wbemObject, putOptions.Flags | 0x10, putOptions.GetContext(), intPtr);
				}
				else
				{
					num = scope.GetSecuredIWbemServicesHandler(iWbemServices).PutInstance_(base.wbemObject, putOptions.Flags | 0x10, putOptions.GetContext(), intPtr);
				}
				intPtr2 = Marshal.ReadIntPtr(intPtr);
				wbemCallResult = (IWbemCallResult)Marshal.GetObjectForIUnknown(intPtr2);
				num = wbemCallResult.GetCallStatus_(-1, out var plStatus);
				if (num >= 0)
				{
					num = plStatus;
				}
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				managementPath = GetPath(wbemCallResult);
			}
			finally
			{
				securityHandler?.Reset();
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.Release(intPtr2);
				}
				if (wbemCallResult != null)
				{
					Marshal.ReleaseComObject(wbemCallResult);
				}
			}
			putButNotGot = true;
			path.SetRelativePath(managementPath.RelativePath);
			return managementPath;
		}

		private ManagementPath GetPath(IWbemCallResult callResult)
		{
			ManagementPath managementPath = null;
			int num = 0;
			try
			{
				string pstrResultString = null;
				num = callResult.GetResultString_(-1, out pstrResultString);
				if (num >= 0)
				{
					managementPath = new ManagementPath(scope.Path.Path);
					managementPath.RelativePath = pstrResultString;
				}
				else
				{
					object propertyValue = GetPropertyValue("__PATH");
					if (propertyValue != null)
					{
						managementPath = new ManagementPath((string)propertyValue);
					}
					else
					{
						propertyValue = GetPropertyValue("__RELPATH");
						if (propertyValue != null)
						{
							managementPath = new ManagementPath(scope.Path.Path);
							managementPath.RelativePath = (string)propertyValue;
						}
					}
				}
			}
			catch
			{
			}
			if (managementPath == null)
			{
				managementPath = new ManagementPath();
			}
			return managementPath;
		}

		/// <summary>Commits the changes to the object, asynchronously.</summary>
		/// <param name="watcher">A <see cref="T:System.Management.ManagementOperationObserver" /> used to handle the progress and results of the asynchronous operation.</param>
		public void Put(ManagementOperationObserver watcher)
		{
			Put(watcher, null);
		}

		/// <summary>Commits the changes to the object asynchronously and using the specified options.</summary>
		/// <param name="watcher">A <see cref="T:System.Management.ManagementOperationObserver" /> used to handle the progress and results of the asynchronous operation.</param>
		/// <param name="options">A <see cref="T:System.Management.PutOptions" /> used to specify additional options for the commit operation.</param>
		public void Put(ManagementOperationObserver watcher, PutOptions options)
		{
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			Initialize(getObject: false);
			PutOptions putOptions = ((options == null) ? new PutOptions() : ((PutOptions)options.Clone()));
			if (watcher.HaveListenersForProgress)
			{
				putOptions.SendStatus = true;
			}
			IWbemServices iWbemServices = scope.GetIWbemServices();
			WmiEventSink newPutSink = watcher.GetNewPutSink(scope, putOptions.Context, scope.Path.GetNamespacePath(8), base.ClassName);
			newPutSink.InternalObjectPut += HandleObjectPut;
			SecurityHandler securityHandler = null;
			int num = -2147217407;
			securityHandler = scope.GetSecurityHandler();
			num = ((!base.IsClass) ? scope.GetSecuredIWbemServicesHandler(iWbemServices).PutInstanceAsync_(base.wbemObject, putOptions.Flags, putOptions.GetContext(), newPutSink.Stub) : scope.GetSecuredIWbemServicesHandler(iWbemServices).PutClassAsync_(base.wbemObject, putOptions.Flags, putOptions.GetContext(), newPutSink.Stub));
			securityHandler?.Reset();
			if (num < 0)
			{
				newPutSink.InternalObjectPut -= HandleObjectPut;
				watcher.RemoveSink(newPutSink);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		internal void HandleObjectPut(object sender, InternalObjectPutEventArgs e)
		{
			try
			{
				if (sender is WmiEventSink)
				{
					((WmiEventSink)sender).InternalObjectPut -= HandleObjectPut;
					putButNotGot = true;
					path.SetRelativePath(e.Path.RelativePath);
				}
			}
			catch
			{
			}
		}

		/// <summary>Copies the object to a different location.</summary>
		/// <param name="path">The <see cref="T:System.Management.ManagementPath" /> to which the object should be copied.</param>
		/// <returns>The new path of the copied object.</returns>
		public ManagementPath CopyTo(ManagementPath path)
		{
			return CopyTo(path, null);
		}

		/// <summary>Copies the object to a different location.</summary>
		/// <param name="path">The path to which the object should be copied.</param>
		/// <returns>The new path of the copied object.</returns>
		public ManagementPath CopyTo(string path)
		{
			return CopyTo(new ManagementPath(path), null);
		}

		/// <summary>Copies the object to a different location.</summary>
		/// <param name="path">The path to which the object should be copied.</param>
		/// <param name="options">The options for how the object should be put.</param>
		/// <returns>The new path of the copied object.</returns>
		public ManagementPath CopyTo(string path, PutOptions options)
		{
			return CopyTo(new ManagementPath(path), options);
		}

		/// <summary>Copies the object to a different location.</summary>
		/// <param name="path">The <see cref="T:System.Management.ManagementPath" /> to which the object should be copied.</param>
		/// <param name="options">The options for how the object should be put.</param>
		/// <returns>The new path of the copied object.</returns>
		public ManagementPath CopyTo(ManagementPath path, PutOptions options)
		{
			Initialize(getObject: false);
			ManagementScope managementScope = null;
			managementScope = new ManagementScope(path, scope);
			managementScope.Initialize();
			PutOptions putOptions = ((options != null) ? options : new PutOptions());
			IWbemServices iWbemServices = managementScope.GetIWbemServices();
			ManagementPath managementPath = null;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IWbemCallResult wbemCallResult = null;
			SecurityHandler securityHandler = null;
			int num = 0;
			try
			{
				securityHandler = managementScope.GetSecurityHandler();
				intPtr = Marshal.AllocHGlobal(IntPtr.Size);
				Marshal.WriteIntPtr(intPtr, IntPtr.Zero);
				if (base.IsClass)
				{
					num = scope.GetSecuredIWbemServicesHandler(iWbemServices).PutClass_(base.wbemObject, putOptions.Flags | 0x10, putOptions.GetContext(), intPtr);
				}
				else
				{
					num = scope.GetSecuredIWbemServicesHandler(iWbemServices).PutInstance_(base.wbemObject, putOptions.Flags | 0x10, putOptions.GetContext(), intPtr);
				}
				intPtr2 = Marshal.ReadIntPtr(intPtr);
				wbemCallResult = (IWbemCallResult)Marshal.GetObjectForIUnknown(intPtr2);
				num = wbemCallResult.GetCallStatus_(-1, out var plStatus);
				if (num >= 0)
				{
					num = plStatus;
				}
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				managementPath = GetPath(wbemCallResult);
				managementPath.NamespacePath = path.GetNamespacePath(8);
				return managementPath;
			}
			finally
			{
				securityHandler?.Reset();
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.Release(intPtr2);
				}
				if (wbemCallResult != null)
				{
					Marshal.ReleaseComObject(wbemCallResult);
				}
			}
		}

		/// <summary>Copies the object to a different location, asynchronously.</summary>
		/// <param name="watcher">The object that will receive the results of the operation.</param>
		/// <param name="path">A <see cref="T:System.Management.ManagementPath" /> specifying the path to which the object should be copied.</param>
		public void CopyTo(ManagementOperationObserver watcher, ManagementPath path)
		{
			CopyTo(watcher, path, null);
		}

		/// <summary>Copies the object to a different location, asynchronously.</summary>
		/// <param name="watcher">The object that will receive the results of the operation.</param>
		/// <param name="path">The path to which the object should be copied.</param>
		public void CopyTo(ManagementOperationObserver watcher, string path)
		{
			CopyTo(watcher, new ManagementPath(path), null);
		}

		/// <summary>Copies the object to a different location, asynchronously.</summary>
		/// <param name="watcher">The object that will receive the results of the operation.</param>
		/// <param name="path">The path to which the object should be copied.</param>
		/// <param name="options">The options for how the object should be put.</param>
		public void CopyTo(ManagementOperationObserver watcher, string path, PutOptions options)
		{
			CopyTo(watcher, new ManagementPath(path), options);
		}

		/// <summary>Copies the object to a different location, asynchronously.</summary>
		/// <param name="watcher">The object that will receive the results of the operation.</param>
		/// <param name="path">The path to which the object should be copied.</param>
		/// <param name="options">The options for how the object should be put.</param>
		public void CopyTo(ManagementOperationObserver watcher, ManagementPath path, PutOptions options)
		{
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			Initialize(getObject: false);
			ManagementScope managementScope = null;
			managementScope = new ManagementScope(path, scope);
			managementScope.Initialize();
			PutOptions putOptions = ((options != null) ? ((PutOptions)options.Clone()) : new PutOptions());
			if (watcher.HaveListenersForProgress)
			{
				putOptions.SendStatus = true;
			}
			WmiEventSink newPutSink = watcher.GetNewPutSink(managementScope, putOptions.Context, path.GetNamespacePath(8), base.ClassName);
			IWbemServices iWbemServices = managementScope.GetIWbemServices();
			SecurityHandler securityHandler = null;
			int num = 0;
			securityHandler = managementScope.GetSecurityHandler();
			num = ((!base.IsClass) ? managementScope.GetSecuredIWbemServicesHandler(iWbemServices).PutInstanceAsync_(base.wbemObject, putOptions.Flags, putOptions.GetContext(), newPutSink.Stub) : managementScope.GetSecuredIWbemServicesHandler(iWbemServices).PutClassAsync_(base.wbemObject, putOptions.Flags, putOptions.GetContext(), newPutSink.Stub));
			securityHandler?.Reset();
			if (num < 0)
			{
				watcher.RemoveSink(newPutSink);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Deletes the object.</summary>
		public void Delete()
		{
			Delete((DeleteOptions)null);
		}

		/// <summary>Deletes the object.</summary>
		/// <param name="options">The options for how to delete the object.</param>
		public void Delete(DeleteOptions options)
		{
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			Initialize(getObject: false);
			DeleteOptions deleteOptions = ((options != null) ? options : new DeleteOptions());
			IWbemServices iWbemServices = scope.GetIWbemServices();
			SecurityHandler securityHandler = null;
			int num = 0;
			try
			{
				securityHandler = scope.GetSecurityHandler();
				num = ((!base.IsClass) ? scope.GetSecuredIWbemServicesHandler(iWbemServices).DeleteInstance_(path.RelativePath, deleteOptions.Flags, deleteOptions.GetContext(), IntPtr.Zero) : scope.GetSecuredIWbemServicesHandler(iWbemServices).DeleteClass_(path.RelativePath, deleteOptions.Flags, deleteOptions.GetContext(), IntPtr.Zero));
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}
			finally
			{
				securityHandler?.Reset();
			}
		}

		/// <summary>Deletes the object.</summary>
		/// <param name="watcher">The object that will receive the results of the operation.</param>
		public void Delete(ManagementOperationObserver watcher)
		{
			Delete(watcher, null);
		}

		/// <summary>Deletes the object.</summary>
		/// <param name="watcher">The object that will receive the results of the operation.</param>
		/// <param name="options">The options for how to delete the object.</param>
		public void Delete(ManagementOperationObserver watcher, DeleteOptions options)
		{
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			Initialize(getObject: false);
			DeleteOptions deleteOptions = ((options != null) ? ((DeleteOptions)options.Clone()) : new DeleteOptions());
			if (watcher.HaveListenersForProgress)
			{
				deleteOptions.SendStatus = true;
			}
			IWbemServices iWbemServices = scope.GetIWbemServices();
			WmiEventSink newSink = watcher.GetNewSink(scope, deleteOptions.Context);
			SecurityHandler securityHandler = null;
			int num = 0;
			securityHandler = scope.GetSecurityHandler();
			num = ((!base.IsClass) ? scope.GetSecuredIWbemServicesHandler(iWbemServices).DeleteInstanceAsync_(path.RelativePath, deleteOptions.Flags, deleteOptions.GetContext(), newSink.Stub) : scope.GetSecuredIWbemServicesHandler(iWbemServices).DeleteClassAsync_(path.RelativePath, deleteOptions.Flags, deleteOptions.GetContext(), newSink.Stub));
			securityHandler?.Reset();
			if (num < 0)
			{
				watcher.RemoveSink(newSink);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Invokes a method on the object.</summary>
		/// <param name="methodName">The name of the method to execute.</param>
		/// <param name="args">An array containing parameter values.</param>
		/// <returns>The object value returned by the method.</returns>
		public object InvokeMethod(string methodName, object[] args)
		{
			object obj = null;
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			if (methodName == null)
			{
				throw new ArgumentNullException("methodName");
			}
			Initialize(getObject: false);
			GetMethodParameters(methodName, out var inParameters, out var inParametersClass, out var outParametersClass);
			MapInParameters(args, inParameters, inParametersClass);
			ManagementBaseObject outParams = InvokeMethod(methodName, inParameters, null);
			return MapOutParameters(args, outParams, outParametersClass);
		}

		/// <summary>Invokes a method on the object, asynchronously.</summary>
		/// <param name="watcher">The object to receive the results of the operation.</param>
		/// <param name="methodName">The name of the method to execute.</param>
		/// <param name="args">An array containing parameter values.</param>
		public void InvokeMethod(ManagementOperationObserver watcher, string methodName, object[] args)
		{
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			if (methodName == null)
			{
				throw new ArgumentNullException("methodName");
			}
			Initialize(getObject: false);
			GetMethodParameters(methodName, out var inParameters, out var inParametersClass, out var _);
			MapInParameters(args, inParameters, inParametersClass);
			InvokeMethod(watcher, methodName, inParameters, null);
		}

		/// <summary>Invokes a method on the WMI object. The input and output parameters are represented as <see cref="T:System.Management.ManagementBaseObject" /> objects.</summary>
		/// <param name="methodName">The name of the method to execute.</param>
		/// <param name="inParameters">A <see cref="T:System.Management.ManagementBaseObject" /> holding the input parameters to the method.</param>
		/// <param name="options">An <see cref="T:System.Management.InvokeMethodOptions" /> containing additional options for the execution of the method.</param>
		/// <returns>A <see cref="T:System.Management.ManagementBaseObject" /> containing the output parameters and return value of the executed method.</returns>
		public ManagementBaseObject InvokeMethod(string methodName, ManagementBaseObject inParameters, InvokeMethodOptions options)
		{
			ManagementBaseObject result = null;
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			if (methodName == null)
			{
				throw new ArgumentNullException("methodName");
			}
			Initialize(getObject: false);
			InvokeMethodOptions invokeMethodOptions = ((options != null) ? options : new InvokeMethodOptions());
			IWbemServices iWbemServices = scope.GetIWbemServices();
			SecurityHandler securityHandler = null;
			int num = 0;
			try
			{
				securityHandler = scope.GetSecurityHandler();
				IWbemClassObjectFreeThreaded pInParams = inParameters?.wbemObject;
				IWbemClassObjectFreeThreaded ppOutParams = null;
				num = scope.GetSecuredIWbemServicesHandler(scope.GetIWbemServices()).ExecMethod_(path.RelativePath, methodName, invokeMethodOptions.Flags, invokeMethodOptions.GetContext(), pInParams, ref ppOutParams, IntPtr.Zero);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				if (ppOutParams != null)
				{
					return new ManagementBaseObject(ppOutParams);
				}
				return result;
			}
			finally
			{
				securityHandler?.Reset();
			}
		}

		/// <summary>Invokes a method on the object, asynchronously.</summary>
		/// <param name="watcher">A <see cref="T:System.Management.ManagementOperationObserver" /> used to handle the asynchronous execution's progress and results.</param>
		/// <param name="methodName">The name of the method to be executed.</param>
		/// <param name="inParameters">A <see cref="T:System.Management.ManagementBaseObject" /> containing the input parameters for the method.</param>
		/// <param name="options">An <see cref="T:System.Management.InvokeMethodOptions" /> containing additional options used to execute the method.</param>
		public void InvokeMethod(ManagementOperationObserver watcher, string methodName, ManagementBaseObject inParameters, InvokeMethodOptions options)
		{
			if (path == null || path.Path.Length == 0)
			{
				throw new InvalidOperationException();
			}
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			if (methodName == null)
			{
				throw new ArgumentNullException("methodName");
			}
			Initialize(getObject: false);
			InvokeMethodOptions invokeMethodOptions = ((options != null) ? ((InvokeMethodOptions)options.Clone()) : new InvokeMethodOptions());
			if (watcher.HaveListenersForProgress)
			{
				invokeMethodOptions.SendStatus = true;
			}
			WmiEventSink newSink = watcher.GetNewSink(scope, invokeMethodOptions.Context);
			SecurityHandler securityHandler = null;
			int num = 0;
			securityHandler = scope.GetSecurityHandler();
			IWbemClassObjectFreeThreaded pInParams = null;
			if (inParameters != null)
			{
				pInParams = inParameters.wbemObject;
			}
			num = scope.GetSecuredIWbemServicesHandler(scope.GetIWbemServices()).ExecMethodAsync_(path.RelativePath, methodName, invokeMethodOptions.Flags, invokeMethodOptions.GetContext(), pInParams, newSink.Stub);
			securityHandler?.Reset();
			if (num < 0)
			{
				watcher.RemoveSink(newSink);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Returns a <see cref="T:System.Management.ManagementBaseObject" /> representing the list of input parameters for a method.</summary>
		/// <param name="methodName">The name of the method.</param>
		/// <returns>A <see cref="T:System.Management.ManagementBaseObject" /> containing the input parameters to the method.</returns>
		public ManagementBaseObject GetMethodParameters(string methodName)
		{
			GetMethodParameters(methodName, out var inParameters, out var _, out var _);
			return inParameters;
		}

		private void GetMethodParameters(string methodName, out ManagementBaseObject inParameters, out IWbemClassObjectFreeThreaded inParametersClass, out IWbemClassObjectFreeThreaded outParametersClass)
		{
			inParameters = null;
			inParametersClass = null;
			outParametersClass = null;
			if (methodName == null)
			{
				throw new ArgumentNullException("methodName");
			}
			Initialize(getObject: false);
			if (wmiClass == null)
			{
				ManagementPath classPath = ClassPath;
				if (classPath == null || !classPath.IsClass)
				{
					throw new InvalidOperationException();
				}
				ManagementClass managementClass = new ManagementClass(scope, classPath, null);
				managementClass.Get();
				wmiClass = managementClass.wbemObject;
			}
			int num = 0;
			num = wmiClass.GetMethod_(methodName, 0, out inParametersClass, out outParametersClass);
			if (num == -2147217406)
			{
				num = -2147217323;
			}
			if (num >= 0 && inParametersClass != null)
			{
				IWbemClassObjectFreeThreaded ppNewInstance = null;
				num = inParametersClass.SpawnInstance_(0, out ppNewInstance);
				if (num >= 0)
				{
					inParameters = new ManagementBaseObject(ppNewInstance);
				}
			}
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Creates a copy of the object.</summary>
		/// <returns>The copied object.</returns>
		public override object Clone()
		{
			if (PutButNotGot)
			{
				Get();
				PutButNotGot = false;
			}
			IWbemClassObjectFreeThreaded ppCopy = null;
			int num = base.wbemObject.Clone_(out ppCopy);
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return GetManagementObject(ppCopy, this);
		}

		/// <summary>Returns the full path of the object. This is an override of the default object implementation.</summary>
		/// <returns>The full path of the object.</returns>
		public override string ToString()
		{
			if (path != null)
			{
				return path.Path;
			}
			return "";
		}

		internal override void Initialize(bool getObject)
		{
			bool flag = false;
			lock (this)
			{
				if (path == null)
				{
					path = new ManagementPath();
					path.IdentifierChanged += HandleIdentifierChange;
				}
				if (!IsBound && getObject)
				{
					flag = true;
				}
				if (scope == null)
				{
					string namespacePath = path.GetNamespacePath(8);
					if (0 < namespacePath.Length)
					{
						scope = new ManagementScope(namespacePath);
					}
					else
					{
						scope = new ManagementScope();
					}
					scope.IdentifierChanged += HandleIdentifierChange;
				}
				else if (scope.Path == null || scope.Path.IsEmpty)
				{
					string namespacePath2 = path.GetNamespacePath(8);
					if (0 < namespacePath2.Length)
					{
						scope.Path = new ManagementPath(namespacePath2);
					}
					else
					{
						scope.Path = ManagementPath.DefaultPath;
					}
				}
				lock (scope)
				{
					if (!scope.IsConnected)
					{
						scope.Initialize();
						if (getObject)
						{
							flag = true;
						}
					}
					if (!flag)
					{
						return;
					}
					if (options == null)
					{
						options = new ObjectGetOptions();
						options.IdentifierChanged += HandleIdentifierChange;
					}
					IWbemClassObjectFreeThreaded ppObject = null;
					IWbemServices iWbemServices = scope.GetIWbemServices();
					SecurityHandler securityHandler = null;
					int num = 0;
					try
					{
						securityHandler = scope.GetSecurityHandler();
						string strObjectPath = null;
						string relativePath = path.RelativePath;
						if (relativePath.Length > 0)
						{
							strObjectPath = relativePath;
						}
						num = scope.GetSecuredIWbemServicesHandler(iWbemServices).GetObject_(strObjectPath, options.Flags, options.GetContext(), ref ppObject, IntPtr.Zero);
						if (num >= 0)
						{
							base.wbemObject = ppObject;
							object pVal = null;
							int pType = 0;
							int plFlavor = 0;
							num = base.wbemObject.Get_("__PATH", 0, ref pVal, ref pType, ref plFlavor);
							if (num >= 0)
							{
								path = ((DBNull.Value != pVal) ? new ManagementPath((string)pVal) : new ManagementPath());
								path.IdentifierChanged += HandleIdentifierChange;
							}
						}
						if (num < 0)
						{
							if ((num & 0xFFFFF000u) == 2147749888u)
							{
								ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
							}
							else
							{
								Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
							}
						}
					}
					finally
					{
						securityHandler?.Reset();
					}
				}
			}
		}

		private static void MapInParameters(object[] args, ManagementBaseObject inParams, IWbemClassObjectFreeThreaded inParamsClass)
		{
			int num = 0;
			if (inParamsClass == null || args == null || args.Length == 0)
			{
				return;
			}
			int upperBound = args.GetUpperBound(0);
			int lowerBound = args.GetLowerBound(0);
			int num2 = upperBound - lowerBound;
			num = inParamsClass.BeginEnumeration_(64);
			if (num >= 0)
			{
				do
				{
					object pVal = null;
					int pType = 0;
					string strName = null;
					IWbemQualifierSetFreeThreaded ppQualSet = null;
					num = inParamsClass.Next_(0, ref strName, ref pVal, ref pType, ref pType);
					if (num < 0)
					{
						continue;
					}
					if (strName == null)
					{
						break;
					}
					num = inParamsClass.GetPropertyQualifierSet_(strName, out ppQualSet);
					if (num < 0)
					{
						continue;
					}
					try
					{
						object pVal2 = 0;
						ppQualSet.Get_("ID", 0, ref pVal2, ref pType);
						int num3 = (int)pVal2;
						if (0 <= num3 && num2 >= num3)
						{
							inParams[strName] = args[lowerBound + num3];
						}
					}
					finally
					{
						ppQualSet.Dispose();
					}
				}
				while (num >= 0);
			}
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		private static object MapOutParameters(object[] args, ManagementBaseObject outParams, IWbemClassObjectFreeThreaded outParamsClass)
		{
			object result = null;
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			if (outParamsClass != null)
			{
				if (args != null && args.Length != 0)
				{
					num = args.GetUpperBound(0);
					num2 = args.GetLowerBound(0);
					num3 = num - num2;
				}
				num4 = outParamsClass.BeginEnumeration_(64);
				if (num4 >= 0)
				{
					do
					{
						object pVal = null;
						int pType = 0;
						string strName = null;
						IWbemQualifierSetFreeThreaded ppQualSet = null;
						num4 = outParamsClass.Next_(0, ref strName, ref pVal, ref pType, ref pType);
						if (num4 < 0)
						{
							continue;
						}
						if (strName == null)
						{
							break;
						}
						if (string.Compare(strName, "RETURNVALUE", StringComparison.OrdinalIgnoreCase) == 0)
						{
							result = outParams["RETURNVALUE"];
							continue;
						}
						num4 = outParamsClass.GetPropertyQualifierSet_(strName, out ppQualSet);
						if (num4 < 0)
						{
							continue;
						}
						try
						{
							object pVal2 = 0;
							ppQualSet.Get_("ID", 0, ref pVal2, ref pType);
							int num5 = (int)pVal2;
							if (0 <= num5 && num3 >= num5)
							{
								args[num2 + num5] = outParams[strName];
							}
						}
						finally
						{
							ppQualSet.Dispose();
						}
					}
					while (num4 >= 0);
				}
				if (num4 < 0)
				{
					if ((num4 & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num4);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num4, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}
			return result;
		}
	}
	/// <summary>Represents different collections of management objects retrieved through WMI. The objects in this collection are of <see cref="T:System.Management.ManagementBaseObject" />-derived types, including <see cref="T:System.Management.ManagementObject" /> and <see cref="T:System.Management.ManagementClass" />. The collection can be the result of a WMI query executed through a <see cref="T:System.Management.ManagementObjectSearcher" />, or an enumeration of management objects of a specified type retrieved through a <see cref="T:System.Management.ManagementClass" /> representing that type. In addition, this can be a collection of management objects related in a specified way to a specific management object - in this case the collection would be retrieved through a method such as <see cref="M:System.Management.ManagementObject.GetRelated" />. The collection can be walked using the <see cref="T:System.Management.ManagementObjectCollection.ManagementObjectEnumerator" /> and objects in it can be inspected or manipulated for various management tasks.</summary>
	public class ManagementObjectCollection : ICollection, IEnumerable, IDisposable
	{
		/// <summary>Represents the enumerator on the collection.</summary>
		public class ManagementObjectEnumerator : IEnumerator, IDisposable
		{
			private static readonly string name = typeof(ManagementObjectEnumerator).FullName;

			private IEnumWbemClassObject enumWbem;

			private ManagementObjectCollection collectionObject;

			private uint cachedCount;

			private int cacheIndex;

			private IWbemClassObjectFreeThreaded[] cachedObjects;

			private bool atEndOfCollection;

			private bool isDisposed;

			/// <summary>Gets the current <see cref="T:System.Management.ManagementBaseObject" /> that this enumerator points to.</summary>
			/// <returns>The current object in the enumeration.</returns>
			public ManagementBaseObject Current
			{
				get
				{
					if (isDisposed)
					{
						throw new ObjectDisposedException(name);
					}
					if (cacheIndex < 0)
					{
						throw new InvalidOperationException();
					}
					return ManagementBaseObject.GetBaseObject(cachedObjects[cacheIndex], collectionObject.scope);
				}
			}

			/// <summary>Gets the current object in the collection.</summary>
			/// <returns>The current element in the collection.</returns>
			/// <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
			object IEnumerator.Current => Current;

			internal ManagementObjectEnumerator(ManagementObjectCollection collectionObject, IEnumWbemClassObject enumWbem)
			{
				this.enumWbem = enumWbem;
				this.collectionObject = collectionObject;
				cachedObjects = new IWbemClassObjectFreeThreaded[collectionObject.options.BlockSize];
				cachedCount = 0u;
				cacheIndex = -1;
				atEndOfCollection = false;
			}

			/// <summary>Disposes of resources the object is holding. This is the destructor for the object. Finalizers are expressed using destructor syntax.</summary>
			~ManagementObjectEnumerator()
			{
				Dispose();
			}

			/// <summary>Releases resources associated with this object. After this method has been called, an attempt to use this object will result in an <see cref="T:System.ObjectDisposedException" /> exception being thrown.</summary>
			public void Dispose()
			{
				if (!isDisposed)
				{
					if (enumWbem != null)
					{
						Marshal.ReleaseComObject(enumWbem);
						enumWbem = null;
					}
					cachedObjects = null;
					collectionObject = null;
					isDisposed = true;
					GC.SuppressFinalize(this);
				}
			}

			/// <summary>Indicates whether the enumerator has moved to the next object in the enumeration.</summary>
			/// <returns>
			///   <see langword="true" />, if the enumerator was successfully advanced to the next element; <see langword="false" /> if the enumerator has passed the end of the collection.</returns>
			public bool MoveNext()
			{
				if (isDisposed)
				{
					throw new ObjectDisposedException(name);
				}
				if (atEndOfCollection)
				{
					return false;
				}
				cacheIndex++;
				if (cachedCount - cacheIndex == 0L)
				{
					int lTimeout = ((collectionObject.options.Timeout.Ticks == long.MaxValue) ? (-1) : ((int)collectionObject.options.Timeout.TotalMilliseconds));
					SecurityHandler securityHandler = collectionObject.scope.GetSecurityHandler();
					IWbemClassObject_DoNotMarshal[] array = new IWbemClassObject_DoNotMarshal[collectionObject.options.BlockSize];
					int num = collectionObject.scope.GetSecuredIEnumWbemClassObjectHandler(enumWbem).Next_(lTimeout, (uint)collectionObject.options.BlockSize, array, ref cachedCount);
					securityHandler.Reset();
					if (num >= 0)
					{
						for (int i = 0; i < cachedCount; i++)
						{
							cachedObjects[i] = new IWbemClassObjectFreeThreaded(Marshal.GetIUnknownForObject(array[i]));
						}
					}
					if (num < 0)
					{
						if ((num & 0xFFFFF000u) == 2147749888u)
						{
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
						}
						else
						{
							Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
						}
					}
					else
					{
						if (num == 262148 && cachedCount == 0)
						{
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
						}
						if (num == 1 && cachedCount == 0)
						{
							atEndOfCollection = true;
							cacheIndex--;
							return false;
						}
					}
					cacheIndex = 0;
				}
				return true;
			}

			/// <summary>Resets the enumerator to the beginning of the collection.</summary>
			public void Reset()
			{
				if (isDisposed)
				{
					throw new ObjectDisposedException(name);
				}
				if (!collectionObject.options.Rewindable)
				{
					throw new InvalidOperationException();
				}
				SecurityHandler securityHandler = collectionObject.scope.GetSecurityHandler();
				int num = 0;
				try
				{
					num = collectionObject.scope.GetSecuredIEnumWbemClassObjectHandler(enumWbem).Reset_();
				}
				catch (COMException e)
				{
					ManagementException.ThrowWithExtendedInfo(e);
				}
				finally
				{
					securityHandler.Reset();
				}
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else if ((num & 0x80000000u) != 0L)
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
				for (int i = ((cacheIndex >= 0) ? cacheIndex : 0); i < cachedCount; i++)
				{
					Marshal.ReleaseComObject((IWbemClassObject_DoNotMarshal)Marshal.GetObjectForIUnknown(cachedObjects[i]));
				}
				cachedCount = 0u;
				cacheIndex = -1;
				atEndOfCollection = false;
			}
		}

		private static readonly string name = typeof(ManagementObjectCollection).FullName;

		internal ManagementScope scope;

		internal EnumerationOptions options;

		private IEnumWbemClassObject enumWbem;

		private bool isDisposed;

		/// <summary>Gets a value indicating the number of objects in the collection.</summary>
		/// <returns>The number of objects in the collection.</returns>
		public int Count
		{
			get
			{
				if (isDisposed)
				{
					throw new ObjectDisposedException(name);
				}
				int num = 0;
				IEnumerator enumerator = GetEnumerator();
				while (enumerator.MoveNext())
				{
					num++;
				}
				return num;
			}
		}

		/// <summary>Gets a value that indicates whether the object is synchronized (thread-safe).</summary>
		/// <returns>
		///   <see langword="true" /> if the object is synchronized; otherwise, <see langword="false" />.</returns>
		public bool IsSynchronized
		{
			get
			{
				if (isDisposed)
				{
					throw new ObjectDisposedException(name);
				}
				return false;
			}
		}

		/// <summary>Gets the object to be used for synchronization.</summary>
		/// <returns>An object that can be used for synchronization.</returns>
		public object SyncRoot
		{
			get
			{
				if (isDisposed)
				{
					throw new ObjectDisposedException(name);
				}
				return this;
			}
		}

		internal ManagementObjectCollection(ManagementScope scope, EnumerationOptions options, IEnumWbemClassObject enumWbem)
		{
			if (options != null)
			{
				this.options = (EnumerationOptions)options.Clone();
			}
			else
			{
				this.options = new EnumerationOptions();
			}
			if (scope != null)
			{
				this.scope = scope.Clone();
			}
			else
			{
				this.scope = ManagementScope._Clone(null);
			}
			this.enumWbem = enumWbem;
		}

		/// <summary>Disposes of resources the object is holding. This is the destructor for the object. Finalizers are expressed using destructor syntax.</summary>
		~ManagementObjectCollection()
		{
			Dispose(disposing: false);
		}

		/// <summary>Releases resources associated with this object. After this method has been called, an attempt to use this object will result in an <see cref="T:System.ObjectDisposedException" /> being thrown.</summary>
		public void Dispose()
		{
			if (!isDisposed)
			{
				Dispose(disposing: true);
			}
		}

		private void Dispose(bool disposing)
		{
			if (disposing)
			{
				GC.SuppressFinalize(this);
				isDisposed = true;
			}
			Marshal.ReleaseComObject(enumWbem);
		}

		/// <summary>Copies the collection to an array.</summary>
		/// <param name="array">An array to copy to.</param>
		/// <param name="index">The index to start from.</param>
		public void CopyTo(Array array, int index)
		{
			if (isDisposed)
			{
				throw new ObjectDisposedException(name);
			}
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (index < array.GetLowerBound(0) || index > array.GetUpperBound(0))
			{
				throw new ArgumentOutOfRangeException("index");
			}
			int num = array.Length - index;
			int num2 = 0;
			ArrayList arrayList = new ArrayList();
			ManagementObjectEnumerator enumerator = GetEnumerator();
			while (enumerator.MoveNext())
			{
				ManagementBaseObject current = enumerator.Current;
				arrayList.Add(current);
				num2++;
				if (num2 > num)
				{
					throw new ArgumentException(null, "index");
				}
			}
			arrayList.CopyTo(array, index);
		}

		/// <summary>Copies the items in the collection to a <see cref="T:System.Management.ManagementBaseObject" /> array.</summary>
		/// <param name="objectCollection">The target array.</param>
		/// <param name="index">The index to start from.</param>
		public void CopyTo(ManagementBaseObject[] objectCollection, int index)
		{
			CopyTo((Array)objectCollection, index);
		}

		/// <summary>Returns the enumerator for the collection.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> that can be used to iterate through the collection.</returns>
		public ManagementObjectEnumerator GetEnumerator()
		{
			if (isDisposed)
			{
				throw new ObjectDisposedException(name);
			}
			if (options.Rewindable)
			{
				IEnumWbemClassObject ppEnum = null;
				int num = 0;
				try
				{
					num = scope.GetSecuredIEnumWbemClassObjectHandler(enumWbem).Clone_(ref ppEnum);
					if ((num & 0x80000000u) == 0L)
					{
						num = scope.GetSecuredIEnumWbemClassObjectHandler(ppEnum).Reset_();
					}
				}
				catch (COMException e)
				{
					ManagementException.ThrowWithExtendedInfo(e);
				}
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else if ((num & 0x80000000u) != 0L)
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
				return new ManagementObjectEnumerator(this, ppEnum);
			}
			return new ManagementObjectEnumerator(this, enumWbem);
		}

		/// <summary>Returns an <see cref="T:System.Collections.IEnumerator" /> that iterates through the <see cref="T:System.Management.ManagementObjectCollection" />.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Management.ManagementObjectCollection" />.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	/// <summary>Retrieves a collection of management objects based on a specified query. This class is one of the more commonly used entry points to retrieving management information. For example, it can be used to enumerate all disk drives, network adapters, processes and many more management objects on a system, or to query for all network connections that are up, services that are paused, and so on.  When instantiated, an instance of this class takes as input a WMI query represented in an <see cref="T:System.Management.ObjectQuery" /> or its derivatives, and optionally a <see cref="T:System.Management.ManagementScope" /> representing the WMI namespace to execute the query in. It can also take additional advanced options in an <see cref="T:System.Management.EnumerationOptions" />. When the <see cref="M:System.Management.ManagementObjectSearcher.Get" /> method on this object is invoked, the <see cref="T:System.Management.ManagementObjectSearcher" /> executes the given query in the specified scope and returns a collection of management objects that match the query in a <see cref="T:System.Management.ManagementObjectCollection" />.</summary>
	[ToolboxItem(false)]
	public class ManagementObjectSearcher : Component
	{
		private ManagementScope scope;

		private ObjectQuery query;

		private EnumerationOptions options;

		/// <summary>Gets or sets the scope in which to look for objects (the scope represents a WMI namespace).</summary>
		/// <returns>The scope (namespace) in which to look for the WMI objects.</returns>
		public ManagementScope Scope
		{
			get
			{
				return scope;
			}
			set
			{
				if (value != null)
				{
					scope = value.Clone();
					return;
				}
				throw new ArgumentNullException("value");
			}
		}

		/// <summary>Gets or sets the query to be invoked in the searcher (that is, the criteria to be applied to the search for management objects).</summary>
		/// <returns>The query to be invoked in the searcher.</returns>
		public ObjectQuery Query
		{
			get
			{
				return query;
			}
			set
			{
				if (value != null)
				{
					query = (ObjectQuery)value.Clone();
					return;
				}
				throw new ArgumentNullException("value");
			}
		}

		/// <summary>Gets or sets the options for how to search for objects.</summary>
		/// <returns>The options for searching for WMI objects.</returns>
		public EnumerationOptions Options
		{
			get
			{
				return options;
			}
			set
			{
				if (value != null)
				{
					options = (EnumerationOptions)value.Clone();
					return;
				}
				throw new ArgumentNullException("value");
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObjectSearcher" /> class. After some properties on this object are set, the object can be used to invoke a query for management information. This is the default constructor.</summary>
		public ManagementObjectSearcher()
			: this((ManagementScope)null, (ObjectQuery)null, (EnumerationOptions)null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObjectSearcher" /> class used to invoke the specified query for management information.</summary>
		/// <param name="queryString">The WMI query to be invoked by the object.</param>
		public ManagementObjectSearcher(string queryString)
			: this(null, new ObjectQuery(queryString), null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObjectSearcher" /> class used to invoke the specified query for management information.</summary>
		/// <param name="query">An <see cref="T:System.Management.ObjectQuery" /> representing the query to be invoked by the searcher.</param>
		public ManagementObjectSearcher(ObjectQuery query)
			: this(null, query, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObjectSearcher" /> class used to invoke the specified query in the specified scope.</summary>
		/// <param name="scope">The scope in which to query.</param>
		/// <param name="queryString">The query to be invoked.</param>
		public ManagementObjectSearcher(string scope, string queryString)
			: this(new ManagementScope(scope), new ObjectQuery(queryString), null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObjectSearcher" /> class used to invoke the specified query in the specified scope.</summary>
		/// <param name="scope">A <see cref="T:System.Management.ManagementScope" /> representing the scope in which to invoke the query.</param>
		/// <param name="query">An <see cref="T:System.Management.ObjectQuery" /> representing the query to be invoked.</param>
		public ManagementObjectSearcher(ManagementScope scope, ObjectQuery query)
			: this(scope, query, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObjectSearcher" /> class used to invoke the specified query, in the specified scope, and with the specified options.</summary>
		/// <param name="scope">The scope in which the query should be invoked.</param>
		/// <param name="queryString">The query to be invoked.</param>
		/// <param name="options">An <see cref="T:System.Management.EnumerationOptions" /> specifying additional options for the query.</param>
		public ManagementObjectSearcher(string scope, string queryString, EnumerationOptions options)
			: this(new ManagementScope(scope), new ObjectQuery(queryString), options)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementObjectSearcher" /> class to be used to invoke the specified query in the specified scope, with the specified options.</summary>
		/// <param name="scope">A <see cref="T:System.Management.ManagementScope" /> specifying the scope of the query.</param>
		/// <param name="query">An <see cref="T:System.Management.ObjectQuery" /> specifying the query to be invoked.</param>
		/// <param name="options">An <see cref="T:System.Management.EnumerationOptions" /> specifying additional options to be used for the query.</param>
		public ManagementObjectSearcher(ManagementScope scope, ObjectQuery query, EnumerationOptions options)
		{
			this.scope = ManagementScope._Clone(scope);
			if (query != null)
			{
				this.query = (ObjectQuery)query.Clone();
			}
			else
			{
				this.query = new ObjectQuery();
			}
			if (options != null)
			{
				this.options = (EnumerationOptions)options.Clone();
			}
			else
			{
				this.options = new EnumerationOptions();
			}
		}

		/// <summary>Invokes the specified WMI query and returns the resulting collection.</summary>
		/// <returns>A <see cref="T:System.Management.ManagementObjectCollection" /> containing the objects that match the specified query.</returns>
		public ManagementObjectCollection Get()
		{
			Initialize();
			IEnumWbemClassObject ppEnum = null;
			SecurityHandler securityHandler = scope.GetSecurityHandler();
			EnumerationOptions enumerationOptions = (EnumerationOptions)options.Clone();
			int num = 0;
			try
			{
				if (query.GetType() == typeof(SelectQuery) && ((SelectQuery)query).Condition == null && ((SelectQuery)query).SelectedProperties == null && options.EnumerateDeep)
				{
					enumerationOptions.EnsureLocatable = false;
					enumerationOptions.PrototypeOnly = false;
					num = (((SelectQuery)query).IsSchemaQuery ? scope.GetSecuredIWbemServicesHandler(scope.GetIWbemServices()).CreateClassEnum_(((SelectQuery)query).ClassName, enumerationOptions.Flags, enumerationOptions.GetContext(), ref ppEnum) : scope.GetSecuredIWbemServicesHandler(scope.GetIWbemServices()).CreateInstanceEnum_(((SelectQuery)query).ClassName, enumerationOptions.Flags, enumerationOptions.GetContext(), ref ppEnum));
				}
				else
				{
					enumerationOptions.EnumerateDeep = true;
					num = scope.GetSecuredIWbemServicesHandler(scope.GetIWbemServices()).ExecQuery_(query.QueryLanguage, query.QueryString, enumerationOptions.Flags, enumerationOptions.GetContext(), ref ppEnum);
				}
			}
			catch (COMException e)
			{
				ManagementException.ThrowWithExtendedInfo(e);
			}
			finally
			{
				securityHandler.Reset();
			}
			if ((num & 0xFFFFF000u) == 2147749888u)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
			}
			else if ((num & 0x80000000u) != 0L)
			{
				Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
			}
			return new ManagementObjectCollection(scope, options, ppEnum);
		}

		/// <summary>Invokes the WMI query asynchronously, and binds to a watcher to deliver the results.</summary>
		/// <param name="watcher">The watcher that raises events triggered by the operation.</param>
		public void Get(ManagementOperationObserver watcher)
		{
			if (watcher == null)
			{
				throw new ArgumentNullException("watcher");
			}
			Initialize();
			IWbemServices iWbemServices = scope.GetIWbemServices();
			EnumerationOptions enumerationOptions = (EnumerationOptions)options.Clone();
			enumerationOptions.ReturnImmediately = false;
			if (watcher.HaveListenersForProgress)
			{
				enumerationOptions.SendStatus = true;
			}
			WmiEventSink newSink = watcher.GetNewSink(scope, enumerationOptions.Context);
			SecurityHandler securityHandler = scope.GetSecurityHandler();
			int num = 0;
			try
			{
				if (query.GetType() == typeof(SelectQuery) && ((SelectQuery)query).Condition == null && ((SelectQuery)query).SelectedProperties == null && options.EnumerateDeep)
				{
					enumerationOptions.EnsureLocatable = false;
					enumerationOptions.PrototypeOnly = false;
					num = (((SelectQuery)query).IsSchemaQuery ? scope.GetSecuredIWbemServicesHandler(iWbemServices).CreateClassEnumAsync_(((SelectQuery)query).ClassName, enumerationOptions.Flags, enumerationOptions.GetContext(), newSink.Stub) : scope.GetSecuredIWbemServicesHandler(iWbemServices).CreateInstanceEnumAsync_(((SelectQuery)query).ClassName, enumerationOptions.Flags, enumerationOptions.GetContext(), newSink.Stub));
				}
				else
				{
					enumerationOptions.EnumerateDeep = true;
					num = scope.GetSecuredIWbemServicesHandler(iWbemServices).ExecQueryAsync_(query.QueryLanguage, query.QueryString, enumerationOptions.Flags, enumerationOptions.GetContext(), newSink.Stub);
				}
			}
			catch (COMException e)
			{
				watcher.RemoveSink(newSink);
				ManagementException.ThrowWithExtendedInfo(e);
			}
			finally
			{
				securityHandler.Reset();
			}
			if ((num & 0xFFFFF000u) == 2147749888u)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
			}
			else if ((num & 0x80000000u) != 0L)
			{
				Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
			}
		}

		private void Initialize()
		{
			if (query == null)
			{
				throw new InvalidOperationException();
			}
			lock (this)
			{
				if (scope == null)
				{
					scope = ManagementScope._Clone(null);
				}
			}
			lock (scope)
			{
				if (!scope.IsConnected)
				{
					scope.Initialize();
				}
			}
		}
	}
	/// <summary>Represents the method that will handle the <see cref="E:System.Management.ManagementOperationObserver.ObjectReady" /> event.</summary>
	/// <param name="sender">The instance of the object for which to invoke this method.</param>
	/// <param name="e">The <see cref="T:System.Management.ObjectReadyEventArgs" /> that specifies the reason the event was invoked.</param>
	public delegate void ObjectReadyEventHandler(object sender, ObjectReadyEventArgs e);
	/// <summary>Represents the method that will handle the <see cref="E:System.Management.ManagementOperationObserver.Completed" /> event.</summary>
	/// <param name="sender">The instance of the object for which to invoke this method.</param>
	/// <param name="e">The <see cref="T:System.Management.CompletedEventArgs" /> that specifies the reason the event was invoked.</param>
	public delegate void CompletedEventHandler(object sender, CompletedEventArgs e);
	/// <summary>Represents the method that will handle the <see cref="E:System.Management.ManagementOperationObserver.Progress" /> event.</summary>
	/// <param name="sender">The instance of the object for which to invoke this method.</param>
	/// <param name="e">The <see cref="T:System.Management.ProgressEventArgs" /> that specifies the reason the event was invoked.</param>
	public delegate void ProgressEventHandler(object sender, ProgressEventArgs e);
	/// <summary>Represents the method that will handle the <see cref="E:System.Management.ManagementOperationObserver.ObjectPut" /> event.</summary>
	/// <param name="sender">The instance of the object for which to invoke this method.</param>
	/// <param name="e">The <see cref="T:System.Management.ObjectPutEventArgs" /> that specifies the reason the event was invoked.</param>
	public delegate void ObjectPutEventHandler(object sender, ObjectPutEventArgs e);
	/// <summary>Manages asynchronous operations and handles management information and events received asynchronously.</summary>
	public class ManagementOperationObserver
	{
		private Hashtable m_sinkCollection;

		private WmiDelegateInvoker delegateInvoker;

		internal bool HaveListenersForProgress
		{
			get
			{
				bool result = false;
				try
				{
					if (this.Progress != null)
					{
						result = this.Progress.GetInvocationList().Length != 0;
						return result;
					}
					return result;
				}
				catch
				{
					return result;
				}
			}
		}

		/// <summary>Occurs when a new object is available.</summary>
		public event ObjectReadyEventHandler ObjectReady;

		/// <summary>Occurs when an operation has completed.</summary>
		public event CompletedEventHandler Completed;

		/// <summary>Occurs to indicate the progress of an ongoing operation.</summary>
		public event ProgressEventHandler Progress;

		/// <summary>Occurs when an object has been successfully committed.</summary>
		public event ObjectPutEventHandler ObjectPut;

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementOperationObserver" /> class. This is the default constructor.</summary>
		public ManagementOperationObserver()
		{
			m_sinkCollection = new Hashtable();
			delegateInvoker = new WmiDelegateInvoker(this);
		}

		/// <summary>Cancels all outstanding operations.</summary>
		public void Cancel()
		{
			Hashtable hashtable = new Hashtable();
			lock (m_sinkCollection)
			{
				IDictionaryEnumerator enumerator = m_sinkCollection.GetEnumerator();
				try
				{
					enumerator.Reset();
					while (enumerator.MoveNext())
					{
						DictionaryEntry dictionaryEntry = (DictionaryEntry)enumerator.Current;
						hashtable.Add(dictionaryEntry.Key, dictionaryEntry.Value);
					}
				}
				catch
				{
				}
			}
			try
			{
				IDictionaryEnumerator enumerator2 = hashtable.GetEnumerator();
				enumerator2.Reset();
				while (enumerator2.MoveNext())
				{
					WmiEventSink wmiEventSink = (WmiEventSink)((DictionaryEntry)enumerator2.Current).Value;
					try
					{
						wmiEventSink.Cancel();
					}
					catch
					{
					}
				}
			}
			catch
			{
			}
		}

		internal WmiEventSink GetNewSink(ManagementScope scope, object context)
		{
			try
			{
				WmiEventSink wmiEventSink = WmiEventSink.GetWmiEventSink(this, context, scope, null, null);
				lock (m_sinkCollection)
				{
					m_sinkCollection.Add(wmiEventSink.GetHashCode(), wmiEventSink);
				}
				return wmiEventSink;
			}
			catch
			{
				return null;
			}
		}

		internal WmiEventSink GetNewPutSink(ManagementScope scope, object context, string path, string className)
		{
			try
			{
				WmiEventSink wmiEventSink = WmiEventSink.GetWmiEventSink(this, context, scope, path, className);
				lock (m_sinkCollection)
				{
					m_sinkCollection.Add(wmiEventSink.GetHashCode(), wmiEventSink);
				}
				return wmiEventSink;
			}
			catch
			{
				return null;
			}
		}

		internal WmiGetEventSink GetNewGetSink(ManagementScope scope, object context, ManagementObject managementObject)
		{
			try
			{
				WmiGetEventSink wmiGetEventSink = WmiGetEventSink.GetWmiGetEventSink(this, context, scope, managementObject);
				lock (m_sinkCollection)
				{
					m_sinkCollection.Add(wmiGetEventSink.GetHashCode(), wmiGetEventSink);
				}
				return wmiGetEventSink;
			}
			catch
			{
				return null;
			}
		}

		internal void RemoveSink(WmiEventSink eventSink)
		{
			try
			{
				lock (m_sinkCollection)
				{
					m_sinkCollection.Remove(eventSink.GetHashCode());
				}
				eventSink.ReleaseStub();
			}
			catch
			{
			}
		}

		internal void FireObjectReady(ObjectReadyEventArgs args)
		{
			try
			{
				delegateInvoker.FireEventToDelegates(this.ObjectReady, args);
			}
			catch
			{
			}
		}

		internal void FireCompleted(CompletedEventArgs args)
		{
			try
			{
				delegateInvoker.FireEventToDelegates(this.Completed, args);
			}
			catch
			{
			}
		}

		internal void FireProgress(ProgressEventArgs args)
		{
			try
			{
				delegateInvoker.FireEventToDelegates(this.Progress, args);
			}
			catch
			{
			}
		}

		internal void FireObjectPut(ObjectPutEventArgs args)
		{
			try
			{
				delegateInvoker.FireEventToDelegates(this.ObjectPut, args);
			}
			catch
			{
			}
		}
	}
	internal class WmiEventState
	{
		private Delegate d;

		private ManagementEventArgs args;

		private AutoResetEvent h;

		public Delegate Delegate => d;

		public ManagementEventArgs Args => args;

		public AutoResetEvent AutoResetEvent => h;

		internal WmiEventState(Delegate d, ManagementEventArgs args, AutoResetEvent h)
		{
			this.d = d;
			this.args = args;
			this.h = h;
		}
	}
	internal class WmiDelegateInvoker
	{
		internal object sender;

		internal WmiDelegateInvoker(object sender)
		{
			this.sender = sender;
		}

		internal void FireEventToDelegates(MulticastDelegate md, ManagementEventArgs args)
		{
			try
			{
				if ((object)md == null)
				{
					return;
				}
				Delegate[] invocationList = md.GetInvocationList();
				foreach (Delegate @delegate in invocationList)
				{
					try
					{
						@delegate.DynamicInvoke(sender, args);
					}
					catch
					{
					}
				}
			}
			catch
			{
			}
		}
	}
	/// <summary>Describes the authentication level to be used to connect to WMI. This is used for the COM connection to WMI.</summary>
	public enum AuthenticationLevel
	{
		/// <summary>The default COM authentication level. WMI uses the default Windows Authentication setting.</summary>
		Default = 0,
		/// <summary>No COM authentication.</summary>
		None = 1,
		/// <summary>Connect-level COM authentication.</summary>
		Connect = 2,
		/// <summary>Call-level COM authentication.</summary>
		Call = 3,
		/// <summary>Packet-level COM authentication.</summary>
		Packet = 4,
		/// <summary>Packet Integrity-level COM authentication.</summary>
		PacketIntegrity = 5,
		/// <summary>Packet Privacy-level COM authentication.</summary>
		PacketPrivacy = 6,
		/// <summary>Authentication level should remain as it was before.</summary>
		Unchanged = -1
	}
	/// <summary>Describes the impersonation level to be used to connect to WMI.</summary>
	public enum ImpersonationLevel
	{
		/// <summary>Default impersonation.</summary>
		Default,
		/// <summary>Anonymous COM impersonation level that hides the identity of the caller. Calls to WMI may fail with this impersonation level.</summary>
		Anonymous,
		/// <summary>Identify-level COM impersonation level that allows objects to query the credentials of the caller. Calls to WMI may fail with this impersonation level.</summary>
		Identify,
		/// <summary>Impersonate-level COM impersonation level that allows objects to use the credentials of the caller. This is the recommended impersonation level for WMI calls.</summary>
		Impersonate,
		/// <summary>Delegate-level COM impersonation level that allows objects to permit other objects to use the credentials of the caller. This level, which will work with WMI calls but may constitute an unnecessary security risk, is supported only under Windows 2000.</summary>
		Delegate
	}
	/// <summary>Describes the possible effects of saving an object to WMI when using <see cref="M:System.Management.ManagementObject.Put" />.</summary>
	public enum PutType
	{
		/// <summary>No change.</summary>
		None,
		/// <summary>Updates an existing object only; does not create a new object.</summary>
		UpdateOnly,
		/// <summary>Creates an object only; does not update an existing object.</summary>
		CreateOnly,
		/// <summary>Saves the object, whether updating an existing object or creating a new object.</summary>
		UpdateOrCreate
	}
	/// <summary>Provides an abstract base class for all options objects.</summary>
	[TypeConverter(typeof(ExpandableObjectConverter))]
	public abstract class ManagementOptions : ICloneable
	{
		/// <summary>Indicates that no timeout should occur.</summary>
		public static readonly TimeSpan InfiniteTimeout = TimeSpan.MaxValue;

		internal int flags;

		internal ManagementNamedValueCollection context;

		internal TimeSpan timeout;

		internal int Flags
		{
			get
			{
				return flags;
			}
			set
			{
				flags = value;
			}
		}

		/// <summary>Gets or sets a WMI context object. This is a name-value pairs list to be passed through to a WMI provider that supports context information for customized operation.</summary>
		/// <returns>Returns a <see cref="T:System.Management.ManagementNamedValueCollection" /> that contains WMI context information.</returns>
		public ManagementNamedValueCollection Context
		{
			get
			{
				if (context == null)
				{
					return context = new ManagementNamedValueCollection();
				}
				return context;
			}
			set
			{
				ManagementNamedValueCollection managementNamedValueCollection = context;
				if (value != null)
				{
					context = value.Clone();
				}
				else
				{
					context = new ManagementNamedValueCollection();
				}
				if (managementNamedValueCollection != null)
				{
					managementNamedValueCollection.IdentifierChanged -= HandleIdentifierChange;
				}
				context.IdentifierChanged += HandleIdentifierChange;
				HandleIdentifierChange(this, null);
			}
		}

		/// <summary>Gets or sets the time-out to apply to the operation. Note that for operations that return collections, this time-out applies to the enumeration through the resulting collection, not the operation itself (the <see cref="P:System.Management.EnumerationOptions.ReturnImmediately" /> property is used for the latter). This property is used to indicate that the operation should be performed semi-synchronously.</summary>
		/// <returns>Returns a <see cref="T:System.TimeSpan" /> that defines the time-out time to apply to the operation.</returns>
		public TimeSpan Timeout
		{
			get
			{
				return timeout;
			}
			set
			{
				if (value.Ticks < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				timeout = value;
				FireIdentifierChanged();
			}
		}

		internal bool SendStatus
		{
			get
			{
				if ((Flags & 0x80) == 0)
				{
					return false;
				}
				return true;
			}
			set
			{
				Flags = ((!value) ? (Flags & -129) : (Flags | 0x80));
			}
		}

		internal event IdentifierChangedEventHandler IdentifierChanged;

		internal void FireIdentifierChanged()
		{
			if (this.IdentifierChanged != null)
			{
				this.IdentifierChanged(this, null);
			}
		}

		internal void HandleIdentifierChange(object sender, IdentifierChangedEventArgs args)
		{
			FireIdentifierChanged();
		}

		internal ManagementOptions()
			: this(null, InfiniteTimeout)
		{
		}

		internal ManagementOptions(ManagementNamedValueCollection context, TimeSpan timeout)
			: this(context, timeout, 0)
		{
		}

		internal ManagementOptions(ManagementNamedValueCollection context, TimeSpan timeout, int flags)
		{
			this.flags = flags;
			if (context != null)
			{
				Context = context;
			}
			else
			{
				this.context = null;
			}
			Timeout = timeout;
		}

		internal IWbemContext GetContext()
		{
			if (context != null)
			{
				return context.GetContext();
			}
			return null;
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The cloned object.</returns>
		public abstract object Clone();
	}
	/// <summary>Provides a base class for query and enumeration-related options objects.</summary>
	public class EnumerationOptions : ManagementOptions
	{
		private int blockSize;

		/// <summary>Gets or sets a value indicating whether the invoked operation should be performed in a synchronous or semisynchronous fashion. If this property is set to <see langword="true" />, the enumeration is invoked and the call returns immediately. The actual retrieval of the results will occur when the resulting collection is walked.</summary>
		/// <returns>
		///   <see langword="true" /> if the invoked operation should be performed in a synchronous or semisynchronous fashion; otherwise, <see langword="false" />.</returns>
		public bool ReturnImmediately
		{
			get
			{
				if ((base.Flags & 0x10) == 0)
				{
					return false;
				}
				return true;
			}
			set
			{
				base.Flags = ((!value) ? (base.Flags & -17) : (base.Flags | 0x10));
			}
		}

		/// <summary>Gets or sets the block size for block operations. When enumerating through a collection, WMI will return results in groups of the specified size.</summary>
		/// <returns>The block size in block operations.</returns>
		public int BlockSize
		{
			get
			{
				return blockSize;
			}
			set
			{
				if (value <= 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				blockSize = value;
			}
		}

		/// <summary>Gets or sets a value indicating whether the collection is assumed to be rewindable. If <see langword="true" />, the objects in the collection will be kept available for multiple enumerations. If <see langword="false" />, the collection can only be enumerated one time.</summary>
		/// <returns>
		///   <see langword="true" /> if the collection is assumed to be rewindable; otherwise, <see langword="false" />.</returns>
		public bool Rewindable
		{
			get
			{
				if ((base.Flags & 0x20) == 0)
				{
					return true;
				}
				return false;
			}
			set
			{
				base.Flags = (value ? (base.Flags & -33) : (base.Flags | 0x20));
			}
		}

		/// <summary>Gets or sets a value indicating whether the objects returned from WMI should contain amended information. Typically, amended information is localizable information attached to the WMI object, such as object and property descriptions.</summary>
		/// <returns>
		///   <see langword="true" /> if the objects returned from WMI should contain amended information; otherwise, <see langword="false" />.</returns>
		public bool UseAmendedQualifiers
		{
			get
			{
				if ((base.Flags & 0x20000) == 0)
				{
					return false;
				}
				return true;
			}
			set
			{
				base.Flags = (value ? (base.Flags | 0x20000) : (base.Flags & -131073));
			}
		}

		/// <summary>Gets or sets a value indicating whether to the objects returned should have locatable information in them. This ensures that the system properties, such as __PATH, __RELPATH, and __SERVER, are non-NULL. This flag can only be used in queries, and is ignored in enumerations.</summary>
		/// <returns>
		///   <see langword="true" /> if the objects returned should have locatable information in them; otherwise, <see langword="false" />.</returns>
		public bool EnsureLocatable
		{
			get
			{
				if ((base.Flags & 0x100) == 0)
				{
					return false;
				}
				return true;
			}
			set
			{
				base.Flags = (value ? (base.Flags | 0x100) : (base.Flags & -257));
			}
		}

		/// <summary>Gets or sets a value indicating whether the query should return a prototype of the result set instead of the actual results. This flag is used for prototyping.</summary>
		/// <returns>
		///   <see langword="true" /> if the query should return a prototype of the result set instead of the actual results; otherwise, <see langword="false" />.</returns>
		public bool PrototypeOnly
		{
			get
			{
				if ((base.Flags & 2) == 0)
				{
					return false;
				}
				return true;
			}
			set
			{
				base.Flags = (value ? (base.Flags | 2) : (base.Flags & -3));
			}
		}

		/// <summary>Gets or sets a value indicating whether direct access to the WMI provider is requested for the specified class, without any regard to its super class or derived classes.</summary>
		/// <returns>
		///   <see langword="true" /> if direct access to the WMI provider is requested for the specified class; otherwise, <see langword="false" />.</returns>
		public bool DirectRead
		{
			get
			{
				if ((base.Flags & 0x200) == 0)
				{
					return false;
				}
				return true;
			}
			set
			{
				base.Flags = (value ? (base.Flags | 0x200) : (base.Flags & -513));
			}
		}

		/// <summary>Gets or sets a value indicating whether recursive enumeration is requested into all classes derived from the specified superclass. If <see langword="false" />, only immediate derived class members are returned.</summary>
		/// <returns>
		///   <see langword="true" /> if recursive enumeration is requested into all classes derived from the specified superclass; otherwise, <see langword="false" />.</returns>
		public bool EnumerateDeep
		{
			get
			{
				if ((base.Flags & 1) == 0)
				{
					return true;
				}
				return false;
			}
			set
			{
				base.Flags = ((!value) ? (base.Flags | 1) : (base.Flags & -2));
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.EnumerationOptions" /> class with default values (see the individual property descriptions for what the default values are). This is the default constructor.</summary>
		public EnumerationOptions()
			: this(null, ManagementOptions.InfiniteTimeout, 1, rewindable: true, returnImmediatley: true, useAmendedQualifiers: false, ensureLocatable: false, prototypeOnly: false, directRead: false, enumerateDeep: false)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.EnumerationOptions" /> class to be used for queries or enumerations, allowing the user to specify values for the different options.</summary>
		/// <param name="context">The options context object containing provider-specific information that can be passed through to the provider.</param>
		/// <param name="timeout">The time-out value for enumerating through the results.</param>
		/// <param name="blockSize">The number of items to retrieve at one time from WMI.</param>
		/// <param name="rewindable">
		///   <see langword="true" /> to show that the result set is rewindable (allows multiple traversal); otherwise, <see langword="false" />.</param>
		/// <param name="returnImmediatley">
		///   <see langword="true" /> to show that the operation should return immediately (semi-sync) or block until all results are available; otherwise, <see langword="false" />.</param>
		/// <param name="useAmendedQualifiers">
		///   <see langword="true" /> to show that the returned objects should contain amended (locale-aware) qualifiers; otherwise, <see langword="false" />.</param>
		/// <param name="ensureLocatable">
		///   <see langword="true" /> to ensure all returned objects have valid paths; otherwise, <see langword="false" />.</param>
		/// <param name="prototypeOnly">
		///   <see langword="true" /> to return a prototype of the result set instead of the actual results; otherwise, <see langword="false" />.</param>
		/// <param name="directRead">
		///   <see langword="true" /> to retrieve objects of only the specified class or from derived classes as well; otherwise, <see langword="false" />.</param>
		/// <param name="enumerateDeep">
		///   <see langword="true" /> to use recursive enumeration in subclasses; otherwise, <see langword="false" />.</param>
		public EnumerationOptions(ManagementNamedValueCollection context, TimeSpan timeout, int blockSize, bool rewindable, bool returnImmediatley, bool useAmendedQualifiers, bool ensureLocatable, bool prototypeOnly, bool directRead, bool enumerateDeep)
			: base(context, timeout)
		{
			BlockSize = blockSize;
			Rewindable = rewindable;
			ReturnImmediately = returnImmediatley;
			UseAmendedQualifiers = useAmendedQualifiers;
			EnsureLocatable = ensureLocatable;
			PrototypeOnly = prototypeOnly;
			DirectRead = directRead;
			EnumerateDeep = enumerateDeep;
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The cloned object.</returns>
		public override object Clone()
		{
			ManagementNamedValueCollection managementNamedValueCollection = null;
			if (base.Context != null)
			{
				managementNamedValueCollection = base.Context.Clone();
			}
			return new EnumerationOptions(managementNamedValueCollection, base.Timeout, blockSize, Rewindable, ReturnImmediately, UseAmendedQualifiers, EnsureLocatable, PrototypeOnly, DirectRead, EnumerateDeep);
		}
	}
	/// <summary>Specifies options for management event watching.</summary>
	public class EventWatcherOptions : ManagementOptions
	{
		private int blockSize = 1;

		/// <summary>Gets or sets the block size for block operations. When waiting for events, this value specifies how many events to wait for before returning.</summary>
		/// <returns>An integer value indicating the block size for a block of operations.</returns>
		public int BlockSize
		{
			get
			{
				return blockSize;
			}
			set
			{
				blockSize = value;
				FireIdentifierChanged();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.EventWatcherOptions" /> class for event watching, using default values. This is the default constructor.</summary>
		public EventWatcherOptions()
			: this(null, ManagementOptions.InfiniteTimeout, 1)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.EventWatcherOptions" /> class with the given values.</summary>
		/// <param name="context">The options context object containing provider-specific information to be passed through to the provider.</param>
		/// <param name="timeout">The time-out to wait for the next events.</param>
		/// <param name="blockSize">The number of events to wait for in each block.</param>
		public EventWatcherOptions(ManagementNamedValueCollection context, TimeSpan timeout, int blockSize)
			: base(context, timeout)
		{
			base.Flags = 48;
			BlockSize = blockSize;
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The cloned object.</returns>
		public override object Clone()
		{
			ManagementNamedValueCollection managementNamedValueCollection = null;
			if (base.Context != null)
			{
				managementNamedValueCollection = base.Context.Clone();
			}
			return new EventWatcherOptions(managementNamedValueCollection, base.Timeout, blockSize);
		}
	}
	/// <summary>Specifies options for getting a management object.</summary>
	public class ObjectGetOptions : ManagementOptions
	{
		/// <summary>Gets or sets a value indicating whether the objects returned from WMI should contain amended information. Typically, amended information is localizable information attached to the WMI object, such as object and property descriptions.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the objects returned from WMI should contain amended information.</returns>
		public bool UseAmendedQualifiers
		{
			get
			{
				if ((base.Flags & 0x20000) == 0)
				{
					return false;
				}
				return true;
			}
			set
			{
				base.Flags = (value ? (base.Flags | 0x20000) : (base.Flags & -131073));
				FireIdentifierChanged();
			}
		}

		internal static ObjectGetOptions _Clone(ObjectGetOptions options)
		{
			return _Clone(options, null);
		}

		internal static ObjectGetOptions _Clone(ObjectGetOptions options, IdentifierChangedEventHandler handler)
		{
			ObjectGetOptions objectGetOptions = ((options == null) ? new ObjectGetOptions() : new ObjectGetOptions(options.context, options.timeout, options.UseAmendedQualifiers));
			if (handler != null)
			{
				objectGetOptions.IdentifierChanged += handler;
			}
			else if (options != null)
			{
				objectGetOptions.IdentifierChanged += options.HandleIdentifierChange;
			}
			return objectGetOptions;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ObjectGetOptions" /> class for getting a WMI object, using default values. This is the default constructor.</summary>
		public ObjectGetOptions()
			: this(null, ManagementOptions.InfiniteTimeout, useAmendedQualifiers: false)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ObjectGetOptions" /> class for getting a WMI object, using the specified provider-specific context.</summary>
		/// <param name="context">A provider-specific, named-value pairs context object to be passed through to the provider.</param>
		public ObjectGetOptions(ManagementNamedValueCollection context)
			: this(context, ManagementOptions.InfiniteTimeout, useAmendedQualifiers: false)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ObjectGetOptions" /> class for getting a WMI object, using the given options values.</summary>
		/// <param name="context">A provider-specific, named-value pairs context object to be passed through to the provider.</param>
		/// <param name="timeout">The length of time to let the operation perform before it times out. The default is <see cref="F:System.TimeSpan.MaxValue" />.</param>
		/// <param name="useAmendedQualifiers">
		///   <see langword="true" /> if the returned objects should contain amended (locale-aware) qualifiers; otherwise, <see langword="false" />.</param>
		public ObjectGetOptions(ManagementNamedValueCollection context, TimeSpan timeout, bool useAmendedQualifiers)
			: base(context, timeout)
		{
			UseAmendedQualifiers = useAmendedQualifiers;
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The cloned object.</returns>
		public override object Clone()
		{
			ManagementNamedValueCollection managementNamedValueCollection = null;
			if (base.Context != null)
			{
				managementNamedValueCollection = base.Context.Clone();
			}
			return new ObjectGetOptions(managementNamedValueCollection, base.Timeout, UseAmendedQualifiers);
		}
	}
	/// <summary>Specifies options for committing management object changes.</summary>
	public class PutOptions : ManagementOptions
	{
		/// <summary>Gets or sets a value indicating whether the objects returned from WMI should contain amended information. Typically, amended information is localizable information attached to the WMI object, such as object and property descriptions.</summary>
		/// <returns>
		///   <see langword="true" /> if the objects returned from WMI should contain amended information; otherwise, <see langword="false" />.</returns>
		public bool UseAmendedQualifiers
		{
			get
			{
				if ((base.Flags & 0x20000) == 0)
				{
					return false;
				}
				return true;
			}
			set
			{
				base.Flags = (value ? (base.Flags | 0x20000) : (base.Flags & -131073));
			}
		}

		/// <summary>Gets or sets the type of commit to be performed for the object.</summary>
		/// <returns>One of the enumeration values that indicates the type of commit to be performed for the object.</returns>
		public PutType Type
		{
			get
			{
				if ((base.Flags & 1) == 0)
				{
					if ((base.Flags & 2) == 0)
					{
						return PutType.UpdateOrCreate;
					}
					return PutType.CreateOnly;
				}
				return PutType.UpdateOnly;
			}
			set
			{
				switch (value)
				{
				case PutType.UpdateOnly:
					base.Flags |= 1;
					break;
				case PutType.CreateOnly:
					base.Flags |= 2;
					break;
				case PutType.UpdateOrCreate:
					base.Flags |= 0;
					break;
				default:
					throw new ArgumentException(null, "Type");
				}
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.PutOptions" /> class for put operations, using default values. This is the default constructor.</summary>
		public PutOptions()
			: this(null, ManagementOptions.InfiniteTimeout, useAmendedQualifiers: false, PutType.UpdateOrCreate)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.PutOptions" /> class for committing a WMI object, using the specified provider-specific context.</summary>
		/// <param name="context">A provider-specific, named-value pairs context object to be passed through to the provider.</param>
		public PutOptions(ManagementNamedValueCollection context)
			: this(context, ManagementOptions.InfiniteTimeout, useAmendedQualifiers: false, PutType.UpdateOrCreate)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.PutOptions" /> class for committing a WMI object, using the specified option values.</summary>
		/// <param name="context">A provider-specific, named-value pairs object to be passed through to the provider.</param>
		/// <param name="timeout">The length of time to let the operation perform before it times out. The default is <see cref="F:System.TimeSpan.MaxValue" />.</param>
		/// <param name="useAmendedQualifiers">
		///   <see langword="true" /> if the returned objects should contain amended (locale-aware) qualifiers; otherwise, <see langword="false" />.</param>
		/// <param name="putType">The type of commit to be performed (update or create).</param>
		public PutOptions(ManagementNamedValueCollection context, TimeSpan timeout, bool useAmendedQualifiers, PutType putType)
			: base(context, timeout)
		{
			UseAmendedQualifiers = useAmendedQualifiers;
			Type = putType;
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The cloned object.</returns>
		public override object Clone()
		{
			ManagementNamedValueCollection managementNamedValueCollection = null;
			if (base.Context != null)
			{
				managementNamedValueCollection = base.Context.Clone();
			}
			return new PutOptions(managementNamedValueCollection, base.Timeout, UseAmendedQualifiers, Type);
		}
	}
	/// <summary>Specifies options for deleting a management object.</summary>
	public class DeleteOptions : ManagementOptions
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.DeleteOptions" /> class for the delete operation, using default values. This is the default constructor.</summary>
		public DeleteOptions()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.DeleteOptions" /> class for a delete operation, using the specified values.</summary>
		/// <param name="context">A provider-specific, named-value pairs object to be passed through to the provider.</param>
		/// <param name="timeout">The length of time to let the operation perform before it times out. The default value is <see cref="F:System.TimeSpan.MaxValue" />. Setting this parameter will invoke the operation semisynchronously.</param>
		public DeleteOptions(ManagementNamedValueCollection context, TimeSpan timeout)
			: base(context, timeout)
		{
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>A cloned object.</returns>
		public override object Clone()
		{
			ManagementNamedValueCollection managementNamedValueCollection = null;
			if (base.Context != null)
			{
				managementNamedValueCollection = base.Context.Clone();
			}
			return new DeleteOptions(managementNamedValueCollection, base.Timeout);
		}
	}
	/// <summary>Specifies options for invoking a management method.</summary>
	public class InvokeMethodOptions : ManagementOptions
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.InvokeMethodOptions" /> class for the <see cref="M:System.Management.ManagementObject.InvokeMethod(System.String,System.Object[])" /> operation, using default values. This is the default constructor.</summary>
		public InvokeMethodOptions()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.InvokeMethodOptions" /> class for an invoke operation using the specified values.</summary>
		/// <param name="context">A provider-specific, named-value pairs object to be passed through to the provider.</param>
		/// <param name="timeout">The length of time to let the operation perform before it times out. The default value is <see cref="F:System.TimeSpan.MaxValue" />. Setting this parameter will invoke the operation semisynchronously.</param>
		public InvokeMethodOptions(ManagementNamedValueCollection context, TimeSpan timeout)
			: base(context, timeout)
		{
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The cloned object.</returns>
		public override object Clone()
		{
			ManagementNamedValueCollection managementNamedValueCollection = null;
			if (base.Context != null)
			{
				managementNamedValueCollection = base.Context.Clone();
			}
			return new InvokeMethodOptions(managementNamedValueCollection, base.Timeout);
		}
	}
	/// <summary>Specifies all settings required to make a WMI connection.</summary>
	public class ConnectionOptions : ManagementOptions
	{
		internal const string DEFAULTLOCALE = null;

		internal const string DEFAULTAUTHORITY = null;

		internal const ImpersonationLevel DEFAULTIMPERSONATION = ImpersonationLevel.Impersonate;

		internal const AuthenticationLevel DEFAULTAUTHENTICATION = AuthenticationLevel.Unchanged;

		internal const bool DEFAULTENABLEPRIVILEGES = false;

		private string locale;

		private string username;

		private SecureString securePassword;

		private string authority;

		private ImpersonationLevel impersonation;

		private AuthenticationLevel authentication;

		private bool enablePrivileges;

		/// <summary>Gets or sets the locale to be used for the connection operation.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value used for the locale in a connection to WMI.</returns>
		public string Locale
		{
			get
			{
				if (locale == null)
				{
					return string.Empty;
				}
				return locale;
			}
			set
			{
				if (locale != value)
				{
					locale = value;
					FireIdentifierChanged();
				}
			}
		}

		/// <summary>Gets or sets the user name to be used for the connection operation.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value used as the user name in a connection to WMI.</returns>
		public string Username
		{
			get
			{
				return username;
			}
			set
			{
				if (username != value)
				{
					username = value;
					FireIdentifierChanged();
				}
			}
		}

		/// <summary>Sets the password for the specified user.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value used for the password in a connection to WMI.</returns>
		public string Password
		{
			set
			{
				if (value != null)
				{
					if (securePassword == null)
					{
						securePassword = new SecureString();
						for (int i = 0; i < value.Length; i++)
						{
							securePassword.AppendChar(value[i]);
						}
						return;
					}
					SecureString secureString = new SecureString();
					for (int j = 0; j < value.Length; j++)
					{
						secureString.AppendChar(value[j]);
					}
					securePassword.Clear();
					securePassword = secureString.Copy();
					FireIdentifierChanged();
					secureString.Dispose();
				}
				else if (securePassword != null)
				{
					securePassword.Dispose();
					securePassword = null;
					FireIdentifierChanged();
				}
			}
		}

		/// <summary>Sets the password for the specified user.</summary>
		/// <returns>Returns a SecureString value used for the password in a connection to WMI.</returns>
		public SecureString SecurePassword
		{
			set
			{
				if (value != null)
				{
					if (securePassword == null)
					{
						securePassword = value.Copy();
						return;
					}
					securePassword.Clear();
					securePassword = value.Copy();
					FireIdentifierChanged();
				}
				else if (securePassword != null)
				{
					securePassword.Dispose();
					securePassword = null;
					FireIdentifierChanged();
				}
			}
		}

		/// <summary>Gets or sets the authority to be used to authenticate the specified user.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> that defines the authority used to authenticate the specified user.</returns>
		public string Authority
		{
			get
			{
				if (authority == null)
				{
					return string.Empty;
				}
				return authority;
			}
			set
			{
				if (authority != value)
				{
					authority = value;
					FireIdentifierChanged();
				}
			}
		}

		/// <summary>Gets or sets the COM impersonation level to be used for operations in this connection.</summary>
		/// <returns>Returns an <see cref="T:System.Management.ImpersonationLevel" /> enumeration value indicating the impersonation level used to connect to WMI.</returns>
		public ImpersonationLevel Impersonation
		{
			get
			{
				return impersonation;
			}
			set
			{
				if (impersonation != value)
				{
					impersonation = value;
					FireIdentifierChanged();
				}
			}
		}

		/// <summary>Gets or sets the COM authentication level to be used for operations in this connection.</summary>
		/// <returns>Returns an <see cref="T:System.Management.AuthenticationLevel" /> enumeration value indicating the COM authentication level used for a connection to the local or a remote computer.</returns>
		public AuthenticationLevel Authentication
		{
			get
			{
				return authentication;
			}
			set
			{
				if (authentication != value)
				{
					authentication = value;
					FireIdentifierChanged();
				}
			}
		}

		/// <summary>Gets or sets a value indicating whether user privileges need to be enabled for the connection operation. This property should only be used when the operation performed requires a certain user privilege to be enabled (for example, a machine restart).</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether user privileges need to be enabled for the connection operation.</returns>
		public bool EnablePrivileges
		{
			get
			{
				return enablePrivileges;
			}
			set
			{
				if (enablePrivileges != value)
				{
					enablePrivileges = value;
					FireIdentifierChanged();
				}
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ConnectionOptions" /> class for the connection operation, using default values. This is the default constructor.</summary>
		public ConnectionOptions()
			: this((string)null, (string)null, (string)null, (string)null, ImpersonationLevel.Impersonate, AuthenticationLevel.Unchanged, enablePrivileges: false, (ManagementNamedValueCollection)null, ManagementOptions.InfiniteTimeout)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ConnectionOptions" /> class to be used for a WMI connection, using the specified values.</summary>
		/// <param name="locale">The locale to be used for the connection.</param>
		/// <param name="username">The user name to be used for the connection. If null, the credentials of the currently logged-on user are used.</param>
		/// <param name="password">The password for the given user name. If the user name is also null, the credentials used will be those of the currently logged-on user.</param>
		/// <param name="authority">The authority to be used to authenticate the specified user.</param>
		/// <param name="impersonation">The COM impersonation level to be used for the connection.</param>
		/// <param name="authentication">The COM authentication level to be used for the connection.</param>
		/// <param name="enablePrivileges">
		///   <see langword="true" /> to enable special user privileges; otherwise, <see langword="false" />. This parameter should only be used when performing an operation that requires special Windows NT user privileges.</param>
		/// <param name="context">A provider-specific, named value pairs object to be passed through to the provider.</param>
		/// <param name="timeout">Reserved for future use.</param>
		public ConnectionOptions(string locale, string username, string password, string authority, ImpersonationLevel impersonation, AuthenticationLevel authentication, bool enablePrivileges, ManagementNamedValueCollection context, TimeSpan timeout)
			: base(context, timeout)
		{
			if (locale != null)
			{
				this.locale = locale;
			}
			this.username = username;
			this.enablePrivileges = enablePrivileges;
			if (password != null)
			{
				securePassword = new SecureString();
				for (int i = 0; i < password.Length; i++)
				{
					securePassword.AppendChar(password[i]);
				}
			}
			if (authority != null)
			{
				this.authority = authority;
			}
			if (impersonation != 0)
			{
				this.impersonation = impersonation;
			}
			if (authentication != 0)
			{
				this.authentication = authentication;
			}
		}

		/// <summary>Creates a new ConnectionOption.</summary>
		/// <param name="locale">The locale to be used for the connection.</param>
		/// <param name="username">The user name to be used for the connection. If null, the credentials of the currently logged-on user are used.</param>
		/// <param name="password">The password for the given user name. If the user name is also null, the credentials used will be those of the currently logged-on user.</param>
		/// <param name="authority">The authority to be used to authenticate the specified user.</param>
		/// <param name="impersonation">The COM impersonation level to be used for the connection.</param>
		/// <param name="authentication">The COM authentication level to be used for the connection.</param>
		/// <param name="enablePrivileges">true to enable special user privileges; otherwise, false. This parameter should only be used when performing an operation that requires special Windows NT user privileges.</param>
		/// <param name="context">A provider-specific, named value pairs object to be passed through to the provider.</param>
		/// <param name="timeout">Reserved for future use.</param>
		public ConnectionOptions(string locale, string username, SecureString password, string authority, ImpersonationLevel impersonation, AuthenticationLevel authentication, bool enablePrivileges, ManagementNamedValueCollection context, TimeSpan timeout)
			: base(context, timeout)
		{
			if (locale != null)
			{
				this.locale = locale;
			}
			this.username = username;
			this.enablePrivileges = enablePrivileges;
			if (password != null)
			{
				securePassword = password.Copy();
			}
			if (authority != null)
			{
				this.authority = authority;
			}
			if (impersonation != 0)
			{
				this.impersonation = impersonation;
			}
			if (authentication != 0)
			{
				this.authentication = authentication;
			}
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The cloned object.</returns>
		public override object Clone()
		{
			ManagementNamedValueCollection managementNamedValueCollection = null;
			if (base.Context != null)
			{
				managementNamedValueCollection = base.Context.Clone();
			}
			return new ConnectionOptions(locale, username, GetSecurePassword(), authority, impersonation, authentication, enablePrivileges, managementNamedValueCollection, base.Timeout);
		}

		internal IntPtr GetPassword()
		{
			if (securePassword != null)
			{
				try
				{
					return Marshal.SecureStringToBSTR(securePassword);
				}
				catch (OutOfMemoryException)
				{
					return IntPtr.Zero;
				}
			}
			return IntPtr.Zero;
		}

		internal SecureString GetSecurePassword()
		{
			if (securePassword != null)
			{
				return securePassword.Copy();
			}
			return null;
		}

		internal ConnectionOptions(ManagementNamedValueCollection context, TimeSpan timeout, int flags)
			: base(context, timeout, flags)
		{
		}

		internal ConnectionOptions(ManagementNamedValueCollection context)
			: base(context, ManagementOptions.InfiniteTimeout)
		{
		}

		internal static ConnectionOptions _Clone(ConnectionOptions options)
		{
			return _Clone(options, null);
		}

		internal static ConnectionOptions _Clone(ConnectionOptions options, IdentifierChangedEventHandler handler)
		{
			ConnectionOptions connectionOptions;
			if (options != null)
			{
				connectionOptions = new ConnectionOptions(options.Context, options.Timeout, options.Flags);
				connectionOptions.locale = options.locale;
				connectionOptions.username = options.username;
				connectionOptions.enablePrivileges = options.enablePrivileges;
				if (options.securePassword != null)
				{
					connectionOptions.securePassword = options.securePassword.Copy();
				}
				else
				{
					connectionOptions.securePassword = null;
				}
				if (options.authority != null)
				{
					connectionOptions.authority = options.authority;
				}
				if (options.impersonation != 0)
				{
					connectionOptions.impersonation = options.impersonation;
				}
				if (options.authentication != 0)
				{
					connectionOptions.authentication = options.authentication;
				}
			}
			else
			{
				connectionOptions = new ConnectionOptions();
			}
			if (handler != null)
			{
				connectionOptions.IdentifierChanged += handler;
			}
			else if (options != null)
			{
				connectionOptions.IdentifierChanged += options.HandleIdentifierChange;
			}
			return connectionOptions;
		}
	}
	/// <summary>Provides a wrapper for parsing and building paths to WMI objects.</summary>
	[TypeConverter(typeof(ManagementPathConverter))]
	public class ManagementPath : ICloneable
	{
		private static ManagementPath defaultPath = new ManagementPath("//./root/cimv2");

		private bool isWbemPathShared;

		private IWbemPath wmiPath;

		/// <summary>Gets or sets the default scope path used when no scope is specified. The default scope is \\.\root\cimv2, and can be changed by setting this property.</summary>
		/// <returns>Returns a <see cref="T:System.Management.ManagementPath" /> that contains the default scope (namespace) path used when no scope is specified.</returns>
		public static ManagementPath DefaultPath
		{
			get
			{
				return defaultPath;
			}
			set
			{
				defaultPath = value;
			}
		}

		internal bool IsEmpty => Path.Length == 0;

		/// <summary>Gets or sets the string representation of the full path in the object.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the full path.</returns>
		[RefreshProperties(RefreshProperties.All)]
		public string Path
		{
			get
			{
				return GetWbemPath();
			}
			set
			{
				try
				{
					if (isWbemPathShared)
					{
						wmiPath = CreateWbemPath(GetWbemPath());
						isWbemPathShared = false;
					}
					SetWbemPath(value);
				}
				catch
				{
					throw new ArgumentOutOfRangeException("value");
				}
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the relative path: class name and keys only.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the relative path.</returns>
		[RefreshProperties(RefreshProperties.All)]
		public string RelativePath
		{
			get
			{
				string text = string.Empty;
				if (wmiPath != null)
				{
					uint puBuffLength = 0u;
					int text_ = wmiPath.GetText_(2, ref puBuffLength, null);
					if (text_ >= 0 && 0 < puBuffLength)
					{
						text = new string('0', (int)(puBuffLength - 1));
						text_ = wmiPath.GetText_(2, ref puBuffLength, text);
					}
					if (text_ < 0 && text_ != -2147217400)
					{
						if ((text_ & 0xFFFFF000u) == 2147749888u)
						{
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)text_);
						}
						else
						{
							Marshal.ThrowExceptionForHR(text_, WmiNetUtilsHelper.GetErrorInfo_f());
						}
					}
				}
				return text;
			}
			set
			{
				try
				{
					SetRelativePath(value);
				}
				catch (COMException)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the server part of the path.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the server name.</returns>
		[RefreshProperties(RefreshProperties.All)]
		public string Server
		{
			get
			{
				string text = string.Empty;
				if (wmiPath != null)
				{
					uint puNameBufLength = 0u;
					int server_ = wmiPath.GetServer_(ref puNameBufLength, null);
					if (server_ >= 0 && 0 < puNameBufLength)
					{
						text = new string('0', (int)(puNameBufLength - 1));
						server_ = wmiPath.GetServer_(ref puNameBufLength, text);
					}
					if (server_ < 0 && server_ != -2147217399)
					{
						if ((server_ & 0xFFFFF000u) == 2147749888u)
						{
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)server_);
						}
						else
						{
							Marshal.ThrowExceptionForHR(server_, WmiNetUtilsHelper.GetErrorInfo_f());
						}
					}
				}
				return text;
			}
			set
			{
				string server = Server;
				if (string.Compare(server, value, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return;
				}
				if (wmiPath == null)
				{
					wmiPath = (IWbemPath)MTAHelper.CreateInMTA(typeof(WbemDefPath));
				}
				else if (isWbemPathShared)
				{
					wmiPath = CreateWbemPath(GetWbemPath());
					isWbemPathShared = false;
				}
				int num = wmiPath.SetServer_(value);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the namespace part of the path. Note that this does not include the server name, which can be retrieved separately.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the namespace part of the path.</returns>
		[RefreshProperties(RefreshProperties.All)]
		public string NamespacePath
		{
			get
			{
				return GetNamespacePath(16);
			}
			set
			{
				bool bChange = false;
				try
				{
					SetNamespacePath(value, out bChange);
				}
				catch (COMException)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				if (bChange)
				{
					FireIdentifierChanged();
				}
			}
		}

		/// <summary>Gets or sets the class portion of the path.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value that holds the class portion of the path.</returns>
		[RefreshProperties(RefreshProperties.All)]
		public string ClassName
		{
			get
			{
				return internalClassName;
			}
			set
			{
				string className = ClassName;
				if (string.Compare(className, value, StringComparison.OrdinalIgnoreCase) != 0)
				{
					internalClassName = value;
					FireIdentifierChanged();
				}
			}
		}

		internal string internalClassName
		{
			get
			{
				string text = string.Empty;
				int num = 0;
				if (wmiPath != null)
				{
					uint puBuffLength = 0u;
					num = wmiPath.GetClassName_(ref puBuffLength, null);
					if (num >= 0 && 0 < puBuffLength)
					{
						text = new string('0', (int)(puBuffLength - 1));
						num = wmiPath.GetClassName_(ref puBuffLength, text);
						if (num < 0)
						{
							text = string.Empty;
						}
					}
				}
				return text;
			}
			set
			{
				int num = 0;
				if (wmiPath == null)
				{
					wmiPath = (IWbemPath)MTAHelper.CreateInMTA(typeof(WbemDefPath));
				}
				else if (isWbemPathShared)
				{
					wmiPath = CreateWbemPath(GetWbemPath());
					isWbemPathShared = false;
				}
				try
				{
					num = wmiPath.SetClassName_(value);
				}
				catch (COMException)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}
		}

		/// <summary>Gets or sets a value indicating whether this is a class path.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether this is a class path.</returns>
		public bool IsClass
		{
			get
			{
				if (wmiPath == null)
				{
					return false;
				}
				ulong puResponse = 0uL;
				int info_ = wmiPath.GetInfo_(0u, out puResponse);
				if (info_ < 0)
				{
					if ((info_ & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)info_);
					}
					else
					{
						Marshal.ThrowExceptionForHR(info_, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				return (puResponse & 4) != 0;
			}
		}

		/// <summary>Gets or sets a value indicating whether this is an instance path.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether this is an instance path.</returns>
		public bool IsInstance
		{
			get
			{
				if (wmiPath == null)
				{
					return false;
				}
				ulong puResponse = 0uL;
				int info_ = wmiPath.GetInfo_(0u, out puResponse);
				if (info_ < 0)
				{
					if ((info_ & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)info_);
					}
					else
					{
						Marshal.ThrowExceptionForHR(info_, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				return (puResponse & 8) != 0;
			}
		}

		/// <summary>Gets or sets a value indicating whether this is a singleton instance path.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether this is a singleton instance path.</returns>
		public bool IsSingleton
		{
			get
			{
				if (wmiPath == null)
				{
					return false;
				}
				ulong puResponse = 0uL;
				int info_ = wmiPath.GetInfo_(0u, out puResponse);
				if (info_ < 0)
				{
					if ((info_ & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)info_);
					}
					else
					{
						Marshal.ThrowExceptionForHR(info_, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				return (puResponse & 0x1000) != 0;
			}
		}

		internal event IdentifierChangedEventHandler IdentifierChanged;

		private void FireIdentifierChanged()
		{
			if (this.IdentifierChanged != null)
			{
				this.IdentifierChanged(this, null);
			}
		}

		internal static string GetManagementPath(IWbemClassObjectFreeThreaded wbemObject)
		{
			string result = null;
			int num = -2147217407;
			if (wbemObject != null)
			{
				int pType = 0;
				int plFlavor = 0;
				object pVal = null;
				num = wbemObject.Get_("__PATH", 0, ref pVal, ref pType, ref plFlavor);
				if (num < 0 || pVal == DBNull.Value)
				{
					num = wbemObject.Get_("__RELPATH", 0, ref pVal, ref pType, ref plFlavor);
					if (num < 0)
					{
						if ((num & 0xFFFFF000u) == 2147749888u)
						{
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
						}
						else
						{
							Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
						}
					}
				}
				result = ((DBNull.Value != pVal) ? ((string)pVal) : null);
			}
			return result;
		}

		internal static bool IsValidNamespaceSyntax(string nsPath)
		{
			if (nsPath.Length != 0)
			{
				char[] anyOf = new char[2] { '\\', '/' };
				if (nsPath.IndexOfAny(anyOf) == -1 && string.Compare("root", nsPath, StringComparison.OrdinalIgnoreCase) != 0)
				{
					return false;
				}
			}
			return true;
		}

		internal static ManagementPath _Clone(ManagementPath path)
		{
			return _Clone(path, null);
		}

		internal static ManagementPath _Clone(ManagementPath path, IdentifierChangedEventHandler handler)
		{
			ManagementPath managementPath = new ManagementPath();
			if (handler != null)
			{
				managementPath.IdentifierChanged = handler;
			}
			if (path != null && path.wmiPath != null)
			{
				managementPath.wmiPath = path.wmiPath;
				managementPath.isWbemPathShared = (path.isWbemPathShared = true);
			}
			return managementPath;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementPath" /> class that is empty. This is the default constructor.</summary>
		public ManagementPath()
			: this(null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementPath" /> class for the given path.</summary>
		/// <param name="path">The object path.</param>
		public ManagementPath(string path)
		{
			if (path != null && 0 < path.Length)
			{
				wmiPath = CreateWbemPath(path);
			}
		}

		/// <summary>Returns the full object path as the string representation.</summary>
		/// <returns>A string containing the full object path represented by this object. This value is equivalent to the value of the <see cref="P:System.Management.ManagementPath.Path" /> property.</returns>
		public override string ToString()
		{
			return Path;
		}

		/// <summary>Returns a copy of the <see cref="T:System.Management.ManagementPath" />.</summary>
		/// <returns>The cloned object.</returns>
		public ManagementPath Clone()
		{
			return new ManagementPath(Path);
		}

		/// <summary>Creates a new object that is a copy of the current instance.</summary>
		/// <returns>A new object that is a copy of this instance.</returns>
		object ICloneable.Clone()
		{
			return Clone();
		}

		private IWbemPath CreateWbemPath(string path)
		{
			IWbemPath wbemPath = (IWbemPath)MTAHelper.CreateInMTA(typeof(WbemDefPath));
			SetWbemPath(wbemPath, path);
			return wbemPath;
		}

		private void SetWbemPath(string path)
		{
			if (wmiPath == null)
			{
				wmiPath = CreateWbemPath(path);
			}
			else
			{
				SetWbemPath(wmiPath, path);
			}
		}

		private static void SetWbemPath(IWbemPath wbemPath, string path)
		{
			if (wbemPath == null)
			{
				return;
			}
			uint num = 4u;
			if (string.Compare(path, "root", StringComparison.OrdinalIgnoreCase) == 0)
			{
				num |= 8u;
			}
			int num2 = wbemPath.SetText_(num, path);
			if (num2 < 0)
			{
				if ((num2 & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num2);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num2, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		private string GetWbemPath()
		{
			return GetWbemPath(wmiPath);
		}

		private static string GetWbemPath(IWbemPath wbemPath)
		{
			string text = string.Empty;
			if (wbemPath != null)
			{
				int lFlags = 4;
				uint puCount = 0u;
				int num = 0;
				num = wbemPath.GetNamespaceCount_(out puCount);
				if (num >= 0)
				{
					if (puCount == 0)
					{
						lFlags = 2;
					}
					uint puBuffLength = 0u;
					num = wbemPath.GetText_(lFlags, ref puBuffLength, null);
					if (num >= 0 && 0 < puBuffLength)
					{
						text = new string('0', (int)(puBuffLength - 1));
						num = wbemPath.GetText_(lFlags, ref puBuffLength, text);
					}
				}
				if (num < 0 && num != -2147217400)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}
			return text;
		}

		private void ClearKeys(bool setAsSingleton)
		{
			int num = 0;
			try
			{
				if (wmiPath != null)
				{
					IWbemPathKeyList pOut = null;
					num = wmiPath.GetKeyList_(out pOut);
					if (pOut != null)
					{
						num = pOut.RemoveAllKeys_(0u);
						if ((num & 0x80000000u) == 0L)
						{
							sbyte bSet = (sbyte)(setAsSingleton ? (-1) : 0);
							num = pOut.MakeSingleton_(bSet);
							FireIdentifierChanged();
						}
					}
				}
			}
			catch (COMException e)
			{
				ManagementException.ThrowWithExtendedInfo(e);
			}
			if ((num & 0xFFFFF000u) == 2147749888u)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
			}
			else if ((num & 0x80000000u) != 0L)
			{
				Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
			}
		}

		/// <summary>Sets the path as a new class path. This means that the path must have a class name but not key values.</summary>
		public void SetAsClass()
		{
			if (IsClass || IsInstance)
			{
				if (isWbemPathShared)
				{
					wmiPath = CreateWbemPath(GetWbemPath());
					isWbemPathShared = false;
				}
				ClearKeys(setAsSingleton: false);
				return;
			}
			throw new ManagementException(ManagementStatus.InvalidOperation, null, null);
		}

		/// <summary>Sets the path as a new singleton object path. This means that it is a path to an instance but there are no key values.</summary>
		public void SetAsSingleton()
		{
			if (IsClass || IsInstance)
			{
				if (isWbemPathShared)
				{
					wmiPath = CreateWbemPath(GetWbemPath());
					isWbemPathShared = false;
				}
				ClearKeys(setAsSingleton: true);
				return;
			}
			throw new ManagementException(ManagementStatus.InvalidOperation, null, null);
		}

		internal void SetRelativePath(string relPath)
		{
			ManagementPath managementPath = new ManagementPath(relPath);
			managementPath.NamespacePath = GetNamespacePath(8);
			managementPath.Server = Server;
			wmiPath = managementPath.wmiPath;
		}

		internal void UpdateRelativePath(string relPath)
		{
			if (relPath != null)
			{
				string empty = string.Empty;
				string namespacePath = GetNamespacePath(8);
				empty = ((namespacePath.Length <= 0) ? relPath : (namespacePath + ":" + relPath));
				if (isWbemPathShared)
				{
					wmiPath = CreateWbemPath(GetWbemPath());
					isWbemPathShared = false;
				}
				SetWbemPath(empty);
			}
		}

		internal string SetNamespacePath(string nsPath, out bool bChange)
		{
			int num = 0;
			string text = null;
			string text2 = null;
			IWbemPath wbemPath = null;
			bChange = false;
			if (!IsValidNamespaceSyntax(nsPath))
			{
				ManagementException.ThrowWithExtendedInfo(ManagementStatus.InvalidNamespace);
			}
			wbemPath = CreateWbemPath(nsPath);
			if (wmiPath == null)
			{
				wmiPath = CreateWbemPath("");
			}
			else if (isWbemPathShared)
			{
				wmiPath = CreateWbemPath(GetWbemPath());
				isWbemPathShared = false;
			}
			text = GetNamespacePath(wmiPath, 16);
			text2 = GetNamespacePath(wbemPath, 16);
			if (string.Compare(text, text2, StringComparison.OrdinalIgnoreCase) != 0)
			{
				wmiPath.RemoveAllNamespaces_();
				bChange = true;
				uint puCount = 0u;
				num = wbemPath.GetNamespaceCount_(out puCount);
				if (num >= 0)
				{
					for (uint num2 = 0u; num2 < puCount; num2++)
					{
						uint puNameBufLength = 0u;
						num = wbemPath.GetNamespaceAt_(num2, ref puNameBufLength, null);
						if (num < 0)
						{
							break;
						}
						string text3 = new string('0', (int)(puNameBufLength - 1));
						num = wbemPath.GetNamespaceAt_(num2, ref puNameBufLength, text3);
						if (num < 0)
						{
							break;
						}
						num = wmiPath.SetNamespaceAt_(num2, text3);
						if (num < 0)
						{
							break;
						}
					}
				}
			}
			if (num >= 0 && nsPath.Length > 1 && ((nsPath[0] == '\\' && nsPath[1] == '\\') || (nsPath[0] == '/' && nsPath[1] == '/')))
			{
				uint puNameBufLength2 = 0u;
				num = wbemPath.GetServer_(ref puNameBufLength2, null);
				if (num >= 0 && puNameBufLength2 != 0)
				{
					string text4 = new string('0', (int)(puNameBufLength2 - 1));
					num = wbemPath.GetServer_(ref puNameBufLength2, text4);
					if (num >= 0)
					{
						puNameBufLength2 = 0u;
						num = wmiPath.GetServer_(ref puNameBufLength2, null);
						if (num >= 0)
						{
							string text5 = new string('0', (int)(puNameBufLength2 - 1));
							num = wmiPath.GetServer_(ref puNameBufLength2, text5);
							if (num >= 0 && string.Compare(text5, text4, StringComparison.OrdinalIgnoreCase) != 0)
							{
								num = wmiPath.SetServer_(text4);
							}
						}
						else if (num == -2147217399)
						{
							num = wmiPath.SetServer_(text4);
							if (num >= 0)
							{
								bChange = true;
							}
						}
					}
				}
				else if (num == -2147217399)
				{
					num = 0;
				}
			}
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return text2;
		}

		internal string GetNamespacePath(int flags)
		{
			return GetNamespacePath(wmiPath, flags);
		}

		internal static string GetNamespacePath(IWbemPath wbemPath, int flags)
		{
			string text = string.Empty;
			if (wbemPath != null)
			{
				uint puCount = 0u;
				int num = 0;
				num = wbemPath.GetNamespaceCount_(out puCount);
				if (num >= 0 && puCount != 0)
				{
					uint puBuffLength = 0u;
					num = wbemPath.GetText_(flags, ref puBuffLength, null);
					if (num >= 0 && puBuffLength != 0)
					{
						text = new string('0', (int)(puBuffLength - 1));
						num = wbemPath.GetText_(flags, ref puBuffLength, text);
					}
				}
				if (num < 0 && num != -2147217400)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}
			return text;
		}
	}
	internal class ManagementPathConverter : ExpandableObjectConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(ManagementPath))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is ManagementPath && destinationType == typeof(InstanceDescriptor))
			{
				ManagementPath managementPath = (ManagementPath)value;
				ConstructorInfo constructor = typeof(ManagementPath).GetConstructor(new Type[1] { typeof(string) });
				if (constructor != null)
				{
					return new InstanceDescriptor(constructor, new object[1] { managementPath.Path });
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}
	}
	/// <summary>Provides an abstract base class for all management query objects.</summary>
	[TypeConverter(typeof(ManagementQueryConverter))]
	public abstract class ManagementQuery : ICloneable
	{
		internal const string DEFAULTQUERYLANGUAGE = "WQL";

		internal static readonly string tokenSelect = "select ";

		private string queryLanguage;

		private string queryString;

		/// <summary>Gets or sets the query in text format.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the query.</returns>
		public virtual string QueryString
		{
			get
			{
				if (queryString == null)
				{
					return string.Empty;
				}
				return queryString;
			}
			set
			{
				if (queryString != value)
				{
					ParseQuery(value);
					queryString = value;
					FireIdentifierChanged();
				}
			}
		}

		/// <summary>Gets or sets the query language used in the query string, defining the format of the query string.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the format of the query string.</returns>
		public virtual string QueryLanguage
		{
			get
			{
				if (queryLanguage == null)
				{
					return string.Empty;
				}
				return queryLanguage;
			}
			set
			{
				if (queryLanguage != value)
				{
					queryLanguage = value;
					FireIdentifierChanged();
				}
			}
		}

		internal event IdentifierChangedEventHandler IdentifierChanged;

		internal void FireIdentifierChanged()
		{
			if (this.IdentifierChanged != null)
			{
				this.IdentifierChanged(this, null);
			}
		}

		internal void SetQueryString(string qString)
		{
			queryString = qString;
		}

		internal ManagementQuery()
			: this("WQL", null)
		{
		}

		internal ManagementQuery(string query)
			: this("WQL", query)
		{
		}

		internal ManagementQuery(string language, string query)
		{
			QueryLanguage = language;
			QueryString = query;
		}

		/// <summary>Parses the query string and sets the property values accordingly. If the query is valid, the class name property and condition property of the query will be parsed.</summary>
		/// <param name="query">The query string to be parsed.</param>
		protected internal virtual void ParseQuery(string query)
		{
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The cloned object.</returns>
		public abstract object Clone();

		internal static void ParseToken(ref string q, string token, string op, ref bool bTokenFound, ref string tokenValue)
		{
			if (bTokenFound)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY_DUP_TOKEN"));
			}
			bTokenFound = true;
			q = q.Remove(0, token.Length).TrimStart(null);
			if (op != null)
			{
				if (q.IndexOf(op, StringComparison.Ordinal) != 0)
				{
					throw new ArgumentException(RC.GetString("INVALID_QUERY"));
				}
				q = q.Remove(0, op.Length).TrimStart(null);
			}
			if (q.Length == 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY_NULL_TOKEN"));
			}
			int length;
			if (-1 == (length = q.IndexOf(' ')))
			{
				length = q.Length;
			}
			tokenValue = q.Substring(0, length);
			q = q.Remove(0, tokenValue.Length).TrimStart(null);
		}

		internal static void ParseToken(ref string q, string token, ref bool bTokenFound)
		{
			if (bTokenFound)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY_DUP_TOKEN"));
			}
			bTokenFound = true;
			q = q.Remove(0, token.Length).TrimStart(null);
		}
	}
	/// <summary>Represents a management query that returns instances or classes.</summary>
	public class ObjectQuery : ManagementQuery
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ObjectQuery" /> class with no initialized values. This is the default constructor.</summary>
		public ObjectQuery()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ObjectQuery" /> class for a specific query string.</summary>
		/// <param name="query">The string representation of the query.</param>
		public ObjectQuery(string query)
			: base(query)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ObjectQuery" /> class for a specific query string and language.</summary>
		/// <param name="language">The query language in which this query is specified.</param>
		/// <param name="query">The string representation of the query.</param>
		public ObjectQuery(string language, string query)
			: base(language, query)
		{
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The cloned object.</returns>
		public override object Clone()
		{
			return new ObjectQuery(QueryLanguage, QueryString);
		}
	}
	/// <summary>Represents a WMI event query.</summary>
	public class EventQuery : ManagementQuery
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.EventQuery" /> class. This is the default constructor.</summary>
		public EventQuery()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.EventQuery" /> class for the specified query.</summary>
		/// <param name="query">A textual representation of the event query.</param>
		public EventQuery(string query)
			: base(query)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.EventQuery" /> class for the specified language and query.</summary>
		/// <param name="language">The language in which the query string is specified.</param>
		/// <param name="query">The string representation of the query.</param>
		public EventQuery(string language, string query)
			: base(language, query)
		{
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>The cloned object.</returns>
		public override object Clone()
		{
			return new EventQuery(QueryLanguage, QueryString);
		}
	}
	/// <summary>Represents a WMI data query in WQL format.</summary>
	public class WqlObjectQuery : ObjectQuery
	{
		/// <summary>Gets the language of the query.</summary>
		/// <returns>The language of the query.</returns>
		public override string QueryLanguage => base.QueryLanguage;

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.WqlObjectQuery" /> class. This is the default constructor.</summary>
		public WqlObjectQuery()
			: base(null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.WqlObjectQuery" /> class initialized to the specified query.</summary>
		/// <param name="query">The representation of the data query.</param>
		public WqlObjectQuery(string query)
			: base(query)
		{
		}

		/// <summary>Creates a copy of the object.</summary>
		/// <returns>The copied object.</returns>
		public override object Clone()
		{
			return new WqlObjectQuery(QueryString);
		}
	}
	/// <summary>Represents a WQL SELECT data query.</summary>
	public class SelectQuery : WqlObjectQuery
	{
		private bool isSchemaQuery;

		private string className;

		private string condition;

		private StringCollection selectedProperties;

		/// <summary>Gets or sets the query in the <see cref="T:System.Management.SelectQuery" /> object, in string form.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the query.</returns>
		public override string QueryString
		{
			get
			{
				BuildQuery();
				return base.QueryString;
			}
			set
			{
				base.QueryString = value;
			}
		}

		/// <summary>Gets or sets a value indicating whether this query is a schema query or an instances query.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the query is a schema query.</returns>
		public bool IsSchemaQuery
		{
			get
			{
				return isSchemaQuery;
			}
			set
			{
				isSchemaQuery = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the class name to be selected from in the query.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the name of the class in the query.</returns>
		public string ClassName
		{
			get
			{
				if (className == null)
				{
					return string.Empty;
				}
				return className;
			}
			set
			{
				className = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the condition to be applied in the SELECT query.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the condition to be applied to the SELECT query.</returns>
		public string Condition
		{
			get
			{
				if (condition == null)
				{
					return string.Empty;
				}
				return condition;
			}
			set
			{
				condition = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Ggets or sets an array of property names to be selected in the query.</summary>
		/// <returns>Returns a <see cref="T:System.Collections.Specialized.StringCollection" /> containing the names of the properties to be selected in the query.</returns>
		public StringCollection SelectedProperties
		{
			get
			{
				return selectedProperties;
			}
			set
			{
				if (value != null)
				{
					StringCollection stringCollection = new StringCollection();
					StringEnumerator enumerator = value.GetEnumerator();
					try
					{
						while (enumerator.MoveNext())
						{
							string current = enumerator.Current;
							stringCollection.Add(current);
						}
					}
					finally
					{
						if (enumerator is IDisposable disposable)
						{
							disposable.Dispose();
						}
					}
					selectedProperties = stringCollection;
				}
				else
				{
					selectedProperties = new StringCollection();
				}
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.SelectQuery" /> class. This is the default constructor.</summary>
		public SelectQuery()
			: this(null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.SelectQuery" /> class for the specified query or the specified class name.</summary>
		/// <param name="queryOrClassName">The entire query or the class name to use in the query. The parser in this class attempts to parse the string as a valid WQL SELECT query. If the parser is unsuccessful, it assumes the string is a class name.</param>
		public SelectQuery(string queryOrClassName)
		{
			selectedProperties = new StringCollection();
			if (queryOrClassName == null)
			{
				return;
			}
			if (queryOrClassName.TrimStart().StartsWith(ManagementQuery.tokenSelect, StringComparison.OrdinalIgnoreCase))
			{
				QueryString = queryOrClassName;
				return;
			}
			ManagementPath managementPath = new ManagementPath(queryOrClassName);
			if (managementPath.IsClass && managementPath.NamespacePath.Length == 0)
			{
				ClassName = queryOrClassName;
				return;
			}
			throw new ArgumentException(RC.GetString("INVALID_QUERY"), "queryOrClassName");
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.SelectQuery" /> class with the specified class name and condition.</summary>
		/// <param name="className">The name of the class to select in the query.</param>
		/// <param name="condition">The condition to be applied in the query.</param>
		public SelectQuery(string className, string condition)
			: this(className, condition, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.SelectQuery" /> class with the specified class name and condition, selecting only the specified properties.</summary>
		/// <param name="className">The name of the class from which to select.</param>
		/// <param name="condition">The condition to be applied to instances of the selected class.</param>
		/// <param name="selectedProperties">An array of property names to be returned in the query results.</param>
		public SelectQuery(string className, string condition, string[] selectedProperties)
		{
			isSchemaQuery = false;
			this.className = className;
			this.condition = condition;
			this.selectedProperties = new StringCollection();
			if (selectedProperties != null)
			{
				this.selectedProperties.AddRange(selectedProperties);
			}
			BuildQuery();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.SelectQuery" /> class for a schema query, optionally specifying a condition.</summary>
		/// <param name="isSchemaQuery">
		///   <see langword="true" /> to indicate that this is a schema query; otherwise, <see langword="false" />. A <see langword="false" /> value is invalid in this constructor.</param>
		/// <param name="condition">The condition to be applied to form the result set of classes.</param>
		public SelectQuery(bool isSchemaQuery, string condition)
		{
			if (!isSchemaQuery)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "isSchemaQuery");
			}
			this.isSchemaQuery = true;
			className = null;
			this.condition = condition;
			selectedProperties = null;
			BuildQuery();
		}

		/// <summary>Builds the query string according to the current property values.</summary>
		protected internal void BuildQuery()
		{
			string text;
			if (!isSchemaQuery)
			{
				if (className == null)
				{
					SetQueryString(string.Empty);
				}
				if (className == null || className.Length == 0)
				{
					return;
				}
				text = ManagementQuery.tokenSelect;
				if (selectedProperties != null && 0 < selectedProperties.Count)
				{
					int count = selectedProperties.Count;
					for (int i = 0; i < count; i++)
					{
						text = text + selectedProperties[i] + ((i == count - 1) ? " " : ",");
					}
				}
				else
				{
					text += "* ";
				}
				text = text + "from " + className;
			}
			else
			{
				text = "select * from meta_class";
			}
			if (Condition != null && Condition.Length != 0)
			{
				text = text + " where " + condition;
			}
			SetQueryString(text);
		}

		/// <summary>Parses the query string and sets the property values accordingly.</summary>
		/// <param name="query">The query string to be parsed.</param>
		protected internal override void ParseQuery(string query)
		{
			className = null;
			condition = null;
			if (selectedProperties != null)
			{
				selectedProperties.Clear();
			}
			string q = query.Trim();
			bool bTokenFound = false;
			if (!isSchemaQuery)
			{
				string text = ManagementQuery.tokenSelect;
				if (q.Length >= text.Length && string.Compare(q, 0, text, 0, text.Length, StringComparison.OrdinalIgnoreCase) == 0)
				{
					ManagementQuery.ParseToken(ref q, text, ref bTokenFound);
					if (q[0] != '*')
					{
						if (selectedProperties != null)
						{
							selectedProperties.Clear();
						}
						else
						{
							selectedProperties = new StringCollection();
						}
						int num;
						string text2;
						while ((num = q.IndexOf(',')) > 0)
						{
							text2 = q.Substring(0, num);
							q = q.Remove(0, num + 1).TrimStart(null);
							text2 = text2.Trim();
							if (text2.Length > 0)
							{
								selectedProperties.Add(text2);
							}
						}
						if ((num = q.IndexOf(' ')) <= 0)
						{
							throw new ArgumentException(RC.GetString("INVALID_QUERY"));
						}
						text2 = q.Substring(0, num);
						q = q.Remove(0, num).TrimStart(null);
						selectedProperties.Add(text2);
					}
					else
					{
						q = q.Remove(0, 1).TrimStart(null);
					}
					text = "from ";
					bTokenFound = false;
					if (q.Length >= text.Length && string.Compare(q, 0, text, 0, text.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref q, text, null, ref bTokenFound, ref className);
						text = "where ";
						if (q.Length >= text.Length && string.Compare(q, 0, text, 0, text.Length, StringComparison.OrdinalIgnoreCase) == 0)
						{
							condition = q.Substring(text.Length).Trim();
						}
						return;
					}
					throw new ArgumentException(RC.GetString("INVALID_QUERY"));
				}
				throw new ArgumentException(RC.GetString("INVALID_QUERY"));
			}
			string text3 = "select";
			if (q.Length < text3.Length || string.Compare(q, 0, text3, 0, text3.Length, StringComparison.OrdinalIgnoreCase) != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "select");
			}
			q = q.Remove(0, text3.Length).TrimStart(null);
			if (q.IndexOf('*', 0) != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "*");
			}
			q = q.Remove(0, 1).TrimStart(null);
			text3 = "from";
			if (q.Length < text3.Length || string.Compare(q, 0, text3, 0, text3.Length, StringComparison.OrdinalIgnoreCase) != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "from");
			}
			q = q.Remove(0, text3.Length).TrimStart(null);
			text3 = "meta_class";
			if (q.Length < text3.Length || string.Compare(q, 0, text3, 0, text3.Length, StringComparison.OrdinalIgnoreCase) != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "meta_class");
			}
			q = q.Remove(0, text3.Length).TrimStart(null);
			if (0 < q.Length)
			{
				text3 = "where";
				if (q.Length < text3.Length || string.Compare(q, 0, text3, 0, text3.Length, StringComparison.OrdinalIgnoreCase) != 0)
				{
					throw new ArgumentException(RC.GetString("INVALID_QUERY"), "where");
				}
				q = q.Remove(0, text3.Length);
				if (q.Length == 0 || !char.IsWhiteSpace(q[0]))
				{
					throw new ArgumentException(RC.GetString("INVALID_QUERY"));
				}
				q = (condition = q.TrimStart(null));
			}
			else
			{
				condition = string.Empty;
			}
			className = null;
			selectedProperties = null;
		}

		/// <summary>Creates a copy of the object.</summary>
		/// <returns>The copied object.</returns>
		public override object Clone()
		{
			string[] array = null;
			if (selectedProperties != null)
			{
				int count = selectedProperties.Count;
				if (0 < count)
				{
					array = new string[count];
					selectedProperties.CopyTo(array, 0);
				}
			}
			if (!isSchemaQuery)
			{
				return new SelectQuery(className, condition, array);
			}
			return new SelectQuery(isSchemaQuery: true, condition);
		}
	}
	/// <summary>Represents a WQL ASSOCIATORS OF data query. It can be used for both instances and schema queries.</summary>
	public class RelatedObjectQuery : WqlObjectQuery
	{
		private static readonly string tokenAssociators = "associators";

		private static readonly string tokenOf = "of";

		private static readonly string tokenWhere = "where";

		private static readonly string tokenResultClass = "resultclass";

		private static readonly string tokenAssocClass = "assocclass";

		private static readonly string tokenResultRole = "resultrole";

		private static readonly string tokenRole = "role";

		private static readonly string tokenRequiredQualifier = "requiredqualifier";

		private static readonly string tokenRequiredAssocQualifier = "requiredassocqualifier";

		private static readonly string tokenClassDefsOnly = "classdefsonly";

		private static readonly string tokenSchemaOnly = "schemaonly";

		private bool isSchemaQuery;

		private string sourceObject;

		private string relatedClass;

		private string relationshipClass;

		private string relatedQualifier;

		private string relationshipQualifier;

		private string relatedRole;

		private string thisRole;

		private bool classDefinitionsOnly;

		/// <summary>Gets or sets a value indicating whether this is a schema query or an instance query.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether this is a schema query.</returns>
		public bool IsSchemaQuery
		{
			get
			{
				return isSchemaQuery;
			}
			set
			{
				isSchemaQuery = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the source object to be used for the query. For instance queries, this is typically an instance path. For schema queries, this is typically a class name.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the path of the object to be used for the query.</returns>
		public string SourceObject
		{
			get
			{
				if (sourceObject == null)
				{
					return string.Empty;
				}
				return sourceObject;
			}
			set
			{
				sourceObject = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the class of the endpoint objects (the related class).</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the related class name.</returns>
		public string RelatedClass
		{
			get
			{
				if (relatedClass == null)
				{
					return string.Empty;
				}
				return relatedClass;
			}
			set
			{
				relatedClass = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the type of relationship (association).</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the relationship class name.</returns>
		public string RelationshipClass
		{
			get
			{
				if (relationshipClass == null)
				{
					return string.Empty;
				}
				return relationshipClass;
			}
			set
			{
				relationshipClass = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets a qualifier required to be defined on the related objects.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the name of the qualifier required on the related object.</returns>
		public string RelatedQualifier
		{
			get
			{
				if (relatedQualifier == null)
				{
					return string.Empty;
				}
				return relatedQualifier;
			}
			set
			{
				relatedQualifier = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets a qualifier required to be defined on the relationship objects.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the name of the qualifier required on the relationship objects.</returns>
		public string RelationshipQualifier
		{
			get
			{
				if (relationshipQualifier == null)
				{
					return string.Empty;
				}
				return relationshipQualifier;
			}
			set
			{
				relationshipQualifier = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the role that the related objects returned should be playing in the relationship.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the role of the related objects.</returns>
		public string RelatedRole
		{
			get
			{
				if (relatedRole == null)
				{
					return string.Empty;
				}
				return relatedRole;
			}
			set
			{
				relatedRole = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the role that the source object should be playing in the relationship.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the role of this object.</returns>
		public string ThisRole
		{
			get
			{
				if (thisRole == null)
				{
					return string.Empty;
				}
				return thisRole;
			}
			set
			{
				thisRole = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets a value indicating that for all instances that adhere to the query, only their class definitions be returned. This parameter is only valid for instance queries.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating that for all instances that adhere to the query, only their class definitions are to be returned.</returns>
		public bool ClassDefinitionsOnly
		{
			get
			{
				return classDefinitionsOnly;
			}
			set
			{
				classDefinitionsOnly = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.RelatedObjectQuery" /> class. This is the default constructor.</summary>
		public RelatedObjectQuery()
			: this(null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.RelatedObjectQuery" /> class. If the specified string can be successfully parsed as a WQL query, it is considered to be the query string; otherwise, it is assumed to be the path of the source object for the query. In this case, the query is assumed to be an instance query.</summary>
		/// <param name="queryOrSourceObject">The query string or the path of the source object.</param>
		public RelatedObjectQuery(string queryOrSourceObject)
		{
			if (queryOrSourceObject == null)
			{
				return;
			}
			if (queryOrSourceObject.TrimStart().StartsWith(tokenAssociators, StringComparison.OrdinalIgnoreCase))
			{
				QueryString = queryOrSourceObject;
				return;
			}
			ManagementPath managementPath = new ManagementPath(queryOrSourceObject);
			if ((managementPath.IsClass || managementPath.IsInstance) && managementPath.NamespacePath.Length == 0)
			{
				SourceObject = queryOrSourceObject;
				isSchemaQuery = false;
				return;
			}
			throw new ArgumentException(RC.GetString("INVALID_QUERY"), "queryOrSourceObject");
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.RelatedObjectQuery" /> class for the given source object and related class. The query is assumed to be an instance query (as opposed to a schema query).</summary>
		/// <param name="sourceObject">The path of the source object for this query.</param>
		/// <param name="relatedClass">The related objects' class.</param>
		public RelatedObjectQuery(string sourceObject, string relatedClass)
			: this(sourceObject, relatedClass, null, null, null, null, null, classDefinitionsOnly: false)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.RelatedObjectQuery" /> class for the given set of parameters. The query is assumed to be an instance query (as opposed to a schema query).</summary>
		/// <param name="sourceObject">The path of the source object.</param>
		/// <param name="relatedClass">The related objects' required class.</param>
		/// <param name="relationshipClass">The relationship type.</param>
		/// <param name="relatedQualifier">The qualifier required to be present on the related objects.</param>
		/// <param name="relationshipQualifier">The qualifier required to be present on the relationships.</param>
		/// <param name="relatedRole">The role that the related objects are required to play in the relationship.</param>
		/// <param name="thisRole">The role that the source object is required to play in the relationship.</param>
		/// <param name="classDefinitionsOnly">
		///   <see langword="true" /> to return only the class definitions of the related objects; otherwise, false .</param>
		public RelatedObjectQuery(string sourceObject, string relatedClass, string relationshipClass, string relatedQualifier, string relationshipQualifier, string relatedRole, string thisRole, bool classDefinitionsOnly)
		{
			isSchemaQuery = false;
			this.sourceObject = sourceObject;
			this.relatedClass = relatedClass;
			this.relationshipClass = relationshipClass;
			this.relatedQualifier = relatedQualifier;
			this.relationshipQualifier = relationshipQualifier;
			this.relatedRole = relatedRole;
			this.thisRole = thisRole;
			this.classDefinitionsOnly = classDefinitionsOnly;
			BuildQuery();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.RelatedObjectQuery" /> class for a schema query using the given set of parameters. This constructor is used for schema queries only: the first parameter must be set to <see langword="true" /> .</summary>
		/// <param name="isSchemaQuery">
		///   <see langword="true" /> to indicate that this is a schema query; otherwise, <see langword="false" /> .</param>
		/// <param name="sourceObject">The path of the source class.</param>
		/// <param name="relatedClass">The related objects' required base class.</param>
		/// <param name="relationshipClass">The relationship type.</param>
		/// <param name="relatedQualifier">The qualifier required to be present on the related objects.</param>
		/// <param name="relationshipQualifier">The qualifier required to be present on the relationships.</param>
		/// <param name="relatedRole">The role that the related objects are required to play in the relationship.</param>
		/// <param name="thisRole">The role that the source class is required to play in the relationship.</param>
		public RelatedObjectQuery(bool isSchemaQuery, string sourceObject, string relatedClass, string relationshipClass, string relatedQualifier, string relationshipQualifier, string relatedRole, string thisRole)
		{
			if (!isSchemaQuery)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "isSchemaQuery");
			}
			this.isSchemaQuery = true;
			this.sourceObject = sourceObject;
			this.relatedClass = relatedClass;
			this.relationshipClass = relationshipClass;
			this.relatedQualifier = relatedQualifier;
			this.relationshipQualifier = relationshipQualifier;
			this.relatedRole = relatedRole;
			this.thisRole = thisRole;
			classDefinitionsOnly = false;
			BuildQuery();
		}

		/// <summary>Builds the query string according to the current property values.</summary>
		protected internal void BuildQuery()
		{
			if (sourceObject == null)
			{
				SetQueryString(string.Empty);
			}
			if (sourceObject == null || sourceObject.Length == 0)
			{
				return;
			}
			string text = tokenAssociators + " " + tokenOf + " {" + sourceObject + "}";
			if (RelatedClass.Length != 0 || RelationshipClass.Length != 0 || RelatedQualifier.Length != 0 || RelationshipQualifier.Length != 0 || RelatedRole.Length != 0 || ThisRole.Length != 0 || classDefinitionsOnly || isSchemaQuery)
			{
				text = text + " " + tokenWhere;
				if (RelatedClass.Length != 0)
				{
					text = text + " " + tokenResultClass + " = " + relatedClass;
				}
				if (RelationshipClass.Length != 0)
				{
					text = text + " " + tokenAssocClass + " = " + relationshipClass;
				}
				if (RelatedRole.Length != 0)
				{
					text = text + " " + tokenResultRole + " = " + relatedRole;
				}
				if (ThisRole.Length != 0)
				{
					text = text + " " + tokenRole + " = " + thisRole;
				}
				if (RelatedQualifier.Length != 0)
				{
					text = text + " " + tokenRequiredQualifier + " = " + relatedQualifier;
				}
				if (RelationshipQualifier.Length != 0)
				{
					text = text + " " + tokenRequiredAssocQualifier + " = " + relationshipQualifier;
				}
				if (!isSchemaQuery)
				{
					if (classDefinitionsOnly)
					{
						text = text + " " + tokenClassDefsOnly;
					}
				}
				else
				{
					text = text + " " + tokenSchemaOnly;
				}
			}
			SetQueryString(text);
		}

		/// <summary>Parses the query string and sets the property values accordingly.</summary>
		/// <param name="query">The query string to be parsed.</param>
		protected internal override void ParseQuery(string query)
		{
			string text = null;
			string tokenValue = null;
			string tokenValue2 = null;
			string tokenValue3 = null;
			string tokenValue4 = null;
			string tokenValue5 = null;
			string tokenValue6 = null;
			bool flag = false;
			bool flag2 = false;
			string text2 = query.Trim();
			if (string.Compare(text2, 0, tokenAssociators, 0, tokenAssociators.Length, StringComparison.OrdinalIgnoreCase) != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "associators");
			}
			text2 = text2.Remove(0, tokenAssociators.Length);
			if (text2.Length == 0 || !char.IsWhiteSpace(text2[0]))
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"));
			}
			text2 = text2.TrimStart(null);
			if (string.Compare(text2, 0, tokenOf, 0, tokenOf.Length, StringComparison.OrdinalIgnoreCase) != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "of");
			}
			text2 = text2.Remove(0, tokenOf.Length).TrimStart(null);
			if (text2.IndexOf('{') != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"));
			}
			text2 = text2.Remove(0, 1).TrimStart(null);
			int num;
			if (-1 == (num = text2.IndexOf('}')))
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"));
			}
			text = text2.Substring(0, num).TrimEnd(null);
			text2 = text2.Remove(0, num + 1).TrimStart(null);
			if (0 < text2.Length)
			{
				if (string.Compare(text2, 0, tokenWhere, 0, tokenWhere.Length, StringComparison.OrdinalIgnoreCase) != 0)
				{
					throw new ArgumentException(RC.GetString("INVALID_QUERY"), "where");
				}
				text2 = text2.Remove(0, tokenWhere.Length);
				if (text2.Length == 0 || !char.IsWhiteSpace(text2[0]))
				{
					throw new ArgumentException(RC.GetString("INVALID_QUERY"));
				}
				text2 = text2.TrimStart(null);
				bool bTokenFound = false;
				bool bTokenFound2 = false;
				bool bTokenFound3 = false;
				bool bTokenFound4 = false;
				bool bTokenFound5 = false;
				bool bTokenFound6 = false;
				bool bTokenFound7 = false;
				bool bTokenFound8 = false;
				while (true)
				{
					if (text2.Length >= tokenResultClass.Length && string.Compare(text2, 0, tokenResultClass, 0, tokenResultClass.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref text2, tokenResultClass, "=", ref bTokenFound, ref tokenValue);
						continue;
					}
					if (text2.Length >= tokenAssocClass.Length && string.Compare(text2, 0, tokenAssocClass, 0, tokenAssocClass.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref text2, tokenAssocClass, "=", ref bTokenFound2, ref tokenValue2);
						continue;
					}
					if (text2.Length >= tokenResultRole.Length && string.Compare(text2, 0, tokenResultRole, 0, tokenResultRole.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref text2, tokenResultRole, "=", ref bTokenFound3, ref tokenValue3);
						continue;
					}
					if (text2.Length >= tokenRole.Length && string.Compare(text2, 0, tokenRole, 0, tokenRole.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref text2, tokenRole, "=", ref bTokenFound4, ref tokenValue4);
						continue;
					}
					if (text2.Length >= tokenRequiredQualifier.Length && string.Compare(text2, 0, tokenRequiredQualifier, 0, tokenRequiredQualifier.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref text2, tokenRequiredQualifier, "=", ref bTokenFound5, ref tokenValue5);
						continue;
					}
					if (text2.Length >= tokenRequiredAssocQualifier.Length && string.Compare(text2, 0, tokenRequiredAssocQualifier, 0, tokenRequiredAssocQualifier.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref text2, tokenRequiredAssocQualifier, "=", ref bTokenFound6, ref tokenValue6);
						continue;
					}
					if (text2.Length >= tokenSchemaOnly.Length && string.Compare(text2, 0, tokenSchemaOnly, 0, tokenSchemaOnly.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref text2, tokenSchemaOnly, ref bTokenFound8);
						flag2 = true;
						continue;
					}
					if (text2.Length < tokenClassDefsOnly.Length || string.Compare(text2, 0, tokenClassDefsOnly, 0, tokenClassDefsOnly.Length, StringComparison.OrdinalIgnoreCase) != 0)
					{
						break;
					}
					ManagementQuery.ParseToken(ref text2, tokenClassDefsOnly, ref bTokenFound7);
					flag = true;
				}
				if (text2.Length != 0)
				{
					throw new ArgumentException(RC.GetString("INVALID_QUERY"));
				}
				if (bTokenFound8 && bTokenFound7)
				{
					throw new ArgumentException(RC.GetString("INVALID_QUERY"));
				}
			}
			sourceObject = text;
			relatedClass = tokenValue;
			relationshipClass = tokenValue2;
			relatedRole = tokenValue3;
			thisRole = tokenValue4;
			relatedQualifier = tokenValue5;
			relationshipQualifier = tokenValue6;
			classDefinitionsOnly = flag;
			isSchemaQuery = flag2;
		}

		/// <summary>Creates a copy of the object.</summary>
		/// <returns>The copied object.</returns>
		public override object Clone()
		{
			if (!isSchemaQuery)
			{
				return new RelatedObjectQuery(sourceObject, relatedClass, relationshipClass, relatedQualifier, relationshipQualifier, relatedRole, thisRole, classDefinitionsOnly);
			}
			return new RelatedObjectQuery(isSchemaQuery: true, sourceObject, relatedClass, relationshipClass, relatedQualifier, relationshipQualifier, relatedRole, thisRole);
		}
	}
	/// <summary>Represents a WQL REFERENCES OF data query.</summary>
	public class RelationshipQuery : WqlObjectQuery
	{
		private static readonly string tokenReferences = "references";

		private static readonly string tokenOf = "of";

		private static readonly string tokenWhere = "where";

		private static readonly string tokenResultClass = "resultclass";

		private static readonly string tokenRole = "role";

		private static readonly string tokenRequiredQualifier = "requiredqualifier";

		private static readonly string tokenClassDefsOnly = "classdefsonly";

		private static readonly string tokenSchemaOnly = "schemaonly";

		private string sourceObject;

		private string relationshipClass;

		private string relationshipQualifier;

		private string thisRole;

		private bool classDefinitionsOnly;

		private bool isSchemaQuery;

		/// <summary>Gets or sets a value indicating whether this query is a schema query or an instance query.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether this query is a schema query.</returns>
		public bool IsSchemaQuery
		{
			get
			{
				return isSchemaQuery;
			}
			set
			{
				isSchemaQuery = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the source object for this query.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the path of the object to be used for the query.</returns>
		public string SourceObject
		{
			get
			{
				if (sourceObject == null)
				{
					return string.Empty;
				}
				return sourceObject;
			}
			set
			{
				sourceObject = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the class of the relationship objects wanted in the query.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the relationship class name.</returns>
		public string RelationshipClass
		{
			get
			{
				if (relationshipClass == null)
				{
					return string.Empty;
				}
				return relationshipClass;
			}
			set
			{
				relationshipClass = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets a qualifier required on the relationship objects.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the name of the qualifier required on the relationship objects.</returns>
		public string RelationshipQualifier
		{
			get
			{
				if (relationshipQualifier == null)
				{
					return string.Empty;
				}
				return relationshipQualifier;
			}
			set
			{
				relationshipQualifier = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets the role of the source object in the relationship.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the role of this object.</returns>
		public string ThisRole
		{
			get
			{
				if (thisRole == null)
				{
					return string.Empty;
				}
				return thisRole;
			}
			set
			{
				thisRole = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Gets or sets a value indicating that only the class definitions of the relevant relationship objects be returned.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating that only the class definitions of the relevant relationship objects be returned.</returns>
		public bool ClassDefinitionsOnly
		{
			get
			{
				return classDefinitionsOnly;
			}
			set
			{
				classDefinitionsOnly = value;
				BuildQuery();
				FireIdentifierChanged();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.RelationshipQuery" /> class. This is the default constructor.</summary>
		public RelationshipQuery()
			: this(null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.RelationshipQuery" /> class. If the specified string can be successfully parsed as a WQL query, it is considered to be the query string; otherwise, it is assumed to be the path of the source object for the query. In this case, the query is assumed to be an instances query.</summary>
		/// <param name="queryOrSourceObject">The query string or the class name for this query.</param>
		public RelationshipQuery(string queryOrSourceObject)
		{
			if (queryOrSourceObject == null)
			{
				return;
			}
			if (queryOrSourceObject.TrimStart().StartsWith(tokenReferences, StringComparison.OrdinalIgnoreCase))
			{
				QueryString = queryOrSourceObject;
				return;
			}
			ManagementPath managementPath = new ManagementPath(queryOrSourceObject);
			if ((managementPath.IsClass || managementPath.IsInstance) && managementPath.NamespacePath.Length == 0)
			{
				SourceObject = queryOrSourceObject;
				isSchemaQuery = false;
				return;
			}
			throw new ArgumentException(RC.GetString("INVALID_QUERY"), "queryOrSourceObject");
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.RelationshipQuery" /> class for the given source object and relationship class. The query is assumed to be an instance query (as opposed to a schema query).</summary>
		/// <param name="sourceObject">The path of the source object for this query.</param>
		/// <param name="relationshipClass">The type of relationship for which to query.</param>
		public RelationshipQuery(string sourceObject, string relationshipClass)
			: this(sourceObject, relationshipClass, null, null, classDefinitionsOnly: false)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.RelationshipQuery" /> class for the given set of parameters. The query is assumed to be an instance query (as opposed to a schema query).</summary>
		/// <param name="sourceObject">The path of the source object for this query.</param>
		/// <param name="relationshipClass">The type of relationship for which to query.</param>
		/// <param name="relationshipQualifier">A qualifier required to be present on the relationship object.</param>
		/// <param name="thisRole">The role that the source object is required to play in the relationship.</param>
		/// <param name="classDefinitionsOnly">When this method returns, it contains a Boolean that indicates that only class definitions for the resulting objects are returned.</param>
		public RelationshipQuery(string sourceObject, string relationshipClass, string relationshipQualifier, string thisRole, bool classDefinitionsOnly)
		{
			isSchemaQuery = false;
			this.sourceObject = sourceObject;
			this.relationshipClass = relationshipClass;
			this.relationshipQualifier = relationshipQualifier;
			this.thisRole = thisRole;
			this.classDefinitionsOnly = classDefinitionsOnly;
			BuildQuery();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.RelationshipQuery" /> class for a schema query using the given set of parameters. This constructor is used for schema queries only, so the first parameter must be true.</summary>
		/// <param name="isSchemaQuery">
		///   <see langword="true" /> to indicate that this is a schema query; otherwise, <see langword="false" />.</param>
		/// <param name="sourceObject">The path of the source class for this query.</param>
		/// <param name="relationshipClass">The type of relationship for which to query.</param>
		/// <param name="relationshipQualifier">A qualifier required to be present on the relationship class.</param>
		/// <param name="thisRole">The role that the source class is required to play in the relationship.</param>
		public RelationshipQuery(bool isSchemaQuery, string sourceObject, string relationshipClass, string relationshipQualifier, string thisRole)
		{
			if (!isSchemaQuery)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "isSchemaQuery");
			}
			this.isSchemaQuery = true;
			this.sourceObject = sourceObject;
			this.relationshipClass = relationshipClass;
			this.relationshipQualifier = relationshipQualifier;
			this.thisRole = thisRole;
			classDefinitionsOnly = false;
			BuildQuery();
		}

		/// <summary>Builds the query string according to the current property values.</summary>
		protected internal void BuildQuery()
		{
			if (sourceObject == null)
			{
				SetQueryString(string.Empty);
			}
			if (sourceObject == null || sourceObject.Length == 0)
			{
				return;
			}
			string text = tokenReferences + " " + tokenOf + " {" + sourceObject + "}";
			if (RelationshipClass.Length != 0 || RelationshipQualifier.Length != 0 || ThisRole.Length != 0 || classDefinitionsOnly || isSchemaQuery)
			{
				text = text + " " + tokenWhere;
				if (RelationshipClass.Length != 0)
				{
					text = text + " " + tokenResultClass + " = " + relationshipClass;
				}
				if (ThisRole.Length != 0)
				{
					text = text + " " + tokenRole + " = " + thisRole;
				}
				if (RelationshipQualifier.Length != 0)
				{
					text = text + " " + tokenRequiredQualifier + " = " + relationshipQualifier;
				}
				if (!isSchemaQuery)
				{
					if (classDefinitionsOnly)
					{
						text = text + " " + tokenClassDefsOnly;
					}
				}
				else
				{
					text = text + " " + tokenSchemaOnly;
				}
			}
			SetQueryString(text);
		}

		/// <summary>Parses the query string and sets the property values accordingly.</summary>
		/// <param name="query">The query string to be parsed.</param>
		protected internal override void ParseQuery(string query)
		{
			string text = null;
			string tokenValue = null;
			string tokenValue2 = null;
			string tokenValue3 = null;
			bool flag = false;
			bool flag2 = false;
			string text2 = query.Trim();
			if (string.Compare(text2, 0, tokenReferences, 0, tokenReferences.Length, StringComparison.OrdinalIgnoreCase) != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "references");
			}
			text2 = text2.Remove(0, tokenReferences.Length);
			if (text2.Length == 0 || !char.IsWhiteSpace(text2[0]))
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"));
			}
			text2 = text2.TrimStart(null);
			if (string.Compare(text2, 0, tokenOf, 0, tokenOf.Length, StringComparison.OrdinalIgnoreCase) != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "of");
			}
			text2 = text2.Remove(0, tokenOf.Length).TrimStart(null);
			if (text2.IndexOf('{') != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"));
			}
			text2 = text2.Remove(0, 1).TrimStart(null);
			int num;
			if (-1 == (num = text2.IndexOf('}')))
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"));
			}
			text = text2.Substring(0, num).TrimEnd(null);
			text2 = text2.Remove(0, num + 1).TrimStart(null);
			if (0 < text2.Length)
			{
				if (string.Compare(text2, 0, tokenWhere, 0, tokenWhere.Length, StringComparison.OrdinalIgnoreCase) != 0)
				{
					throw new ArgumentException(RC.GetString("INVALID_QUERY"), "where");
				}
				text2 = text2.Remove(0, tokenWhere.Length);
				if (text2.Length == 0 || !char.IsWhiteSpace(text2[0]))
				{
					throw new ArgumentException(RC.GetString("INVALID_QUERY"));
				}
				text2 = text2.TrimStart(null);
				bool bTokenFound = false;
				bool bTokenFound2 = false;
				bool bTokenFound3 = false;
				bool bTokenFound4 = false;
				bool bTokenFound5 = false;
				while (true)
				{
					if (text2.Length >= tokenResultClass.Length && string.Compare(text2, 0, tokenResultClass, 0, tokenResultClass.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref text2, tokenResultClass, "=", ref bTokenFound, ref tokenValue);
						continue;
					}
					if (text2.Length >= tokenRole.Length && string.Compare(text2, 0, tokenRole, 0, tokenRole.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref text2, tokenRole, "=", ref bTokenFound2, ref tokenValue2);
						continue;
					}
					if (text2.Length >= tokenRequiredQualifier.Length && string.Compare(text2, 0, tokenRequiredQualifier, 0, tokenRequiredQualifier.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref text2, tokenRequiredQualifier, "=", ref bTokenFound3, ref tokenValue3);
						continue;
					}
					if (text2.Length >= tokenClassDefsOnly.Length && string.Compare(text2, 0, tokenClassDefsOnly, 0, tokenClassDefsOnly.Length, StringComparison.OrdinalIgnoreCase) == 0)
					{
						ManagementQuery.ParseToken(ref text2, tokenClassDefsOnly, ref bTokenFound4);
						flag = true;
						continue;
					}
					if (text2.Length < tokenSchemaOnly.Length || string.Compare(text2, 0, tokenSchemaOnly, 0, tokenSchemaOnly.Length, StringComparison.OrdinalIgnoreCase) != 0)
					{
						break;
					}
					ManagementQuery.ParseToken(ref text2, tokenSchemaOnly, ref bTokenFound5);
					flag2 = true;
				}
				if (text2.Length != 0)
				{
					throw new ArgumentException(RC.GetString("INVALID_QUERY"));
				}
				if (flag && flag2)
				{
					throw new ArgumentException(RC.GetString("INVALID_QUERY"));
				}
			}
			sourceObject = text;
			relationshipClass = tokenValue;
			thisRole = tokenValue2;
			relationshipQualifier = tokenValue3;
			classDefinitionsOnly = flag;
			isSchemaQuery = flag2;
		}

		/// <summary>Creates a copy of the object.</summary>
		/// <returns>The copied object.</returns>
		public override object Clone()
		{
			if (!isSchemaQuery)
			{
				return new RelationshipQuery(sourceObject, relationshipClass, relationshipQualifier, thisRole, classDefinitionsOnly);
			}
			return new RelationshipQuery(isSchemaQuery: true, sourceObject, relationshipClass, relationshipQualifier, thisRole);
		}
	}
	/// <summary>Represents a WMI event query in WQL format.</summary>
	public class WqlEventQuery : EventQuery
	{
		private static readonly string tokenSelectAll = "select * ";

		private string eventClassName;

		private TimeSpan withinInterval;

		private string condition;

		private TimeSpan groupWithinInterval;

		private StringCollection groupByPropertyList;

		private string havingCondition;

		/// <summary>Gets  the language of the query.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value that contains the query language that the query is written in.</returns>
		public override string QueryLanguage => base.QueryLanguage;

		/// <summary>Gets or sets the string representing the query.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the query.</returns>
		public override string QueryString
		{
			get
			{
				BuildQuery();
				return base.QueryString;
			}
			set
			{
				base.QueryString = value;
			}
		}

		/// <summary>Gets or sets the event class to query.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the name of the event class in the event query.</returns>
		public string EventClassName
		{
			get
			{
				if (eventClassName == null)
				{
					return string.Empty;
				}
				return eventClassName;
			}
			set
			{
				eventClassName = value;
				BuildQuery();
			}
		}

		/// <summary>Gets or sets the condition to be applied to events of the specified class.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the condition or conditions in the event query.</returns>
		public string Condition
		{
			get
			{
				if (condition == null)
				{
					return string.Empty;
				}
				return condition;
			}
			set
			{
				condition = value;
				BuildQuery();
			}
		}

		/// <summary>Gets or sets the polling interval to be used in this query.</summary>
		/// <returns>Returns a <see cref="T:System.TimeSpan" /> value containing the polling interval used in the event query.</returns>
		public TimeSpan WithinInterval
		{
			get
			{
				return withinInterval;
			}
			set
			{
				withinInterval = value;
				BuildQuery();
			}
		}

		/// <summary>Gets or sets the interval to be used for grouping events of the same type.</summary>
		/// <returns>Returns a <see cref="T:System.TimeSpan" /> value containing the interval used for grouping events of the same type.</returns>
		public TimeSpan GroupWithinInterval
		{
			get
			{
				return groupWithinInterval;
			}
			set
			{
				groupWithinInterval = value;
				BuildQuery();
			}
		}

		/// <summary>Gets or sets properties in the event to be used for grouping events of the same type.</summary>
		/// <returns>Returns a <see cref="T:System.Collections.Specialized.StringCollection" /> containing the properties in the event to be used for grouping events of the same type.</returns>
		public StringCollection GroupByPropertyList
		{
			get
			{
				return groupByPropertyList;
			}
			set
			{
				StringCollection stringCollection = new StringCollection();
				StringEnumerator enumerator = value.GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						string current = enumerator.Current;
						stringCollection.Add(current);
					}
				}
				finally
				{
					if (enumerator is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
				groupByPropertyList = stringCollection;
				BuildQuery();
			}
		}

		/// <summary>Gets or sets the condition to be applied to the aggregation of events, based on the number of events received.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the condition applied to the aggregation of events, based on the number of events received.</returns>
		public string HavingCondition
		{
			get
			{
				if (havingCondition == null)
				{
					return string.Empty;
				}
				return havingCondition;
			}
			set
			{
				havingCondition = value;
				BuildQuery();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.WqlEventQuery" /> class. This is the default constructor.</summary>
		public WqlEventQuery()
			: this(null, TimeSpan.Zero, null, TimeSpan.Zero, null, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.WqlEventQuery" /> class based on the given query string or event class name.</summary>
		/// <param name="queryOrEventClassName">The string representing either the entire event query or the name of the event class to query. The object will try to parse the string as a valid event query. If unsuccessful, the parser will assume that the parameter represents an event class name.</param>
		public WqlEventQuery(string queryOrEventClassName)
		{
			groupByPropertyList = new StringCollection();
			if (queryOrEventClassName == null)
			{
				return;
			}
			if (queryOrEventClassName.TrimStart().StartsWith(tokenSelectAll, StringComparison.OrdinalIgnoreCase))
			{
				QueryString = queryOrEventClassName;
				return;
			}
			ManagementPath managementPath = new ManagementPath(queryOrEventClassName);
			if (managementPath.IsClass && managementPath.NamespacePath.Length == 0)
			{
				EventClassName = queryOrEventClassName;
				return;
			}
			throw new ArgumentException(RC.GetString("INVALID_QUERY"), "queryOrEventClassName");
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.WqlEventQuery" /> class for the specified event class name, with the specified condition.</summary>
		/// <param name="eventClassName">The name of the event class to query.</param>
		/// <param name="condition">The condition to apply to events of the specified class.</param>
		public WqlEventQuery(string eventClassName, string condition)
			: this(eventClassName, TimeSpan.Zero, condition, TimeSpan.Zero, null, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.WqlEventQuery" /> class for the specified event class, with the specified latency time.</summary>
		/// <param name="eventClassName">The name of the event class to query.</param>
		/// <param name="withinInterval">A <see cref="T:System.TimeSpan" /> value specifying the latency acceptable for receiving this event. This value is used in cases where there is no explicit event provider for the query requested, and WMI is required to poll for the condition. This interval is the maximum amount of time that can pass before notification of an event must be delivered.</param>
		public WqlEventQuery(string eventClassName, TimeSpan withinInterval)
			: this(eventClassName, withinInterval, null, TimeSpan.Zero, null, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.WqlEventQuery" /> class with the specified event class name, polling interval, and condition.</summary>
		/// <param name="eventClassName">The name of the event class to query.</param>
		/// <param name="withinInterval">A <see cref="T:System.TimeSpan" /> value specifying the latency acceptable for receiving this event. This value is used in cases where there is no explicit event provider for the query requested and WMI is required to poll for the condition. This interval is the maximum amount of time that can pass before notification of an event must be delivered.</param>
		/// <param name="condition">The condition to apply to events of the specified class.</param>
		public WqlEventQuery(string eventClassName, TimeSpan withinInterval, string condition)
			: this(eventClassName, withinInterval, condition, TimeSpan.Zero, null, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.WqlEventQuery" /> class with the specified event class name, condition, and grouping interval.</summary>
		/// <param name="eventClassName">The name of the event class to query.</param>
		/// <param name="condition">The condition to apply to events of the specified class.</param>
		/// <param name="groupWithinInterval">The specified interval at which WMI sends one aggregate event, rather than many events.</param>
		public WqlEventQuery(string eventClassName, string condition, TimeSpan groupWithinInterval)
			: this(eventClassName, TimeSpan.Zero, condition, groupWithinInterval, null, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.WqlEventQuery" /> class with the specified event class name, condition, grouping interval, and grouping properties.</summary>
		/// <param name="eventClassName">The name of the event class to query.</param>
		/// <param name="condition">The condition to apply to events of the specified class.</param>
		/// <param name="groupWithinInterval">The specified interval at which WMI sends one aggregate event, rather than many events.</param>
		/// <param name="groupByPropertyList">The properties in the event class by which the events should be grouped.</param>
		public WqlEventQuery(string eventClassName, string condition, TimeSpan groupWithinInterval, string[] groupByPropertyList)
			: this(eventClassName, TimeSpan.Zero, condition, groupWithinInterval, groupByPropertyList, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.WqlEventQuery" /> class with the specified event class name, condition, grouping interval, grouping properties, and specified number of events.</summary>
		/// <param name="eventClassName">The name of the event class on which to be queried.</param>
		/// <param name="withinInterval">A <see cref="T:System.TimeSpan" /> value specifying the latency acceptable for receiving this event. This value is used in cases where there is no explicit event provider for the query requested, and WMI is required to poll for the condition. This interval is the maximum amount of time that can pass before notification of an event must be delivered.</param>
		/// <param name="condition">The condition to apply to events of the specified class.</param>
		/// <param name="groupWithinInterval">The specified interval at which WMI sends one aggregate event, rather than many events.</param>
		/// <param name="groupByPropertyList">The properties in the event class by which the events should be grouped.</param>
		/// <param name="havingCondition">The condition to apply to the number of events.</param>
		public WqlEventQuery(string eventClassName, TimeSpan withinInterval, string condition, TimeSpan groupWithinInterval, string[] groupByPropertyList, string havingCondition)
		{
			this.eventClassName = eventClassName;
			this.withinInterval = withinInterval;
			this.condition = condition;
			this.groupWithinInterval = groupWithinInterval;
			this.groupByPropertyList = new StringCollection();
			if (groupByPropertyList != null)
			{
				this.groupByPropertyList.AddRange(groupByPropertyList);
			}
			this.havingCondition = havingCondition;
			BuildQuery();
		}

		/// <summary>Builds the query string according to the current property values.</summary>
		protected internal void BuildQuery()
		{
			if (eventClassName == null || eventClassName.Length == 0)
			{
				SetQueryString(string.Empty);
				return;
			}
			string text = tokenSelectAll;
			text = text + "from " + eventClassName;
			if (withinInterval != TimeSpan.Zero)
			{
				text = text + " within " + withinInterval.TotalSeconds.ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(double)));
			}
			if (Condition.Length != 0)
			{
				text = text + " where " + condition;
			}
			if (groupWithinInterval != TimeSpan.Zero)
			{
				text = text + " group within " + groupWithinInterval.TotalSeconds.ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(double)));
				if (groupByPropertyList != null && 0 < groupByPropertyList.Count)
				{
					int count = groupByPropertyList.Count;
					text += " by ";
					for (int i = 0; i < count; i++)
					{
						text = text + groupByPropertyList[i] + ((i == count - 1) ? "" : ",");
					}
				}
				if (HavingCondition.Length != 0)
				{
					text = text + " having " + havingCondition;
				}
			}
			SetQueryString(text);
		}

		/// <summary>Parses the query string and sets the property values accordingly.</summary>
		/// <param name="query">The query string to be parsed.</param>
		protected internal override void ParseQuery(string query)
		{
			eventClassName = null;
			withinInterval = TimeSpan.Zero;
			condition = null;
			groupWithinInterval = TimeSpan.Zero;
			if (groupByPropertyList != null)
			{
				groupByPropertyList.Clear();
			}
			havingCondition = null;
			string text = query.Trim();
			bool bTokenFound = false;
			string text2 = ManagementQuery.tokenSelect;
			if (text.Length < text2.Length || string.Compare(text, 0, text2, 0, text2.Length, StringComparison.OrdinalIgnoreCase) != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"));
			}
			text = text.Remove(0, text2.Length).TrimStart(null);
			if (!text.StartsWith("*", StringComparison.Ordinal))
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "*");
			}
			text = text.Remove(0, 1).TrimStart(null);
			text2 = "from ";
			if (text.Length < text2.Length || string.Compare(text, 0, text2, 0, text2.Length, StringComparison.OrdinalIgnoreCase) != 0)
			{
				throw new ArgumentException(RC.GetString("INVALID_QUERY"), "from");
			}
			ManagementQuery.ParseToken(ref text, text2, null, ref bTokenFound, ref eventClassName);
			text2 = "within ";
			if (text.Length >= text2.Length && string.Compare(text, 0, text2, 0, text2.Length, StringComparison.OrdinalIgnoreCase) == 0)
			{
				string tokenValue = null;
				bTokenFound = false;
				ManagementQuery.ParseToken(ref text, text2, null, ref bTokenFound, ref tokenValue);
				withinInterval = TimeSpan.FromSeconds(((IConvertible)tokenValue).ToDouble((IFormatProvider)null));
			}
			text2 = "group within ";
			string text3;
			int num;
			if (text.Length >= text2.Length && (num = text.ToLower(CultureInfo.InvariantCulture).IndexOf(text2, StringComparison.Ordinal)) != -1)
			{
				text3 = text.Substring(0, num).Trim();
				text = text.Remove(0, num);
				string tokenValue2 = null;
				bTokenFound = false;
				ManagementQuery.ParseToken(ref text, text2, null, ref bTokenFound, ref tokenValue2);
				groupWithinInterval = TimeSpan.FromSeconds(((IConvertible)tokenValue2).ToDouble((IFormatProvider)null));
				text2 = "by ";
				if (text.Length >= text2.Length && string.Compare(text, 0, text2, 0, text2.Length, StringComparison.OrdinalIgnoreCase) == 0)
				{
					text = text.Remove(0, text2.Length);
					if (groupByPropertyList != null)
					{
						groupByPropertyList.Clear();
					}
					else
					{
						groupByPropertyList = new StringCollection();
					}
					string text4;
					while ((num = text.IndexOf(',')) > 0)
					{
						text4 = text.Substring(0, num);
						text = text.Remove(0, num + 1).TrimStart(null);
						text4 = text4.Trim();
						if (text4.Length > 0)
						{
							groupByPropertyList.Add(text4);
						}
					}
					if ((num = text.IndexOf(' ')) <= 0)
					{
						groupByPropertyList.Add(text);
						return;
					}
					text4 = text.Substring(0, num);
					text = text.Remove(0, num).TrimStart(null);
					groupByPropertyList.Add(text4);
				}
				text2 = "having ";
				bTokenFound = false;
				if (text.Length >= text2.Length && string.Compare(text, 0, text2, 0, text2.Length, StringComparison.OrdinalIgnoreCase) == 0)
				{
					text = text.Remove(0, text2.Length);
					if (text.Length == 0)
					{
						throw new ArgumentException(RC.GetString("INVALID_QUERY"), "having");
					}
					havingCondition = text;
				}
			}
			else
			{
				text3 = text.Trim();
			}
			text2 = "where ";
			if (text3.Length >= text2.Length && string.Compare(text3, 0, text2, 0, text2.Length, StringComparison.OrdinalIgnoreCase) == 0)
			{
				condition = text3.Substring(text2.Length);
			}
		}

		/// <summary>Creates a copy of the object.</summary>
		/// <returns>The copied object.</returns>
		public override object Clone()
		{
			string[] array = null;
			if (groupByPropertyList != null)
			{
				int count = groupByPropertyList.Count;
				if (0 < count)
				{
					array = new string[count];
					groupByPropertyList.CopyTo(array, 0);
				}
			}
			return new WqlEventQuery(eventClassName, withinInterval, condition, groupWithinInterval, array, havingCondition);
		}
	}
	internal class ManagementQueryConverter : ExpandableObjectConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(ManagementQuery))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is EventQuery && destinationType == typeof(InstanceDescriptor))
			{
				EventQuery eventQuery = (EventQuery)value;
				ConstructorInfo constructor = typeof(EventQuery).GetConstructor(new Type[1] { typeof(string) });
				if (constructor != null)
				{
					return new InstanceDescriptor(constructor, new object[1] { eventQuery.QueryString });
				}
			}
			if (value is ObjectQuery && destinationType == typeof(InstanceDescriptor))
			{
				ObjectQuery objectQuery = (ObjectQuery)value;
				ConstructorInfo constructor2 = typeof(ObjectQuery).GetConstructor(new Type[1] { typeof(string) });
				if (constructor2 != null)
				{
					return new InstanceDescriptor(constructor2, new object[1] { objectQuery.QueryString });
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}
	}
	internal static class CompatSwitches
	{
		private const string DotNetVersion = "v4.0.30319";

		private const string RegKeyLocation = "SOFTWARE\\Microsoft\\.NETFramework\\v4.0.30319";

		private static readonly object s_syncLock = new object();

		private static int s_allowManagementObjectQI;

		private const string c_WMIDisableCOMSecurity = "WMIDisableCOMSecurity";

		public static bool AllowIManagementObjectQI
		{
			get
			{
				if (s_allowManagementObjectQI == 0)
				{
					lock (s_syncLock)
					{
						if (s_allowManagementObjectQI == 0)
						{
							s_allowManagementObjectQI = (GetSwitchValueFromRegistry() ? 1 : (-1));
						}
					}
				}
				if (s_allowManagementObjectQI != 1)
				{
					return false;
				}
				return true;
			}
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		private static bool GetSwitchValueFromRegistry()
		{
			RegistryKey registryKey = null;
			try
			{
				registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\.NETFramework\\v4.0.30319");
				if (registryKey == null)
				{
					return false;
				}
				return (int)registryKey.GetValue("WMIDisableCOMSecurity", -1) == 1;
			}
			catch (Exception ex)
			{
				if (ex is StackOverflowException || ex is OutOfMemoryException || ex is ThreadAbortException || ex is AccessViolationException)
				{
					throw;
				}
			}
			finally
			{
				registryKey?.Dispose();
			}
			return false;
		}
	}
	internal static class WmiNetUtilsHelper
	{
		internal delegate int ResetSecurity(IntPtr hToken);

		internal delegate int SetSecurity([In][Out] ref bool pNeedtoReset, [In][Out] ref IntPtr pHandle);

		internal delegate int BlessIWbemServices([MarshalAs(UnmanagedType.Interface)] IWbemServices pIUnknown, [In][MarshalAs(UnmanagedType.BStr)] string strUser, IntPtr password, [In][MarshalAs(UnmanagedType.BStr)] string strAuthority, int impersonationLevel, int authenticationLevel);

		internal delegate int BlessIWbemServicesObject([MarshalAs(UnmanagedType.IUnknown)] object pIUnknown, [In][MarshalAs(UnmanagedType.BStr)] string strUser, IntPtr password, [In][MarshalAs(UnmanagedType.BStr)] string strAuthority, int impersonationLevel, int authenticationLevel);

		internal delegate int GetPropertyHandle(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszPropertyName, out int pType, out int plHandle);

		internal delegate int WritePropertyValue(int vFunc, IntPtr pWbemClassObject, [In] int lHandle, [In] int lNumBytes, [In][MarshalAs(UnmanagedType.LPWStr)] string str);

		internal delegate int GetQualifierSet(int vFunc, IntPtr pWbemClassObject, out IntPtr ppQualSet);

		internal delegate int Get(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In][Out] ref object pVal, [In][Out] ref int pType, [In][Out] ref int plFlavor);

		internal delegate int Put(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In] ref object pVal, [In] int Type);

		internal delegate int Delete(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszName);

		internal delegate int GetNames(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszQualifierName, [In] int lFlags, [In] ref object pQualifierVal, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)] out string[] pNames);

		internal delegate int BeginEnumeration(int vFunc, IntPtr pWbemClassObject, [In] int lEnumFlags);

		internal delegate int Next(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)] ref string strName, [In][Out] ref object pVal, [In][Out] ref int pType, [In][Out] ref int plFlavor);

		internal delegate int EndEnumeration(int vFunc, IntPtr pWbemClassObject);

		internal delegate int GetPropertyQualifierSet(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszProperty, out IntPtr ppQualSet);

		internal delegate int Clone(int vFunc, IntPtr pWbemClassObject, out IntPtr ppCopy);

		internal delegate int GetObjectText(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [MarshalAs(UnmanagedType.BStr)] out string pstrObjectText);

		internal delegate int SpawnDerivedClass(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, out IntPtr ppNewClass);

		internal delegate int SpawnInstance(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, out IntPtr ppNewInstance);

		internal delegate int CompareTo(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [In] IntPtr pCompareTo);

		internal delegate int GetPropertyOrigin(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [MarshalAs(UnmanagedType.BStr)] out string pstrClassName);

		internal delegate int InheritsFrom(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string strAncestor);

		internal delegate int GetMethod(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, out IntPtr ppInSignature, out IntPtr ppOutSignature);

		internal delegate int PutMethod(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In] IntPtr pInSignature, [In] IntPtr pOutSignature);

		internal delegate int DeleteMethod(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszName);

		internal delegate int BeginMethodEnumeration(int vFunc, IntPtr pWbemClassObject, [In] int lEnumFlags);

		internal delegate int NextMethod(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [MarshalAs(UnmanagedType.BStr)] out string pstrName, out IntPtr ppInSignature, out IntPtr ppOutSignature);

		internal delegate int EndMethodEnumeration(int vFunc, IntPtr pWbemClassObject);

		internal delegate int GetMethodQualifierSet(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszMethod, out IntPtr ppQualSet);

		internal delegate int GetMethodOrigin(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszMethodName, [MarshalAs(UnmanagedType.BStr)] out string pstrClassName);

		internal delegate int QualifierSet_Get(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In][Out] ref object pVal, [In][Out] ref int plFlavor);

		internal delegate int QualifierSet_Put(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] ref object pVal, [In] int lFlavor);

		internal delegate int QualifierSet_Delete(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)] string wszName);

		internal delegate int QualifierSet_GetNames(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)] out string[] pNames);

		internal delegate int QualifierSet_BeginEnumeration(int vFunc, IntPtr pWbemClassObject, [In] int lFlags);

		internal delegate int QualifierSet_Next(int vFunc, IntPtr pWbemClassObject, [In] int lFlags, [MarshalAs(UnmanagedType.BStr)] out string pstrName, out object pVal, out int plFlavor);

		internal delegate int QualifierSet_EndEnumeration(int vFunc, IntPtr pWbemClassObject);

		internal delegate int GetCurrentApartmentType(int vFunc, IntPtr pComThreadingInfo, out APTTYPE aptType);

		internal delegate void VerifyClientKey();

		internal delegate int GetDemultiplexedStub([In][MarshalAs(UnmanagedType.IUnknown)] object pIUnknown, [In] bool isLocal, [MarshalAs(UnmanagedType.IUnknown)] out object ppIUnknown);

		internal delegate int CreateInstanceEnumWmi([In][MarshalAs(UnmanagedType.BStr)] string strFilter, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum, [In] int impLevel, [In] int authnLevel, [In][MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace, [In][MarshalAs(UnmanagedType.BStr)] string strUser, [In] IntPtr strPassword, [In][MarshalAs(UnmanagedType.BStr)] string strAuthority);

		internal delegate int CreateClassEnumWmi([In][MarshalAs(UnmanagedType.BStr)] string strSuperclass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum, [In] int impLevel, [In] int authnLevel, [In][MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace, [In][MarshalAs(UnmanagedType.BStr)] string strUser, [In] IntPtr strPassword, [In][MarshalAs(UnmanagedType.BStr)] string strAuthority);

		internal delegate int ExecQueryWmi([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum, [In] int impLevel, [In] int authnLevel, [In][MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace, [In][MarshalAs(UnmanagedType.BStr)] string strUser, [In] IntPtr strPassword, [In][MarshalAs(UnmanagedType.BStr)] string strAuthority);

		internal delegate int ExecNotificationQueryWmi([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum, [In] int impLevel, [In] int authnLevel, [In][MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace, [In][MarshalAs(UnmanagedType.BStr)] string strUser, [In] IntPtr strPassword, [In][MarshalAs(UnmanagedType.BStr)] string strAuthority);

		internal delegate int PutInstanceWmi([In] IntPtr pInst, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult, [In] int impLevel, [In] int authnLevel, [In][MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace, [In][MarshalAs(UnmanagedType.BStr)] string strUser, [In] IntPtr strPassword, [In][MarshalAs(UnmanagedType.BStr)] string strAuthority);

		internal delegate int PutClassWmi([In] IntPtr pObject, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult, [In] int impLevel, [In] int authnLevel, [In][MarshalAs(UnmanagedType.Interface)] IWbemServices pCurrentNamespace, [In][MarshalAs(UnmanagedType.BStr)] string strUser, [In] IntPtr strPassword, [In][MarshalAs(UnmanagedType.BStr)] string strAuthority);

		internal delegate int CloneEnumWbemClassObject([MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum, [In] int impLevel, [In] int authnLevel, [In][MarshalAs(UnmanagedType.Interface)] IEnumWbemClassObject pCurrentEnumWbemClassObject, [In][MarshalAs(UnmanagedType.BStr)] string strUser, [In] IntPtr strPassword, [In][MarshalAs(UnmanagedType.BStr)] string strAuthority);

		internal delegate int ConnectServerWmi([In][MarshalAs(UnmanagedType.BStr)] string strNetworkResource, [In][MarshalAs(UnmanagedType.BStr)] string strUser, [In] IntPtr strPassword, [In][MarshalAs(UnmanagedType.BStr)] string strLocale, [In] int lSecurityFlags, [In][MarshalAs(UnmanagedType.BStr)] string strAuthority, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IWbemServices ppNamespace, int impersonationLevel, int authenticationLevel);

		internal delegate IntPtr GetErrorInfo();

		internal delegate int Initialize([In] bool AllowIManagementObjectQI);

		internal enum APTTYPE
		{
			APTTYPE_CURRENT = -1,
			APTTYPE_STA,
			APTTYPE_MTA,
			APTTYPE_NA,
			APTTYPE_MAINSTA
		}

		internal static string myDllPath;

		internal static ResetSecurity ResetSecurity_f;

		internal static SetSecurity SetSecurity_f;

		internal static BlessIWbemServices BlessIWbemServices_f;

		internal static BlessIWbemServicesObject BlessIWbemServicesObject_f;

		internal static GetPropertyHandle GetPropertyHandle_f27;

		internal static WritePropertyValue WritePropertyValue_f28;

		internal static GetQualifierSet GetQualifierSet_f;

		internal static Get Get_f;

		internal static Put Put_f;

		internal static Delete Delete_f;

		internal static GetNames GetNames_f;

		internal static BeginEnumeration BeginEnumeration_f;

		internal static Next Next_f;

		internal static EndEnumeration EndEnumeration_f;

		internal static GetPropertyQualifierSet GetPropertyQualifierSet_f;

		internal static Clone Clone_f;

		internal static GetObjectText GetObjectText_f;

		internal static SpawnDerivedClass SpawnDerivedClass_f;

		internal static SpawnInstance SpawnInstance_f;

		internal static CompareTo CompareTo_f;

		internal static GetPropertyOrigin GetPropertyOrigin_f;

		internal static InheritsFrom InheritsFrom_f;

		internal static GetMethod GetMethod_f;

		internal static PutMethod PutMethod_f;

		internal static DeleteMethod DeleteMethod_f;

		internal static BeginMethodEnumeration BeginMethodEnumeration_f;

		internal static NextMethod NextMethod_f;

		internal static EndMethodEnumeration EndMethodEnumeration_f;

		internal static GetMethodQualifierSet GetMethodQualifierSet_f;

		internal static GetMethodOrigin GetMethodOrigin_f;

		internal static QualifierSet_Get QualifierGet_f;

		internal static QualifierSet_Put QualifierPut_f;

		internal static QualifierSet_Delete QualifierDelete_f;

		internal static QualifierSet_GetNames QualifierGetNames_f;

		internal static QualifierSet_BeginEnumeration QualifierBeginEnumeration_f;

		internal static QualifierSet_Next QualifierNext_f;

		internal static QualifierSet_EndEnumeration QualifierEndEnumeration_f;

		internal static GetCurrentApartmentType GetCurrentApartmentType_f;

		internal static VerifyClientKey VerifyClientKey_f;

		internal static Clone Clone_f12;

		internal static GetDemultiplexedStub GetDemultiplexedStub_f;

		internal static CreateInstanceEnumWmi CreateInstanceEnumWmi_f;

		internal static CreateClassEnumWmi CreateClassEnumWmi_f;

		internal static ExecQueryWmi ExecQueryWmi_f;

		internal static ExecNotificationQueryWmi ExecNotificationQueryWmi_f;

		internal static PutInstanceWmi PutInstanceWmi_f;

		internal static PutClassWmi PutClassWmi_f;

		internal static CloneEnumWbemClassObject CloneEnumWbemClassObject_f;

		internal static ConnectServerWmi ConnectServerWmi_f;

		internal static GetErrorInfo GetErrorInfo_f;

		internal static Initialize Initialize_f;

		[DllImport("kernel32.dll")]
		[SuppressUnmanagedCodeSecurity]
		internal static extern IntPtr LoadLibrary(string fileName);

		[DllImport("kernel32.dll")]
		[SuppressUnmanagedCodeSecurity]
		internal static extern IntPtr GetProcAddress(IntPtr hModule, string procname);

		static WmiNetUtilsHelper()
		{
			myDllPath = RuntimeEnvironment.GetRuntimeDirectory() + "\\wminet_utils.dll";
			IntPtr zero = IntPtr.Zero;
			IntPtr zero2 = IntPtr.Zero;
			zero2 = LoadLibrary(myDllPath);
			if (zero2 != IntPtr.Zero)
			{
				zero = GetProcAddress(zero2, "ResetSecurity");
				if (zero != IntPtr.Zero)
				{
					ResetSecurity_f = (ResetSecurity)Marshal.GetDelegateForFunctionPointer(zero, typeof(ResetSecurity));
				}
				zero = GetProcAddress(zero2, "SetSecurity");
				if (zero != IntPtr.Zero)
				{
					SetSecurity_f = (SetSecurity)Marshal.GetDelegateForFunctionPointer(zero, typeof(SetSecurity));
				}
				zero = GetProcAddress(zero2, "BlessIWbemServices");
				if (zero != IntPtr.Zero)
				{
					BlessIWbemServices_f = (BlessIWbemServices)Marshal.GetDelegateForFunctionPointer(zero, typeof(BlessIWbemServices));
				}
				zero = GetProcAddress(zero2, "BlessIWbemServicesObject");
				if (zero != IntPtr.Zero)
				{
					BlessIWbemServicesObject_f = (BlessIWbemServicesObject)Marshal.GetDelegateForFunctionPointer(zero, typeof(BlessIWbemServicesObject));
				}
				zero = GetProcAddress(zero2, "GetPropertyHandle");
				if (zero != IntPtr.Zero)
				{
					GetPropertyHandle_f27 = (GetPropertyHandle)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetPropertyHandle));
				}
				zero = GetProcAddress(zero2, "WritePropertyValue");
				if (zero != IntPtr.Zero)
				{
					WritePropertyValue_f28 = (WritePropertyValue)Marshal.GetDelegateForFunctionPointer(zero, typeof(WritePropertyValue));
				}
				zero = GetProcAddress(zero2, "Clone");
				if (zero != IntPtr.Zero)
				{
					Clone_f12 = (Clone)Marshal.GetDelegateForFunctionPointer(zero, typeof(Clone));
				}
				zero = GetProcAddress(zero2, "VerifyClientKey");
				if (zero != IntPtr.Zero)
				{
					VerifyClientKey_f = (VerifyClientKey)Marshal.GetDelegateForFunctionPointer(zero, typeof(VerifyClientKey));
				}
				zero = GetProcAddress(zero2, "GetQualifierSet");
				if (zero != IntPtr.Zero)
				{
					GetQualifierSet_f = (GetQualifierSet)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetQualifierSet));
				}
				zero = GetProcAddress(zero2, "Get");
				if (zero != IntPtr.Zero)
				{
					Get_f = (Get)Marshal.GetDelegateForFunctionPointer(zero, typeof(Get));
				}
				zero = GetProcAddress(zero2, "Put");
				if (zero != IntPtr.Zero)
				{
					Put_f = (Put)Marshal.GetDelegateForFunctionPointer(zero, typeof(Put));
				}
				zero = GetProcAddress(zero2, "Delete");
				if (zero != IntPtr.Zero)
				{
					Delete_f = (Delete)Marshal.GetDelegateForFunctionPointer(zero, typeof(Delete));
				}
				zero = GetProcAddress(zero2, "GetNames");
				if (zero != IntPtr.Zero)
				{
					GetNames_f = (GetNames)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetNames));
				}
				zero = GetProcAddress(zero2, "BeginEnumeration");
				if (zero != IntPtr.Zero)
				{
					BeginEnumeration_f = (BeginEnumeration)Marshal.GetDelegateForFunctionPointer(zero, typeof(BeginEnumeration));
				}
				zero = GetProcAddress(zero2, "Next");
				if (zero != IntPtr.Zero)
				{
					Next_f = (Next)Marshal.GetDelegateForFunctionPointer(zero, typeof(Next));
				}
				zero = GetProcAddress(zero2, "EndEnumeration");
				if (zero != IntPtr.Zero)
				{
					EndEnumeration_f = (EndEnumeration)Marshal.GetDelegateForFunctionPointer(zero, typeof(EndEnumeration));
				}
				zero = GetProcAddress(zero2, "GetPropertyQualifierSet");
				if (zero != IntPtr.Zero)
				{
					GetPropertyQualifierSet_f = (GetPropertyQualifierSet)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetPropertyQualifierSet));
				}
				zero = GetProcAddress(zero2, "Clone");
				if (zero != IntPtr.Zero)
				{
					Clone_f = (Clone)Marshal.GetDelegateForFunctionPointer(zero, typeof(Clone));
				}
				zero = GetProcAddress(zero2, "GetObjectText");
				if (zero != IntPtr.Zero)
				{
					GetObjectText_f = (GetObjectText)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetObjectText));
				}
				zero = GetProcAddress(zero2, "SpawnDerivedClass");
				if (zero != IntPtr.Zero)
				{
					SpawnDerivedClass_f = (SpawnDerivedClass)Marshal.GetDelegateForFunctionPointer(zero, typeof(SpawnDerivedClass));
				}
				zero = GetProcAddress(zero2, "SpawnInstance");
				if (zero != IntPtr.Zero)
				{
					SpawnInstance_f = (SpawnInstance)Marshal.GetDelegateForFunctionPointer(zero, typeof(SpawnInstance));
				}
				zero = GetProcAddress(zero2, "CompareTo");
				if (zero != IntPtr.Zero)
				{
					CompareTo_f = (CompareTo)Marshal.GetDelegateForFunctionPointer(zero, typeof(CompareTo));
				}
				zero = GetProcAddress(zero2, "GetPropertyOrigin");
				if (zero != IntPtr.Zero)
				{
					GetPropertyOrigin_f = (GetPropertyOrigin)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetPropertyOrigin));
				}
				zero = GetProcAddress(zero2, "InheritsFrom");
				if (zero != IntPtr.Zero)
				{
					InheritsFrom_f = (InheritsFrom)Marshal.GetDelegateForFunctionPointer(zero, typeof(InheritsFrom));
				}
				zero = GetProcAddress(zero2, "GetMethod");
				if (zero != IntPtr.Zero)
				{
					GetMethod_f = (GetMethod)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetMethod));
				}
				zero = GetProcAddress(zero2, "PutMethod");
				if (zero != IntPtr.Zero)
				{
					PutMethod_f = (PutMethod)Marshal.GetDelegateForFunctionPointer(zero, typeof(PutMethod));
				}
				zero = GetProcAddress(zero2, "DeleteMethod");
				if (zero != IntPtr.Zero)
				{
					DeleteMethod_f = (DeleteMethod)Marshal.GetDelegateForFunctionPointer(zero, typeof(DeleteMethod));
				}
				zero = GetProcAddress(zero2, "BeginMethodEnumeration");
				if (zero != IntPtr.Zero)
				{
					BeginMethodEnumeration_f = (BeginMethodEnumeration)Marshal.GetDelegateForFunctionPointer(zero, typeof(BeginMethodEnumeration));
				}
				zero = GetProcAddress(zero2, "NextMethod");
				if (zero != IntPtr.Zero)
				{
					NextMethod_f = (NextMethod)Marshal.GetDelegateForFunctionPointer(zero, typeof(NextMethod));
				}
				zero = GetProcAddress(zero2, "EndMethodEnumeration");
				if (zero != IntPtr.Zero)
				{
					EndMethodEnumeration_f = (EndMethodEnumeration)Marshal.GetDelegateForFunctionPointer(zero, typeof(EndMethodEnumeration));
				}
				zero = GetProcAddress(zero2, "GetMethodQualifierSet");
				if (zero != IntPtr.Zero)
				{
					GetMethodQualifierSet_f = (GetMethodQualifierSet)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetMethodQualifierSet));
				}
				zero = GetProcAddress(zero2, "GetMethodOrigin");
				if (zero != IntPtr.Zero)
				{
					GetMethodOrigin_f = (GetMethodOrigin)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetMethodOrigin));
				}
				zero = GetProcAddress(zero2, "QualifierSet_Get");
				if (zero != IntPtr.Zero)
				{
					QualifierGet_f = (QualifierSet_Get)Marshal.GetDelegateForFunctionPointer(zero, typeof(QualifierSet_Get));
				}
				zero = GetProcAddress(zero2, "QualifierSet_Put");
				if (zero != IntPtr.Zero)
				{
					QualifierPut_f = (QualifierSet_Put)Marshal.GetDelegateForFunctionPointer(zero, typeof(QualifierSet_Put));
				}
				zero = GetProcAddress(zero2, "QualifierSet_Delete");
				if (zero != IntPtr.Zero)
				{
					QualifierDelete_f = (QualifierSet_Delete)Marshal.GetDelegateForFunctionPointer(zero, typeof(QualifierSet_Delete));
				}
				zero = GetProcAddress(zero2, "QualifierSet_GetNames");
				if (zero != IntPtr.Zero)
				{
					QualifierGetNames_f = (QualifierSet_GetNames)Marshal.GetDelegateForFunctionPointer(zero, typeof(QualifierSet_GetNames));
				}
				zero = GetProcAddress(zero2, "QualifierSet_BeginEnumeration");
				if (zero != IntPtr.Zero)
				{
					QualifierBeginEnumeration_f = (QualifierSet_BeginEnumeration)Marshal.GetDelegateForFunctionPointer(zero, typeof(QualifierSet_BeginEnumeration));
				}
				zero = GetProcAddress(zero2, "QualifierSet_Next");
				if (zero != IntPtr.Zero)
				{
					QualifierNext_f = (QualifierSet_Next)Marshal.GetDelegateForFunctionPointer(zero, typeof(QualifierSet_Next));
				}
				zero = GetProcAddress(zero2, "QualifierSet_EndEnumeration");
				if (zero != IntPtr.Zero)
				{
					QualifierEndEnumeration_f = (QualifierSet_EndEnumeration)Marshal.GetDelegateForFunctionPointer(zero, typeof(QualifierSet_EndEnumeration));
				}
				zero = GetProcAddress(zero2, "GetCurrentApartmentType");
				if (zero != IntPtr.Zero)
				{
					GetCurrentApartmentType_f = (GetCurrentApartmentType)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetCurrentApartmentType));
				}
				zero = GetProcAddress(zero2, "GetDemultiplexedStub");
				if (zero != IntPtr.Zero)
				{
					GetDemultiplexedStub_f = (GetDemultiplexedStub)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetDemultiplexedStub));
				}
				zero = GetProcAddress(zero2, "CreateInstanceEnumWmi");
				if (zero != IntPtr.Zero)
				{
					CreateInstanceEnumWmi_f = (CreateInstanceEnumWmi)Marshal.GetDelegateForFunctionPointer(zero, typeof(CreateInstanceEnumWmi));
				}
				zero = GetProcAddress(zero2, "CreateClassEnumWmi");
				if (zero != IntPtr.Zero)
				{
					CreateClassEnumWmi_f = (CreateClassEnumWmi)Marshal.GetDelegateForFunctionPointer(zero, typeof(CreateClassEnumWmi));
				}
				zero = GetProcAddress(zero2, "ExecQueryWmi");
				if (zero != IntPtr.Zero)
				{
					ExecQueryWmi_f = (ExecQueryWmi)Marshal.GetDelegateForFunctionPointer(zero, typeof(ExecQueryWmi));
				}
				zero = GetProcAddress(zero2, "ExecNotificationQueryWmi");
				if (zero != IntPtr.Zero)
				{
					ExecNotificationQueryWmi_f = (ExecNotificationQueryWmi)Marshal.GetDelegateForFunctionPointer(zero, typeof(ExecNotificationQueryWmi));
				}
				zero = GetProcAddress(zero2, "PutInstanceWmi");
				if (zero != IntPtr.Zero)
				{
					PutInstanceWmi_f = (PutInstanceWmi)Marshal.GetDelegateForFunctionPointer(zero, typeof(PutInstanceWmi));
				}
				zero = GetProcAddress(zero2, "PutClassWmi");
				if (zero != IntPtr.Zero)
				{
					PutClassWmi_f = (PutClassWmi)Marshal.GetDelegateForFunctionPointer(zero, typeof(PutClassWmi));
				}
				zero = GetProcAddress(zero2, "CloneEnumWbemClassObject");
				if (zero != IntPtr.Zero)
				{
					CloneEnumWbemClassObject_f = (CloneEnumWbemClassObject)Marshal.GetDelegateForFunctionPointer(zero, typeof(CloneEnumWbemClassObject));
				}
				zero = GetProcAddress(zero2, "ConnectServerWmi");
				if (zero != IntPtr.Zero)
				{
					ConnectServerWmi_f = (ConnectServerWmi)Marshal.GetDelegateForFunctionPointer(zero, typeof(ConnectServerWmi));
				}
				zero = GetProcAddress(zero2, "GetErrorInfo");
				if (zero != IntPtr.Zero)
				{
					GetErrorInfo_f = (GetErrorInfo)Marshal.GetDelegateForFunctionPointer(zero, typeof(GetErrorInfo));
				}
				zero = GetProcAddress(zero2, "Initialize");
				if (zero != IntPtr.Zero)
				{
					Initialize_f = (Initialize)Marshal.GetDelegateForFunctionPointer(zero, typeof(Initialize));
				}
				Initialize_f(CompatSwitches.AllowIManagementObjectQI);
			}
		}
	}
	/// <summary>Represents a scope (namespace) for management operations.</summary>
	[TypeConverter(typeof(ManagementScopeConverter))]
	public class ManagementScope : ICloneable
	{
		private ManagementPath validatedPath;

		private IWbemServices wbemServices;

		private ConnectionOptions options;

		internal bool IsDefaulted;

		private ManagementPath prvpath
		{
			get
			{
				return validatedPath;
			}
			set
			{
				if (value != null)
				{
					string path = value.Path;
					if (!ManagementPath.IsValidNamespaceSyntax(path))
					{
						ManagementException.ThrowWithExtendedInfo(ManagementStatus.InvalidNamespace);
					}
				}
				validatedPath = value;
			}
		}

		/// <summary>Gets a value indicating whether the <see cref="T:System.Management.ManagementScope" /> is currently bound to a WMI server and namespace.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the scope is currently bound to a WMI server and namespace.</returns>
		public bool IsConnected => wbemServices != null;

		/// <summary>Gets or sets options for making the WMI connection.</summary>
		/// <returns>Returns a <see cref="T:System.Management.ConnectionOptions" /> that contains the options for making a WMI connection.</returns>
		public ConnectionOptions Options
		{
			get
			{
				if (options == null)
				{
					return options = ConnectionOptions._Clone(null, HandleIdentifierChange);
				}
				return options;
			}
			set
			{
				if (value != null)
				{
					if (options != null)
					{
						options.IdentifierChanged -= HandleIdentifierChange;
					}
					options = ConnectionOptions._Clone(value, HandleIdentifierChange);
					HandleIdentifierChange(this, null);
					return;
				}
				throw new ArgumentNullException("value");
			}
		}

		/// <summary>Gets or sets the path for the <see cref="T:System.Management.ManagementScope" />.</summary>
		/// <returns>Returns a <see cref="T:System.Management.ManagementPath" /> containing the path to the scope (namespace).</returns>
		public ManagementPath Path
		{
			get
			{
				if (prvpath == null)
				{
					return prvpath = ManagementPath._Clone(null);
				}
				return prvpath;
			}
			set
			{
				if (value != null)
				{
					if (prvpath != null)
					{
						prvpath.IdentifierChanged -= HandleIdentifierChange;
					}
					IsDefaulted = false;
					prvpath = ManagementPath._Clone(value, HandleIdentifierChange);
					HandleIdentifierChange(this, null);
					return;
				}
				throw new ArgumentNullException("value");
			}
		}

		internal event IdentifierChangedEventHandler IdentifierChanged;

		[DllImport("rpcrt4.dll")]
		private static extern int RpcMgmtEnableIdleCleanup();

		private void FireIdentifierChanged()
		{
			if (this.IdentifierChanged != null)
			{
				this.IdentifierChanged(this, null);
			}
		}

		private void HandleIdentifierChange(object sender, IdentifierChangedEventArgs args)
		{
			wbemServices = null;
			FireIdentifierChanged();
		}

		internal IWbemServices GetIWbemServices()
		{
			IWbemServices wbemServices = this.wbemServices;
			if (CompatSwitches.AllowIManagementObjectQI)
			{
				IntPtr iUnknownForObject = Marshal.GetIUnknownForObject(this.wbemServices);
				object objectForIUnknown = Marshal.GetObjectForIUnknown(iUnknownForObject);
				Marshal.Release(iUnknownForObject);
				if (objectForIUnknown != this.wbemServices)
				{
					SecurityHandler securityHandler = GetSecurityHandler();
					securityHandler.SecureIUnknown(objectForIUnknown);
					wbemServices = (IWbemServices)objectForIUnknown;
					securityHandler.Secure(wbemServices);
				}
			}
			return wbemServices;
		}

		internal ManagementScope(ManagementPath path, IWbemServices wbemServices, ConnectionOptions options)
		{
			if (path != null)
			{
				Path = path;
			}
			if (options != null)
			{
				Options = options;
			}
			this.wbemServices = wbemServices;
		}

		internal ManagementScope(ManagementPath path, ManagementScope scope)
			: this(path, scope?.options)
		{
		}

		internal static ManagementScope _Clone(ManagementScope scope)
		{
			return _Clone(scope, null);
		}

		internal static ManagementScope _Clone(ManagementScope scope, IdentifierChangedEventHandler handler)
		{
			ManagementScope managementScope = new ManagementScope(null, null, null);
			if (handler != null)
			{
				managementScope.IdentifierChanged = handler;
			}
			else if (scope != null)
			{
				managementScope.IdentifierChanged = scope.HandleIdentifierChange;
			}
			if (scope == null)
			{
				managementScope.prvpath = ManagementPath._Clone(ManagementPath.DefaultPath, managementScope.HandleIdentifierChange);
				managementScope.IsDefaulted = true;
				managementScope.wbemServices = null;
				managementScope.options = null;
			}
			else
			{
				if (scope.prvpath == null)
				{
					managementScope.prvpath = ManagementPath._Clone(ManagementPath.DefaultPath, managementScope.HandleIdentifierChange);
					managementScope.IsDefaulted = true;
				}
				else
				{
					managementScope.prvpath = ManagementPath._Clone(scope.prvpath, managementScope.HandleIdentifierChange);
					managementScope.IsDefaulted = scope.IsDefaulted;
				}
				managementScope.wbemServices = scope.wbemServices;
				if (scope.options != null)
				{
					managementScope.options = ConnectionOptions._Clone(scope.options, managementScope.HandleIdentifierChange);
				}
			}
			return managementScope;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementScope" /> class, with default values. This is the default constructor.</summary>
		public ManagementScope()
			: this(new ManagementPath(ManagementPath.DefaultPath.Path))
		{
			IsDefaulted = true;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementScope" /> class representing the specified scope path.</summary>
		/// <param name="path">A <see cref="T:System.Management.ManagementPath" /> containing the path to a server and namespace for the <see cref="T:System.Management.ManagementScope" />.</param>
		public ManagementScope(ManagementPath path)
			: this(path, (ConnectionOptions)null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementScope" /> class representing the specified scope path.</summary>
		/// <param name="path">The server and namespace path for the <see cref="T:System.Management.ManagementScope" />.</param>
		public ManagementScope(string path)
			: this(new ManagementPath(path), (ConnectionOptions)null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementScope" /> class representing the specified scope path, with the specified options.</summary>
		/// <param name="path">The server and namespace for the <see cref="T:System.Management.ManagementScope" />.</param>
		/// <param name="options">A <see cref="T:System.Management.ConnectionOptions" /> containing options for the connection.</param>
		public ManagementScope(string path, ConnectionOptions options)
			: this(new ManagementPath(path), options)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementScope" /> class representing the specified scope path, with the specified options.</summary>
		/// <param name="path">A <see cref="T:System.Management.ManagementPath" /> containing the path to the server and namespace for the <see cref="T:System.Management.ManagementScope" />.</param>
		/// <param name="options">The <see cref="T:System.Management.ConnectionOptions" /> containing options for the connection.</param>
		public ManagementScope(ManagementPath path, ConnectionOptions options)
		{
			if (path != null)
			{
				prvpath = ManagementPath._Clone(path, HandleIdentifierChange);
			}
			else
			{
				prvpath = ManagementPath._Clone(null);
			}
			if (options != null)
			{
				this.options = ConnectionOptions._Clone(options, HandleIdentifierChange);
			}
			else
			{
				this.options = null;
			}
			IsDefaulted = false;
		}

		/// <summary>Returns a copy of the object.</summary>
		/// <returns>A new copy of the <see cref="T:System.Management.ManagementScope" />.</returns>
		public ManagementScope Clone()
		{
			return _Clone(this);
		}

		/// <summary>Creates a new object that is a copy of the current instance.</summary>
		/// <returns>A new object that is a copy of this instance.</returns>
		object ICloneable.Clone()
		{
			return Clone();
		}

		/// <summary>Connects this <see cref="T:System.Management.ManagementScope" /> to the actual WMI scope.</summary>
		public void Connect()
		{
			Initialize();
		}

		internal void Initialize()
		{
			if (prvpath == null)
			{
				throw new InvalidOperationException();
			}
			if (IsConnected)
			{
				return;
			}
			lock (this)
			{
				if (!IsConnected)
				{
					if (!MTAHelper.IsNoContextMTA())
					{
						ThreadDispatch threadDispatch = new ThreadDispatch((ThreadDispatch.ThreadWorkerMethodWithParam)InitializeGuts);
						threadDispatch.Parameter = this;
						threadDispatch.Start();
					}
					else
					{
						InitializeGuts(this);
					}
				}
			}
		}

		private void InitializeGuts(object o)
		{
			ManagementScope managementScope = (ManagementScope)o;
			IWbemLocator wbemLocator = (IWbemLocator)new WbemLocator();
			IntPtr zero = IntPtr.Zero;
			if (managementScope.options == null)
			{
				managementScope.Options = new ConnectionOptions();
			}
			string text = managementScope.prvpath.GetNamespacePath(8);
			if (text == null || text.Length == 0)
			{
				text = managementScope.prvpath.SetNamespacePath(ManagementPath.DefaultPath.Path, out var _);
			}
			int num = 0;
			managementScope.wbemServices = null;
			if (Environment.OSVersion.Platform == PlatformID.Win32NT && ((Environment.OSVersion.Version.Major == 5 && Environment.OSVersion.Version.Minor >= 1) || Environment.OSVersion.Version.Major >= 6))
			{
				managementScope.options.Flags |= 128;
			}
			try
			{
				num = GetSecuredConnectHandler().ConnectNSecureIWbemServices(text, ref managementScope.wbemServices);
			}
			catch (COMException e)
			{
				ManagementException.ThrowWithExtendedInfo(e);
			}
			if ((num & 0xFFFFF000u) == 2147749888u)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
			}
			else if ((num & 0x80000000u) != 0L)
			{
				Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
			}
		}

		internal SecurityHandler GetSecurityHandler()
		{
			return new SecurityHandler(this);
		}

		internal SecuredConnectHandler GetSecuredConnectHandler()
		{
			return new SecuredConnectHandler(this);
		}

		internal SecuredIEnumWbemClassObjectHandler GetSecuredIEnumWbemClassObjectHandler(IEnumWbemClassObject pEnumWbemClassObject)
		{
			return new SecuredIEnumWbemClassObjectHandler(this, pEnumWbemClassObject);
		}

		internal SecuredIWbemServicesHandler GetSecuredIWbemServicesHandler(IWbemServices pWbemServiecs)
		{
			return new SecuredIWbemServicesHandler(this, pWbemServiecs);
		}
	}
	internal class SecuredIEnumWbemClassObjectHandler
	{
		private IEnumWbemClassObject pEnumWbemClassObjectsecurityHelper;

		private ManagementScope scope;

		internal SecuredIEnumWbemClassObjectHandler(ManagementScope theScope, IEnumWbemClassObject pEnumWbemClassObject)
		{
			scope = theScope;
			pEnumWbemClassObjectsecurityHelper = pEnumWbemClassObject;
		}

		internal int Reset_()
		{
			int num = -2147217407;
			return pEnumWbemClassObjectsecurityHelper.Reset_();
		}

		internal int Next_(int lTimeout, uint uCount, IWbemClassObject_DoNotMarshal[] ppOutParams, ref uint puReturned)
		{
			int num = -2147217407;
			return pEnumWbemClassObjectsecurityHelper.Next_(lTimeout, uCount, ppOutParams, out puReturned);
		}

		internal int NextAsync_(uint uCount, IWbemObjectSink pSink)
		{
			int num = -2147217407;
			return pEnumWbemClassObjectsecurityHelper.NextAsync_(uCount, pSink);
		}

		internal int Clone_(ref IEnumWbemClassObject ppEnum)
		{
			int result = -2147217407;
			if (scope != null)
			{
				IntPtr password = scope.Options.GetPassword();
				result = WmiNetUtilsHelper.CloneEnumWbemClassObject_f(out ppEnum, (int)scope.Options.Authentication, (int)scope.Options.Impersonation, pEnumWbemClassObjectsecurityHelper, scope.Options.Username, password, scope.Options.Authority);
				Marshal.ZeroFreeBSTR(password);
			}
			return result;
		}

		internal int Skip_(int lTimeout, uint nCount)
		{
			int num = -2147217407;
			return pEnumWbemClassObjectsecurityHelper.Skip_(lTimeout, nCount);
		}
	}
	internal class SecuredConnectHandler
	{
		private ManagementScope scope;

		internal SecuredConnectHandler(ManagementScope theScope)
		{
			scope = theScope;
		}

		internal int ConnectNSecureIWbemServices(string path, ref IWbemServices pServices)
		{
			int result = -2147217407;
			if (scope != null)
			{
				bool pNeedtoReset = false;
				IntPtr pHandle = IntPtr.Zero;
				try
				{
					if (scope.Options.EnablePrivileges && !CompatSwitches.AllowIManagementObjectQI)
					{
						WmiNetUtilsHelper.SetSecurity_f(ref pNeedtoReset, ref pHandle);
					}
					IntPtr password = scope.Options.GetPassword();
					result = WmiNetUtilsHelper.ConnectServerWmi_f(path, scope.Options.Username, password, scope.Options.Locale, scope.Options.Flags, scope.Options.Authority, scope.Options.GetContext(), out pServices, (int)scope.Options.Impersonation, (int)scope.Options.Authentication);
					Marshal.ZeroFreeBSTR(password);
					return result;
				}
				finally
				{
					if (pNeedtoReset)
					{
						pNeedtoReset = false;
						WmiNetUtilsHelper.ResetSecurity_f(pHandle);
					}
				}
			}
			return result;
		}
	}
	internal class SecuredIWbemServicesHandler
	{
		private IWbemServices pWbemServiecsSecurityHelper;

		private ManagementScope scope;

		internal SecuredIWbemServicesHandler(ManagementScope theScope, IWbemServices pWbemServiecs)
		{
			scope = theScope;
			pWbemServiecsSecurityHelper = pWbemServiecs;
		}

		internal int OpenNamespace_(string strNamespace, int lFlags, ref IWbemServices ppWorkingNamespace, IntPtr ppCallResult)
		{
			return -2147217396;
		}

		internal int CancelAsyncCall_(IWbemObjectSink pSink)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.CancelAsyncCall_(pSink);
		}

		internal int QueryObjectSink_(int lFlags, ref IWbemObjectSink ppResponseHandler)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.QueryObjectSink_(lFlags, out ppResponseHandler);
		}

		internal int GetObject_(string strObjectPath, int lFlags, IWbemContext pCtx, ref IWbemClassObjectFreeThreaded ppObject, IntPtr ppCallResult)
		{
			int result = -2147217407;
			if ((object)ppCallResult != (object)IntPtr.Zero)
			{
				result = pWbemServiecsSecurityHelper.GetObject_(strObjectPath, lFlags, pCtx, out ppObject, ppCallResult);
			}
			return result;
		}

		internal int GetObjectAsync_(string strObjectPath, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.GetObjectAsync_(strObjectPath, lFlags, pCtx, pResponseHandler);
		}

		internal int PutClass_(IWbemClassObjectFreeThreaded pObject, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
		{
			int result = -2147217407;
			if (scope != null)
			{
				IntPtr password = scope.Options.GetPassword();
				result = WmiNetUtilsHelper.PutClassWmi_f(pObject, lFlags, pCtx, ppCallResult, (int)scope.Options.Authentication, (int)scope.Options.Impersonation, pWbemServiecsSecurityHelper, scope.Options.Username, password, scope.Options.Authority);
				Marshal.ZeroFreeBSTR(password);
			}
			return result;
		}

		internal int PutClassAsync_(IWbemClassObjectFreeThreaded pObject, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.PutClassAsync_(pObject, lFlags, pCtx, pResponseHandler);
		}

		internal int DeleteClass_(string strClass, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
		{
			int result = -2147217407;
			if ((object)ppCallResult != (object)IntPtr.Zero)
			{
				result = pWbemServiecsSecurityHelper.DeleteClass_(strClass, lFlags, pCtx, ppCallResult);
			}
			return result;
		}

		internal int DeleteClassAsync_(string strClass, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.DeleteClassAsync_(strClass, lFlags, pCtx, pResponseHandler);
		}

		internal int CreateClassEnum_(string strSuperClass, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
		{
			int result = -2147217407;
			if (scope != null)
			{
				IntPtr password = scope.Options.GetPassword();
				result = WmiNetUtilsHelper.CreateClassEnumWmi_f(strSuperClass, lFlags, pCtx, out ppEnum, (int)scope.Options.Authentication, (int)scope.Options.Impersonation, pWbemServiecsSecurityHelper, scope.Options.Username, password, scope.Options.Authority);
				Marshal.ZeroFreeBSTR(password);
			}
			return result;
		}

		internal int CreateClassEnumAsync_(string strSuperClass, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.CreateClassEnumAsync_(strSuperClass, lFlags, pCtx, pResponseHandler);
		}

		internal int PutInstance_(IWbemClassObjectFreeThreaded pInst, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
		{
			int result = -2147217407;
			if (scope != null)
			{
				IntPtr password = scope.Options.GetPassword();
				result = WmiNetUtilsHelper.PutInstanceWmi_f(pInst, lFlags, pCtx, ppCallResult, (int)scope.Options.Authentication, (int)scope.Options.Impersonation, pWbemServiecsSecurityHelper, scope.Options.Username, password, scope.Options.Authority);
				Marshal.ZeroFreeBSTR(password);
			}
			return result;
		}

		internal int PutInstanceAsync_(IWbemClassObjectFreeThreaded pInst, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.PutInstanceAsync_(pInst, lFlags, pCtx, pResponseHandler);
		}

		internal int DeleteInstance_(string strObjectPath, int lFlags, IWbemContext pCtx, IntPtr ppCallResult)
		{
			int result = -2147217407;
			if ((object)ppCallResult != (object)IntPtr.Zero)
			{
				result = pWbemServiecsSecurityHelper.DeleteInstance_(strObjectPath, lFlags, pCtx, ppCallResult);
			}
			return result;
		}

		internal int DeleteInstanceAsync_(string strObjectPath, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.DeleteInstanceAsync_(strObjectPath, lFlags, pCtx, pResponseHandler);
		}

		internal int CreateInstanceEnum_(string strFilter, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
		{
			int result = -2147217407;
			if (scope != null)
			{
				IntPtr password = scope.Options.GetPassword();
				result = WmiNetUtilsHelper.CreateInstanceEnumWmi_f(strFilter, lFlags, pCtx, out ppEnum, (int)scope.Options.Authentication, (int)scope.Options.Impersonation, pWbemServiecsSecurityHelper, scope.Options.Username, password, scope.Options.Authority);
				Marshal.ZeroFreeBSTR(password);
			}
			return result;
		}

		internal int CreateInstanceEnumAsync_(string strFilter, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.CreateInstanceEnumAsync_(strFilter, lFlags, pCtx, pResponseHandler);
		}

		internal int ExecQuery_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
		{
			int result = -2147217407;
			if (scope != null)
			{
				IntPtr password = scope.Options.GetPassword();
				result = WmiNetUtilsHelper.ExecQueryWmi_f(strQueryLanguage, strQuery, lFlags, pCtx, out ppEnum, (int)scope.Options.Authentication, (int)scope.Options.Impersonation, pWbemServiecsSecurityHelper, scope.Options.Username, password, scope.Options.Authority);
				Marshal.ZeroFreeBSTR(password);
			}
			return result;
		}

		internal int ExecQueryAsync_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.ExecQueryAsync_(strQueryLanguage, strQuery, lFlags, pCtx, pResponseHandler);
		}

		internal int ExecNotificationQuery_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, ref IEnumWbemClassObject ppEnum)
		{
			int result = -2147217407;
			if (scope != null)
			{
				IntPtr password = scope.Options.GetPassword();
				result = WmiNetUtilsHelper.ExecNotificationQueryWmi_f(strQueryLanguage, strQuery, lFlags, pCtx, out ppEnum, (int)scope.Options.Authentication, (int)scope.Options.Impersonation, pWbemServiecsSecurityHelper, scope.Options.Username, password, scope.Options.Authority);
				Marshal.ZeroFreeBSTR(password);
			}
			return result;
		}

		internal int ExecNotificationQueryAsync_(string strQueryLanguage, string strQuery, int lFlags, IWbemContext pCtx, IWbemObjectSink pResponseHandler)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.ExecNotificationQueryAsync_(strQueryLanguage, strQuery, lFlags, pCtx, pResponseHandler);
		}

		internal int ExecMethod_(string strObjectPath, string strMethodName, int lFlags, IWbemContext pCtx, IWbemClassObjectFreeThreaded pInParams, ref IWbemClassObjectFreeThreaded ppOutParams, IntPtr ppCallResult)
		{
			int result = -2147217407;
			if ((object)ppCallResult != (object)IntPtr.Zero)
			{
				result = pWbemServiecsSecurityHelper.ExecMethod_(strObjectPath, strMethodName, lFlags, pCtx, pInParams, out ppOutParams, ppCallResult);
			}
			return result;
		}

		internal int ExecMethodAsync_(string strObjectPath, string strMethodName, int lFlags, IWbemContext pCtx, IWbemClassObjectFreeThreaded pInParams, IWbemObjectSink pResponseHandler)
		{
			int num = -2147217407;
			return pWbemServiecsSecurityHelper.ExecMethodAsync_(strObjectPath, strMethodName, lFlags, pCtx, pInParams, pResponseHandler);
		}
	}
	internal class SecurityHandler
	{
		private bool needToReset;

		private IntPtr handle;

		private ManagementScope scope;

		internal SecurityHandler(ManagementScope theScope)
		{
			scope = theScope;
			if (scope != null && scope.Options.EnablePrivileges)
			{
				WmiNetUtilsHelper.SetSecurity_f(ref needToReset, ref handle);
			}
		}

		internal void Reset()
		{
			if (needToReset)
			{
				needToReset = false;
				if (scope != null)
				{
					WmiNetUtilsHelper.ResetSecurity_f(handle);
				}
			}
		}

		internal void Secure(IWbemServices services)
		{
			if (scope != null)
			{
				IntPtr password = scope.Options.GetPassword();
				int num = WmiNetUtilsHelper.BlessIWbemServices_f(services, scope.Options.Username, password, scope.Options.Authority, (int)scope.Options.Impersonation, (int)scope.Options.Authentication);
				Marshal.ZeroFreeBSTR(password);
				if (num < 0)
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		internal void SecureIUnknown(object unknown)
		{
			if (scope != null)
			{
				IntPtr password = scope.Options.GetPassword();
				int num = WmiNetUtilsHelper.BlessIWbemServicesObject_f(unknown, scope.Options.Username, password, scope.Options.Authority, (int)scope.Options.Impersonation, (int)scope.Options.Authentication);
				Marshal.ZeroFreeBSTR(password);
				if (num < 0)
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}
	}
	internal class ManagementScopeConverter : ExpandableObjectConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(ManagementScope))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is ManagementScope && destinationType == typeof(InstanceDescriptor))
			{
				ManagementScope managementScope = (ManagementScope)value;
				ConstructorInfo constructor = typeof(ManagementScope).GetConstructor(new Type[1] { typeof(string) });
				if (constructor != null)
				{
					return new InstanceDescriptor(constructor, new object[1] { managementScope.Path.Path });
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}
	}
	internal sealed class RC
	{
		private static readonly ResourceManager resMgr = new ResourceManager(Assembly.GetExecutingAssembly().GetName().Name, Assembly.GetExecutingAssembly(), null);

		private RC()
		{
		}

		public static string GetString(string strToGet)
		{
			return resMgr.GetString(strToGet, CultureInfo.CurrentCulture);
		}
	}
	internal class ValueTypeSafety
	{
		public static object GetSafeObject(object theValue)
		{
			if (theValue == null)
			{
				return null;
			}
			if (theValue.GetType().IsPrimitive)
			{
				return ((IConvertible)theValue).ToType(typeof(object), null);
			}
			return RuntimeHelpers.GetObjectValue(theValue);
		}
	}
	/// <summary>Represents information about a WMI property.</summary>
	public class PropertyData
	{
		private ManagementBaseObject parent;

		private string propertyName;

		private object propertyValue;

		private long propertyNullEnumValue;

		private int propertyType;

		private int propertyFlavor;

		private QualifierDataCollection qualifiers;

		/// <summary>Gets the name of the property.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the property name.</returns>
		public string Name
		{
			get
			{
				if (propertyName == null)
				{
					return "";
				}
				return propertyName;
			}
		}

		/// <summary>Gets or sets the current value of the property.</summary>
		/// <returns>Returns an <see cref="T:System.Object" /> value representing the value of the property.</returns>
		public object Value
		{
			get
			{
				RefreshPropertyInfo();
				return ValueTypeSafety.GetSafeObject(MapWmiValueToValue(propertyValue, (CimType)(propertyType & -8193), (propertyType & 0x2000) != 0));
			}
			set
			{
				RefreshPropertyInfo();
				object pVal = MapValueToWmiValue(value, (CimType)(propertyType & -8193), (propertyType & 0x2000) != 0);
				int num = parent.wbemObject.Put_(propertyName, 0, ref pVal, 0);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				else if (parent.GetType() == typeof(ManagementObject))
				{
					((ManagementObject)parent).Path.UpdateRelativePath((string)parent["__RELPATH"]);
				}
			}
		}

		/// <summary>Gets the CIM type of the property.</summary>
		/// <returns>Returns a <see cref="T:System.Management.CimType" /> enumeration value representing the CIM type of the property.</returns>
		public CimType Type
		{
			get
			{
				RefreshPropertyInfo();
				return (CimType)(propertyType & -8193);
			}
		}

		/// <summary>Gets a value indicating whether the property has been defined in the current WMI class.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the property has been defined in the current WMI class.</returns>
		public bool IsLocal
		{
			get
			{
				RefreshPropertyInfo();
				if ((propertyFlavor & 0x20) == 0)
				{
					return true;
				}
				return false;
			}
		}

		/// <summary>Gets a value indicating whether the property is an array.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the property is an array.</returns>
		public bool IsArray
		{
			get
			{
				RefreshPropertyInfo();
				return (propertyType & 0x2000) != 0;
			}
		}

		/// <summary>Gets the name of the WMI class in the hierarchy in which the property was introduced.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the name of the WMI class in the hierarchy in which the property was introduced.</returns>
		public string Origin
		{
			get
			{
				string pstrClassName = null;
				int propertyOrigin_ = parent.wbemObject.GetPropertyOrigin_(propertyName, out pstrClassName);
				if (propertyOrigin_ < 0)
				{
					if (propertyOrigin_ == -2147217393)
					{
						pstrClassName = string.Empty;
					}
					else if ((propertyOrigin_ & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)propertyOrigin_);
					}
					else
					{
						Marshal.ThrowExceptionForHR(propertyOrigin_, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				return pstrClassName;
			}
		}

		/// <summary>Gets the set of qualifiers defined on the property.</summary>
		/// <returns>Returns a <see cref="T:System.Management.QualifierDataCollection" /> containing the set of qualifiers defined on the property.</returns>
		public QualifierDataCollection Qualifiers
		{
			get
			{
				if (qualifiers == null)
				{
					qualifiers = new QualifierDataCollection(parent, propertyName, QualifierType.PropertyQualifier);
				}
				return qualifiers;
			}
		}

		internal long NullEnumValue
		{
			get
			{
				return propertyNullEnumValue;
			}
			set
			{
				propertyNullEnumValue = value;
			}
		}

		internal PropertyData(ManagementBaseObject parent, string propName)
		{
			this.parent = parent;
			propertyName = propName;
			qualifiers = null;
			RefreshPropertyInfo();
		}

		private void RefreshPropertyInfo()
		{
			propertyValue = null;
			int num = parent.wbemObject.Get_(propertyName, 0, ref propertyValue, ref propertyType, ref propertyFlavor);
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		internal static object MapWmiValueToValue(object wmiValue, CimType type, bool isArray)
		{
			object obj = null;
			if (DBNull.Value != wmiValue && wmiValue != null)
			{
				if (!isArray)
				{
					obj = type switch
					{
						CimType.SInt8 => (sbyte)(short)wmiValue, 
						CimType.UInt16 => (ushort)(int)wmiValue, 
						CimType.UInt32 => (uint)(int)wmiValue, 
						CimType.UInt64 => Convert.ToUInt64((string)wmiValue, (IFormatProvider)CultureInfo.CurrentCulture.GetFormat(typeof(ulong))), 
						CimType.SInt64 => Convert.ToInt64((string)wmiValue, (IFormatProvider)CultureInfo.CurrentCulture.GetFormat(typeof(long))), 
						CimType.Char16 => (char)(short)wmiValue, 
						CimType.Object => new ManagementBaseObject(new IWbemClassObjectFreeThreaded(Marshal.GetIUnknownForObject(wmiValue))), 
						_ => wmiValue, 
					};
				}
				else
				{
					Array array = (Array)wmiValue;
					int length = array.Length;
					switch (type)
					{
					case CimType.UInt16:
					{
						obj = new ushort[length];
						for (int n = 0; n < length; n++)
						{
							((ushort[])obj)[n] = (ushort)(int)array.GetValue(n);
						}
						break;
					}
					case CimType.UInt32:
					{
						obj = new uint[length];
						for (int j = 0; j < length; j++)
						{
							((uint[])obj)[j] = (uint)(int)array.GetValue(j);
						}
						break;
					}
					case CimType.UInt64:
					{
						obj = new ulong[length];
						for (int l = 0; l < length; l++)
						{
							((ulong[])obj)[l] = Convert.ToUInt64((string)array.GetValue(l), (IFormatProvider)CultureInfo.CurrentCulture.GetFormat(typeof(ulong)));
						}
						break;
					}
					case CimType.SInt8:
					{
						obj = new sbyte[length];
						for (int num = 0; num < length; num++)
						{
							((sbyte[])obj)[num] = (sbyte)(short)array.GetValue(num);
						}
						break;
					}
					case CimType.SInt64:
					{
						obj = new long[length];
						for (int m = 0; m < length; m++)
						{
							((long[])obj)[m] = Convert.ToInt64((string)array.GetValue(m), (IFormatProvider)CultureInfo.CurrentCulture.GetFormat(typeof(long)));
						}
						break;
					}
					case CimType.Char16:
					{
						obj = new char[length];
						for (int k = 0; k < length; k++)
						{
							((char[])obj)[k] = (char)(short)array.GetValue(k);
						}
						break;
					}
					case CimType.Object:
					{
						obj = new ManagementBaseObject[length];
						for (int i = 0; i < length; i++)
						{
							((ManagementBaseObject[])obj)[i] = new ManagementBaseObject(new IWbemClassObjectFreeThreaded(Marshal.GetIUnknownForObject(array.GetValue(i))));
						}
						break;
					}
					default:
						obj = wmiValue;
						break;
					}
				}
			}
			return obj;
		}

		internal static object MapValueToWmiValue(object val, CimType type, bool isArray)
		{
			object obj = DBNull.Value;
			CultureInfo invariantCulture = CultureInfo.InvariantCulture;
			if (val != null)
			{
				if (isArray)
				{
					Array array = (Array)val;
					int length = array.Length;
					switch (type)
					{
					case CimType.SInt8:
					{
						obj = new short[length];
						for (int j = 0; j < length; j++)
						{
							((short[])obj)[j] = Convert.ToSByte(array.GetValue(j), (IFormatProvider)invariantCulture.GetFormat(typeof(sbyte)));
						}
						break;
					}
					case CimType.UInt8:
					{
						if (val is byte[])
						{
							obj = val;
							break;
						}
						obj = new byte[length];
						for (int num3 = 0; num3 < length; num3++)
						{
							((byte[])obj)[num3] = Convert.ToByte(array.GetValue(num3), (IFormatProvider)invariantCulture.GetFormat(typeof(byte)));
						}
						break;
					}
					case CimType.SInt16:
					{
						if (val is short[])
						{
							obj = val;
							break;
						}
						obj = new short[length];
						for (int num6 = 0; num6 < length; num6++)
						{
							((short[])obj)[num6] = Convert.ToInt16(array.GetValue(num6), (IFormatProvider)invariantCulture.GetFormat(typeof(short)));
						}
						break;
					}
					case CimType.UInt16:
					{
						obj = new int[length];
						for (int n = 0; n < length; n++)
						{
							((int[])obj)[n] = Convert.ToUInt16(array.GetValue(n), (IFormatProvider)invariantCulture.GetFormat(typeof(ushort)));
						}
						break;
					}
					case CimType.SInt32:
					{
						if (val is int[])
						{
							obj = val;
							break;
						}
						obj = new int[length];
						for (int num2 = 0; num2 < length; num2++)
						{
							((int[])obj)[num2] = Convert.ToInt32(array.GetValue(num2), (IFormatProvider)invariantCulture.GetFormat(typeof(int)));
						}
						break;
					}
					case CimType.UInt32:
					{
						obj = new int[length];
						for (int l = 0; l < length; l++)
						{
							((int[])obj)[l] = (int)Convert.ToUInt32(array.GetValue(l), (IFormatProvider)invariantCulture.GetFormat(typeof(uint)));
						}
						break;
					}
					case CimType.SInt64:
					{
						obj = new string[length];
						for (int num8 = 0; num8 < length; num8++)
						{
							((string[])obj)[num8] = Convert.ToInt64(array.GetValue(num8), (IFormatProvider)invariantCulture.GetFormat(typeof(long))).ToString((IFormatProvider)invariantCulture.GetFormat(typeof(long)));
						}
						break;
					}
					case CimType.UInt64:
					{
						obj = new string[length];
						for (int num4 = 0; num4 < length; num4++)
						{
							((string[])obj)[num4] = Convert.ToUInt64(array.GetValue(num4), (IFormatProvider)invariantCulture.GetFormat(typeof(ulong))).ToString((IFormatProvider)invariantCulture.GetFormat(typeof(ulong)));
						}
						break;
					}
					case CimType.Real32:
					{
						if (val is float[])
						{
							obj = val;
							break;
						}
						obj = new float[length];
						for (int m = 0; m < length; m++)
						{
							((float[])obj)[m] = Convert.ToSingle(array.GetValue(m), (IFormatProvider)invariantCulture.GetFormat(typeof(float)));
						}
						break;
					}
					case CimType.Real64:
					{
						if (val is double[])
						{
							obj = val;
							break;
						}
						obj = new double[length];
						for (int num7 = 0; num7 < length; num7++)
						{
							((double[])obj)[num7] = Convert.ToDouble(array.GetValue(num7), (IFormatProvider)invariantCulture.GetFormat(typeof(double)));
						}
						break;
					}
					case CimType.Char16:
					{
						obj = new short[length];
						for (int num5 = 0; num5 < length; num5++)
						{
							((short[])obj)[num5] = (short)Convert.ToChar(array.GetValue(num5), (IFormatProvider)invariantCulture.GetFormat(typeof(char)));
						}
						break;
					}
					case CimType.String:
					case CimType.DateTime:
					case CimType.Reference:
					{
						if (val is string[])
						{
							obj = val;
							break;
						}
						obj = new string[length];
						for (int num = 0; num < length; num++)
						{
							((string[])obj)[num] = array.GetValue(num).ToString();
						}
						break;
					}
					case CimType.Boolean:
					{
						if (val is bool[])
						{
							obj = val;
							break;
						}
						obj = new bool[length];
						for (int k = 0; k < length; k++)
						{
							((bool[])obj)[k] = Convert.ToBoolean(array.GetValue(k), (IFormatProvider)invariantCulture.GetFormat(typeof(bool)));
						}
						break;
					}
					case CimType.Object:
					{
						obj = new IWbemClassObject_DoNotMarshal[length];
						for (int i = 0; i < length; i++)
						{
							((IWbemClassObject_DoNotMarshal[])obj)[i] = (IWbemClassObject_DoNotMarshal)Marshal.GetObjectForIUnknown(((ManagementBaseObject)array.GetValue(i)).wbemObject);
						}
						break;
					}
					default:
						obj = val;
						break;
					}
				}
				else
				{
					switch (type)
					{
					case CimType.SInt8:
						obj = (short)Convert.ToSByte(val, (IFormatProvider)invariantCulture.GetFormat(typeof(short)));
						break;
					case CimType.UInt8:
						obj = Convert.ToByte(val, (IFormatProvider)invariantCulture.GetFormat(typeof(byte)));
						break;
					case CimType.SInt16:
						obj = Convert.ToInt16(val, (IFormatProvider)invariantCulture.GetFormat(typeof(short)));
						break;
					case CimType.UInt16:
						obj = (int)Convert.ToUInt16(val, (IFormatProvider)invariantCulture.GetFormat(typeof(ushort)));
						break;
					case CimType.SInt32:
						obj = Convert.ToInt32(val, (IFormatProvider)invariantCulture.GetFormat(typeof(int)));
						break;
					case CimType.UInt32:
						obj = (int)Convert.ToUInt32(val, (IFormatProvider)invariantCulture.GetFormat(typeof(uint)));
						break;
					case CimType.SInt64:
						obj = Convert.ToInt64(val, (IFormatProvider)invariantCulture.GetFormat(typeof(long))).ToString((IFormatProvider)invariantCulture.GetFormat(typeof(long)));
						break;
					case CimType.UInt64:
						obj = Convert.ToUInt64(val, (IFormatProvider)invariantCulture.GetFormat(typeof(ulong))).ToString((IFormatProvider)invariantCulture.GetFormat(typeof(ulong)));
						break;
					case CimType.Real32:
						obj = Convert.ToSingle(val, (IFormatProvider)invariantCulture.GetFormat(typeof(float)));
						break;
					case CimType.Real64:
						obj = Convert.ToDouble(val, (IFormatProvider)invariantCulture.GetFormat(typeof(double)));
						break;
					case CimType.Char16:
						obj = (short)Convert.ToChar(val, (IFormatProvider)invariantCulture.GetFormat(typeof(char)));
						break;
					case CimType.String:
					case CimType.DateTime:
					case CimType.Reference:
						obj = val.ToString();
						break;
					case CimType.Boolean:
						obj = Convert.ToBoolean(val, (IFormatProvider)invariantCulture.GetFormat(typeof(bool)));
						break;
					case CimType.Object:
						obj = ((!(val is ManagementBaseObject)) ? val : Marshal.GetObjectForIUnknown(((ManagementBaseObject)val).wbemObject));
						break;
					default:
						obj = val;
						break;
					}
				}
			}
			return obj;
		}

		internal static object MapValueToWmiValue(object val, out bool isArray, out CimType type)
		{
			object obj = DBNull.Value;
			CultureInfo invariantCulture = CultureInfo.InvariantCulture;
			isArray = false;
			type = CimType.None;
			if (val != null)
			{
				isArray = val.GetType().IsArray;
				Type type2 = val.GetType();
				if (isArray)
				{
					Type elementType = type2.GetElementType();
					if (elementType.IsPrimitive)
					{
						if (elementType == typeof(byte))
						{
							byte[] array = (byte[])val;
							int num = array.Length;
							type = CimType.UInt8;
							obj = new short[num];
							for (int i = 0; i < num; i++)
							{
								((short[])obj)[i] = ((IConvertible)array[i]).ToInt16((IFormatProvider)null);
							}
						}
						else if (elementType == typeof(sbyte))
						{
							sbyte[] array2 = (sbyte[])val;
							int num2 = array2.Length;
							type = CimType.SInt8;
							obj = new short[num2];
							for (int j = 0; j < num2; j++)
							{
								((short[])obj)[j] = ((IConvertible)array2[j]).ToInt16((IFormatProvider)null);
							}
						}
						else if (elementType == typeof(bool))
						{
							type = CimType.Boolean;
							obj = (bool[])val;
						}
						else if (elementType == typeof(ushort))
						{
							ushort[] array3 = (ushort[])val;
							int num3 = array3.Length;
							type = CimType.UInt16;
							obj = new int[num3];
							for (int k = 0; k < num3; k++)
							{
								((int[])obj)[k] = ((IConvertible)array3[k]).ToInt32((IFormatProvider)null);
							}
						}
						else if (elementType == typeof(short))
						{
							type = CimType.SInt16;
							obj = (short[])val;
						}
						else if (elementType == typeof(int))
						{
							type = CimType.SInt32;
							obj = (int[])val;
						}
						else if (elementType == typeof(uint))
						{
							uint[] array4 = (uint[])val;
							int num4 = array4.Length;
							type = CimType.UInt32;
							obj = new string[num4];
							for (int l = 0; l < num4; l++)
							{
								string[] obj2 = (string[])obj;
								int num5 = l;
								uint num6 = array4[l];
								obj2[num5] = num6.ToString((IFormatProvider)invariantCulture.GetFormat(typeof(uint)));
							}
						}
						else if (elementType == typeof(ulong))
						{
							ulong[] array5 = (ulong[])val;
							int num7 = array5.Length;
							type = CimType.UInt64;
							obj = new string[num7];
							for (int m = 0; m < num7; m++)
							{
								string[] obj3 = (string[])obj;
								int num8 = m;
								ulong num9 = array5[m];
								obj3[num8] = num9.ToString((IFormatProvider)invariantCulture.GetFormat(typeof(ulong)));
							}
						}
						else if (elementType == typeof(long))
						{
							long[] array6 = (long[])val;
							int num10 = array6.Length;
							type = CimType.SInt64;
							obj = new string[num10];
							for (int n = 0; n < num10; n++)
							{
								string[] obj4 = (string[])obj;
								int num11 = n;
								long num12 = array6[n];
								obj4[num11] = num12.ToString((IFormatProvider)invariantCulture.GetFormat(typeof(long)));
							}
						}
						else if (elementType == typeof(float))
						{
							type = CimType.Real32;
							obj = (float[])val;
						}
						else if (elementType == typeof(double))
						{
							type = CimType.Real64;
							obj = (double[])val;
						}
						else if (elementType == typeof(char))
						{
							char[] array7 = (char[])val;
							int num13 = array7.Length;
							type = CimType.Char16;
							obj = new short[num13];
							for (int num14 = 0; num14 < num13; num14++)
							{
								((short[])obj)[num14] = ((IConvertible)array7[num14]).ToInt16((IFormatProvider)null);
							}
						}
					}
					else if (elementType == typeof(string))
					{
						type = CimType.String;
						obj = (string[])val;
					}
					else if (val is ManagementBaseObject[])
					{
						Array array8 = (Array)val;
						int length = array8.Length;
						type = CimType.Object;
						obj = new IWbemClassObject_DoNotMarshal[length];
						for (int num15 = 0; num15 < length; num15++)
						{
							((IWbemClassObject_DoNotMarshal[])obj)[num15] = (IWbemClassObject_DoNotMarshal)Marshal.GetObjectForIUnknown(((ManagementBaseObject)array8.GetValue(num15)).wbemObject);
						}
					}
				}
				else if (type2 == typeof(ushort))
				{
					type = CimType.UInt16;
					obj = ((IConvertible)(ushort)val).ToInt32((IFormatProvider)null);
				}
				else if (type2 == typeof(uint))
				{
					type = CimType.UInt32;
					obj = ((((uint)val & 0x80000000u) == 0) ? ((object)Convert.ToInt32(val, (IFormatProvider)invariantCulture.GetFormat(typeof(int)))) : Convert.ToString(val, (IFormatProvider)invariantCulture.GetFormat(typeof(uint))));
				}
				else if (type2 == typeof(ulong))
				{
					type = CimType.UInt64;
					obj = ((ulong)val).ToString((IFormatProvider)invariantCulture.GetFormat(typeof(ulong)));
				}
				else if (type2 == typeof(sbyte))
				{
					type = CimType.SInt8;
					obj = ((IConvertible)(sbyte)val).ToInt16((IFormatProvider)null);
				}
				else if (type2 == typeof(byte))
				{
					type = CimType.UInt8;
					obj = val;
				}
				else if (type2 == typeof(short))
				{
					type = CimType.SInt16;
					obj = val;
				}
				else if (type2 == typeof(int))
				{
					type = CimType.SInt32;
					obj = val;
				}
				else if (type2 == typeof(long))
				{
					type = CimType.SInt64;
					obj = val.ToString();
				}
				else if (type2 == typeof(bool))
				{
					type = CimType.Boolean;
					obj = val;
				}
				else if (type2 == typeof(float))
				{
					type = CimType.Real32;
					obj = val;
				}
				else if (type2 == typeof(double))
				{
					type = CimType.Real64;
					obj = val;
				}
				else if (type2 == typeof(char))
				{
					type = CimType.Char16;
					obj = ((IConvertible)(char)val).ToInt16((IFormatProvider)null);
				}
				else if (type2 == typeof(string))
				{
					type = CimType.String;
					obj = val;
				}
				else if (val is ManagementBaseObject)
				{
					type = CimType.Object;
					obj = Marshal.GetObjectForIUnknown(((ManagementBaseObject)val).wbemObject);
				}
			}
			return obj;
		}
	}
	/// <summary>Represents the set of properties of a WMI object.</summary>
	public class PropertyDataCollection : ICollection, IEnumerable
	{
		/// <summary>Represents the enumerator for <see cref="T:System.Management.PropertyData" /> objects in the <see cref="T:System.Management.PropertyDataCollection" />.</summary>
		public class PropertyDataEnumerator : IEnumerator
		{
			private ManagementBaseObject parent;

			private string[] propertyNames;

			private int index;

			/// <summary>Gets the current object in the collection.</summary>
			/// <returns>Returns the current element in the collection.</returns>
			/// <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
			object IEnumerator.Current => Current;

			/// <summary>Gets the current <see cref="T:System.Management.PropertyData" /> in the <see cref="T:System.Management.PropertyDataCollection" /> enumeration.</summary>
			/// <returns>The current <see cref="T:System.Management.PropertyData" /> element in the collection.</returns>
			public PropertyData Current
			{
				get
				{
					if (index == -1 || index == propertyNames.Length)
					{
						throw new InvalidOperationException();
					}
					return new PropertyData(parent, propertyNames[index]);
				}
			}

			internal PropertyDataEnumerator(ManagementBaseObject parent, bool isSystem)
			{
				this.parent = parent;
				propertyNames = null;
				index = -1;
				object pQualifierVal = null;
				int lFlags = ((!isSystem) ? 64 : 48) | 0;
				int names_ = parent.wbemObject.GetNames_(null, lFlags, ref pQualifierVal, out propertyNames);
				if (names_ < 0)
				{
					if ((names_ & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)names_);
					}
					else
					{
						Marshal.ThrowExceptionForHR(names_, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}

			/// <summary>Moves to the next element in the <see cref="T:System.Management.PropertyDataCollection" /> enumeration.</summary>
			/// <returns>
			///   <see langword="true" /> if the enumerator was successfully advanced to the next element; <see langword="false" /> if the enumerator has passed the end of the collection.</returns>
			public bool MoveNext()
			{
				if (index == propertyNames.Length)
				{
					return false;
				}
				index++;
				if (index != propertyNames.Length)
				{
					return true;
				}
				return false;
			}

			/// <summary>Resets the enumerator to the beginning of the <see cref="T:System.Management.PropertyDataCollection" /> enumeration.</summary>
			public void Reset()
			{
				index = -1;
			}
		}

		private ManagementBaseObject parent;

		private bool isSystem;

		/// <summary>Gets the number of objects in the <see cref="T:System.Management.PropertyDataCollection" />.</summary>
		/// <returns>Returns an <see cref="T:System.Int32" /> value representing the number of objects in the collection.</returns>
		public int Count
		{
			get
			{
				string[] pNames = null;
				object pQualifierVal = null;
				int num = ((!isSystem) ? 64 : 48);
				num |= 0;
				int names_ = parent.wbemObject.GetNames_(null, num, ref pQualifierVal, out pNames);
				if (names_ < 0)
				{
					if ((names_ & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)names_);
					}
					else
					{
						Marshal.ThrowExceptionForHR(names_, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				return pNames.Length;
			}
		}

		/// <summary>Gets a value indicating whether the object is synchronized.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the object is synchronized.</returns>
		public bool IsSynchronized => false;

		/// <summary>Gets the object to be used for synchronization.</summary>
		/// <returns>Returns an <see cref="T:System.Object" /> value containing the object to be used for synchronization.</returns>
		public object SyncRoot => this;

		/// <summary>Gets the specified property from the <see cref="T:System.Management.PropertyDataCollection" />, using [] syntax. This property is the indexer for the <see cref="T:System.Management.PropertyDataCollection" /> class.</summary>
		/// <param name="propertyName">The name of the property to retrieve.</param>
		/// <returns>Returns a <see cref="T:System.Management.PropertyData" /> containing the data for a specified property in the collection.</returns>
		public virtual PropertyData this[string propertyName]
		{
			get
			{
				if (propertyName == null)
				{
					throw new ArgumentNullException("propertyName");
				}
				return new PropertyData(parent, propertyName);
			}
		}

		internal PropertyDataCollection(ManagementBaseObject parent, bool isSystem)
		{
			this.parent = parent;
			this.isSystem = isSystem;
		}

		/// <summary>Copies the <see cref="T:System.Management.PropertyDataCollection" /> into an array.</summary>
		/// <param name="array">The array to which to copy the <see cref="T:System.Management.PropertyDataCollection" />.</param>
		/// <param name="index">The index from which to start copying.</param>
		public void CopyTo(Array array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (index < array.GetLowerBound(0) || index > array.GetUpperBound(0))
			{
				throw new ArgumentOutOfRangeException("index");
			}
			string[] pNames = null;
			object pQualifierVal = null;
			int num = 0;
			num = ((!isSystem) ? (num | 0x40) : (num | 0x30));
			num |= 0;
			int names_ = parent.wbemObject.GetNames_(null, num, ref pQualifierVal, out pNames);
			if (names_ >= 0)
			{
				if (index + pNames.Length > array.Length)
				{
					throw new ArgumentException(null, "index");
				}
				string[] array2 = pNames;
				foreach (string propName in array2)
				{
					array.SetValue(new PropertyData(parent, propName), index++);
				}
			}
			if (names_ < 0)
			{
				if ((names_ & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)names_);
				}
				else
				{
					Marshal.ThrowExceptionForHR(names_, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Copies the <see cref="T:System.Management.PropertyDataCollection" /> to a specialized <see cref="T:System.Management.PropertyData" /> object array.</summary>
		/// <param name="propertyArray">The destination array to contain the copied <see cref="T:System.Management.PropertyDataCollection" />.</param>
		/// <param name="index">The index in the destination array from which to start copying.</param>
		public void CopyTo(PropertyData[] propertyArray, int index)
		{
			CopyTo((Array)propertyArray, index);
		}

		/// <summary>Returns an <see cref="T:System.Collections.IEnumerator" /> that iterates through the <see cref="T:System.Management.PropertyDataCollection" />.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Management.PropertyDataCollection" />.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return new PropertyDataEnumerator(parent, isSystem);
		}

		/// <summary>Returns the enumerator for this <see cref="T:System.Management.PropertyDataCollection" />.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> that can be used to iterate through the collection.</returns>
		public PropertyDataEnumerator GetEnumerator()
		{
			return new PropertyDataEnumerator(parent, isSystem);
		}

		/// <summary>Removes a <see cref="T:System.Management.PropertyData" /> from the <see cref="T:System.Management.PropertyDataCollection" />.</summary>
		/// <param name="propertyName">The name of the property to be removed.</param>
		public virtual void Remove(string propertyName)
		{
			if (parent.GetType() == typeof(ManagementObject))
			{
				ManagementClass managementClass = new ManagementClass(parent.ClassPath);
				parent.SetPropertyValue(propertyName, managementClass.GetPropertyValue(propertyName));
				return;
			}
			int num = parent.wbemObject.Delete_(propertyName);
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Adds a new <see cref="T:System.Management.PropertyData" /> with the specified value. The value cannot be null and must be convertible to a Common Information Model (CIM) type.</summary>
		/// <param name="propertyName">The name of the new property.</param>
		/// <param name="propertyValue">The value of the property (cannot be null).</param>
		public virtual void Add(string propertyName, object propertyValue)
		{
			if (propertyValue == null)
			{
				throw new ArgumentNullException("propertyValue");
			}
			if (parent.GetType() == typeof(ManagementObject))
			{
				throw new InvalidOperationException();
			}
			CimType type = CimType.None;
			bool isArray = false;
			object pVal = PropertyData.MapValueToWmiValue(propertyValue, out isArray, out type);
			int num = (int)type;
			if (isArray)
			{
				num |= 0x2000;
			}
			int num2 = parent.wbemObject.Put_(propertyName, 0, ref pVal, num);
			if (num2 < 0)
			{
				if ((num2 & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num2);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num2, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Adds a new <see cref="T:System.Management.PropertyData" /> with the specified value and Common Information Model (CIM) type.</summary>
		/// <param name="propertyName">The name of the property.</param>
		/// <param name="propertyValue">The value of the property (which can be null).</param>
		/// <param name="propertyType">The CIM type of the property.</param>
		public void Add(string propertyName, object propertyValue, CimType propertyType)
		{
			if (propertyName == null)
			{
				throw new ArgumentNullException("propertyName");
			}
			if (parent.GetType() == typeof(ManagementObject))
			{
				throw new InvalidOperationException();
			}
			int num = (int)propertyType;
			bool isArray = false;
			if (propertyValue != null && propertyValue.GetType().IsArray)
			{
				isArray = true;
				num |= 0x2000;
			}
			object pVal = PropertyData.MapValueToWmiValue(propertyValue, propertyType, isArray);
			int num2 = parent.wbemObject.Put_(propertyName, 0, ref pVal, num);
			if (num2 < 0)
			{
				if ((num2 & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num2);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num2, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Adds a new <see cref="T:System.Management.PropertyData" /> with no assigned value.</summary>
		/// <param name="propertyName">The name of the property.</param>
		/// <param name="propertyType">The Common Information Model (CIM) type of the property.</param>
		/// <param name="isArray">
		///   <see langword="true" /> to specify that the property is an array type; otherwise, <see langword="false" />.</param>
		public void Add(string propertyName, CimType propertyType, bool isArray)
		{
			if (propertyName == null)
			{
				throw new ArgumentNullException(propertyName);
			}
			if (parent.GetType() == typeof(ManagementObject))
			{
				throw new InvalidOperationException();
			}
			int num = (int)propertyType;
			if (isArray)
			{
				num |= 0x2000;
			}
			object pVal = DBNull.Value;
			int num2 = parent.wbemObject.Put_(propertyName, 0, ref pVal, num);
			if (num2 < 0)
			{
				if ((num2 & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num2);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num2, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}
	}
	/// <summary>Contains information about a WMI qualifier.</summary>
	public class QualifierData
	{
		private ManagementBaseObject parent;

		private string propertyOrMethodName;

		private string qualifierName;

		private QualifierType qualifierType;

		private object qualifierValue;

		private int qualifierFlavor;

		private IWbemQualifierSetFreeThreaded qualifierSet;

		/// <summary>Represents the name of the qualifier.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the name of the qualifier.</returns>
		public string Name
		{
			get
			{
				if (qualifierName == null)
				{
					return "";
				}
				return qualifierName;
			}
		}

		/// <summary>Gets or sets the value of the qualifier.</summary>
		/// <returns>Returns an <see cref="T:System.Object" /> value containing the value of the qualifier.</returns>
		public object Value
		{
			get
			{
				RefreshQualifierInfo();
				return ValueTypeSafety.GetSafeObject(qualifierValue);
			}
			set
			{
				int num = 0;
				RefreshQualifierInfo();
				object pVal = MapQualValueToWmiValue(value);
				num = qualifierSet.Put_(qualifierName, ref pVal, qualifierFlavor & -97);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else if ((num & 0x80000000u) != 0L)
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Gets or sets a value indicating whether the qualifier is amended.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the qualifier is amended.</returns>
		public bool IsAmended
		{
			get
			{
				RefreshQualifierInfo();
				return 128 == (qualifierFlavor & 0x80);
			}
			set
			{
				int num = 0;
				RefreshQualifierInfo();
				int num2 = qualifierFlavor & -97;
				num2 = ((!value) ? (num2 & -129) : (num2 | 0x80));
				num = qualifierSet.Put_(qualifierName, ref qualifierValue, num2);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else if ((num & 0x80000000u) != 0L)
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Gets a value indicating whether the qualifier has been defined locally on this class or has been propagated from a base class.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the qualifier has been defined locally on this class or has been propagated from a base class.</returns>
		public bool IsLocal
		{
			get
			{
				RefreshQualifierInfo();
				return (qualifierFlavor & 0x60) == 0;
			}
		}

		/// <summary>Gets or sets a value indicating whether the qualifier should be propagated to instances of the class.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the qualifier should be propagated to instances of the class.</returns>
		public bool PropagatesToInstance
		{
			get
			{
				RefreshQualifierInfo();
				return 1 == (qualifierFlavor & 1);
			}
			set
			{
				int num = 0;
				RefreshQualifierInfo();
				int num2 = qualifierFlavor & -97;
				num2 = ((!value) ? (num2 & -2) : (num2 | 1));
				num = qualifierSet.Put_(qualifierName, ref qualifierValue, num2);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else if ((num & 0x80000000u) != 0L)
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Gets or sets a value indicating whether the qualifier should be propagated to subclasses of the class.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the qualifier should be propagated to subclasses of the class.</returns>
		public bool PropagatesToSubclass
		{
			get
			{
				RefreshQualifierInfo();
				return 2 == (qualifierFlavor & 2);
			}
			set
			{
				int num = 0;
				RefreshQualifierInfo();
				int num2 = qualifierFlavor & -97;
				num2 = ((!value) ? (num2 & -3) : (num2 | 2));
				num = qualifierSet.Put_(qualifierName, ref qualifierValue, num2);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else if ((num & 0x80000000u) != 0L)
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Gets or sets a value indicating whether the value of the qualifier can be overridden when propagated.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the value of the qualifier can be overridden when propagated.</returns>
		public bool IsOverridable
		{
			get
			{
				RefreshQualifierInfo();
				return (qualifierFlavor & 0x10) == 0;
			}
			set
			{
				int num = 0;
				RefreshQualifierInfo();
				int num2 = qualifierFlavor & -97;
				num2 = ((!value) ? (num2 | 0x10) : (num2 & -17));
				num = qualifierSet.Put_(qualifierName, ref qualifierValue, num2);
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else if ((num & 0x80000000u) != 0L)
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		internal QualifierData(ManagementBaseObject parent, string propName, string qualName, QualifierType type)
		{
			this.parent = parent;
			propertyOrMethodName = propName;
			qualifierName = qualName;
			qualifierType = type;
			RefreshQualifierInfo();
		}

		private void RefreshQualifierInfo()
		{
			int num = -2147217407;
			qualifierSet = null;
			num = qualifierType switch
			{
				QualifierType.ObjectQualifier => parent.wbemObject.GetQualifierSet_(out qualifierSet), 
				QualifierType.PropertyQualifier => parent.wbemObject.GetPropertyQualifierSet_(propertyOrMethodName, out qualifierSet), 
				QualifierType.MethodQualifier => parent.wbemObject.GetMethodQualifierSet_(propertyOrMethodName, out qualifierSet), 
				_ => throw new ManagementException(ManagementStatus.Unexpected, null, null), 
			};
			if ((num & 0x80000000u) == 0L)
			{
				qualifierValue = null;
				if (qualifierSet != null)
				{
					num = qualifierSet.Get_(qualifierName, 0, ref qualifierValue, ref qualifierFlavor);
				}
			}
			if ((num & 0xFFFFF000u) == 2147749888u)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
			}
			else if ((num & 0x80000000u) != 0L)
			{
				Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
			}
		}

		private static object MapQualValueToWmiValue(object qualVal)
		{
			object obj = DBNull.Value;
			if (qualVal != null)
			{
				if (qualVal is Array)
				{
					if (qualVal is int[] || qualVal is double[] || qualVal is string[] || qualVal is bool[])
					{
						obj = qualVal;
					}
					else
					{
						Array array = (Array)qualVal;
						int length = array.Length;
						Type type = ((length > 0) ? array.GetValue(0).GetType() : null);
						if (type == typeof(int))
						{
							obj = new int[length];
							for (int i = 0; i < length; i++)
							{
								((int[])obj)[i] = Convert.ToInt32(array.GetValue(i), (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int)));
							}
						}
						else if (type == typeof(double))
						{
							obj = new double[length];
							for (int j = 0; j < length; j++)
							{
								((double[])obj)[j] = Convert.ToDouble(array.GetValue(j), (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(double)));
							}
						}
						else if (type == typeof(string))
						{
							obj = new string[length];
							for (int k = 0; k < length; k++)
							{
								((string[])obj)[k] = array.GetValue(k).ToString();
							}
						}
						else if (type == typeof(bool))
						{
							obj = new bool[length];
							for (int l = 0; l < length; l++)
							{
								((bool[])obj)[l] = Convert.ToBoolean(array.GetValue(l), (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(bool)));
							}
						}
						else
						{
							obj = array;
						}
					}
				}
				else
				{
					obj = qualVal;
				}
			}
			return obj;
		}
	}
	/// <summary>Represents a collection of <see cref="T:System.Management.QualifierData" /> objects.</summary>
	public class QualifierDataCollection : ICollection, IEnumerable
	{
		/// <summary>Represents the enumerator for <see cref="T:System.Management.QualifierData" /> objects in the <see cref="T:System.Management.QualifierDataCollection" />.</summary>
		public class QualifierDataEnumerator : IEnumerator
		{
			private ManagementBaseObject parent;

			private string propertyOrMethodName;

			private QualifierType qualifierType;

			private string[] qualifierNames;

			private int index = -1;

			/// <summary>Gets the current object in the collection.</summary>
			/// <returns>The current element in the collection.</returns>
			/// <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
			object IEnumerator.Current => Current;

			/// <summary>Gets or sets the current <see cref="T:System.Management.QualifierData" /> in the <see cref="T:System.Management.QualifierDataCollection" /> enumeration.</summary>
			/// <returns>The current <see cref="T:System.Management.QualifierData" /> element in the collection.</returns>
			public QualifierData Current
			{
				get
				{
					if (index == -1 || index == qualifierNames.Length)
					{
						throw new InvalidOperationException();
					}
					return new QualifierData(parent, propertyOrMethodName, qualifierNames[index], qualifierType);
				}
			}

			internal QualifierDataEnumerator(ManagementBaseObject parent, string propertyOrMethodName, QualifierType qualifierType)
			{
				this.parent = parent;
				this.propertyOrMethodName = propertyOrMethodName;
				this.qualifierType = qualifierType;
				qualifierNames = null;
				IWbemQualifierSetFreeThreaded ppQualSet = null;
				int num = 0;
				if (qualifierType switch
				{
					QualifierType.ObjectQualifier => parent.wbemObject.GetQualifierSet_(out ppQualSet), 
					QualifierType.PropertyQualifier => parent.wbemObject.GetPropertyQualifierSet_(propertyOrMethodName, out ppQualSet), 
					QualifierType.MethodQualifier => parent.wbemObject.GetMethodQualifierSet_(propertyOrMethodName, out ppQualSet), 
					_ => throw new ManagementException(ManagementStatus.Unexpected, null, null), 
				} < 0)
				{
					qualifierNames = new string[0];
					return;
				}
				num = ppQualSet.GetNames_(0, out qualifierNames);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}

			/// <summary>Moves to the next element in the <see cref="T:System.Management.QualifierDataCollection" /> enumeration.</summary>
			/// <returns>
			///   <see langword="true" /> if the enumerator was successfully advanced to the next element; <see langword="false" /> if the enumerator has passed the end of the collection.</returns>
			public bool MoveNext()
			{
				if (index == qualifierNames.Length)
				{
					return false;
				}
				index++;
				if (index != qualifierNames.Length)
				{
					return true;
				}
				return false;
			}

			/// <summary>Resets the enumerator to the beginning of the <see cref="T:System.Management.QualifierDataCollection" /> enumeration.</summary>
			public void Reset()
			{
				index = -1;
			}
		}

		private ManagementBaseObject parent;

		private string propertyOrMethodName;

		private QualifierType qualifierSetType;

		/// <summary>Gets the number of <see cref="T:System.Management.QualifierData" /> objects in the <see cref="T:System.Management.QualifierDataCollection" />.</summary>
		/// <returns>The number of objects in the collection.</returns>
		public int Count
		{
			get
			{
				string[] pNames = null;
				IWbemQualifierSetFreeThreaded typeQualifierSet;
				try
				{
					typeQualifierSet = GetTypeQualifierSet();
				}
				catch (ManagementException ex)
				{
					if (qualifierSetType == QualifierType.PropertyQualifier && ex.ErrorCode == ManagementStatus.SystemProperty)
					{
						return 0;
					}
					throw;
				}
				int names_ = typeQualifierSet.GetNames_(0, out pNames);
				if (names_ < 0)
				{
					if ((names_ & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)names_);
					}
					else
					{
						Marshal.ThrowExceptionForHR(names_, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				return pNames.Length;
			}
		}

		/// <summary>Gets a value indicating whether the object is synchronized (thread-safe).</summary>
		/// <returns>
		///   <see langword="true" /> if the object is synchronized; otherwise, <see langword="false" />.</returns>
		public bool IsSynchronized => false;

		/// <summary>Gets the object to be used for synchronization.</summary>
		/// <returns>The object to be used for synchronization.</returns>
		public object SyncRoot => this;

		/// <summary>Gets the specified <see cref="T:System.Management.QualifierData" /> from the <see cref="T:System.Management.QualifierDataCollection" />.</summary>
		/// <param name="qualifierName">The name of the <see cref="T:System.Management.QualifierData" /> to access in the <see cref="T:System.Management.QualifierDataCollection" />.</param>
		/// <returns>The data for a specified qualifier in the collection.</returns>
		public virtual QualifierData this[string qualifierName]
		{
			get
			{
				if (qualifierName == null)
				{
					throw new ArgumentNullException("qualifierName");
				}
				return new QualifierData(parent, propertyOrMethodName, qualifierName, qualifierSetType);
			}
		}

		internal QualifierDataCollection(ManagementBaseObject parent)
		{
			this.parent = parent;
			qualifierSetType = QualifierType.ObjectQualifier;
			propertyOrMethodName = null;
		}

		internal QualifierDataCollection(ManagementBaseObject parent, string propertyOrMethodName, QualifierType type)
		{
			this.parent = parent;
			this.propertyOrMethodName = propertyOrMethodName;
			qualifierSetType = type;
		}

		private IWbemQualifierSetFreeThreaded GetTypeQualifierSet()
		{
			return GetTypeQualifierSet(qualifierSetType);
		}

		private IWbemQualifierSetFreeThreaded GetTypeQualifierSet(QualifierType qualifierSetType)
		{
			IWbemQualifierSetFreeThreaded ppQualSet = null;
			int num = 0;
			num = qualifierSetType switch
			{
				QualifierType.ObjectQualifier => parent.wbemObject.GetQualifierSet_(out ppQualSet), 
				QualifierType.PropertyQualifier => parent.wbemObject.GetPropertyQualifierSet_(propertyOrMethodName, out ppQualSet), 
				QualifierType.MethodQualifier => parent.wbemObject.GetMethodQualifierSet_(propertyOrMethodName, out ppQualSet), 
				_ => throw new ManagementException(ManagementStatus.Unexpected, null, null), 
			};
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			return ppQualSet;
		}

		/// <summary>Copies the <see cref="T:System.Management.QualifierDataCollection" /> into an array.</summary>
		/// <param name="array">The array to which to copy the <see cref="T:System.Management.QualifierDataCollection" />.</param>
		/// <param name="index">The index from which to start copying.</param>
		public void CopyTo(Array array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (index < array.GetLowerBound(0) || index > array.GetUpperBound(0))
			{
				throw new ArgumentOutOfRangeException("index");
			}
			string[] pNames = null;
			IWbemQualifierSetFreeThreaded typeQualifierSet;
			try
			{
				typeQualifierSet = GetTypeQualifierSet();
			}
			catch (ManagementException ex)
			{
				if (qualifierSetType == QualifierType.PropertyQualifier && ex.ErrorCode == ManagementStatus.SystemProperty)
				{
					return;
				}
				throw;
			}
			int names_ = typeQualifierSet.GetNames_(0, out pNames);
			if (names_ < 0)
			{
				if ((names_ & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)names_);
				}
				else
				{
					Marshal.ThrowExceptionForHR(names_, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
			if (index + pNames.Length > array.Length)
			{
				throw new ArgumentException(null, "index");
			}
			string[] array2 = pNames;
			foreach (string qualName in array2)
			{
				array.SetValue(new QualifierData(parent, propertyOrMethodName, qualName, qualifierSetType), index++);
			}
		}

		/// <summary>Copies the <see cref="T:System.Management.QualifierDataCollection" /> into a specialized              <see cref="T:System.Management.QualifierData" /> array.</summary>
		/// <param name="qualifierArray">The specialized array of <see cref="T:System.Management.QualifierData" /> objects to which to copy the <see cref="T:System.Management.QualifierDataCollection" />.</param>
		/// <param name="index">The index from which to start copying.</param>
		public void CopyTo(QualifierData[] qualifierArray, int index)
		{
			CopyTo((Array)qualifierArray, index);
		}

		/// <summary>Returns an <see cref="T:System.Collections.IEnumerator" /> that iterates through the <see cref="T:System.Management.QualifierDataCollection" />.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Management.QualifierDataCollection" />.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return new QualifierDataEnumerator(parent, propertyOrMethodName, qualifierSetType);
		}

		/// <summary>Returns an enumerator for the <see cref="T:System.Management.QualifierDataCollection" />. This method is strongly typed.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> that can be used to iterate through the collection.</returns>
		public QualifierDataEnumerator GetEnumerator()
		{
			return new QualifierDataEnumerator(parent, propertyOrMethodName, qualifierSetType);
		}

		/// <summary>Removes a <see cref="T:System.Management.QualifierData" /> from the <see cref="T:System.Management.QualifierDataCollection" /> by name.</summary>
		/// <param name="qualifierName">The name of the <see cref="T:System.Management.QualifierData" /> to remove.</param>
		public virtual void Remove(string qualifierName)
		{
			int num = GetTypeQualifierSet().Delete_(qualifierName);
			if (num < 0)
			{
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}

		/// <summary>Adds a <see cref="T:System.Management.QualifierData" /> to the <see cref="T:System.Management.QualifierDataCollection" />. This overload specifies the qualifier name and value.</summary>
		/// <param name="qualifierName">The name of the <see cref="T:System.Management.QualifierData" /> to be added to the <see cref="T:System.Management.QualifierDataCollection" />.</param>
		/// <param name="qualifierValue">The value for the new qualifier.</param>
		public virtual void Add(string qualifierName, object qualifierValue)
		{
			Add(qualifierName, qualifierValue, isAmended: false, propagatesToInstance: false, propagatesToSubclass: false, isOverridable: true);
		}

		/// <summary>Adds a <see cref="T:System.Management.QualifierData" /> to the <see cref="T:System.Management.QualifierDataCollection" />. This overload specifies all property values for a <see cref="T:System.Management.QualifierData" />.</summary>
		/// <param name="qualifierName">The qualifier name.</param>
		/// <param name="qualifierValue">The qualifier value.</param>
		/// <param name="isAmended">
		///   <see langword="true" /> to specify that this qualifier is amended (flavor); otherwise, <see langword="false" />.</param>
		/// <param name="propagatesToInstance">
		///   <see langword="true" /> to propagate this qualifier to instances; otherwise, <see langword="false" />.</param>
		/// <param name="propagatesToSubclass">
		///   <see langword="true" /> to propagate this qualifier to subclasses; otherwise, <see langword="false" />.</param>
		/// <param name="isOverridable">
		///   <see langword="true" /> to specify that this qualifier's value is overridable in instances of subclasses; otherwise, <see langword="false" />.</param>
		public virtual void Add(string qualifierName, object qualifierValue, bool isAmended, bool propagatesToInstance, bool propagatesToSubclass, bool isOverridable)
		{
			int num = 0;
			if (isAmended)
			{
				num |= 0x80;
			}
			if (propagatesToInstance)
			{
				num |= 1;
			}
			if (propagatesToSubclass)
			{
				num |= 2;
			}
			if (!isOverridable)
			{
				num |= 0x10;
			}
			int num2 = GetTypeQualifierSet().Put_(qualifierName, ref qualifierValue, num);
			if (num2 < 0)
			{
				if ((num2 & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num2);
				}
				else
				{
					Marshal.ThrowExceptionForHR(num2, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}
		}
	}
	/// <summary>Contains information about a WMI method.</summary>
	public class MethodData
	{
		private ManagementObject parent;

		private string methodName;

		private IWbemClassObjectFreeThreaded wmiInParams;

		private IWbemClassObjectFreeThreaded wmiOutParams;

		private QualifierDataCollection qualifiers;

		/// <summary>Gets the name of the method.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the name of the method.</returns>
		public string Name
		{
			get
			{
				if (methodName == null)
				{
					return "";
				}
				return methodName;
			}
		}

		/// <summary>Gets the input parameters to the method. Each parameter is described as a property in the object. If a parameter is both in and out, it appears in both the <see cref="P:System.Management.MethodData.InParameters" /> and <see cref="P:System.Management.MethodData.OutParameters" /> properties.</summary>
		/// <returns>Returns a <see cref="T:System.Management.ManagementBaseObject" /> containing the input parameters to the method.</returns>
		public ManagementBaseObject InParameters
		{
			get
			{
				RefreshMethodInfo();
				if (wmiInParams != null)
				{
					return new ManagementBaseObject(wmiInParams);
				}
				return null;
			}
		}

		/// <summary>Gets the output parameters to the method. Each parameter is described as a property in the object. If a parameter is both in and out, it will appear in both the <see cref="P:System.Management.MethodData.InParameters" /> and <see cref="P:System.Management.MethodData.OutParameters" /> properties.</summary>
		/// <returns>Returns a <see cref="T:System.Management.ManagementBaseObject" /> containing the output parameters for the method.</returns>
		public ManagementBaseObject OutParameters
		{
			get
			{
				RefreshMethodInfo();
				if (wmiOutParams != null)
				{
					return new ManagementBaseObject(wmiOutParams);
				}
				return null;
			}
		}

		/// <summary>Gets the name of the management class in which the method was first introduced in the class inheritance hierarchy.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the name of the class in which the method was first introduced in the class inheritance hierarchy.</returns>
		public string Origin
		{
			get
			{
				string pstrClassName = null;
				int methodOrigin_ = parent.wbemObject.GetMethodOrigin_(methodName, out pstrClassName);
				if (methodOrigin_ < 0)
				{
					if (methodOrigin_ == -2147217393)
					{
						pstrClassName = string.Empty;
					}
					else if ((methodOrigin_ & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)methodOrigin_);
					}
					else
					{
						Marshal.ThrowExceptionForHR(methodOrigin_, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
				return pstrClassName;
			}
		}

		/// <summary>Gets a collection of qualifiers defined in the method. Each element is of type <see cref="T:System.Management.QualifierData" /> and contains information such as the qualifier name, value, and flavor.</summary>
		/// <returns>Returns a <see cref="T:System.Management.QualifierDataCollection" /> containing the qualifiers for the method.</returns>
		public QualifierDataCollection Qualifiers
		{
			get
			{
				if (qualifiers == null)
				{
					qualifiers = new QualifierDataCollection(parent, methodName, QualifierType.MethodQualifier);
				}
				return qualifiers;
			}
		}

		internal MethodData(ManagementObject parent, string methodName)
		{
			this.parent = parent;
			this.methodName = methodName;
			RefreshMethodInfo();
			qualifiers = null;
		}

		private void RefreshMethodInfo()
		{
			int num = -2147217407;
			try
			{
				num = parent.wbemObject.GetMethod_(methodName, 0, out wmiInParams, out wmiOutParams);
			}
			catch (COMException e)
			{
				ManagementException.ThrowWithExtendedInfo(e);
			}
			if ((num & 0xFFFFF000u) == 2147749888u)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
			}
			else if ((num & 0x80000000u) != 0L)
			{
				Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
			}
		}
	}
	/// <summary>Represents the set of methods available in the collection.</summary>
	public class MethodDataCollection : ICollection, IEnumerable
	{
		private class enumLock
		{
		}

		/// <summary>Represents the enumerator for <see cref="T:System.Management.MethodData" /> objects in the <see cref="T:System.Management.MethodDataCollection" />.</summary>
		public class MethodDataEnumerator : IEnumerator
		{
			private ManagementObject parent;

			private ArrayList methodNames;

			private IEnumerator en;

			/// <summary>Gets the current object in the collection.</summary>
			/// <returns>Returns the current element in the collection.</returns>
			/// <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
			object IEnumerator.Current => Current;

			/// <summary>Returns the current <see cref="T:System.Management.MethodData" /> in the <see cref="T:System.Management.MethodDataCollection" /> enumeration.</summary>
			/// <returns>The current <see cref="T:System.Management.MethodData" /> item in the collection.</returns>
			public MethodData Current => new MethodData(parent, (string)en.Current);

			internal MethodDataEnumerator(ManagementObject parent)
			{
				this.parent = parent;
				methodNames = new ArrayList();
				IWbemClassObjectFreeThreaded ppInSignature = null;
				IWbemClassObjectFreeThreaded ppOutSignature = null;
				int num = -2147217407;
				lock (typeof(enumLock))
				{
					try
					{
						num = parent.wbemObject.BeginMethodEnumeration_(0);
						if (num >= 0)
						{
							string pstrName = "";
							while (pstrName != null && num >= 0 && num != 262149)
							{
								pstrName = null;
								num = parent.wbemObject.NextMethod_(0, out pstrName, out ppInSignature, out ppOutSignature);
								if (num >= 0 && num != 262149)
								{
									methodNames.Add(pstrName);
								}
							}
							parent.wbemObject.EndMethodEnumeration_();
						}
					}
					catch (COMException e)
					{
						ManagementException.ThrowWithExtendedInfo(e);
					}
					en = methodNames.GetEnumerator();
				}
				if ((num & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
				}
				else if ((num & 0x80000000u) != 0L)
				{
					Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
				}
			}

			/// <summary>Moves to the next element in the <see cref="T:System.Management.MethodDataCollection" /> enumeration.</summary>
			/// <returns>
			///   <see langword="true" /> if the enumerator was successfully advanced to the next method; <see langword="false" /> if the enumerator has passed the end of the collection.</returns>
			public bool MoveNext()
			{
				return en.MoveNext();
			}

			/// <summary>Resets the enumerator to the beginning of the <see cref="T:System.Management.MethodDataCollection" /> enumeration.</summary>
			public void Reset()
			{
				en.Reset();
			}
		}

		private ManagementObject parent;

		/// <summary>Gets the number of objects in the <see cref="T:System.Management.MethodDataCollection" /> collection.</summary>
		/// <returns>Returns an <see cref="T:System.Int32" /> value representing the number of objects in the collection.</returns>
		public int Count
		{
			get
			{
				int num = 0;
				IWbemClassObjectFreeThreaded wbemClassObjectFreeThreaded = null;
				IWbemClassObjectFreeThreaded wbemClassObjectFreeThreaded2 = null;
				int num2 = -2147217407;
				lock (typeof(enumLock))
				{
					try
					{
						num2 = parent.wbemObject.BeginMethodEnumeration_(0);
						if (num2 >= 0)
						{
							string pstrName = "";
							while (pstrName != null && num2 >= 0 && num2 != 262149)
							{
								pstrName = null;
								wbemClassObjectFreeThreaded = null;
								wbemClassObjectFreeThreaded2 = null;
								num2 = parent.wbemObject.NextMethod_(0, out pstrName, out wbemClassObjectFreeThreaded, out wbemClassObjectFreeThreaded2);
								if (num2 >= 0 && num2 != 262149)
								{
									num++;
								}
							}
							parent.wbemObject.EndMethodEnumeration_();
						}
					}
					catch (COMException e)
					{
						ManagementException.ThrowWithExtendedInfo(e);
					}
				}
				if ((num2 & 0xFFFFF000u) == 2147749888u)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)num2);
				}
				else if ((num2 & 0x80000000u) != 0L)
				{
					Marshal.ThrowExceptionForHR(num2, WmiNetUtilsHelper.GetErrorInfo_f());
				}
				return num;
			}
		}

		/// <summary>Gets a value that indicates whether the object is synchronized.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether the object is synchronized.</returns>
		public bool IsSynchronized => false;

		/// <summary>Gets the object to be used for synchronization.</summary>
		/// <returns>Returns an <see cref="T:System.Object" /> value representing the object to be used for synchronization.</returns>
		public object SyncRoot => this;

		/// <summary>Gets the specified <see cref="T:System.Management.MethodData" /> from the <see cref="T:System.Management.MethodDataCollection" />.</summary>
		/// <param name="methodName">The name of the method requested.</param>
		/// <returns>Returns a <see cref="T:System.Management.MethodData" /> containing the method data for a specified method from the collection.</returns>
		public virtual MethodData this[string methodName]
		{
			get
			{
				if (methodName == null)
				{
					throw new ArgumentNullException("methodName");
				}
				return new MethodData(parent, methodName);
			}
		}

		internal MethodDataCollection(ManagementObject parent)
		{
			this.parent = parent;
		}

		/// <summary>Copies the <see cref="T:System.Management.MethodDataCollection" /> into an array.</summary>
		/// <param name="array">The array to which to copy the collection.</param>
		/// <param name="index">The index from which to start.</param>
		public void CopyTo(Array array, int index)
		{
			MethodDataEnumerator methodDataEnumerator = GetEnumerator();
			try
			{
				while (methodDataEnumerator.MoveNext())
				{
					MethodData current = methodDataEnumerator.Current;
					array.SetValue(current, index++);
				}
			}
			finally
			{
				IDisposable disposable = methodDataEnumerator as IDisposable;
				if (disposable != null)
				{
					disposable.Dispose();
				}
			}
		}

		/// <summary>Copies the <see cref="T:System.Management.MethodDataCollection" /> to a specialized <see cref="T:System.Management.MethodData" /> array.</summary>
		/// <param name="methodArray">The destination array to which to copy the <see cref="T:System.Management.MethodData" /> objects.</param>
		/// <param name="index">The index in the destination array from which to start the copy.</param>
		public void CopyTo(MethodData[] methodArray, int index)
		{
			CopyTo((Array)methodArray, index);
		}

		/// <summary>Returns an <see cref="T:System.Collections.IEnumerator" /> that iterates through the <see cref="T:System.Management.MethodDataCollection" />.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Management.MethodDataCollection" />.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return new MethodDataEnumerator(parent);
		}

		/// <summary>Returns an enumerator for the <see cref="T:System.Management.MethodDataCollection" />.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> to enumerate through the collection.</returns>
		public MethodDataEnumerator GetEnumerator()
		{
			return new MethodDataEnumerator(parent);
		}

		/// <summary>Removes a <see cref="T:System.Management.MethodData" /> from the <see cref="T:System.Management.MethodDataCollection" />.</summary>
		/// <param name="methodName">The name of the method to remove from the collection.</param>
		public virtual void Remove(string methodName)
		{
			if (parent.GetType() == typeof(ManagementObject))
			{
				throw new InvalidOperationException();
			}
			int num = -2147217407;
			try
			{
				num = parent.wbemObject.DeleteMethod_(methodName);
			}
			catch (COMException e)
			{
				ManagementException.ThrowWithExtendedInfo(e);
			}
			if ((num & 0xFFFFF000u) == 2147749888u)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
			}
			else if ((num & 0x80000000u) != 0L)
			{
				Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
			}
		}

		/// <summary>Adds a <see cref="T:System.Management.MethodData" /> to the <see cref="T:System.Management.MethodDataCollection" />. This overload will add a new method with no parameters to the collection.</summary>
		/// <param name="methodName">The name of the method to add.</param>
		public virtual void Add(string methodName)
		{
			Add(methodName, null, null);
		}

		/// <summary>Adds a <see cref="T:System.Management.MethodData" /> to the <see cref="T:System.Management.MethodDataCollection" />. This overload will add a new method with the specified parameter objects to the collection.</summary>
		/// <param name="methodName">The name of the method to add.</param>
		/// <param name="inParameters">The <see cref="T:System.Management.ManagementBaseObject" /> holding the input parameters to the method.</param>
		/// <param name="outParameters">The <see cref="T:System.Management.ManagementBaseObject" /> holding the output parameters to the method.</param>
		public virtual void Add(string methodName, ManagementBaseObject inParameters, ManagementBaseObject outParameters)
		{
			IWbemClassObjectFreeThreaded pInSignature = null;
			IWbemClassObjectFreeThreaded pOutSignature = null;
			if (parent.GetType() == typeof(ManagementObject))
			{
				throw new InvalidOperationException();
			}
			if (inParameters != null)
			{
				pInSignature = inParameters.wbemObject;
			}
			if (outParameters != null)
			{
				pOutSignature = outParameters.wbemObject;
			}
			int num = -2147217407;
			try
			{
				num = parent.wbemObject.PutMethod_(methodName, 0, pInSignature, pOutSignature);
			}
			catch (COMException e)
			{
				ManagementException.ThrowWithExtendedInfo(e);
			}
			if ((num & 0xFFFFF000u) == 2147749888u)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
			}
			else if ((num & 0x80000000u) != 0L)
			{
				Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
			}
		}
	}
	internal class WmiEventSink : IWmiEventSource
	{
		private static int s_hash;

		private int hash;

		private ManagementOperationObserver watcher;

		private object context;

		private ManagementScope scope;

		private object stub;

		private ManagementPath path;

		private string className;

		private bool isLocal;

		private static ManagementOperationObserver watcherParameter;

		private static object contextParameter;

		private static ManagementScope scopeParameter;

		private static string pathParameter;

		private static string classNameParameter;

		private static WmiEventSink wmiEventSinkNew;

		public IWbemObjectSink Stub
		{
			get
			{
				try
				{
					return (stub != null) ? ((IWbemObjectSink)stub) : null;
				}
				catch
				{
					return null;
				}
			}
		}

		internal event InternalObjectPutEventHandler InternalObjectPut;

		internal static WmiEventSink GetWmiEventSink(ManagementOperationObserver watcher, object context, ManagementScope scope, string path, string className)
		{
			if (MTAHelper.IsNoContextMTA())
			{
				return new WmiEventSink(watcher, context, scope, path, className);
			}
			watcherParameter = watcher;
			contextParameter = context;
			scopeParameter = scope;
			pathParameter = path;
			classNameParameter = className;
			ThreadDispatch threadDispatch = new ThreadDispatch((ThreadDispatch.ThreadWorkerMethod)HackToCreateWmiEventSink);
			threadDispatch.Start();
			return wmiEventSinkNew;
		}

		private static void HackToCreateWmiEventSink()
		{
			wmiEventSinkNew = new WmiEventSink(watcherParameter, contextParameter, scopeParameter, pathParameter, classNameParameter);
		}

		protected WmiEventSink(ManagementOperationObserver watcher, object context, ManagementScope scope, string path, string className)
		{
			try
			{
				this.context = context;
				this.watcher = watcher;
				this.className = className;
				isLocal = false;
				if (path != null)
				{
					this.path = new ManagementPath(path);
					if (string.Compare(this.path.Server, ".", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(this.path.Server, Environment.MachineName, StringComparison.OrdinalIgnoreCase) == 0)
					{
						isLocal = true;
					}
				}
				if (scope != null)
				{
					this.scope = scope.Clone();
					if (path == null && (string.Compare(this.scope.Path.Server, ".", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(this.scope.Path.Server, Environment.MachineName, StringComparison.OrdinalIgnoreCase) == 0))
					{
						isLocal = true;
					}
				}
				WmiNetUtilsHelper.GetDemultiplexedStub_f(this, isLocal, out stub);
				hash = Interlocked.Increment(ref s_hash);
			}
			catch
			{
			}
		}

		public override int GetHashCode()
		{
			return hash;
		}

		public virtual void Indicate(IntPtr pIWbemClassObject)
		{
			Marshal.AddRef(pIWbemClassObject);
			IWbemClassObjectFreeThreaded wbemObject = new IWbemClassObjectFreeThreaded(pIWbemClassObject);
			try
			{
				ObjectReadyEventArgs args = new ObjectReadyEventArgs(context, ManagementBaseObject.GetBaseObject(wbemObject, scope));
				watcher.FireObjectReady(args);
			}
			catch
			{
			}
		}

		public void SetStatus(int flags, int hResult, string message, IntPtr pErrorObj)
		{
			IWbemClassObjectFreeThreaded wbemClassObjectFreeThreaded = null;
			if (pErrorObj != IntPtr.Zero)
			{
				Marshal.AddRef(pErrorObj);
				wbemClassObjectFreeThreaded = new IWbemClassObjectFreeThreaded(pErrorObj);
			}
			try
			{
				if (flags == 0)
				{
					if (path != null)
					{
						if (className == null)
						{
							path.RelativePath = message;
						}
						else
						{
							path.RelativePath = className;
						}
						if (this.InternalObjectPut != null)
						{
							try
							{
								InternalObjectPutEventArgs e = new InternalObjectPutEventArgs(path);
								this.InternalObjectPut(this, e);
							}
							catch
							{
							}
						}
						ObjectPutEventArgs args = new ObjectPutEventArgs(context, path);
						watcher.FireObjectPut(args);
					}
					CompletedEventArgs completedEventArgs = null;
					completedEventArgs = ((wbemClassObjectFreeThreaded == null) ? new CompletedEventArgs(context, hResult, null) : new CompletedEventArgs(context, hResult, new ManagementBaseObject(wbemClassObjectFreeThreaded)));
					watcher.FireCompleted(completedEventArgs);
					watcher.RemoveSink(this);
				}
				else if (((uint)flags & 2u) != 0)
				{
					ProgressEventArgs args2 = new ProgressEventArgs(context, (int)((uint)(hResult & -65536) >> 16), hResult & 0xFFFF, message);
					watcher.FireProgress(args2);
				}
			}
			catch
			{
			}
		}

		internal void Cancel()
		{
			try
			{
				scope.GetIWbemServices().CancelAsyncCall_((IWbemObjectSink)stub);
			}
			catch
			{
			}
		}

		internal void ReleaseStub()
		{
			try
			{
				if (stub != null)
				{
					Marshal.ReleaseComObject(stub);
					stub = null;
				}
			}
			catch
			{
			}
		}
	}
	internal class WmiGetEventSink : WmiEventSink
	{
		private ManagementObject managementObject;

		private static ManagementOperationObserver watcherParameter;

		private static object contextParameter;

		private static ManagementScope scopeParameter;

		private static ManagementObject managementObjectParameter;

		private static WmiGetEventSink wmiGetEventSinkNew;

		internal static WmiGetEventSink GetWmiGetEventSink(ManagementOperationObserver watcher, object context, ManagementScope scope, ManagementObject managementObject)
		{
			if (MTAHelper.IsNoContextMTA())
			{
				return new WmiGetEventSink(watcher, context, scope, managementObject);
			}
			watcherParameter = watcher;
			contextParameter = context;
			scopeParameter = scope;
			managementObjectParameter = managementObject;
			ThreadDispatch threadDispatch = new ThreadDispatch((ThreadDispatch.ThreadWorkerMethod)HackToCreateWmiGetEventSink);
			threadDispatch.Start();
			return wmiGetEventSinkNew;
		}

		private static void HackToCreateWmiGetEventSink()
		{
			wmiGetEventSinkNew = new WmiGetEventSink(watcherParameter, contextParameter, scopeParameter, managementObjectParameter);
		}

		private WmiGetEventSink(ManagementOperationObserver watcher, object context, ManagementScope scope, ManagementObject managementObject)
			: base(watcher, context, scope, null, null)
		{
			this.managementObject = managementObject;
		}

		public override void Indicate(IntPtr pIWbemClassObject)
		{
			Marshal.AddRef(pIWbemClassObject);
			IWbemClassObjectFreeThreaded wbemObject = new IWbemClassObjectFreeThreaded(pIWbemClassObject);
			if (managementObject != null)
			{
				try
				{
					managementObject.wbemObject = wbemObject;
				}
				catch
				{
				}
			}
		}
	}
	/// <summary>Defines the languages supported by the code generator.</summary>
	public enum CodeLanguage
	{
		/// <summary>A value for generating C# code.</summary>
		CSharp,
		/// <summary>A value for generating JScript code.</summary>
		JScript,
		/// <summary>A value for generating Visual Basic code.</summary>
		VB,
		/// <summary>A value for generating Visual J# code.</summary>
		VJSharp,
		/// <summary>A value for generating managed C++ code.</summary>
		Mcpp
	}
	internal class ManagementClassGenerator
	{
		private string VSVERSION = "8.0.0.0";

		private string OriginalServer = string.Empty;

		private string OriginalNamespace = string.Empty;

		private string OriginalClassName = string.Empty;

		private string OriginalPath = string.Empty;

		private bool bSingletonClass;

		private bool bUnsignedSupported = true;

		private string NETNamespace = string.Empty;

		private string arrConvFuncName = string.Empty;

		private string enumType = string.Empty;

		private const int DMTF_DATETIME_STR_LENGTH = 25;

		private bool bDateConversionFunctionsAdded;

		private bool bTimeSpanConversionFunctionsAdded;

		private ManagementClass classobj;

		private CodeDomProvider cp;

		private TextWriter tw;

		private string genFileName = string.Empty;

		private CodeTypeDeclaration cc;

		private CodeTypeDeclaration ccc;

		private CodeTypeDeclaration ecc;

		private CodeTypeDeclaration EnumObj;

		private CodeNamespace cn;

		private CodeMemberProperty cmp;

		private CodeConstructor cctor;

		private CodeMemberField cf;

		private CodeObjectCreateExpression coce;

		private CodeParameterDeclarationExpression cpde;

		private CodeIndexerExpression cie;

		private CodeMemberField cmf;

		private CodeMemberMethod cmm;

		private CodePropertyReferenceExpression cpre;

		private CodeMethodInvokeExpression cmie;

		private CodeExpressionStatement cmis;

		private CodeConditionStatement cis;

		private CodeBinaryOperatorExpression cboe;

		private CodeIterationStatement cfls;

		private CodeAttributeArgument caa;

		private CodeAttributeDeclaration cad;

		private ArrayList arrKeyType = new ArrayList(5);

		private ArrayList arrKeys = new ArrayList(5);

		private ArrayList BitMap = new ArrayList(5);

		private ArrayList BitValues = new ArrayList(5);

		private ArrayList ValueMap = new ArrayList(5);

		private ArrayList Values = new ArrayList(5);

		private SortedList PublicProperties = new SortedList(StringComparer.OrdinalIgnoreCase);

		private SortedList PublicMethods = new SortedList(StringComparer.OrdinalIgnoreCase);

		private SortedList PublicNamesUsed = new SortedList(StringComparer.OrdinalIgnoreCase);

		private SortedList PrivateNamesUsed = new SortedList(StringComparer.OrdinalIgnoreCase);

		private ArrayList CommentsString = new ArrayList(5);

		private bool bHasEmbeddedProperties;

		private const int IDS_COMMENT_SHOULDSERIALIZE = 0;

		private const int IDS_COMMENT_ISPROPNULL = 1;

		private const int IDS_COMMENT_RESETPROP = 2;

		private const int IDS_COMMENT_ATTRIBPROP = 3;

		private const int IDS_COMMENT_DATECONVFUNC = 4;

		private const int IDS_COMMENT_GETINSTANCES = 5;

		private const int IDS_COMMENT_CLASSBEGIN = 6;

		private const int IDS_COMMENT_PRIV_AUTOCOMMIT = 7;

		private const int IDS_COMMENT_CONSTRUCTORS = 8;

		private const int IDS_COMMENT_ORIG_NAMESPACE = 9;

		private const int IDS_COMMENT_CLASSNAME = 10;

		private const int IDS_COMMENT_SYSOBJECT = 11;

		private const int IDS_COMMENT_LATEBOUNDOBJ = 12;

		private const int IDS_COMMENT_MGMTSCOPE = 13;

		private const int IDS_COMMENT_AUTOCOMMITPROP = 14;

		private const int IDS_COMMENT_MGMTPATH = 15;

		private const int IDS_COMMENT_PROP_TYPECONVERTER = 16;

		private const int IDS_COMMENT_SYSPROPCLASS = 17;

		private const int IDS_COMMENT_ENUMIMPL = 18;

		private const int IDS_COMMENT_LATEBOUNDPROP = 19;

		private const int IDS_COMMENTS_CREATEDCLASS = 20;

		private const int IDS_COMMENT_EMBEDDEDOBJ = 21;

		private const int IDS_COMMENT_CURRENTOBJ = 22;

		private const int IDS_COMMENT_FLAGFOREMBEDDED = 23;

		public string GeneratedFileName => genFileName;

		public string GeneratedTypeName => PrivateNamesUsed["GeneratedNamespace"].ToString() + "." + PrivateNamesUsed["GeneratedClassName"].ToString();

		public ManagementClassGenerator()
		{
		}

		public ManagementClassGenerator(ManagementClass cls)
		{
			classobj = cls;
		}

		public CodeTypeDeclaration GenerateCode(bool includeSystemProperties, bool systemPropertyClass)
		{
			if (systemPropertyClass)
			{
				InitilializePublicPrivateMembers();
				return GenerateSystemPropertiesClass();
			}
			CheckIfClassIsProperlyInitialized();
			InitializeCodeGeneration();
			return GetCodeTypeDeclarationForClass(includeSystemProperties);
		}

		public bool GenerateCode(CodeLanguage lang, string filePath, string netNamespace)
		{
			if (filePath == null)
			{
				throw new ArgumentOutOfRangeException(GetString("NULLFILEPATH_EXCEPT"));
			}
			if (filePath.Length == 0)
			{
				throw new ArgumentOutOfRangeException(GetString("EMPTY_FILEPATH_EXCEPT"));
			}
			NETNamespace = netNamespace;
			CheckIfClassIsProperlyInitialized();
			InitializeCodeGeneration();
			tw = new StreamWriter(new FileStream(filePath, FileMode.Create), Encoding.UTF8);
			return GenerateAndWriteCode(lang);
		}

		private void CheckIfClassIsProperlyInitialized()
		{
			if (classobj == null)
			{
				if (OriginalNamespace == null || (OriginalNamespace != null && OriginalNamespace.Length == 0))
				{
					throw new ArgumentOutOfRangeException(GetString("NAMESPACE_NOTINIT_EXCEPT"));
				}
				if (OriginalClassName == null || (OriginalClassName != null && OriginalClassName.Length == 0))
				{
					throw new ArgumentOutOfRangeException(GetString("CLASSNAME_NOTINIT_EXCEPT"));
				}
			}
		}

		private void InitializeCodeGeneration()
		{
			InitializeClassObject();
			InitilializePublicPrivateMembers();
			ProcessNamespaceAndClassName();
			ProcessNamingCollisions();
		}

		private CodeTypeDeclaration GetCodeTypeDeclarationForClass(bool bIncludeSystemClassinClassDef)
		{
			cc = new CodeTypeDeclaration(PrivateNamesUsed["GeneratedClassName"].ToString());
			cc.BaseTypes.Add(new CodeTypeReference(PrivateNamesUsed["ComponentClass"].ToString()));
			AddClassComments(cc);
			GeneratePublicReadOnlyProperty(PublicNamesUsed["NamespaceProperty"].ToString(), "System.String", OriginalNamespace, isLiteral: false, isBrowsable: true, GetString("COMMENT_ORIGNAMESPACE"));
			GeneratePrivateMember(PrivateNamesUsed["CreationWmiNamespace"].ToString(), "System.String", new CodePrimitiveExpression(OriginalNamespace), isStatic: true, GetString("COMMENT_CREATEDWMINAMESPACE"));
			GenerateClassNameProperty();
			GeneratePrivateMember(PrivateNamesUsed["CreationClassName"].ToString(), "System.String", new CodePrimitiveExpression(OriginalClassName), isStatic: true, GetString("COMMENT_CREATEDCLASS"));
			GeneratePublicReadOnlyProperty(PublicNamesUsed["SystemPropertiesProperty"].ToString(), PublicNamesUsed["SystemPropertiesClass"].ToString(), PrivateNamesUsed["SystemPropertiesObject"].ToString(), isLiteral: true, isBrowsable: true, GetString("COMMENT_SYSOBJECT"));
			GeneratePublicReadOnlyProperty(PublicNamesUsed["LateBoundObjectProperty"].ToString(), PublicNamesUsed["BaseObjClass"].ToString(), PrivateNamesUsed["CurrentObject"].ToString(), isLiteral: true, isBrowsable: false, GetString("COMMENT_LATEBOUNDPROP"));
			GenerateScopeProperty();
			GeneratePublicProperty(PublicNamesUsed["AutoCommitProperty"].ToString(), "System.Boolean", new CodeSnippetExpression(PrivateNamesUsed["AutoCommitProperty"].ToString()), isBrowsable: false, GetString("COMMENT_AUTOCOMMITPROP"), isStatic: false);
			GeneratePathProperty();
			GeneratePrivateMember(PrivateNamesUsed["statMgmtScope"].ToString(), PublicNamesUsed["ScopeClass"].ToString(), new CodePrimitiveExpression(null), isStatic: true, GetString("COMMENT_STATICMANAGEMENTSCOPE"));
			GeneratePublicProperty(PrivateNamesUsed["staticScope"].ToString(), PublicNamesUsed["ScopeClass"].ToString(), new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString()), isBrowsable: true, GetString("COMMENT_STATICSCOPEPROPERTY"), isStatic: true);
			GenerateIfClassvalidFunction();
			GenerateProperties();
			GenerateMethodToInitializeVariables();
			GenerateConstructPath();
			GenerateDefaultConstructor();
			GenerateInitializeObject();
			if (bSingletonClass)
			{
				GenerateConstructorWithScope();
				GenerateConstructorWithOptions();
				GenerateConstructorWithScopeOptions();
			}
			else
			{
				GenerateConstructorWithKeys();
				GenerateConstructorWithScopeKeys();
				GenerateConstructorWithPathOptions();
				GenerateConstructorWithScopePath();
				GenerateGetInstancesWithNoParameters();
				GenerateGetInstancesWithCondition();
				GenerateGetInstancesWithProperties();
				GenerateGetInstancesWithWhereProperties();
				GenerateGetInstancesWithScope();
				GenerateGetInstancesWithScopeCondition();
				GenerateGetInstancesWithScopeProperties();
				GenerateGetInstancesWithScopeWhereProperties();
				GenerateCollectionClass();
			}
			GenerateConstructorWithPath();
			GenerateConstructorWithScopePathOptions();
			GenarateConstructorWithLateBound();
			GenarateConstructorWithLateBoundForEmbedded();
			GenerateCreateInstance();
			GenerateDeleteInstance();
			GenerateMethods();
			GeneratePrivateMember(PrivateNamesUsed["SystemPropertiesObject"].ToString(), PublicNamesUsed["SystemPropertiesClass"].ToString(), null);
			GeneratePrivateMember(PrivateNamesUsed["LateBoundObject"].ToString(), PublicNamesUsed["LateBoundClass"].ToString(), GetString("COMMENT_LATEBOUNDOBJ"));
			GeneratePrivateMember(PrivateNamesUsed["AutoCommitProperty"].ToString(), "System.Boolean", new CodePrimitiveExpression(true), isStatic: false, GetString("COMMENT_PRIVAUTOCOMMIT"));
			GeneratePrivateMember(PrivateNamesUsed["EmbeddedObject"].ToString(), PublicNamesUsed["BaseObjClass"].ToString(), GetString("COMMENT_EMBEDDEDOBJ"));
			GeneratePrivateMember(PrivateNamesUsed["CurrentObject"].ToString(), PublicNamesUsed["BaseObjClass"].ToString(), GetString("COMMENT_CURRENTOBJ"));
			GeneratePrivateMember(PrivateNamesUsed["IsEmbedded"].ToString(), "System.Boolean", new CodePrimitiveExpression(false), isStatic: false, GetString("COMMENT_FLAGFOREMBEDDED"));
			cc.Members.Add(GenerateTypeConverterClass());
			if (bIncludeSystemClassinClassDef)
			{
				cc.Members.Add(GenerateSystemPropertiesClass());
			}
			if (bHasEmbeddedProperties)
			{
				AddCommentsForEmbeddedProperties();
			}
			cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_CLASSBEGIN") + OriginalClassName));
			return cc;
		}

		private bool GenerateAndWriteCode(CodeLanguage lang)
		{
			if (!InitializeCodeGenerator(lang))
			{
				return false;
			}
			InitializeCodeTypeDeclaration(lang);
			GetCodeTypeDeclarationForClass(bIncludeSystemClassinClassDef: true);
			cc.Name = cp.CreateValidIdentifier(cc.Name);
			cn.Types.Add(cc);
			try
			{
				cp.GenerateCodeFromNamespace(cn, tw, new CodeGeneratorOptions());
			}
			finally
			{
				tw.Close();
			}
			return true;
		}

		private void InitializeClassObject()
		{
			if (classobj == null)
			{
				ManagementPath managementPath;
				if (OriginalPath.Length != 0)
				{
					managementPath = new ManagementPath(OriginalPath);
				}
				else
				{
					managementPath = new ManagementPath();
					if (OriginalServer.Length != 0)
					{
						managementPath.Server = OriginalServer;
					}
					managementPath.ClassName = OriginalClassName;
					managementPath.NamespacePath = OriginalNamespace;
				}
				classobj = new ManagementClass(managementPath);
			}
			else
			{
				ManagementPath path = classobj.Path;
				OriginalServer = path.Server;
				OriginalClassName = path.ClassName;
				OriginalNamespace = path.NamespacePath;
				char[] array = OriginalNamespace.ToCharArray();
				if (array.Length >= 2 && array[0] == '\\' && array[1] == '\\')
				{
					bool flag = false;
					int length = OriginalNamespace.Length;
					OriginalNamespace = string.Empty;
					for (int i = 2; i < length; i++)
					{
						if (flag)
						{
							OriginalNamespace += array[i];
						}
						else if (array[i] == '\\')
						{
							flag = true;
						}
					}
				}
			}
			try
			{
				classobj.Get();
			}
			catch (ManagementException)
			{
				throw;
			}
			bSingletonClass = false;
			foreach (QualifierData qualifier in classobj.Qualifiers)
			{
				if (string.Compare(qualifier.Name, "singleton", StringComparison.OrdinalIgnoreCase) == 0)
				{
					bSingletonClass = true;
					break;
				}
			}
		}

		private void InitilializePublicPrivateMembers()
		{
			PublicNamesUsed.Add("SystemPropertiesProperty", "SystemProperties");
			PublicNamesUsed.Add("LateBoundObjectProperty", "LateBoundObject");
			PublicNamesUsed.Add("NamespaceProperty", "OriginatingNamespace");
			PublicNamesUsed.Add("ClassNameProperty", "ManagementClassName");
			PublicNamesUsed.Add("ScopeProperty", "Scope");
			PublicNamesUsed.Add("PathProperty", "Path");
			PublicNamesUsed.Add("SystemPropertiesClass", "ManagementSystemProperties");
			PublicNamesUsed.Add("LateBoundClass", "System.Management.ManagementObject");
			PublicNamesUsed.Add("PathClass", "System.Management.ManagementPath");
			PublicNamesUsed.Add("ScopeClass", "System.Management.ManagementScope");
			PublicNamesUsed.Add("QueryOptionsClass", "System.Management.EnumerationOptions");
			PublicNamesUsed.Add("GetOptionsClass", "System.Management.ObjectGetOptions");
			PublicNamesUsed.Add("ArgumentExceptionClass", "System.ArgumentException");
			PublicNamesUsed.Add("QueryClass", "SelectQuery");
			PublicNamesUsed.Add("ObjectSearcherClass", "System.Management.ManagementObjectSearcher");
			PublicNamesUsed.Add("FilterFunction", "GetInstances");
			PublicNamesUsed.Add("ConstructPathFunction", "ConstructPath");
			PublicNamesUsed.Add("TypeConverter", "TypeConverter");
			PublicNamesUsed.Add("AutoCommitProperty", "AutoCommit");
			PublicNamesUsed.Add("CommitMethod", "CommitObject");
			PublicNamesUsed.Add("ManagementClass", "System.Management.ManagementClass");
			PublicNamesUsed.Add("NotSupportedExceptClass", "System.NotSupportedException");
			PublicNamesUsed.Add("BaseObjClass", "System.Management.ManagementBaseObject");
			PublicNamesUsed.Add("OptionsProp", "Options");
			PublicNamesUsed.Add("ClassPathProperty", "ClassPath");
			PublicNamesUsed.Add("CreateInst", "CreateInstance");
			PublicNamesUsed.Add("DeleteInst", "Delete");
			PublicNamesUsed.Add("SystemNameSpace", "System");
			PublicNamesUsed.Add("ArgumentOutOfRangeException", "System.ArgumentOutOfRangeException");
			PublicNamesUsed.Add("System", "System");
			PublicNamesUsed.Add("Other", "Other");
			PublicNamesUsed.Add("Unknown", "Unknown");
			PublicNamesUsed.Add("PutOptions", "System.Management.PutOptions");
			PublicNamesUsed.Add("Type", "System.Type");
			PublicNamesUsed.Add("Boolean", "System.Boolean");
			PublicNamesUsed.Add("ValueType", "System.ValueType");
			PublicNamesUsed.Add("Events1", "Events");
			PublicNamesUsed.Add("Component1", "Component");
			PrivateNamesUsed.Add("SystemPropertiesObject", "PrivateSystemProperties");
			PrivateNamesUsed.Add("LateBoundObject", "PrivateLateBoundObject");
			PrivateNamesUsed.Add("AutoCommitProperty", "AutoCommitProp");
			PrivateNamesUsed.Add("Privileges", "EnablePrivileges");
			PrivateNamesUsed.Add("ComponentClass", "System.ComponentModel.Component");
			PrivateNamesUsed.Add("ScopeParam", "mgmtScope");
			PrivateNamesUsed.Add("NullRefExcep", "System.NullReferenceException");
			PrivateNamesUsed.Add("ConverterClass", "WMIValueTypeConverter");
			PrivateNamesUsed.Add("EnumParam", "enumOptions");
			PrivateNamesUsed.Add("CreationClassName", "CreatedClassName");
			PrivateNamesUsed.Add("CreationWmiNamespace", "CreatedWmiNamespace");
			PrivateNamesUsed.Add("ClassNameCheckFunc", "CheckIfProperClass");
			PrivateNamesUsed.Add("EmbeddedObject", "embeddedObj");
			PrivateNamesUsed.Add("CurrentObject", "curObj");
			PrivateNamesUsed.Add("IsEmbedded", "isEmbedded");
			PrivateNamesUsed.Add("ToDateTimeMethod", "ToDateTime");
			PrivateNamesUsed.Add("ToDMTFDateTimeMethod", "ToDmtfDateTime");
			PrivateNamesUsed.Add("ToDMTFTimeIntervalMethod", "ToDmtfTimeInterval");
			PrivateNamesUsed.Add("ToTimeSpanMethod", "ToTimeSpan");
			PrivateNamesUsed.Add("SetMgmtScope", "SetStaticManagementScope");
			PrivateNamesUsed.Add("statMgmtScope", "statMgmtScope");
			PrivateNamesUsed.Add("staticScope", "StaticScope");
			PrivateNamesUsed.Add("initVariable", "Initialize");
			PrivateNamesUsed.Add("putOptions", "putOptions");
			PrivateNamesUsed.Add("InitialObjectFunc", "InitializeObject");
		}

		private void ProcessNamingCollisions()
		{
			if (classobj.Properties != null)
			{
				foreach (PropertyData property in classobj.Properties)
				{
					PublicProperties.Add(property.Name, property.Name);
				}
			}
			if (classobj.Methods != null)
			{
				foreach (MethodData method in classobj.Methods)
				{
					PublicMethods.Add(method.Name, method.Name);
				}
			}
			foreach (string value in PublicNamesUsed.Values)
			{
				int num = IsContainedIn(value, ref PublicProperties);
				if (num != -1)
				{
					PublicProperties.SetByIndex(num, ResolveCollision(value, bCheckthisFirst: false));
					continue;
				}
				num = IsContainedIn(value, ref PublicMethods);
				if (num != -1)
				{
					PublicMethods.SetByIndex(num, ResolveCollision(value, bCheckthisFirst: false));
				}
			}
			foreach (string value2 in PublicProperties.Values)
			{
				int num = IsContainedIn(value2, ref PrivateNamesUsed);
				if (num != -1)
				{
					PrivateNamesUsed.SetByIndex(num, ResolveCollision(value2, bCheckthisFirst: false));
				}
			}
			foreach (string value3 in PublicMethods.Values)
			{
				int num = IsContainedIn(value3, ref PrivateNamesUsed);
				if (num != -1)
				{
					PrivateNamesUsed.SetByIndex(num, ResolveCollision(value3, bCheckthisFirst: false));
				}
			}
			foreach (string value4 in PublicProperties.Values)
			{
				int num = IsContainedIn(value4, ref PublicMethods);
				if (num != -1)
				{
					PublicMethods.SetByIndex(num, ResolveCollision(value4, bCheckthisFirst: false));
				}
			}
			string inString = PrivateNamesUsed["GeneratedClassName"].ToString() + "Collection";
			PrivateNamesUsed.Add("CollectionClass", ResolveCollision(inString, bCheckthisFirst: true));
			inString = PrivateNamesUsed["GeneratedClassName"].ToString() + "Enumerator";
			PrivateNamesUsed.Add("EnumeratorClass", ResolveCollision(inString, bCheckthisFirst: true));
		}

		private string ResolveCollision(string inString, bool bCheckthisFirst)
		{
			string text = inString;
			bool flag = true;
			int num = -1;
			string text2 = "";
			if (!bCheckthisFirst)
			{
				num++;
				text = text + text2 + num.ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int)));
			}
			while (flag)
			{
				if (IsContainedIn(text, ref PublicProperties) == -1 && IsContainedIn(text, ref PublicMethods) == -1 && IsContainedIn(text, ref PublicNamesUsed) == -1 && IsContainedIn(text, ref PrivateNamesUsed) == -1)
				{
					flag = false;
					break;
				}
				try
				{
					num++;
				}
				catch (OverflowException)
				{
					text2 += "_";
					num = 0;
				}
				text = inString + text2 + num.ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int)));
			}
			if (text.Length > 0)
			{
				string text3 = text.Substring(0, 1).ToUpper(CultureInfo.InvariantCulture);
				text = text3 + text.Substring(1, text.Length - 1);
			}
			return text;
		}

		private void ProcessNamespaceAndClassName()
		{
			string empty = string.Empty;
			string empty2 = string.Empty;
			if (NETNamespace.Length == 0)
			{
				empty2 = OriginalNamespace;
				empty2 = empty2.Replace('\\', '.');
				empty2 = empty2.ToUpper(CultureInfo.InvariantCulture);
			}
			else
			{
				empty2 = NETNamespace;
			}
			if (OriginalClassName.IndexOf('_') > 0)
			{
				empty = OriginalClassName.Substring(0, OriginalClassName.IndexOf('_'));
				if (NETNamespace.Length == 0)
				{
					empty2 += ".";
					empty2 += empty;
				}
				empty = OriginalClassName.Substring(OriginalClassName.IndexOf('_') + 1);
			}
			else
			{
				empty = OriginalClassName;
			}
			if (!char.IsLetter(empty[0]))
			{
				empty = "C" + empty;
			}
			empty = ResolveCollision(empty, bCheckthisFirst: true);
			if (Type.GetType("System." + empty) != null || Type.GetType("System.ComponentModel." + empty) != null || Type.GetType("System.Management." + empty) != null || Type.GetType("System.Collections." + empty) != null || Type.GetType("System.Globalization." + empty) != null)
			{
				PublicNamesUsed.Add(empty, empty);
				empty = ResolveCollision(empty, bCheckthisFirst: true);
			}
			PrivateNamesUsed.Add("GeneratedClassName", empty);
			PrivateNamesUsed.Add("GeneratedNamespace", empty2);
		}

		private void InitializeCodeTypeDeclaration(CodeLanguage lang)
		{
			cn = new CodeNamespace(PrivateNamesUsed["GeneratedNamespace"].ToString());
			cn.Imports.Add(new CodeNamespaceImport("System"));
			cn.Imports.Add(new CodeNamespaceImport("System.ComponentModel"));
			cn.Imports.Add(new CodeNamespaceImport("System.Management"));
			cn.Imports.Add(new CodeNamespaceImport("System.Collections"));
			cn.Imports.Add(new CodeNamespaceImport("System.Globalization"));
			if (lang == CodeLanguage.VB)
			{
				cn.Imports.Add(new CodeNamespaceImport("Microsoft.VisualBasic"));
			}
		}

		private void GeneratePublicReadOnlyProperty(string propName, string propType, object propValue, bool isLiteral, bool isBrowsable, string Comment)
		{
			cmp = new CodeMemberProperty();
			cmp.Name = propName;
			cmp.Attributes = (MemberAttributes)24578;
			cmp.Type = new CodeTypeReference(propType);
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(isBrowsable);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp.CustomAttributes.Add(cad);
			caa = new CodeAttributeArgument();
			caa.Value = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("DesignerSerializationVisibility"), "Hidden");
			cad = new CodeAttributeDeclaration();
			cad.Name = "DesignerSerializationVisibility";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes.Add(cad);
			if (isLiteral)
			{
				cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeSnippetExpression(propValue.ToString())));
			}
			else
			{
				cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(propValue)));
			}
			cc.Members.Add(cmp);
			if (Comment != null && Comment.Length != 0)
			{
				cmp.Comments.Add(new CodeCommentStatement(Comment));
			}
		}

		private void GeneratePublicProperty(string propName, string propType, CodeExpression Value, bool isBrowsable, string Comment, bool isStatic)
		{
			cmp = new CodeMemberProperty();
			cmp.Name = propName;
			cmp.Attributes = (MemberAttributes)24578;
			cmp.Type = new CodeTypeReference(propType);
			if (isStatic)
			{
				cmp.Attributes |= MemberAttributes.Static;
			}
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(isBrowsable);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp.CustomAttributes.Add(cad);
			if (IsDesignerSerializationVisibilityToBeSet(propName))
			{
				caa = new CodeAttributeArgument();
				caa.Value = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("DesignerSerializationVisibility"), "Hidden");
				cad = new CodeAttributeDeclaration();
				cad.Name = "DesignerSerializationVisibility";
				cad.Arguments.Add(caa);
				cmp.CustomAttributes.Add(cad);
			}
			cmp.GetStatements.Add(new CodeMethodReturnStatement(Value));
			cmp.SetStatements.Add(new CodeAssignStatement(Value, new CodeSnippetExpression("value")));
			cc.Members.Add(cmp);
			if (Comment != null && Comment.Length != 0)
			{
				cmp.Comments.Add(new CodeCommentStatement(Comment));
			}
		}

		private void GeneratePathProperty()
		{
			cmp = new CodeMemberProperty();
			cmp.Name = PublicNamesUsed["PathProperty"].ToString();
			cmp.Attributes = (MemberAttributes)24578;
			cmp.Type = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp.CustomAttributes.Add(cad);
			cpre = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()), "Path");
			cis = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
			cboe.Right = new CodePrimitiveExpression(false);
			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			cis.Condition = cboe;
			cis.TrueStatements.Add(new CodeMethodReturnStatement(cpre));
			cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
			cmp.GetStatements.Add(cis);
			cis = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
			cboe.Right = new CodePrimitiveExpression(false);
			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			cis.Condition = cboe;
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.MethodName = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			cmie.Parameters.Add(new CodeVariableReferenceExpression("value"));
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = cmie;
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(true);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
			coce.Parameters.Add(new CodePrimitiveExpression(GetString("CLASSNOT_FOUND_EXCEPT")));
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(coce));
			cis.TrueStatements.Add(codeConditionStatement);
			cis.TrueStatements.Add(new CodeAssignStatement(cpre, new CodeSnippetExpression("value")));
			cmp.SetStatements.Add(cis);
			cc.Members.Add(cmp);
			cmp.Comments.Add(new CodeCommentStatement(GetString("COMMENT_MGMTPATH")));
		}

		private CodeTypeDeclaration GenerateSystemPropertiesClass()
		{
			CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration(PublicNamesUsed["SystemPropertiesClass"].ToString());
			codeTypeDeclaration.TypeAttributes = TypeAttributes.NestedPublic;
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cpde = new CodeParameterDeclarationExpression();
			cpde.Type = new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString());
			cpde.Name = "ManagedObject";
			cctor.Parameters.Add(cpde);
			cctor.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()), new CodeVariableReferenceExpression("ManagedObject")));
			codeTypeDeclaration.Members.Add(cctor);
			caa = new CodeAttributeArgument();
			caa.Value = new CodeTypeOfExpression(typeof(ExpandableObjectConverter));
			cad = new CodeAttributeDeclaration();
			cad.Name = PublicNamesUsed["TypeConverter"].ToString();
			cad.Arguments.Add(caa);
			codeTypeDeclaration.CustomAttributes.Add(cad);
			int num = 0;
			foreach (PropertyData systemProperty in classobj.SystemProperties)
			{
				cmp = new CodeMemberProperty();
				caa = new CodeAttributeArgument();
				caa.Value = new CodePrimitiveExpression(true);
				cad = new CodeAttributeDeclaration();
				cad.Name = "Browsable";
				cad.Arguments.Add(caa);
				cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
				cmp.CustomAttributes.Add(cad);
				char[] array = systemProperty.Name.ToCharArray();
				for (num = 0; num < array.Length && !char.IsLetterOrDigit(array[num]); num++)
				{
				}
				if (num == array.Length)
				{
					num = 0;
				}
				char[] array2 = new char[array.Length - num];
				for (int i = num; i < array.Length; i++)
				{
					array2[i - num] = array[i];
				}
				cmp.Name = new string(array2).ToUpper(CultureInfo.InvariantCulture);
				cmp.Attributes = (MemberAttributes)24578;
				cmp.Type = ConvertCIMType(systemProperty.Type, systemProperty.IsArray);
				cie = new CodeIndexerExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()), new CodePrimitiveExpression(systemProperty.Name));
				cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeCastExpression(cmp.Type, cie)));
				codeTypeDeclaration.Members.Add(cmp);
			}
			cf = new CodeMemberField();
			cf.Name = PrivateNamesUsed["LateBoundObject"].ToString();
			cf.Attributes = (MemberAttributes)20482;
			cf.Type = new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString());
			codeTypeDeclaration.Members.Add(cf);
			codeTypeDeclaration.Comments.Add(new CodeCommentStatement(GetString("COMMENT_SYSPROPCLASS")));
			return codeTypeDeclaration;
		}

		private void GenerateProperties()
		{
			bool bDynamicClass = IsDynamicClass();
			CodeMemberMethod codeMemberMethod = null;
			CodeMemberProperty codeMemberProperty = null;
			string empty = string.Empty;
			bool flag = false;
			for (int i = 0; i < PublicProperties.Count; i++)
			{
				flag = false;
				PropertyData propertyData = classobj.Properties[PublicProperties.GetKey(i).ToString()];
				bool bRead = true;
				bool bWrite = true;
				bool bStatic = false;
				cmp = new CodeMemberProperty();
				cmp.Name = PublicProperties[propertyData.Name].ToString();
				cmp.Attributes = (MemberAttributes)24578;
				cmp.Type = ConvertCIMType(propertyData.Type, propertyData.IsArray);
				if (propertyData.Type == CimType.DateTime)
				{
					CodeTypeReference codeType = cmp.Type;
					flag = GetDateTimeType(propertyData, ref codeType);
					cmp.Type = codeType;
				}
				if ((cmp.Type.ArrayRank == 0 && cmp.Type.BaseType == new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString()).BaseType) || (cmp.Type.ArrayRank > 0 && cmp.Type.ArrayElementType.BaseType == new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString()).BaseType))
				{
					bHasEmbeddedProperties = true;
				}
				empty = "Is" + PublicProperties[propertyData.Name].ToString() + "Null";
				codeMemberProperty = new CodeMemberProperty();
				codeMemberProperty.Name = empty;
				codeMemberProperty.Attributes = (MemberAttributes)24578;
				codeMemberProperty.Type = new CodeTypeReference("System.Boolean");
				caa = new CodeAttributeArgument();
				caa.Value = new CodePrimitiveExpression(true);
				cad = new CodeAttributeDeclaration();
				cad.Name = "Browsable";
				cad.Arguments.Add(caa);
				cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
				cmp.CustomAttributes.Add(cad);
				caa = new CodeAttributeArgument();
				caa.Value = new CodePrimitiveExpression(false);
				cad = new CodeAttributeDeclaration();
				cad.Name = "Browsable";
				cad.Arguments.Add(caa);
				codeMemberProperty.CustomAttributes = new CodeAttributeDeclarationCollection();
				codeMemberProperty.CustomAttributes.Add(cad);
				caa = new CodeAttributeArgument();
				caa.Value = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("DesignerSerializationVisibility"), "Hidden");
				cad = new CodeAttributeDeclaration();
				cad.Name = "DesignerSerializationVisibility";
				cad.Arguments.Add(caa);
				cmp.CustomAttributes.Add(cad);
				codeMemberProperty.CustomAttributes.Add(cad);
				cie = new CodeIndexerExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString()), new CodePrimitiveExpression(propertyData.Name));
				bool nullable = false;
				string text = ProcessPropertyQualifiers(propertyData, ref bRead, ref bWrite, ref bStatic, bDynamicClass, out nullable);
				if (!bRead && !bWrite)
				{
					continue;
				}
				if (text.Length != 0)
				{
					caa = new CodeAttributeArgument();
					caa.Value = new CodePrimitiveExpression(text);
					cad = new CodeAttributeDeclaration();
					cad.Name = "Description";
					cad.Arguments.Add(caa);
					cmp.CustomAttributes.Add(cad);
				}
				bool flag2 = GeneratePropertyHelperEnums(propertyData, PublicProperties[propertyData.Name].ToString(), nullable);
				if (bRead)
				{
					if (IsPropertyValueType(propertyData.Type) && !propertyData.IsArray)
					{
						cis = new CodeConditionStatement();
						cis.Condition = new CodeBinaryOperatorExpression(cie, CodeBinaryOperatorType.IdentityEquality, new CodePrimitiveExpression(null));
						cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));
						cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(false)));
						codeMemberProperty.GetStatements.Add(cis);
						cc.Members.Add(codeMemberProperty);
						caa = new CodeAttributeArgument();
						caa.Value = new CodeTypeOfExpression(PrivateNamesUsed["ConverterClass"].ToString());
						cad = new CodeAttributeDeclaration();
						cad.Name = PublicNamesUsed["TypeConverter"].ToString();
						cad.Arguments.Add(caa);
						cmp.CustomAttributes.Add(cad);
						if (propertyData.Type != CimType.DateTime)
						{
							cis = new CodeConditionStatement();
							cis.Condition = new CodeBinaryOperatorExpression(cie, CodeBinaryOperatorType.IdentityEquality, new CodePrimitiveExpression(null));
							if (flag2)
							{
								if (propertyData.IsArray)
								{
									cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
								}
								else
								{
									cmie = new CodeMethodInvokeExpression();
									cmie.Method.TargetObject = new CodeTypeReferenceExpression("System.Convert");
									cmie.Parameters.Add(new CodePrimitiveExpression(propertyData.NullEnumValue));
									cmie.Method.MethodName = arrConvFuncName;
									cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodeCastExpression(cmp.Type, cmie)));
								}
							}
							else
							{
								cmie = new CodeMethodInvokeExpression();
								cmie.Parameters.Add(new CodePrimitiveExpression(propertyData.NullEnumValue));
								cmie.Method.MethodName = GetConversionFunction(propertyData.Type);
								cmie.Method.TargetObject = new CodeTypeReferenceExpression("System.Convert");
								if (propertyData.IsArray)
								{
									CodeExpression[] initializers = new CodeExpression[1] { cmie };
									cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodeArrayCreateExpression(cmp.Type, initializers)));
								}
								else
								{
									cis.TrueStatements.Add(new CodeMethodReturnStatement(cmie));
								}
							}
							cmp.GetStatements.Add(cis);
						}
						cmm = new CodeMemberMethod();
						cmm.Name = "ShouldSerialize" + PublicProperties[propertyData.Name].ToString();
						cmm.Attributes = (MemberAttributes)20482;
						cmm.ReturnType = new CodeTypeReference("System.Boolean");
						CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
						codeConditionStatement.Condition = new CodeBinaryOperatorExpression(new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), empty), CodeBinaryOperatorType.ValueEquality, new CodePrimitiveExpression(false));
						codeConditionStatement.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));
						cmm.Statements.Add(codeConditionStatement);
						cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(false)));
						cc.Members.Add(cmm);
					}
					if (propertyData.Type == CimType.Reference)
					{
						GenerateCodeForRefAndDateTimeTypes(cie, propertyData.IsArray, cmp.GetStatements, PublicNamesUsed["PathClass"].ToString(), null, bIsValueProprequired: false);
					}
					else if (propertyData.Type == CimType.DateTime)
					{
						if (flag)
						{
							GenerateCodeForRefAndDateTimeTypes(cie, propertyData.IsArray, cmp.GetStatements, "System.TimeSpan", null, bIsValueProprequired: false);
						}
						else
						{
							GenerateCodeForRefAndDateTimeTypes(cie, propertyData.IsArray, cmp.GetStatements, "System.DateTime", null, bIsValueProprequired: false);
						}
					}
					else if (flag2)
					{
						if (propertyData.IsArray)
						{
							AddGetStatementsForEnumArray(cie, cmp);
						}
						else
						{
							cmie = new CodeMethodInvokeExpression();
							cmie.Method.TargetObject = new CodeTypeReferenceExpression("System.Convert");
							cmie.Parameters.Add(cie);
							cmie.Method.MethodName = arrConvFuncName;
							cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeCastExpression(cmp.Type, cmie)));
						}
					}
					else
					{
						cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeCastExpression(cmp.Type, cie)));
					}
				}
				if (bWrite)
				{
					if (nullable)
					{
						codeMemberMethod = new CodeMemberMethod();
						codeMemberMethod.Name = "Reset" + PublicProperties[propertyData.Name].ToString();
						codeMemberMethod.Attributes = (MemberAttributes)20482;
						codeMemberMethod.Statements.Add(new CodeAssignStatement(cie, new CodePrimitiveExpression(null)));
					}
					if (propertyData.Type == CimType.Reference)
					{
						AddPropertySet(cie, propertyData.IsArray, cmp.SetStatements, PublicNamesUsed["PathClass"].ToString(), null);
					}
					else if (propertyData.Type == CimType.DateTime)
					{
						if (flag)
						{
							AddPropertySet(cie, propertyData.IsArray, cmp.SetStatements, "System.TimeSpan", null);
						}
						else
						{
							AddPropertySet(cie, propertyData.IsArray, cmp.SetStatements, "System.DateTime", null);
						}
					}
					else if (flag2 && nullable)
					{
						CodeConditionStatement codeConditionStatement2 = new CodeConditionStatement();
						if (propertyData.IsArray)
						{
							codeConditionStatement2.Condition = new CodeBinaryOperatorExpression(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(new CodeTypeReference(PublicProperties[propertyData.Name].ToString() + "Values")), "NULL_ENUM_VALUE"), CodeBinaryOperatorType.ValueEquality, new CodeArrayIndexerExpression(new CodeVariableReferenceExpression("value"), new CodePrimitiveExpression(0)));
						}
						else
						{
							codeConditionStatement2.Condition = new CodeBinaryOperatorExpression(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(new CodeTypeReference(PublicProperties[propertyData.Name].ToString() + "Values")), "NULL_ENUM_VALUE"), CodeBinaryOperatorType.ValueEquality, new CodeSnippetExpression("value"));
						}
						codeConditionStatement2.TrueStatements.Add(new CodeAssignStatement(cie, new CodePrimitiveExpression(null)));
						codeConditionStatement2.FalseStatements.Add(new CodeAssignStatement(cie, new CodeSnippetExpression("value")));
						cmp.SetStatements.Add(codeConditionStatement2);
					}
					else
					{
						cmp.SetStatements.Add(new CodeAssignStatement(cie, new CodeSnippetExpression("value")));
					}
					cmie = new CodeMethodInvokeExpression();
					cmie.Method.TargetObject = new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString());
					cmie.Method.MethodName = "Put";
					cboe = new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["AutoCommitProperty"].ToString()), CodeBinaryOperatorType.ValueEquality, new CodePrimitiveExpression(true));
					CodeBinaryOperatorExpression left = new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString()), CodeBinaryOperatorType.ValueEquality, new CodePrimitiveExpression(false));
					CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
					codeBinaryOperatorExpression.Right = cboe;
					codeBinaryOperatorExpression.Left = left;
					codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.BooleanAnd;
					cis = new CodeConditionStatement();
					cis.Condition = codeBinaryOperatorExpression;
					cis.TrueStatements.Add(new CodeExpressionStatement(cmie));
					cmp.SetStatements.Add(cis);
					if (nullable)
					{
						codeMemberMethod.Statements.Add(cis);
					}
				}
				cc.Members.Add(cmp);
				if (nullable && bWrite)
				{
					cc.Members.Add(codeMemberMethod);
				}
			}
			GenerateCommitMethod();
		}

		private string ProcessPropertyQualifiers(PropertyData prop, ref bool bRead, ref bool bWrite, ref bool bStatic, bool bDynamicClass, out bool nullable)
		{
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			nullable = true;
			bRead = true;
			bWrite = false;
			arrConvFuncName = "ToInt32";
			enumType = "System.Int32";
			string result = string.Empty;
			foreach (QualifierData qualifier in prop.Qualifiers)
			{
				if (string.Compare(qualifier.Name, "description", StringComparison.OrdinalIgnoreCase) == 0)
				{
					result = qualifier.Value.ToString();
					continue;
				}
				if (string.Compare(qualifier.Name, "Not_Null", StringComparison.OrdinalIgnoreCase) == 0)
				{
					nullable = false;
					continue;
				}
				if (string.Compare(qualifier.Name, "key", StringComparison.OrdinalIgnoreCase) == 0)
				{
					arrKeyType.Add(cmp.Type);
					arrKeys.Add(prop.Name);
					nullable = false;
					break;
				}
				if (string.Compare(qualifier.Name, "static", StringComparison.OrdinalIgnoreCase) == 0)
				{
					bStatic = true;
					cmp.Attributes |= MemberAttributes.Static;
				}
				else if (string.Compare(qualifier.Name, "read", StringComparison.OrdinalIgnoreCase) == 0)
				{
					if (!(bool)qualifier.Value)
					{
						bRead = false;
					}
					else
					{
						bRead = true;
					}
				}
				else if (string.Compare(qualifier.Name, "write", StringComparison.OrdinalIgnoreCase) == 0)
				{
					flag = true;
					flag2 = (((bool)qualifier.Value) ? true : false);
				}
				else if (string.Compare(qualifier.Name, "ValueMap", StringComparison.OrdinalIgnoreCase) == 0 && !flag3)
				{
					try
					{
						ValueMap.Clear();
						if (!isTypeInt(prop.Type) || qualifier.Value == null)
						{
							continue;
						}
						string[] array = (string[])qualifier.Value;
						for (int i = 0; i < array.Length; i++)
						{
							try
							{
								arrConvFuncName = ConvertToNumericValueAndAddToArray(prop.Type, array[i], ValueMap, out enumType);
							}
							catch (OverflowException)
							{
							}
						}
					}
					catch (FormatException)
					{
						flag3 = true;
						ValueMap.Clear();
					}
					catch (InvalidCastException)
					{
						ValueMap.Clear();
					}
				}
				else if (string.Compare(qualifier.Name, "Values", StringComparison.OrdinalIgnoreCase) == 0 && !flag3)
				{
					try
					{
						Values.Clear();
						if (!isTypeInt(prop.Type) || qualifier.Value == null)
						{
							continue;
						}
						ArrayList arrayList = new ArrayList(5);
						string[] array2 = (string[])qualifier.Value;
						for (int j = 0; j < array2.Length; j++)
						{
							if (array2[j].Length == 0)
							{
								Values.Clear();
								flag3 = true;
								break;
							}
							string value = ConvertValuesToName(array2[j]);
							arrayList.Add(value);
						}
						ResolveEnumNameValues(arrayList, ref Values);
					}
					catch (InvalidCastException)
					{
						Values.Clear();
					}
				}
				else if (string.Compare(qualifier.Name, "BitMap", StringComparison.OrdinalIgnoreCase) == 0 && !flag3)
				{
					try
					{
						BitMap.Clear();
						if (isTypeInt(prop.Type) && qualifier.Value != null)
						{
							string[] array3 = (string[])qualifier.Value;
							for (int k = 0; k < array3.Length; k++)
							{
								BitMap.Add(ConvertBitMapValueToInt32(array3[k]));
							}
						}
					}
					catch (FormatException)
					{
						BitMap.Clear();
						flag3 = true;
					}
					catch (InvalidCastException)
					{
						BitMap.Clear();
					}
				}
				else
				{
					if (string.Compare(qualifier.Name, "BitValues", StringComparison.OrdinalIgnoreCase) != 0 || flag3)
					{
						continue;
					}
					try
					{
						BitValues.Clear();
						if (!isTypeInt(prop.Type) || qualifier.Value == null)
						{
							continue;
						}
						ArrayList arrayList2 = new ArrayList(5);
						string[] array4 = (string[])qualifier.Value;
						for (int l = 0; l < array4.Length; l++)
						{
							if (array4[l].Length == 0)
							{
								BitValues.Clear();
								flag3 = true;
								break;
							}
							string value2 = ConvertValuesToName(array4[l]);
							arrayList2.Add(value2);
						}
						ResolveEnumNameValues(arrayList2, ref BitValues);
					}
					catch (InvalidCastException)
					{
						BitValues.Clear();
					}
				}
			}
			if ((!bDynamicClass && !flag) || (!bDynamicClass && flag && flag2) || (bDynamicClass && flag && flag2))
			{
				bWrite = true;
			}
			return result;
		}

		private bool GeneratePropertyHelperEnums(PropertyData prop, string strPropertyName, bool bNullable)
		{
			bool result = false;
			bool flag = false;
			string text = ResolveCollision(strPropertyName + "Values", bCheckthisFirst: true);
			if (Values.Count > 0 && (ValueMap.Count == 0 || ValueMap.Count == Values.Count))
			{
				if (ValueMap.Count == 0)
				{
					flag = true;
				}
				EnumObj = new CodeTypeDeclaration(text);
				if (prop.IsArray)
				{
					cmp.Type = new CodeTypeReference(text, 1);
				}
				else
				{
					cmp.Type = new CodeTypeReference(text);
				}
				EnumObj.IsEnum = true;
				EnumObj.TypeAttributes = TypeAttributes.Public;
				long num = 0L;
				for (int i = 0; i < Values.Count; i++)
				{
					cmf = new CodeMemberField();
					cmf.Name = Values[i].ToString();
					if (ValueMap.Count > 0)
					{
						cmf.InitExpression = new CodePrimitiveExpression(ValueMap[i]);
						long num2 = Convert.ToInt64(ValueMap[i], (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(ulong)));
						if (num2 > num)
						{
							num = num2;
						}
						if (!flag && Convert.ToInt64(ValueMap[i], (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(ulong))) == 0L)
						{
							flag = true;
						}
					}
					else
					{
						cmf.InitExpression = new CodePrimitiveExpression(i);
						if (i > num)
						{
							num = i;
						}
					}
					EnumObj.Members.Add(cmf);
				}
				if (bNullable && !flag)
				{
					cmf = new CodeMemberField();
					cmf.Name = "NULL_ENUM_VALUE";
					cmf.InitExpression = new CodePrimitiveExpression(0);
					EnumObj.Members.Add(cmf);
					prop.NullEnumValue = 0L;
				}
				else if (bNullable && flag)
				{
					cmf = new CodeMemberField();
					cmf.Name = "NULL_ENUM_VALUE";
					cmf.InitExpression = new CodePrimitiveExpression((int)(num + 1));
					EnumObj.Members.Add(cmf);
					prop.NullEnumValue = (int)(num + 1);
				}
				else if (!bNullable && !flag)
				{
					cmf = new CodeMemberField();
					cmf.Name = "INVALID_ENUM_VALUE";
					cmf.InitExpression = new CodePrimitiveExpression(0);
					EnumObj.Members.Add(cmf);
					prop.NullEnumValue = 0L;
				}
				cc.Members.Add(EnumObj);
				result = true;
			}
			Values.Clear();
			ValueMap.Clear();
			flag = false;
			if (BitValues.Count > 0 && (BitMap.Count == 0 || BitMap.Count == BitValues.Count))
			{
				if (BitMap.Count == 0)
				{
					flag = true;
				}
				EnumObj = new CodeTypeDeclaration(text);
				if (prop.IsArray)
				{
					cmp.Type = new CodeTypeReference(text, 1);
				}
				else
				{
					cmp.Type = new CodeTypeReference(text);
				}
				EnumObj.IsEnum = true;
				EnumObj.TypeAttributes = TypeAttributes.Public;
				int num3 = 1;
				long num4 = 0L;
				for (int j = 0; j < BitValues.Count; j++)
				{
					cmf = new CodeMemberField();
					cmf.Name = BitValues[j].ToString();
					if (BitMap.Count > 0)
					{
						cmf.InitExpression = new CodePrimitiveExpression(BitMap[j]);
						long num5 = Convert.ToInt64(BitMap[j], (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(ulong)));
						if (num5 > num4)
						{
							num4 = num5;
						}
					}
					else
					{
						cmf.InitExpression = new CodePrimitiveExpression(num3);
						if (num3 > num4)
						{
							num4 = num3;
						}
						num3 <<= 1;
					}
					if (!flag && Convert.ToInt64(BitMap[j], (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(ulong))) == 0L)
					{
						flag = true;
					}
					EnumObj.Members.Add(cmf);
				}
				if (bNullable && !flag)
				{
					cmf = new CodeMemberField();
					cmf.Name = "NULL_ENUM_VALUE";
					cmf.InitExpression = new CodePrimitiveExpression(0);
					EnumObj.Members.Add(cmf);
					prop.NullEnumValue = 0L;
				}
				else if (bNullable && flag)
				{
					cmf = new CodeMemberField();
					cmf.Name = "NULL_ENUM_VALUE";
					num4 = ((BitValues.Count <= 30) ? (num4 << 1) : (num4 + 1));
					cmf.InitExpression = new CodePrimitiveExpression((int)num4);
					EnumObj.Members.Add(cmf);
					prop.NullEnumValue = (int)num4;
				}
				else if (!bNullable && !flag)
				{
					cmf = new CodeMemberField();
					cmf.Name = "INVALID_ENUM_VALUE";
					cmf.InitExpression = new CodePrimitiveExpression(0);
					EnumObj.Members.Add(cmf);
					prop.NullEnumValue = 0L;
				}
				cc.Members.Add(EnumObj);
				result = true;
			}
			BitValues.Clear();
			BitMap.Clear();
			return result;
		}

		private void GenerateConstructPath()
		{
			cmm = new CodeMemberMethod();
			cmm.Name = PublicNamesUsed["ConstructPathFunction"].ToString();
			cmm.Attributes = (MemberAttributes)20483;
			cmm.ReturnType = new CodeTypeReference("System.String");
			for (int i = 0; i < arrKeys.Count; i++)
			{
				string baseType = ((CodeTypeReference)arrKeyType[i]).BaseType;
				cmm.Parameters.Add(new CodeParameterDeclarationExpression(baseType, "key" + arrKeys[i].ToString()));
			}
			string text = OriginalNamespace + ":" + OriginalClassName;
			if (bSingletonClass)
			{
				text += "=@";
				cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(text)));
			}
			else
			{
				string text2 = "strPath";
				cmm.Statements.Add(new CodeVariableDeclarationStatement("System.String", text2, new CodePrimitiveExpression(text)));
				for (int j = 0; j < arrKeys.Count; j++)
				{
					CodeMethodInvokeExpression right;
					if (((CodeTypeReference)arrKeyType[j]).BaseType == "System.String")
					{
						CodeMethodInvokeExpression ce = GenerateConcatStrings(new CodeVariableReferenceExpression("key" + arrKeys[j]), new CodePrimitiveExpression("\""));
						CodeMethodInvokeExpression ce2 = GenerateConcatStrings(new CodePrimitiveExpression("\""), ce);
						CodeMethodInvokeExpression ce3 = GenerateConcatStrings(new CodePrimitiveExpression((j == 0) ? ("." + arrKeys[j]?.ToString() + "=") : ("," + arrKeys[j]?.ToString() + "=")), ce2);
						right = GenerateConcatStrings(new CodeVariableReferenceExpression(text2), ce3);
					}
					else
					{
						cmie = new CodeMethodInvokeExpression();
						cmie.Method.TargetObject = new CodeCastExpression(new CodeTypeReference(((CodeTypeReference)arrKeyType[j]).BaseType + " "), new CodeVariableReferenceExpression("key" + arrKeys[j]));
						cmie.Method.MethodName = "ToString";
						CodeMethodInvokeExpression ce4 = GenerateConcatStrings(new CodePrimitiveExpression((j == 0) ? ("." + arrKeys[j]?.ToString() + "=") : ("," + arrKeys[j]?.ToString() + "=")), cmie);
						right = GenerateConcatStrings(new CodeVariableReferenceExpression(text2), ce4);
					}
					cmm.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text2), right));
				}
				cmm.Statements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(text2)));
			}
			cc.Members.Add(cmm);
		}

		private void GenerateDefaultConstructor()
		{
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["InitialObjectFunc"].ToString();
			codeMethodInvokeExpression.Method.TargetObject = new CodeThisReferenceExpression();
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
			if (bSingletonClass)
			{
				cmie = new CodeMethodInvokeExpression();
				cmie.Method.TargetObject = new CodeTypeReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
				cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
				coce = new CodeObjectCreateExpression();
				coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
				coce.Parameters.Add(cmie);
				codeMethodInvokeExpression.Parameters.Add(coce);
			}
			else
			{
				codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
			}
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
			cctor.Statements.Add(new CodeExpressionStatement(codeMethodInvokeExpression));
			cc.Members.Add(cctor);
			cctor.Comments.Add(new CodeCommentStatement(GetString("COMMENT_CONSTRUCTORS")));
		}

		private void GenerateConstructorWithKeys()
		{
			if (arrKeyType.Count > 0)
			{
				cctor = new CodeConstructor();
				cctor.Attributes = MemberAttributes.Public;
				CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
				codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["InitialObjectFunc"].ToString();
				codeMethodInvokeExpression.Method.TargetObject = new CodeThisReferenceExpression();
				for (int i = 0; i < arrKeys.Count; i++)
				{
					cpde = new CodeParameterDeclarationExpression();
					cpde.Type = new CodeTypeReference(((CodeTypeReference)arrKeyType[i]).BaseType);
					cpde.Name = "key" + arrKeys[i].ToString();
					cctor.Parameters.Add(cpde);
				}
				if (cctor.Parameters.Count == 1 && cctor.Parameters[0].Type.BaseType == new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()).BaseType)
				{
					cpde = new CodeParameterDeclarationExpression();
					cpde.Type = new CodeTypeReference("System.Object");
					cpde.Name = "dummyParam";
					cctor.Parameters.Add(cpde);
					cctor.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("dummyParam"), new CodePrimitiveExpression(null)));
				}
				codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
				cmie = new CodeMethodInvokeExpression();
				cmie.Method.TargetObject = new CodeTypeReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
				cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
				for (int j = 0; j < arrKeys.Count; j++)
				{
					cmie.Parameters.Add(new CodeVariableReferenceExpression("key" + arrKeys[j]));
				}
				coce = new CodeObjectCreateExpression();
				coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
				coce.Parameters.Add(cmie);
				codeMethodInvokeExpression.Parameters.Add(coce);
				codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
				cctor.Statements.Add(new CodeExpressionStatement(codeMethodInvokeExpression));
				cc.Members.Add(cctor);
			}
		}

		private void GenerateConstructorWithScopeKeys()
		{
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), PrivateNamesUsed["ScopeParam"].ToString()));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["InitialObjectFunc"].ToString();
			codeMethodInvokeExpression.Method.TargetObject = new CodeThisReferenceExpression();
			if (arrKeyType.Count > 0)
			{
				for (int i = 0; i < arrKeys.Count; i++)
				{
					cpde = new CodeParameterDeclarationExpression();
					cpde.Type = new CodeTypeReference(((CodeTypeReference)arrKeyType[i]).BaseType);
					cpde.Name = "key" + arrKeys[i].ToString();
					cctor.Parameters.Add(cpde);
				}
				if (cctor.Parameters.Count == 2 && cctor.Parameters[1].Type.BaseType == new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()).BaseType)
				{
					cpde = new CodeParameterDeclarationExpression();
					cpde.Type = new CodeTypeReference("System.Object");
					cpde.Name = "dummyParam";
					cctor.Parameters.Add(cpde);
					cctor.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("dummyParam"), new CodePrimitiveExpression(null)));
				}
				codeMethodInvokeExpression.Parameters.Add(new CodeCastExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString())));
				cmie = new CodeMethodInvokeExpression();
				cmie.Method.TargetObject = new CodeTypeReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
				cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
				for (int j = 0; j < arrKeys.Count; j++)
				{
					cmie.Parameters.Add(new CodeVariableReferenceExpression("key" + arrKeys[j]));
				}
				coce = new CodeObjectCreateExpression();
				coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
				coce.Parameters.Add(cmie);
				codeMethodInvokeExpression.Parameters.Add(coce);
				codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
				cctor.Statements.Add(new CodeExpressionStatement(codeMethodInvokeExpression));
				cc.Members.Add(cctor);
			}
		}

		private void GenerateConstructorWithPath()
		{
			string text = "path";
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cpde = new CodeParameterDeclarationExpression();
			cpde.Type = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			cpde.Name = text;
			cctor.Parameters.Add(cpde);
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["InitialObjectFunc"].ToString();
			codeMethodInvokeExpression.Method.TargetObject = new CodeThisReferenceExpression();
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
			cctor.Statements.Add(new CodeExpressionStatement(codeMethodInvokeExpression));
			cc.Members.Add(cctor);
		}

		private void GenerateConstructorWithPathOptions()
		{
			string text = "path";
			string text2 = "getOptions";
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()), text));
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()), text2));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["InitialObjectFunc"].ToString();
			codeMethodInvokeExpression.Method.TargetObject = new CodeThisReferenceExpression();
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text));
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text2));
			cctor.Statements.Add(new CodeExpressionStatement(codeMethodInvokeExpression));
			cc.Members.Add(cctor);
		}

		private void GenerateConstructorWithScopePath()
		{
			string text = "path";
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), PrivateNamesUsed["ScopeParam"].ToString()));
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()), text));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["InitialObjectFunc"].ToString();
			codeMethodInvokeExpression.Method.TargetObject = new CodeThisReferenceExpression();
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
			cctor.Statements.Add(new CodeExpressionStatement(codeMethodInvokeExpression));
			cc.Members.Add(cctor);
		}

		private void GenerateConstructorWithScope()
		{
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), PrivateNamesUsed["ScopeParam"].ToString()));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["InitialObjectFunc"].ToString();
			codeMethodInvokeExpression.Method.TargetObject = new CodeThisReferenceExpression();
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeTypeReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			coce.Parameters.Add(cmie);
			codeMethodInvokeExpression.Parameters.Add(coce);
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
			cctor.Statements.Add(new CodeExpressionStatement(codeMethodInvokeExpression));
			cc.Members.Add(cctor);
		}

		private void GenerateConstructorWithOptions()
		{
			string text = "getOptions";
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()), text));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["InitialObjectFunc"].ToString();
			codeMethodInvokeExpression.Method.TargetObject = new CodeThisReferenceExpression();
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(null));
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeTypeReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			coce.Parameters.Add(cmie);
			codeMethodInvokeExpression.Parameters.Add(coce);
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text));
			cctor.Statements.Add(new CodeExpressionStatement(codeMethodInvokeExpression));
			cc.Members.Add(cctor);
		}

		private void GenerateConstructorWithScopeOptions()
		{
			string text = "getOptions";
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), PrivateNamesUsed["ScopeParam"].ToString()));
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()), text));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["InitialObjectFunc"].ToString();
			codeMethodInvokeExpression.Method.TargetObject = new CodeThisReferenceExpression();
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeTypeReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			coce.Parameters.Add(cmie);
			codeMethodInvokeExpression.Parameters.Add(coce);
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text));
			cctor.Statements.Add(new CodeExpressionStatement(codeMethodInvokeExpression));
			cc.Members.Add(cctor);
		}

		private void GenerateConstructorWithScopePathOptions()
		{
			string text = "path";
			string text2 = "getOptions";
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), PrivateNamesUsed["ScopeParam"].ToString()));
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()), text));
			cctor.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()), text2));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["InitialObjectFunc"].ToString();
			codeMethodInvokeExpression.Method.TargetObject = new CodeThisReferenceExpression();
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text));
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text2));
			cctor.Statements.Add(new CodeExpressionStatement(codeMethodInvokeExpression));
			cc.Members.Add(cctor);
		}

		private void GenarateConstructorWithLateBound()
		{
			string text = "theObject";
			string propertyName = "SystemProperties";
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cpde = new CodeParameterDeclarationExpression();
			cpde.Type = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
			cpde.Name = text;
			cctor.Parameters.Add(cpde);
			InitPrivateMemberVariables(cctor);
			cis = new CodeConditionStatement();
			cpre = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), propertyName);
			cie = new CodeIndexerExpression(cpre, new CodePrimitiveExpression("__CLASS"));
			cpre = new CodePropertyReferenceExpression(cie, "Value");
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.MethodName = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = cmie;
			cboe.Right = new CodePrimitiveExpression(true);
			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			cis.Condition = cboe;
			cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()), new CodeVariableReferenceExpression(text)));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["SystemPropertiesClass"].ToString());
			coce.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()));
			cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["SystemPropertiesObject"].ToString()), coce));
			cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString()), new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString())));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
			coce.Parameters.Add(new CodePrimitiveExpression(GetString("CLASSNOT_FOUND_EXCEPT")));
			cis.FalseStatements.Add(new CodeThrowExceptionStatement(coce));
			cctor.Statements.Add(cis);
			cc.Members.Add(cctor);
		}

		private void GenarateConstructorWithLateBoundForEmbedded()
		{
			string text = "theObject";
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cpde = new CodeParameterDeclarationExpression();
			cpde.Type = new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString());
			cpde.Name = text;
			cctor.Parameters.Add(cpde);
			InitPrivateMemberVariables(cctor);
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.MethodName = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = cmie;
			cboe.Right = new CodePrimitiveExpression(true);
			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			cis = new CodeConditionStatement();
			cis.Condition = cboe;
			cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["EmbeddedObject"].ToString()), new CodeVariableReferenceExpression(text)));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["SystemPropertiesClass"].ToString());
			coce.Parameters.Add(new CodeVariableReferenceExpression(text));
			cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["SystemPropertiesObject"].ToString()), coce));
			cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString()), new CodeVariableReferenceExpression(PrivateNamesUsed["EmbeddedObject"].ToString())));
			cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString()), new CodePrimitiveExpression(true)));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
			coce.Parameters.Add(new CodePrimitiveExpression(GetString("CLASSNOT_FOUND_EXCEPT")));
			cis.FalseStatements.Add(new CodeThrowExceptionStatement(coce));
			cctor.Statements.Add(cis);
			cc.Members.Add(cctor);
		}

		private void GenerateInitializeObject()
		{
			string text = "path";
			string text2 = "getOptions";
			bool flag = true;
			try
			{
				classobj.Qualifiers["priveleges"].ToString();
			}
			catch (ManagementException ex)
			{
				if (ex.ErrorCode != ManagementStatus.NotFound)
				{
					throw;
				}
				flag = false;
			}
			CodeMemberMethod codeMemberMethod = new CodeMemberMethod();
			codeMemberMethod.Name = PrivateNamesUsed["InitialObjectFunc"].ToString();
			codeMemberMethod.Attributes = (MemberAttributes)20482;
			codeMemberMethod.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), PrivateNamesUsed["ScopeParam"].ToString()));
			codeMemberMethod.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()), text));
			codeMemberMethod.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()), text2));
			InitPrivateMemberVariables(codeMemberMethod);
			cis = new CodeConditionStatement();
			cis.Condition = new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(text), CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression(null));
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.MethodName = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
			cmie.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text2));
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = cmie;
			cboe.Right = new CodePrimitiveExpression(true);
			cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
			codeConditionStatement.Condition = cboe;
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
			coce.Parameters.Add(new CodePrimitiveExpression(GetString("CLASSNOT_FOUND_EXCEPT")));
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(coce));
			cis.TrueStatements.Add(codeConditionStatement);
			codeMemberMethod.Statements.Add(cis);
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
			coce.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text2));
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()), coce));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["SystemPropertiesClass"].ToString());
			coce.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()));
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["SystemPropertiesObject"].ToString()), coce));
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString()), new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString())));
			cc.Members.Add(codeMemberMethod);
			if (flag)
			{
				cpre = new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()), PublicNamesUsed["ScopeProperty"].ToString()), "Options"), "EnablePrivileges");
				cctor.Statements.Add(new CodeAssignStatement(cpre, new CodePrimitiveExpression(true)));
			}
		}

		private void GenerateMethods()
		{
			string text = "inParams";
			string text2 = "outParams";
			string text3 = "classObj";
			bool flag = false;
			bool flag2 = false;
			CodePropertyReferenceExpression codePropertyReferenceExpression = null;
			CimType cimType = CimType.SInt8;
			CodeTypeReference codeTypeReference = null;
			bool bArray = false;
			bool flag3 = false;
			ArrayList arrayList = new ArrayList(5);
			ArrayList arrayList2 = new ArrayList(5);
			ArrayList arrayList3 = new ArrayList(5);
			for (int i = 0; i < PublicMethods.Count; i++)
			{
				flag = false;
				MethodData methodData = classobj.Methods[PublicMethods.GetKey(i).ToString()];
				string variableName = PrivateNamesUsed["LateBoundObject"].ToString();
				if (methodData.OutParameters != null && methodData.OutParameters.Properties != null)
				{
					foreach (PropertyData property in methodData.OutParameters.Properties)
					{
						arrayList.Add(property.Name);
					}
				}
				cmm = new CodeMemberMethod();
				cmm.Attributes = (MemberAttributes)24578;
				cmm.Name = PublicMethods[methodData.Name].ToString();
				foreach (QualifierData qualifier in methodData.Qualifiers)
				{
					if (string.Compare(qualifier.Name, "static", StringComparison.OrdinalIgnoreCase) == 0)
					{
						cmm.Attributes |= MemberAttributes.Static;
						flag = true;
						break;
					}
					if (string.Compare(qualifier.Name, "privileges", StringComparison.OrdinalIgnoreCase) == 0)
					{
						flag2 = true;
					}
				}
				cis = new CodeConditionStatement();
				cboe = new CodeBinaryOperatorExpression();
				if (flag)
				{
					cmm.Statements.Add(new CodeVariableDeclarationStatement("System.Boolean", "IsMethodStatic", new CodePrimitiveExpression(flag)));
					cboe.Left = new CodeVariableReferenceExpression("IsMethodStatic");
					cboe.Right = new CodePrimitiveExpression(true);
				}
				else
				{
					cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
					cboe.Right = new CodePrimitiveExpression(false);
				}
				cboe.Operator = CodeBinaryOperatorType.ValueEquality;
				cis.Condition = cboe;
				bool flag4 = true;
				cis.TrueStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString()), text, new CodePrimitiveExpression(null)));
				if (flag)
				{
					string text4 = "mgmtPath";
					CodeObjectCreateExpression codeObjectCreateExpression = new CodeObjectCreateExpression();
					codeObjectCreateExpression.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
					codeObjectCreateExpression.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["CreationClassName"].ToString()));
					cis.TrueStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()), text4, codeObjectCreateExpression));
					CodeObjectCreateExpression codeObjectCreateExpression2 = new CodeObjectCreateExpression();
					codeObjectCreateExpression2.CreateType = new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString());
					codeObjectCreateExpression2.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString()));
					codeObjectCreateExpression2.Parameters.Add(new CodeVariableReferenceExpression(text4));
					codeObjectCreateExpression2.Parameters.Add(new CodePrimitiveExpression(null));
					coce = new CodeObjectCreateExpression();
					coce.CreateType = new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString());
					coce.Parameters.Add(codeObjectCreateExpression2);
					cis.TrueStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString()), text3, codeObjectCreateExpression2));
					variableName = text3;
				}
				if (flag2)
				{
					codePropertyReferenceExpression = new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(flag ? text3 : PrivateNamesUsed["LateBoundObject"].ToString()), PublicNamesUsed["ScopeProperty"].ToString()), "Options"), "EnablePrivileges");
					cis.TrueStatements.Add(new CodeVariableDeclarationStatement("System.Boolean", PrivateNamesUsed["Privileges"].ToString(), codePropertyReferenceExpression));
					cis.TrueStatements.Add(new CodeAssignStatement(codePropertyReferenceExpression, new CodePrimitiveExpression(true)));
				}
				if (methodData.InParameters != null && methodData.InParameters.Properties != null)
				{
					foreach (PropertyData property2 in methodData.InParameters.Properties)
					{
						flag3 = false;
						if (flag4)
						{
							cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(variableName), "GetMethodParameters", new CodePrimitiveExpression(methodData.Name));
							cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), cmie));
							flag4 = false;
						}
						cpde = new CodeParameterDeclarationExpression();
						cpde.Name = property2.Name;
						cpde.Type = ConvertCIMType(property2.Type, property2.IsArray);
						cpde.Direction = FieldDirection.In;
						if (property2.Type == CimType.DateTime)
						{
							CodeTypeReference codeType = cpde.Type;
							flag3 = GetDateTimeType(property2, ref codeType);
							cpde.Type = codeType;
						}
						for (int j = 0; j < arrayList.Count; j++)
						{
							if (string.Compare(property2.Name, arrayList[j].ToString(), StringComparison.OrdinalIgnoreCase) == 0)
							{
								cpde.Direction = FieldDirection.Ref;
								arrayList2.Add(property2.Name);
								arrayList3.Add(cpde.Type);
							}
						}
						cmm.Parameters.Add(cpde);
						cie = new CodeIndexerExpression(new CodeVariableReferenceExpression(text), new CodePrimitiveExpression(property2.Name));
						if (property2.Type == CimType.Reference)
						{
							AddPropertySet(cie, property2.IsArray, cis.TrueStatements, PublicNamesUsed["PathClass"].ToString(), new CodeVariableReferenceExpression(cpde.Name));
						}
						else if (property2.Type == CimType.DateTime)
						{
							if (flag3)
							{
								AddPropertySet(cie, property2.IsArray, cis.TrueStatements, "System.TimeSpan", new CodeVariableReferenceExpression(cpde.Name));
							}
							else
							{
								AddPropertySet(cie, property2.IsArray, cis.TrueStatements, "System.DateTime", new CodeVariableReferenceExpression(cpde.Name));
							}
						}
						else if (cpde.Type.ArrayRank == 0)
						{
							cis.TrueStatements.Add(new CodeAssignStatement(cie, new CodeCastExpression(new CodeTypeReference(cpde.Type.BaseType + " "), new CodeVariableReferenceExpression(cpde.Name))));
						}
						else
						{
							cis.TrueStatements.Add(new CodeAssignStatement(cie, new CodeCastExpression(cpde.Type, new CodeVariableReferenceExpression(cpde.Name))));
						}
					}
				}
				arrayList.Clear();
				bool flag5 = false;
				flag4 = true;
				bool flag6 = false;
				CodeMethodInvokeExpression codeMethodInvokeExpression = null;
				if (methodData.OutParameters != null && methodData.OutParameters.Properties != null)
				{
					foreach (PropertyData property3 in methodData.OutParameters.Properties)
					{
						flag3 = false;
						if (flag4)
						{
							cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(variableName), "InvokeMethod");
							cmie.Parameters.Add(new CodePrimitiveExpression(methodData.Name));
							cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
							cmie.Parameters.Add(new CodePrimitiveExpression(null));
							cis.TrueStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString()), text2, cmie));
							flag4 = false;
							flag6 = true;
						}
						bool flag7 = false;
						for (int k = 0; k < arrayList2.Count; k++)
						{
							if (string.Compare(property3.Name, arrayList2[k].ToString(), StringComparison.OrdinalIgnoreCase) == 0)
							{
								flag7 = true;
							}
						}
						if (flag7)
						{
							continue;
						}
						if (string.Compare(property3.Name, "ReturnValue", StringComparison.OrdinalIgnoreCase) == 0)
						{
							cmm.ReturnType = ConvertCIMType(property3.Type, property3.IsArray);
							flag5 = true;
							cimType = property3.Type;
							if (property3.Type == CimType.DateTime)
							{
								CodeTypeReference codeType2 = cmm.ReturnType;
								bool dateTimeType = GetDateTimeType(property3, ref codeType2);
								cmm.ReturnType = codeType2;
							}
							codeTypeReference = cmm.ReturnType;
							bArray = property3.IsArray;
							continue;
						}
						cpde = new CodeParameterDeclarationExpression();
						cpde.Name = property3.Name;
						cpde.Type = ConvertCIMType(property3.Type, property3.IsArray);
						cpde.Direction = FieldDirection.Out;
						cmm.Parameters.Add(cpde);
						if (property3.Type == CimType.DateTime)
						{
							CodeTypeReference codeType3 = cpde.Type;
							flag3 = GetDateTimeType(property3, ref codeType3);
							cpde.Type = codeType3;
						}
						cpre = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Properties");
						cie = new CodeIndexerExpression(cpre, new CodePrimitiveExpression(property3.Name));
						if (property3.Type == CimType.Reference)
						{
							GenerateCodeForRefAndDateTimeTypes(cie, property3.IsArray, cis.TrueStatements, PublicNamesUsed["PathClass"].ToString(), new CodeVariableReferenceExpression(property3.Name), bIsValueProprequired: true);
						}
						else if (property3.Type == CimType.DateTime)
						{
							if (flag3)
							{
								GenerateCodeForRefAndDateTimeTypes(cie, property3.IsArray, cis.TrueStatements, "System.TimeSpan", new CodeVariableReferenceExpression(property3.Name), bIsValueProprequired: true);
							}
							else
							{
								GenerateCodeForRefAndDateTimeTypes(cie, property3.IsArray, cis.TrueStatements, "System.DateTime", new CodeVariableReferenceExpression(property3.Name), bIsValueProprequired: true);
							}
						}
						else if (property3.IsArray || property3.Type == CimType.Object)
						{
							cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(property3.Name), new CodeCastExpression(ConvertCIMType(property3.Type, property3.IsArray), new CodePropertyReferenceExpression(cie, "Value"))));
						}
						else
						{
							codeMethodInvokeExpression = new CodeMethodInvokeExpression();
							codeMethodInvokeExpression.Parameters.Add(new CodePropertyReferenceExpression(cie, "Value"));
							codeMethodInvokeExpression.Method.MethodName = GetConversionFunction(property3.Type);
							codeMethodInvokeExpression.Method.TargetObject = new CodeTypeReferenceExpression("System.Convert");
							cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(property3.Name), codeMethodInvokeExpression));
						}
						if (property3.Type == CimType.DateTime && !property3.IsArray)
						{
							if (flag3)
							{
								coce = new CodeObjectCreateExpression();
								coce.CreateType = new CodeTypeReference("System.TimeSpan");
								coce.Parameters.Add(new CodePrimitiveExpression(0));
								coce.Parameters.Add(new CodePrimitiveExpression(0));
								coce.Parameters.Add(new CodePrimitiveExpression(0));
								coce.Parameters.Add(new CodePrimitiveExpression(0));
								coce.Parameters.Add(new CodePrimitiveExpression(0));
								cis.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(property3.Name), coce));
							}
							else
							{
								cis.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(property3.Name), new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.DateTime"), "MinValue")));
							}
						}
						else if (IsPropertyValueType(property3.Type) && !property3.IsArray)
						{
							codeMethodInvokeExpression = new CodeMethodInvokeExpression();
							codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(0));
							codeMethodInvokeExpression.Method.MethodName = GetConversionFunction(property3.Type);
							codeMethodInvokeExpression.Method.TargetObject = new CodeTypeReferenceExpression("System.Convert");
							cis.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(property3.Name), codeMethodInvokeExpression));
						}
						else
						{
							cis.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(property3.Name), new CodePrimitiveExpression(null)));
						}
					}
				}
				if (!flag6)
				{
					cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(variableName), "InvokeMethod");
					cmie.Parameters.Add(new CodePrimitiveExpression(methodData.Name));
					cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
					cmie.Parameters.Add(new CodePrimitiveExpression(null));
					cmis = new CodeExpressionStatement(cmie);
					cis.TrueStatements.Add(cmis);
				}
				for (int l = 0; l < arrayList2.Count; l++)
				{
					cpre = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Properties");
					cie = new CodeIndexerExpression(cpre, new CodePrimitiveExpression(arrayList2[l].ToString()));
					cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(arrayList2[l].ToString()), new CodeCastExpression((CodeTypeReference)arrayList3[l], new CodePropertyReferenceExpression(cie, "Value"))));
				}
				arrayList2.Clear();
				if (flag2)
				{
					cis.TrueStatements.Add(new CodeAssignStatement(codePropertyReferenceExpression, new CodeVariableReferenceExpression(PrivateNamesUsed["Privileges"].ToString())));
				}
				if (flag5)
				{
					CodeVariableDeclarationStatement value = new CodeVariableDeclarationStatement(codeTypeReference, "retVar");
					cpre = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Properties");
					cie = new CodeIndexerExpression(cpre, new CodePrimitiveExpression("ReturnValue"));
					if (codeTypeReference.BaseType == new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()).BaseType)
					{
						cmm.Statements.Add(value);
						cmm.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("retVar"), new CodePrimitiveExpression(null)));
						GenerateCodeForRefAndDateTimeTypes(cie, bArray, cis.TrueStatements, PublicNamesUsed["PathClass"].ToString(), new CodeVariableReferenceExpression("retVar"), bIsValueProprequired: true);
						cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("retVar")));
						cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
					}
					else if (codeTypeReference.BaseType == "System.DateTime")
					{
						cmm.Statements.Add(value);
						cmm.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("retVar"), new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.DateTime"), "MinValue")));
						GenerateCodeForRefAndDateTimeTypes(cie, bArray, cis.TrueStatements, "System.DateTime", new CodeVariableReferenceExpression("retVar"), bIsValueProprequired: true);
						cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("retVar")));
						cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("retVar")));
					}
					else if (codeTypeReference.BaseType == "System.TimeSpan")
					{
						cmm.Statements.Add(value);
						coce = new CodeObjectCreateExpression();
						coce.CreateType = new CodeTypeReference("System.TimeSpan");
						coce.Parameters.Add(new CodePrimitiveExpression(0));
						coce.Parameters.Add(new CodePrimitiveExpression(0));
						coce.Parameters.Add(new CodePrimitiveExpression(0));
						coce.Parameters.Add(new CodePrimitiveExpression(0));
						coce.Parameters.Add(new CodePrimitiveExpression(0));
						cmm.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("retVar"), coce));
						GenerateCodeForRefAndDateTimeTypes(cie, bArray, cis.TrueStatements, "System.TimeSpan", new CodeVariableReferenceExpression("retVar"), bIsValueProprequired: true);
						cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("retVar")));
						cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("retVar")));
					}
					else if (codeTypeReference.ArrayRank == 0 && codeTypeReference.BaseType != new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString()).BaseType)
					{
						cmie = new CodeMethodInvokeExpression();
						cmie.Parameters.Add(new CodePropertyReferenceExpression(cie, "Value"));
						cmie.Method.MethodName = GetConversionFunction(cimType);
						cmie.Method.TargetObject = new CodeTypeReferenceExpression("System.Convert");
						cis.TrueStatements.Add(new CodeMethodReturnStatement(cmie));
						cmie = new CodeMethodInvokeExpression();
						cmie.Parameters.Add(new CodePrimitiveExpression(0));
						cmie.Method.MethodName = GetConversionFunction(cimType);
						cmie.Method.TargetObject = new CodeTypeReferenceExpression("System.Convert");
						cis.FalseStatements.Add(new CodeMethodReturnStatement(cmie));
					}
					else
					{
						cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodeCastExpression(codeTypeReference, new CodePropertyReferenceExpression(cie, "Value"))));
						cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
					}
				}
				cmm.Statements.Add(cis);
				cc.Members.Add(cmm);
			}
		}

		private void GenerateGetInstancesWithNoParameters()
		{
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24579;
			cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
			cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.MethodName = PublicNamesUsed["FilterFunction"].ToString();
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			cc.Members.Add(cmm);
			cmm.Comments.Add(new CodeCommentStatement(GetString("COMMENT_GETINSTANCES")));
		}

		private void GenerateGetInstancesWithCondition()
		{
			string text = "condition";
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24579;
			cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
			cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
			cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String", text));
			cmie = new CodeMethodInvokeExpression(null, PublicNamesUsed["FilterFunction"].ToString());
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			cc.Members.Add(cmm);
		}

		private void GenerateGetInstancesWithProperties()
		{
			string text = "selectedProperties";
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24579;
			cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
			cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
			cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String []", text));
			cmie = new CodeMethodInvokeExpression(null, PublicNamesUsed["FilterFunction"].ToString());
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			cc.Members.Add(cmm);
		}

		private void GenerateGetInstancesWithWhereProperties()
		{
			string text = "selectedProperties";
			string text2 = "condition";
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24579;
			cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
			cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
			cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String", text2));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String []", text));
			cmie = new CodeMethodInvokeExpression(null, PublicNamesUsed["FilterFunction"].ToString());
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text2));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			cc.Members.Add(cmm);
		}

		private void GenerateGetInstancesWithScope()
		{
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24579;
			cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
			cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), PrivateNamesUsed["ScopeParam"].ToString()));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["QueryOptionsClass"].ToString()), PrivateNamesUsed["EnumParam"].ToString()));
			string text = "clsObject";
			string text2 = "pathObj";
			cis = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString());
			cboe.Right = new CodePrimitiveExpression(null);
			cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
			cis.Condition = cboe;
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString());
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(null);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityEquality;
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString());
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()), coce));
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()), "Path"), "NamespacePath"), new CodePrimitiveExpression(classobj.Scope.Path.NamespacePath)));
			codeConditionStatement.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()), new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString())));
			cis.TrueStatements.Add(codeConditionStatement);
			cmm.Statements.Add(cis);
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			cmm.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()), text2, coce));
			cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "ClassName"), new CodePrimitiveExpression(OriginalClassName)));
			cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "NamespacePath"), new CodePrimitiveExpression(classobj.Scope.Path.NamespacePath)));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString());
			coce.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text2));
			coce.Parameters.Add(new CodePrimitiveExpression(null));
			cmm.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString()), text, coce));
			cis = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString());
			cboe.Right = new CodePrimitiveExpression(null);
			cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
			cis.Condition = cboe;
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["QueryOptionsClass"].ToString());
			cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString()), coce));
			cis.TrueStatements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString()), "EnsureLocatable"), new CodePrimitiveExpression(true)));
			cmm.Statements.Add(cis);
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
			cmie = new CodeMethodInvokeExpression();
			cmie.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text), "GetInstances");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString()));
			coce.Parameters.Add(cmie);
			cmm.Statements.Add(new CodeMethodReturnStatement(coce));
			cc.Members.Add(cmm);
		}

		private void GenerateGetInstancesWithScopeCondition()
		{
			string text = "condition";
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24579;
			cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
			cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), PrivateNamesUsed["ScopeParam"].ToString()));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference("System.String"), text));
			cmie = new CodeMethodInvokeExpression(null, PublicNamesUsed["FilterFunction"].ToString());
			cmie.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			cc.Members.Add(cmm);
		}

		private void GenerateGetInstancesWithScopeProperties()
		{
			string text = "selectedProperties";
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24579;
			cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
			cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(), PrivateNamesUsed["ScopeParam"].ToString()));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String []", text));
			cmie = new CodeMethodInvokeExpression(null, PublicNamesUsed["FilterFunction"].ToString());
			cmie.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
			cmie.Parameters.Add(new CodePrimitiveExpression(null));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			cc.Members.Add(cmm);
		}

		private void GenerateGetInstancesWithScopeWhereProperties()
		{
			string text = "condition";
			string text2 = "selectedProperties";
			string text3 = "ObjectSearcher";
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24579;
			cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
			cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), PrivateNamesUsed["ScopeParam"].ToString()));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String", text));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String []", text2));
			cis = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString());
			cboe.Right = new CodePrimitiveExpression(null);
			cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
			cis.Condition = cboe;
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString());
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(null);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityEquality;
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString());
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()), coce));
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()), "Path"), "NamespacePath"), new CodePrimitiveExpression(classobj.Scope.Path.NamespacePath)));
			codeConditionStatement.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()), new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString())));
			cis.TrueStatements.Add(codeConditionStatement);
			cmm.Statements.Add(cis);
			CodeObjectCreateExpression codeObjectCreateExpression = new CodeObjectCreateExpression();
			codeObjectCreateExpression.CreateType = new CodeTypeReference(PublicNamesUsed["QueryClass"].ToString());
			codeObjectCreateExpression.Parameters.Add(new CodePrimitiveExpression(OriginalClassName));
			codeObjectCreateExpression.Parameters.Add(new CodeVariableReferenceExpression(text));
			codeObjectCreateExpression.Parameters.Add(new CodeVariableReferenceExpression(text2));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["ObjectSearcherClass"].ToString());
			coce.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
			coce.Parameters.Add(codeObjectCreateExpression);
			cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["ObjectSearcherClass"].ToString(), text3, coce));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["QueryOptionsClass"].ToString());
			cmm.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference(PublicNamesUsed["QueryOptionsClass"].ToString()), PrivateNamesUsed["EnumParam"].ToString(), coce));
			cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString()), "EnsureLocatable"), new CodePrimitiveExpression(true)));
			cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text3), "Options"), new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString())));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
			coce.Parameters.Add(new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text3), "Get"));
			cmm.Statements.Add(new CodeMethodReturnStatement(coce));
			cc.Members.Add(cmm);
		}

		private void GeneratePrivateMember(string memberName, string MemberType, string Comment)
		{
			GeneratePrivateMember(memberName, MemberType, null, isStatic: false, Comment);
		}

		private void GeneratePrivateMember(string memberName, string MemberType, CodeExpression initExpression, bool isStatic, string Comment)
		{
			cf = new CodeMemberField();
			cf.Name = memberName;
			cf.Attributes = (MemberAttributes)20482;
			if (isStatic)
			{
				cf.Attributes |= MemberAttributes.Static;
			}
			cf.Type = new CodeTypeReference(MemberType);
			if (initExpression != null && isStatic)
			{
				cf.InitExpression = initExpression;
			}
			cc.Members.Add(cf);
			if (Comment != null && Comment.Length != 0)
			{
				cf.Comments.Add(new CodeCommentStatement(Comment));
			}
		}

		private CodeTypeDeclaration GenerateTypeConverterClass()
		{
			string type = "System.ComponentModel.ITypeDescriptorContext";
			string text = "context";
			string text2 = "destinationType";
			string text3 = "value";
			string type2 = "System.Globalization.CultureInfo";
			string text4 = "culture";
			string type3 = "System.Collections.IDictionary";
			string text5 = "dictionary";
			string typeName = "PropertyDescriptorCollection";
			string text6 = "attributeVar";
			string text7 = "inBaseType";
			string text8 = "baseConverter";
			string text9 = "baseType";
			string type4 = "TypeDescriptor";
			string text10 = "srcType";
			CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration(PrivateNamesUsed["ConverterClass"].ToString());
			codeTypeDeclaration.BaseTypes.Add(PublicNamesUsed["TypeConverter"].ToString());
			cf = new CodeMemberField();
			cf.Name = text8;
			cf.Attributes = (MemberAttributes)20482;
			cf.Type = new CodeTypeReference(PublicNamesUsed["TypeConverter"].ToString());
			codeTypeDeclaration.Members.Add(cf);
			cf = new CodeMemberField();
			cf.Name = text9;
			cf.Attributes = (MemberAttributes)20482;
			cf.Type = new CodeTypeReference(PublicNamesUsed["Type"].ToString());
			codeTypeDeclaration.Members.Add(cf);
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cpde = new CodeParameterDeclarationExpression();
			cpde.Name = text7;
			cpde.Type = new CodeTypeReference("System.Type");
			cctor.Parameters.Add(cpde);
			cmie = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(type4), "GetConverter");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text7));
			cctor.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text8), cmie));
			cctor.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text9), new CodeVariableReferenceExpression(text7)));
			codeTypeDeclaration.Members.Add(cctor);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24836;
			cmm.Name = "CanConvertFrom";
			cmm.ReturnType = new CodeTypeReference("System.Boolean");
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type, text));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.Type", text10));
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text8), "CanConvertFrom");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text10));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			codeTypeDeclaration.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24836;
			cmm.Name = "CanConvertTo";
			cmm.ReturnType = new CodeTypeReference("System.Boolean");
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type, text));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.Type", text2));
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text8), "CanConvertTo");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text2));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			codeTypeDeclaration.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24836;
			cmm.Name = "ConvertFrom";
			cmm.ReturnType = new CodeTypeReference("System.Object");
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type, text));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type2, text4));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference("System.Object"), text3));
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text8), "ConvertFrom");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text4));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text3));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			codeTypeDeclaration.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24836;
			cmm.ReturnType = new CodeTypeReference("System.Object");
			cmm.Name = "CreateInstance";
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type, text));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type3, text5));
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text8), "CreateInstance");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text5));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			codeTypeDeclaration.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24836;
			cmm.Name = "GetCreateInstanceSupported";
			cmm.ReturnType = new CodeTypeReference("System.Boolean");
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type, text));
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text8), "GetCreateInstanceSupported");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			codeTypeDeclaration.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24836;
			cmm.Name = "GetProperties";
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type, text));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference("System.Object"), text3));
			CodeTypeReference type5 = new CodeTypeReference(new CodeTypeReference("System.Attribute"), 1);
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type5, text6));
			cmm.ReturnType = new CodeTypeReference(typeName);
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text8), "GetProperties");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text3));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text6));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			codeTypeDeclaration.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24836;
			cmm.Name = "GetPropertiesSupported";
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type, text));
			cmm.ReturnType = new CodeTypeReference("System.Boolean");
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text8), "GetPropertiesSupported");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			codeTypeDeclaration.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24836;
			cmm.Name = "GetStandardValues";
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type, text));
			cmm.ReturnType = new CodeTypeReference("System.ComponentModel.TypeConverter.StandardValuesCollection");
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text8), "GetStandardValues");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			codeTypeDeclaration.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24836;
			cmm.Name = "GetStandardValuesExclusive";
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type, text));
			cmm.ReturnType = new CodeTypeReference("System.Boolean");
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text8), "GetStandardValuesExclusive");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			codeTypeDeclaration.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24836;
			cmm.Name = "GetStandardValuesSupported";
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type, text));
			cmm.ReturnType = new CodeTypeReference("System.Boolean");
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text8), "GetStandardValuesSupported");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			codeTypeDeclaration.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24836;
			cmm.Name = "ConvertTo";
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type, text));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(type2, text4));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference("System.Object"), text3));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.Type", text2));
			cmm.ReturnType = new CodeTypeReference("System.Object");
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text8), "ConvertTo");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text4));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text3));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text2));
			CodeMethodReturnStatement value = new CodeMethodReturnStatement(cmie);
			cis = new CodeConditionStatement();
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text9), "BaseType");
			codeBinaryOperatorExpression.Right = new CodeTypeOfExpression(typeof(Enum));
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityEquality;
			cis.Condition = codeBinaryOperatorExpression;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression("value"), "GetType");
			codeBinaryOperatorExpression2.Right = new CodeVariableReferenceExpression("destinationType");
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.IdentityEquality;
			cis.TrueStatements.Add(new CodeConditionStatement(codeBinaryOperatorExpression2, new CodeMethodReturnStatement(new CodeVariableReferenceExpression("value"))));
			CodeBinaryOperatorExpression left = new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression("value"), CodeBinaryOperatorType.IdentityEquality, new CodePrimitiveExpression(null));
			CodeBinaryOperatorExpression right = new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(text), CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression(null));
			CodeBinaryOperatorExpression codeBinaryOperatorExpression3 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression3.Left = left;
			codeBinaryOperatorExpression3.Right = right;
			codeBinaryOperatorExpression3.Operator = CodeBinaryOperatorType.BooleanAnd;
			cmie = new CodeMethodInvokeExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "PropertyDescriptor"), "ShouldSerializeValue");
			cmie.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "Instance"));
			CodeBinaryOperatorExpression right2 = new CodeBinaryOperatorExpression(cmie, CodeBinaryOperatorType.ValueEquality, new CodePrimitiveExpression(false));
			CodeBinaryOperatorExpression codeBinaryOperatorExpression4 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression4.Left = codeBinaryOperatorExpression3;
			codeBinaryOperatorExpression4.Right = right2;
			codeBinaryOperatorExpression4.Operator = CodeBinaryOperatorType.BooleanAnd;
			cis.TrueStatements.Add(new CodeConditionStatement(codeBinaryOperatorExpression4, new CodeMethodReturnStatement(new CodeSnippetExpression(" \"NULL_ENUM_VALUE\" "))));
			cis.TrueStatements.Add(value);
			cmm.Statements.Add(cis);
			cis = new CodeConditionStatement();
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(text9);
			codeBinaryOperatorExpression.Right = new CodeTypeOfExpression(PublicNamesUsed["Boolean"].ToString());
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityEquality;
			codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text9), "BaseType");
			codeBinaryOperatorExpression2.Right = new CodeTypeOfExpression(PublicNamesUsed["ValueType"].ToString());
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.IdentityEquality;
			left = new CodeBinaryOperatorExpression();
			left.Left = codeBinaryOperatorExpression;
			left.Right = codeBinaryOperatorExpression2;
			left.Operator = CodeBinaryOperatorType.BooleanAnd;
			cis.Condition = left;
			left = new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression("value"), CodeBinaryOperatorType.IdentityEquality, new CodePrimitiveExpression(null));
			right = new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(text), CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression(null));
			codeBinaryOperatorExpression3 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression3.Left = left;
			codeBinaryOperatorExpression3.Right = right;
			codeBinaryOperatorExpression3.Operator = CodeBinaryOperatorType.BooleanAnd;
			cmie = new CodeMethodInvokeExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "PropertyDescriptor"), "ShouldSerializeValue");
			cmie.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "Instance"));
			right2 = new CodeBinaryOperatorExpression(cmie, CodeBinaryOperatorType.ValueEquality, new CodePrimitiveExpression(false));
			codeBinaryOperatorExpression4 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression4.Left = codeBinaryOperatorExpression3;
			codeBinaryOperatorExpression4.Right = right2;
			codeBinaryOperatorExpression4.Operator = CodeBinaryOperatorType.BooleanAnd;
			cis.TrueStatements.Add(new CodeConditionStatement(codeBinaryOperatorExpression4, new CodeMethodReturnStatement(new CodePrimitiveExpression(""))));
			cis.TrueStatements.Add(value);
			cmm.Statements.Add(cis);
			cis = new CodeConditionStatement();
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(text), CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression(null));
			cmie = new CodeMethodInvokeExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "PropertyDescriptor"), "ShouldSerializeValue");
			cmie.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "Instance"));
			codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression(cmie, CodeBinaryOperatorType.ValueEquality, new CodePrimitiveExpression(false));
			left = new CodeBinaryOperatorExpression();
			left.Left = codeBinaryOperatorExpression;
			left.Right = codeBinaryOperatorExpression2;
			left.Operator = CodeBinaryOperatorType.BooleanAnd;
			cis.Condition = left;
			cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression("")));
			cmm.Statements.Add(cis);
			cmm.Statements.Add(value);
			codeTypeDeclaration.Members.Add(cmm);
			codeTypeDeclaration.Comments.Add(new CodeCommentStatement(GetString("COMMENT_PROPTYPECONVERTER")));
			return codeTypeDeclaration;
		}

		private void GenerateCollectionClass()
		{
			string typeName = "ManagementObjectCollection";
			string text = "privColObj";
			string text2 = "objCollection";
			ccc = new CodeTypeDeclaration(PrivateNamesUsed["CollectionClass"].ToString());
			ccc.BaseTypes.Add("System.Object");
			ccc.BaseTypes.Add("ICollection");
			ccc.TypeAttributes = TypeAttributes.NestedPublic;
			cf = new CodeMemberField();
			cf.Name = text;
			cf.Attributes = (MemberAttributes)20482;
			cf.Type = new CodeTypeReference(typeName);
			ccc.Members.Add(cf);
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cpde = new CodeParameterDeclarationExpression();
			cpde.Name = text2;
			cpde.Type = new CodeTypeReference(typeName);
			cctor.Parameters.Add(cpde);
			cctor.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), new CodeVariableReferenceExpression(text2)));
			ccc.Members.Add(cctor);
			cmp = new CodeMemberProperty();
			cmp.Type = new CodeTypeReference("System.Int32");
			cmp.Attributes = (MemberAttributes)24582;
			cmp.Name = "Count";
			cmp.ImplementationTypes.Add("System.Collections.ICollection");
			cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "Count")));
			ccc.Members.Add(cmp);
			cmp = new CodeMemberProperty();
			cmp.Type = new CodeTypeReference("System.Boolean");
			cmp.Attributes = (MemberAttributes)24582;
			cmp.Name = "IsSynchronized";
			cmp.ImplementationTypes.Add("System.Collections.ICollection");
			cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "IsSynchronized")));
			ccc.Members.Add(cmp);
			cmp = new CodeMemberProperty();
			cmp.Type = new CodeTypeReference("System.Object");
			cmp.Attributes = (MemberAttributes)24582;
			cmp.Name = "SyncRoot";
			cmp.ImplementationTypes.Add("System.Collections.ICollection");
			cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeThisReferenceExpression()));
			ccc.Members.Add(cmp);
			string text3 = "array";
			string text4 = "index";
			string text5 = "nCtr";
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24582;
			cmm.Name = "CopyTo";
			cmm.ImplementationTypes.Add("System.Collections.ICollection");
			cpde = new CodeParameterDeclarationExpression();
			cpde.Name = text3;
			cpde.Type = new CodeTypeReference("System.Array");
			cmm.Parameters.Add(cpde);
			cpde = new CodeParameterDeclarationExpression();
			cpde.Name = text4;
			cpde.Type = new CodeTypeReference("System.Int32");
			cmm.Parameters.Add(cpde);
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text), "CopyTo");
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text3));
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text4));
			cmm.Statements.Add(new CodeExpressionStatement(cmie));
			cmm.Statements.Add(new CodeVariableDeclarationStatement("System.Int32", text5));
			cfls = new CodeIterationStatement();
			cfls.InitStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(text5), new CodePrimitiveExpression(0));
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(text5);
			cboe.Operator = CodeBinaryOperatorType.LessThan;
			cboe.Right = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text3), "Length");
			cfls.TestExpression = cboe;
			cfls.IncrementStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(text5), new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(text5), CodeBinaryOperatorType.Add, new CodePrimitiveExpression(1)));
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text3), "SetValue");
			CodeMethodInvokeExpression expression = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text3), "GetValue", new CodeVariableReferenceExpression(text5));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());
			coce.Parameters.Add(new CodeCastExpression(new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString()), expression));
			cmie.Parameters.Add(coce);
			cmie.Parameters.Add(new CodeVariableReferenceExpression(text5));
			cfls.Statements.Add(new CodeExpressionStatement(cmie));
			cmm.Statements.Add(cfls);
			ccc.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24582;
			cmm.Name = "GetEnumerator";
			cmm.ImplementationTypes.Add("System.Collections.IEnumerable");
			cmm.ReturnType = new CodeTypeReference("System.Collections.IEnumerator");
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PrivateNamesUsed["EnumeratorClass"].ToString());
			coce.Parameters.Add(new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text), "GetEnumerator"));
			cmm.Statements.Add(new CodeMethodReturnStatement(coce));
			ccc.Members.Add(cmm);
			GenerateEnumeratorClass();
			ccc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_ENUMIMPL")));
			cc.Members.Add(ccc);
		}

		private void GenerateEnumeratorClass()
		{
			string text = "privObjEnum";
			string text2 = "ManagementObjectEnumerator";
			string text3 = "ManagementObjectCollection";
			string text4 = "objEnum";
			ecc = new CodeTypeDeclaration(PrivateNamesUsed["EnumeratorClass"].ToString());
			ecc.TypeAttributes = TypeAttributes.NestedPublic;
			ecc.BaseTypes.Add("System.Object");
			ecc.BaseTypes.Add("System.Collections.IEnumerator");
			cf = new CodeMemberField();
			cf.Name = text;
			cf.Attributes = (MemberAttributes)20482;
			cf.Type = new CodeTypeReference(text3 + "." + text2);
			ecc.Members.Add(cf);
			cctor = new CodeConstructor();
			cctor.Attributes = MemberAttributes.Public;
			cpde = new CodeParameterDeclarationExpression();
			cpde.Name = text4;
			cpde.Type = new CodeTypeReference(text3 + "." + text2);
			cctor.Parameters.Add(cpde);
			cctor.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), new CodeVariableReferenceExpression(text4)));
			ecc.Members.Add(cctor);
			cmp = new CodeMemberProperty();
			cmp.Type = new CodeTypeReference("System.Object");
			cmp.Attributes = (MemberAttributes)24582;
			cmp.Name = "Current";
			cmp.ImplementationTypes.Add("System.Collections.IEnumerator");
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());
			coce.Parameters.Add(new CodeCastExpression(new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString()), new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "Current")));
			cmp.GetStatements.Add(new CodeMethodReturnStatement(coce));
			ecc.Members.Add(cmp);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24582;
			cmm.Name = "MoveNext";
			cmm.ImplementationTypes.Add("System.Collections.IEnumerator");
			cmm.ReturnType = new CodeTypeReference("System.Boolean");
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text), "MoveNext");
			cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
			ecc.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24582;
			cmm.Name = "Reset";
			cmm.ImplementationTypes.Add("System.Collections.IEnumerator");
			cmie = new CodeMethodInvokeExpression(new CodeVariableReferenceExpression(text), "Reset");
			cmm.Statements.Add(new CodeExpressionStatement(cmie));
			ecc.Members.Add(cmm);
			ccc.Members.Add(ecc);
		}

		private int IsContainedIn(string strToFind, ref SortedList sortedList)
		{
			int result = -1;
			for (int i = 0; i < sortedList.Count; i++)
			{
				if (string.Compare(sortedList.GetByIndex(i).ToString(), strToFind, StringComparison.OrdinalIgnoreCase) == 0)
				{
					result = i;
					break;
				}
			}
			return result;
		}

		private CodeTypeReference ConvertCIMType(CimType cType, bool isArray)
		{
			string text = cType switch
			{
				CimType.SInt8 => "System.SByte", 
				CimType.UInt8 => "System.Byte", 
				CimType.SInt16 => "System.Int16", 
				CimType.UInt16 => bUnsignedSupported ? "System.UInt16" : "System.Int16", 
				CimType.SInt32 => "System.Int32", 
				CimType.UInt32 => bUnsignedSupported ? "System.UInt32" : "System.Int32", 
				CimType.SInt64 => "System.Int64", 
				CimType.UInt64 => bUnsignedSupported ? "System.UInt64" : "System.Int64", 
				CimType.Real32 => "System.Single", 
				CimType.Real64 => "System.Double", 
				CimType.Boolean => "System.Boolean", 
				CimType.String => "System.String", 
				CimType.DateTime => "System.DateTime", 
				CimType.Reference => PublicNamesUsed["PathClass"].ToString(), 
				CimType.Char16 => "System.Char", 
				_ => PublicNamesUsed["BaseObjClass"].ToString(), 
			};
			if (isArray)
			{
				return new CodeTypeReference(text, 1);
			}
			return new CodeTypeReference(text);
		}

		private static bool isTypeInt(CimType cType)
		{
			switch (cType)
			{
			case CimType.SInt16:
			case CimType.SInt32:
			case CimType.SInt8:
			case CimType.UInt8:
			case CimType.UInt16:
			case CimType.UInt32:
				return true;
			default:
				return false;
			}
		}

		private static string ConvertValuesToName(string str)
		{
			string text = string.Empty;
			string text2 = "_";
			string text3 = string.Empty;
			bool flag = true;
			if (str.Length == 0)
			{
				return string.Copy("");
			}
			char[] array = str.ToCharArray();
			if (!char.IsLetter(array[0]))
			{
				text = "Val_";
				text3 = "l";
			}
			for (int i = 0; i < str.Length; i++)
			{
				flag = true;
				if (!char.IsLetterOrDigit(array[i]))
				{
					if (text3 == text2)
					{
						flag = false;
					}
					else
					{
						text3 = text2;
					}
				}
				else
				{
					text3 = new string(array[i], 1);
				}
				if (flag)
				{
					text += text3;
				}
			}
			return text;
		}

		private void ResolveEnumNameValues(ArrayList arrIn, ref ArrayList arrayOut)
		{
			arrayOut.Clear();
			int num = 0;
			string empty = string.Empty;
			IFormatProvider formatProvider = (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int));
			for (int i = 0; i < arrIn.Count; i++)
			{
				empty = arrIn[i].ToString();
				empty = ResolveCollision(empty, bCheckthisFirst: true);
				if (IsContainedInArray(empty, arrayOut))
				{
					num = 0;
					empty = arrIn[i].ToString() + num.ToString(formatProvider);
					while (IsContainedInArray(empty, arrayOut))
					{
						num++;
						empty = arrIn[i].ToString() + num.ToString(formatProvider);
					}
				}
				arrayOut.Add(empty);
			}
		}

		private static bool IsContainedInArray(string strToFind, ArrayList arrToSearch)
		{
			for (int i = 0; i < arrToSearch.Count; i++)
			{
				if (string.Compare(arrToSearch[i].ToString(), strToFind, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return true;
				}
			}
			return false;
		}

		private bool InitializeCodeGenerator(CodeLanguage lang)
		{
			string arg = "";
			Assembly assembly = null;
			Type type = null;
			bool flag = true;
			AssemblyName assemblyName = null;
			AssemblyName assemblyName2 = null;
			try
			{
				switch (lang)
				{
				case CodeLanguage.VB:
					arg = "Visual Basic.";
					cp = new VBCodeProvider();
					break;
				case CodeLanguage.JScript:
					arg = "JScript.NET.";
					cp = new JScriptCodeProvider();
					break;
				case CodeLanguage.CSharp:
					arg = "C#.";
					cp = new CSharpCodeProvider();
					break;
				case CodeLanguage.VJSharp:
					arg = "Visual J#.";
					flag = false;
					assemblyName = Assembly.GetExecutingAssembly().GetName();
					assemblyName2 = new AssemblyName();
					assemblyName2.CultureInfo = new CultureInfo("");
					assemblyName2.Name = "VJSharpCodeProvider";
					assemblyName2.SetPublicKey(assemblyName.GetPublicKey());
					assemblyName2.Version = assemblyName.Version;
					assembly = Assembly.Load(assemblyName2);
					if (assembly != null)
					{
						type = assembly.GetType("Microsoft.VJSharp.VJSharpCodeProvider");
						if (type != null)
						{
							cp = (CodeDomProvider)Activator.CreateInstance(type);
							flag = true;
						}
					}
					break;
				case CodeLanguage.Mcpp:
					arg = "Managed C++.";
					flag = false;
					assemblyName = Assembly.GetExecutingAssembly().GetName();
					assemblyName2 = new AssemblyName();
					assemblyName2.CultureInfo = new CultureInfo("");
					assemblyName2.SetPublicKey(assemblyName.GetPublicKey());
					assemblyName2.Name = "CppCodeProvider";
					assemblyName2.Version = new Version(VSVERSION);
					assembly = Assembly.Load(assemblyName2);
					if (assembly != null)
					{
						type = assembly.GetType("Microsoft.VisualC.CppCodeProvider");
						if (type != null)
						{
							cp = (CodeDomProvider)Activator.CreateInstance(type);
							flag = true;
						}
					}
					break;
				}
			}
			catch
			{
				throw new ArgumentOutOfRangeException(string.Format(GetString("UNABLE_TOCREATE_GEN_EXCEPT"), arg));
			}
			if (flag)
			{
				GetUnsignedSupport(lang);
				return true;
			}
			throw new ArgumentOutOfRangeException(string.Format(GetString("UNABLE_TOCREATE_GEN_EXCEPT"), arg));
		}

		private void GetUnsignedSupport(CodeLanguage Language)
		{
			if (Language != 0)
			{
				_ = Language - 1;
				_ = 1;
			}
			else
			{
				bUnsignedSupported = true;
			}
		}

		private void GenerateCommitMethod()
		{
			cmm = new CodeMemberMethod();
			cmm.Name = PublicNamesUsed["CommitMethod"].ToString();
			cmm.Attributes = (MemberAttributes)24578;
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmm.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmm.CustomAttributes.Add(cad);
			cis = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
			cboe.Right = new CodePrimitiveExpression(false);
			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			cis.Condition = cboe;
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString());
			cmie.Method.MethodName = "Put";
			cis.TrueStatements.Add(new CodeExpressionStatement(cmie));
			cmm.Statements.Add(cis);
			cc.Members.Add(cmm);
			cmm = new CodeMemberMethod();
			cmm.Name = PublicNamesUsed["CommitMethod"].ToString();
			cmm.Attributes = (MemberAttributes)24578;
			CodeParameterDeclarationExpression codeParameterDeclarationExpression = new CodeParameterDeclarationExpression();
			codeParameterDeclarationExpression.Type = new CodeTypeReference(PublicNamesUsed["PutOptions"].ToString());
			codeParameterDeclarationExpression.Name = PrivateNamesUsed["putOptions"].ToString();
			cmm.Parameters.Add(codeParameterDeclarationExpression);
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmm.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmm.CustomAttributes.Add(cad);
			cis = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
			cboe.Right = new CodePrimitiveExpression(false);
			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			cis.Condition = cboe;
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString());
			cmie.Method.MethodName = "Put";
			cmie.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["putOptions"].ToString()));
			cis.TrueStatements.Add(new CodeExpressionStatement(cmie));
			cmm.Statements.Add(cis);
			cc.Members.Add(cmm);
		}

		private static int ConvertBitMapValueToInt32(string bitMap)
		{
			string text = "0x";
			int num = 0;
			if (bitMap.StartsWith(text, StringComparison.Ordinal) || bitMap.StartsWith(text.ToUpper(CultureInfo.InvariantCulture), StringComparison.Ordinal))
			{
				text = string.Empty;
				char[] array = bitMap.ToCharArray();
				int length = bitMap.Length;
				for (int i = 2; i < length; i++)
				{
					text += array[i];
				}
				return Convert.ToInt32(text, (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int)));
			}
			return Convert.ToInt32(bitMap, (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int)));
		}

		private string GetConversionFunction(CimType cimType)
		{
			string result = string.Empty;
			switch (cimType)
			{
			case CimType.UInt8:
				result = "ToByte";
				break;
			case CimType.SInt8:
				result = "ToSByte";
				break;
			case CimType.SInt16:
				result = "ToInt16";
				break;
			case CimType.UInt16:
				result = (bUnsignedSupported ? "ToUInt16" : "ToInt16");
				break;
			case CimType.SInt32:
				result = "ToInt32";
				break;
			case CimType.UInt32:
				result = (bUnsignedSupported ? "ToUInt32" : "ToInt32");
				break;
			case CimType.SInt64:
				result = "ToInt64";
				break;
			case CimType.UInt64:
				result = (bUnsignedSupported ? "ToUInt64" : "ToInt64");
				break;
			case CimType.Real32:
				result = "ToSingle";
				break;
			case CimType.Real64:
				result = "ToDouble";
				break;
			case CimType.Boolean:
				result = "ToBoolean";
				break;
			case CimType.Char16:
				result = "ToChar";
				break;
			case CimType.String:
				result = "ToString";
				break;
			}
			return result;
		}

		private static bool IsDesignerSerializationVisibilityToBeSet(string propName)
		{
			if (string.Compare(propName, "Path", StringComparison.OrdinalIgnoreCase) != 0)
			{
				return true;
			}
			return false;
		}

		private static bool IsPropertyValueType(CimType cType)
		{
			bool result = true;
			if (cType == CimType.String || cType == CimType.Object || cType == CimType.Reference)
			{
				result = false;
			}
			return result;
		}

		private bool IsDynamicClass()
		{
			bool result = false;
			try
			{
				result = Convert.ToBoolean(classobj.Qualifiers["dynamic"].Value, (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(bool)));
				return result;
			}
			catch (ManagementException)
			{
				return result;
			}
		}

		private static string ConvertToNumericValueAndAddToArray(CimType cimType, string numericValue, ArrayList arrayToAdd, out string enumType)
		{
			string result = string.Empty;
			enumType = string.Empty;
			switch (cimType)
			{
			case CimType.SInt16:
			case CimType.SInt32:
			case CimType.SInt8:
			case CimType.UInt8:
			case CimType.UInt16:
				arrayToAdd.Add(Convert.ToInt32(numericValue, (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int))));
				result = "ToInt32";
				enumType = "System.Int32";
				break;
			case CimType.UInt32:
				arrayToAdd.Add(Convert.ToInt32(numericValue, (IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int))));
				result = "ToInt32";
				enumType = "System.Int32";
				break;
			}
			return result;
		}

		private void AddClassComments(CodeTypeDeclaration cc)
		{
			cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_SHOULDSERIALIZE")));
			cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_ISPROPNULL")));
			cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_RESETPROP")));
			cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_ATTRIBPROP")));
		}

		private static string GetString(string strToGet)
		{
			return RC.GetString(strToGet);
		}

		private void GenerateClassNameProperty()
		{
			string text = "strRet";
			cmp = new CodeMemberProperty();
			cmp.Name = PublicNamesUsed["ClassNameProperty"].ToString();
			cmp.Attributes = (MemberAttributes)24578;
			cmp.Type = new CodeTypeReference("System.String");
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp.CustomAttributes.Add(cad);
			caa = new CodeAttributeArgument();
			caa.Value = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("DesignerSerializationVisibility"), "Hidden");
			cad = new CodeAttributeDeclaration();
			cad.Name = "DesignerSerializationVisibility";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes.Add(cad);
			cmp.GetStatements.Add(new CodeVariableDeclarationStatement("System.String", text, new CodeVariableReferenceExpression(PrivateNamesUsed["CreationClassName"].ToString())));
			cis = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString());
			cboe.Right = new CodePrimitiveExpression(null);
			cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
			cis.Condition = cboe;
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString()), PublicNamesUsed["ClassPathProperty"].ToString());
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(null);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			cis.TrueStatements.Add(codeConditionStatement);
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), new CodeCastExpression(new CodeTypeReference("System.String"), new CodeIndexerExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString()), new CodePrimitiveExpression("__CLASS")))));
			CodeConditionStatement codeConditionStatement2 = new CodeConditionStatement();
			CodeBinaryOperatorExpression codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = new CodeVariableReferenceExpression(text);
			codeBinaryOperatorExpression2.Right = new CodePrimitiveExpression(null);
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.IdentityEquality;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression3 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression3.Left = new CodeVariableReferenceExpression(text);
			codeBinaryOperatorExpression3.Right = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.String"), "Empty");
			codeBinaryOperatorExpression3.Operator = CodeBinaryOperatorType.IdentityEquality;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression4 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression4.Left = codeBinaryOperatorExpression2;
			codeBinaryOperatorExpression4.Right = codeBinaryOperatorExpression3;
			codeBinaryOperatorExpression4.Operator = CodeBinaryOperatorType.BooleanOr;
			codeConditionStatement2.Condition = codeBinaryOperatorExpression4;
			codeConditionStatement2.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), new CodeVariableReferenceExpression(PrivateNamesUsed["CreationClassName"].ToString())));
			codeConditionStatement.TrueStatements.Add(codeConditionStatement2);
			cmp.GetStatements.Add(cis);
			cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(text)));
			cc.Members.Add(cmp);
		}

		private void GenerateIfClassvalidFuncWithAllParams()
		{
			string text = "path";
			string text2 = "OptionsParam";
			cmm = new CodeMemberMethod();
			cmm.Name = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
			cmm.Attributes = (MemberAttributes)20482;
			cmm.ReturnType = new CodeTypeReference("System.Boolean");
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), PrivateNamesUsed["ScopeParam"].ToString()));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()), text));
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()), text2));
			CodeExpression[] parameters = new CodeExpression[4]
			{
				new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "ClassName"),
				new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), PublicNamesUsed["ClassNameProperty"].ToString()),
				new CodePrimitiveExpression(true),
				new CodePropertyReferenceExpression(new CodeTypeReferenceExpression("System.Globalization.CultureInfo"), "InvariantCulture")
			};
			cmie = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression("System.String"), "Compare", parameters);
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = cmie;
			cboe.Right = new CodePrimitiveExpression(0);
			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(text);
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(null);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = codeBinaryOperatorExpression;
			codeBinaryOperatorExpression2.Right = cboe;
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.BooleanAnd;
			cis = new CodeConditionStatement();
			cis.Condition = codeBinaryOperatorExpression2;
			cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
			coce.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text2));
			CodeMethodReferenceExpression codeMethodReferenceExpression = new CodeMethodReferenceExpression();
			codeMethodReferenceExpression.MethodName = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
			cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodeMethodInvokeExpression(codeMethodReferenceExpression, coce)));
			cmm.Statements.Add(cis);
			cc.Members.Add(cmm);
		}

		private void GenerateIfClassvalidFunction()
		{
			GenerateIfClassvalidFuncWithAllParams();
			string text = "theObj";
			string text2 = "count";
			string text3 = "parentClasses";
			cmm = new CodeMemberMethod();
			cmm.Name = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
			cmm.Attributes = (MemberAttributes)20482;
			cmm.ReturnType = new CodeTypeReference("System.Boolean");
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString()), text));
			CodeExpression[] parameters = new CodeExpression[4]
			{
				new CodeCastExpression(new CodeTypeReference("System.String"), new CodeIndexerExpression(new CodeVariableReferenceExpression(text), new CodePrimitiveExpression("__CLASS"))),
				new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), PublicNamesUsed["ClassNameProperty"].ToString()),
				new CodePrimitiveExpression(true),
				new CodePropertyReferenceExpression(new CodeTypeReferenceExpression("System.Globalization.CultureInfo"), "InvariantCulture")
			};
			cmie = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression("System.String"), "Compare", parameters);
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = cmie;
			cboe.Right = new CodePrimitiveExpression(0);
			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(text);
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(null);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = codeBinaryOperatorExpression;
			codeBinaryOperatorExpression2.Right = cboe;
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.BooleanAnd;
			cis = new CodeConditionStatement();
			cis.Condition = codeBinaryOperatorExpression2;
			cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));
			CodeExpression initExpression = new CodeCastExpression(new CodeTypeReference("System.Array"), new CodeIndexerExpression(new CodeVariableReferenceExpression(text), new CodePrimitiveExpression("__DERIVATION")));
			cis.FalseStatements.Add(new CodeVariableDeclarationStatement("System.Array", text3, initExpression));
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(text3);
			cboe.Right = new CodePrimitiveExpression(null);
			cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
			codeConditionStatement.Condition = cboe;
			cfls = new CodeIterationStatement();
			codeConditionStatement.TrueStatements.Add(new CodeVariableDeclarationStatement("System.Int32", text2, new CodePrimitiveExpression(0)));
			cfls.InitStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(text2), new CodePrimitiveExpression(0));
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(text2);
			cboe.Operator = CodeBinaryOperatorType.LessThan;
			cboe.Right = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text3), "Length");
			cfls.TestExpression = cboe;
			cfls.IncrementStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(text2), new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(text2), CodeBinaryOperatorType.Add, new CodePrimitiveExpression(1)));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = "GetValue";
			codeMethodInvokeExpression.Method.TargetObject = new CodeVariableReferenceExpression(text3);
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text2));
			CodeExpression[] parameters2 = new CodeExpression[4]
			{
				new CodeCastExpression(new CodeTypeReference("System.String"), codeMethodInvokeExpression),
				new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), PublicNamesUsed["ClassNameProperty"].ToString()),
				new CodePrimitiveExpression(true),
				new CodePropertyReferenceExpression(new CodeTypeReferenceExpression("System.Globalization.CultureInfo"), "InvariantCulture")
			};
			CodeMethodInvokeExpression left = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression("System.String"), "Compare", parameters2);
			CodeConditionStatement codeConditionStatement2 = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = left;
			cboe.Right = new CodePrimitiveExpression(0);
			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			codeConditionStatement2.Condition = cboe;
			codeConditionStatement2.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));
			codeConditionStatement.TrueStatements.Add(cfls);
			cfls.Statements.Add(codeConditionStatement2);
			cis.FalseStatements.Add(codeConditionStatement);
			cmm.Statements.Add(cis);
			cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(false)));
			cc.Members.Add(cmm);
		}

		private void GenerateCodeForRefAndDateTimeTypes(CodeIndexerExpression prop, bool bArray, CodeStatementCollection statColl, string strType, CodeVariableReferenceExpression varToAssign, bool bIsValueProprequired)
		{
			if (!bArray)
			{
				CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
				CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
				codeBinaryOperatorExpression.Left = prop;
				codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
				codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(null);
				codeConditionStatement.Condition = codeBinaryOperatorExpression;
				if (string.Compare(strType, PublicNamesUsed["PathClass"].ToString(), StringComparison.OrdinalIgnoreCase) == 0)
				{
					CodeMethodReferenceExpression codeMethodReferenceExpression = new CodeMethodReferenceExpression();
					codeMethodReferenceExpression.MethodName = "ToString";
					codeMethodReferenceExpression.TargetObject = prop;
					cmie = new CodeMethodInvokeExpression();
					cmie.Method = codeMethodReferenceExpression;
					if (varToAssign == null)
					{
						codeConditionStatement.TrueStatements.Add(new CodeMethodReturnStatement(CreateObjectForProperty(strType, cmie)));
						statColl.Add(codeConditionStatement);
						statColl.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
					}
					else
					{
						statColl.Add(new CodeAssignStatement(varToAssign, new CodePrimitiveExpression(null)));
						codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(varToAssign, CreateObjectForProperty(strType, cmie)));
						statColl.Add(codeConditionStatement);
					}
				}
				else
				{
					statColl.Add(codeConditionStatement);
					CodeExpression codeExpression = null;
					codeExpression = ((!bIsValueProprequired) ? new CodeCastExpression(new CodeTypeReference("System.String"), prop) : new CodeCastExpression(new CodeTypeReference("System.String"), new CodePropertyReferenceExpression(prop, "Value")));
					if (varToAssign == null)
					{
						codeConditionStatement.TrueStatements.Add(new CodeMethodReturnStatement(CreateObjectForProperty(strType, codeExpression)));
						codeConditionStatement.FalseStatements.Add(new CodeMethodReturnStatement(CreateObjectForProperty(strType, null)));
					}
					else
					{
						codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(varToAssign, CreateObjectForProperty(strType, codeExpression)));
						codeConditionStatement.FalseStatements.Add(new CodeAssignStatement(varToAssign, CreateObjectForProperty(strType, null)));
					}
				}
				return;
			}
			string text = "len";
			string text2 = "iCounter";
			string text3 = "arrToRet";
			CodeConditionStatement codeConditionStatement2 = new CodeConditionStatement();
			CodeBinaryOperatorExpression codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = prop;
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.IdentityInequality;
			codeBinaryOperatorExpression2.Right = new CodePrimitiveExpression(null);
			codeConditionStatement2.Condition = codeBinaryOperatorExpression2;
			CodePropertyReferenceExpression codePropertyReferenceExpression = null;
			codePropertyReferenceExpression = ((!bIsValueProprequired) ? new CodePropertyReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Array"), prop), "Length") : new CodePropertyReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Array"), new CodePropertyReferenceExpression(prop, "Value")), "Length"));
			codeConditionStatement2.TrueStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text, codePropertyReferenceExpression));
			CodeTypeReference type = new CodeTypeReference(new CodeTypeReference(strType), 1);
			codeConditionStatement2.TrueStatements.Add(new CodeVariableDeclarationStatement(type, text3, new CodeArrayCreateExpression(new CodeTypeReference(strType), new CodeVariableReferenceExpression(text))));
			cfls = new CodeIterationStatement();
			cfls.InitStatement = new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text2, new CodePrimitiveExpression(0));
			codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = new CodeVariableReferenceExpression(text2);
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.LessThan;
			codeBinaryOperatorExpression2.Right = new CodeVariableReferenceExpression(text);
			cfls.TestExpression = codeBinaryOperatorExpression2;
			cfls.IncrementStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(text2), new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(text2), CodeBinaryOperatorType.Add, new CodePrimitiveExpression(1)));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = "GetValue";
			if (bIsValueProprequired)
			{
				codeMethodInvokeExpression.Method.TargetObject = new CodeCastExpression(new CodeTypeReference("System.Array"), new CodePropertyReferenceExpression(prop, "Value"));
			}
			else
			{
				codeMethodInvokeExpression.Method.TargetObject = new CodeCastExpression(new CodeTypeReference("System.Array"), prop);
			}
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text2));
			CodeMethodInvokeExpression codeMethodInvokeExpression2 = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression2.Method.MethodName = "ToString";
			codeMethodInvokeExpression2.Method.TargetObject = codeMethodInvokeExpression;
			cfls.Statements.Add(new CodeAssignStatement(new CodeIndexerExpression(new CodeVariableReferenceExpression(text3), new CodeVariableReferenceExpression(text2)), CreateObjectForProperty(strType, codeMethodInvokeExpression2)));
			codeConditionStatement2.TrueStatements.Add(cfls);
			if (varToAssign == null)
			{
				codeConditionStatement2.TrueStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(text3)));
				statColl.Add(codeConditionStatement2);
				statColl.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
			}
			else
			{
				statColl.Add(new CodeAssignStatement(varToAssign, new CodePrimitiveExpression(null)));
				codeConditionStatement2.TrueStatements.Add(new CodeAssignStatement(varToAssign, new CodeVariableReferenceExpression(text3)));
				statColl.Add(codeConditionStatement2);
			}
		}

		private void AddPropertySet(CodeIndexerExpression prop, bool bArray, CodeStatementCollection statColl, string strType, CodeVariableReferenceExpression varValue)
		{
			if (varValue == null)
			{
				varValue = new CodeVariableReferenceExpression("value");
			}
			if (!bArray)
			{
				statColl.Add(new CodeAssignStatement(prop, ConvertPropertyToString(strType, varValue)));
				return;
			}
			string text = "len";
			string text2 = "iCounter";
			string text3 = "arrProp";
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = varValue;
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(null);
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			CodePropertyReferenceExpression initExpression = new CodePropertyReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Array"), varValue), "Length");
			codeConditionStatement.TrueStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text, initExpression));
			CodeTypeReference type = new CodeTypeReference(new CodeTypeReference("System.String"), 1);
			codeConditionStatement.TrueStatements.Add(new CodeVariableDeclarationStatement(type, text3, new CodeArrayCreateExpression(new CodeTypeReference("System.String"), new CodeVariableReferenceExpression(text))));
			cfls = new CodeIterationStatement();
			cfls.InitStatement = new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text2, new CodePrimitiveExpression(0));
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(text2);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.LessThan;
			codeBinaryOperatorExpression.Right = new CodeVariableReferenceExpression(text);
			cfls.TestExpression = codeBinaryOperatorExpression;
			cfls.IncrementStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(text2), new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(text2), CodeBinaryOperatorType.Add, new CodePrimitiveExpression(1)));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = "GetValue";
			codeMethodInvokeExpression.Method.TargetObject = new CodeCastExpression(new CodeTypeReference("System.Array"), varValue);
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text2));
			cfls.Statements.Add(new CodeAssignStatement(new CodeIndexerExpression(new CodeVariableReferenceExpression(text3), new CodeVariableReferenceExpression(text2)), ConvertPropertyToString(strType, codeMethodInvokeExpression)));
			codeConditionStatement.TrueStatements.Add(cfls);
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(prop, new CodeVariableReferenceExpression(text3)));
			codeConditionStatement.FalseStatements.Add(new CodeAssignStatement(prop, new CodePrimitiveExpression(null)));
			statColl.Add(codeConditionStatement);
		}

		private CodeExpression CreateObjectForProperty(string strType, CodeExpression param)
		{
			switch (strType)
			{
			case "System.DateTime":
				if (param == null)
				{
					return new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.DateTime"), "MinValue");
				}
				cmie = new CodeMethodInvokeExpression();
				cmie.Parameters.Add(param);
				cmie.Method.MethodName = PrivateNamesUsed["ToDateTimeMethod"].ToString();
				return cmie;
			case "System.TimeSpan":
				if (param == null)
				{
					coce = new CodeObjectCreateExpression();
					coce.CreateType = new CodeTypeReference("System.TimeSpan");
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					return coce;
				}
				cmie = new CodeMethodInvokeExpression();
				cmie.Parameters.Add(param);
				cmie.Method.MethodName = PrivateNamesUsed["ToTimeSpanMethod"].ToString();
				return cmie;
			case "System.Management.ManagementPath":
				coce = new CodeObjectCreateExpression();
				coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
				coce.Parameters.Add(param);
				return coce;
			default:
				return null;
			}
		}

		private CodeExpression ConvertPropertyToString(string strType, CodeExpression beginingExpression)
		{
			switch (strType)
			{
			case "System.DateTime":
			{
				CodeMethodInvokeExpression codeMethodInvokeExpression2 = new CodeMethodInvokeExpression();
				codeMethodInvokeExpression2.Parameters.Add(new CodeCastExpression(new CodeTypeReference("System.DateTime"), beginingExpression));
				codeMethodInvokeExpression2.Method.MethodName = PrivateNamesUsed["ToDMTFDateTimeMethod"].ToString();
				return codeMethodInvokeExpression2;
			}
			case "System.TimeSpan":
			{
				CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
				codeMethodInvokeExpression.Parameters.Add(new CodeCastExpression(new CodeTypeReference("System.TimeSpan"), beginingExpression));
				codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["ToDMTFTimeIntervalMethod"].ToString();
				return codeMethodInvokeExpression;
			}
			case "System.Management.ManagementPath":
				return new CodePropertyReferenceExpression(new CodeCastExpression(new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()), beginingExpression), PublicNamesUsed["PathProperty"].ToString());
			default:
				return null;
			}
		}

		private void GenerateScopeProperty()
		{
			cmp = new CodeMemberProperty();
			cmp.Name = PublicNamesUsed["ScopeProperty"].ToString();
			cmp.Attributes = (MemberAttributes)24578;
			cmp.Type = new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString());
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp.CustomAttributes.Add(cad);
			if (IsDesignerSerializationVisibilityToBeSet(PublicNamesUsed["ScopeProperty"].ToString()))
			{
				caa = new CodeAttributeArgument();
				caa.Value = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("DesignerSerializationVisibility"), "Hidden");
				cad = new CodeAttributeDeclaration();
				cad.Name = "DesignerSerializationVisibility";
				cad.Arguments.Add(caa);
				cmp.CustomAttributes.Add(cad);
			}
			cis = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
			cboe.Right = new CodePrimitiveExpression(false);
			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			cis.Condition = cboe;
			CodeExpression codeExpression = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()), "Scope");
			cis.TrueStatements.Add(new CodeMethodReturnStatement(codeExpression));
			cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
			cmp.GetStatements.Add(cis);
			cis = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
			cboe.Right = new CodePrimitiveExpression(false);
			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			cis.Condition = cboe;
			cis.TrueStatements.Add(new CodeAssignStatement(codeExpression, new CodeSnippetExpression("value")));
			cmp.SetStatements.Add(cis);
			cc.Members.Add(cmp);
			cmp.Comments.Add(new CodeCommentStatement(GetString("COMMENT_MGMTSCOPE")));
		}

		private void AddGetStatementsForEnumArray(CodeIndexerExpression ciProp, CodeMemberProperty cmProp)
		{
			string text = "arrEnumVals";
			string text2 = "enumToRet";
			string text3 = "counter";
			string baseType = cmProp.Type.BaseType;
			cmProp.GetStatements.Add(new CodeVariableDeclarationStatement("System.Array", text, new CodeCastExpression(new CodeTypeReference("System.Array"), ciProp)));
			cmProp.GetStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference(baseType, 1), text2, new CodeArrayCreateExpression(new CodeTypeReference(baseType), new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "Length"))));
			cfls = new CodeIterationStatement();
			cmProp.GetStatements.Add(new CodeVariableDeclarationStatement("System.Int32", text3, new CodePrimitiveExpression(0)));
			cfls.InitStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(text3), new CodePrimitiveExpression(0));
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(text3);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.LessThan;
			codeBinaryOperatorExpression.Right = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "Length");
			cfls.TestExpression = codeBinaryOperatorExpression;
			cfls.IncrementStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(text3), new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(text3), CodeBinaryOperatorType.Add, new CodePrimitiveExpression(1)));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = "GetValue";
			codeMethodInvokeExpression.Method.TargetObject = new CodeVariableReferenceExpression(text);
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text3));
			CodeMethodInvokeExpression codeMethodInvokeExpression2 = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression2.Method.TargetObject = new CodeTypeReferenceExpression("System.Convert");
			codeMethodInvokeExpression2.Parameters.Add(codeMethodInvokeExpression);
			codeMethodInvokeExpression2.Method.MethodName = arrConvFuncName;
			cfls.Statements.Add(new CodeAssignStatement(new CodeIndexerExpression(new CodeVariableReferenceExpression(text2), new CodeVariableReferenceExpression(text3)), new CodeCastExpression(new CodeTypeReference(baseType), codeMethodInvokeExpression2)));
			cmProp.GetStatements.Add(cfls);
			cmProp.GetStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(text2)));
		}

		private void AddCommentsForEmbeddedProperties()
		{
			cc.Comments.Add(new CodeCommentStatement(GetString("")));
			cc.Comments.Add(new CodeCommentStatement(GetString("")));
			cc.Comments.Add(new CodeCommentStatement(GetString("")));
			cc.Comments.Add(new CodeCommentStatement(GetString("")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT1")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT2")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT3")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT4")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT5")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT6")));
			cc.Comments.Add(new CodeCommentStatement(GetString("")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT7")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP1")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP2")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP3")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP4")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP5")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP6")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP7")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP8")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP9")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP10")));
			cc.Comments.Add(new CodeCommentStatement(GetString("")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT8")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP1")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP2")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP3")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP4")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP5")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP6")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP7")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP8")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP9")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP10")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP11")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP12")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP13")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP14")));
			cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP15")));
		}

		private bool GetDateTimeType(PropertyData prop, ref CodeTypeReference codeType)
		{
			bool flag = false;
			codeType = null;
			if (prop.IsArray)
			{
				codeType = new CodeTypeReference("System.DateTime", 1);
			}
			else
			{
				codeType = new CodeTypeReference("System.DateTime");
			}
			try
			{
				if (string.Compare(prop.Qualifiers["SubType"].Value.ToString(), "interval", StringComparison.OrdinalIgnoreCase) == 0)
				{
					flag = true;
					if (prop.IsArray)
					{
						codeType = new CodeTypeReference("System.TimeSpan", 1);
					}
					else
					{
						codeType = new CodeTypeReference("System.TimeSpan");
					}
				}
			}
			catch (ManagementException)
			{
			}
			if (flag)
			{
				if (!bTimeSpanConversionFunctionsAdded)
				{
					cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_TIMESPANCONVFUNC")));
					bTimeSpanConversionFunctionsAdded = true;
					GenerateTimeSpanConversionFunction();
				}
			}
			else if (!bDateConversionFunctionsAdded)
			{
				cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_DATECONVFUNC")));
				bDateConversionFunctionsAdded = true;
				GenerateDateTimeConversionFunction();
			}
			return flag;
		}

		private void GenerateCreateInstance()
		{
			string text = "tmpMgmtClass";
			cmm = new CodeMemberMethod();
			string text2 = "mgmtScope";
			string text3 = "mgmtPath";
			cmm.Attributes = (MemberAttributes)24579;
			cmm.Name = PublicNamesUsed["CreateInst"].ToString();
			cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmm.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmm.CustomAttributes.Add(cad);
			cmm.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()), text2, new CodePrimitiveExpression(null)));
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString());
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(null);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityEquality;
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString());
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text2), coce));
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Path"), "NamespacePath"), new CodeVariableReferenceExpression(PrivateNamesUsed["CreationWmiNamespace"].ToString())));
			codeConditionStatement.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text2), new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString())));
			cmm.Statements.Add(codeConditionStatement);
			CodeObjectCreateExpression codeObjectCreateExpression = new CodeObjectCreateExpression();
			codeObjectCreateExpression.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			codeObjectCreateExpression.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["CreationClassName"].ToString()));
			cmm.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()), text3, codeObjectCreateExpression));
			CodeObjectCreateExpression codeObjectCreateExpression2 = new CodeObjectCreateExpression();
			codeObjectCreateExpression2.CreateType = new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString());
			codeObjectCreateExpression2.Parameters.Add(new CodeVariableReferenceExpression(text2));
			codeObjectCreateExpression2.Parameters.Add(new CodeVariableReferenceExpression(text3));
			codeObjectCreateExpression2.Parameters.Add(new CodePrimitiveExpression(null));
			cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["ManagementClass"].ToString(), text, codeObjectCreateExpression2));
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = "CreateInstance";
			codeMethodInvokeExpression.Method.TargetObject = new CodeVariableReferenceExpression(text);
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());
			coce.Parameters.Add(codeMethodInvokeExpression);
			cmm.Statements.Add(new CodeMethodReturnStatement(coce));
			cc.Members.Add(cmm);
		}

		private void GenerateDeleteInstance()
		{
			cmm = new CodeMemberMethod();
			cmm.Attributes = (MemberAttributes)24578;
			cmm.Name = PublicNamesUsed["DeleteInst"].ToString();
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmm.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmm.CustomAttributes.Add(cad);
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = "Delete";
			codeMethodInvokeExpression.Method.TargetObject = new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString());
			cmm.Statements.Add(codeMethodInvokeExpression);
			cc.Members.Add(cmm);
		}

		private void GenerateDateTimeConversionFunction()
		{
			AddToDateTimeFunction();
			AddToDMTFDateTimeFunction();
		}

		private void GenerateTimeSpanConversionFunction()
		{
			AddToTimeSpanFunction();
			AddToDMTFTimeIntervalFunction();
		}

		private void AddToDateTimeFunction()
		{
			string text = "dmtfDate";
			string text2 = "year";
			string text3 = "month";
			string text4 = "day";
			string text5 = "hour";
			string text6 = "minute";
			string text7 = "second";
			string text8 = "ticks";
			string text9 = "dmtf";
			string text10 = "tempString";
			string text11 = "datetime";
			CodeCastExpression codeCastExpression = null;
			CodeMemberMethod codeMemberMethod = new CodeMemberMethod();
			codeMemberMethod.Name = PrivateNamesUsed["ToDateTimeMethod"].ToString();
			codeMemberMethod.Attributes = MemberAttributes.Static;
			codeMemberMethod.ReturnType = new CodeTypeReference("System.DateTime");
			codeMemberMethod.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference("System.String"), text));
			codeMemberMethod.Comments.Add(new CodeCommentStatement(GetString("COMMENT_TODATETIME")));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.DateTime"), "initializer", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.DateTime"), "MinValue")));
			CodeVariableReferenceExpression targetObject = new CodeVariableReferenceExpression("initializer");
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text2, new CodePropertyReferenceExpression(targetObject, "Year")));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text3, new CodePropertyReferenceExpression(targetObject, "Month")));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text4, new CodePropertyReferenceExpression(targetObject, "Day")));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text5, new CodePropertyReferenceExpression(targetObject, "Hour")));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text6, new CodePropertyReferenceExpression(targetObject, "Minute")));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text7, new CodePropertyReferenceExpression(targetObject, "Second")));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int64"), text8, new CodePrimitiveExpression(0)));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.String"), text9, new CodeVariableReferenceExpression(text)));
			CodeFieldReferenceExpression initExpression = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.DateTime"), "MinValue");
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.DateTime"), text11, initExpression));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.String"), text10, new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.String"), "Empty")));
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(text9);
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(null);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityEquality;
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			CodeObjectCreateExpression codeObjectCreateExpression = new CodeObjectCreateExpression();
			codeObjectCreateExpression.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentOutOfRangeException"].ToString());
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression));
			codeMemberMethod.Statements.Add(codeConditionStatement);
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text9), "Length");
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.ValueEquality;
			codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression));
			codeMemberMethod.Statements.Add(codeConditionStatement);
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text9), "Length");
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(25);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
			codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression));
			codeMemberMethod.Statements.Add(codeConditionStatement);
			CodeTryCatchFinallyStatement codeTryCatchFinallyStatement = new CodeTryCatchFinallyStatement();
			DateTimeConversionFunctionHelper(codeTryCatchFinallyStatement.TryStatements, "****", text10, text9, text2, 0, 4);
			DateTimeConversionFunctionHelper(codeTryCatchFinallyStatement.TryStatements, "**", text10, text9, text3, 4, 2);
			DateTimeConversionFunctionHelper(codeTryCatchFinallyStatement.TryStatements, "**", text10, text9, text4, 6, 2);
			DateTimeConversionFunctionHelper(codeTryCatchFinallyStatement.TryStatements, "**", text10, text9, text5, 8, 2);
			DateTimeConversionFunctionHelper(codeTryCatchFinallyStatement.TryStatements, "**", text10, text9, text6, 10, 2);
			DateTimeConversionFunctionHelper(codeTryCatchFinallyStatement.TryStatements, "**", text10, text9, text7, 12, 2);
			CodeMethodReferenceExpression method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text9), "Substring");
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = method;
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(15));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(6));
			codeTryCatchFinallyStatement.TryStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text10), codeMethodInvokeExpression));
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePrimitiveExpression("******");
			codeBinaryOperatorExpression.Right = new CodeVariableReferenceExpression(text10);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
			codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			CodeMethodReferenceExpression method2 = new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("System.Int64"), "Parse");
			CodeMethodInvokeExpression codeMethodInvokeExpression2 = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression2.Method = method2;
			codeMethodInvokeExpression2.Parameters.Add(new CodeVariableReferenceExpression(text10));
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.TimeSpan"), "TicksPerMillisecond");
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(1000);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.Divide;
			codeCastExpression = new CodeCastExpression("System.Int64", codeBinaryOperatorExpression);
			CodeBinaryOperatorExpression codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = codeMethodInvokeExpression2;
			codeBinaryOperatorExpression2.Right = codeCastExpression;
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.Multiply;
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text8), codeBinaryOperatorExpression2));
			codeTryCatchFinallyStatement.TryStatements.Add(codeConditionStatement);
			CodeBinaryOperatorExpression codeBinaryOperatorExpression3 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression3.Left = new CodeVariableReferenceExpression(text2);
			codeBinaryOperatorExpression3.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression3.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression4 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression4.Left = new CodeVariableReferenceExpression(text3);
			codeBinaryOperatorExpression4.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression4.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression5 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression5.Left = new CodeVariableReferenceExpression(text4);
			codeBinaryOperatorExpression5.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression5.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression6 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression6.Left = new CodeVariableReferenceExpression(text5);
			codeBinaryOperatorExpression6.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression6.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression7 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression7.Left = new CodeVariableReferenceExpression(text6);
			codeBinaryOperatorExpression7.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression7.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression8 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression8.Left = new CodeVariableReferenceExpression(text7);
			codeBinaryOperatorExpression8.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression8.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression9 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression9.Left = new CodeVariableReferenceExpression(text8);
			codeBinaryOperatorExpression9.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression9.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression10 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression10.Left = codeBinaryOperatorExpression3;
			codeBinaryOperatorExpression10.Right = codeBinaryOperatorExpression4;
			codeBinaryOperatorExpression10.Operator = CodeBinaryOperatorType.BooleanOr;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression11 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression11.Left = codeBinaryOperatorExpression10;
			codeBinaryOperatorExpression11.Right = codeBinaryOperatorExpression5;
			codeBinaryOperatorExpression11.Operator = CodeBinaryOperatorType.BooleanOr;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression12 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression12.Left = codeBinaryOperatorExpression11;
			codeBinaryOperatorExpression12.Right = codeBinaryOperatorExpression6;
			codeBinaryOperatorExpression12.Operator = CodeBinaryOperatorType.BooleanOr;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression13 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression13.Left = codeBinaryOperatorExpression12;
			codeBinaryOperatorExpression13.Right = codeBinaryOperatorExpression7;
			codeBinaryOperatorExpression13.Operator = CodeBinaryOperatorType.BooleanOr;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression14 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression14.Left = codeBinaryOperatorExpression13;
			codeBinaryOperatorExpression14.Right = codeBinaryOperatorExpression7;
			codeBinaryOperatorExpression14.Operator = CodeBinaryOperatorType.BooleanOr;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression15 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression15.Left = codeBinaryOperatorExpression14;
			codeBinaryOperatorExpression15.Right = codeBinaryOperatorExpression8;
			codeBinaryOperatorExpression15.Operator = CodeBinaryOperatorType.BooleanOr;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression16 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression16.Left = codeBinaryOperatorExpression15;
			codeBinaryOperatorExpression16.Right = codeBinaryOperatorExpression9;
			codeBinaryOperatorExpression16.Operator = CodeBinaryOperatorType.BooleanOr;
			codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression16;
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression));
			codeTryCatchFinallyStatement.TryStatements.Add(codeConditionStatement);
			string text12 = "e";
			CodeCatchClause codeCatchClause = new CodeCatchClause(text12);
			CodeObjectCreateExpression codeObjectCreateExpression2 = new CodeObjectCreateExpression();
			codeObjectCreateExpression2.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentOutOfRangeException"].ToString());
			codeObjectCreateExpression2.Parameters.Add(new CodePrimitiveExpression(null));
			codeObjectCreateExpression2.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text12), "Message"));
			codeCatchClause.Statements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression2));
			codeTryCatchFinallyStatement.CatchClauses.Add(codeCatchClause);
			codeMemberMethod.Statements.Add(codeTryCatchFinallyStatement);
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference("System.DateTime");
			coce.Parameters.Add(new CodeVariableReferenceExpression(text2));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text3));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text4));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text5));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text6));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text7));
			coce.Parameters.Add(new CodePrimitiveExpression(0));
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text11), coce));
			CodeMethodReferenceExpression method3 = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text11), "AddTicks");
			CodeMethodInvokeExpression codeMethodInvokeExpression3 = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression3.Method = method3;
			codeMethodInvokeExpression3.Parameters.Add(new CodeVariableReferenceExpression(text8));
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text11), codeMethodInvokeExpression3));
			method2 = new CodeMethodReferenceExpression(new CodePropertyReferenceExpression(new CodeTypeReferenceExpression("System.TimeZone"), "CurrentTimeZone"), "GetUtcOffset");
			codeMethodInvokeExpression2 = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression2.Method = method2;
			codeMethodInvokeExpression2.Parameters.Add(new CodeVariableReferenceExpression(text11));
			string text13 = "tickOffset";
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.TimeSpan"), text13, codeMethodInvokeExpression2));
			string text14 = "UTCOffset";
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text14, new CodePrimitiveExpression(0)));
			string text15 = "OffsetToBeAdjusted";
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text15, new CodePrimitiveExpression(0)));
			string text16 = "OffsetMins";
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text13), "Ticks");
			codeBinaryOperatorExpression.Right = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.TimeSpan"), "TicksPerMinute");
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.Divide;
			codeCastExpression = new CodeCastExpression("System.Int64", codeBinaryOperatorExpression);
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int64"), text16, codeCastExpression));
			method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text9), "Substring");
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = method;
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(22));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(3));
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text10), codeMethodInvokeExpression));
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(text10);
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression("******");
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
			codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text9), "Substring");
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = method;
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(21));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(4));
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text10), codeMethodInvokeExpression));
			CodeTryCatchFinallyStatement codeTryCatchFinallyStatement2 = new CodeTryCatchFinallyStatement();
			method = new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("System.Int32"), "Parse");
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = method;
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text10));
			codeTryCatchFinallyStatement2.TryStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text14), codeMethodInvokeExpression));
			codeTryCatchFinallyStatement2.CatchClauses.Add(codeCatchClause);
			codeConditionStatement.TrueStatements.Add(codeTryCatchFinallyStatement2);
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(text16);
			codeBinaryOperatorExpression.Right = new CodeVariableReferenceExpression(text14);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.Subtract;
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text15), new CodeCastExpression(new CodeTypeReference("System.Int32"), codeBinaryOperatorExpression)));
			method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text11), "AddMinutes");
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = method;
			codeMethodInvokeExpression.Parameters.Add(new CodeCastExpression("System.Double", new CodeVariableReferenceExpression(text15)));
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text11), codeMethodInvokeExpression));
			codeMemberMethod.Statements.Add(codeConditionStatement);
			codeMemberMethod.Statements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(text11)));
			cc.Members.Add(codeMemberMethod);
		}

		private static void DateTimeConversionFunctionHelper(CodeStatementCollection cmmdt, string toCompare, string tempVarName, string dmtfVarName, string toAssign, int SubStringParam1, int SubStringParam2)
		{
			CodeMethodReferenceExpression method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(dmtfVarName), "Substring");
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = method;
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(SubStringParam1));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(SubStringParam2));
			cmmdt.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(tempVarName), codeMethodInvokeExpression));
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePrimitiveExpression(toCompare);
			codeBinaryOperatorExpression.Right = new CodeVariableReferenceExpression(tempVarName);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			method = new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("System.Int32"), "Parse");
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = method;
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(tempVarName));
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(toAssign), codeMethodInvokeExpression));
			cmmdt.Add(codeConditionStatement);
		}

		private void AddToDMTFTimeIntervalFunction()
		{
			string text = "dmtftimespan";
			string text2 = "timespan";
			string text3 = "tsTemp";
			string text4 = "microsec";
			string text5 = "strMicroSec";
			CodeMemberMethod codeMemberMethod = new CodeMemberMethod();
			codeMemberMethod.Name = PrivateNamesUsed["ToDMTFTimeIntervalMethod"].ToString();
			codeMemberMethod.Attributes = MemberAttributes.Static;
			codeMemberMethod.ReturnType = new CodeTypeReference("System.String");
			codeMemberMethod.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference("System.TimeSpan"), text2));
			codeMemberMethod.Comments.Add(new CodeCommentStatement(GetString("COMMENT_TODMTFTIMEINTERVAL")));
			CodePropertyReferenceExpression expression = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Days");
			cmie = new CodeMethodInvokeExpression();
			cmie.Method = new CodeMethodReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Int32 "), expression), "ToString");
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(cmie, "PadLeft");
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(8));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression('0'));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.String"), text, codeMethodInvokeExpression));
			CodeObjectCreateExpression codeObjectCreateExpression = new CodeObjectCreateExpression();
			codeObjectCreateExpression.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentOutOfRangeException"].ToString());
			CodeFieldReferenceExpression initExpression = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.TimeSpan"), "MaxValue");
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.TimeSpan"), "maxTimeSpan", initExpression));
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Days");
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.GreaterThan;
			codeBinaryOperatorExpression.Right = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("maxTimeSpan"), "Days");
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression));
			codeMemberMethod.Statements.Add(codeConditionStatement);
			CodeFieldReferenceExpression initExpression2 = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.TimeSpan"), "MinValue");
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.TimeSpan"), "minTimeSpan", initExpression2));
			CodeBinaryOperatorExpression codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Days");
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.LessThan;
			codeBinaryOperatorExpression2.Right = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("minTimeSpan"), "Days");
			CodeConditionStatement codeConditionStatement2 = new CodeConditionStatement();
			codeConditionStatement2.Condition = codeBinaryOperatorExpression2;
			codeConditionStatement2.TrueStatements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression));
			codeMemberMethod.Statements.Add(codeConditionStatement2);
			expression = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Hours");
			cmie = new CodeMethodInvokeExpression();
			cmie.Method = new CodeMethodReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Int32 "), expression), "ToString");
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(cmie, "PadLeft");
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(2));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression('0'));
			CodeMethodInvokeExpression right = GenerateConcatStrings(new CodeVariableReferenceExpression(text), codeMethodInvokeExpression);
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), right));
			expression = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Minutes");
			cmie = new CodeMethodInvokeExpression();
			cmie.Method = new CodeMethodReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Int32 "), expression), "ToString");
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(cmie, "PadLeft");
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(2));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression('0'));
			right = GenerateConcatStrings(new CodeVariableReferenceExpression(text), codeMethodInvokeExpression);
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), right));
			expression = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Seconds");
			cmie = new CodeMethodInvokeExpression();
			cmie.Method = new CodeMethodReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Int32 "), expression), "ToString");
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(cmie, "PadLeft");
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(2));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression('0'));
			right = GenerateConcatStrings(new CodeVariableReferenceExpression(text), codeMethodInvokeExpression);
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), right));
			right = GenerateConcatStrings(new CodeVariableReferenceExpression(text), new CodePrimitiveExpression("."));
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), right));
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference("System.TimeSpan");
			coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Days"));
			coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Hours"));
			coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Minutes"));
			coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Seconds"));
			coce.Parameters.Add(new CodePrimitiveExpression(0));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.TimeSpan"), text3, coce));
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Ticks");
			codeBinaryOperatorExpression.Right = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text3), "Ticks");
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.Subtract;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression3 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression3.Left = codeBinaryOperatorExpression;
			codeBinaryOperatorExpression3.Right = new CodePrimitiveExpression(1000);
			codeBinaryOperatorExpression3.Operator = CodeBinaryOperatorType.Multiply;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression4 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression4.Left = codeBinaryOperatorExpression3;
			codeBinaryOperatorExpression4.Right = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.TimeSpan"), "TicksPerMillisecond");
			codeBinaryOperatorExpression4.Operator = CodeBinaryOperatorType.Divide;
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int64"), text4, new CodeCastExpression("System.Int64", codeBinaryOperatorExpression4)));
			cmie = new CodeMethodInvokeExpression();
			cmie.Method = new CodeMethodReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Int64 "), new CodeVariableReferenceExpression(text4)), "ToString");
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.String"), text5, cmie));
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text5), "Length");
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(6);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.GreaterThan;
			codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			cmie = new CodeMethodInvokeExpression();
			cmie.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text5), "Substring");
			cmie.Parameters.Add(new CodePrimitiveExpression(0));
			cmie.Parameters.Add(new CodePrimitiveExpression(6));
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text5), cmie));
			codeMemberMethod.Statements.Add(codeConditionStatement);
			cmie = new CodeMethodInvokeExpression();
			cmie.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text5), "PadLeft");
			cmie.Parameters.Add(new CodePrimitiveExpression(6));
			cmie.Parameters.Add(new CodePrimitiveExpression('0'));
			right = GenerateConcatStrings(new CodeVariableReferenceExpression(text), cmie);
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), right));
			right = GenerateConcatStrings(new CodeVariableReferenceExpression(text), new CodePrimitiveExpression(":000"));
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), right));
			codeMemberMethod.Statements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(text)));
			cc.Members.Add(codeMemberMethod);
		}

		private void AddToDMTFDateTimeFunction()
		{
			string text = "utcString";
			string text2 = "date";
			CodeCastExpression codeCastExpression = null;
			CodeMemberMethod codeMemberMethod = new CodeMemberMethod();
			codeMemberMethod.Name = PrivateNamesUsed["ToDMTFDateTimeMethod"].ToString();
			codeMemberMethod.Attributes = MemberAttributes.Static;
			codeMemberMethod.ReturnType = new CodeTypeReference("System.String");
			codeMemberMethod.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference("System.DateTime"), text2));
			codeMemberMethod.Comments.Add(new CodeCommentStatement(GetString("COMMENT_TODMTFDATETIME")));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.String"), text, new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.String"), "Empty")));
			CodeMethodReferenceExpression method = new CodeMethodReferenceExpression(new CodePropertyReferenceExpression(new CodeTypeReferenceExpression("System.TimeZone"), "CurrentTimeZone"), "GetUtcOffset");
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = method;
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text2));
			string text3 = "tickOffset";
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.TimeSpan"), text3, codeMethodInvokeExpression));
			string text4 = "OffsetMins";
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text3), "Ticks");
			cboe.Right = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.TimeSpan"), "TicksPerMinute");
			cboe.Operator = CodeBinaryOperatorType.Divide;
			codeCastExpression = new CodeCastExpression("System.Int64", cboe);
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int64"), text4, codeCastExpression));
			method = new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("System.Math"), "Abs");
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = method;
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text4));
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = codeMethodInvokeExpression;
			cboe.Right = new CodePrimitiveExpression(999);
			cboe.Operator = CodeBinaryOperatorType.GreaterThan;
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = cboe;
			method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text2), "ToUniversalTime");
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = method;
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text2), codeMethodInvokeExpression));
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), new CodePrimitiveExpression("+000")));
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text3), "Ticks");
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.GreaterThanOrEqual;
			CodeConditionStatement codeConditionStatement2 = new CodeConditionStatement();
			codeConditionStatement2.Condition = codeBinaryOperatorExpression;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text3), "Ticks");
			codeBinaryOperatorExpression2.Right = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.TimeSpan"), "TicksPerMinute");
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.Divide;
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Int64 "), codeBinaryOperatorExpression2), "ToString");
			CodeMethodInvokeExpression codeMethodInvokeExpression2 = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression2.Method = new CodeMethodReferenceExpression(codeMethodInvokeExpression, "PadLeft");
			codeMethodInvokeExpression2.Parameters.Add(new CodePrimitiveExpression(3));
			codeMethodInvokeExpression2.Parameters.Add(new CodePrimitiveExpression('0'));
			codeConditionStatement2.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), GenerateConcatStrings(new CodePrimitiveExpression("+"), codeMethodInvokeExpression2)));
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Int64 "), new CodeVariableReferenceExpression(text4)), "ToString");
			codeConditionStatement2.FalseStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.String"), "strTemp", codeMethodInvokeExpression));
			codeMethodInvokeExpression2 = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression2.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression("strTemp"), "Substring");
			codeMethodInvokeExpression2.Parameters.Add(new CodePrimitiveExpression(1));
			codeMethodInvokeExpression2.Parameters.Add(new CodeBinaryOperatorExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("strTemp"), "Length"), CodeBinaryOperatorType.Subtract, new CodePrimitiveExpression(1)));
			CodeMethodInvokeExpression codeMethodInvokeExpression3 = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression3.Method = new CodeMethodReferenceExpression(codeMethodInvokeExpression2, "PadLeft");
			codeMethodInvokeExpression3.Parameters.Add(new CodePrimitiveExpression(3));
			codeMethodInvokeExpression3.Parameters.Add(new CodePrimitiveExpression('0'));
			codeConditionStatement2.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text), GenerateConcatStrings(new CodePrimitiveExpression("-"), codeMethodInvokeExpression3)));
			codeConditionStatement.FalseStatements.Add(codeConditionStatement2);
			codeMemberMethod.Statements.Add(codeConditionStatement);
			string text5 = "dmtfDateTime";
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Int32 "), new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Year")), "ToString");
			codeMethodInvokeExpression2 = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression2.Method = new CodeMethodReferenceExpression(codeMethodInvokeExpression, "PadLeft");
			codeMethodInvokeExpression2.Parameters.Add(new CodePrimitiveExpression(4));
			codeMethodInvokeExpression2.Parameters.Add(new CodePrimitiveExpression('0'));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.String"), text5, codeMethodInvokeExpression2));
			ToDMTFDateHelper("Month", codeMemberMethod, "System.Int32 ");
			ToDMTFDateHelper("Day", codeMemberMethod, "System.Int32 ");
			ToDMTFDateHelper("Hour", codeMemberMethod, "System.Int32 ");
			ToDMTFDateHelper("Minute", codeMemberMethod, "System.Int32 ");
			ToDMTFDateHelper("Second", codeMemberMethod, "System.Int32 ");
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text5), GenerateConcatStrings(new CodeVariableReferenceExpression(text5), new CodePrimitiveExpression("."))));
			string text6 = "dtTemp";
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference("System.DateTime");
			coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Year"));
			coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Month"));
			coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Day"));
			coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Hour"));
			coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Minute"));
			coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Second"));
			coce.Parameters.Add(new CodePrimitiveExpression(0));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.DateTime"), text6, coce));
			string text7 = "microsec";
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text2), "Ticks");
			cboe.Right = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text6), "Ticks");
			cboe.Operator = CodeBinaryOperatorType.Subtract;
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = cboe;
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(1000);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.Multiply;
			codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = codeBinaryOperatorExpression;
			codeBinaryOperatorExpression2.Right = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.TimeSpan"), "TicksPerMillisecond");
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.Divide;
			codeCastExpression = new CodeCastExpression("System.Int64", codeBinaryOperatorExpression2);
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int64"), text7, codeCastExpression));
			string text8 = "strMicrosec";
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Int64 "), new CodeVariableReferenceExpression(text7)), "ToString");
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.String"), text8, codeMethodInvokeExpression));
			cboe = new CodeBinaryOperatorExpression();
			cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text8), "Length");
			cboe.Right = new CodePrimitiveExpression(6);
			cboe.Operator = CodeBinaryOperatorType.GreaterThan;
			codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = cboe;
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text8), "Substring");
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(0));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(6));
			codeConditionStatement.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text8), codeMethodInvokeExpression));
			codeMemberMethod.Statements.Add(codeConditionStatement);
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text8), "PadLeft");
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(6));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression('0'));
			codeMethodInvokeExpression2 = GenerateConcatStrings(new CodeVariableReferenceExpression(text5), codeMethodInvokeExpression);
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text5), codeMethodInvokeExpression2));
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text5), GenerateConcatStrings(new CodeVariableReferenceExpression(text5), new CodeVariableReferenceExpression(text))));
			codeMemberMethod.Statements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(text5)));
			cc.Members.Add(codeMemberMethod);
		}

		private void ToDMTFDateHelper(string dateTimeMember, CodeMemberMethod cmmdt, string strType)
		{
			string variableName = "dmtfDateTime";
			string variableName2 = "date";
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeCastExpression(new CodeTypeReference(strType), new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(variableName2), dateTimeMember)), "ToString");
			CodeMethodInvokeExpression codeMethodInvokeExpression2 = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression2.Method = new CodeMethodReferenceExpression(codeMethodInvokeExpression, "PadLeft");
			codeMethodInvokeExpression2.Parameters.Add(new CodePrimitiveExpression(2));
			codeMethodInvokeExpression2.Parameters.Add(new CodePrimitiveExpression('0'));
			CodeMethodInvokeExpression codeMethodInvokeExpression3 = GenerateConcatStrings(codeMethodInvokeExpression, codeMethodInvokeExpression2);
			cmmdt.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(variableName), GenerateConcatStrings(new CodeVariableReferenceExpression(variableName), codeMethodInvokeExpression2)));
		}

		private void AddToTimeSpanFunction()
		{
			string text = "dmtfTimespan";
			string text2 = "days";
			string text3 = "hours";
			string text4 = "minutes";
			string text5 = "seconds";
			string text6 = "ticks";
			CodeMemberMethod codeMemberMethod = new CodeMemberMethod();
			codeMemberMethod.Name = PrivateNamesUsed["ToTimeSpanMethod"].ToString();
			codeMemberMethod.Attributes = MemberAttributes.Static;
			codeMemberMethod.ReturnType = new CodeTypeReference("System.TimeSpan");
			codeMemberMethod.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference("System.String"), text));
			codeMemberMethod.Comments.Add(new CodeCommentStatement(GetString("COMMENT_TOTIMESPAN")));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text2, new CodePrimitiveExpression(0)));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text3, new CodePrimitiveExpression(0)));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text4, new CodePrimitiveExpression(0)));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"), text5, new CodePrimitiveExpression(0)));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int64"), text6, new CodePrimitiveExpression(0)));
			CodeBinaryOperatorExpression codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodeVariableReferenceExpression(text);
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(null);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityEquality;
			CodeConditionStatement codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			CodeObjectCreateExpression codeObjectCreateExpression = new CodeObjectCreateExpression();
			codeObjectCreateExpression.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentOutOfRangeException"].ToString());
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression));
			codeMemberMethod.Statements.Add(codeConditionStatement);
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "Length");
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.ValueEquality;
			codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression));
			codeMemberMethod.Statements.Add(codeConditionStatement);
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text), "Length");
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(25);
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
			codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression));
			codeMemberMethod.Statements.Add(codeConditionStatement);
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text), "Substring");
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(21));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(4));
			codeBinaryOperatorExpression = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression.Left = codeMethodInvokeExpression;
			codeBinaryOperatorExpression.Right = new CodePrimitiveExpression(":000");
			codeBinaryOperatorExpression.Operator = CodeBinaryOperatorType.IdentityInequality;
			codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression;
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression));
			codeMemberMethod.Statements.Add(codeConditionStatement);
			CodeTryCatchFinallyStatement codeTryCatchFinallyStatement = new CodeTryCatchFinallyStatement();
			string text7 = "tempString";
			codeTryCatchFinallyStatement.TryStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.String"), text7, new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.String"), "Empty")));
			ToTimeSpanHelper(0, 8, text2, codeTryCatchFinallyStatement.TryStatements);
			ToTimeSpanHelper(8, 2, text3, codeTryCatchFinallyStatement.TryStatements);
			ToTimeSpanHelper(10, 2, text4, codeTryCatchFinallyStatement.TryStatements);
			ToTimeSpanHelper(12, 2, text5, codeTryCatchFinallyStatement.TryStatements);
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text), "Substring");
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(15));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(6));
			codeTryCatchFinallyStatement.TryStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text7), codeMethodInvokeExpression));
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("System.Int64"), "Parse");
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text7));
			codeTryCatchFinallyStatement.TryStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text6), new CodeBinaryOperatorExpression(codeMethodInvokeExpression, CodeBinaryOperatorType.Multiply, new CodeCastExpression("System.Int64", new CodeBinaryOperatorExpression(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.TimeSpan"), "TicksPerMillisecond"), CodeBinaryOperatorType.Divide, new CodePrimitiveExpression(1000))))));
			CodeBinaryOperatorExpression codeBinaryOperatorExpression2 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression2.Left = new CodeVariableReferenceExpression(text2);
			codeBinaryOperatorExpression2.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression2.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression3 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression3.Left = new CodeVariableReferenceExpression(text3);
			codeBinaryOperatorExpression3.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression3.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression4 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression4.Left = new CodeVariableReferenceExpression(text4);
			codeBinaryOperatorExpression4.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression4.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression5 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression5.Left = new CodeVariableReferenceExpression(text5);
			codeBinaryOperatorExpression5.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression5.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression6 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression6.Left = new CodeVariableReferenceExpression(text6);
			codeBinaryOperatorExpression6.Right = new CodePrimitiveExpression(0);
			codeBinaryOperatorExpression6.Operator = CodeBinaryOperatorType.LessThan;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression7 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression7.Left = codeBinaryOperatorExpression2;
			codeBinaryOperatorExpression7.Right = codeBinaryOperatorExpression3;
			codeBinaryOperatorExpression7.Operator = CodeBinaryOperatorType.BooleanOr;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression8 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression8.Left = codeBinaryOperatorExpression7;
			codeBinaryOperatorExpression8.Right = codeBinaryOperatorExpression4;
			codeBinaryOperatorExpression8.Operator = CodeBinaryOperatorType.BooleanOr;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression9 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression9.Left = codeBinaryOperatorExpression8;
			codeBinaryOperatorExpression9.Right = codeBinaryOperatorExpression5;
			codeBinaryOperatorExpression9.Operator = CodeBinaryOperatorType.BooleanOr;
			CodeBinaryOperatorExpression codeBinaryOperatorExpression10 = new CodeBinaryOperatorExpression();
			codeBinaryOperatorExpression10.Left = codeBinaryOperatorExpression9;
			codeBinaryOperatorExpression10.Right = codeBinaryOperatorExpression6;
			codeBinaryOperatorExpression10.Operator = CodeBinaryOperatorType.BooleanOr;
			codeConditionStatement = new CodeConditionStatement();
			codeConditionStatement.Condition = codeBinaryOperatorExpression10;
			codeConditionStatement.TrueStatements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression));
			string text8 = "e";
			CodeCatchClause codeCatchClause = new CodeCatchClause(text8);
			CodeObjectCreateExpression codeObjectCreateExpression2 = new CodeObjectCreateExpression();
			codeObjectCreateExpression2.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentOutOfRangeException"].ToString());
			codeObjectCreateExpression2.Parameters.Add(new CodePrimitiveExpression(null));
			codeObjectCreateExpression2.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(text8), "Message"));
			codeCatchClause.Statements.Add(new CodeThrowExceptionStatement(codeObjectCreateExpression2));
			codeTryCatchFinallyStatement.CatchClauses.Add(codeCatchClause);
			codeMemberMethod.Statements.Add(codeTryCatchFinallyStatement);
			string text9 = "timespan";
			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference("System.TimeSpan");
			coce.Parameters.Add(new CodeVariableReferenceExpression(text2));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text3));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text4));
			coce.Parameters.Add(new CodeVariableReferenceExpression(text5));
			coce.Parameters.Add(new CodePrimitiveExpression(0));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.TimeSpan"), text9, coce));
			string text10 = "tsTemp";
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("System.TimeSpan"), "FromTicks");
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text6));
			codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.TimeSpan"), text10, codeMethodInvokeExpression));
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(text9), "Add");
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(text10));
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(text9), codeMethodInvokeExpression));
			codeMemberMethod.Statements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(text9)));
			cc.Members.Add(codeMemberMethod);
		}

		private static void ToTimeSpanHelper(int start, int numOfCharacters, string strVarToAssign, CodeStatementCollection statCol)
		{
			string variableName = "tempString";
			string variableName2 = "dmtfTimespan";
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(variableName2), "Substring");
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(start));
			codeMethodInvokeExpression.Parameters.Add(new CodePrimitiveExpression(numOfCharacters));
			statCol.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(variableName), codeMethodInvokeExpression));
			codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method = new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("System.Int32"), "Parse");
			codeMethodInvokeExpression.Parameters.Add(new CodeVariableReferenceExpression(variableName));
			statCol.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strVarToAssign), codeMethodInvokeExpression));
		}

		private void InitPrivateMemberVariables(CodeMemberMethod cmMethod)
		{
			CodeMethodInvokeExpression codeMethodInvokeExpression = new CodeMethodInvokeExpression();
			codeMethodInvokeExpression.Method.MethodName = PrivateNamesUsed["initVariable"].ToString();
			cmMethod.Statements.Add(codeMethodInvokeExpression);
		}

		private void GenerateMethodToInitializeVariables()
		{
			CodeMemberMethod codeMemberMethod = new CodeMemberMethod();
			codeMemberMethod.Name = PrivateNamesUsed["initVariable"].ToString();
			codeMemberMethod.Attributes = (MemberAttributes)20482;
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["AutoCommitProperty"].ToString()), new CodePrimitiveExpression(true)));
			codeMemberMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString()), new CodePrimitiveExpression(false)));
			cc.Members.Add(codeMemberMethod);
		}

		private static CodeMethodInvokeExpression GenerateConcatStrings(CodeExpression ce1, CodeExpression ce2)
		{
			CodeExpression[] parameters = new CodeExpression[2] { ce1, ce2 };
			return new CodeMethodInvokeExpression(new CodeTypeReferenceExpression("System.String"), "Concat", parameters);
		}
	}
	[ComImport]
	[Guid("87A5AD68-A38A-43ef-ACA9-EFE910E5D24C")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IWmiEventSource
	{
		void Indicate(IntPtr pIWbemClassObject);

		void SetStatus(int lFlags, int hResult, [MarshalAs(UnmanagedType.BStr)] string strParam, IntPtr pObjParam);
	}
	internal class WbemErrorInfo
	{
		public static IWbemClassObjectFreeThreaded GetErrorInfo()
		{
			IntPtr intPtr = WmiNetUtilsHelper.GetErrorInfo_f();
			if (IntPtr.Zero != intPtr && new IntPtr(-1) != intPtr)
			{
				Marshal.QueryInterface(intPtr, ref IWbemClassObjectFreeThreaded.IID_IWbemClassObject, out var ppv);
				Marshal.Release(intPtr);
				if (ppv != IntPtr.Zero)
				{
					return new IWbemClassObjectFreeThreaded(ppv);
				}
			}
			return null;
		}
	}
	[ComImport]
	[Guid("1CF2B120-547D-101B-8E65-08002B2BD119")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IErrorInfo
	{
		Guid GetGUID();

		[return: MarshalAs(UnmanagedType.BStr)]
		string GetSource();

		[return: MarshalAs(UnmanagedType.BStr)]
		string GetDescription();

		[return: MarshalAs(UnmanagedType.BStr)]
		string GetHelpFile();

		uint GetHelpContext();
	}
	[Serializable]
	internal sealed class IWbemClassObjectFreeThreaded : IDisposable, ISerializable
	{
		private enum STATFLAG
		{
			STATFLAG_DEFAULT,
			STATFLAG_NONAME
		}

		private enum MSHCTX
		{
			MSHCTX_LOCAL,
			MSHCTX_NOSHAREDMEM,
			MSHCTX_DIFFERENTMACHINE,
			MSHCTX_INPROC
		}

		private enum MSHLFLAGS
		{
			MSHLFLAGS_NORMAL,
			MSHLFLAGS_TABLESTRONG,
			MSHLFLAGS_TABLEWEAK,
			MSHLFLAGS_NOPING
		}

		private const string SerializationBlobName = "flatWbemClassObject";

		private static readonly string name = typeof(IWbemClassObjectFreeThreaded).FullName;

		public static Guid IID_IWbemClassObject = new Guid("DC12A681-737F-11CF-884D-00AA004B2E24");

		private IntPtr pWbemClassObject = IntPtr.Zero;

		public IWbemClassObjectFreeThreaded(IntPtr pWbemClassObject)
		{
			this.pWbemClassObject = pWbemClassObject;
		}

		public static implicit operator IntPtr(IWbemClassObjectFreeThreaded wbemClassObject)
		{
			return wbemClassObject?.pWbemClassObject ?? IntPtr.Zero;
		}

		public IWbemClassObjectFreeThreaded(SerializationInfo info, StreamingContext context)
		{
			if (!(info.GetValue("flatWbemClassObject", typeof(byte[])) is byte[] rg))
			{
				throw new SerializationException();
			}
			DeserializeFromBlob(rg);
		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
		{
			info.AddValue("flatWbemClassObject", SerializeToBlob());
		}

		public void Dispose()
		{
			Dispose_(finalization: false);
		}

		private void Dispose_(bool finalization)
		{
			if (pWbemClassObject != IntPtr.Zero)
			{
				Marshal.Release(pWbemClassObject);
				pWbemClassObject = IntPtr.Zero;
			}
			GC.SuppressFinalize(this);
		}

		~IWbemClassObjectFreeThreaded()
		{
			Dispose_(finalization: true);
		}

		private void DeserializeFromBlob(byte[] rg)
		{
			IntPtr intPtr = IntPtr.Zero;
			IStream stream = null;
			try
			{
				pWbemClassObject = IntPtr.Zero;
				intPtr = Marshal.AllocHGlobal(rg.Length);
				Marshal.Copy(rg, 0, intPtr, rg.Length);
				stream = CreateStreamOnHGlobal(intPtr, 0);
				pWbemClassObject = CoUnmarshalInterface(stream, ref IID_IWbemClassObject);
			}
			finally
			{
				if (stream != null)
				{
					Marshal.ReleaseComObject(stream);
				}
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		private byte[] SerializeToBlob()
		{
			byte[] array = null;
			IStream stream = null;
			IntPtr intPtr = IntPtr.Zero;
			try
			{
				stream = CreateStreamOnHGlobal(IntPtr.Zero, 1);
				CoMarshalInterface(stream, ref IID_IWbemClassObject, pWbemClassObject, 2u, IntPtr.Zero, 2u);
				stream.Stat(out var pstatstg, 0);
				array = new byte[pstatstg.cbSize];
				intPtr = GlobalLock(GetHGlobalFromStream(stream));
				Marshal.Copy(intPtr, array, 0, (int)pstatstg.cbSize);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					GlobalUnlock(intPtr);
				}
				if (stream != null)
				{
					Marshal.ReleaseComObject(stream);
				}
			}
			GC.KeepAlive(this);
			return array;
		}

		public int GetQualifierSet_(out IWbemQualifierSetFreeThreaded ppQualSet)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			IntPtr ppQualSet2;
			int num = WmiNetUtilsHelper.GetQualifierSet_f(3, pWbemClassObject, out ppQualSet2);
			if (num < 0)
			{
				ppQualSet = null;
			}
			else
			{
				ppQualSet = new IWbemQualifierSetFreeThreaded(ppQualSet2);
			}
			GC.KeepAlive(this);
			return num;
		}

		public int Get_(string wszName, int lFlags, ref object pVal, ref int pType, ref int plFlavor)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int num = WmiNetUtilsHelper.Get_f(4, pWbemClassObject, wszName, lFlags, ref pVal, ref pType, ref plFlavor);
			if (num == -2147217393 && string.Compare(wszName, "__path", StringComparison.OrdinalIgnoreCase) == 0)
			{
				num = 0;
				pType = 8;
				plFlavor = 64;
				pVal = DBNull.Value;
			}
			GC.KeepAlive(this);
			return num;
		}

		public int Put_(string wszName, int lFlags, ref object pVal, int Type)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.Put_f(5, pWbemClassObject, wszName, lFlags, ref pVal, Type);
			GC.KeepAlive(this);
			return result;
		}

		public int Delete_(string wszName)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.Delete_f(6, pWbemClassObject, wszName);
			GC.KeepAlive(this);
			return result;
		}

		public int GetNames_(string wszQualifierName, int lFlags, ref object pQualifierVal, out string[] pNames)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.GetNames_f(7, pWbemClassObject, wszQualifierName, lFlags, ref pQualifierVal, out pNames);
			GC.KeepAlive(this);
			return result;
		}

		public int BeginEnumeration_(int lEnumFlags)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.BeginEnumeration_f(8, pWbemClassObject, lEnumFlags);
			GC.KeepAlive(this);
			return result;
		}

		public int Next_(int lFlags, ref string strName, ref object pVal, ref int pType, ref int plFlavor)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			pVal = null;
			strName = null;
			int result = WmiNetUtilsHelper.Next_f(9, pWbemClassObject, lFlags, ref strName, ref pVal, ref pType, ref plFlavor);
			GC.KeepAlive(this);
			return result;
		}

		public int EndEnumeration_()
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.EndEnumeration_f(10, pWbemClassObject);
			GC.KeepAlive(this);
			return result;
		}

		public int GetPropertyQualifierSet_(string wszProperty, out IWbemQualifierSetFreeThreaded ppQualSet)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			IntPtr ppQualSet2;
			int num = WmiNetUtilsHelper.GetPropertyQualifierSet_f(11, pWbemClassObject, wszProperty, out ppQualSet2);
			if (num < 0)
			{
				ppQualSet = null;
			}
			else
			{
				ppQualSet = new IWbemQualifierSetFreeThreaded(ppQualSet2);
			}
			GC.KeepAlive(this);
			return num;
		}

		public int Clone_(out IWbemClassObjectFreeThreaded ppCopy)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			IntPtr ppCopy2;
			int num = WmiNetUtilsHelper.Clone_f(12, pWbemClassObject, out ppCopy2);
			if (num < 0)
			{
				ppCopy = null;
			}
			else
			{
				ppCopy = new IWbemClassObjectFreeThreaded(ppCopy2);
			}
			GC.KeepAlive(this);
			return num;
		}

		public int GetObjectText_(int lFlags, out string pstrObjectText)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.GetObjectText_f(13, pWbemClassObject, lFlags, out pstrObjectText);
			GC.KeepAlive(this);
			return result;
		}

		public int SpawnDerivedClass_(int lFlags, out IWbemClassObjectFreeThreaded ppNewClass)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			IntPtr ppNewClass2;
			int num = WmiNetUtilsHelper.SpawnDerivedClass_f(14, pWbemClassObject, lFlags, out ppNewClass2);
			if (num < 0)
			{
				ppNewClass = null;
			}
			else
			{
				ppNewClass = new IWbemClassObjectFreeThreaded(ppNewClass2);
			}
			GC.KeepAlive(this);
			return num;
		}

		public int SpawnInstance_(int lFlags, out IWbemClassObjectFreeThreaded ppNewInstance)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			IntPtr ppNewInstance2;
			int num = WmiNetUtilsHelper.SpawnInstance_f(15, pWbemClassObject, lFlags, out ppNewInstance2);
			if (num < 0)
			{
				ppNewInstance = null;
			}
			else
			{
				ppNewInstance = new IWbemClassObjectFreeThreaded(ppNewInstance2);
			}
			GC.KeepAlive(this);
			return num;
		}

		public int CompareTo_(int lFlags, IWbemClassObjectFreeThreaded pCompareTo)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.CompareTo_f(16, pWbemClassObject, lFlags, pCompareTo.pWbemClassObject);
			GC.KeepAlive(this);
			return result;
		}

		public int GetPropertyOrigin_(string wszName, out string pstrClassName)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.GetPropertyOrigin_f(17, pWbemClassObject, wszName, out pstrClassName);
			GC.KeepAlive(this);
			return result;
		}

		public int InheritsFrom_(string strAncestor)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.InheritsFrom_f(18, pWbemClassObject, strAncestor);
			GC.KeepAlive(this);
			return result;
		}

		public int GetMethod_(string wszName, int lFlags, out IWbemClassObjectFreeThreaded ppInSignature, out IWbemClassObjectFreeThreaded ppOutSignature)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			IntPtr ppInSignature2;
			IntPtr ppOutSignature2;
			int num = WmiNetUtilsHelper.GetMethod_f(19, pWbemClassObject, wszName, lFlags, out ppInSignature2, out ppOutSignature2);
			ppInSignature = null;
			ppOutSignature = null;
			if (num >= 0)
			{
				if (ppInSignature2 != IntPtr.Zero)
				{
					ppInSignature = new IWbemClassObjectFreeThreaded(ppInSignature2);
				}
				if (ppOutSignature2 != IntPtr.Zero)
				{
					ppOutSignature = new IWbemClassObjectFreeThreaded(ppOutSignature2);
				}
			}
			GC.KeepAlive(this);
			return num;
		}

		public int PutMethod_(string wszName, int lFlags, IWbemClassObjectFreeThreaded pInSignature, IWbemClassObjectFreeThreaded pOutSignature)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.PutMethod_f(20, pWbemClassObject, wszName, lFlags, pInSignature, pOutSignature);
			GC.KeepAlive(this);
			return result;
		}

		public int DeleteMethod_(string wszName)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.DeleteMethod_f(21, pWbemClassObject, wszName);
			GC.KeepAlive(this);
			return result;
		}

		public int BeginMethodEnumeration_(int lEnumFlags)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.BeginMethodEnumeration_f(22, pWbemClassObject, lEnumFlags);
			GC.KeepAlive(this);
			return result;
		}

		public int NextMethod_(int lFlags, out string pstrName, out IWbemClassObjectFreeThreaded ppInSignature, out IWbemClassObjectFreeThreaded ppOutSignature)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			IntPtr ppInSignature2;
			IntPtr ppOutSignature2;
			int num = WmiNetUtilsHelper.NextMethod_f(23, pWbemClassObject, lFlags, out pstrName, out ppInSignature2, out ppOutSignature2);
			ppInSignature = null;
			ppOutSignature = null;
			if (num >= 0)
			{
				if (ppInSignature2 != IntPtr.Zero)
				{
					ppInSignature = new IWbemClassObjectFreeThreaded(ppInSignature2);
				}
				if (ppOutSignature2 != IntPtr.Zero)
				{
					ppOutSignature = new IWbemClassObjectFreeThreaded(ppOutSignature2);
				}
			}
			GC.KeepAlive(this);
			return num;
		}

		public int EndMethodEnumeration_()
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.EndMethodEnumeration_f(24, pWbemClassObject);
			GC.KeepAlive(this);
			return result;
		}

		public int GetMethodQualifierSet_(string wszMethod, out IWbemQualifierSetFreeThreaded ppQualSet)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			IntPtr ppQualSet2;
			int num = WmiNetUtilsHelper.GetMethodQualifierSet_f(25, pWbemClassObject, wszMethod, out ppQualSet2);
			if (num < 0)
			{
				ppQualSet = null;
			}
			else
			{
				ppQualSet = new IWbemQualifierSetFreeThreaded(ppQualSet2);
			}
			GC.KeepAlive(this);
			return num;
		}

		public int GetMethodOrigin_(string wszMethodName, out string pstrClassName)
		{
			if (pWbemClassObject == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.GetMethodOrigin_f(26, pWbemClassObject, wszMethodName, out pstrClassName);
			GC.KeepAlive(this);
			return result;
		}

		[DllImport("ole32.dll", PreserveSig = false)]
		private static extern IStream CreateStreamOnHGlobal(IntPtr hGlobal, int fDeleteOnRelease);

		[DllImport("ole32.dll", PreserveSig = false)]
		private static extern IntPtr GetHGlobalFromStream([In] IStream pstm);

		[DllImport("kernel32.dll")]
		private static extern IntPtr GlobalLock([In] IntPtr hGlobal);

		[DllImport("kernel32.dll")]
		private static extern int GlobalUnlock([In] IntPtr pData);

		[DllImport("ole32.dll", PreserveSig = false)]
		private static extern void CoMarshalInterface([In] IStream pStm, [In] ref Guid riid, [In] IntPtr Unk, [In] uint dwDestContext, [In] IntPtr pvDestContext, [In] uint mshlflags);

		[DllImport("ole32.dll", PreserveSig = false)]
		private static extern IntPtr CoUnmarshalInterface([In] IStream pStm, [In] ref Guid riid);
	}
	internal sealed class IWbemQualifierSetFreeThreaded : IDisposable
	{
		private const string SerializationBlobName = "flatWbemClassObject";

		private static readonly string name = typeof(IWbemQualifierSetFreeThreaded).FullName;

		public static Guid IID_IWbemClassObject = new Guid("DC12A681-737F-11CF-884D-00AA004B2E24");

		private IntPtr pWbemQualifierSet = IntPtr.Zero;

		public IWbemQualifierSetFreeThreaded(IntPtr pWbemQualifierSet)
		{
			this.pWbemQualifierSet = pWbemQualifierSet;
		}

		public void Dispose()
		{
			Dispose_(finalization: false);
		}

		private void Dispose_(bool finalization)
		{
			if (pWbemQualifierSet != IntPtr.Zero)
			{
				Marshal.Release(pWbemQualifierSet);
				pWbemQualifierSet = IntPtr.Zero;
			}
			if (!finalization)
			{
				GC.KeepAlive(this);
			}
			GC.SuppressFinalize(this);
		}

		~IWbemQualifierSetFreeThreaded()
		{
			Dispose_(finalization: true);
		}

		public int Get_(string wszName, int lFlags, ref object pVal, ref int plFlavor)
		{
			if (pWbemQualifierSet == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.QualifierGet_f(3, pWbemQualifierSet, wszName, lFlags, ref pVal, ref plFlavor);
			GC.KeepAlive(this);
			return result;
		}

		public int Put_(string wszName, ref object pVal, int lFlavor)
		{
			if (pWbemQualifierSet == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.QualifierPut_f(4, pWbemQualifierSet, wszName, ref pVal, lFlavor);
			GC.KeepAlive(this);
			return result;
		}

		public int Delete_(string wszName)
		{
			if (pWbemQualifierSet == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.QualifierDelete_f(5, pWbemQualifierSet, wszName);
			GC.KeepAlive(this);
			return result;
		}

		public int GetNames_(int lFlags, out string[] pNames)
		{
			if (pWbemQualifierSet == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.QualifierGetNames_f(6, pWbemQualifierSet, lFlags, out pNames);
			GC.KeepAlive(this);
			return result;
		}

		public int BeginEnumeration_(int lFlags)
		{
			if (pWbemQualifierSet == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.QualifierBeginEnumeration_f(7, pWbemQualifierSet, lFlags);
			GC.KeepAlive(this);
			return result;
		}

		public int Next_(int lFlags, out string pstrName, out object pVal, out int plFlavor)
		{
			if (pWbemQualifierSet == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.QualifierNext_f(8, pWbemQualifierSet, lFlags, out pstrName, out pVal, out plFlavor);
			GC.KeepAlive(this);
			return result;
		}

		public int EndEnumeration_()
		{
			if (pWbemQualifierSet == IntPtr.Zero)
			{
				throw new ObjectDisposedException(name);
			}
			int result = WmiNetUtilsHelper.QualifierEndEnumeration_f(9, pWbemQualifierSet);
			GC.KeepAlive(this);
			return result;
		}
	}
	internal class MarshalWbemObject : ICustomMarshaler
	{
		private string cookie;

		public static ICustomMarshaler GetInstance(string cookie)
		{
			return new MarshalWbemObject(cookie);
		}

		private MarshalWbemObject(string cookie)
		{
			this.cookie = cookie;
		}

		public void CleanUpManagedData(object obj)
		{
		}

		public void CleanUpNativeData(IntPtr pObj)
		{
		}

		public int GetNativeDataSize()
		{
			return -1;
		}

		public IntPtr MarshalManagedToNative(object obj)
		{
			return (IntPtr)obj;
		}

		public object MarshalNativeToManaged(IntPtr pObj)
		{
			return new IWbemClassObjectFreeThreaded(pObj);
		}
	}
	[ComImport]
	[InterfaceType(1)]
	[TypeLibType(512)]
	[Guid("DC12A681-737F-11CF-884D-00AA004B2E24")]
	internal interface IWbemClassObject_DoNotMarshal
	{
		[PreserveSig]
		int GetQualifierSet_([MarshalAs(UnmanagedType.Interface)] out IWbemQualifierSet_DoNotMarshal ppQualSet);

		[PreserveSig]
		int Get_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In][Out] ref object pVal, [In][Out] ref int pType, [In][Out] ref int plFlavor);

		[PreserveSig]
		int Put_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In] ref object pVal, [In] int Type);

		[PreserveSig]
		int Delete_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName);

		[PreserveSig]
		int GetNames_([In][MarshalAs(UnmanagedType.LPWStr)] string wszQualifierName, [In] int lFlags, [In] ref object pQualifierVal, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)] out string[] pNames);

		[PreserveSig]
		int BeginEnumeration_([In] int lEnumFlags);

		[PreserveSig]
		int Next_([In] int lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)] ref string strName, [In][Out] ref object pVal, [In][Out] ref int pType, [In][Out] ref int plFlavor);

		[PreserveSig]
		int EndEnumeration_();

		[PreserveSig]
		int GetPropertyQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)] string wszProperty, [MarshalAs(UnmanagedType.Interface)] out IWbemQualifierSet_DoNotMarshal ppQualSet);

		[PreserveSig]
		int Clone_([MarshalAs(UnmanagedType.Interface)] out IWbemClassObject_DoNotMarshal ppCopy);

		[PreserveSig]
		int GetObjectText_([In] int lFlags, [MarshalAs(UnmanagedType.BStr)] out string pstrObjectText);

		[PreserveSig]
		int SpawnDerivedClass_([In] int lFlags, [MarshalAs(UnmanagedType.Interface)] out IWbemClassObject_DoNotMarshal ppNewClass);

		[PreserveSig]
		int SpawnInstance_([In] int lFlags, [MarshalAs(UnmanagedType.Interface)] out IWbemClassObject_DoNotMarshal ppNewInstance);

		[PreserveSig]
		int CompareTo_([In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pCompareTo);

		[PreserveSig]
		int GetPropertyOrigin_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [MarshalAs(UnmanagedType.BStr)] out string pstrClassName);

		[PreserveSig]
		int InheritsFrom_([In][MarshalAs(UnmanagedType.LPWStr)] string strAncestor);

		[PreserveSig]
		int GetMethod_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [MarshalAs(UnmanagedType.Interface)] out IWbemClassObject_DoNotMarshal ppInSignature, [MarshalAs(UnmanagedType.Interface)] out IWbemClassObject_DoNotMarshal ppOutSignature);

		[PreserveSig]
		int PutMethod_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pInSignature, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pOutSignature);

		[PreserveSig]
		int DeleteMethod_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName);

		[PreserveSig]
		int BeginMethodEnumeration_([In] int lEnumFlags);

		[PreserveSig]
		int NextMethod_([In] int lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)] ref string pstrName, [In][Out][MarshalAs(UnmanagedType.Interface)] ref IWbemClassObject_DoNotMarshal ppInSignature, [In][Out][MarshalAs(UnmanagedType.Interface)] ref IWbemClassObject_DoNotMarshal ppOutSignature);

		[PreserveSig]
		int EndMethodEnumeration_();

		[PreserveSig]
		int GetMethodQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)] string wszMethod, [MarshalAs(UnmanagedType.Interface)] out IWbemQualifierSet_DoNotMarshal ppQualSet);

		[PreserveSig]
		int GetMethodOrigin_([In][MarshalAs(UnmanagedType.LPWStr)] string wszMethodName, [MarshalAs(UnmanagedType.BStr)] out string pstrClassName);
	}
	[ComImport]
	[InterfaceType(1)]
	[Guid("DC12A680-737F-11CF-884D-00AA004B2E24")]
	[TypeLibType(512)]
	internal interface IWbemQualifierSet_DoNotMarshal
	{
		[PreserveSig]
		int Get_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In][Out] ref object pVal, [In][Out] ref int plFlavor);

		[PreserveSig]
		int Put_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] ref object pVal, [In] int lFlavor);

		[PreserveSig]
		int Delete_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName);

		[PreserveSig]
		int GetNames_([In] int lFlags, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)] out string[] pNames);

		[PreserveSig]
		int BeginEnumeration_([In] int lFlags);

		[PreserveSig]
		int Next_([In] int lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)] ref string pstrName, [In][Out] ref object pVal, [In][Out] ref int plFlavor);

		[PreserveSig]
		int EndEnumeration_();
	}
	[ComImport]
	[InterfaceType(1)]
	[TypeLibType(512)]
	[Guid("DC12A687-737F-11CF-884D-00AA004B2E24")]
	internal interface IWbemLocator
	{
		[PreserveSig]
		int ConnectServer_([In][MarshalAs(UnmanagedType.BStr)] string strNetworkResource, [In][MarshalAs(UnmanagedType.BStr)] string strUser, [In] IntPtr strPassword, [In][MarshalAs(UnmanagedType.BStr)] string strLocale, [In] int lSecurityFlags, [In][MarshalAs(UnmanagedType.BStr)] string strAuthority, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IWbemServices ppNamespace);
	}
	[ComImport]
	[Guid("44ACA674-E8FC-11D0-A07C-00C04FB68820")]
	[TypeLibType(512)]
	[InterfaceType(1)]
	internal interface IWbemContext
	{
		[PreserveSig]
		int Clone_([MarshalAs(UnmanagedType.Interface)] out IWbemContext ppNewCopy);

		[PreserveSig]
		int GetNames_([In] int lFlags, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)] out string[] pNames);

		[PreserveSig]
		int BeginEnumeration_([In] int lFlags);

		[PreserveSig]
		int Next_([In] int lFlags, [MarshalAs(UnmanagedType.BStr)] out string pstrName, out object pValue);

		[PreserveSig]
		int EndEnumeration_();

		[PreserveSig]
		int SetValue_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In] ref object pValue);

		[PreserveSig]
		int GetValue_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, out object pValue);

		[PreserveSig]
		int DeleteValue_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags);

		[PreserveSig]
		int DeleteAll_();
	}
	[ComImport]
	[InterfaceType(1)]
	[TypeLibType(512)]
	[Guid("9556DC99-828C-11CF-A37E-00AA003240C7")]
	internal interface IWbemServices
	{
		[PreserveSig]
		int OpenNamespace_([In][MarshalAs(UnmanagedType.BStr)] string strNamespace, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][Out][MarshalAs(UnmanagedType.Interface)] ref IWbemServices ppWorkingNamespace, [In] IntPtr ppCallResult);

		[PreserveSig]
		int CancelAsyncCall_([In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pSink);

		[PreserveSig]
		int QueryObjectSink_([In] int lFlags, [MarshalAs(UnmanagedType.Interface)] out IWbemObjectSink ppResponseHandler);

		[PreserveSig]
		int GetObject_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "System.Management.MarshalWbemObject")] out IWbemClassObjectFreeThreaded ppObject, [In] IntPtr ppCallResult);

		[PreserveSig]
		int GetObjectAsync_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int PutClass_([In] IntPtr pObject, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult);

		[PreserveSig]
		int PutClassAsync_([In] IntPtr pObject, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int DeleteClass_([In][MarshalAs(UnmanagedType.BStr)] string strClass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult);

		[PreserveSig]
		int DeleteClassAsync_([In][MarshalAs(UnmanagedType.BStr)] string strClass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int CreateClassEnum_([In][MarshalAs(UnmanagedType.BStr)] string strSuperclass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum);

		[PreserveSig]
		int CreateClassEnumAsync_([In][MarshalAs(UnmanagedType.BStr)] string strSuperclass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int PutInstance_([In] IntPtr pInst, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult);

		[PreserveSig]
		int PutInstanceAsync_([In] IntPtr pInst, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int DeleteInstance_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult);

		[PreserveSig]
		int DeleteInstanceAsync_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int CreateInstanceEnum_([In][MarshalAs(UnmanagedType.BStr)] string strFilter, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum);

		[PreserveSig]
		int CreateInstanceEnumAsync_([In][MarshalAs(UnmanagedType.BStr)] string strFilter, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int ExecQuery_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum);

		[PreserveSig]
		int ExecQueryAsync_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int ExecNotificationQuery_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum);

		[PreserveSig]
		int ExecNotificationQueryAsync_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int ExecMethod_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In][MarshalAs(UnmanagedType.BStr)] string strMethodName, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr pInParams, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "System.Management.MarshalWbemObject")] out IWbemClassObjectFreeThreaded ppOutParams, [In] IntPtr ppCallResult);

		[PreserveSig]
		int ExecMethodAsync_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In][MarshalAs(UnmanagedType.BStr)] string strMethodName, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr pInParams, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);
	}
	[ComImport]
	[InterfaceType(1)]
	[TypeLibType(512)]
	[Guid("9556DC99-828C-11CF-A37E-00AA003240C7")]
	internal interface IWbemServices_Old
	{
		[PreserveSig]
		int OpenNamespace_([In][MarshalAs(UnmanagedType.BStr)] string strNamespace, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][Out][MarshalAs(UnmanagedType.Interface)] ref IWbemServices ppWorkingNamespace, [In] IntPtr ppCallResult);

		[PreserveSig]
		int CancelAsyncCall_([In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pSink);

		[PreserveSig]
		int QueryObjectSink_([In] int lFlags, [MarshalAs(UnmanagedType.Interface)] out IWbemObjectSink ppResponseHandler);

		[PreserveSig]
		int GetObject_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][Out][MarshalAs(UnmanagedType.Interface)] ref IWbemClassObject_DoNotMarshal ppObject, [In] IntPtr ppCallResult);

		[PreserveSig]
		int GetObjectAsync_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int PutClass_([In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pObject, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult);

		[PreserveSig]
		int PutClassAsync_([In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pObject, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int DeleteClass_([In][MarshalAs(UnmanagedType.BStr)] string strClass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult);

		[PreserveSig]
		int DeleteClassAsync_([In][MarshalAs(UnmanagedType.BStr)] string strClass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int CreateClassEnum_([In][MarshalAs(UnmanagedType.BStr)] string strSuperclass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum);

		[PreserveSig]
		int CreateClassEnumAsync_([In][MarshalAs(UnmanagedType.BStr)] string strSuperclass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int PutInstance_([In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pInst, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult);

		[PreserveSig]
		int PutInstanceAsync_([In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pInst, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int DeleteInstance_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult);

		[PreserveSig]
		int DeleteInstanceAsync_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int CreateInstanceEnum_([In][MarshalAs(UnmanagedType.BStr)] string strFilter, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum);

		[PreserveSig]
		int CreateInstanceEnumAsync_([In][MarshalAs(UnmanagedType.BStr)] string strFilter, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int ExecQuery_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum);

		[PreserveSig]
		int ExecQueryAsync_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int ExecNotificationQuery_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum);

		[PreserveSig]
		int ExecNotificationQueryAsync_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);

		[PreserveSig]
		int ExecMethod_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In][MarshalAs(UnmanagedType.BStr)] string strMethodName, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pInParams, [In][Out][MarshalAs(UnmanagedType.Interface)] ref IWbemClassObject_DoNotMarshal ppOutParams, [In] IntPtr ppCallResult);

		[PreserveSig]
		int ExecMethodAsync_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In][MarshalAs(UnmanagedType.BStr)] string strMethodName, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pInParams, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler);
	}
	[ComImport]
	[Guid("44ACA675-E8FC-11D0-A07C-00C04FB68820")]
	[TypeLibType(512)]
	[InterfaceType(1)]
	internal interface IWbemCallResult
	{
		[PreserveSig]
		int GetResultObject_([In] int lTimeout, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "System.Management.MarshalWbemObject")] out IWbemClassObjectFreeThreaded ppResultObject);

		[PreserveSig]
		int GetResultString_([In] int lTimeout, [MarshalAs(UnmanagedType.BStr)] out string pstrResultString);

		[PreserveSig]
		int GetResultServices_([In] int lTimeout, [MarshalAs(UnmanagedType.Interface)] out IWbemServices ppServices);

		[PreserveSig]
		int GetCallStatus_([In] int lTimeout, out int plStatus);
	}
	[ComImport]
	[TypeLibType(512)]
	[Guid("7C857801-7381-11CF-884D-00AA004B2E24")]
	[InterfaceType(1)]
	[SuppressUnmanagedCodeSecurity]
	internal interface IWbemObjectSink
	{
		[PreserveSig]
		[SuppressUnmanagedCodeSecurity]
		int Indicate_([In] int lObjectCount, [In][MarshalAs(UnmanagedType.LPArray)] IntPtr[] apObjArray);

		[PreserveSig]
		int SetStatus_([In] int lFlags, [In][MarshalAs(UnmanagedType.Error)] int hResult, [In][MarshalAs(UnmanagedType.BStr)] string strParam, [In] IntPtr pObjParam);
	}
	[ComImport]
	[InterfaceType(1)]
	[TypeLibType(512)]
	[Guid("027947E1-D731-11CE-A357-000000000001")]
	internal interface IEnumWbemClassObject
	{
		[PreserveSig]
		int Reset_();

		[PreserveSig]
		int Next_([In] int lTimeout, [In] uint uCount, [In][Out][MarshalAs(UnmanagedType.LPArray)] IWbemClassObject_DoNotMarshal[] apObjects, out uint puReturned);

		[PreserveSig]
		int NextAsync_([In] uint uCount, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pSink);

		[PreserveSig]
		int Clone_([MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum);

		[PreserveSig]
		int Skip_([In] int lTimeout, [In] uint nCount);
	}
	[ComImport]
	[InterfaceType(1)]
	[Guid("B7B31DF9-D515-11D3-A11C-00105A1F515A")]
	internal interface IWbemShutdown
	{
		[PreserveSig]
		int Shutdown_([In] int uReason, [In] uint uMaxMilliseconds, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx);
	}
	[ComImport]
	[InterfaceType(1)]
	[TypeLibType(512)]
	[Guid("BFBF883A-CAD7-11D3-A11B-00105A1F515A")]
	internal interface IWbemObjectTextSrc
	{
		[PreserveSig]
		int GetText_([In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pObj, [In] uint uObjTextFormat, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.BStr)] out string strText);

		[PreserveSig]
		int CreateFromText_([In] int lFlags, [In][MarshalAs(UnmanagedType.BStr)] string strText, [In] uint uObjTextFormat, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IWbemClassObject_DoNotMarshal pNewObj);
	}
	[ComImport]
	[Guid("49353C9A-516B-11D1-AEA6-00C04FB68820")]
	[TypeLibType(512)]
	[InterfaceType(1)]
	internal interface IWbemObjectAccess
	{
		[PreserveSig]
		int GetQualifierSet_([MarshalAs(UnmanagedType.Interface)] out IWbemQualifierSet_DoNotMarshal ppQualSet);

		[PreserveSig]
		int Get_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In][Out] ref object pVal, [In][Out] ref int pType, [In][Out] ref int plFlavor);

		[PreserveSig]
		int Put_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In] ref object pVal, [In] int Type);

		[PreserveSig]
		int Delete_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName);

		[PreserveSig]
		int GetNames_([In][MarshalAs(UnmanagedType.LPWStr)] string wszQualifierName, [In] int lFlags, [In] ref object pQualifierVal, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)] out string[] pNames);

		[PreserveSig]
		int BeginEnumeration_([In] int lEnumFlags);

		[PreserveSig]
		int Next_([In] int lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)] ref string strName, [In][Out] ref object pVal, [In][Out] ref int pType, [In][Out] ref int plFlavor);

		[PreserveSig]
		int EndEnumeration_();

		[PreserveSig]
		int GetPropertyQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)] string wszProperty, [MarshalAs(UnmanagedType.Interface)] out IWbemQualifierSet_DoNotMarshal ppQualSet);

		[PreserveSig]
		int Clone_([MarshalAs(UnmanagedType.Interface)] out IWbemClassObject_DoNotMarshal ppCopy);

		[PreserveSig]
		int GetObjectText_([In] int lFlags, [MarshalAs(UnmanagedType.BStr)] out string pstrObjectText);

		[PreserveSig]
		int SpawnDerivedClass_([In] int lFlags, [MarshalAs(UnmanagedType.Interface)] out IWbemClassObject_DoNotMarshal ppNewClass);

		[PreserveSig]
		int SpawnInstance_([In] int lFlags, [MarshalAs(UnmanagedType.Interface)] out IWbemClassObject_DoNotMarshal ppNewInstance);

		[PreserveSig]
		int CompareTo_([In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pCompareTo);

		[PreserveSig]
		int GetPropertyOrigin_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [MarshalAs(UnmanagedType.BStr)] out string pstrClassName);

		[PreserveSig]
		int InheritsFrom_([In][MarshalAs(UnmanagedType.LPWStr)] string strAncestor);

		[PreserveSig]
		int GetMethod_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [MarshalAs(UnmanagedType.Interface)] out IWbemClassObject_DoNotMarshal ppInSignature, [MarshalAs(UnmanagedType.Interface)] out IWbemClassObject_DoNotMarshal ppOutSignature);

		[PreserveSig]
		int PutMethod_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pInSignature, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pOutSignature);

		[PreserveSig]
		int DeleteMethod_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName);

		[PreserveSig]
		int BeginMethodEnumeration_([In] int lEnumFlags);

		[PreserveSig]
		int NextMethod_([In] int lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)] ref string pstrName, [In][Out][MarshalAs(UnmanagedType.Interface)] ref IWbemClassObject_DoNotMarshal ppInSignature, [In][Out][MarshalAs(UnmanagedType.Interface)] ref IWbemClassObject_DoNotMarshal ppOutSignature);

		[PreserveSig]
		int EndMethodEnumeration_();

		[PreserveSig]
		int GetMethodQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)] string wszMethod, [MarshalAs(UnmanagedType.Interface)] out IWbemQualifierSet_DoNotMarshal ppQualSet);

		[PreserveSig]
		int GetMethodOrigin_([In][MarshalAs(UnmanagedType.LPWStr)] string wszMethodName, [MarshalAs(UnmanagedType.BStr)] out string pstrClassName);

		[PreserveSig]
		int GetPropertyHandle_([In][MarshalAs(UnmanagedType.LPWStr)] string wszPropertyName, out int pType, out int plHandle);

		[PreserveSig]
		int WritePropertyValue_([In] int lHandle, [In] int lNumBytes, [In] ref byte aData);

		[PreserveSig]
		int ReadPropertyValue_([In] int lHandle, [In] int lBufferSize, out int plNumBytes, out byte aData);

		[PreserveSig]
		int ReadDWORD_([In] int lHandle, out uint pdw);

		[PreserveSig]
		int WriteDWORD_([In] int lHandle, [In] uint dw);

		[PreserveSig]
		int ReadQWORD_([In] int lHandle, out ulong pqw);

		[PreserveSig]
		int WriteQWORD_([In] int lHandle, [In] ulong pw);

		[PreserveSig]
		int GetPropertyInfoByHandle_([In] int lHandle, [MarshalAs(UnmanagedType.BStr)] out string pstrName, out int pType);

		[PreserveSig]
		int Lock_([In] int lFlags);

		[PreserveSig]
		int Unlock_([In] int lFlags);
	}
	[ComImport]
	[Guid("1CFABA8C-1523-11D1-AD79-00C04FD8FDFF")]
	[TypeLibType(512)]
	[InterfaceType(1)]
	internal interface IUnsecuredApartment
	{
		[PreserveSig]
		int CreateObjectStub_([In][MarshalAs(UnmanagedType.IUnknown)] object pObject, [MarshalAs(UnmanagedType.IUnknown)] out object ppStub);
	}
	[ComImport]
	[Guid("EB87E1BC-3233-11D2-AEC9-00C04FB68820")]
	[InterfaceType(1)]
	internal interface IWbemStatusCodeText
	{
		[PreserveSig]
		int GetErrorCodeText_([In][MarshalAs(UnmanagedType.Error)] int hRes, [In] uint LocaleId, [In] int lFlags, [MarshalAs(UnmanagedType.BStr)] out string MessageText);

		[PreserveSig]
		int GetFacilityCodeText_([In][MarshalAs(UnmanagedType.Error)] int hRes, [In] uint LocaleId, [In] int lFlags, [MarshalAs(UnmanagedType.BStr)] out string MessageText);
	}
	[ComImport]
	[InterfaceType(1)]
	[TypeLibType(512)]
	[Guid("E246107B-B06E-11D0-AD61-00C04FD8FDFF")]
	internal interface IWbemUnboundObjectSink
	{
		[PreserveSig]
		int IndicateToConsumer_([In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pLogicalConsumer, [In] int lNumObjects, [In][MarshalAs(UnmanagedType.Interface)] ref IWbemClassObject_DoNotMarshal apObjects);
	}
	[ComImport]
	[InterfaceType(1)]
	[Guid("CE61E841-65BC-11D0-B6BD-00AA003240C7")]
	[TypeLibType(512)]
	internal interface IWbemPropertyProvider
	{
		[PreserveSig]
		int GetProperty_([In] int lFlags, [In][MarshalAs(UnmanagedType.BStr)] string strLocale, [In][MarshalAs(UnmanagedType.BStr)] string strClassMapping, [In][MarshalAs(UnmanagedType.BStr)] string strInstMapping, [In][MarshalAs(UnmanagedType.BStr)] string strPropMapping, out object pvValue);

		[PreserveSig]
		int PutProperty_([In] int lFlags, [In][MarshalAs(UnmanagedType.BStr)] string strLocale, [In][MarshalAs(UnmanagedType.BStr)] string strClassMapping, [In][MarshalAs(UnmanagedType.BStr)] string strInstMapping, [In][MarshalAs(UnmanagedType.BStr)] string strPropMapping, [In] ref object pvValue);
	}
	[ComImport]
	[InterfaceType(1)]
	[TypeLibType(512)]
	[Guid("E245105B-B06E-11D0-AD61-00C04FD8FDFF")]
	internal interface IWbemEventProvider
	{
		[PreserveSig]
		int ProvideEvents_([In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pSink, [In] int lFlags);
	}
	[ComImport]
	[Guid("580ACAF8-FA1C-11D0-AD72-00C04FD8FDFF")]
	[TypeLibType(512)]
	[InterfaceType(1)]
	internal interface IWbemEventProviderQuerySink
	{
		[PreserveSig]
		int NewQuery_([In] uint dwId, [In][MarshalAs(UnmanagedType.LPWStr)] string wszQueryLanguage, [In][MarshalAs(UnmanagedType.LPWStr)] string wszQuery);

		[PreserveSig]
		int CancelQuery_([In] uint dwId);
	}
	[ComImport]
	[InterfaceType(1)]
	[TypeLibType(512)]
	[Guid("631F7D96-D993-11D2-B339-00105A1F4AAF")]
	internal interface IWbemEventProviderSecurity
	{
		[PreserveSig]
		int AccessCheck_([In][MarshalAs(UnmanagedType.LPWStr)] string wszQueryLanguage, [In][MarshalAs(UnmanagedType.LPWStr)] string wszQuery, [In] int lSidLength, [In] ref byte pSid);
	}
	[ComImport]
	[Guid("631F7D97-D993-11D2-B339-00105A1F4AAF")]
	[TypeLibType(512)]
	[InterfaceType(1)]
	internal interface IWbemProviderIdentity
	{
		[PreserveSig]
		int SetRegistrationObject_([In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pProvReg);
	}
	[ComImport]
	[InterfaceType(1)]
	[TypeLibType(512)]
	[Guid("E246107A-B06E-11D0-AD61-00C04FD8FDFF")]
	internal interface IWbemEventConsumerProvider
	{
		[PreserveSig]
		int FindConsumer_([In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pLogicalConsumer, [MarshalAs(UnmanagedType.Interface)] out IWbemUnboundObjectSink ppConsumer);
	}
	[ComImport]
	[Guid("1BE41571-91DD-11D1-AEB2-00C04FB68820")]
	[InterfaceType(1)]
	internal interface IWbemProviderInitSink
	{
		[PreserveSig]
		int SetStatus_([In] int lStatus, [In] int lFlags);
	}
	[ComImport]
	[Guid("1BE41572-91DD-11D1-AEB2-00C04FB68820")]
	[InterfaceType(1)]
	internal interface IWbemProviderInit
	{
		[PreserveSig]
		int Initialize_([In][MarshalAs(UnmanagedType.LPWStr)] string wszUser, [In] int lFlags, [In][MarshalAs(UnmanagedType.LPWStr)] string wszNamespace, [In][MarshalAs(UnmanagedType.LPWStr)] string wszLocale, [In][MarshalAs(UnmanagedType.Interface)] IWbemServices pNamespace, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemProviderInitSink pInitSink);
	}
	[ComImport]
	[InterfaceType(1)]
	[Guid("1005CBCF-E64F-4646-BCD3-3A089D8A84B4")]
	internal interface IWbemDecoupledRegistrar
	{
		[PreserveSig]
		int Register_([In] int flags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext context, [In][MarshalAs(UnmanagedType.LPWStr)] string user, [In][MarshalAs(UnmanagedType.LPWStr)] string locale, [In][MarshalAs(UnmanagedType.LPWStr)] string scope, [In][MarshalAs(UnmanagedType.LPWStr)] string registration, [In][MarshalAs(UnmanagedType.IUnknown)] object unknown);

		[PreserveSig]
		int UnRegister_();
	}
	[ComImport]
	[InterfaceType(1)]
	[TypeLibType(512)]
	[Guid("3AE0080A-7E3A-4366-BF89-0FEEDC931659")]
	internal interface IWbemEventSink
	{
		[PreserveSig]
		int Indicate_([In] int lObjectCount, [In][MarshalAs(UnmanagedType.Interface)] ref IWbemClassObject_DoNotMarshal apObjArray);

		[PreserveSig]
		int SetStatus_([In] int lFlags, [In][MarshalAs(UnmanagedType.Error)] int hResult, [In][MarshalAs(UnmanagedType.BStr)] string strParam, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pObjParam);

		[PreserveSig]
		int IndicateWithSD_([In] int lNumObjects, [In][MarshalAs(UnmanagedType.IUnknown)] ref object apObjects, [In] int lSDLength, [In] ref byte pSD);

		[PreserveSig]
		int SetSinkSecurity_([In] int lSDLength, [In] ref byte pSD);

		[PreserveSig]
		int IsActive_();

		[PreserveSig]
		int GetRestrictedSink_([In] int lNumQueries, [In][MarshalAs(UnmanagedType.LPWStr)] ref string awszQueries, [In][MarshalAs(UnmanagedType.IUnknown)] object pCallback, [MarshalAs(UnmanagedType.Interface)] out IWbemEventSink ppSink);

		[PreserveSig]
		int SetBatchingParameters_([In] int lFlags, [In] uint dwMaxBufferSize, [In] uint dwMaxSendLatency);
	}
	[ComImport]
	[Guid("9AE62877-7544-4BB0-AA26-A13824659ED6")]
	[InterfaceType(1)]
	internal interface IWbemPathKeyList
	{
		[PreserveSig]
		int GetCount_(out uint puKeyCount);

		[PreserveSig]
		int SetKey_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] uint uFlags, [In] uint uCimType, [In] IntPtr pKeyVal);

		[PreserveSig]
		int SetKey2_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] uint uFlags, [In] uint uCimType, [In] ref object pKeyVal);

		[PreserveSig]
		int GetKey_([In] uint uKeyIx, [In] uint uFlags, [In][Out] ref uint puNameBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)] string pszKeyName, [In][Out] ref uint puKeyValBufSize, [In][Out] IntPtr pKeyVal, out uint puApparentCimType);

		[PreserveSig]
		int GetKey2_([In] uint uKeyIx, [In] uint uFlags, [In][Out] ref uint puNameBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)] string pszKeyName, [In][Out] ref object pKeyValue, out uint puApparentCimType);

		[PreserveSig]
		int RemoveKey_([In][MarshalAs(UnmanagedType.LPWStr)] string wszName, [In] uint uFlags);

		[PreserveSig]
		int RemoveAllKeys_([In] uint uFlags);

		[PreserveSig]
		int MakeSingleton_([In] sbyte bSet);

		[PreserveSig]
		int GetInfo_([In] uint uRequestedInfo, out ulong puResponse);

		[PreserveSig]
		int GetText_([In] int lFlags, [In][Out] ref uint puBuffLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)] string pszText);
	}
	[ComImport]
	[Guid("3BC15AF2-736C-477E-9E51-238AF8667DCC")]
	[InterfaceType(1)]
	internal interface IWbemPath
	{
		[PreserveSig]
		int SetText_([In] uint uMode, [In][MarshalAs(UnmanagedType.LPWStr)] string pszPath);

		[PreserveSig]
		int GetText_([In] int lFlags, [In][Out] ref uint puBuffLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)] string pszText);

		[PreserveSig]
		int GetInfo_([In] uint uRequestedInfo, out ulong puResponse);

		[PreserveSig]
		int SetServer_([In][MarshalAs(UnmanagedType.LPWStr)] string Name);

		[PreserveSig]
		int GetServer_([In][Out] ref uint puNameBufLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)] string pName);

		[PreserveSig]
		int GetNamespaceCount_(out uint puCount);

		[PreserveSig]
		int SetNamespaceAt_([In] uint uIndex, [In][MarshalAs(UnmanagedType.LPWStr)] string pszName);

		[PreserveSig]
		int GetNamespaceAt_([In] uint uIndex, [In][Out] ref uint puNameBufLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)] string pName);

		[PreserveSig]
		int RemoveNamespaceAt_([In] uint uIndex);

		[PreserveSig]
		int RemoveAllNamespaces_();

		[PreserveSig]
		int GetScopeCount_(out uint puCount);

		[PreserveSig]
		int SetScope_([In] uint uIndex, [In][MarshalAs(UnmanagedType.LPWStr)] string pszClass);

		[PreserveSig]
		int SetScopeFromText_([In] uint uIndex, [In][MarshalAs(UnmanagedType.LPWStr)] string pszText);

		[PreserveSig]
		int GetScope_([In] uint uIndex, [In][Out] ref uint puClassNameBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)] string pszClass, [MarshalAs(UnmanagedType.Interface)] out IWbemPathKeyList pKeyList);

		[PreserveSig]
		int GetScopeAsText_([In] uint uIndex, [In][Out] ref uint puTextBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)] string pszText);

		[PreserveSig]
		int RemoveScope_([In] uint uIndex);

		[PreserveSig]
		int RemoveAllScopes_();

		[PreserveSig]
		int SetClassName_([In][MarshalAs(UnmanagedType.LPWStr)] string Name);

		[PreserveSig]
		int GetClassName_([In][Out] ref uint puBuffLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)] string pszName);

		[PreserveSig]
		int GetKeyList_([MarshalAs(UnmanagedType.Interface)] out IWbemPathKeyList pOut);

		[PreserveSig]
		int CreateClassPart_([In] int lFlags, [In][MarshalAs(UnmanagedType.LPWStr)] string Name);

		[PreserveSig]
		int DeleteClassPart_([In] int lFlags);

		[PreserveSig]
		int IsRelative_([In][MarshalAs(UnmanagedType.LPWStr)] string wszMachine, [In][MarshalAs(UnmanagedType.LPWStr)] string wszNamespace);

		[PreserveSig]
		int IsRelativeOrChild_([In][MarshalAs(UnmanagedType.LPWStr)] string wszMachine, [In][MarshalAs(UnmanagedType.LPWStr)] string wszNamespace, [In] int lFlags);

		[PreserveSig]
		int IsLocal_([In][MarshalAs(UnmanagedType.LPWStr)] string wszMachine);

		[PreserveSig]
		int IsSameClassName_([In][MarshalAs(UnmanagedType.LPWStr)] string wszClass);
	}
	internal enum tag_WBEM_GENUS_TYPE
	{
		WBEM_GENUS_CLASS = 1,
		WBEM_GENUS_INSTANCE
	}
	internal enum tag_WBEM_CHANGE_FLAG_TYPE
	{
		WBEM_FLAG_CREATE_OR_UPDATE = 0,
		WBEM_FLAG_UPDATE_ONLY = 1,
		WBEM_FLAG_CREATE_ONLY = 2,
		WBEM_FLAG_UPDATE_COMPATIBLE = 0,
		WBEM_FLAG_UPDATE_SAFE_MODE = 32,
		WBEM_FLAG_UPDATE_FORCE_MODE = 64,
		WBEM_MASK_UPDATE_MODE = 96,
		WBEM_FLAG_ADVISORY = 65536
	}
	internal enum tag_WBEM_GENERIC_FLAG_TYPE
	{
		WBEM_FLAG_RETURN_IMMEDIATELY = 16,
		WBEM_FLAG_RETURN_WBEM_COMPLETE = 0,
		WBEM_FLAG_BIDIRECTIONAL = 0,
		WBEM_FLAG_FORWARD_ONLY = 32,
		WBEM_FLAG_NO_ERROR_OBJECT = 64,
		WBEM_FLAG_RETURN_ERROR_OBJECT = 0,
		WBEM_FLAG_SEND_STATUS = 128,
		WBEM_FLAG_DONT_SEND_STATUS = 0,
		WBEM_FLAG_ENSURE_LOCATABLE = 256,
		WBEM_FLAG_DIRECT_READ = 512,
		WBEM_FLAG_SEND_ONLY_SELECTED = 0,
		WBEM_RETURN_WHEN_COMPLETE = 0,
		WBEM_RETURN_IMMEDIATELY = 16,
		WBEM_MASK_RESERVED_FLAGS = 126976,
		WBEM_FLAG_USE_AMENDED_QUALIFIERS = 131072,
		WBEM_FLAG_STRONG_VALIDATION = 1048576
	}
	internal enum tag_WBEM_STATUS_TYPE
	{
		WBEM_STATUS_COMPLETE,
		WBEM_STATUS_REQUIREMENTS,
		WBEM_STATUS_PROGRESS
	}
	internal enum tag_WBEM_TIMEOUT_TYPE
	{
		WBEM_NO_WAIT = 0,
		WBEM_INFINITE = -1
	}
	internal enum tag_WBEM_CONDITION_FLAG_TYPE
	{
		WBEM_FLAG_ALWAYS = 0,
		WBEM_FLAG_ONLY_IF_TRUE = 1,
		WBEM_FLAG_ONLY_IF_FALSE = 2,
		WBEM_FLAG_ONLY_IF_IDENTICAL = 3,
		WBEM_MASK_PRIMARY_CONDITION = 3,
		WBEM_FLAG_KEYS_ONLY = 4,
		WBEM_FLAG_REFS_ONLY = 8,
		WBEM_FLAG_LOCAL_ONLY = 16,
		WBEM_FLAG_PROPAGATED_ONLY = 32,
		WBEM_FLAG_SYSTEM_ONLY = 48,
		WBEM_FLAG_NONSYSTEM_ONLY = 64,
		WBEM_MASK_CONDITION_ORIGIN = 112,
		WBEM_FLAG_CLASS_OVERRIDES_ONLY = 256,
		WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES = 512,
		WBEM_MASK_CLASS_CONDITION = 768
	}
	internal enum tag_WBEM_FLAVOR_TYPE
	{
		WBEM_FLAVOR_DONT_PROPAGATE = 0,
		WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE = 1,
		WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS = 2,
		WBEM_FLAVOR_MASK_PROPAGATION = 15,
		WBEM_FLAVOR_OVERRIDABLE = 0,
		WBEM_FLAVOR_NOT_OVERRIDABLE = 16,
		WBEM_FLAVOR_MASK_PERMISSIONS = 16,
		WBEM_FLAVOR_ORIGIN_LOCAL = 0,
		WBEM_FLAVOR_ORIGIN_PROPAGATED = 32,
		WBEM_FLAVOR_ORIGIN_SYSTEM = 64,
		WBEM_FLAVOR_MASK_ORIGIN = 96,
		WBEM_FLAVOR_NOT_AMENDED = 0,
		WBEM_FLAVOR_AMENDED = 128,
		WBEM_FLAVOR_MASK_AMENDED = 128
	}
	internal enum tag_WBEM_QUERY_FLAG_TYPE
	{
		WBEM_FLAG_DEEP,
		WBEM_FLAG_SHALLOW,
		WBEM_FLAG_PROTOTYPE
	}
	internal enum tag_WBEM_SECURITY_FLAGS
	{
		WBEM_ENABLE = 1,
		WBEM_METHOD_EXECUTE = 2,
		WBEM_FULL_WRITE_REP = 4,
		WBEM_PARTIAL_WRITE_REP = 8,
		WBEM_WRITE_PROVIDER = 16,
		WBEM_REMOTE_ACCESS = 32,
		WBEM_RIGHT_SUBSCRIBE = 1,
		WBEM_RIGHT_PUBLISH = 1
	}
	internal enum tag_WBEM_LIMITATION_FLAG_TYPE
	{
		WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS = 0x10,
		WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS = 0x20
	}
	internal enum tag_WBEM_TEXT_FLAG_TYPE
	{
		WBEM_FLAG_NO_FLAVORS = 1
	}
	internal enum tag_WBEM_COMPARISON_FLAG
	{
		WBEM_COMPARISON_INCLUDE_ALL = 0,
		WBEM_FLAG_IGNORE_QUALIFIERS = 1,
		WBEM_FLAG_IGNORE_OBJECT_SOURCE = 2,
		WBEM_FLAG_IGNORE_DEFAULT_VALUES = 4,
		WBEM_FLAG_IGNORE_CLASS = 8,
		WBEM_FLAG_IGNORE_CASE = 0x10,
		WBEM_FLAG_IGNORE_FLAVOR = 0x20
	}
	internal enum tag_WBEM_LOCKING
	{
		WBEM_FLAG_ALLOW_READ = 1
	}
	internal enum tag_CIMTYPE_ENUMERATION
	{
		CIM_ILLEGAL = 4095,
		CIM_EMPTY = 0,
		CIM_SINT8 = 16,
		CIM_UINT8 = 17,
		CIM_SINT16 = 2,
		CIM_UINT16 = 18,
		CIM_SINT32 = 3,
		CIM_UINT32 = 19,
		CIM_SINT64 = 20,
		CIM_UINT64 = 21,
		CIM_REAL32 = 4,
		CIM_REAL64 = 5,
		CIM_BOOLEAN = 11,
		CIM_STRING = 8,
		CIM_DATETIME = 101,
		CIM_REFERENCE = 102,
		CIM_CHAR16 = 103,
		CIM_OBJECT = 13,
		CIM_FLAG_ARRAY = 8192
	}
	internal enum tag_WBEM_BACKUP_RESTORE_FLAGS
	{
		WBEM_FLAG_BACKUP_RESTORE_DEFAULT,
		WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN
	}
	internal enum tag_WBEM_REFRESHER_FLAGS
	{
		WBEM_FLAG_REFRESH_AUTO_RECONNECT,
		WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT
	}
	internal enum tag_WBEM_SHUTDOWN_FLAGS
	{
		WBEM_SHUTDOWN_UNLOAD_COMPONENT = 1,
		WBEM_SHUTDOWN_WMI,
		WBEM_SHUTDOWN_OS
	}
	internal enum tag_WBEMSTATUS_FORMAT
	{
		WBEMSTATUS_FORMAT_NEWLINE,
		WBEMSTATUS_FORMAT_NO_NEWLINE
	}
	internal enum tag_WBEMSTATUS
	{
		WBEM_NO_ERROR = 0,
		WBEM_S_NO_ERROR = 0,
		WBEM_S_SAME = 0,
		WBEM_S_FALSE = 1,
		WBEM_S_ALREADY_EXISTS = 262145,
		WBEM_S_RESET_TO_DEFAULT = 262146,
		WBEM_S_DIFFERENT = 262147,
		WBEM_S_TIMEDOUT = 262148,
		WBEM_S_NO_MORE_DATA = 262149,
		WBEM_S_OPERATION_CANCELLED = 262150,
		WBEM_S_PENDING = 262151,
		WBEM_S_DUPLICATE_OBJECTS = 262152,
		WBEM_S_ACCESS_DENIED = 262153,
		WBEM_S_PARTIAL_RESULTS = 262160,
		WBEM_S_NO_POSTHOOK = 262161,
		WBEM_S_POSTHOOK_WITH_BOTH = 262162,
		WBEM_S_POSTHOOK_WITH_NEW = 262163,
		WBEM_S_POSTHOOK_WITH_STATUS = 262164,
		WBEM_S_POSTHOOK_WITH_OLD = 262165,
		WBEM_S_REDO_PREHOOK_WITH_ORIGINAL_OBJECT = 262166,
		WBEM_S_SOURCE_NOT_AVAILABLE = 262167,
		WBEM_E_FAILED = -2147217407,
		WBEM_E_NOT_FOUND = -2147217406,
		WBEM_E_ACCESS_DENIED = -2147217405,
		WBEM_E_PROVIDER_FAILURE = -2147217404,
		WBEM_E_TYPE_MISMATCH = -2147217403,
		WBEM_E_OUT_OF_MEMORY = -2147217402,
		WBEM_E_INVALID_CONTEXT = -2147217401,
		WBEM_E_INVALID_PARAMETER = -2147217400,
		WBEM_E_NOT_AVAILABLE = -2147217399,
		WBEM_E_CRITICAL_ERROR = -2147217398,
		WBEM_E_INVALID_STREAM = -2147217397,
		WBEM_E_NOT_SUPPORTED = -2147217396,
		WBEM_E_INVALID_SUPERCLASS = -2147217395,
		WBEM_E_INVALID_NAMESPACE = -2147217394,
		WBEM_E_INVALID_OBJECT = -2147217393,
		WBEM_E_INVALID_CLASS = -2147217392,
		WBEM_E_PROVIDER_NOT_FOUND = -2147217391,
		WBEM_E_INVALID_PROVIDER_REGISTRATION = -2147217390,
		WBEM_E_PROVIDER_LOAD_FAILURE = -2147217389,
		WBEM_E_INITIALIZATION_FAILURE = -2147217388,
		WBEM_E_TRANSPORT_FAILURE = -2147217387,
		WBEM_E_INVALID_OPERATION = -2147217386,
		WBEM_E_INVALID_QUERY = -2147217385,
		WBEM_E_INVALID_QUERY_TYPE = -2147217384,
		WBEM_E_ALREADY_EXISTS = -2147217383,
		WBEM_E_OVERRIDE_NOT_ALLOWED = -2147217382,
		WBEM_E_PROPAGATED_QUALIFIER = -2147217381,
		WBEM_E_PROPAGATED_PROPERTY = -2147217380,
		WBEM_E_UNEXPECTED = -2147217379,
		WBEM_E_ILLEGAL_OPERATION = -2147217378,
		WBEM_E_CANNOT_BE_KEY = -2147217377,
		WBEM_E_INCOMPLETE_CLASS = -2147217376,
		WBEM_E_INVALID_SYNTAX = -2147217375,
		WBEM_E_NONDECORATED_OBJECT = -2147217374,
		WBEM_E_READ_ONLY = -2147217373,
		WBEM_E_PROVIDER_NOT_CAPABLE = -2147217372,
		WBEM_E_CLASS_HAS_CHILDREN = -2147217371,
		WBEM_E_CLASS_HAS_INSTANCES = -2147217370,
		WBEM_E_QUERY_NOT_IMPLEMENTED = -2147217369,
		WBEM_E_ILLEGAL_NULL = -2147217368,
		WBEM_E_INVALID_QUALIFIER_TYPE = -2147217367,
		WBEM_E_INVALID_PROPERTY_TYPE = -2147217366,
		WBEM_E_VALUE_OUT_OF_RANGE = -2147217365,
		WBEM_E_CANNOT_BE_SINGLETON = -2147217364,
		WBEM_E_INVALID_CIM_TYPE = -2147217363,
		WBEM_E_INVALID_METHOD = -2147217362,
		WBEM_E_INVALID_METHOD_PARAMETERS = -2147217361,
		WBEM_E_SYSTEM_PROPERTY = -2147217360,
		WBEM_E_INVALID_PROPERTY = -2147217359,
		WBEM_E_CALL_CANCELLED = -2147217358,
		WBEM_E_SHUTTING_DOWN = -2147217357,
		WBEM_E_PROPAGATED_METHOD = -2147217356,
		WBEM_E_UNSUPPORTED_PARAMETER = -2147217355,
		WBEM_E_MISSING_PARAMETER_ID = -2147217354,
		WBEM_E_INVALID_PARAMETER_ID = -2147217353,
		WBEM_E_NONCONSECUTIVE_PARAMETER_IDS = -2147217352,
		WBEM_E_PARAMETER_ID_ON_RETVAL = -2147217351,
		WBEM_E_INVALID_OBJECT_PATH = -2147217350,
		WBEM_E_OUT_OF_DISK_SPACE = -2147217349,
		WBEM_E_BUFFER_TOO_SMALL = -2147217348,
		WBEM_E_UNSUPPORTED_PUT_EXTENSION = -2147217347,
		WBEM_E_UNKNOWN_OBJECT_TYPE = -2147217346,
		WBEM_E_UNKNOWN_PACKET_TYPE = -2147217345,
		WBEM_E_MARSHAL_VERSION_MISMATCH = -2147217344,
		WBEM_E_MARSHAL_INVALID_SIGNATURE = -2147217343,
		WBEM_E_INVALID_QUALIFIER = -2147217342,
		WBEM_E_INVALID_DUPLICATE_PARAMETER = -2147217341,
		WBEM_E_TOO_MUCH_DATA = -2147217340,
		WBEM_E_SERVER_TOO_BUSY = -2147217339,
		WBEM_E_INVALID_FLAVOR = -2147217338,
		WBEM_E_CIRCULAR_REFERENCE = -2147217337,
		WBEM_E_UNSUPPORTED_CLASS_UPDATE = -2147217336,
		WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE = -2147217335,
		WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE = -2147217328,
		WBEM_E_TOO_MANY_PROPERTIES = -2147217327,
		WBEM_E_UPDATE_TYPE_MISMATCH = -2147217326,
		WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED = -2147217325,
		WBEM_E_UPDATE_PROPAGATED_METHOD = -2147217324,
		WBEM_E_METHOD_NOT_IMPLEMENTED = -2147217323,
		WBEM_E_METHOD_DISABLED = -2147217322,
		WBEM_E_REFRESHER_BUSY = -2147217321,
		WBEM_E_UNPARSABLE_QUERY = -2147217320,
		WBEM_E_NOT_EVENT_CLASS = -2147217319,
		WBEM_E_MISSING_GROUP_WITHIN = -2147217318,
		WBEM_E_MISSING_AGGREGATION_LIST = -2147217317,
		WBEM_E_PROPERTY_NOT_AN_OBJECT = -2147217316,
		WBEM_E_AGGREGATING_BY_OBJECT = -2147217315,
		WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY = -2147217313,
		WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING = -2147217312,
		WBEM_E_QUEUE_OVERFLOW = -2147217311,
		WBEM_E_PRIVILEGE_NOT_HELD = -2147217310,
		WBEM_E_INVALID_OPERATOR = -2147217309,
		WBEM_E_LOCAL_CREDENTIALS = -2147217308,
		WBEM_E_CANNOT_BE_ABSTRACT = -2147217307,
		WBEM_E_AMENDED_OBJECT = -2147217306,
		WBEM_E_CLIENT_TOO_SLOW = -2147217305,
		WBEM_E_NULL_SECURITY_DESCRIPTOR = -2147217304,
		WBEM_E_TIMED_OUT = -2147217303,
		WBEM_E_INVALID_ASSOCIATION = -2147217302,
		WBEM_E_AMBIGUOUS_OPERATION = -2147217301,
		WBEM_E_QUOTA_VIOLATION = -2147217300,
		WBEM_E_RESERVED_001 = -2147217299,
		WBEM_E_RESERVED_002 = -2147217298,
		WBEM_E_UNSUPPORTED_LOCALE = -2147217297,
		WBEM_E_HANDLE_OUT_OF_DATE = -2147217296,
		WBEM_E_CONNECTION_FAILED = -2147217295,
		WBEM_E_INVALID_HANDLE_REQUEST = -2147217294,
		WBEM_E_PROPERTY_NAME_TOO_WIDE = -2147217293,
		WBEM_E_CLASS_NAME_TOO_WIDE = -2147217292,
		WBEM_E_METHOD_NAME_TOO_WIDE = -2147217291,
		WBEM_E_QUALIFIER_NAME_TOO_WIDE = -2147217290,
		WBEM_E_RERUN_COMMAND = -2147217289,
		WBEM_E_DATABASE_VER_MISMATCH = -2147217288,
		WBEM_E_VETO_DELETE = -2147217287,
		WBEM_E_VETO_PUT = -2147217286,
		WBEM_E_INVALID_LOCALE = -2147217280,
		WBEM_E_PROVIDER_SUSPENDED = -2147217279,
		WBEM_E_SYNCHRONIZATION_REQUIRED = -2147217278,
		WBEM_E_NO_SCHEMA = -2147217277,
		WBEM_E_PROVIDER_ALREADY_REGISTERED = -2147217276,
		WBEM_E_PROVIDER_NOT_REGISTERED = -2147217275,
		WBEM_E_FATAL_TRANSPORT_ERROR = -2147217274,
		WBEM_E_ENCRYPTED_CONNECTION_REQUIRED = -2147217273,
		WBEM_E_PROVIDER_TIMED_OUT = -2147217272,
		WBEM_E_NO_KEY = -2147217271,
		WBEMESS_E_REGISTRATION_TOO_BROAD = -2147213311,
		WBEMESS_E_REGISTRATION_TOO_PRECISE = -2147213310,
		WBEMMOF_E_EXPECTED_QUALIFIER_NAME = -2147205119,
		WBEMMOF_E_EXPECTED_SEMI = -2147205118,
		WBEMMOF_E_EXPECTED_OPEN_BRACE = -2147205117,
		WBEMMOF_E_EXPECTED_CLOSE_BRACE = -2147205116,
		WBEMMOF_E_EXPECTED_CLOSE_BRACKET = -2147205115,
		WBEMMOF_E_EXPECTED_CLOSE_PAREN = -2147205114,
		WBEMMOF_E_ILLEGAL_CONSTANT_VALUE = -2147205113,
		WBEMMOF_E_EXPECTED_TYPE_IDENTIFIER = -2147205112,
		WBEMMOF_E_EXPECTED_OPEN_PAREN = -2147205111,
		WBEMMOF_E_UNRECOGNIZED_TOKEN = -2147205110,
		WBEMMOF_E_UNRECOGNIZED_TYPE = -2147205109,
		WBEMMOF_E_EXPECTED_PROPERTY_NAME = -2147205108,
		WBEMMOF_E_TYPEDEF_NOT_SUPPORTED = -2147205107,
		WBEMMOF_E_UNEXPECTED_ALIAS = -2147205106,
		WBEMMOF_E_UNEXPECTED_ARRAY_INIT = -2147205105,
		WBEMMOF_E_INVALID_AMENDMENT_SYNTAX = -2147205104,
		WBEMMOF_E_INVALID_DUPLICATE_AMENDMENT = -2147205103,
		WBEMMOF_E_INVALID_PRAGMA = -2147205102,
		WBEMMOF_E_INVALID_NAMESPACE_SYNTAX = -2147205101,
		WBEMMOF_E_EXPECTED_CLASS_NAME = -2147205100,
		WBEMMOF_E_TYPE_MISMATCH = -2147205099,
		WBEMMOF_E_EXPECTED_ALIAS_NAME = -2147205098,
		WBEMMOF_E_INVALID_CLASS_DECLARATION = -2147205097,
		WBEMMOF_E_INVALID_INSTANCE_DECLARATION = -2147205096,
		WBEMMOF_E_EXPECTED_DOLLAR = -2147205095,
		WBEMMOF_E_CIMTYPE_QUALIFIER = -2147205094,
		WBEMMOF_E_DUPLICATE_PROPERTY = -2147205093,
		WBEMMOF_E_INVALID_NAMESPACE_SPECIFICATION = -2147205092,
		WBEMMOF_E_OUT_OF_RANGE = -2147205091,
		WBEMMOF_E_INVALID_FILE = -2147205090,
		WBEMMOF_E_ALIASES_IN_EMBEDDED = -2147205089,
		WBEMMOF_E_NULL_ARRAY_ELEM = -2147205088,
		WBEMMOF_E_DUPLICATE_QUALIFIER = -2147205087,
		WBEMMOF_E_EXPECTED_FLAVOR_TYPE = -2147205086,
		WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES = -2147205085,
		WBEMMOF_E_MULTIPLE_ALIASES = -2147205084,
		WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2 = -2147205083,
		WBEMMOF_E_NO_ARRAYS_RETURNED = -2147205082,
		WBEMMOF_E_MUST_BE_IN_OR_OUT = -2147205081,
		WBEMMOF_E_INVALID_FLAGS_SYNTAX = -2147205080,
		WBEMMOF_E_EXPECTED_BRACE_OR_BAD_TYPE = -2147205079,
		WBEMMOF_E_UNSUPPORTED_CIMV22_QUAL_VALUE = -2147205078,
		WBEMMOF_E_UNSUPPORTED_CIMV22_DATA_TYPE = -2147205077,
		WBEMMOF_E_INVALID_DELETEINSTANCE_SYNTAX = -2147205076,
		WBEMMOF_E_INVALID_QUALIFIER_SYNTAX = -2147205075,
		WBEMMOF_E_QUALIFIER_USED_OUTSIDE_SCOPE = -2147205074,
		WBEMMOF_E_ERROR_CREATING_TEMP_FILE = -2147205073,
		WBEMMOF_E_ERROR_INVALID_INCLUDE_FILE = -2147205072,
		WBEMMOF_E_INVALID_DELETECLASS_SYNTAX = -2147205071
	}
	internal enum tag_WMI_OBJ_TEXT
	{
		WMI_OBJ_TEXT_CIM_DTD_2_0 = 1,
		WMI_OBJ_TEXT_WMI_DTD_2_0,
		WMI_OBJ_TEXT_WMI_EXT1,
		WMI_OBJ_TEXT_WMI_EXT2,
		WMI_OBJ_TEXT_WMI_EXT3,
		WMI_OBJ_TEXT_WMI_EXT4,
		WMI_OBJ_TEXT_WMI_EXT5,
		WMI_OBJ_TEXT_WMI_EXT6,
		WMI_OBJ_TEXT_WMI_EXT7,
		WMI_OBJ_TEXT_WMI_EXT8,
		WMI_OBJ_TEXT_WMI_EXT9,
		WMI_OBJ_TEXT_WMI_EXT10,
		WMI_OBJ_TEXT_LAST
	}
	internal enum tag_WBEM_COMPILER_OPTIONS
	{
		WBEM_FLAG_CHECK_ONLY = 1,
		WBEM_FLAG_AUTORECOVER = 2,
		WBEM_FLAG_WMI_CHECK = 4,
		WBEM_FLAG_CONSOLE_PRINT = 8,
		WBEM_FLAG_DONT_ADD_TO_LIST = 0x10,
		WBEM_FLAG_SPLIT_FILES = 0x20,
		WBEM_FLAG_CONNECT_REPOSITORY_ONLY = 0x40
	}
	internal enum tag_WBEM_CONNECT_OPTIONS
	{
		WBEM_FLAG_CONNECT_REPOSITORY_ONLY = 0x40,
		WBEM_FLAG_CONNECT_USE_MAX_WAIT = 0x80
	}
	internal enum tag_WBEM_PROVIDER_REQUIREMENTS_TYPE
	{
		WBEM_REQUIREMENTS_START_POSTFILTER,
		WBEM_REQUIREMENTS_STOP_POSTFILTER,
		WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS
	}
	internal enum tag_WBEM_EXTRA_RETURN_CODES
	{
		WBEM_S_INITIALIZED = 0,
		WBEM_S_LIMITED_SERVICE = 274433,
		WBEM_S_INDIRECTLY_UPDATED = 274434,
		WBEM_S_SUBJECT_TO_SDS = 274435,
		WBEM_E_RETRY_LATER = -2147209215,
		WBEM_E_RESOURCE_CONTENTION = -2147209214
	}
	internal enum tag_WBEM_PROVIDER_FLAGS
	{
		WBEM_FLAG_OWNER_UPDATE = 0x10000
	}
	internal enum tag_WBEM_INFORMATION_FLAG_TYPE
	{
		WBEM_FLAG_SHORT_NAME = 1,
		WBEM_FLAG_LONG_NAME
	}
	internal enum tag_WBEM_BATCH_TYPE
	{
		WBEM_FLAG_BATCH_IF_NEEDED,
		WBEM_FLAG_MUST_BATCH,
		WBEM_FLAG_MUST_NOT_BATCH
	}
	internal enum tag_WBEM_PATH_STATUS_FLAG
	{
		WBEMPATH_INFO_ANON_LOCAL_MACHINE = 1,
		WBEMPATH_INFO_HAS_MACHINE_NAME = 2,
		WBEMPATH_INFO_IS_CLASS_REF = 4,
		WBEMPATH_INFO_IS_INST_REF = 8,
		WBEMPATH_INFO_HAS_SUBSCOPES = 0x10,
		WBEMPATH_INFO_IS_COMPOUND = 0x20,
		WBEMPATH_INFO_HAS_V2_REF_PATHS = 0x40,
		WBEMPATH_INFO_HAS_IMPLIED_KEY = 0x80,
		WBEMPATH_INFO_CONTAINS_SINGLETON = 0x100,
		WBEMPATH_INFO_V1_COMPLIANT = 0x200,
		WBEMPATH_INFO_V2_COMPLIANT = 0x400,
		WBEMPATH_INFO_CIM_COMPLIANT = 0x800,
		WBEMPATH_INFO_IS_SINGLETON = 0x1000,
		WBEMPATH_INFO_IS_PARENT = 0x2000,
		WBEMPATH_INFO_SERVER_NAMESPACE_ONLY = 0x4000,
		WBEMPATH_INFO_NATIVE_PATH = 0x8000,
		WBEMPATH_INFO_WMI_PATH = 0x10000,
		WBEMPATH_INFO_PATH_HAD_SERVER = 0x20000
	}
	internal enum tag_WBEM_PATH_CREATE_FLAG
	{
		WBEMPATH_CREATE_ACCEPT_RELATIVE = 1,
		WBEMPATH_CREATE_ACCEPT_ABSOLUTE = 2,
		WBEMPATH_CREATE_ACCEPT_ALL = 4,
		WBEMPATH_TREAT_SINGLE_IDENT_AS_NS = 8
	}
	internal enum tag_WBEM_GET_TEXT_FLAGS
	{
		WBEMPATH_COMPRESSED = 1,
		WBEMPATH_GET_RELATIVE_ONLY = 2,
		WBEMPATH_GET_SERVER_TOO = 4,
		WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY = 8,
		WBEMPATH_GET_NAMESPACE_ONLY = 0x10,
		WBEMPATH_GET_ORIGINAL = 0x20
	}
	internal enum tag_WBEM_GET_KEY_FLAGS
	{
		WBEMPATH_TEXT = 1,
		WBEMPATH_QUOTEDTEXT
	}
	internal enum WMIQ_ANALYSIS_TYPE
	{
		WMIQ_ANALYSIS_RPN_SEQUENCE = 1,
		WMIQ_ANALYSIS_ASSOC_QUERY = 2,
		WMIQ_ANALYSIS_PROP_ANALYSIS_MATRIX = 3,
		WMIQ_ANALYSIS_QUERY_TEXT = 4,
		WMIQ_ANALYSIS_RESERVED = 134217728
	}
	internal enum __MIDL___MIDL_itf_wmi_0000_0001
	{
		WMIQ_ANALYSIS_RPN_SEQUENCE = 1,
		WMIQ_ANALYSIS_ASSOC_QUERY = 2,
		WMIQ_ANALYSIS_PROP_ANALYSIS_MATRIX = 3,
		WMIQ_ANALYSIS_QUERY_TEXT = 4,
		WMIQ_ANALYSIS_RESERVED = 134217728
	}
	internal enum WMIQ_RPN_TOKEN_FLAGS
	{
		WMIQ_RPN_TOKEN_EXPRESSION = 1,
		WMIQ_RPN_TOKEN_AND = 2,
		WMIQ_RPN_TOKEN_OR = 3,
		WMIQ_RPN_TOKEN_NOT = 4,
		WMIQ_RPN_OP_UNDEFINED = 0,
		WMIQ_RPN_OP_EQ = 1,
		WMIQ_RPN_OP_NE = 2,
		WMIQ_RPN_OP_GE = 3,
		WMIQ_RPN_OP_LE = 4,
		WMIQ_RPN_OP_LT = 5,
		WMIQ_RPN_OP_GT = 6,
		WMIQ_RPN_OP_LIKE = 7,
		WMIQ_RPN_OP_ISA = 8,
		WMIQ_RPN_OP_ISNOTA = 9,
		WMIQ_RPN_LEFT_PROPERTY_NAME = 1,
		WMIQ_RPN_RIGHT_PROPERTY_NAME = 2,
		WMIQ_RPN_CONST2 = 4,
		WMIQ_RPN_CONST = 8,
		WMIQ_RPN_RELOP = 16,
		WMIQ_RPN_LEFT_FUNCTION = 32,
		WMIQ_RPN_RIGHT_FUNCTION = 64,
		WMIQ_RPN_GET_TOKEN_TYPE = 1,
		WMIQ_RPN_GET_EXPR_SHAPE = 2,
		WMIQ_RPN_GET_LEFT_FUNCTION = 3,
		WMIQ_RPN_GET_RIGHT_FUNCTION = 4,
		WMIQ_RPN_GET_RELOP = 5,
		WMIQ_RPN_NEXT_TOKEN = 1,
		WMIQ_RPN_FROM_UNARY = 1,
		WMIQ_RPN_FROM_PATH = 2,
		WMIQ_RPN_FROM_CLASS_LIST = 4
	}
	internal enum __MIDL___MIDL_itf_wmi_0000_0002
	{
		WMIQ_RPN_TOKEN_EXPRESSION = 1,
		WMIQ_RPN_TOKEN_AND = 2,
		WMIQ_RPN_TOKEN_OR = 3,
		WMIQ_RPN_TOKEN_NOT = 4,
		WMIQ_RPN_OP_UNDEFINED = 0,
		WMIQ_RPN_OP_EQ = 1,
		WMIQ_RPN_OP_NE = 2,
		WMIQ_RPN_OP_GE = 3,
		WMIQ_RPN_OP_LE = 4,
		WMIQ_RPN_OP_LT = 5,
		WMIQ_RPN_OP_GT = 6,
		WMIQ_RPN_OP_LIKE = 7,
		WMIQ_RPN_OP_ISA = 8,
		WMIQ_RPN_OP_ISNOTA = 9,
		WMIQ_RPN_LEFT_PROPERTY_NAME = 1,
		WMIQ_RPN_RIGHT_PROPERTY_NAME = 2,
		WMIQ_RPN_CONST2 = 4,
		WMIQ_RPN_CONST = 8,
		WMIQ_RPN_RELOP = 16,
		WMIQ_RPN_LEFT_FUNCTION = 32,
		WMIQ_RPN_RIGHT_FUNCTION = 64,
		WMIQ_RPN_GET_TOKEN_TYPE = 1,
		WMIQ_RPN_GET_EXPR_SHAPE = 2,
		WMIQ_RPN_GET_LEFT_FUNCTION = 3,
		WMIQ_RPN_GET_RIGHT_FUNCTION = 4,
		WMIQ_RPN_GET_RELOP = 5,
		WMIQ_RPN_NEXT_TOKEN = 1,
		WMIQ_RPN_FROM_UNARY = 1,
		WMIQ_RPN_FROM_PATH = 2,
		WMIQ_RPN_FROM_CLASS_LIST = 4
	}
	internal enum WMIQ_ASSOCQ_FLAGS
	{
		WMIQ_ASSOCQ_ASSOCIATORS = 1,
		WMIQ_ASSOCQ_REFERENCES = 2,
		WMIQ_ASSOCQ_RESULTCLASS = 4,
		WMIQ_ASSOCQ_ASSOCCLASS = 8,
		WMIQ_ASSOCQ_ROLE = 0x10,
		WMIQ_ASSOCQ_RESULTROLE = 0x20,
		WMIQ_ASSOCQ_REQUIREDQUALIFIER = 0x40,
		WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER = 0x80,
		WMIQ_ASSOCQ_CLASSDEFSONLY = 0x100,
		WMIQ_ASSOCQ_KEYSONLY = 0x200,
		WMIQ_ASSOCQ_SCHEMAONLY = 0x400,
		WMIQ_ASSOCQ_CLASSREFSONLY = 0x800
	}
	internal enum __MIDL___MIDL_itf_wmi_0000_0003
	{
		WMIQ_ASSOCQ_ASSOCIATORS = 1,
		WMIQ_ASSOCQ_REFERENCES = 2,
		WMIQ_ASSOCQ_RESULTCLASS = 4,
		WMIQ_ASSOCQ_ASSOCCLASS = 8,
		WMIQ_ASSOCQ_ROLE = 0x10,
		WMIQ_ASSOCQ_RESULTROLE = 0x20,
		WMIQ_ASSOCQ_REQUIREDQUALIFIER = 0x40,
		WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER = 0x80,
		WMIQ_ASSOCQ_CLASSDEFSONLY = 0x100,
		WMIQ_ASSOCQ_KEYSONLY = 0x200,
		WMIQ_ASSOCQ_SCHEMAONLY = 0x400,
		WMIQ_ASSOCQ_CLASSREFSONLY = 0x800
	}
	internal enum tag_WMIQ_LANGUAGE_FEATURES
	{
		WMIQ_LF1_BASIC_SELECT = 1,
		WMIQ_LF2_CLASS_NAME_IN_QUERY = 2,
		WMIQ_LF3_STRING_CASE_FUNCTIONS = 3,
		WMIQ_LF4_PROP_TO_PROP_TESTS = 4,
		WMIQ_LF5_COUNT_STAR = 5,
		WMIQ_LF6_ORDER_BY = 6,
		WMIQ_LF7_DISTINCT = 7,
		WMIQ_LF8_ISA = 8,
		WMIQ_LF9_THIS = 9,
		WMIQ_LF10_COMPEX_SUBEXPRESSIONS = 10,
		WMIQ_LF11_ALIASING = 11,
		WMIQ_LF12_GROUP_BY_HAVING = 12,
		WMIQ_LF13_WMI_WITHIN = 13,
		WMIQ_LF14_SQL_WRITE_OPERATIONS = 14,
		WMIQ_LF15_GO = 15,
		WMIQ_LF16_SINGLE_LEVEL_TRANSACTIONS = 16,
		WMIQ_LF17_QUALIFIED_NAMES = 17,
		WMIQ_LF18_ASSOCIATONS = 18,
		WMIQ_LF19_SYSTEM_PROPERTIES = 19,
		WMIQ_LF20_EXTENDED_SYSTEM_PROPERTIES = 20,
		WMIQ_LF21_SQL89_JOINS = 21,
		WMIQ_LF22_SQL92_JOINS = 22,
		WMIQ_LF23_SUBSELECTS = 23,
		WMIQ_LF24_UMI_EXTENSIONS = 24,
		WMIQ_LF25_DATEPART = 25,
		WMIQ_LF26_LIKE = 26,
		WMIQ_LF27_CIM_TEMPORAL_CONSTRUCTS = 27,
		WMIQ_LF28_STANDARD_AGGREGATES = 28,
		WMIQ_LF29_MULTI_LEVEL_ORDER_BY = 29,
		WMIQ_LF30_WMI_PRAGMAS = 30,
		WMIQ_LF31_QUALIFIER_TESTS = 31,
		WMIQ_LF32_SP_EXECUTE = 32,
		WMIQ_LF33_ARRAY_ACCESS = 33,
		WMIQ_LF34_UNION = 34,
		WMIQ_LF35_COMPLEX_SELECT_TARGET = 35,
		WMIQ_LF36_REFERENCE_TESTS = 36,
		WMIQ_LF37_SELECT_INTO = 37,
		WMIQ_LF38_BASIC_DATETIME_TESTS = 38,
		WMIQ_LF39_COUNT_COLUMN = 39,
		WMIQ_LF40_BETWEEN = 40,
		WMIQ_LF_LAST = 40
	}
	internal enum tag_WMIQ_RPNQ_FEATURE
	{
		WMIQ_RPNF_WHERE_CLAUSE_PRESENT = 1,
		WMIQ_RPNF_QUERY_IS_CONJUNCTIVE = 2,
		WMIQ_RPNF_QUERY_IS_DISJUNCTIVE = 4,
		WMIQ_RPNF_PROJECTION = 8,
		WMIQ_RPNF_FEATURE_SELECT_STAR = 0x10,
		WMIQ_RPNF_EQUALITY_TESTS_ONLY = 0x20,
		WMIQ_RPNF_COUNT_STAR = 0x40,
		WMIQ_RPNF_QUALIFIED_NAMES_IN_SELECT = 0x80,
		WMIQ_RPNF_QUALIFIED_NAMES_IN_WHERE = 0x100,
		WMIQ_RPNF_PROP_TO_PROP_TESTS = 0x200,
		WMIQ_RPNF_ORDER_BY = 0x400,
		WMIQ_RPNF_ISA_USED = 0x800,
		WMIQ_RPNF_ISNOTA_USED = 0x1000,
		WMIQ_RPNF_GROUP_BY_HAVING = 0x2000,
		WMIQ_RPNF_WITHIN_INTERVAL = 0x4000,
		WMIQ_RPNF_WITHIN_AGGREGATE = 0x8000,
		WMIQ_RPNF_SYSPROP_CLASS = 0x10000,
		WMIQ_RPNF_REFERENCE_TESTS = 0x20000,
		WMIQ_RPNF_DATETIME_TESTS = 0x40000,
		WMIQ_RPNF_ARRAY_ACCESS = 0x80000,
		WMIQ_RPNF_QUALIFIER_FILTER = 0x100000,
		WMIQ_RPNF_SELECTED_FROM_PATH = 0x200000
	}
	[ComImport]
	[ClassInterface(0)]
	[Guid("4590F811-1D3A-11D0-891F-00AA004B2E24")]
	[TypeLibType(514)]
	internal class WbemLocator
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern WbemLocator();
	}
	[ComImport]
	[ClassInterface(0)]
	[Guid("674B6698-EE92-11D0-AD71-00C04FD8FDFF")]
	[TypeLibType(514)]
	internal class WbemContext
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern WbemContext();
	}
	[ComImport]
	[ClassInterface(0)]
	[Guid("49BD2028-1523-11D1-AD79-00C04FD8FDFF")]
	[TypeLibType(2)]
	internal class UnsecuredApartment
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern UnsecuredApartment();
	}
	[ComImport]
	[Guid("9A653086-174F-11D2-B5F9-00104B703EFD")]
	[ClassInterface(0)]
	[TypeLibType(2)]
	internal class WbemClassObject
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern WbemClassObject();
	}
	[ComImport]
	[ClassInterface(0)]
	[Guid("6DAF9757-2E37-11D2-AEC9-00C04FB68820")]
	[TypeLibType(2)]
	internal class MofCompiler
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern MofCompiler();
	}
	[ComImport]
	[ClassInterface(0)]
	[TypeLibType(2)]
	[Guid("EB87E1BD-3233-11D2-AEC9-00C04FB68820")]
	internal class WbemStatusCodeText
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern WbemStatusCodeText();
	}
	[ComImport]
	[Guid("C49E32C6-BC8B-11D2-85D4-00105A1F8304")]
	[ClassInterface(0)]
	[TypeLibType(2)]
	internal class WbemBackupRestore
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern WbemBackupRestore();
	}
	[ComImport]
	[ClassInterface(0)]
	[TypeLibType(514)]
	[Guid("8D1C559D-84F0-4BB3-A7D5-56A7435A9BA6")]
	internal class WbemObjectTextSrc
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern WbemObjectTextSrc();
	}
	[ComImport]
	[Guid("4CFC7932-0F9D-4BEF-9C32-8EA2A6B56FCB")]
	[TypeLibType(2)]
	[ClassInterface(0)]
	internal class WbemDecoupledRegistrar
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern WbemDecoupledRegistrar();
	}
	[ComImport]
	[Guid("F5F75737-2843-4F22-933D-C76A97CDA62F")]
	[TypeLibType(2)]
	[ClassInterface(0)]
	internal class WbemDecoupledBasicEventProvider
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern WbemDecoupledBasicEventProvider();
	}
	[ComImport]
	[ClassInterface(0)]
	[Guid("CF4CC405-E2C5-4DDD-B3CE-5E7582D8C9FA")]
	[TypeLibType(514)]
	internal class WbemDefPath
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern WbemDefPath();
	}
	[ComImport]
	[Guid("EAC8A024-21E2-4523-AD73-A71A0AA2F56A")]
	[ClassInterface(0)]
	[TypeLibType(2)]
	internal class WbemQuery
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern WbemQuery();
	}
	internal class MTAHelper
	{
		private class MTARequest
		{
			public AutoResetEvent evtDone = new AutoResetEvent(initialState: false);

			public Type typeToCreate;

			public object createdObject;

			public Exception exception;

			public MTARequest(Type typeToCreate)
			{
				this.typeToCreate = typeToCreate;
			}
		}

		private static ArrayList reqList = new ArrayList(3);

		private static object critSec = new object();

		private static AutoResetEvent evtGo = new AutoResetEvent(initialState: false);

		private static bool workerThreadInitialized = false;

		private static Guid IID_IObjectContext = new Guid("51372AE0-CAE7-11CF-BE81-00AA00A2FA25");

		private static Guid IID_IComThreadingInfo = new Guid("000001ce-0000-0000-C000-000000000046");

		private static bool CanCallCoGetObjectContext = IsWindows2000OrHigher();

		private static void InitWorkerThread()
		{
			Thread thread = new Thread(WorkerThread);
			thread.SetApartmentState(ApartmentState.MTA);
			thread.IsBackground = true;
			thread.Start();
		}

		public static object CreateInMTA(Type type)
		{
			if (IsNoContextMTA())
			{
				return Activator.CreateInstance(type);
			}
			MTARequest mTARequest = new MTARequest(type);
			lock (critSec)
			{
				if (!workerThreadInitialized)
				{
					InitWorkerThread();
					workerThreadInitialized = true;
				}
				int index = reqList.Add(mTARequest);
				if (!evtGo.Set())
				{
					reqList.RemoveAt(index);
					throw new ManagementException(RC.GetString("WORKER_THREAD_WAKEUP_FAILED"));
				}
			}
			mTARequest.evtDone.WaitOne();
			if (mTARequest.exception != null)
			{
				throw mTARequest.exception;
			}
			return mTARequest.createdObject;
		}

		private static void WorkerThread()
		{
			while (true)
			{
				evtGo.WaitOne();
				while (true)
				{
					MTARequest mTARequest = null;
					lock (critSec)
					{
						if (reqList.Count > 0)
						{
							mTARequest = (MTARequest)reqList[0];
							reqList.RemoveAt(0);
							goto IL_0054;
						}
					}
					break;
					IL_0054:
					try
					{
						mTARequest.createdObject = Activator.CreateInstance(mTARequest.typeToCreate);
					}
					catch (Exception exception)
					{
						Exception ex = (mTARequest.exception = exception);
					}
					finally
					{
						mTARequest.evtDone.Set();
					}
				}
			}
		}

		[DllImport("ole32.dll")]
		[SuppressUnmanagedCodeSecurity]
		private static extern int CoGetObjectContext([In] ref Guid riid, out IntPtr pUnk);

		public static bool IsNoContextMTA()
		{
			if (Thread.CurrentThread.GetApartmentState() != ApartmentState.MTA)
			{
				return false;
			}
			if (!CanCallCoGetObjectContext)
			{
				return true;
			}
			IntPtr pUnk = IntPtr.Zero;
			IntPtr ppv = IntPtr.Zero;
			try
			{
				if (CoGetObjectContext(ref IID_IComThreadingInfo, out pUnk) != 0)
				{
					return false;
				}
				if (WmiNetUtilsHelper.GetCurrentApartmentType_f(3, pUnk, out var aptType) != 0)
				{
					return false;
				}
				if (aptType != WmiNetUtilsHelper.APTTYPE.APTTYPE_MTA)
				{
					return false;
				}
				if (Marshal.QueryInterface(pUnk, ref IID_IObjectContext, out ppv) == 0)
				{
					return false;
				}
			}
			finally
			{
				if (pUnk != IntPtr.Zero)
				{
					Marshal.Release(pUnk);
				}
				if (ppv != IntPtr.Zero)
				{
					Marshal.Release(ppv);
				}
			}
			return true;
		}

		private static bool IsWindows2000OrHigher()
		{
			OperatingSystem oSVersion = Environment.OSVersion;
			if (oSVersion.Platform == PlatformID.Win32NT && oSVersion.Version >= new Version(5, 0))
			{
				return true;
			}
			return false;
		}
	}
	internal class ThreadDispatch
	{
		public delegate object ThreadWorkerMethodWithReturn();

		public delegate object ThreadWorkerMethodWithReturnAndParam(object param);

		public delegate void ThreadWorkerMethod();

		public delegate void ThreadWorkerMethodWithParam(object param);

		private Thread thread;

		private Exception exception;

		private ThreadWorkerMethodWithReturn threadWorkerMethodWithReturn;

		private ThreadWorkerMethodWithReturnAndParam threadWorkerMethodWithReturnAndParam;

		private ThreadWorkerMethod threadWorkerMethod;

		private ThreadWorkerMethodWithParam threadWorkerMethodWithParam;

		private object threadReturn;

		private object threadParams;

		private bool backgroundThread;

		private ApartmentState apartmentType;

		public Exception Exception => exception;

		public object Parameter
		{
			get
			{
				return threadParams;
			}
			set
			{
				threadParams = value;
			}
		}

		public bool IsBackgroundThread
		{
			get
			{
				return backgroundThread;
			}
			set
			{
				backgroundThread = value;
			}
		}

		public object Result => threadReturn;

		public ApartmentState ApartmentType
		{
			get
			{
				return apartmentType;
			}
			set
			{
				apartmentType = value;
			}
		}

		public ThreadDispatch(ThreadWorkerMethodWithReturn workerMethod)
			: this()
		{
			InitializeThreadState(null, workerMethod, ApartmentState.MTA, background: false);
		}

		public ThreadDispatch(ThreadWorkerMethodWithReturnAndParam workerMethod)
			: this()
		{
			InitializeThreadState(null, workerMethod, ApartmentState.MTA, background: false);
		}

		public ThreadDispatch(ThreadWorkerMethodWithParam workerMethod)
			: this()
		{
			InitializeThreadState(null, workerMethod, ApartmentState.MTA, background: false);
		}

		public ThreadDispatch(ThreadWorkerMethod workerMethod)
			: this()
		{
			InitializeThreadState(null, workerMethod, ApartmentState.MTA, background: false);
		}

		public void Start()
		{
			exception = null;
			DispatchThread();
			if (Exception != null)
			{
				throw Exception;
			}
		}

		private ThreadDispatch()
		{
			thread = null;
			exception = null;
			threadParams = null;
			threadWorkerMethodWithReturn = null;
			threadWorkerMethodWithReturnAndParam = null;
			threadWorkerMethod = null;
			threadWorkerMethodWithParam = null;
			threadReturn = null;
			backgroundThread = false;
			apartmentType = ApartmentState.MTA;
		}

		private void InitializeThreadState(object threadParams, ThreadWorkerMethodWithReturn workerMethod, ApartmentState aptState, bool background)
		{
			this.threadParams = threadParams;
			threadWorkerMethodWithReturn = workerMethod;
			thread = new Thread(ThreadEntryPointMethodWithReturn);
			thread.SetApartmentState(aptState);
			backgroundThread = background;
		}

		private void InitializeThreadState(object threadParams, ThreadWorkerMethodWithReturnAndParam workerMethod, ApartmentState aptState, bool background)
		{
			this.threadParams = threadParams;
			threadWorkerMethodWithReturnAndParam = workerMethod;
			thread = new Thread(ThreadEntryPointMethodWithReturnAndParam);
			thread.SetApartmentState(aptState);
			backgroundThread = background;
		}

		private void InitializeThreadState(object threadParams, ThreadWorkerMethod workerMethod, ApartmentState aptState, bool background)
		{
			this.threadParams = threadParams;
			threadWorkerMethod = workerMethod;
			thread = new Thread(ThreadEntryPoint);
			thread.SetApartmentState(aptState);
			backgroundThread = background;
		}

		private void InitializeThreadState(object threadParams, ThreadWorkerMethodWithParam workerMethod, ApartmentState aptState, bool background)
		{
			this.threadParams = threadParams;
			threadWorkerMethodWithParam = workerMethod;
			thread = new Thread(ThreadEntryPointMethodWithParam);
			thread.SetApartmentState(aptState);
			backgroundThread = background;
		}

		private void DispatchThread()
		{
			thread.Start();
			thread.Join();
		}

		private void ThreadEntryPoint()
		{
			try
			{
				threadWorkerMethod();
			}
			catch (Exception ex)
			{
				Exception ex2 = (exception = ex);
			}
		}

		private void ThreadEntryPointMethodWithParam()
		{
			try
			{
				threadWorkerMethodWithParam(threadParams);
			}
			catch (Exception ex)
			{
				Exception ex2 = (exception = ex);
			}
		}

		private void ThreadEntryPointMethodWithReturn()
		{
			try
			{
				threadReturn = threadWorkerMethodWithReturn();
			}
			catch (Exception ex)
			{
				Exception ex2 = (exception = ex);
			}
		}

		private void ThreadEntryPointMethodWithReturnAndParam()
		{
			try
			{
				threadReturn = threadWorkerMethodWithReturnAndParam(threadParams);
			}
			catch (Exception ex)
			{
				Exception ex2 = (exception = ex);
			}
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRDescriptionAttribute : DescriptionAttribute
	{
		private bool replaced;

		public override string Description
		{
			get
			{
				if (!replaced)
				{
					replaced = true;
					base.DescriptionValue = SR.GetString(base.Description);
				}
				return base.Description;
			}
		}

		public SRDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRCategoryAttribute : CategoryAttribute
	{
		public SRCategoryAttribute(string category)
			: base(category)
		{
		}

		protected override string GetLocalizedString(string value)
		{
			return SR.GetString(value);
		}
	}
	internal sealed class SR
	{
		internal const string ASSEMBLY_NOT_REGISTERED = "ASSEMBLY_NOT_REGISTERED";

		internal const string FAILED_TO_BUILD_GENERATED_ASSEMBLY = "FAILED_TO_BUILD_GENERATED_ASSEMBLY";

		internal const string COMMENT_SHOULDSERIALIZE = "COMMENT_SHOULDSERIALIZE";

		internal const string COMMENT_ISPROPNULL = "COMMENT_ISPROPNULL";

		internal const string COMMENT_RESETPROP = "COMMENT_RESETPROP";

		internal const string COMMENT_DATECONVFUNC = "COMMENT_DATECONVFUNC";

		internal const string COMMENT_TIMESPANCONVFUNC = "COMMENT_TIMESPANCONVFUNC";

		internal const string COMMENT_ATTRIBPROP = "COMMENT_ATTRIBPROP";

		internal const string COMMENT_GETINSTANCES = "COMMENT_GETINSTANCES";

		internal const string COMMENT_CLASSBEGIN = "COMMENT_CLASSBEGIN";

		internal const string COMMENT_PRIVAUTOCOMMIT = "COMMENT_PRIVAUTOCOMMIT";

		internal const string COMMENT_CONSTRUCTORS = "COMMENT_CONSTRUCTORS";

		internal const string COMMENT_ORIGNAMESPACE = "COMMENT_ORIGNAMESPACE";

		internal const string COMMENT_CLASSNAME = "COMMENT_CLASSNAME";

		internal const string COMMENT_SYSOBJECT = "COMMENT_SYSOBJECT";

		internal const string COMMENT_LATEBOUNDOBJ = "COMMENT_LATEBOUNDOBJ";

		internal const string COMMENT_MGMTSCOPE = "COMMENT_MGMTSCOPE";

		internal const string COMMENT_AUTOCOMMITPROP = "COMMENT_AUTOCOMMITPROP";

		internal const string COMMENT_MGMTPATH = "COMMENT_MGMTPATH";

		internal const string COMMENT_PROPTYPECONVERTER = "COMMENT_PROPTYPECONVERTER";

		internal const string COMMENT_SYSPROPCLASS = "COMMENT_SYSPROPCLASS";

		internal const string COMMENT_ENUMIMPL = "COMMENT_ENUMIMPL";

		internal const string COMMENT_LATEBOUNDPROP = "COMMENT_LATEBOUNDPROP";

		internal const string COMMENT_CREATEDCLASS = "COMMENT_CREATEDCLASS";

		internal const string COMMENT_CREATEDWMINAMESPACE = "COMMENT_CREATEDWMINAMESPACE";

		internal const string COMMENT_STATICMANAGEMENTSCOPE = "COMMENT_STATICMANAGEMENTSCOPE";

		internal const string COMMENT_STATICSCOPEPROPERTY = "COMMENT_STATICSCOPEPROPERTY";

		internal const string COMMENT_TODATETIME = "COMMENT_TODATETIME";

		internal const string COMMENT_TODMTFDATETIME = "COMMENT_TODMTFDATETIME";

		internal const string COMMENT_TODMTFTIMEINTERVAL = "COMMENT_TODMTFTIMEINTERVAL";

		internal const string COMMENT_TOTIMESPAN = "COMMENT_TOTIMESPAN";

		internal const string COMMENT_EMBEDDEDOBJ = "COMMENT_EMBEDDEDOBJ";

		internal const string COMMENT_CURRENTOBJ = "COMMENT_CURRENTOBJ";

		internal const string COMMENT_FLAGFOREMBEDDED = "COMMENT_FLAGFOREMBEDDED";

		internal const string EMBEDDED_COMMENT1 = "EMBEDDED_COMMENT1";

		internal const string EMBEDDED_COMMENT2 = "EMBEDDED_COMMENT2";

		internal const string EMBEDDED_COMMENT3 = "EMBEDDED_COMMENT3";

		internal const string EMBEDDED_COMMENT4 = "EMBEDDED_COMMENT4";

		internal const string EMBEDDED_COMMENT5 = "EMBEDDED_COMMENT5";

		internal const string EMBEDDED_COMMENT6 = "EMBEDDED_COMMENT6";

		internal const string EMBEDDED_COMMENT7 = "EMBEDDED_COMMENT7";

		internal const string EMBEDED_VB_CODESAMP4 = "EMBEDED_VB_CODESAMP4";

		internal const string EMBEDED_VB_CODESAMP5 = "EMBEDED_VB_CODESAMP5";

		internal const string EMBEDDED_COMMENT8 = "EMBEDDED_COMMENT8";

		internal const string EMBEDED_CS_CODESAMP4 = "EMBEDED_CS_CODESAMP4";

		internal const string EMBEDED_CS_CODESAMP5 = "EMBEDED_CS_CODESAMP5";

		internal const string CLASSNOT_FOUND_EXCEPT = "CLASSNOT_FOUND_EXCEPT";

		internal const string NULLFILEPATH_EXCEPT = "NULLFILEPATH_EXCEPT";

		internal const string EMPTY_FILEPATH_EXCEPT = "EMPTY_FILEPATH_EXCEPT";

		internal const string NAMESPACE_NOTINIT_EXCEPT = "NAMESPACE_NOTINIT_EXCEPT";

		internal const string CLASSNAME_NOTINIT_EXCEPT = "CLASSNAME_NOTINIT_EXCEPT";

		internal const string UNABLE_TOCREATE_GEN_EXCEPT = "UNABLE_TOCREATE_GEN_EXCEPT";

		internal const string FORCE_UPDATE = "FORCE_UPDATE";

		internal const string FILETOWRITE_MOF = "FILETOWRITE_MOF";

		internal const string WMISCHEMA_INSTALLATIONSTART = "WMISCHEMA_INSTALLATIONSTART";

		internal const string REGESTRING_ASSEMBLY = "REGESTRING_ASSEMBLY";

		internal const string WMISCHEMA_INSTALLATIONEND = "WMISCHEMA_INSTALLATIONEND";

		internal const string MOFFILE_GENERATING = "MOFFILE_GENERATING";

		internal const string UNSUPPORTEDMEMBER_EXCEPT = "UNSUPPORTEDMEMBER_EXCEPT";

		internal const string CLASSINST_EXCEPT = "CLASSINST_EXCEPT";

		internal const string MEMBERCONFLILCT_EXCEPT = "MEMBERCONFLILCT_EXCEPT";

		internal const string NAMESPACE_ENSURE = "NAMESPACE_ENSURE";

		internal const string CLASS_ENSURE = "CLASS_ENSURE";

		internal const string CLASS_ENSURECREATE = "CLASS_ENSURECREATE";

		internal const string CLASS_NOTREPLACED_EXCEPT = "CLASS_NOTREPLACED_EXCEPT";

		internal const string NONCLS_COMPLIANT_EXCEPTION = "NONCLS_COMPLIANT_EXCEPTION";

		internal const string INVALID_QUERY = "INVALID_QUERY";

		internal const string INVALID_QUERY_DUP_TOKEN = "INVALID_QUERY_DUP_TOKEN";

		internal const string INVALID_QUERY_NULL_TOKEN = "INVALID_QUERY_NULL_TOKEN";

		internal const string WORKER_THREAD_WAKEUP_FAILED = "WORKER_THREAD_WAKEUP_FAILED";

		private static SR loader;

		private ResourceManager resources;

		private static CultureInfo Culture => null;

		public static ResourceManager Resources => GetLoader().resources;

		internal SR()
		{
			resources = new ResourceManager("System.Management", GetType().Assembly);
		}

		private static SR GetLoader()
		{
			if (loader == null)
			{
				SR value = new SR();
				Interlocked.CompareExchange(ref loader, value, null);
			}
			return loader;
		}

		public static string GetString(string name, params object[] args)
		{
			SR sR = GetLoader();
			if (sR == null)
			{
				return null;
			}
			string @string = sR.resources.GetString(name, Culture);
			if (args != null && args.Length != 0)
			{
				for (int i = 0; i < args.Length; i++)
				{
					if (args[i] is string text && text.Length > 1024)
					{
						args[i] = text.Substring(0, 1021) + "...";
					}
				}
				return string.Format(CultureInfo.CurrentCulture, @string, args);
			}
			return @string;
		}

		public static string GetString(string name)
		{
			return GetLoader()?.resources.GetString(name, Culture);
		}

		public static string GetString(string name, out bool usedFallback)
		{
			usedFallback = false;
			return GetString(name);
		}

		public static object GetObject(string name)
		{
			return GetLoader()?.resources.GetObject(name, Culture);
		}
	}
}
namespace System.Management.Instrumentation
{
	internal sealed class AssemblyNameUtility
	{
		private static string BinToString(byte[] rg)
		{
			if (rg == null)
			{
				return "";
			}
			string text = "";
			for (int i = 0; i < rg.GetLength(0); i++)
			{
				text += $"{rg[i]:x2}";
			}
			return text;
		}

		public static string UniqueToAssemblyMinorVersion(Assembly assembly)
		{
			AssemblyName name = assembly.GetName(copiedName: true);
			return name.Name + "_SN_" + BinToString(name.GetPublicKeyToken()) + "_Version_" + name.Version.Major + "." + name.Version.Minor;
		}

		public static string UniqueToAssemblyFullVersion(Assembly assembly)
		{
			AssemblyName name = assembly.GetName(copiedName: true);
			return name.Name + "_SN_" + BinToString(name.GetPublicKeyToken()) + "_Version_" + name.Version.Major + "." + name.Version.Minor + "." + name.Version.Build + "." + name.Version.Revision;
		}

		private static string UniqueToAssemblyVersion(Assembly assembly)
		{
			AssemblyName name = assembly.GetName(copiedName: true);
			return name.Name + "_SN_" + BinToString(name.GetPublicKeyToken()) + "_Version_" + name.Version.Major + "." + name.Version.Minor + "." + name.Version.Build + "." + name.Version.Revision;
		}

		public static string UniqueToAssemblyBuild(Assembly assembly)
		{
			return UniqueToAssemblyVersion(assembly) + "_Mvid_" + MetaDataInfo.GetMvid(assembly).ToString().ToLower(CultureInfo.InvariantCulture);
		}
	}
	/// <summary>Specifies that this assembly provides management instrumentation. This attribute should appear one time per assembly.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Assembly)]
	public class InstrumentedAttribute : Attribute
	{
		private string namespaceName;

		private string securityDescriptor;

		/// <summary>Gets or sets the namespace for instrumentation instances and events in this assembly.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the name of the namespace for instrumentation instances and events in this assembly.</returns>
		public string NamespaceName
		{
			get
			{
				if (namespaceName != null)
				{
					return namespaceName;
				}
				return string.Empty;
			}
		}

		/// <summary>Gets or sets a security descriptor that allows only the specified users or groups to run applications that provide the instrumentation supported by this assembly.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the security descriptor that allows only the specified users or groups to run applications that provide the instrumentation supported by this assembly.</returns>
		public string SecurityDescriptor
		{
			get
			{
				if (securityDescriptor == null || securityDescriptor.Length == 0)
				{
					return null;
				}
				return securityDescriptor;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentedAttribute" /> class that is set for the root\default namespace. This is the default constructor.</summary>
		public InstrumentedAttribute()
			: this(null, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentedAttribute" /> class that is set to the specified namespace for instrumentation within this assembly.</summary>
		/// <param name="namespaceName">The namespace for instrumentation instances and events.</param>
		public InstrumentedAttribute(string namespaceName)
			: this(namespaceName, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentedAttribute" /> class that is set to the specified namespace and security settings for instrumentation within this assembly.</summary>
		/// <param name="namespaceName">The namespace for instrumentation instances and events.</param>
		/// <param name="securityDescriptor">A security descriptor that allows only the specified users or groups to run applications that provide the instrumentation supported by this assembly.</param>
		public InstrumentedAttribute(string namespaceName, string securityDescriptor)
		{
			if (namespaceName != null)
			{
				namespaceName = namespaceName.Replace('/', '\\');
			}
			if (namespaceName == null || namespaceName.Length == 0)
			{
				namespaceName = "root\\default";
			}
			bool flag = true;
			string[] array = namespaceName.Split('\\');
			foreach (string text in array)
			{
				if (text.Length == 0 || (flag && string.Compare(text, "root", StringComparison.OrdinalIgnoreCase) != 0) || !Regex.Match(text, "^[a-z,A-Z]").Success || Regex.Match(text, "_$").Success || Regex.Match(text, "[^a-z,A-Z,0-9,_,\\u0080-\\uFFFF]").Success)
				{
					ManagementException.ThrowWithExtendedInfo(ManagementStatus.InvalidNamespace);
				}
				flag = false;
			}
			this.namespaceName = namespaceName;
			this.securityDescriptor = securityDescriptor;
		}

		internal static InstrumentedAttribute GetAttribute(Assembly assembly)
		{
			object[] customAttributes = assembly.GetCustomAttributes(typeof(InstrumentedAttribute), inherit: false);
			if (customAttributes.Length != 0)
			{
				return (InstrumentedAttribute)customAttributes[0];
			}
			return new InstrumentedAttribute();
		}

		internal static Type[] GetInstrumentedTypes(Assembly assembly)
		{
			ArrayList arrayList = new ArrayList();
			Type[] types = assembly.GetTypes();
			foreach (Type type in types)
			{
				if (IsInstrumentationClass(type))
				{
					GetInstrumentedParentTypes(arrayList, type);
				}
			}
			return (Type[])arrayList.ToArray(typeof(Type));
		}

		private static void GetInstrumentedParentTypes(ArrayList types, Type childType)
		{
			if (!types.Contains(childType))
			{
				Type baseInstrumentationType = InstrumentationClassAttribute.GetBaseInstrumentationType(childType);
				if (baseInstrumentationType != null)
				{
					GetInstrumentedParentTypes(types, baseInstrumentationType);
				}
				types.Add(childType);
			}
		}

		private static bool IsInstrumentationClass(Type type)
		{
			return InstrumentationClassAttribute.GetAttribute(type) != null;
		}
	}
	/// <summary>Specifies the type of instrumentation provided by a class.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	public enum InstrumentationType
	{
		/// <summary>The class provides instances for management instrumentation.</summary>
		Instance,
		/// <summary>The class provides events for management instrumentation.</summary>
		Event,
		/// <summary>The class defines an abstract class for management instrumentation.</summary>
		Abstract
	}
	/// <summary>Specifies that a class provides event or instance instrumentation.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
	public class InstrumentationClassAttribute : Attribute
	{
		private InstrumentationType instrumentationType;

		private string managedBaseClassName;

		/// <summary>Gets or sets the type of instrumentation provided by this class.</summary>
		/// <returns>Returns an <see cref="T:System.Management.Instrumentation.InstrumentationType" /> enumeration value containing the type of instrumentation provided by this class.</returns>
		public InstrumentationType InstrumentationType => instrumentationType;

		/// <summary>Gets or sets the name of the base class of this instrumentation class.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the name of the base class of this instrumentation class.</returns>
		public string ManagedBaseClassName
		{
			get
			{
				if (managedBaseClassName == null || managedBaseClassName.Length == 0)
				{
					return null;
				}
				return managedBaseClassName;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationClassAttribute" /> class that is used if this type is derived from another type that has the <see cref="T:System.Management.Instrumentation.InstrumentationClassAttribute" /> attribute, or if this is a top-level instrumentation class (for example, an instance or abstract class                without a base class, or an event derived from __ExtrinsicEvent).</summary>
		/// <param name="instrumentationType">The type of instrumentation provided by this class.</param>
		public InstrumentationClassAttribute(InstrumentationType instrumentationType)
		{
			this.instrumentationType = instrumentationType;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationClassAttribute" /> class that has schema for an existing base class. The class must contain proper member definitions for the properties of the existing WMI base class.</summary>
		/// <param name="instrumentationType">The type of instrumentation provided by this class.</param>
		/// <param name="managedBaseClassName">The name of the base class.</param>
		public InstrumentationClassAttribute(InstrumentationType instrumentationType, string managedBaseClassName)
		{
			this.instrumentationType = instrumentationType;
			this.managedBaseClassName = managedBaseClassName;
		}

		internal static InstrumentationClassAttribute GetAttribute(Type type)
		{
			if (type == typeof(BaseEvent) || type == typeof(Instance))
			{
				return null;
			}
			object[] customAttributes = type.GetCustomAttributes(typeof(InstrumentationClassAttribute), inherit: true);
			if (customAttributes.Length != 0)
			{
				return (InstrumentationClassAttribute)customAttributes[0];
			}
			return null;
		}

		internal static Type GetBaseInstrumentationType(Type type)
		{
			if (GetAttribute(type.BaseType) != null)
			{
				return type.BaseType;
			}
			return null;
		}
	}
	/// <summary>Allows an instrumented class, or member of an instrumented class, to present an alternate name through management instrumentation.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field)]
	public class ManagedNameAttribute : Attribute
	{
		private string name;

		/// <summary>Gets the name of the managed entity.</summary>
		/// <returns>Returns a T:System.String value containing the name of the managed entity.</returns>
		public string Name => name;

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.ManagedNameAttribute" /> class that allows the alternate name to be specified for the type, field, property, method, or parameter to which this attribute is applied.</summary>
		/// <param name="name">The alternate name for the type, field, property, method, or parameter to which this attribute is applied.</param>
		public ManagedNameAttribute(string name)
		{
			this.name = name;
		}

		internal static string GetMemberName(MemberInfo member)
		{
			object[] customAttributes = member.GetCustomAttributes(typeof(ManagedNameAttribute), inherit: false);
			if (customAttributes.Length != 0)
			{
				ManagedNameAttribute managedNameAttribute = (ManagedNameAttribute)customAttributes[0];
				if (managedNameAttribute.name != null && managedNameAttribute.name.Length != 0)
				{
					return managedNameAttribute.name;
				}
			}
			return member.Name;
		}

		internal static string GetBaseClassName(Type type)
		{
			InstrumentationClassAttribute attribute = InstrumentationClassAttribute.GetAttribute(type);
			string managedBaseClassName = attribute.ManagedBaseClassName;
			if (managedBaseClassName != null)
			{
				return managedBaseClassName;
			}
			InstrumentationClassAttribute attribute2 = InstrumentationClassAttribute.GetAttribute(type.BaseType);
			if (attribute2 == null)
			{
				switch (attribute.InstrumentationType)
				{
				case InstrumentationType.Abstract:
					return null;
				case InstrumentationType.Instance:
					return null;
				case InstrumentationType.Event:
					return "__ExtrinsicEvent";
				}
			}
			return GetMemberName(type.BaseType);
		}
	}
	/// <summary>Causes the associated member of an instrumented class to be ignored by management instrumentation.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field)]
	public class IgnoreMemberAttribute : Attribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.IgnoreMemberAttribute" /> class</summary>
		public IgnoreMemberAttribute()
		{
		}
	}
	internal class CodeWriter
	{
		private int depth;

		private ArrayList children = new ArrayList();

		public static explicit operator string(CodeWriter writer)
		{
			return writer.ToString();
		}

		public override string ToString()
		{
			StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			WriteCode(stringWriter);
			string result = stringWriter.ToString();
			stringWriter.Close();
			return result;
		}

		private void WriteCode(TextWriter writer)
		{
			string value = new string(' ', depth * 4);
			foreach (object child in children)
			{
				if (child == null)
				{
					writer.WriteLine();
				}
				else if (child is string)
				{
					writer.Write(value);
					writer.WriteLine(child);
				}
				else
				{
					((CodeWriter)child).WriteCode(writer);
				}
			}
		}

		public CodeWriter AddChild(string name)
		{
			Line(name);
			Line("{");
			CodeWriter codeWriter = new CodeWriter();
			codeWriter.depth = depth + 1;
			children.Add(codeWriter);
			Line("}");
			return codeWriter;
		}

		public CodeWriter AddChild(params string[] parts)
		{
			return AddChild(string.Concat(parts));
		}

		public CodeWriter AddChildNoIndent(string name)
		{
			Line(name);
			CodeWriter codeWriter = new CodeWriter();
			codeWriter.depth = depth + 1;
			children.Add(codeWriter);
			return codeWriter;
		}

		public CodeWriter AddChild(CodeWriter snippet)
		{
			snippet.depth = depth;
			children.Add(snippet);
			return snippet;
		}

		public void Line(string line)
		{
			children.Add(line);
		}

		public void Line(params string[] parts)
		{
			Line(string.Concat(parts));
		}

		public void Line()
		{
			children.Add(null);
		}
	}
	internal class ReferencesCollection
	{
		private StringCollection namespaces = new StringCollection();

		private StringCollection assemblies = new StringCollection();

		private CodeWriter usingCode = new CodeWriter();

		public StringCollection Namespaces => namespaces;

		public StringCollection Assemblies => assemblies;

		public CodeWriter UsingCode => usingCode;

		public void Add(Type type)
		{
			if (!namespaces.Contains(type.Namespace))
			{
				namespaces.Add(type.Namespace);
				usingCode.Line($"using {type.Namespace};");
			}
			if (!assemblies.Contains(type.Assembly.Location))
			{
				assemblies.Add(type.Assembly.Location);
			}
		}
	}
	internal class ComThreadingInfo
	{
		public enum APTTYPE
		{
			APTTYPE_CURRENT = -1,
			APTTYPE_STA,
			APTTYPE_MTA,
			APTTYPE_NA,
			APTTYPE_MAINSTA
		}

		public enum THDTYPE
		{
			THDTYPE_BLOCKMESSAGES,
			THDTYPE_PROCESSMESSAGES
		}

		[ComImport]
		[Guid("000001ce-0000-0000-C000-000000000046")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		private interface IComThreadingInfo
		{
			APTTYPE GetCurrentApartmentType();

			THDTYPE GetCurrentThreadType();

			Guid GetCurrentLogicalThreadId();

			void SetCurrentLogicalThreadId([In] Guid rguid);
		}

		private Guid IID_IUnknown = new Guid("00000000-0000-0000-C000-000000000046");

		private APTTYPE apartmentType;

		private THDTYPE threadType;

		private Guid logicalThreadId;

		public static ComThreadingInfo Current => new ComThreadingInfo();

		public APTTYPE ApartmentType => apartmentType;

		public THDTYPE ThreadType => threadType;

		public Guid LogicalThreadId => logicalThreadId;

		private ComThreadingInfo()
		{
			IComThreadingInfo comThreadingInfo = (IComThreadingInfo)CoGetObjectContext(ref IID_IUnknown);
			apartmentType = comThreadingInfo.GetCurrentApartmentType();
			threadType = comThreadingInfo.GetCurrentThreadType();
			logicalThreadId = comThreadingInfo.GetCurrentLogicalThreadId();
		}

		public override string ToString()
		{
			return $"{{{LogicalThreadId}}} - {ApartmentType} - {ThreadType}";
		}

		[DllImport("ole32.dll", PreserveSig = false)]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		private static extern object CoGetObjectContext([In] ref Guid riid);
	}
	internal sealed class EventSource : IWbemProviderInit, IWbemEventProvider, IWbemEventProviderQuerySink, IWbemEventProviderSecurity, IWbemServices_Old
	{
		private class MTARequest
		{
			public AutoResetEvent doneIndicate = new AutoResetEvent(initialState: false);

			public Exception exception;

			public int lengthFromSTA = -1;

			public IntPtr[] objectsFromSTA;

			public MTARequest(int length, IntPtr[] objects)
			{
				lengthFromSTA = length;
				objectsFromSTA = objects;
			}
		}

		private IWbemDecoupledRegistrar registrar = (IWbemDecoupledRegistrar)new WbemDecoupledRegistrar();

		private static ArrayList eventSources;

		private InstrumentedAssembly instrumentedAssembly;

		private static int shutdownInProgress;

		private static ReaderWriterLock preventShutdownLock;

		private IWbemServices pNamespaceNA;

		private IWbemObjectSink pSinkNA;

		private IWbemServices pNamespaceMTA;

		private IWbemObjectSink pSinkMTA;

		private ArrayList reqList = new ArrayList(3);

		private object critSec = new object();

		private AutoResetEvent doIndicate = new AutoResetEvent(initialState: false);

		private bool workerThreadInitialized;

		private bool alive = true;

		private Hashtable mapQueryIdToQuery = new Hashtable();

		public EventSource(string namespaceName, string appName, InstrumentedAssembly instrumentedAssembly)
		{
			lock (eventSources)
			{
				if (shutdownInProgress == 0)
				{
					this.instrumentedAssembly = instrumentedAssembly;
					int num = registrar.Register_(0, null, null, null, namespaceName, appName, this);
					if (num != 0)
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
					eventSources.Add(this);
				}
			}
		}

		~EventSource()
		{
			UnRegister();
		}

		private void UnRegister()
		{
			lock (this)
			{
				if (registrar != null)
				{
					if (workerThreadInitialized)
					{
						alive = false;
						doIndicate.Set();
						GC.KeepAlive(this);
						workerThreadInitialized = false;
					}
					registrar.UnRegister_();
					registrar = null;
				}
			}
		}

		private static void ProcessExit(object o, EventArgs args)
		{
			if (shutdownInProgress != 0)
			{
				return;
			}
			Interlocked.Increment(ref shutdownInProgress);
			try
			{
				preventShutdownLock.AcquireWriterLock(-1);
				lock (eventSources)
				{
					foreach (EventSource eventSource in eventSources)
					{
						eventSource.UnRegister();
					}
				}
			}
			finally
			{
				preventShutdownLock.ReleaseWriterLock();
				Thread.Sleep(50);
				preventShutdownLock.AcquireWriterLock(-1);
				preventShutdownLock.ReleaseWriterLock();
			}
		}

		static EventSource()
		{
			eventSources = new ArrayList();
			shutdownInProgress = 0;
			preventShutdownLock = new ReaderWriterLock();
			AppDomain.CurrentDomain.ProcessExit += ProcessExit;
			AppDomain.CurrentDomain.DomainUnload += ProcessExit;
		}

		public void MTAWorkerThread2()
		{
			while (true)
			{
				doIndicate.WaitOne();
				if (!alive)
				{
					break;
				}
				while (true)
				{
					MTARequest mTARequest = null;
					lock (critSec)
					{
						if (reqList.Count > 0)
						{
							mTARequest = (MTARequest)reqList[0];
							reqList.RemoveAt(0);
							goto IL_0064;
						}
					}
					break;
					IL_0064:
					try
					{
						if (pSinkMTA == null)
						{
							continue;
						}
						int num = pSinkMTA.Indicate_(mTARequest.lengthFromSTA, mTARequest.objectsFromSTA);
						if (num < 0)
						{
							if ((num & 0xFFFFF000u) == 2147749888u)
							{
								ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
							}
							else
							{
								Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
							}
						}
					}
					catch (Exception exception)
					{
						Exception ex = (mTARequest.exception = exception);
					}
					finally
					{
						mTARequest.doneIndicate.Set();
						GC.KeepAlive(this);
					}
				}
			}
		}

		public void IndicateEvents(int length, IntPtr[] objects)
		{
			if (pSinkMTA == null)
			{
				return;
			}
			if (MTAHelper.IsNoContextMTA())
			{
				int num = pSinkMTA.Indicate_(length, objects);
				if (num < 0)
				{
					if ((num & 0xFFFFF000u) == 2147749888u)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)num);
					}
					else
					{
						Marshal.ThrowExceptionForHR(num, WmiNetUtilsHelper.GetErrorInfo_f());
					}
				}
			}
			else
			{
				MTARequest mTARequest = new MTARequest(length, objects);
				lock (critSec)
				{
					if (!workerThreadInitialized)
					{
						Thread thread = new Thread(MTAWorkerThread2);
						thread.IsBackground = true;
						thread.SetApartmentState(ApartmentState.MTA);
						thread.Start();
						workerThreadInitialized = true;
					}
					int index = reqList.Add(mTARequest);
					if (!doIndicate.Set())
					{
						reqList.RemoveAt(index);
						throw new ManagementException(RC.GetString("WORKER_THREAD_WAKEUP_FAILED"));
					}
				}
				mTARequest.doneIndicate.WaitOne();
				if (mTARequest.exception != null)
				{
					throw mTARequest.exception;
				}
			}
			GC.KeepAlive(this);
		}

		private void RelocateSinkRCWToMTA()
		{
			ThreadDispatch threadDispatch = new ThreadDispatch((ThreadDispatch.ThreadWorkerMethodWithParam)RelocateSinkRCWToMTA_ThreadFuncion);
			threadDispatch.Parameter = this;
			threadDispatch.Start();
		}

		private void RelocateSinkRCWToMTA_ThreadFuncion(object param)
		{
			EventSource eventSource = (EventSource)param;
			eventSource.pSinkMTA = (IWbemObjectSink)RelocateRCWToCurrentApartment(eventSource.pSinkNA);
			eventSource.pSinkNA = null;
		}

		private void RelocateNamespaceRCWToMTA()
		{
			ThreadDispatch threadDispatch = new ThreadDispatch((ThreadDispatch.ThreadWorkerMethodWithParam)RelocateNamespaceRCWToMTA_ThreadFuncion);
			threadDispatch.Parameter = this;
			threadDispatch.Start();
		}

		private void RelocateNamespaceRCWToMTA_ThreadFuncion(object param)
		{
			EventSource eventSource = (EventSource)param;
			eventSource.pNamespaceMTA = (IWbemServices)RelocateRCWToCurrentApartment(eventSource.pNamespaceNA);
			eventSource.pNamespaceNA = null;
		}

		private static object RelocateRCWToCurrentApartment(object comObject)
		{
			if (comObject == null)
			{
				return null;
			}
			IntPtr iUnknownForObject = Marshal.GetIUnknownForObject(comObject);
			if (Marshal.ReleaseComObject(comObject) != 0)
			{
				throw new Exception();
			}
			comObject = Marshal.GetObjectForIUnknown(iUnknownForObject);
			Marshal.Release(iUnknownForObject);
			return comObject;
		}

		public bool Any()
		{
			if (pSinkMTA != null)
			{
				return mapQueryIdToQuery.Count == 0;
			}
			return true;
		}

		int IWbemProviderInit.Initialize_([In][MarshalAs(UnmanagedType.LPWStr)] string wszUser, [In] int lFlags, [In][MarshalAs(UnmanagedType.LPWStr)] string wszNamespace, [In][MarshalAs(UnmanagedType.LPWStr)] string wszLocale, [In][MarshalAs(UnmanagedType.Interface)] IWbemServices pNamespace, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemProviderInitSink pInitSink)
		{
			pNamespaceNA = pNamespace;
			RelocateNamespaceRCWToMTA();
			pSinkNA = null;
			pSinkMTA = null;
			lock (mapQueryIdToQuery)
			{
				mapQueryIdToQuery.Clear();
			}
			pInitSink.SetStatus_(0, 0);
			Marshal.ReleaseComObject(pInitSink);
			return 0;
		}

		int IWbemEventProvider.ProvideEvents_([In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pSink, [In] int lFlags)
		{
			pSinkNA = pSink;
			RelocateSinkRCWToMTA();
			return 0;
		}

		int IWbemEventProviderQuerySink.NewQuery_([In] uint dwId, [In][MarshalAs(UnmanagedType.LPWStr)] string wszQueryLanguage, [In][MarshalAs(UnmanagedType.LPWStr)] string wszQuery)
		{
			lock (mapQueryIdToQuery)
			{
				if (mapQueryIdToQuery.ContainsKey(dwId))
				{
					mapQueryIdToQuery.Remove(dwId);
				}
				mapQueryIdToQuery.Add(dwId, wszQuery);
			}
			return 0;
		}

		int IWbemEventProviderQuerySink.CancelQuery_([In] uint dwId)
		{
			lock (mapQueryIdToQuery)
			{
				mapQueryIdToQuery.Remove(dwId);
			}
			return 0;
		}

		int IWbemEventProviderSecurity.AccessCheck_([In][MarshalAs(UnmanagedType.LPWStr)] string wszQueryLanguage, [In][MarshalAs(UnmanagedType.LPWStr)] string wszQuery, [In] int lSidLength, [In] ref byte pSid)
		{
			return 0;
		}

		int IWbemServices_Old.OpenNamespace_([In][MarshalAs(UnmanagedType.BStr)] string strNamespace, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][Out][MarshalAs(UnmanagedType.Interface)] ref IWbemServices ppWorkingNamespace, [In] IntPtr ppCallResult)
		{
			return -2147217396;
		}

		int IWbemServices_Old.CancelAsyncCall_([In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pSink)
		{
			return -2147217396;
		}

		int IWbemServices_Old.QueryObjectSink_([In] int lFlags, [MarshalAs(UnmanagedType.Interface)] out IWbemObjectSink ppResponseHandler)
		{
			ppResponseHandler = null;
			return -2147217396;
		}

		int IWbemServices_Old.GetObject_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][Out][MarshalAs(UnmanagedType.Interface)] ref IWbemClassObject_DoNotMarshal ppObject, [In] IntPtr ppCallResult)
		{
			return -2147217396;
		}

		int IWbemServices_Old.GetObjectAsync_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler)
		{
			Match match = Regex.Match(strObjectPath.ToLower(CultureInfo.InvariantCulture), "(.*?)\\.instanceid=\"(.*?)\",processid=\"(.*?)\"");
			if (!match.Success)
			{
				pResponseHandler.SetStatus_(0, -2147217406, null, IntPtr.Zero);
				Marshal.ReleaseComObject(pResponseHandler);
				return -2147217406;
			}
			string value = match.Groups[1].Value;
			string value2 = match.Groups[2].Value;
			string value3 = match.Groups[3].Value;
			if (Instrumentation.ProcessIdentity != value3)
			{
				pResponseHandler.SetStatus_(0, -2147217406, null, IntPtr.Zero);
				Marshal.ReleaseComObject(pResponseHandler);
				return -2147217406;
			}
			int num = ((IConvertible)value2).ToInt32((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int)));
			object obj = null;
			try
			{
				InstrumentedAssembly.readerWriterLock.AcquireReaderLock(-1);
				obj = InstrumentedAssembly.mapIDToPublishedObject[num.ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int)))];
			}
			finally
			{
				InstrumentedAssembly.readerWriterLock.ReleaseReaderLock();
			}
			if (obj != null)
			{
				Type type = (Type)instrumentedAssembly.mapTypeToConverter[obj.GetType()];
				if (type != null)
				{
					object obj2 = Activator.CreateInstance(type);
					ConvertToWMI convertToWMI = (ConvertToWMI)Delegate.CreateDelegate(typeof(ConvertToWMI), obj2, "ToWMI");
					lock (obj)
					{
						convertToWMI(obj);
					}
					IntPtr[] array = new IntPtr[1] { (IntPtr)obj2.GetType().GetField("instWbemObjectAccessIP").GetValue(obj2) };
					Marshal.AddRef(array[0]);
					IWbemClassObjectFreeThreaded wbemClassObjectFreeThreaded = new IWbemClassObjectFreeThreaded(array[0]);
					object pVal = num;
					wbemClassObjectFreeThreaded.Put_("InstanceId", 0, ref pVal, 0);
					pVal = Instrumentation.ProcessIdentity;
					wbemClassObjectFreeThreaded.Put_("ProcessId", 0, ref pVal, 0);
					pResponseHandler.Indicate_(1, array);
					pResponseHandler.SetStatus_(0, 0, null, IntPtr.Zero);
					Marshal.ReleaseComObject(pResponseHandler);
					return 0;
				}
			}
			pResponseHandler.SetStatus_(0, -2147217406, null, IntPtr.Zero);
			Marshal.ReleaseComObject(pResponseHandler);
			return -2147217406;
		}

		int IWbemServices_Old.PutClass_([In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pObject, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult)
		{
			return -2147217396;
		}

		int IWbemServices_Old.PutClassAsync_([In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pObject, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler)
		{
			return -2147217396;
		}

		int IWbemServices_Old.DeleteClass_([In][MarshalAs(UnmanagedType.BStr)] string strClass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult)
		{
			return -2147217396;
		}

		int IWbemServices_Old.DeleteClassAsync_([In][MarshalAs(UnmanagedType.BStr)] string strClass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler)
		{
			return -2147217396;
		}

		int IWbemServices_Old.CreateClassEnum_([In][MarshalAs(UnmanagedType.BStr)] string strSuperclass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum)
		{
			ppEnum = null;
			return -2147217396;
		}

		int IWbemServices_Old.CreateClassEnumAsync_([In][MarshalAs(UnmanagedType.BStr)] string strSuperclass, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler)
		{
			return -2147217396;
		}

		int IWbemServices_Old.PutInstance_([In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pInst, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult)
		{
			return -2147217396;
		}

		int IWbemServices_Old.PutInstanceAsync_([In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pInst, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler)
		{
			return -2147217396;
		}

		int IWbemServices_Old.DeleteInstance_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In] IntPtr ppCallResult)
		{
			return -2147217396;
		}

		int IWbemServices_Old.DeleteInstanceAsync_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler)
		{
			return -2147217396;
		}

		int IWbemServices_Old.CreateInstanceEnum_([In][MarshalAs(UnmanagedType.BStr)] string strFilter, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum)
		{
			ppEnum = null;
			return -2147217396;
		}

		int IWbemServices_Old.CreateInstanceEnumAsync_([In][MarshalAs(UnmanagedType.BStr)] string strFilter, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler)
		{
			try
			{
				preventShutdownLock.AcquireReaderLock(-1);
				if (shutdownInProgress != 0)
				{
					return 0;
				}
				uint num = (uint)(Environment.TickCount + 100);
				Type type = null;
				foreach (Type key in instrumentedAssembly.mapTypeToConverter.Keys)
				{
					if (string.Compare(ManagedNameAttribute.GetMemberName(key), strFilter, StringComparison.Ordinal) == 0)
					{
						type = key;
						break;
					}
				}
				if (null == type)
				{
					return 0;
				}
				int num2 = 64;
				IntPtr[] array = new IntPtr[num2];
				IntPtr[] array2 = new IntPtr[num2];
				ConvertToWMI[] array3 = new ConvertToWMI[num2];
				IWbemClassObjectFreeThreaded[] array4 = new IWbemClassObjectFreeThreaded[num2];
				int plHandle = 0;
				int num3 = 0;
				object pVal = Instrumentation.ProcessIdentity;
				try
				{
					InstrumentedAssembly.readerWriterLock.AcquireReaderLock(-1);
					foreach (DictionaryEntry item in InstrumentedAssembly.mapIDToPublishedObject)
					{
						if (shutdownInProgress != 0)
						{
							return 0;
						}
						if (type != item.Value.GetType())
						{
							continue;
						}
						if (array3[num3] == null)
						{
							object obj = Activator.CreateInstance((Type)instrumentedAssembly.mapTypeToConverter[type]);
							array3[num3] = (ConvertToWMI)Delegate.CreateDelegate(typeof(ConvertToWMI), obj, "ToWMI");
							lock (item.Value)
							{
								array3[num3](item.Value);
							}
							array[num3] = (IntPtr)obj.GetType().GetField("instWbemObjectAccessIP").GetValue(obj);
							Marshal.AddRef(array[num3]);
							array4[num3] = new IWbemClassObjectFreeThreaded(array[num3]);
							array4[num3].Put_("ProcessId", 0, ref pVal, 0);
							if (num3 == 0)
							{
								WmiNetUtilsHelper.GetPropertyHandle_f27(27, array4[num3], "InstanceId", out var _, out plHandle);
							}
						}
						else
						{
							lock (item.Value)
							{
								array3[num3](item.Value);
							}
							array[num3] = (IntPtr)array3[num3].Target.GetType().GetField("instWbemObjectAccessIP").GetValue(array3[num3].Target);
							Marshal.AddRef(array[num3]);
							array4[num3] = new IWbemClassObjectFreeThreaded(array[num3]);
							array4[num3].Put_("ProcessId", 0, ref pVal, 0);
							if (num3 == 0)
							{
								WmiNetUtilsHelper.GetPropertyHandle_f27(27, array4[num3], "InstanceId", out var _, out plHandle);
							}
						}
						string text = (string)item.Key;
						WmiNetUtilsHelper.WritePropertyValue_f28(28, array4[num3], plHandle, (text.Length + 1) * 2, text);
						num3++;
						if (num3 == num2 || (uint)Environment.TickCount >= num)
						{
							for (int i = 0; i < num3; i++)
							{
								WmiNetUtilsHelper.Clone_f(12, array[i], out array2[i]);
							}
							int num4 = pResponseHandler.Indicate_(num3, array2);
							for (int j = 0; j < num3; j++)
							{
								Marshal.Release(array2[j]);
							}
							if (num4 != 0)
							{
								return 0;
							}
							num3 = 0;
							num = (uint)(Environment.TickCount + 100);
						}
					}
				}
				finally
				{
					InstrumentedAssembly.readerWriterLock.ReleaseReaderLock();
				}
				if (num3 > 0)
				{
					for (int k = 0; k < num3; k++)
					{
						WmiNetUtilsHelper.Clone_f(12, array[k], out array2[k]);
					}
					pResponseHandler.Indicate_(num3, array2);
					for (int l = 0; l < num3; l++)
					{
						Marshal.Release(array2[l]);
					}
				}
			}
			finally
			{
				pResponseHandler.SetStatus_(0, 0, null, IntPtr.Zero);
				Marshal.ReleaseComObject(pResponseHandler);
				preventShutdownLock.ReleaseReaderLock();
			}
			return 0;
		}

		int IWbemServices_Old.ExecQuery_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum)
		{
			ppEnum = null;
			return -2147217396;
		}

		int IWbemServices_Old.ExecQueryAsync_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler)
		{
			return -2147217396;
		}

		int IWbemServices_Old.ExecNotificationQuery_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [MarshalAs(UnmanagedType.Interface)] out IEnumWbemClassObject ppEnum)
		{
			ppEnum = null;
			return -2147217396;
		}

		int IWbemServices_Old.ExecNotificationQueryAsync_([In][MarshalAs(UnmanagedType.BStr)] string strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)] string strQuery, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler)
		{
			return -2147217396;
		}

		int IWbemServices_Old.ExecMethod_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In][MarshalAs(UnmanagedType.BStr)] string strMethodName, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pInParams, [In][Out][MarshalAs(UnmanagedType.Interface)] ref IWbemClassObject_DoNotMarshal ppOutParams, [In] IntPtr ppCallResult)
		{
			return -2147217396;
		}

		int IWbemServices_Old.ExecMethodAsync_([In][MarshalAs(UnmanagedType.BStr)] string strObjectPath, [In][MarshalAs(UnmanagedType.BStr)] string strMethodName, [In] int lFlags, [In][MarshalAs(UnmanagedType.Interface)] IWbemContext pCtx, [In][MarshalAs(UnmanagedType.Interface)] IWbemClassObject_DoNotMarshal pInParams, [In][MarshalAs(UnmanagedType.Interface)] IWbemObjectSink pResponseHandler)
		{
			return -2147217396;
		}
	}
	internal delegate void ProvisionFunction(object o);
	internal sealed class SecurityHelper
	{
		internal static readonly SecurityPermission UnmanagedCode = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
	}
	/// <summary>Provides helper functions for exposing events and data for management. There is a single instance of this class per application domain.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	public class Instrumentation
	{
		private static string processIdentity = null;

		private static Hashtable instrumentedAssemblies = new Hashtable();

		internal static string ProcessIdentity
		{
			get
			{
				lock (typeof(Instrumentation))
				{
					if (processIdentity == null)
					{
						processIdentity = Guid.NewGuid().ToString().ToLower(CultureInfo.InvariantCulture);
					}
				}
				return processIdentity;
			}
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
		private static extern int GetCurrentProcessId();

		/// <summary>Registers the management instance or event classes in the specified assembly with WMI. This ensures that the instrumentation schema is accessible to <see cref="N:System.Management" /> client applications.</summary>
		/// <param name="assemblyToRegister">The <see cref="T:System.Reflection.Assembly" /> containing instrumentation instance or event types.</param>
		public static void RegisterAssembly(Assembly assemblyToRegister)
		{
			if (null == assemblyToRegister)
			{
				throw new ArgumentNullException("assemblyToRegister");
			}
			GetInstrumentedAssembly(assemblyToRegister);
		}

		/// <summary>Determines if the instrumentation schema of the specified assembly has already been correctly registered with WMI.</summary>
		/// <param name="assemblyToRegister">The <see cref="T:System.Reflection.Assembly" /> containing instrumentation instance or event types.</param>
		/// <returns>
		///   <see langword="true" /> if the instrumentation schema in the specified assembly is registered with WMI; otherwise, <see langword="false" />.</returns>
		public static bool IsAssemblyRegistered(Assembly assemblyToRegister)
		{
			if (null == assemblyToRegister)
			{
				throw new ArgumentNullException("assemblyToRegister");
			}
			lock (instrumentedAssemblies)
			{
				if (instrumentedAssemblies.ContainsKey(assemblyToRegister))
				{
					return true;
				}
			}
			return SchemaNaming.GetSchemaNaming(assemblyToRegister)?.IsAssemblyRegistered() ?? false;
		}

		/// <summary>Raises a management event.</summary>
		/// <param name="eventData">The object that determines the class, properties, and values of the event.</param>
		public static void Fire(object eventData)
		{
			if (eventData is IEvent @event)
			{
				@event.Fire();
			}
			else
			{
				GetFireFunction(eventData.GetType())(eventData);
			}
		}

		/// <summary>Makes an instance visible through management instrumentation.</summary>
		/// <param name="instanceData">The object that is to be visible through management instrumentation.</param>
		public static void Publish(object instanceData)
		{
			Type type = instanceData as Type;
			Assembly assembly = instanceData as Assembly;
			IInstance instance = instanceData as IInstance;
			if (type != null)
			{
				GetInstrumentedAssembly(type.Assembly);
			}
			else if (assembly != null)
			{
				GetInstrumentedAssembly(assembly);
			}
			else if (instance != null)
			{
				instance.Published = true;
			}
			else
			{
				GetPublishFunction(instanceData.GetType())(instanceData);
			}
		}

		/// <summary>Makes an instance that was previously published through the <see cref="M:System.Management.Instrumentation.Instrumentation.Publish(System.Object)" /> method no longer visible through management instrumentation.</summary>
		/// <param name="instanceData">The object to remove from visibility for management instrumentation.</param>
		public static void Revoke(object instanceData)
		{
			if (instanceData is IInstance instance)
			{
				instance.Published = false;
			}
			else
			{
				GetRevokeFunction(instanceData.GetType())(instanceData);
			}
		}

		/// <summary>Specifies the maximum number of objects of the specified type to be provided at a time.</summary>
		/// <param name="instrumentationClass">The class for which the batch size is being set.</param>
		/// <param name="batchSize">The maximum number of objects to be provided at a time.</param>
		public static void SetBatchSize(Type instrumentationClass, int batchSize)
		{
			GetInstrumentedAssembly(instrumentationClass.Assembly).SetBatchSize(instrumentationClass, batchSize);
		}

		internal static ProvisionFunction GetFireFunction(Type type)
		{
			return GetInstrumentedAssembly(type.Assembly).Fire;
		}

		internal static ProvisionFunction GetPublishFunction(Type type)
		{
			return GetInstrumentedAssembly(type.Assembly).Publish;
		}

		internal static ProvisionFunction GetRevokeFunction(Type type)
		{
			return GetInstrumentedAssembly(type.Assembly).Revoke;
		}

		private static void Initialize(Assembly assembly)
		{
			lock (instrumentedAssemblies)
			{
				if (instrumentedAssemblies.ContainsKey(assembly))
				{
					return;
				}
				SchemaNaming schemaNaming = SchemaNaming.GetSchemaNaming(assembly);
				if (schemaNaming == null)
				{
					return;
				}
				if (!schemaNaming.IsAssemblyRegistered())
				{
					if (!WMICapabilities.IsUserAdmin())
					{
						throw new Exception(RC.GetString("ASSEMBLY_NOT_REGISTERED"));
					}
					schemaNaming.DecoupledProviderInstanceName = AssemblyNameUtility.UniqueToAssemblyFullVersion(assembly);
					schemaNaming.RegisterNonAssemblySpecificSchema(null);
					schemaNaming.RegisterAssemblySpecificSchema();
				}
				InstrumentedAssembly value = new InstrumentedAssembly(assembly, schemaNaming);
				instrumentedAssemblies.Add(assembly, value);
			}
		}

		private static InstrumentedAssembly GetInstrumentedAssembly(Assembly assembly)
		{
			lock (instrumentedAssemblies)
			{
				if (!instrumentedAssemblies.ContainsKey(assembly))
				{
					Initialize(assembly);
				}
				return (InstrumentedAssembly)instrumentedAssemblies[assembly];
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.Instrumentation" /> class.</summary>
		public Instrumentation()
		{
		}
	}
	internal delegate void ConvertToWMI(object obj);
	internal class InstrumentedAssembly
	{
		private class TypeInfo
		{
			private FieldInfo fieldInfo;

			private int batchSize = 64;

			private bool batchEvents = true;

			private ConvertToWMI[] convertFunctionsBatch;

			private ConvertToWMI convertFunctionNoBatch;

			private IntPtr[] wbemObjects;

			private Type converterType;

			private int currentIndex;

			public EventSource source;

			public int lastFire;

			public Thread cleanupThread;

			public void Fire(object o)
			{
				if (source.Any())
				{
					return;
				}
				if (!batchEvents)
				{
					lock (this)
					{
						convertFunctionNoBatch(o);
						wbemObjects[0] = (IntPtr)fieldInfo.GetValue(convertFunctionNoBatch.Target);
						source.IndicateEvents(1, wbemObjects);
						return;
					}
				}
				lock (this)
				{
					convertFunctionsBatch[currentIndex++](o);
					wbemObjects[currentIndex - 1] = (IntPtr)fieldInfo.GetValue(convertFunctionsBatch[currentIndex - 1].Target);
					if (cleanupThread == null)
					{
						int tickCount = Environment.TickCount;
						if (tickCount - lastFire < 1000)
						{
							lastFire = Environment.TickCount;
							cleanupThread = new Thread(Cleanup);
							cleanupThread.SetApartmentState(ApartmentState.MTA);
							cleanupThread.Start();
						}
						else
						{
							source.IndicateEvents(currentIndex, wbemObjects);
							currentIndex = 0;
							lastFire = tickCount;
						}
					}
					else if (currentIndex == batchSize)
					{
						source.IndicateEvents(currentIndex, wbemObjects);
						currentIndex = 0;
						lastFire = Environment.TickCount;
					}
				}
			}

			public void SetBatchSize(int batchSize)
			{
				if (batchSize <= 0)
				{
					throw new ArgumentOutOfRangeException("batchSize");
				}
				if (!WMICapabilities.MultiIndicateSupported)
				{
					batchSize = 1;
				}
				lock (this)
				{
					if (currentIndex > 0)
					{
						source.IndicateEvents(currentIndex, wbemObjects);
						currentIndex = 0;
						lastFire = Environment.TickCount;
					}
					wbemObjects = new IntPtr[batchSize];
					if (batchSize > 1)
					{
						batchEvents = true;
						this.batchSize = batchSize;
						convertFunctionsBatch = new ConvertToWMI[batchSize];
						for (int i = 0; i < batchSize; i++)
						{
							object obj = Activator.CreateInstance(converterType);
							convertFunctionsBatch[i] = (ConvertToWMI)Delegate.CreateDelegate(typeof(ConvertToWMI), obj, "ToWMI");
							wbemObjects[i] = ExtractIntPtr(obj);
						}
						fieldInfo = convertFunctionsBatch[0].Target.GetType().GetField("instWbemObjectAccessIP");
					}
					else
					{
						fieldInfo = convertFunctionNoBatch.Target.GetType().GetField("instWbemObjectAccessIP");
						wbemObjects[0] = ExtractIntPtr(convertFunctionNoBatch.Target);
						batchEvents = false;
					}
				}
			}

			public IntPtr ExtractIntPtr(object o)
			{
				return (IntPtr)o.GetType().GetField("instWbemObjectAccessIP").GetValue(o);
			}

			public void Cleanup()
			{
				int num = 0;
				while (num < 20)
				{
					Thread.Sleep(100);
					if (currentIndex == 0)
					{
						num++;
						continue;
					}
					num = 0;
					if (Environment.TickCount - lastFire < 100)
					{
						continue;
					}
					lock (this)
					{
						if (currentIndex > 0)
						{
							source.IndicateEvents(currentIndex, wbemObjects);
							currentIndex = 0;
							lastFire = Environment.TickCount;
						}
					}
				}
				cleanupThread = null;
			}

			public TypeInfo(EventSource source, SchemaNaming naming, Type converterType)
			{
				this.converterType = converterType;
				this.source = source;
				object target = Activator.CreateInstance(converterType);
				convertFunctionNoBatch = (ConvertToWMI)Delegate.CreateDelegate(typeof(ConvertToWMI), target, "ToWMI");
				SetBatchSize(batchSize);
			}
		}

		private SchemaNaming naming;

		public EventSource source;

		public Hashtable mapTypeToConverter;

		public static ReaderWriterLock readerWriterLock = new ReaderWriterLock();

		public static Hashtable mapIDToPublishedObject = new Hashtable();

		private static Hashtable mapPublishedObjectToID = new Hashtable();

		private static int upcountId = 3839;

		private Hashtable mapTypeToTypeInfo = new Hashtable();

		private TypeInfo lastTypeInfo;

		private Type lastType;

		private void InitEventSource(object param)
		{
			InstrumentedAssembly instrumentedAssembly = (InstrumentedAssembly)param;
			instrumentedAssembly.source = new EventSource(instrumentedAssembly.naming.NamespaceName, instrumentedAssembly.naming.DecoupledProviderInstanceName, this);
		}

		public void FindReferences(Type type, CompilerParameters parameters)
		{
			if (!parameters.ReferencedAssemblies.Contains(type.Assembly.Location))
			{
				parameters.ReferencedAssemblies.Add(type.Assembly.Location);
			}
			if (type.BaseType != null)
			{
				FindReferences(type.BaseType, parameters);
			}
			Type[] interfaces = type.GetInterfaces();
			foreach (Type type2 in interfaces)
			{
				if (type2.Assembly != type.Assembly)
				{
					FindReferences(type2, parameters);
				}
			}
		}

		public bool IsInstrumentedType(Type type)
		{
			if (null != type.GetInterface("System.Management.Instrumentation.IEvent", ignoreCase: false) || null != type.GetInterface("System.Management.Instrumentation.IInstance", ignoreCase: false))
			{
				return true;
			}
			object[] customAttributes = type.GetCustomAttributes(typeof(InstrumentationClassAttribute), inherit: true);
			if (customAttributes == null || customAttributes.Length == 0)
			{
				return false;
			}
			return true;
		}

		public InstrumentedAssembly(Assembly assembly, SchemaNaming naming)
		{
			SecurityHelper.UnmanagedCode.Demand();
			this.naming = naming;
			Assembly assembly2 = naming.PrecompiledAssembly;
			if (null == assembly2)
			{
				CSharpCodeProvider cSharpCodeProvider = new CSharpCodeProvider();
				CompilerParameters compilerParameters = new CompilerParameters
				{
					GenerateInMemory = true,
					ReferencedAssemblies = 
					{
						assembly.Location,
						typeof(BaseEvent).Assembly.Location,
						typeof(Component).Assembly.Location
					}
				};
				Type[] types = assembly.GetTypes();
				foreach (Type type in types)
				{
					if (IsInstrumentedType(type))
					{
						FindReferences(type, compilerParameters);
					}
				}
				CompilerResults compilerResults = cSharpCodeProvider.CompileAssemblyFromSource(compilerParameters, naming.Code);
				foreach (CompilerError error in compilerResults.Errors)
				{
					Console.WriteLine(error.ToString());
				}
				if (compilerResults.Errors.HasErrors)
				{
					throw new Exception(RC.GetString("FAILED_TO_BUILD_GENERATED_ASSEMBLY"));
				}
				assembly2 = compilerResults.CompiledAssembly;
			}
			Type type2 = assembly2.GetType("WMINET_Converter");
			mapTypeToConverter = (Hashtable)type2.GetField("mapTypeToConverter").GetValue(null);
			if (!MTAHelper.IsNoContextMTA())
			{
				ThreadDispatch threadDispatch = new ThreadDispatch((ThreadDispatch.ThreadWorkerMethodWithParam)InitEventSource);
				threadDispatch.Parameter = this;
				threadDispatch.Start();
			}
			else
			{
				InitEventSource(this);
			}
		}

		public void Fire(object o)
		{
			SecurityHelper.UnmanagedCode.Demand();
			Fire(o.GetType(), o);
		}

		public void Publish(object o)
		{
			SecurityHelper.UnmanagedCode.Demand();
			try
			{
				readerWriterLock.AcquireWriterLock(-1);
				if (!mapPublishedObjectToID.ContainsKey(o))
				{
					mapIDToPublishedObject.Add(upcountId.ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int))), o);
					mapPublishedObjectToID.Add(o, upcountId);
					upcountId++;
				}
			}
			finally
			{
				readerWriterLock.ReleaseWriterLock();
			}
		}

		public void Revoke(object o)
		{
			SecurityHelper.UnmanagedCode.Demand();
			try
			{
				readerWriterLock.AcquireWriterLock(-1);
				object obj = mapPublishedObjectToID[o];
				if (obj != null)
				{
					int num = (int)obj;
					mapPublishedObjectToID.Remove(o);
					mapIDToPublishedObject.Remove(num.ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(int))));
				}
			}
			finally
			{
				readerWriterLock.ReleaseWriterLock();
			}
		}

		public void SetBatchSize(Type t, int batchSize)
		{
			GetTypeInfo(t).SetBatchSize(batchSize);
		}

		private TypeInfo GetTypeInfo(Type t)
		{
			lock (mapTypeToTypeInfo)
			{
				if (lastType == t)
				{
					return lastTypeInfo;
				}
				lastType = t;
				TypeInfo typeInfo = (TypeInfo)mapTypeToTypeInfo[t];
				if (typeInfo == null)
				{
					typeInfo = new TypeInfo(source, naming, (Type)mapTypeToConverter[t]);
					mapTypeToTypeInfo.Add(t, typeInfo);
				}
				lastTypeInfo = typeInfo;
				return typeInfo;
			}
		}

		public void Fire(Type t, object o)
		{
			TypeInfo typeInfo = GetTypeInfo(t);
			typeInfo.Fire(o);
		}
	}
	/// <summary>Specifies a source of a management instrumentation event. Objects that implement this interface are known to be sources of management instrumentation events. Classes that do not derive from <see cref="T:System.Management.Instrumentation.BaseEvent" /> should implement this interface instead.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	public interface IEvent
	{
		/// <summary>Raises a management event.</summary>
		void Fire();
	}
	/// <summary>Represents classes derived from <see cref="T:System.Management.Instrumentation.BaseEvent" /> that are known to be management event classes. These derived classes inherit an implementation of <see cref="T:System.Management.Instrumentation.IEvent" /> that allows events to be fired through the <see cref="M:System.Management.Instrumentation.BaseEvent.Fire" /> method.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[InstrumentationClass(InstrumentationType.Event)]
	public abstract class BaseEvent : IEvent
	{
		private ProvisionFunction fireFunction;

		private ProvisionFunction FireFunction
		{
			get
			{
				if (fireFunction == null)
				{
					fireFunction = Instrumentation.GetFireFunction(GetType());
				}
				return fireFunction;
			}
		}

		/// <summary>Raises a management event.</summary>
		public void Fire()
		{
			FireFunction(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.BaseEvent" /> class.</summary>
		protected BaseEvent()
		{
		}
	}
	/// <summary>Specifies a source of a management instrumentation instance. Objects that implement this interface are known to be sources of management instrumentation instances. Classes that do not derive from <see cref="T:System.Management.Instrumentation.Instance" /> should implement this interface instead.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	public interface IInstance
	{
		/// <summary>Gets or sets a value indicating whether instances of classes that implement this interface are visible through management instrumentation.</summary>
		/// <returns>
		///   <see langword="true" /> if instances of classes that implement this interface are visible through management instrumentation; otherwise, <see langword="false" />.</returns>
		bool Published { get; set; }
	}
	/// <summary>Represents derived classes known to be management instrumentation instance classes. These derived classes inherit an implementation of <see cref="T:System.Management.Instrumentation.IInstance" /> that allows instances to be published through the <see cref="P:System.Management.Instrumentation.IInstance.Published" /> property.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[InstrumentationClass(InstrumentationType.Instance)]
	public abstract class Instance : IInstance
	{
		private ProvisionFunction publishFunction;

		private ProvisionFunction revokeFunction;

		private bool published;

		private ProvisionFunction PublishFunction
		{
			get
			{
				if (publishFunction == null)
				{
					publishFunction = Instrumentation.GetPublishFunction(GetType());
				}
				return publishFunction;
			}
		}

		private ProvisionFunction RevokeFunction
		{
			get
			{
				if (revokeFunction == null)
				{
					revokeFunction = Instrumentation.GetRevokeFunction(GetType());
				}
				return revokeFunction;
			}
		}

		/// <summary>Gets or sets a value indicating whether instances of classes that implement this interface are visible through management instrumentation.</summary>
		/// <returns>Returns a <see cref="T:System.Boolean" /> value indicating whether instances of classes that implement this interface are visible through management instrumentation.</returns>
		[IgnoreMember]
		public bool Published
		{
			get
			{
				return published;
			}
			set
			{
				if (published && !value)
				{
					RevokeFunction(this);
					published = false;
				}
				else if (!published && value)
				{
					PublishFunction(this);
					published = true;
				}
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.Instance" /> class.</summary>
		protected Instance()
		{
		}
	}
	/// <summary>Installs instrumented assemblies. Include an instance of this installer class in the project installer for an assembly that includes instrumentation.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	public class ManagementInstaller : Installer
	{
		private static bool helpPrinted;

		private string mof;

		/// <summary>Gets or sets installer options for this class.</summary>
		/// <returns>Returns a <see cref="T:System.String" /> value containing the installer options for this class.</returns>
		public override string HelpText
		{
			get
			{
				if (helpPrinted)
				{
					return base.HelpText;
				}
				helpPrinted = true;
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append("/MOF=[filename]\r\n");
				stringBuilder.Append(" " + RC.GetString("FILETOWRITE_MOF") + "\r\n\r\n");
				stringBuilder.Append("/Force or /F\r\n");
				stringBuilder.Append(" " + RC.GetString("FORCE_UPDATE"));
				return stringBuilder.ToString() + base.HelpText;
			}
		}

		/// <summary>Installs the assembly.</summary>
		/// <param name="savedState">The state of the assembly.</param>
		public override void Install(IDictionary savedState)
		{
			FileIOPermission fileIOPermission = new FileIOPermission(FileIOPermissionAccess.Read, base.Context.Parameters["assemblypath"]);
			fileIOPermission.Demand();
			base.Install(savedState);
			base.Context.LogMessage(RC.GetString("WMISCHEMA_INSTALLATIONSTART"));
			string assemblyFile = base.Context.Parameters["assemblypath"];
			Assembly assembly = Assembly.LoadFrom(assemblyFile);
			SchemaNaming schemaNaming = SchemaNaming.GetSchemaNaming(assembly);
			schemaNaming.DecoupledProviderInstanceName = AssemblyNameUtility.UniqueToAssemblyFullVersion(assembly);
			if (schemaNaming != null)
			{
				if (!schemaNaming.IsAssemblyRegistered() || base.Context.Parameters.ContainsKey("force") || base.Context.Parameters.ContainsKey("f"))
				{
					base.Context.LogMessage(RC.GetString("REGESTRING_ASSEMBLY") + " " + schemaNaming.DecoupledProviderInstanceName);
					schemaNaming.RegisterNonAssemblySpecificSchema(base.Context);
					schemaNaming.RegisterAssemblySpecificSchema();
				}
				mof = schemaNaming.Mof;
				base.Context.LogMessage(RC.GetString("WMISCHEMA_INSTALLATIONEND"));
			}
		}

		/// <summary>Commits the assembly to the operation.</summary>
		/// <param name="savedState">The state of the assembly.</param>
		public override void Commit(IDictionary savedState)
		{
			base.Commit(savedState);
			if (base.Context.Parameters.ContainsKey("mof"))
			{
				string text = base.Context.Parameters["mof"];
				if (text == null || text.Length == 0)
				{
					text = base.Context.Parameters["assemblypath"];
					text = ((text != null && text.Length != 0) ? Path.GetFileName(text) : "defaultmoffile");
				}
				if (text.Length < 4)
				{
					text += ".mof";
				}
				else if (string.Compare(text.Substring(text.Length - 4, 4), ".mof", StringComparison.OrdinalIgnoreCase) != 0)
				{
					text += ".mof";
				}
				base.Context.LogMessage(RC.GetString("MOFFILE_GENERATING") + " " + text);
				using StreamWriter streamWriter = new StreamWriter(text, append: false, Encoding.Unicode);
				streamWriter.WriteLine("//**************************************************************************");
				streamWriter.WriteLine("//* {0}", text);
				streamWriter.WriteLine("//**************************************************************************");
				streamWriter.WriteLine(mof);
			}
		}

		/// <summary>Rolls back the state of the assembly.</summary>
		/// <param name="savedState">The state of the assembly.</param>
		public override void Rollback(IDictionary savedState)
		{
			base.Rollback(savedState);
		}

		/// <summary>Uninstalls the assembly.</summary>
		/// <param name="savedState">The state of the assembly.</param>
		public override void Uninstall(IDictionary savedState)
		{
			base.Uninstall(savedState);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.ManagementInstaller" /> class.</summary>
		public ManagementInstaller()
		{
		}
	}
	/// <summary>Installs an instrumented assembly. To use this default project installer, derive a class from <see cref="T:System.Management.Instrumentation.DefaultManagementProjectInstaller" /> inside the assembly. No methods need to be overridden.  
	///  Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	public class DefaultManagementProjectInstaller : Installer
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.DefaultManagementProjectInstaller" /> class. This is the default constructor.</summary>
		public DefaultManagementProjectInstaller()
		{
			ManagementInstaller value = new ManagementInstaller();
			base.Installers.Add(value);
		}
	}
	internal class SchemaMapping
	{
		private Type classType;

		private ManagementClass newClass;

		private string className;

		private string classPath;

		private string codeClassName;

		private CodeWriter code = new CodeWriter();

		private InstrumentationType instrumentationType;

		public Type ClassType => classType;

		public ManagementClass NewClass => newClass;

		public string ClassName => className;

		public string ClassPath => classPath;

		public CodeWriter Code => code;

		public string CodeClassName => codeClassName;

		public InstrumentationType InstrumentationType => instrumentationType;

		public static void ThrowUnsupportedMember(MemberInfo mi)
		{
			ThrowUnsupportedMember(mi, null);
		}

		public static void ThrowUnsupportedMember(MemberInfo mi, Exception innerException)
		{
			throw new ArgumentException(string.Format(RC.GetString("UNSUPPORTEDMEMBER_EXCEPT"), mi.Name), mi.Name, innerException);
		}

		public SchemaMapping(Type type, SchemaNaming naming, Hashtable mapTypeToConverterClassName)
		{
			codeClassName = (string)mapTypeToConverterClassName[type];
			classType = type;
			bool flag = false;
			string baseClassName = ManagedNameAttribute.GetBaseClassName(type);
			className = ManagedNameAttribute.GetMemberName(type);
			instrumentationType = InstrumentationClassAttribute.GetAttribute(type).InstrumentationType;
			classPath = naming.NamespaceName + ":" + className;
			if (baseClassName == null)
			{
				newClass = new ManagementClass(naming.NamespaceName, "", null);
				newClass.SystemProperties["__CLASS"].Value = className;
			}
			else
			{
				ManagementClass managementClass = new ManagementClass(naming.NamespaceName + ":" + baseClassName);
				if (instrumentationType == InstrumentationType.Instance)
				{
					bool flag2 = false;
					try
					{
						QualifierData qualifierData = managementClass.Qualifiers["abstract"];
						if (qualifierData.Value is bool)
						{
							flag2 = (bool)qualifierData.Value;
						}
					}
					catch (ManagementException ex)
					{
						if (ex.ErrorCode != ManagementStatus.NotFound)
						{
							throw;
						}
					}
					if (!flag2)
					{
						throw new Exception(RC.GetString("CLASSINST_EXCEPT"));
					}
				}
				newClass = managementClass.Derive(className);
			}
			CodeWriter codeWriter = code.AddChild("public class " + codeClassName + " : IWmiConverter");
			CodeWriter codeWriter2 = codeWriter.AddChild(new CodeWriter());
			codeWriter2.Line("static ManagementClass managementClass = new ManagementClass(@\"" + classPath + "\");");
			codeWriter2.Line("static IntPtr classWbemObjectIP;");
			codeWriter2.Line("static Guid iidIWbemObjectAccess = new Guid(\"49353C9A-516B-11D1-AEA6-00C04FB68820\");");
			codeWriter2.Line("internal ManagementObject instance = managementClass.CreateInstance();");
			codeWriter2.Line("object reflectionInfoTempObj = null ; ");
			codeWriter2.Line("FieldInfo reflectionIWbemClassObjectField = null ; ");
			codeWriter2.Line("IntPtr emptyWbemObject = IntPtr.Zero ; ");
			codeWriter2.Line("IntPtr originalObject = IntPtr.Zero ; ");
			codeWriter2.Line("bool toWmiCalled = false ; ");
			codeWriter2.Line("IntPtr theClone = IntPtr.Zero;");
			codeWriter2.Line("public static ManagementObject emptyInstance = managementClass.CreateInstance();");
			codeWriter2.Line("public IntPtr instWbemObjectAccessIP;");
			CodeWriter codeWriter3 = codeWriter.AddChild("static " + codeClassName + "()");
			codeWriter3.Line("classWbemObjectIP = (IntPtr)managementClass;");
			codeWriter3.Line("IntPtr wbemObjectAccessIP;");
			codeWriter3.Line("Marshal.QueryInterface(classWbemObjectIP, ref iidIWbemObjectAccess, out wbemObjectAccessIP);");
			codeWriter3.Line("int cimType;");
			CodeWriter codeWriter4 = codeWriter.AddChild("public " + codeClassName + "()");
			codeWriter4.Line("IntPtr wbemObjectIP = (IntPtr)instance;");
			codeWriter4.Line("originalObject = (IntPtr)instance;");
			codeWriter4.Line("Marshal.QueryInterface(wbemObjectIP, ref iidIWbemObjectAccess, out instWbemObjectAccessIP);");
			codeWriter4.Line("FieldInfo tempField = instance.GetType().GetField ( \"_wbemObject\", BindingFlags.Instance | BindingFlags.NonPublic );");
			codeWriter4.Line("if ( tempField == null )");
			codeWriter4.Line("{");
			codeWriter4.Line("   tempField = instance.GetType().GetField ( \"wbemObject\", BindingFlags.Instance | BindingFlags.NonPublic ) ;");
			codeWriter4.Line("}");
			codeWriter4.Line("reflectionInfoTempObj = tempField.GetValue (instance) ;");
			codeWriter4.Line("reflectionIWbemClassObjectField = reflectionInfoTempObj.GetType().GetField (\"pWbemClassObject\", BindingFlags.Instance | BindingFlags.NonPublic );");
			codeWriter4.Line("emptyWbemObject = (IntPtr) emptyInstance;");
			CodeWriter codeWriter5 = codeWriter.AddChild("~" + codeClassName + "()");
			codeWriter5.AddChild("if(instWbemObjectAccessIP != IntPtr.Zero)").Line("Marshal.Release(instWbemObjectAccessIP);");
			codeWriter5.Line("if ( toWmiCalled == true )");
			codeWriter5.Line("{");
			codeWriter5.Line("\tMarshal.Release (originalObject);");
			codeWriter5.Line("}");
			CodeWriter codeWriter6 = codeWriter.AddChild("public void ToWMI(object obj)");
			codeWriter6.Line("toWmiCalled = true ;");
			codeWriter6.Line("if(instWbemObjectAccessIP != IntPtr.Zero)");
			codeWriter6.Line("{");
			codeWriter6.Line("    Marshal.Release(instWbemObjectAccessIP);");
			codeWriter6.Line("    instWbemObjectAccessIP = IntPtr.Zero;");
			codeWriter6.Line("}");
			codeWriter6.Line("if(theClone != IntPtr.Zero)");
			codeWriter6.Line("{");
			codeWriter6.Line("    Marshal.Release(theClone);");
			codeWriter6.Line("    theClone = IntPtr.Zero;");
			codeWriter6.Line("}");
			codeWriter6.Line("IWOA.Clone_f(12, emptyWbemObject, out theClone) ;");
			codeWriter6.Line("Marshal.QueryInterface(theClone, ref iidIWbemObjectAccess, out instWbemObjectAccessIP) ;");
			codeWriter6.Line("reflectionIWbemClassObjectField.SetValue ( reflectionInfoTempObj, theClone ) ;");
			codeWriter6.Line(string.Format("{0} instNET = ({0})obj;", type.FullName.Replace('+', '.')));
			CodeWriter codeWriter7 = codeWriter.AddChild("public static explicit operator IntPtr(" + codeClassName + " obj)");
			codeWriter7.Line("return obj.instWbemObjectAccessIP;");
			codeWriter2.Line("public ManagementObject GetInstance() {return instance;}");
			PropertyDataCollection properties = newClass.Properties;
			switch (instrumentationType)
			{
			case InstrumentationType.Instance:
				properties.Add("ProcessId", CimType.String, isArray: false);
				properties.Add("InstanceId", CimType.String, isArray: false);
				properties["ProcessId"].Qualifiers.Add("key", true);
				properties["InstanceId"].Qualifiers.Add("key", true);
				newClass.Qualifiers.Add("dynamic", true, isAmended: false, propagatesToInstance: false, propagatesToSubclass: false, isOverridable: true);
				newClass.Qualifiers.Add("provider", naming.DecoupledProviderInstanceName, isAmended: false, propagatesToInstance: false, propagatesToSubclass: false, isOverridable: true);
				break;
			case InstrumentationType.Abstract:
				newClass.Qualifiers.Add("abstract", true, isAmended: false, propagatesToInstance: false, propagatesToSubclass: false, isOverridable: true);
				break;
			}
			int num = 0;
			bool flag3 = false;
			MemberInfo[] members = type.GetMembers();
			foreach (MemberInfo memberInfo in members)
			{
				if ((!(memberInfo is FieldInfo) && !(memberInfo is PropertyInfo)) || memberInfo.GetCustomAttributes(typeof(IgnoreMemberAttribute), inherit: false).Length != 0)
				{
					continue;
				}
				if (memberInfo is FieldInfo)
				{
					FieldInfo fieldInfo = memberInfo as FieldInfo;
					if (fieldInfo.IsStatic)
					{
						ThrowUnsupportedMember(memberInfo);
					}
				}
				else if (memberInfo is PropertyInfo)
				{
					PropertyInfo propertyInfo = memberInfo as PropertyInfo;
					if (!propertyInfo.CanRead)
					{
						ThrowUnsupportedMember(memberInfo);
					}
					MethodInfo getMethod = propertyInfo.GetGetMethod();
					if (null == getMethod || getMethod.IsStatic)
					{
						ThrowUnsupportedMember(memberInfo);
					}
					if (getMethod.GetParameters().Length != 0)
					{
						ThrowUnsupportedMember(memberInfo);
					}
				}
				string memberName = ManagedNameAttribute.GetMemberName(memberInfo);
				Type type2 = ((!(memberInfo is FieldInfo)) ? (memberInfo as PropertyInfo).PropertyType : (memberInfo as FieldInfo).FieldType);
				bool flag4 = false;
				if (type2.IsArray)
				{
					if (type2.GetArrayRank() != 1)
					{
						ThrowUnsupportedMember(memberInfo);
					}
					flag4 = true;
					type2 = type2.GetElementType();
				}
				string text = null;
				string text2 = null;
				if (mapTypeToConverterClassName.Contains(type2))
				{
					text2 = (string)mapTypeToConverterClassName[type2];
					text = ManagedNameAttribute.GetMemberName(type2);
				}
				bool flag5 = false;
				if (type2 == typeof(object))
				{
					flag5 = true;
					if (!flag)
					{
						flag = true;
						codeWriter2.Line("static Hashtable mapTypeToConverter = new Hashtable();");
						foreach (DictionaryEntry item in mapTypeToConverterClassName)
						{
							codeWriter3.Line($"mapTypeToConverter[typeof({((Type)item.Key).FullName.Replace('+', '.')})] = typeof({(string)item.Value});");
						}
					}
				}
				string text3 = "prop_" + num;
				string text4 = "handle_" + num++;
				codeWriter2.Line("static int " + text4 + ";");
				codeWriter3.Line($"IWOA.GetPropertyHandle_f27(27, wbemObjectAccessIP, \"{memberName}\", out cimType, out {text4});");
				codeWriter2.Line("PropertyData " + text3 + ";");
				codeWriter4.Line($"{text3} = instance.Properties[\"{memberName}\"];");
				if (flag5)
				{
					CodeWriter codeWriter8 = codeWriter6.AddChild($"if(instNET.{memberInfo.Name} != null)");
					CodeWriter codeWriter9 = codeWriter6.AddChild("else");
					codeWriter9.Line($"{text3}.Value = null;");
					if (flag4)
					{
						codeWriter8.Line($"int len = instNET.{memberInfo.Name}.Length;");
						codeWriter8.Line("ManagementObject[] embeddedObjects = new ManagementObject[len];");
						codeWriter8.Line("IWmiConverter[] embeddedConverters = new IWmiConverter[len];");
						CodeWriter codeWriter10 = codeWriter8.AddChild("for(int i=0;i<len;i++)");
						CodeWriter codeWriter11 = codeWriter10.AddChild(string.Format("if((instNET.{0}[i] != null) && mapTypeToConverter.Contains(instNET.{0}[i].GetType()))", memberInfo.Name));
						codeWriter11.Line($"Type type = (Type)mapTypeToConverter[instNET.{memberInfo.Name}[i].GetType()];");
						codeWriter11.Line("embeddedConverters[i] = (IWmiConverter)Activator.CreateInstance(type);");
						codeWriter11.Line($"embeddedConverters[i].ToWMI(instNET.{memberInfo.Name}[i]);");
						codeWriter11.Line("embeddedObjects[i] = embeddedConverters[i].GetInstance();");
						codeWriter10.AddChild("else").Line($"embeddedObjects[i] = SafeAssign.GetManagementObject(instNET.{memberInfo.Name}[i]);");
						codeWriter8.Line($"{text3}.Value = embeddedObjects;");
					}
					else
					{
						CodeWriter codeWriter12 = codeWriter8.AddChild($"if(mapTypeToConverter.Contains(instNET.{memberInfo.Name}.GetType()))");
						codeWriter12.Line($"Type type = (Type)mapTypeToConverter[instNET.{memberInfo.Name}.GetType()];");
						codeWriter12.Line("IWmiConverter converter = (IWmiConverter)Activator.CreateInstance(type);");
						codeWriter12.Line($"converter.ToWMI(instNET.{memberInfo.Name});");
						codeWriter12.Line($"{text3}.Value = converter.GetInstance();");
						codeWriter8.AddChild("else").Line($"{text3}.Value = SafeAssign.GetInstance(instNET.{memberInfo.Name});");
					}
				}
				else if (text != null)
				{
					CodeWriter codeWriter13;
					if (type2.IsValueType)
					{
						codeWriter13 = codeWriter6;
					}
					else
					{
						codeWriter13 = codeWriter6.AddChild($"if(instNET.{memberInfo.Name} != null)");
						CodeWriter codeWriter14 = codeWriter6.AddChild("else");
						codeWriter14.Line($"{text3}.Value = null;");
					}
					if (flag4)
					{
						codeWriter13.Line($"int len = instNET.{memberInfo.Name}.Length;");
						codeWriter13.Line("ManagementObject[] embeddedObjects = new ManagementObject[len];");
						codeWriter13.Line(string.Format("{0}[] embeddedConverters = new {0}[len];", text2));
						CodeWriter codeWriter15 = codeWriter13.AddChild("for(int i=0;i<len;i++)");
						codeWriter15.Line($"embeddedConverters[i] = new {text2}();");
						if (type2.IsValueType)
						{
							codeWriter15.Line($"embeddedConverters[i].ToWMI(instNET.{memberInfo.Name}[i]);");
						}
						else
						{
							CodeWriter codeWriter16 = codeWriter15.AddChild($"if(instNET.{memberInfo.Name}[i] != null)");
							codeWriter16.Line($"embeddedConverters[i].ToWMI(instNET.{memberInfo.Name}[i]);");
						}
						codeWriter15.Line("embeddedObjects[i] = embeddedConverters[i].instance;");
						codeWriter13.Line($"{text3}.Value = embeddedObjects;");
					}
					else
					{
						codeWriter2.Line($"{text2} lazy_embeddedConverter_{text3} = null;");
						CodeWriter codeWriter17 = codeWriter.AddChild($"{text2} embeddedConverter_{text3}");
						CodeWriter codeWriter18 = codeWriter17.AddChild("get");
						CodeWriter codeWriter19 = codeWriter18.AddChild($"if(null == lazy_embeddedConverter_{text3})");
						codeWriter19.Line($"lazy_embeddedConverter_{text3} = new {text2}();");
						codeWriter18.Line($"return lazy_embeddedConverter_{text3};");
						codeWriter13.Line($"embeddedConverter_{text3}.ToWMI(instNET.{memberInfo.Name});");
						codeWriter13.Line(string.Format("{0}.Value = embeddedConverter_{0}.instance;", text3));
					}
				}
				else if (!flag4)
				{
					if (type2 == typeof(byte) || type2 == typeof(sbyte))
					{
						codeWriter6.Line(string.Format("{0} instNET_{1} = instNET.{1} ;", type2, memberInfo.Name));
						codeWriter6.Line($"IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {text4}, 1, ref instNET_{memberInfo.Name});");
					}
					else if (type2 == typeof(short) || type2 == typeof(ushort) || type2 == typeof(char))
					{
						codeWriter6.Line(string.Format("{0} instNET_{1} = instNET.{1} ;", type2, memberInfo.Name));
						codeWriter6.Line($"IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {text4}, 2, ref instNET_{memberInfo.Name});");
					}
					else if (type2 == typeof(uint) || type2 == typeof(int) || type2 == typeof(float))
					{
						codeWriter6.Line($"IWOA.WriteDWORD_f31(31, instWbemObjectAccessIP, {text4}, instNET.{memberInfo.Name});");
					}
					else if (type2 == typeof(ulong) || type2 == typeof(long) || type2 == typeof(double))
					{
						codeWriter6.Line($"IWOA.WriteQWORD_f33(33, instWbemObjectAccessIP, {text4}, instNET.{memberInfo.Name});");
					}
					else if (type2 == typeof(bool))
					{
						codeWriter6.Line($"if(instNET.{memberInfo.Name})");
						codeWriter6.Line($"    IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {text4}, 2, ref SafeAssign.boolTrue);");
						codeWriter6.Line("else");
						codeWriter6.Line($"    IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {text4}, 2, ref SafeAssign.boolFalse);");
					}
					else if (type2 == typeof(string))
					{
						CodeWriter codeWriter20 = codeWriter6.AddChild($"if(null != instNET.{memberInfo.Name})");
						codeWriter20.Line(string.Format("IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {0}, (instNET.{1}.Length+1)*2, instNET.{1});", text4, memberInfo.Name));
						codeWriter6.AddChild("else").Line($"IWOA.Put_f5(5, instWbemObjectAccessIP, \"{memberName}\", 0, ref nullObj, 8);");
						if (!flag3)
						{
							flag3 = true;
							codeWriter2.Line("object nullObj = DBNull.Value;");
						}
					}
					else if (type2 == typeof(DateTime) || type2 == typeof(TimeSpan))
					{
						codeWriter6.Line($"IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {text4}, 52, SafeAssign.WMITimeToString(instNET.{memberInfo.Name}));");
					}
					else
					{
						codeWriter6.Line($"{text3}.Value = instNET.{memberInfo.Name};");
					}
				}
				else if (type2 == typeof(DateTime) || type2 == typeof(TimeSpan))
				{
					codeWriter6.AddChild($"if(null == instNET.{memberInfo.Name})").Line($"{text3}.Value = null;");
					codeWriter6.AddChild("else").Line($"{text3}.Value = SafeAssign.WMITimeArrayToStringArray(instNET.{memberInfo.Name});");
				}
				else
				{
					codeWriter6.Line($"{text3}.Value = instNET.{memberInfo.Name};");
				}
				CimType propertyType = CimType.String;
				if (memberInfo.DeclaringType != type)
				{
					continue;
				}
				bool flag6 = true;
				try
				{
					PropertyData propertyData = newClass.Properties[memberName];
					CimType type3 = propertyData.Type;
					if (propertyData.IsLocal)
					{
						throw new ArgumentException(string.Format(RC.GetString("MEMBERCONFLILCT_EXCEPT"), memberInfo.Name), memberInfo.Name);
					}
				}
				catch (ManagementException ex2)
				{
					if (ex2.ErrorCode != ManagementStatus.NotFound)
					{
						throw;
					}
					flag6 = false;
				}
				if (!flag6)
				{
					if (text != null)
					{
						propertyType = CimType.Object;
					}
					else if (flag5)
					{
						propertyType = CimType.Object;
					}
					else if (type2 == typeof(ManagementObject))
					{
						propertyType = CimType.Object;
					}
					else if (type2 == typeof(sbyte))
					{
						propertyType = CimType.SInt8;
					}
					else if (type2 == typeof(byte))
					{
						propertyType = CimType.UInt8;
					}
					else if (type2 == typeof(short))
					{
						propertyType = CimType.SInt16;
					}
					else if (type2 == typeof(ushort))
					{
						propertyType = CimType.UInt16;
					}
					else if (type2 == typeof(int))
					{
						propertyType = CimType.SInt32;
					}
					else if (type2 == typeof(uint))
					{
						propertyType = CimType.UInt32;
					}
					else if (type2 == typeof(long))
					{
						propertyType = CimType.SInt64;
					}
					else if (type2 == typeof(ulong))
					{
						propertyType = CimType.UInt64;
					}
					else if (type2 == typeof(float))
					{
						propertyType = CimType.Real32;
					}
					else if (type2 == typeof(double))
					{
						propertyType = CimType.Real64;
					}
					else if (type2 == typeof(bool))
					{
						propertyType = CimType.Boolean;
					}
					else if (type2 == typeof(string))
					{
						propertyType = CimType.String;
					}
					else if (type2 == typeof(char))
					{
						propertyType = CimType.Char16;
					}
					else if (type2 == typeof(DateTime))
					{
						propertyType = CimType.DateTime;
					}
					else if (type2 == typeof(TimeSpan))
					{
						propertyType = CimType.DateTime;
					}
					else
					{
						ThrowUnsupportedMember(memberInfo);
					}
					try
					{
						properties.Add(memberName, propertyType, flag4);
					}
					catch (ManagementException innerException)
					{
						ThrowUnsupportedMember(memberInfo, innerException);
					}
					if (type2 == typeof(TimeSpan))
					{
						PropertyData propertyData2 = properties[memberName];
						propertyData2.Qualifiers.Add("SubType", "interval", isAmended: false, propagatesToInstance: true, propagatesToSubclass: true, isOverridable: true);
					}
					if (text != null)
					{
						PropertyData propertyData3 = properties[memberName];
						propertyData3.Qualifiers["CIMTYPE"].Value = "object:" + text;
					}
				}
			}
			codeWriter3.Line("Marshal.Release(wbemObjectAccessIP);");
		}
	}
	internal class SchemaNaming
	{
		private class InstallLogWrapper
		{
			private InstallContext context;

			public InstallLogWrapper(InstallContext context)
			{
				this.context = context;
			}

			public void LogMessage(string str)
			{
				if (context != null)
				{
					context.LogMessage(str);
				}
			}
		}

		private class AssemblySpecificNaming
		{
			private string namespaceName;

			private string securityDescriptor;

			private string decoupledProviderInstanceName;

			private string assemblyUniqueIdentifier;

			private string assemblyName;

			private string assemblyPath;

			public string NamespaceName => namespaceName;

			public string SecurityDescriptor => securityDescriptor;

			public string DecoupledProviderInstanceName
			{
				get
				{
					return decoupledProviderInstanceName;
				}
				set
				{
					decoupledProviderInstanceName = value;
				}
			}

			public string AssemblyUniqueIdentifier => assemblyUniqueIdentifier;

			public string AssemblyName => assemblyName;

			public string AssemblyPath => assemblyPath;

			public AssemblySpecificNaming(string namespaceName, string securityDescriptor, Assembly assembly)
			{
				this.namespaceName = namespaceName;
				this.securityDescriptor = securityDescriptor;
				decoupledProviderInstanceName = AssemblyNameUtility.UniqueToAssemblyFullVersion(assembly);
				assemblyUniqueIdentifier = AssemblyNameUtility.UniqueToAssemblyBuild(assembly);
				assemblyName = assembly.FullName;
				assemblyPath = assembly.Location;
			}
		}

		private delegate ManagementClass ClassMaker();

		private Assembly assembly;

		private const string Win32ProviderClassName = "__Win32Provider";

		private const string EventProviderRegistrationClassName = "__EventProviderRegistration";

		private const string InstanceProviderRegistrationClassName = "__InstanceProviderRegistration";

		private const string DecoupledProviderClassName = "MSFT_DecoupledProvider";

		private const string ProviderClassName = "WMINET_ManagedAssemblyProvider";

		private const string InstrumentationClassName = "WMINET_Instrumentation";

		private const string InstrumentedAssembliesClassName = "WMINET_InstrumentedAssembly";

		private const string DecoupledProviderCLSID = "{54D8502C-527D-43f7-A506-A9DA075E229C}";

		private const string GlobalWmiNetNamespace = "root\\MicrosoftWmiNet";

		private const string InstrumentedNamespacesClassName = "WMINET_InstrumentedNamespaces";

		private const string NamingClassName = "WMINET_Naming";

		private AssemblySpecificNaming assemblyInfo;

		private ManagementObject registrationInstance;

		private const string iwoaDef = "class IWOA\r\n{\r\nprotected const string DllName = \"wminet_utils.dll\";\r\nprotected const string EntryPointName = \"UFunc\";\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"GetPropertyHandle\")] public static extern int GetPropertyHandle_f27(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszPropertyName, [Out] out Int32 pType, [Out] out Int32 plHandle);\r\n//[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Byte aData);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"ReadPropertyValue\")] public static extern int ReadPropertyValue_f29(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lBufferSize, [Out] out Int32 plNumBytes, [Out] out Byte aData);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"ReadDWORD\")] public static extern int ReadDWORD_f30(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [Out] out UInt32 pdw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteDWORD\")] public static extern int WriteDWORD_f31(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] UInt32 dw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"ReadQWORD\")] public static extern int ReadQWORD_f32(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [Out] out UInt64 pqw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteQWORD\")] public static extern int WriteQWORD_f33(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] UInt64 pw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"GetPropertyInfoByHandle\")] public static extern int GetPropertyInfoByHandle_f34(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrName, [Out] out Int32 pType);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"Lock\")] public static extern int Lock_f35(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"Unlock\")] public static extern int Unlock_f36(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags);\r\n\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"Put\")] public static extern int Put_f5(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] ref object pVal, [In] Int32 Type);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In][MarshalAs(UnmanagedType.LPWStr)] string str);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Byte n);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref SByte n);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Int16 n);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref UInt16 n);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\", CharSet=CharSet.Unicode)] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Char c);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteDWORD\")] public static extern int WriteDWORD_f31(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 dw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteSingle\")] public static extern int WriteDWORD_f31(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Single dw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteQWORD\")] public static extern int WriteQWORD_f33(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int64 pw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteDouble\")] public static extern int WriteQWORD_f33(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Double pw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"Clone\")] public static extern int Clone_f(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppCopy);\r\n}\r\ninterface IWmiConverter\r\n{\r\n    void ToWMI(object obj);\r\n    ManagementObject GetInstance();\r\n}\r\nclass SafeAssign\r\n{\r\n    public static UInt16 boolTrue = 0xffff;\r\n    public static UInt16 boolFalse = 0;\r\n    static Hashtable validTypes = new Hashtable();\r\n    static SafeAssign()\r\n    {\r\n        validTypes.Add(typeof(SByte), null);\r\n        validTypes.Add(typeof(Byte), null);\r\n        validTypes.Add(typeof(Int16), null);\r\n        validTypes.Add(typeof(UInt16), null);\r\n        validTypes.Add(typeof(Int32), null);\r\n        validTypes.Add(typeof(UInt32), null);\r\n        validTypes.Add(typeof(Int64), null);\r\n        validTypes.Add(typeof(UInt64), null);\r\n        validTypes.Add(typeof(Single), null);\r\n        validTypes.Add(typeof(Double), null);\r\n        validTypes.Add(typeof(Boolean), null);\r\n        validTypes.Add(typeof(String), null);\r\n        validTypes.Add(typeof(Char), null);\r\n        validTypes.Add(typeof(DateTime), null);\r\n        validTypes.Add(typeof(TimeSpan), null);\r\n        validTypes.Add(typeof(ManagementObject), null);\r\n        nullClass.SystemProperties [\"__CLASS\"].Value = \"nullInstance\";\r\n    }\r\n    public static object GetInstance(object o)\r\n    {\r\n        if(o is ManagementObject)\r\n            return o;\r\n        return null;\r\n    }\r\n    static ManagementClass nullClass = new ManagementClass(";

		private const string iwoaDefEnd = ");\r\n    \r\n    public static ManagementObject GetManagementObject(object o)\r\n    {\r\n        if(o != null && o is ManagementObject)\r\n            return o as ManagementObject;\r\n        // Must return empty instance\r\n        return nullClass.CreateInstance();\r\n    }\r\n    public static object GetValue(object o)\r\n    {\r\n        Type t = o.GetType();\r\n        if(t.IsArray)\r\n            t = t.GetElementType();\r\n        if(validTypes.Contains(t))\r\n            return o;\r\n        return null;\r\n    }\r\n    public static string WMITimeToString(DateTime dt)\r\n    {\r\n        TimeSpan ts = dt.Subtract(dt.ToUniversalTime());\r\n        int diffUTC = (ts.Minutes + ts.Hours * 60);\r\n        if(diffUTC >= 0)\r\n            return String.Format(\"{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}.{6:D3}000+{7:D3}\", dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond, diffUTC);\r\n        return String.Format(\"{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}.{6:D3}000-{7:D3}\", dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond, -diffUTC);\r\n    }\r\n    public static string WMITimeToString(TimeSpan ts)\r\n    {\r\n        return String.Format(\"{0:D8}{1:D2}{2:D2}{3:D2}.{4:D3}000:000\", ts.Days, ts.Hours, ts.Minutes, ts.Seconds, ts.Milliseconds);\r\n    }\r\n    public static string[] WMITimeArrayToStringArray(DateTime[] dates)\r\n    {\r\n        string[] strings = new string[dates.Length];\r\n        for(int i=0;i<dates.Length;i++)\r\n            strings[i] = WMITimeToString(dates[i]);\r\n        return strings;\r\n    }\r\n    public static string[] WMITimeArrayToStringArray(TimeSpan[] timeSpans)\r\n    {\r\n        string[] strings = new string[timeSpans.Length];\r\n        for(int i=0;i<timeSpans.Length;i++)\r\n            strings[i] = WMITimeToString(timeSpans[i]);\r\n        return strings;\r\n    }\r\n}\r\n";

		public string NamespaceName => assemblyInfo.NamespaceName;

		public string SecurityDescriptor => assemblyInfo.SecurityDescriptor;

		public string DecoupledProviderInstanceName
		{
			get
			{
				return assemblyInfo.DecoupledProviderInstanceName;
			}
			set
			{
				assemblyInfo.DecoupledProviderInstanceName = value;
			}
		}

		private string AssemblyUniqueIdentifier => assemblyInfo.AssemblyUniqueIdentifier;

		private string AssemblyName => assemblyInfo.AssemblyName;

		private string AssemblyPath => assemblyInfo.AssemblyPath;

		private string Win32ProviderClassPath => MakeClassPath(assemblyInfo.NamespaceName, "__Win32Provider");

		private string DecoupledProviderClassPath => MakeClassPath(assemblyInfo.NamespaceName, "MSFT_DecoupledProvider");

		private string InstrumentationClassPath => MakeClassPath(assemblyInfo.NamespaceName, "WMINET_Instrumentation");

		private string EventProviderRegistrationClassPath => MakeClassPath(assemblyInfo.NamespaceName, "__EventProviderRegistration");

		private string EventProviderRegistrationPath => AppendProperty(EventProviderRegistrationClassPath, "provider", "\\\\\\\\.\\\\" + ProviderPath.Replace("\\", "\\\\").Replace("\"", "\\\""));

		private string InstanceProviderRegistrationClassPath => MakeClassPath(assemblyInfo.NamespaceName, "__InstanceProviderRegistration");

		private string InstanceProviderRegistrationPath => AppendProperty(InstanceProviderRegistrationClassPath, "provider", "\\\\\\\\.\\\\" + ProviderPath.Replace("\\", "\\\\").Replace("\"", "\\\""));

		private string ProviderClassPath => MakeClassPath(assemblyInfo.NamespaceName, "WMINET_ManagedAssemblyProvider");

		private string ProviderPath => AppendProperty(ProviderClassPath, "Name", assemblyInfo.DecoupledProviderInstanceName);

		private string RegistrationClassPath => MakeClassPath(assemblyInfo.NamespaceName, "WMINET_InstrumentedAssembly");

		private string RegistrationPath => AppendProperty(RegistrationClassPath, "Name", assemblyInfo.DecoupledProviderInstanceName);

		private string GlobalRegistrationNamespace => "root\\MicrosoftWmiNet";

		private string GlobalInstrumentationClassPath => MakeClassPath("root\\MicrosoftWmiNet", "WMINET_Instrumentation");

		private string GlobalRegistrationClassPath => MakeClassPath("root\\MicrosoftWmiNet", "WMINET_InstrumentedNamespaces");

		private string GlobalRegistrationPath => AppendProperty(GlobalRegistrationClassPath, "NamespaceName", assemblyInfo.NamespaceName.Replace("\\", "\\\\"));

		private string GlobalNamingClassPath => MakeClassPath("root\\MicrosoftWmiNet", "WMINET_Naming");

		private string DataDirectory => Path.Combine(WMICapabilities.FrameworkDirectory, NamespaceName);

		private string MofPath => Path.Combine(DataDirectory, DecoupledProviderInstanceName + ".mof");

		private string CodePath => Path.Combine(DataDirectory, DecoupledProviderInstanceName + ".cs");

		private string PrecompiledAssemblyPath => Path.Combine(DataDirectory, DecoupledProviderInstanceName + ".dll");

		private ManagementObject RegistrationInstance
		{
			get
			{
				if (registrationInstance == null)
				{
					registrationInstance = new ManagementObject(RegistrationPath);
				}
				return registrationInstance;
			}
		}

		public string Code
		{
			get
			{
				using StreamReader streamReader = new StreamReader(CodePath);
				return streamReader.ReadToEnd();
			}
		}

		public string Mof
		{
			get
			{
				using StreamReader streamReader = new StreamReader(MofPath);
				return streamReader.ReadToEnd();
			}
		}

		public Assembly PrecompiledAssembly
		{
			get
			{
				if (File.Exists(PrecompiledAssemblyPath))
				{
					return Assembly.LoadFrom(PrecompiledAssemblyPath);
				}
				return null;
			}
		}

		public static SchemaNaming GetSchemaNaming(Assembly assembly)
		{
			InstrumentedAttribute attribute = InstrumentedAttribute.GetAttribute(assembly);
			if (attribute == null)
			{
				return null;
			}
			return new SchemaNaming(attribute.NamespaceName, attribute.SecurityDescriptor, assembly);
		}

		private SchemaNaming(string namespaceName, string securityDescriptor, Assembly assembly)
		{
			this.assembly = assembly;
			assemblyInfo = new AssemblySpecificNaming(namespaceName, securityDescriptor, assembly);
			if (!DoesInstanceExist(RegistrationPath))
			{
				assemblyInfo.DecoupledProviderInstanceName = AssemblyNameUtility.UniqueToAssemblyMinorVersion(assembly);
			}
		}

		private static string MakeClassPath(string namespaceName, string className)
		{
			return namespaceName + ":" + className;
		}

		private static string AppendProperty(string classPath, string propertyName, string propertyValue)
		{
			return classPath + "." + propertyName + "=\"" + propertyValue + "\"";
		}

		public bool IsAssemblyRegistered()
		{
			if (DoesInstanceExist(RegistrationPath))
			{
				ManagementObject managementObject = new ManagementObject(RegistrationPath);
				return string.Compare(AssemblyUniqueIdentifier, managementObject["RegisteredBuild"].ToString(), StringComparison.OrdinalIgnoreCase) == 0;
			}
			return false;
		}

		private bool IsSchemaToBeCompared()
		{
			bool result = false;
			if (DoesInstanceExist(RegistrationPath))
			{
				ManagementObject managementObject = new ManagementObject(RegistrationPath);
				result = string.Compare(AssemblyUniqueIdentifier, managementObject["RegisteredBuild"].ToString(), StringComparison.OrdinalIgnoreCase) != 0;
			}
			return result;
		}

		private bool IsClassAlreadyPresentInRepository(ManagementObject obj)
		{
			bool result = false;
			string text = MakeClassPath(NamespaceName, (string)obj.SystemProperties["__CLASS"].Value);
			if (DoesClassExist(text))
			{
				ManagementObject managementObject = new ManagementClass(text);
				result = managementObject.CompareTo(obj, ComparisonSettings.IgnoreObjectSource | ComparisonSettings.IgnoreCase);
			}
			return result;
		}

		private string GenerateMof(string[] mofs)
		{
			return string.Concat("//**************************************************************************\r\n", $"//* {DecoupledProviderInstanceName}\r\n", $"//* {AssemblyUniqueIdentifier}\r\n", "//**************************************************************************\r\n", "#pragma autorecover\r\n", EnsureNamespaceInMof(GlobalRegistrationNamespace), EnsureNamespaceInMof(NamespaceName), PragmaNamespace(GlobalRegistrationNamespace), GetMofFormat(new ManagementClass(GlobalInstrumentationClassPath)), GetMofFormat(new ManagementClass(GlobalRegistrationClassPath)), GetMofFormat(new ManagementClass(GlobalNamingClassPath)), GetMofFormat(new ManagementObject(GlobalRegistrationPath)), PragmaNamespace(NamespaceName), GetMofFormat(new ManagementClass(InstrumentationClassPath)), GetMofFormat(new ManagementClass(RegistrationClassPath)), GetMofFormat(new ManagementClass(DecoupledProviderClassPath)), GetMofFormat(new ManagementClass(ProviderClassPath)), GetMofFormat(new ManagementObject(ProviderPath)), GetMofFormat(new ManagementObject(EventProviderRegistrationPath)), GetMofFormat(new ManagementObject(InstanceProviderRegistrationPath)), string.Concat(mofs), GetMofFormat(new ManagementObject(RegistrationPath)));
		}

		public void RegisterNonAssemblySpecificSchema(InstallContext installContext)
		{
			SecurityHelper.UnmanagedCode.Demand();
			WmiNetUtilsHelper.VerifyClientKey_f();
			InstallLogWrapper context = new InstallLogWrapper(installContext);
			EnsureNamespace(context, GlobalRegistrationNamespace);
			EnsureClassExists(context, GlobalInstrumentationClassPath, MakeGlobalInstrumentationClass);
			EnsureClassExists(context, GlobalRegistrationClassPath, MakeNamespaceRegistrationClass);
			EnsureClassExists(context, GlobalNamingClassPath, MakeNamingClass);
			EnsureNamespace(context, NamespaceName);
			EnsureClassExists(context, InstrumentationClassPath, MakeInstrumentationClass);
			EnsureClassExists(context, RegistrationClassPath, MakeRegistrationClass);
			try
			{
				ManagementClass managementClass = new ManagementClass(DecoupledProviderClassPath);
				if (managementClass["HostingModel"].ToString() != "Decoupled:Com")
				{
					managementClass.Delete();
				}
			}
			catch (ManagementException ex)
			{
				if (ex.ErrorCode != ManagementStatus.NotFound)
				{
					throw ex;
				}
			}
			EnsureClassExists(context, DecoupledProviderClassPath, MakeDecoupledProviderClass);
			EnsureClassExists(context, ProviderClassPath, MakeProviderClass);
			if (!DoesInstanceExist(GlobalRegistrationPath))
			{
				RegisterNamespaceAsInstrumented();
			}
		}

		public void RegisterAssemblySpecificSchema()
		{
			SecurityHelper.UnmanagedCode.Demand();
			Type[] instrumentedTypes = InstrumentedAttribute.GetInstrumentedTypes(assembly);
			StringCollection stringCollection = new StringCollection();
			StringCollection stringCollection2 = new StringCollection();
			StringCollection stringCollection3 = new StringCollection();
			string[] array = new string[instrumentedTypes.Length];
			CodeWriter codeWriter = new CodeWriter();
			ReferencesCollection referencesCollection = new ReferencesCollection();
			codeWriter.AddChild(referencesCollection.UsingCode);
			referencesCollection.Add(typeof(object));
			referencesCollection.Add(typeof(ManagementClass));
			referencesCollection.Add(typeof(Marshal));
			referencesCollection.Add(typeof(SuppressUnmanagedCodeSecurityAttribute));
			referencesCollection.Add(typeof(FieldInfo));
			referencesCollection.Add(typeof(Hashtable));
			codeWriter.Line();
			CodeWriter codeWriter2 = codeWriter.AddChild("public class WMINET_Converter");
			codeWriter2.Line("public static Hashtable mapTypeToConverter = new Hashtable();");
			CodeWriter codeWriter3 = codeWriter2.AddChild("static WMINET_Converter()");
			Hashtable hashtable = new Hashtable();
			for (int i = 0; i < instrumentedTypes.Length; i++)
			{
				hashtable[instrumentedTypes[i]] = "ConvertClass_" + i;
			}
			bool flag = IsSchemaToBeCompared();
			bool flag2 = false;
			if (!flag)
			{
				flag2 = !IsAssemblyRegistered();
			}
			for (int j = 0; j < instrumentedTypes.Length; j++)
			{
				SchemaMapping schemaMapping = new SchemaMapping(instrumentedTypes[j], this, hashtable);
				codeWriter3.Line($"mapTypeToConverter[typeof({schemaMapping.ClassType.FullName.Replace('+', '.')})] = typeof({schemaMapping.CodeClassName});");
				if (flag && !IsClassAlreadyPresentInRepository(schemaMapping.NewClass))
				{
					flag2 = true;
				}
				ReplaceClassIfNecessary(schemaMapping.ClassPath, schemaMapping.NewClass);
				array[j] = GetMofFormat(schemaMapping.NewClass);
				codeWriter.AddChild(schemaMapping.Code);
				switch (schemaMapping.InstrumentationType)
				{
				case InstrumentationType.Event:
					stringCollection.Add(schemaMapping.ClassName);
					break;
				case InstrumentationType.Instance:
					stringCollection2.Add(schemaMapping.ClassName);
					break;
				case InstrumentationType.Abstract:
					stringCollection3.Add(schemaMapping.ClassName);
					break;
				}
			}
			RegisterAssemblySpecificDecoupledProviderInstance();
			RegisterProviderAsEventProvider(stringCollection);
			RegisterProviderAsInstanceProvider();
			RegisterAssemblyAsInstrumented();
			Directory.CreateDirectory(DataDirectory);
			using (StreamWriter streamWriter = new StreamWriter(CodePath, append: false, Encoding.Unicode))
			{
				streamWriter.WriteLine(codeWriter);
				streamWriter.WriteLine("class IWOA\r\n{\r\nprotected const string DllName = \"wminet_utils.dll\";\r\nprotected const string EntryPointName = \"UFunc\";\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"GetPropertyHandle\")] public static extern int GetPropertyHandle_f27(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszPropertyName, [Out] out Int32 pType, [Out] out Int32 plHandle);\r\n//[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Byte aData);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"ReadPropertyValue\")] public static extern int ReadPropertyValue_f29(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lBufferSize, [Out] out Int32 plNumBytes, [Out] out Byte aData);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"ReadDWORD\")] public static extern int ReadDWORD_f30(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [Out] out UInt32 pdw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteDWORD\")] public static extern int WriteDWORD_f31(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] UInt32 dw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"ReadQWORD\")] public static extern int ReadQWORD_f32(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [Out] out UInt64 pqw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteQWORD\")] public static extern int WriteQWORD_f33(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] UInt64 pw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"GetPropertyInfoByHandle\")] public static extern int GetPropertyInfoByHandle_f34(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrName, [Out] out Int32 pType);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"Lock\")] public static extern int Lock_f35(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"Unlock\")] public static extern int Unlock_f36(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags);\r\n\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"Put\")] public static extern int Put_f5(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] ref object pVal, [In] Int32 Type);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In][MarshalAs(UnmanagedType.LPWStr)] string str);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Byte n);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref SByte n);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Int16 n);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\")] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref UInt16 n);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WritePropertyValue\", CharSet=CharSet.Unicode)] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Char c);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteDWORD\")] public static extern int WriteDWORD_f31(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 dw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteSingle\")] public static extern int WriteDWORD_f31(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Single dw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteQWORD\")] public static extern int WriteQWORD_f33(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int64 pw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"WriteDouble\")] public static extern int WriteQWORD_f33(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Double pw);\r\n[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=\"Clone\")] public static extern int Clone_f(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppCopy);\r\n}\r\ninterface IWmiConverter\r\n{\r\n    void ToWMI(object obj);\r\n    ManagementObject GetInstance();\r\n}\r\nclass SafeAssign\r\n{\r\n    public static UInt16 boolTrue = 0xffff;\r\n    public static UInt16 boolFalse = 0;\r\n    static Hashtable validTypes = new Hashtable();\r\n    static SafeAssign()\r\n    {\r\n        validTypes.Add(typeof(SByte), null);\r\n        validTypes.Add(typeof(Byte), null);\r\n        validTypes.Add(typeof(Int16), null);\r\n        validTypes.Add(typeof(UInt16), null);\r\n        validTypes.Add(typeof(Int32), null);\r\n        validTypes.Add(typeof(UInt32), null);\r\n        validTypes.Add(typeof(Int64), null);\r\n        validTypes.Add(typeof(UInt64), null);\r\n        validTypes.Add(typeof(Single), null);\r\n        validTypes.Add(typeof(Double), null);\r\n        validTypes.Add(typeof(Boolean), null);\r\n        validTypes.Add(typeof(String), null);\r\n        validTypes.Add(typeof(Char), null);\r\n        validTypes.Add(typeof(DateTime), null);\r\n        validTypes.Add(typeof(TimeSpan), null);\r\n        validTypes.Add(typeof(ManagementObject), null);\r\n        nullClass.SystemProperties [\"__CLASS\"].Value = \"nullInstance\";\r\n    }\r\n    public static object GetInstance(object o)\r\n    {\r\n        if(o is ManagementObject)\r\n            return o;\r\n        return null;\r\n    }\r\n    static ManagementClass nullClass = new ManagementClass(new ManagementPath(@\"" + NamespaceName + "\"));\r\n    \r\n    public static ManagementObject GetManagementObject(object o)\r\n    {\r\n        if(o != null && o is ManagementObject)\r\n            return o as ManagementObject;\r\n        // Must return empty instance\r\n        return nullClass.CreateInstance();\r\n    }\r\n    public static object GetValue(object o)\r\n    {\r\n        Type t = o.GetType();\r\n        if(t.IsArray)\r\n            t = t.GetElementType();\r\n        if(validTypes.Contains(t))\r\n            return o;\r\n        return null;\r\n    }\r\n    public static string WMITimeToString(DateTime dt)\r\n    {\r\n        TimeSpan ts = dt.Subtract(dt.ToUniversalTime());\r\n        int diffUTC = (ts.Minutes + ts.Hours * 60);\r\n        if(diffUTC >= 0)\r\n            return String.Format(\"{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}.{6:D3}000+{7:D3}\", dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond, diffUTC);\r\n        return String.Format(\"{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}.{6:D3}000-{7:D3}\", dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond, -diffUTC);\r\n    }\r\n    public static string WMITimeToString(TimeSpan ts)\r\n    {\r\n        return String.Format(\"{0:D8}{1:D2}{2:D2}{3:D2}.{4:D3}000:000\", ts.Days, ts.Hours, ts.Minutes, ts.Seconds, ts.Milliseconds);\r\n    }\r\n    public static string[] WMITimeArrayToStringArray(DateTime[] dates)\r\n    {\r\n        string[] strings = new string[dates.Length];\r\n        for(int i=0;i<dates.Length;i++)\r\n            strings[i] = WMITimeToString(dates[i]);\r\n        return strings;\r\n    }\r\n    public static string[] WMITimeArrayToStringArray(TimeSpan[] timeSpans)\r\n    {\r\n        string[] strings = new string[timeSpans.Length];\r\n        for(int i=0;i<timeSpans.Length;i++)\r\n            strings[i] = WMITimeToString(timeSpans[i]);\r\n        return strings;\r\n    }\r\n}\r\n");
			}
			using (StreamWriter streamWriter2 = new StreamWriter(MofPath, append: false, Encoding.Unicode))
			{
				streamWriter2.WriteLine(GenerateMof(array));
			}
			if (flag2)
			{
				RegisterSchemaUsingMofcomp(MofPath);
			}
		}

		private void RegisterNamespaceAsInstrumented()
		{
			ManagementClass managementClass = new ManagementClass(GlobalRegistrationClassPath);
			ManagementObject managementObject = managementClass.CreateInstance();
			managementObject["NamespaceName"] = NamespaceName;
			managementObject.Put();
		}

		private void RegisterAssemblyAsInstrumented()
		{
			ManagementClass managementClass = new ManagementClass(RegistrationClassPath);
			ManagementObject managementObject = managementClass.CreateInstance();
			managementObject["Name"] = DecoupledProviderInstanceName;
			managementObject["RegisteredBuild"] = AssemblyUniqueIdentifier;
			managementObject["FullName"] = AssemblyName;
			managementObject["PathToAssembly"] = AssemblyPath;
			managementObject["Code"] = "";
			managementObject["Mof"] = "";
			managementObject.Put();
		}

		private void RegisterAssemblySpecificDecoupledProviderInstance()
		{
			ManagementClass managementClass = new ManagementClass(ProviderClassPath);
			ManagementObject managementObject = managementClass.CreateInstance();
			managementObject["Name"] = DecoupledProviderInstanceName;
			managementObject["HostingModel"] = "Decoupled:Com";
			if (SecurityDescriptor != null)
			{
				managementObject["SecurityDescriptor"] = SecurityDescriptor;
			}
			managementObject.Put();
		}

		private string RegisterProviderAsEventProvider(StringCollection events)
		{
			ManagementClass managementClass = new ManagementClass(EventProviderRegistrationClassPath);
			ManagementObject managementObject = managementClass.CreateInstance();
			managementObject["provider"] = "\\\\.\\" + ProviderPath;
			string[] array = new string[events.Count];
			int num = 0;
			StringEnumerator enumerator = events.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					string current = enumerator.Current;
					array[num++] = "select * from " + current;
				}
			}
			finally
			{
				if (enumerator is IDisposable disposable)
				{
					disposable.Dispose();
				}
			}
			managementObject["EventQueryList"] = array;
			return managementObject.Put().Path;
		}

		private string RegisterProviderAsInstanceProvider()
		{
			ManagementClass managementClass = new ManagementClass(InstanceProviderRegistrationClassPath);
			ManagementObject managementObject = managementClass.CreateInstance();
			managementObject["provider"] = "\\\\.\\" + ProviderPath;
			managementObject["SupportsGet"] = true;
			managementObject["SupportsEnumeration"] = true;
			return managementObject.Put().Path;
		}

		private ManagementClass MakeNamingClass()
		{
			ManagementClass managementClass = new ManagementClass(GlobalInstrumentationClassPath);
			ManagementClass managementClass2 = managementClass.Derive("WMINET_Naming");
			managementClass2.Qualifiers.Add("abstract", true);
			PropertyDataCollection properties = managementClass2.Properties;
			properties.Add("InstrumentedAssembliesClassName", "WMINET_InstrumentedAssembly", CimType.String);
			return managementClass2;
		}

		private ManagementClass MakeInstrumentationClass()
		{
			ManagementClass managementClass = new ManagementClass(NamespaceName, "", null);
			managementClass.SystemProperties["__CLASS"].Value = "WMINET_Instrumentation";
			managementClass.Qualifiers.Add("abstract", true);
			return managementClass;
		}

		private ManagementClass MakeGlobalInstrumentationClass()
		{
			ManagementClass managementClass = new ManagementClass("root\\MicrosoftWmiNet", "", null);
			managementClass.SystemProperties["__CLASS"].Value = "WMINET_Instrumentation";
			managementClass.Qualifiers.Add("abstract", true);
			return managementClass;
		}

		private ManagementClass MakeRegistrationClass()
		{
			ManagementClass managementClass = new ManagementClass(InstrumentationClassPath);
			ManagementClass managementClass2 = managementClass.Derive("WMINET_InstrumentedAssembly");
			PropertyDataCollection properties = managementClass2.Properties;
			properties.Add("Name", CimType.String, isArray: false);
			PropertyData propertyData = properties["Name"];
			propertyData.Qualifiers.Add("key", true);
			properties.Add("RegisteredBuild", CimType.String, isArray: false);
			properties.Add("FullName", CimType.String, isArray: false);
			properties.Add("PathToAssembly", CimType.String, isArray: false);
			properties.Add("Code", CimType.String, isArray: false);
			properties.Add("Mof", CimType.String, isArray: false);
			return managementClass2;
		}

		private ManagementClass MakeNamespaceRegistrationClass()
		{
			ManagementClass managementClass = new ManagementClass(GlobalInstrumentationClassPath);
			ManagementClass managementClass2 = managementClass.Derive("WMINET_InstrumentedNamespaces");
			PropertyDataCollection properties = managementClass2.Properties;
			properties.Add("NamespaceName", CimType.String, isArray: false);
			PropertyData propertyData = properties["NamespaceName"];
			propertyData.Qualifiers.Add("key", true);
			return managementClass2;
		}

		private ManagementClass MakeDecoupledProviderClass()
		{
			ManagementClass managementClass = new ManagementClass(Win32ProviderClassPath);
			ManagementClass managementClass2 = managementClass.Derive("MSFT_DecoupledProvider");
			PropertyDataCollection properties = managementClass2.Properties;
			properties.Add("HostingModel", "Decoupled:Com", CimType.String);
			properties.Add("SecurityDescriptor", CimType.String, isArray: false);
			properties.Add("Version", 1, CimType.UInt32);
			properties["CLSID"].Value = "{54D8502C-527D-43f7-A506-A9DA075E229C}";
			return managementClass2;
		}

		private ManagementClass MakeProviderClass()
		{
			ManagementClass managementClass = new ManagementClass(DecoupledProviderClassPath);
			ManagementClass managementClass2 = managementClass.Derive("WMINET_ManagedAssemblyProvider");
			PropertyDataCollection properties = managementClass2.Properties;
			properties.Add("Assembly", CimType.String, isArray: false);
			return managementClass2;
		}

		private static void RegisterSchemaUsingMofcomp(string mofPath)
		{
			ProcessStartInfo processStartInfo = new ProcessStartInfo();
			processStartInfo.Arguments = mofPath;
			processStartInfo.FileName = WMICapabilities.InstallationDirectory + "\\mofcomp.exe";
			processStartInfo.UseShellExecute = false;
			processStartInfo.RedirectStandardOutput = true;
			processStartInfo.CreateNoWindow = true;
			Process process = Process.Start(processStartInfo);
			process.WaitForExit();
		}

		private static void EnsureNamespace(string baseNamespace, string childNamespaceName)
		{
			if (!DoesInstanceExist(baseNamespace + ":__NAMESPACE.Name=\"" + childNamespaceName + "\""))
			{
				ManagementClass managementClass = new ManagementClass(baseNamespace + ":__NAMESPACE");
				ManagementObject managementObject = managementClass.CreateInstance();
				managementObject["Name"] = childNamespaceName;
				managementObject.Put();
			}
		}

		private static void EnsureNamespace(InstallLogWrapper context, string namespaceName)
		{
			context.LogMessage(RC.GetString("NAMESPACE_ENSURE") + " " + namespaceName);
			string text = null;
			string[] array = namespaceName.Split('\\');
			foreach (string text2 in array)
			{
				if (text == null)
				{
					text = text2;
					continue;
				}
				EnsureNamespace(text, text2);
				text = text + "\\" + text2;
			}
		}

		private static void EnsureClassExists(InstallLogWrapper context, string classPath, ClassMaker classMakerFunction)
		{
			try
			{
				context.LogMessage(RC.GetString("CLASS_ENSURE") + " " + classPath);
				ManagementClass managementClass = new ManagementClass(classPath);
				managementClass.Get();
			}
			catch (ManagementException ex)
			{
				if (ex.ErrorCode == ManagementStatus.NotFound)
				{
					context.LogMessage(RC.GetString("CLASS_ENSURECREATE") + " " + classPath);
					ManagementClass managementClass2 = classMakerFunction();
					managementClass2.Put();
					return;
				}
				throw ex;
			}
		}

		private static bool DoesInstanceExist(string objectPath)
		{
			bool result = false;
			try
			{
				ManagementObject managementObject = new ManagementObject(objectPath);
				managementObject.Get();
				result = true;
				return result;
			}
			catch (ManagementException ex)
			{
				if (ManagementStatus.InvalidNamespace != ex.ErrorCode)
				{
					if (ManagementStatus.InvalidClass != ex.ErrorCode)
					{
						if (ManagementStatus.NotFound != ex.ErrorCode)
						{
							throw ex;
						}
						return result;
					}
					return result;
				}
				return result;
			}
		}

		private static bool DoesClassExist(string objectPath)
		{
			bool result = false;
			try
			{
				ManagementObject managementObject = new ManagementClass(objectPath);
				managementObject.Get();
				result = true;
				return result;
			}
			catch (ManagementException ex)
			{
				if (ManagementStatus.InvalidNamespace != ex.ErrorCode)
				{
					if (ManagementStatus.InvalidClass != ex.ErrorCode)
					{
						if (ManagementStatus.NotFound != ex.ErrorCode)
						{
							throw ex;
						}
						return result;
					}
					return result;
				}
				return result;
			}
		}

		private static ManagementClass SafeGetClass(string classPath)
		{
			ManagementClass result = null;
			try
			{
				ManagementClass managementClass = new ManagementClass(classPath);
				managementClass.Get();
				result = managementClass;
				return result;
			}
			catch (ManagementException ex)
			{
				if (ex.ErrorCode != ManagementStatus.NotFound)
				{
					throw ex;
				}
				return result;
			}
		}

		private static void ReplaceClassIfNecessary(string classPath, ManagementClass newClass)
		{
			try
			{
				ManagementClass managementClass = SafeGetClass(classPath);
				if (managementClass == null)
				{
					newClass.Put();
				}
				else if (newClass.GetText(TextFormat.Mof) != managementClass.GetText(TextFormat.Mof))
				{
					managementClass.Delete();
					newClass.Put();
				}
			}
			catch (ManagementException innerException)
			{
				string format = RC.GetString("CLASS_NOTREPLACED_EXCEPT") + "\r\n{0}\r\n{1}";
				throw new ArgumentException(string.Format(format, classPath, newClass.GetText(TextFormat.Mof)), innerException);
			}
		}

		private static string GetMofFormat(ManagementObject obj)
		{
			return obj.GetText(TextFormat.Mof).Replace("\n", "\r\n") + "\r\n";
		}

		private static string PragmaNamespace(string namespaceName)
		{
			return string.Format("#pragma namespace(\"\\\\\\\\.\\\\{0}\")\r\n\r\n", namespaceName.Replace("\\", "\\\\"));
		}

		private static string EnsureNamespaceInMof(string baseNamespace, string childNamespaceName)
		{
			return $"{PragmaNamespace(baseNamespace)}instance of __Namespace\r\n{{\r\n  Name = \"{childNamespaceName}\";\r\n}};\r\n\r\n";
		}

		private static string EnsureNamespaceInMof(string namespaceName)
		{
			string text = "";
			string text2 = null;
			string[] array = namespaceName.Split('\\');
			foreach (string text3 in array)
			{
				if (text2 == null)
				{
					text2 = text3;
					continue;
				}
				text += EnsureNamespaceInMof(text2, text3);
				text2 = text2 + "\\" + text3;
			}
			return text;
		}
	}
	internal sealed class WMICapabilities
	{
		private const string WMIKeyPath = "Software\\Microsoft\\WBEM";

		private const string WMINetKeyPath = "Software\\Microsoft\\WBEM\\.NET";

		private const string WMICIMOMKeyPath = "Software\\Microsoft\\WBEM\\CIMOM";

		private const string MultiIndicateSupportedValueNameVal = "MultiIndicateSupported";

		private const string AutoRecoverMofsVal = "Autorecover MOFs";

		private const string AutoRecoverMofsTimestampVal = "Autorecover MOFs timestamp";

		private const string InstallationDirectoryVal = "Installation Directory";

		private const string FrameworkSubDirectory = "Framework";

		private static RegistryKey wmiNetKey;

		private static RegistryKey wmiKey;

		private static int multiIndicateSupported;

		private static string installationDirectory;

		public static bool MultiIndicateSupported
		{
			get
			{
				if (-1 == multiIndicateSupported)
				{
					multiIndicateSupported = (MultiIndicatePossible() ? 1 : 0);
					if (wmiNetKey != null)
					{
						object value = wmiNetKey.GetValue("MultiIndicateSupported", multiIndicateSupported);
						if (value.GetType() == typeof(int) && (int)value == 1)
						{
							multiIndicateSupported = 1;
						}
					}
				}
				return multiIndicateSupported == 1;
			}
		}

		public static string InstallationDirectory
		{
			get
			{
				if (installationDirectory == null && wmiKey != null)
				{
					installationDirectory = wmiKey.GetValue("Installation Directory").ToString();
				}
				return installationDirectory;
			}
		}

		public static string FrameworkDirectory => Path.Combine(InstallationDirectory, "Framework");

		static WMICapabilities()
		{
			multiIndicateSupported = -1;
			installationDirectory = null;
			wmiNetKey = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\WBEM\\.NET", writable: false);
			wmiKey = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\WBEM", writable: false);
		}

		public static void AddAutorecoverMof(string path)
		{
			RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\WBEM\\CIMOM", writable: true);
			if (registryKey == null)
			{
				return;
			}
			object value = registryKey.GetValue("Autorecover MOFs");
			string[] array = value as string[];
			if (array == null)
			{
				if (value != null)
				{
					return;
				}
				array = new string[0];
			}
			registryKey.SetValue("Autorecover MOFs timestamp", DateTime.Now.ToFileTime().ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(long))));
			string[] array2 = array;
			foreach (string strA in array2)
			{
				if (string.Compare(strA, path, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return;
				}
			}
			string[] array3 = new string[array.Length + 1];
			array.CopyTo(array3, 0);
			array3[array3.Length - 1] = path;
			registryKey.SetValue("Autorecover MOFs", array3);
			registryKey.SetValue("Autorecover MOFs timestamp", DateTime.Now.ToFileTime().ToString((IFormatProvider)CultureInfo.InvariantCulture.GetFormat(typeof(long))));
		}

		public static bool IsUserAdmin()
		{
			if (Environment.OSVersion.Platform == PlatformID.Win32Windows)
			{
				return true;
			}
			WindowsPrincipal windowsPrincipal = new WindowsPrincipal(WindowsIdentity.GetCurrent());
			if (windowsPrincipal.Identity.IsAuthenticated)
			{
				return windowsPrincipal.IsInRole(WindowsBuiltInRole.Administrator);
			}
			return false;
		}

		private static bool IsNovaFile(FileVersionInfo info)
		{
			if (info.FileMajorPart == 1 && info.FileMinorPart == 50)
			{
				return info.FileBuildPart == 1085;
			}
			return false;
		}

		private static bool MultiIndicatePossible()
		{
			OperatingSystem oSVersion = Environment.OSVersion;
			if (oSVersion.Platform == PlatformID.Win32NT && oSVersion.Version >= new Version(5, 1))
			{
				return true;
			}
			string fileName = Path.Combine(Environment.SystemDirectory, "wbem\\fastprox.dll");
			FileVersionInfo versionInfo = FileVersionInfo.GetVersionInfo(fileName);
			if (IsNovaFile(versionInfo) && versionInfo.FilePrivatePart >= 56)
			{
				return true;
			}
			return false;
		}

		public static bool IsWindowsXPOrHigher()
		{
			OperatingSystem oSVersion = Environment.OSVersion;
			if (oSVersion.Platform == PlatformID.Win32NT && oSVersion.Version >= new Version(5, 1))
			{
				return true;
			}
			return false;
		}
	}
	[ComImport]
	[Guid("E5CB7A31-7512-11d2-89CE-0080C792E5D8")]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[ClassInterface(ClassInterfaceType.None)]
	internal class CorMetaDataDispenser
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern CorMetaDataDispenser();
	}
	[ComImport]
	[Guid("809c652e-7396-11d2-9771-00a0c9b4d50c")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[TypeLibType(TypeLibTypeFlags.FRestricted)]
	internal interface IMetaDataDispenser
	{
		[return: MarshalAs(UnmanagedType.Interface)]
		object DefineScope([In] ref Guid rclsid, [In] uint dwCreateFlags, [In] ref Guid riid);

		[return: MarshalAs(UnmanagedType.Interface)]
		object OpenScope([In][MarshalAs(UnmanagedType.LPWStr)] string szScope, [In] uint dwOpenFlags, [In] ref Guid riid);

		[return: MarshalAs(UnmanagedType.Interface)]
		object OpenScopeOnMemory([In] IntPtr pData, [In] uint cbData, [In] uint dwOpenFlags, [In] ref Guid riid);
	}
	[ComImport]
	[Guid("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[TypeLibType(TypeLibTypeFlags.FRestricted)]
	internal interface IMetaDataImportInternalOnly
	{
		void f1();

		void f2();

		void f3();

		void f4();

		void f5();

		void f6();

		void f7();

		void GetScopeProps([Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder szName, [In] uint cchName, out uint pchName, out Guid pmvid);
	}
	internal class MetaDataInfo : IDisposable
	{
		private IMetaDataImportInternalOnly importInterface;

		private string name;

		private Guid mvid;

		public string Name
		{
			get
			{
				InitNameAndMvid();
				return name;
			}
		}

		public Guid Mvid
		{
			get
			{
				InitNameAndMvid();
				return mvid;
			}
		}

		public MetaDataInfo(Assembly assembly)
			: this(assembly.Location)
		{
		}

		public MetaDataInfo(string assemblyName)
		{
			Guid riid = new Guid(((GuidAttribute)Attribute.GetCustomAttribute(typeof(IMetaDataImportInternalOnly), typeof(GuidAttribute), inherit: false)).Value);
			IMetaDataDispenser metaDataDispenser = (IMetaDataDispenser)new CorMetaDataDispenser();
			importInterface = (IMetaDataImportInternalOnly)metaDataDispenser.OpenScope(assemblyName, 0u, ref riid);
			Marshal.ReleaseComObject(metaDataDispenser);
		}

		private void InitNameAndMvid()
		{
			if (name == null)
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Capacity = 0;
				importInterface.GetScopeProps(stringBuilder, (uint)stringBuilder.Capacity, out var pchName, out mvid);
				stringBuilder.Capacity = (int)pchName;
				importInterface.GetScopeProps(stringBuilder, (uint)stringBuilder.Capacity, out pchName, out mvid);
				name = stringBuilder.ToString();
			}
		}

		public void Dispose()
		{
			if (importInterface == null)
			{
				Marshal.ReleaseComObject(importInterface);
			}
			importInterface = null;
			GC.SuppressFinalize(this);
		}

		~MetaDataInfo()
		{
			Dispose();
		}

		public static Guid GetMvid(Assembly assembly)
		{
			using MetaDataInfo metaDataInfo = new MetaDataInfo(assembly);
			return metaDataInfo.Mvid;
		}
	}
}
