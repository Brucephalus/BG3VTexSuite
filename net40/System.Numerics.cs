
// C:\WINDOWS\Microsoft.NET\assembly\GAC_MSIL\System.Numerics\v4.0_4.0.0.0__b77a5c561934e089\System.Numerics.dll
// System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v4.0.30319
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 00000000000000000400000000000000

using System;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Threading;

[assembly: CompilationRelaxations(8)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: ComVisible(false)]
[assembly: CLSCompliant(true)]
[assembly: AllowPartiallyTrustedCallers]
[assembly: SecurityRules(SecurityRuleSet.Level2, SkipVerificationInFullTrust = true)]
[assembly: AssemblyTitle("System.Numerics.dll")]
[assembly: AssemblyDescription("System.Numerics.dll")]
[assembly: AssemblyDefaultAlias("System.Numerics.dll")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyFileVersion("4.8.9037.0")]
[assembly: AssemblyInformationalVersion("4.8.9037.0")]
[assembly: SatelliteContractVersion("4.0.0.0")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: AssemblyDelaySign(true)]
[assembly: AssemblyKeyFile("f:\\dd\\tools\\devdiv\\EcmaPublicKey.snk")]
[assembly: AssemblySignatureKey("002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3", "a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d")]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: DefaultDllImportSearchPaths(DllImportSearchPath.System32 | DllImportSearchPath.AssemblyDirectory)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("4.0.0.0")]
[module: UnverifiableCode]
internal static class FXAssembly
{
	internal const string Version = "4.0.0.0";
}
internal static class ThisAssembly
{
	internal const string Title = "System.Numerics.dll";

	internal const string Description = "System.Numerics.dll";

	internal const string DefaultAlias = "System.Numerics.dll";

	internal const string Copyright = "© Microsoft Corporation.  All rights reserved.";

	internal const string Version = "4.0.0.0";

	internal const string InformationalVersion = "4.8.9037.0";

	internal const string DailyBuildNumberStr = "30319";

	internal const string BuildRevisionStr = "0";

	internal const int DailyBuildNumber = 30319;
}
internal static class AssemblyRef
{
	internal const string EcmaPublicKey = "b77a5c561934e089";

	internal const string EcmaPublicKeyToken = "b77a5c561934e089";

	internal const string EcmaPublicKeyFull = "00000000000000000400000000000000";

	internal const string SilverlightPublicKey = "31bf3856ad364e35";

	internal const string SilverlightPublicKeyToken = "31bf3856ad364e35";

	internal const string SilverlightPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9";

	internal const string SilverlightPlatformPublicKey = "7cec85d7bea7798e";

	internal const string SilverlightPlatformPublicKeyToken = "7cec85d7bea7798e";

	internal const string SilverlightPlatformPublicKeyFull = "00240000048000009400000006020000002400005253413100040000010001008D56C76F9E8649383049F383C44BE0EC204181822A6C31CF5EB7EF486944D032188EA1D3920763712CCB12D75FB77E9811149E6148E5D32FBAAB37611C1878DDC19E20EF135D0CB2CFF2BFEC3D115810C3D9069638FE4BE215DBF795861920E5AB6F7DB2E2CEEF136AC23D5DD2BF031700AEC232F6C6B1C785B4305C123B37AB";

	internal const string PlatformPublicKey = "b77a5c561934e089";

	internal const string PlatformPublicKeyToken = "b77a5c561934e089";

	internal const string PlatformPublicKeyFull = "00000000000000000400000000000000";

	internal const string Mscorlib = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemData = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemDataOracleClient = "System.Data.OracleClient, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string System = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemCore = "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemNumerics = "System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemRuntimeRemoting = "System.Runtime.Remoting, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemThreadingTasksDataflow = "System.Threading.Tasks.Dataflow, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWindowsForms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemXml = "System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string MicrosoftPublicKey = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyToken = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyFull = "002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293";

	internal const string SharedLibPublicKey = "31bf3856ad364e35";

	internal const string SharedLibPublicKeyToken = "31bf3856ad364e35";

	internal const string SharedLibPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9";

	internal const string SystemComponentModelDataAnnotations = "System.ComponentModel.DataAnnotations, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemConfiguration = "System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemConfigurationInstall = "System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDeployment = "System.Deployment, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDesign = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDirectoryServices = "System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawingDesign = "System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemEnterpriseServices = "System.EnterpriseServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemManagement = "System.Management, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemMessaging = "System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemNetHttp = "System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemNetHttpWebRequest = "System.Net.Http.WebRequest, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemRuntimeSerializationFormattersSoap = "System.Runtime.Serialization.Formatters.Soap, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemRuntimeWindowsRuntime = "System.Runtime.WindowsRuntime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemRuntimeWindowsRuntimeUIXaml = "System.Runtime.WindowsRuntimeUIXaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemSecurity = "System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemServiceModelWeb = "System.ServiceModel.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemServiceProcess = "System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWeb = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebAbstractions = "System.Web.Abstractions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebDynamicData = "System.Web.DynamicData, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebDynamicDataDesign = "System.Web.DynamicData.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebEntityDesign = "System.Web.Entity.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWebExtensions = "System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebExtensionsDesign = "System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebMobile = "System.Web.Mobile, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRegularExpressions = "System.Web.RegularExpressions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRouting = "System.Web.Routing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebServices = "System.Web.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string WindowsBase = "WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string MicrosoftVisualStudio = "Microsoft.VisualStudio, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWindowsForms = "Microsoft.VisualStudio.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string VJSharpCodeProvider = "VJSharpCodeProvider, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string ASPBrowserCapsPublicKey = "b7bd7678b977bd8f";

	internal const string ASPBrowserCapsFactory = "ASP.BrowserCapsFactory, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b7bd7678b977bd8f";

	internal const string MicrosoftVSDesigner = "Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWeb = "Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftWebDesign = "Microsoft.Web.Design.Client, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVSDesignerMobile = "Microsoft.VSDesigner.Mobile, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftJScript = "Microsoft.JScript, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
}
namespace System
{
	internal sealed class SR
	{
		internal const string Argument_InvalidNumberStyles = "Argument_InvalidNumberStyles";

		internal const string Argument_InvalidHexStyle = "Argument_InvalidHexStyle";

		internal const string Argument_MustBeBigInt = "Argument_MustBeBigInt";

		internal const string Format_InvalidFormatSpecifier = "Format_InvalidFormatSpecifier";

		internal const string Format_TooLarge = "Format_TooLarge";

		internal const string ArgumentOutOfRange_MustBeNonNeg = "ArgumentOutOfRange_MustBeNonNeg";

		internal const string Overflow_BigIntInfinity = "Overflow_BigIntInfinity";

		internal const string Overflow_NotANumber = "Overflow_NotANumber";

		internal const string Overflow_ParseBigInteger = "Overflow_ParseBigInteger";

		internal const string Overflow_Int32 = "Overflow_Int32";

		internal const string Overflow_Int64 = "Overflow_Int64";

		internal const string Overflow_UInt32 = "Overflow_UInt32";

		internal const string Overflow_UInt64 = "Overflow_UInt64";

		internal const string Overflow_Decimal = "Overflow_Decimal";

		internal const string Arg_ArgumentOutOfRangeException = "Arg_ArgumentOutOfRangeException";

		internal const string Arg_ElementsInSourceIsGreaterThanDestination = "Arg_ElementsInSourceIsGreaterThanDestination";

		internal const string Arg_MultiDimArrayNotSupported = "Arg_MultiDimArrayNotSupported";

		internal const string Arg_RegisterLengthOfRangeException = "Arg_RegisterLengthOfRangeException";

		internal const string Arg_NullArgumentNullRef = "Arg_NullArgumentNullRef";

		private static SR loader;

		private ResourceManager resources;

		private static CultureInfo Culture => null;

		public static ResourceManager Resources => GetLoader().resources;

		internal SR()
		{
			resources = new ResourceManager("System.Numerics", GetType().Assembly);
		}

		private static SR GetLoader()
		{
			if (loader == null)
			{
				SR value = new SR();
				Interlocked.CompareExchange(ref loader, value, null);
			}
			return loader;
		}

		public static string GetString(string name, params object[] args)
		{
			SR sR = GetLoader();
			if (sR == null)
			{
				return null;
			}
			string @string = sR.resources.GetString(name, Culture);
			if (args != null && args.Length != 0)
			{
				for (int i = 0; i < args.Length; i++)
				{
					if (args[i] is string text && text.Length > 1024)
					{
						args[i] = text.Substring(0, 1021) + "...";
					}
				}
				return string.Format(CultureInfo.CurrentCulture, @string, args);
			}
			return @string;
		}

		public static string GetString(string name)
		{
			return GetLoader()?.resources.GetString(name, Culture);
		}

		public static string GetString(string name, out bool usedFallback)
		{
			usedFallback = false;
			return GetString(name);
		}

		public static object GetObject(string name)
		{
			return GetLoader()?.resources.GetObject(name, Culture);
		}
	}
}
namespace System.Numerics
{
	/// <summary>Represents an arbitrarily large signed integer.</summary>
	[Serializable]
	[__DynamicallyInvokable]
	public struct BigInteger : IFormattable, IComparable, IComparable<BigInteger>, IEquatable<BigInteger>
	{
		private const int knMaskHighBit = int.MinValue;

		private const uint kuMaskHighBit = 2147483648u;

		private const int kcbitUint = 32;

		private const int kcbitUlong = 64;

		private const int DecimalScaleFactorMask = 16711680;

		private const int DecimalSignMask = int.MinValue;

		internal int _sign;

		internal uint[] _bits;

		private static readonly BigInteger s_bnMinInt = new BigInteger(-1, new uint[1] { 2147483648u });

		private static readonly BigInteger s_bnOneInt = new BigInteger(1);

		private static readonly BigInteger s_bnZeroInt = new BigInteger(0);

		private static readonly BigInteger s_bnMinusOneInt = new BigInteger(-1);

		/// <summary>Gets a value that represents the number 0 (zero).</summary>
		/// <returns>An integer whose value is 0 (zero).</returns>
		[__DynamicallyInvokable]
		public static BigInteger Zero
		{
			[__DynamicallyInvokable]
			get
			{
				return s_bnZeroInt;
			}
		}

		/// <summary>Gets a value that represents the number one (1).</summary>
		/// <returns>An object whose value is one (1).</returns>
		[__DynamicallyInvokable]
		public static BigInteger One
		{
			[__DynamicallyInvokable]
			get
			{
				return s_bnOneInt;
			}
		}

		/// <summary>Gets a value that represents the number negative one (-1).</summary>
		/// <returns>An integer whose value is negative one (-1).</returns>
		[__DynamicallyInvokable]
		public static BigInteger MinusOne
		{
			[__DynamicallyInvokable]
			get
			{
				return s_bnMinusOneInt;
			}
		}

		/// <summary>Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is a power of two.</summary>
		/// <returns>
		///   <see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is a power of two; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool IsPowerOfTwo
		{
			[__DynamicallyInvokable]
			get
			{
				if (_bits == null)
				{
					if ((_sign & (_sign - 1)) == 0)
					{
						return _sign != 0;
					}
					return false;
				}
				if (_sign != 1)
				{
					return false;
				}
				int num = Length(_bits) - 1;
				if ((_bits[num] & (_bits[num] - 1)) != 0)
				{
					return false;
				}
				while (--num >= 0)
				{
					if (_bits[num] != 0)
					{
						return false;
					}
				}
				return true;
			}
		}

		/// <summary>Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.Zero" />.</summary>
		/// <returns>
		///   <see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.Zero" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool IsZero
		{
			[__DynamicallyInvokable]
			get
			{
				return _sign == 0;
			}
		}

		/// <summary>Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.One" />.</summary>
		/// <returns>
		///   <see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.One" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool IsOne
		{
			[__DynamicallyInvokable]
			get
			{
				if (_sign == 1)
				{
					return _bits == null;
				}
				return false;
			}
		}

		/// <summary>Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is an even number.</summary>
		/// <returns>
		///   <see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is an even number; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool IsEven
		{
			[__DynamicallyInvokable]
			get
			{
				if (_bits != null)
				{
					return (_bits[0] & 1) == 0;
				}
				return (_sign & 1) == 0;
			}
		}

		/// <summary>Gets a number that indicates the sign (negative, positive, or zero) of the current <see cref="T:System.Numerics.BigInteger" /> object.</summary>
		/// <returns>A number that indicates the sign of the <see cref="T:System.Numerics.BigInteger" /> object, as shown in the following table.  
		///   Number  
		///
		///   Description  
		///
		///   -1  
		///
		///   The value of this object is negative.  
		///
		///   0  
		///
		///   The value of this object is 0 (zero).  
		///
		///   1  
		///
		///   The value of this object is positive.</returns>
		[__DynamicallyInvokable]
		public int Sign
		{
			[__DynamicallyInvokable]
			get
			{
				return (_sign >> 31) - (-_sign >> 31);
			}
		}

		internal int _Sign => _sign;

		internal uint[] _Bits => _bits;

		[Conditional("DEBUG")]
		private void AssertValid()
		{
			if (_bits != null)
			{
				Length(_bits);
				_ = 1;
			}
		}

		/// <summary>Returns a value that indicates whether the current instance and a specified object have the same value.</summary>
		/// <param name="obj">The object to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="obj" /> argument is a <see cref="T:System.Numerics.BigInteger" /> object, and its value is equal to the value of the current <see cref="T:System.Numerics.BigInteger" /> instance; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public override bool Equals(object obj)
		{
			if (!(obj is BigInteger))
			{
				return false;
			}
			return Equals((BigInteger)obj);
		}

		/// <summary>Returns the hash code for the current <see cref="T:System.Numerics.BigInteger" /> object.</summary>
		/// <returns>A 32-bit signed integer hash code.</returns>
		[__DynamicallyInvokable]
		public override int GetHashCode()
		{
			if (_bits == null)
			{
				return _sign;
			}
			int num = _sign;
			int num2 = Length(_bits);
			while (--num2 >= 0)
			{
				num = NumericsHelpers.CombineHash(num, (int)_bits[num2]);
			}
			return num;
		}

		/// <summary>Returns a value that indicates whether the current instance and a signed 64-bit integer have the same value.</summary>
		/// <param name="other">The signed 64-bit integer value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the signed 64-bit integer and the current instance have the same value; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool Equals(long other)
		{
			if (_bits == null)
			{
				return _sign == other;
			}
			int num;
			if ((_sign ^ other) < 0 || (num = Length(_bits)) > 2)
			{
				return false;
			}
			ulong num2 = (ulong)((other < 0) ? (-other) : other);
			if (num == 1)
			{
				return _bits[0] == num2;
			}
			return NumericsHelpers.MakeUlong(_bits[1], _bits[0]) == num2;
		}

		/// <summary>Returns a value that indicates whether the current instance and an unsigned 64-bit integer have the same value.</summary>
		/// <param name="other">The unsigned 64-bit integer to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the current instance and the unsigned 64-bit integer have the same value; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public bool Equals(ulong other)
		{
			if (_sign < 0)
			{
				return false;
			}
			if (_bits == null)
			{
				return (ulong)_sign == other;
			}
			int num = Length(_bits);
			if (num > 2)
			{
				return false;
			}
			if (num == 1)
			{
				return _bits[0] == other;
			}
			return NumericsHelpers.MakeUlong(_bits[1], _bits[0]) == other;
		}

		/// <summary>Returns a value that indicates whether the current instance and a specified <see cref="T:System.Numerics.BigInteger" /> object have the same value.</summary>
		/// <param name="other">The object to compare.</param>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Numerics.BigInteger" /> object and <paramref name="other" /> have the same value; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool Equals(BigInteger other)
		{
			if (_sign != other._sign)
			{
				return false;
			}
			if (_bits == other._bits)
			{
				return true;
			}
			if (_bits == null || other._bits == null)
			{
				return false;
			}
			int num = Length(_bits);
			if (num != Length(other._bits))
			{
				return false;
			}
			int diffLength = GetDiffLength(_bits, other._bits, num);
			return diffLength == 0;
		}

		/// <summary>Compares this instance to a signed 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the signed 64-bit integer.</summary>
		/// <param name="other">The signed 64-bit integer to compare.</param>
		/// <returns>A signed integer value that indicates the relationship of this instance to <paramref name="other" />, as shown in the following table.  
		///   Return value  
		///
		///   Description  
		///
		///   Less than zero  
		///
		///   The current instance is less than <paramref name="other" />.  
		///
		///   Zero  
		///
		///   The current instance equals <paramref name="other" />.  
		///
		///   Greater than zero  
		///
		///   The current instance is greater than <paramref name="other" />.</returns>
		[__DynamicallyInvokable]
		public int CompareTo(long other)
		{
			if (_bits == null)
			{
				return ((long)_sign).CompareTo(other);
			}
			int num;
			if ((_sign ^ other) < 0 || (num = Length(_bits)) > 2)
			{
				return _sign;
			}
			ulong value = (ulong)((other < 0) ? (-other) : other);
			ulong num2 = ((num == 2) ? NumericsHelpers.MakeUlong(_bits[1], _bits[0]) : _bits[0]);
			return _sign * num2.CompareTo(value);
		}

		/// <summary>Compares this instance to an unsigned 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the unsigned 64-bit integer.</summary>
		/// <param name="other">The unsigned 64-bit integer to compare.</param>
		/// <returns>A signed integer that indicates the relative value of this instance and <paramref name="other" />, as shown in the following table.  
		///   Return value  
		///
		///   Description  
		///
		///   Less than zero  
		///
		///   The current instance is less than <paramref name="other" />.  
		///
		///   Zero  
		///
		///   The current instance equals <paramref name="other" />.  
		///
		///   Greater than zero  
		///
		///   The current instance is greater than <paramref name="other" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public int CompareTo(ulong other)
		{
			if (_sign < 0)
			{
				return -1;
			}
			if (_bits == null)
			{
				return ((ulong)_sign).CompareTo(other);
			}
			int num = Length(_bits);
			if (num > 2)
			{
				return 1;
			}
			return ((num == 2) ? NumericsHelpers.MakeUlong(_bits[1], _bits[0]) : _bits[0]).CompareTo(other);
		}

		/// <summary>Compares this instance to a second <see cref="T:System.Numerics.BigInteger" /> and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</summary>
		/// <param name="other">The object to compare.</param>
		/// <returns>A signed integer value that indicates the relationship of this instance to <paramref name="other" />, as shown in the following table.  
		///   Return value  
		///
		///   Description  
		///
		///   Less than zero  
		///
		///   The current instance is less than <paramref name="other" />.  
		///
		///   Zero  
		///
		///   The current instance equals <paramref name="other" />.  
		///
		///   Greater than zero  
		///
		///   The current instance is greater than <paramref name="other" />.</returns>
		[__DynamicallyInvokable]
		public int CompareTo(BigInteger other)
		{
			if ((_sign ^ other._sign) < 0)
			{
				if (_sign >= 0)
				{
					return 1;
				}
				return -1;
			}
			if (_bits == null)
			{
				if (other._bits == null)
				{
					if (_sign >= other._sign)
					{
						if (_sign <= other._sign)
						{
							return 0;
						}
						return 1;
					}
					return -1;
				}
				return -other._sign;
			}
			int num;
			int num2;
			if (other._bits == null || (num = Length(_bits)) > (num2 = Length(other._bits)))
			{
				return _sign;
			}
			if (num < num2)
			{
				return -_sign;
			}
			int diffLength = GetDiffLength(_bits, other._bits, num);
			if (diffLength == 0)
			{
				return 0;
			}
			if (_bits[diffLength - 1] >= other._bits[diffLength - 1])
			{
				return _sign;
			}
			return -_sign;
		}

		/// <summary>Compares this instance to a specified object and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</summary>
		/// <param name="obj">The object to compare.</param>
		/// <returns>A signed integer that indicates the relationship of the current instance to the <paramref name="obj" /> parameter, as shown in the following table.  
		///   Return value  
		///
		///   Description  
		///
		///   Less than zero  
		///
		///   The current instance is less than <paramref name="obj" />.  
		///
		///   Zero  
		///
		///   The current instance equals <paramref name="obj" />.  
		///
		///   Greater than zero  
		///
		///   The current instance is greater than <paramref name="obj" />, or the <paramref name="obj" /> parameter is <see langword="null" />.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="obj" /> is not a <see cref="T:System.Numerics.BigInteger" />.</exception>
		public int CompareTo(object obj)
		{
			if (obj == null)
			{
				return 1;
			}
			if (!(obj is BigInteger))
			{
				throw new ArgumentException(SR.GetString("Argument_MustBeBigInt"));
			}
			return CompareTo((BigInteger)obj);
		}

		/// <summary>Converts a <see cref="T:System.Numerics.BigInteger" /> value to a byte array.</summary>
		/// <returns>The value of the current <see cref="T:System.Numerics.BigInteger" /> object converted to an array of bytes.</returns>
		[__DynamicallyInvokable]
		public byte[] ToByteArray()
		{
			if (_bits == null && _sign == 0)
			{
				return new byte[1];
			}
			uint[] array;
			byte b;
			if (_bits == null)
			{
				array = new uint[1] { (uint)_sign };
				b = (byte)((_sign < 0) ? 255u : 0u);
			}
			else if (_sign == -1)
			{
				array = (uint[])_bits.Clone();
				NumericsHelpers.DangerousMakeTwosComplement(array);
				b = byte.MaxValue;
			}
			else
			{
				array = _bits;
				b = 0;
			}
			byte[] array2 = new byte[checked(4 * array.Length)];
			int num = 0;
			for (int i = 0; i < array.Length; i++)
			{
				uint num2 = array[i];
				for (int j = 0; j < 4; j++)
				{
					array2[num++] = (byte)(num2 & 0xFFu);
					num2 >>= 8;
				}
			}
			int num3 = array2.Length - 1;
			while (num3 > 0 && array2[num3] == b)
			{
				num3--;
			}
			bool flag = (array2[num3] & 0x80) != (b & 0x80);
			byte[] array3 = new byte[num3 + 1 + (flag ? 1 : 0)];
			Array.Copy(array2, array3, num3 + 1);
			if (flag)
			{
				array3[array3.Length - 1] = b;
			}
			return array3;
		}

		private uint[] ToUInt32Array()
		{
			if (_bits == null && _sign == 0)
			{
				return new uint[1];
			}
			uint[] array;
			uint num;
			if (_bits == null)
			{
				array = new uint[1] { (uint)_sign };
				num = ((_sign < 0) ? uint.MaxValue : 0u);
			}
			else if (_sign == -1)
			{
				array = (uint[])_bits.Clone();
				NumericsHelpers.DangerousMakeTwosComplement(array);
				num = uint.MaxValue;
			}
			else
			{
				array = _bits;
				num = 0u;
			}
			int num2 = array.Length - 1;
			while (num2 > 0 && array[num2] == num)
			{
				num2--;
			}
			bool flag = (array[num2] & 0x80000000u) != (num & 0x80000000u);
			uint[] array2 = new uint[num2 + 1 + (flag ? 1 : 0)];
			Array.Copy(array, array2, num2 + 1);
			if (flag)
			{
				array2[array2.Length - 1] = num;
			}
			return array2;
		}

		/// <summary>Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation.</summary>
		/// <returns>The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value.</returns>
		[__DynamicallyInvokable]
		public override string ToString()
		{
			return BigNumber.FormatBigInteger(this, null, NumberFormatInfo.CurrentInfo);
		}

		/// <summary>Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified culture-specific formatting information.</summary>
		/// <param name="provider">An object that supplies culture-specific formatting information.</param>
		/// <returns>The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value in the format specified by the <paramref name="provider" /> parameter.</returns>
		[__DynamicallyInvokable]
		public string ToString(IFormatProvider provider)
		{
			return BigNumber.FormatBigInteger(this, null, NumberFormatInfo.GetInstance(provider));
		}

		/// <summary>Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified format.</summary>
		/// <param name="format">A standard or custom numeric format string.</param>
		/// <returns>The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value in the format specified by the <paramref name="format" /> parameter.</returns>
		/// <exception cref="T:System.FormatException">
		///   <paramref name="format" /> is not a valid format string.</exception>
		[__DynamicallyInvokable]
		public string ToString(string format)
		{
			return BigNumber.FormatBigInteger(this, format, NumberFormatInfo.CurrentInfo);
		}

		/// <summary>Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified format and culture-specific format information.</summary>
		/// <param name="format">A standard or custom numeric format string.</param>
		/// <param name="provider">An object that supplies culture-specific formatting information.</param>
		/// <returns>The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value as specified by the <paramref name="format" /> and <paramref name="provider" /> parameters.</returns>
		/// <exception cref="T:System.FormatException">
		///   <paramref name="format" /> is not a valid format string.</exception>
		[__DynamicallyInvokable]
		public string ToString(string format, IFormatProvider provider)
		{
			return BigNumber.FormatBigInteger(this, format, NumberFormatInfo.GetInstance(provider));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a 32-bit signed integer value.</summary>
		/// <param name="value">A 32-bit signed integer.</param>
		[__DynamicallyInvokable]
		public BigInteger(int value)
		{
			if (value == int.MinValue)
			{
				this = s_bnMinInt;
				return;
			}
			_sign = value;
			_bits = null;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using an unsigned 32-bit integer value.</summary>
		/// <param name="value">An unsigned 32-bit integer value.</param>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public BigInteger(uint value)
		{
			if (value <= int.MaxValue)
			{
				_sign = (int)value;
				_bits = null;
			}
			else
			{
				_sign = 1;
				_bits = new uint[1];
				_bits[0] = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a 64-bit signed integer value.</summary>
		/// <param name="value">A 64-bit signed integer.</param>
		[__DynamicallyInvokable]
		public BigInteger(long value)
		{
			if (int.MinValue <= value && value <= int.MaxValue)
			{
				if (value == int.MinValue)
				{
					this = s_bnMinInt;
					return;
				}
				_sign = (int)value;
				_bits = null;
				return;
			}
			ulong num = 0uL;
			if (value < 0)
			{
				num = (ulong)(-value);
				_sign = -1;
			}
			else
			{
				num = (ulong)value;
				_sign = 1;
			}
			_bits = new uint[2];
			_bits[0] = (uint)num;
			_bits[1] = (uint)(num >> 32);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure with an unsigned 64-bit integer value.</summary>
		/// <param name="value">An unsigned 64-bit integer.</param>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public BigInteger(ulong value)
		{
			if (value <= int.MaxValue)
			{
				_sign = (int)value;
				_bits = null;
				return;
			}
			_sign = 1;
			_bits = new uint[2];
			_bits[0] = (uint)value;
			_bits[1] = (uint)(value >> 32);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a single-precision floating-point value.</summary>
		/// <param name="value">A single-precision floating-point value.</param>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />.</exception>
		[__DynamicallyInvokable]
		public BigInteger(float value)
		{
			if (float.IsInfinity(value))
			{
				throw new OverflowException(SR.GetString("Overflow_BigIntInfinity"));
			}
			if (float.IsNaN(value))
			{
				throw new OverflowException(SR.GetString("Overflow_NotANumber"));
			}
			_sign = 0;
			_bits = null;
			SetBitsFromDouble(value);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a double-precision floating-point value.</summary>
		/// <param name="value">A double-precision floating-point value.</param>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />.</exception>
		[__DynamicallyInvokable]
		public BigInteger(double value)
		{
			if (double.IsInfinity(value))
			{
				throw new OverflowException(SR.GetString("Overflow_BigIntInfinity"));
			}
			if (double.IsNaN(value))
			{
				throw new OverflowException(SR.GetString("Overflow_NotANumber"));
			}
			_sign = 0;
			_bits = null;
			SetBitsFromDouble(value);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a <see cref="T:System.Decimal" /> value.</summary>
		/// <param name="value">A decimal number.</param>
		[__DynamicallyInvokable]
		public BigInteger(decimal value)
		{
			int[] bits = decimal.GetBits(decimal.Truncate(value));
			int num = 3;
			while (num > 0 && bits[num - 1] == 0)
			{
				num--;
			}
			switch (num)
			{
			case 0:
				this = s_bnZeroInt;
				return;
			case 1:
				if (bits[0] > 0)
				{
					_sign = bits[0];
					_sign *= (((bits[3] & int.MinValue) == 0) ? 1 : (-1));
					_bits = null;
					return;
				}
				break;
			}
			_bits = new uint[num];
			_bits[0] = (uint)bits[0];
			if (num > 1)
			{
				_bits[1] = (uint)bits[1];
			}
			if (num > 2)
			{
				_bits[2] = (uint)bits[2];
			}
			_sign = (((bits[3] & int.MinValue) == 0) ? 1 : (-1));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using the values in a byte array.</summary>
		/// <param name="value">An array of byte values in little-endian order.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="value" /> is <see langword="null" />.</exception>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public BigInteger(byte[] value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			int num = value.Length;
			bool flag = num > 0 && (value[num - 1] & 0x80) == 128;
			while (num > 0 && value[num - 1] == 0)
			{
				num--;
			}
			if (num == 0)
			{
				_sign = 0;
				_bits = null;
				return;
			}
			if (num <= 4)
			{
				if (flag)
				{
					_sign = -1;
				}
				else
				{
					_sign = 0;
				}
				for (int num2 = num - 1; num2 >= 0; num2--)
				{
					_sign <<= 8;
					_sign |= value[num2];
				}
				_bits = null;
				if (_sign < 0 && !flag)
				{
					_bits = new uint[1];
					_bits[0] = (uint)_sign;
					_sign = 1;
				}
				if (_sign == int.MinValue)
				{
					this = s_bnMinInt;
				}
				return;
			}
			int num3 = num % 4;
			int num4 = num / 4 + ((num3 != 0) ? 1 : 0);
			bool flag2 = true;
			uint[] array = new uint[num4];
			int num5 = 3;
			int i;
			for (i = 0; i < num4 - ((num3 != 0) ? 1 : 0); i++)
			{
				for (int j = 0; j < 4; j++)
				{
					if (value[num5] != 0)
					{
						flag2 = false;
					}
					array[i] <<= 8;
					array[i] |= value[num5];
					num5--;
				}
				num5 += 8;
			}
			if (num3 != 0)
			{
				if (flag)
				{
					array[num4 - 1] = uint.MaxValue;
				}
				for (num5 = num - 1; num5 >= num - num3; num5--)
				{
					if (value[num5] != 0)
					{
						flag2 = false;
					}
					array[i] <<= 8;
					array[i] |= value[num5];
				}
			}
			if (flag2)
			{
				this = s_bnZeroInt;
			}
			else if (flag)
			{
				NumericsHelpers.DangerousMakeTwosComplement(array);
				int num6 = array.Length;
				while (num6 > 0 && array[num6 - 1] == 0)
				{
					num6--;
				}
				if (num6 == 1 && (int)array[0] > 0)
				{
					if (array[0] == 1)
					{
						this = s_bnMinusOneInt;
						return;
					}
					if (array[0] == 2147483648u)
					{
						this = s_bnMinInt;
						return;
					}
					_sign = -1 * (int)array[0];
					_bits = null;
				}
				else if (num6 != array.Length)
				{
					_sign = -1;
					_bits = new uint[num6];
					Array.Copy(array, _bits, num6);
				}
				else
				{
					_sign = -1;
					_bits = array;
				}
			}
			else
			{
				_sign = 1;
				_bits = array;
			}
		}

		internal BigInteger(int n, uint[] rgu)
		{
			_sign = n;
			_bits = rgu;
		}

		internal BigInteger(uint[] value, bool negative)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			int num = value.Length;
			while (num > 0 && value[num - 1] == 0)
			{
				num--;
			}
			switch (num)
			{
			case 0:
				this = s_bnZeroInt;
				break;
			case 1:
				if (value[0] < 2147483648u)
				{
					_sign = (int)(negative ? (0 - value[0]) : value[0]);
					_bits = null;
					if (_sign == int.MinValue)
					{
						this = s_bnMinInt;
					}
					break;
				}
				goto default;
			default:
				_sign = ((!negative) ? 1 : (-1));
				_bits = new uint[num];
				Array.Copy(value, _bits, num);
				break;
			}
		}

		private BigInteger(uint[] value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			int num = value.Length;
			bool flag = num > 0 && (value[num - 1] & 0x80000000u) == 2147483648u;
			while (num > 0 && value[num - 1] == 0)
			{
				num--;
			}
			switch (num)
			{
			case 0:
				this = s_bnZeroInt;
				return;
			case 1:
				if ((int)value[0] < 0 && !flag)
				{
					_bits = new uint[1];
					_bits[0] = value[0];
					_sign = 1;
				}
				else if (int.MinValue == (int)value[0])
				{
					this = s_bnMinInt;
				}
				else
				{
					_sign = (int)value[0];
					_bits = null;
				}
				return;
			}
			if (!flag)
			{
				if (num != value.Length)
				{
					_sign = 1;
					_bits = new uint[num];
					Array.Copy(value, _bits, num);
				}
				else
				{
					_sign = 1;
					_bits = value;
				}
				return;
			}
			NumericsHelpers.DangerousMakeTwosComplement(value);
			int num2 = value.Length;
			while (num2 > 0 && value[num2 - 1] == 0)
			{
				num2--;
			}
			if (num2 == 1 && (int)value[0] > 0)
			{
				if (value[0] == 1)
				{
					this = s_bnMinusOneInt;
					return;
				}
				if (value[0] == 2147483648u)
				{
					this = s_bnMinInt;
					return;
				}
				_sign = -1 * (int)value[0];
				_bits = null;
			}
			else if (num2 != value.Length)
			{
				_sign = -1;
				_bits = new uint[num2];
				Array.Copy(value, _bits, num2);
			}
			else
			{
				_sign = -1;
				_bits = value;
			}
		}

		/// <summary>Converts the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</summary>
		/// <param name="value">A string that contains the number to convert.</param>
		/// <returns>A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="value" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.FormatException">
		///   <paramref name="value" /> is not in the correct format.</exception>
		[__DynamicallyInvokable]
		public static BigInteger Parse(string value)
		{
			return BigNumber.ParseBigInteger(value, NumberStyles.Integer, NumberFormatInfo.CurrentInfo);
		}

		/// <summary>Converts the string representation of a number in a specified style to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</summary>
		/// <param name="value">A string that contains a number to convert.</param>
		/// <param name="style">A bitwise combination of the enumeration values that specify the permitted format of <paramref name="value" />.</param>
		/// <returns>A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.  
		/// -or-  
		/// <paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="value" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.FormatException">
		///   <paramref name="value" /> does not comply with the input pattern specified by <see cref="T:System.Globalization.NumberStyles" />.</exception>
		[__DynamicallyInvokable]
		public static BigInteger Parse(string value, NumberStyles style)
		{
			return BigNumber.ParseBigInteger(value, style, NumberFormatInfo.CurrentInfo);
		}

		/// <summary>Converts the string representation of a number in a specified culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</summary>
		/// <param name="value">A string that contains a number to convert.</param>
		/// <param name="provider">An object that provides culture-specific formatting information about <paramref name="value" />.</param>
		/// <returns>A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="value" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.FormatException">
		///   <paramref name="value" /> is not in the correct format.</exception>
		[__DynamicallyInvokable]
		public static BigInteger Parse(string value, IFormatProvider provider)
		{
			return BigNumber.ParseBigInteger(value, NumberStyles.Integer, NumberFormatInfo.GetInstance(provider));
		}

		/// <summary>Converts the string representation of a number in a specified style and culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</summary>
		/// <param name="value">A string that contains a number to convert.</param>
		/// <param name="style">A bitwise combination of the enumeration values that specify the permitted format of <paramref name="value" />.</param>
		/// <param name="provider">An object that provides culture-specific formatting information about <paramref name="value" />.</param>
		/// <returns>A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.  
		/// -or-  
		/// <paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="value" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.FormatException">
		///   <paramref name="value" /> does not comply with the input pattern specified by <paramref name="style" />.</exception>
		[__DynamicallyInvokable]
		public static BigInteger Parse(string value, NumberStyles style, IFormatProvider provider)
		{
			return BigNumber.ParseBigInteger(value, style, NumberFormatInfo.GetInstance(provider));
		}

		/// <summary>Tries to convert the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent, and returns a value that indicates whether the conversion succeeded.</summary>
		/// <param name="value">The string representation of a number.</param>
		/// <param name="result">When this method returns, contains the <see cref="T:System.Numerics.BigInteger" /> equivalent to the number that is contained in <paramref name="value" />, or zero (0) if the conversion fails. The conversion fails if the <paramref name="value" /> parameter is <see langword="null" /> or is not of the correct format. This parameter is passed uninitialized.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="value" /> was converted successfully; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="value" /> is <see langword="null" />.</exception>
		[__DynamicallyInvokable]
		public static bool TryParse(string value, out BigInteger result)
		{
			return BigNumber.TryParseBigInteger(value, NumberStyles.Integer, NumberFormatInfo.CurrentInfo, out result);
		}

		/// <summary>Tries to convert the string representation of a number in a specified style and culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent, and returns a value that indicates whether the conversion succeeded.</summary>
		/// <param name="value">The string representation of a number. The string is interpreted using the style specified by <paramref name="style" />.</param>
		/// <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="value" />. A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
		/// <param name="provider">An object that supplies culture-specific formatting information about <paramref name="value" />.</param>
		/// <param name="result">When this method returns, contains the <see cref="T:System.Numerics.BigInteger" /> equivalent to the number that is contained in <paramref name="value" />, or <see cref="P:System.Numerics.BigInteger.Zero" /> if the conversion failed. The conversion fails if the <paramref name="value" /> parameter is <see langword="null" /> or is not in a format that is compliant with <paramref name="style" />. This parameter is passed uninitialized.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="value" /> parameter was converted successfully; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.  
		/// -or-  
		/// <paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</exception>
		[__DynamicallyInvokable]
		public static bool TryParse(string value, NumberStyles style, IFormatProvider provider, out BigInteger result)
		{
			return BigNumber.TryParseBigInteger(value, style, NumberFormatInfo.GetInstance(provider), out result);
		}

		/// <summary>Compares two <see cref="T:System.Numerics.BigInteger" /> values and returns an integer that indicates whether the first value is less than, equal to, or greater than the second value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>A signed integer that indicates the relative values of <paramref name="left" /> and <paramref name="right" />, as shown in the following table.  
		///   Value  
		///
		///   Condition  
		///
		///   Less than zero  
		///
		///  <paramref name="left" /> is less than <paramref name="right" />.  
		///
		///   Zero  
		///
		///  <paramref name="left" /> equals <paramref name="right" />.  
		///
		///   Greater than zero  
		///
		///  <paramref name="left" /> is greater than <paramref name="right" />.</returns>
		[__DynamicallyInvokable]
		public static int Compare(BigInteger left, BigInteger right)
		{
			return left.CompareTo(right);
		}

		/// <summary>Gets the absolute value of a <see cref="T:System.Numerics.BigInteger" /> object.</summary>
		/// <param name="value">A number.</param>
		/// <returns>The absolute value of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static BigInteger Abs(BigInteger value)
		{
			if (!(value >= Zero))
			{
				return -value;
			}
			return value;
		}

		/// <summary>Adds two <see cref="T:System.Numerics.BigInteger" /> values and returns the result.</summary>
		/// <param name="left">The first value to add.</param>
		/// <param name="right">The second value to add.</param>
		/// <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
		[__DynamicallyInvokable]
		public static BigInteger Add(BigInteger left, BigInteger right)
		{
			return left + right;
		}

		/// <summary>Subtracts one <see cref="T:System.Numerics.BigInteger" /> value from another and returns the result.</summary>
		/// <param name="left">The value to subtract from (the minuend).</param>
		/// <param name="right">The value to subtract (the subtrahend).</param>
		/// <returns>The result of subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
		[__DynamicallyInvokable]
		public static BigInteger Subtract(BigInteger left, BigInteger right)
		{
			return left - right;
		}

		/// <summary>Returns the product of two <see cref="T:System.Numerics.BigInteger" /> values.</summary>
		/// <param name="left">The first number to multiply.</param>
		/// <param name="right">The second number to multiply.</param>
		/// <returns>The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</returns>
		[__DynamicallyInvokable]
		public static BigInteger Multiply(BigInteger left, BigInteger right)
		{
			return left * right;
		}

		/// <summary>Divides one <see cref="T:System.Numerics.BigInteger" /> value by another and returns the result.</summary>
		/// <param name="dividend">The value to be divided.</param>
		/// <param name="divisor">The value to divide by.</param>
		/// <returns>The quotient of the division.</returns>
		/// <exception cref="T:System.DivideByZeroException">
		///   <paramref name="divisor" /> is 0 (zero).</exception>
		[__DynamicallyInvokable]
		public static BigInteger Divide(BigInteger dividend, BigInteger divisor)
		{
			return dividend / divisor;
		}

		/// <summary>Performs integer division on two <see cref="T:System.Numerics.BigInteger" /> values and returns the remainder.</summary>
		/// <param name="dividend">The value to be divided.</param>
		/// <param name="divisor">The value to divide by.</param>
		/// <returns>The remainder after dividing <paramref name="dividend" /> by <paramref name="divisor" />.</returns>
		/// <exception cref="T:System.DivideByZeroException">
		///   <paramref name="divisor" /> is 0 (zero).</exception>
		[__DynamicallyInvokable]
		public static BigInteger Remainder(BigInteger dividend, BigInteger divisor)
		{
			return dividend % divisor;
		}

		/// <summary>Divides one <see cref="T:System.Numerics.BigInteger" /> value by another, returns the result, and returns the remainder in an output parameter.</summary>
		/// <param name="dividend">The value to be divided.</param>
		/// <param name="divisor">The value to divide by.</param>
		/// <param name="remainder">When this method returns, contains a <see cref="T:System.Numerics.BigInteger" /> value that represents the remainder from the division. This parameter is passed uninitialized.</param>
		/// <returns>The quotient of the division.</returns>
		/// <exception cref="T:System.DivideByZeroException">
		///   <paramref name="divisor" /> is 0 (zero).</exception>
		[__DynamicallyInvokable]
		public static BigInteger DivRem(BigInteger dividend, BigInteger divisor, out BigInteger remainder)
		{
			int sign = 1;
			int sign2 = 1;
			BigIntegerBuilder bigIntegerBuilder = new BigIntegerBuilder(dividend, ref sign);
			BigIntegerBuilder regDen = new BigIntegerBuilder(divisor, ref sign2);
			BigIntegerBuilder regQuo = default(BigIntegerBuilder);
			bigIntegerBuilder.ModDiv(ref regDen, ref regQuo);
			remainder = bigIntegerBuilder.GetInteger(sign);
			return regQuo.GetInteger(sign * sign2);
		}

		/// <summary>Negates a specified <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="value">The value to negate.</param>
		/// <returns>The result of the <paramref name="value" /> parameter multiplied by negative one (-1).</returns>
		[__DynamicallyInvokable]
		public static BigInteger Negate(BigInteger value)
		{
			return -value;
		}

		/// <summary>Returns the natural (base <see langword="e" />) logarithm of a specified number.</summary>
		/// <param name="value">The number whose logarithm is to be found.</param>
		/// <returns>The natural (base <see langword="e" />) logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The natural log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</exception>
		[__DynamicallyInvokable]
		public static double Log(BigInteger value)
		{
			return Log(value, Math.E);
		}

		/// <summary>Returns the logarithm of a specified number in a specified base.</summary>
		/// <param name="value">A number whose logarithm is to be found.</param>
		/// <param name="baseValue">The base of the logarithm.</param>
		/// <returns>The base <paramref name="baseValue" /> logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</exception>
		[__DynamicallyInvokable]
		public static double Log(BigInteger value, double baseValue)
		{
			if (value._sign < 0 || baseValue == 1.0)
			{
				return double.NaN;
			}
			if (baseValue == double.PositiveInfinity)
			{
				if (!value.IsOne)
				{
					return double.NaN;
				}
				return 0.0;
			}
			if (baseValue == 0.0 && !value.IsOne)
			{
				return double.NaN;
			}
			if (value._bits == null)
			{
				return Math.Log(value._sign, baseValue);
			}
			double num = 0.0;
			double num2 = 0.5;
			int num3 = Length(value._bits);
			int num4 = BitLengthOfUInt(value._bits[num3 - 1]);
			int num5 = (num3 - 1) * 32 + num4;
			uint num6 = (uint)(1 << num4 - 1);
			for (int num7 = num3 - 1; num7 >= 0; num7--)
			{
				while (num6 != 0)
				{
					if ((value._bits[num7] & num6) != 0)
					{
						num += num2;
					}
					num2 *= 0.5;
					num6 >>= 1;
				}
				num6 = 2147483648u;
			}
			return (Math.Log(num) + 0.69314718055994529 * (double)num5) / Math.Log(baseValue);
		}

		/// <summary>Returns the base 10 logarithm of a specified number.</summary>
		/// <param name="value">A number whose logarithm is to be found.</param>
		/// <returns>The base 10 logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The base 10 log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</exception>
		[__DynamicallyInvokable]
		public static double Log10(BigInteger value)
		{
			return Log(value, 10.0);
		}

		/// <summary>Finds the greatest common divisor of two <see cref="T:System.Numerics.BigInteger" /> values.</summary>
		/// <param name="left">The first value.</param>
		/// <param name="right">The second value.</param>
		/// <returns>The greatest common divisor of <paramref name="left" /> and <paramref name="right" />.</returns>
		[__DynamicallyInvokable]
		public static BigInteger GreatestCommonDivisor(BigInteger left, BigInteger right)
		{
			if (left._sign == 0)
			{
				return Abs(right);
			}
			if (right._sign == 0)
			{
				return Abs(left);
			}
			BigIntegerBuilder reg = new BigIntegerBuilder(left);
			BigIntegerBuilder reg2 = new BigIntegerBuilder(right);
			BigIntegerBuilder.GCD(ref reg, ref reg2);
			return reg.GetInteger(1);
		}

		/// <summary>Returns the larger of two <see cref="T:System.Numerics.BigInteger" /> values.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>The <paramref name="left" /> or <paramref name="right" /> parameter, whichever is larger.</returns>
		[__DynamicallyInvokable]
		public static BigInteger Max(BigInteger left, BigInteger right)
		{
			if (left.CompareTo(right) < 0)
			{
				return right;
			}
			return left;
		}

		/// <summary>Returns the smaller of two <see cref="T:System.Numerics.BigInteger" /> values.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>The <paramref name="left" /> or <paramref name="right" /> parameter, whichever is smaller.</returns>
		[__DynamicallyInvokable]
		public static BigInteger Min(BigInteger left, BigInteger right)
		{
			if (left.CompareTo(right) <= 0)
			{
				return left;
			}
			return right;
		}

		private static void ModPowUpdateResult(ref BigIntegerBuilder regRes, ref BigIntegerBuilder regVal, ref BigIntegerBuilder regMod, ref BigIntegerBuilder regTmp)
		{
			NumericsHelpers.Swap(ref regRes, ref regTmp);
			regRes.Mul(ref regTmp, ref regVal);
			regRes.Mod(ref regMod);
		}

		private static void ModPowSquareModValue(ref BigIntegerBuilder regVal, ref BigIntegerBuilder regMod, ref BigIntegerBuilder regTmp)
		{
			NumericsHelpers.Swap(ref regVal, ref regTmp);
			regVal.Mul(ref regTmp, ref regTmp);
			regVal.Mod(ref regMod);
		}

		private static void ModPowInner(uint exp, ref BigIntegerBuilder regRes, ref BigIntegerBuilder regVal, ref BigIntegerBuilder regMod, ref BigIntegerBuilder regTmp)
		{
			while (exp != 0)
			{
				if ((exp & 1) == 1)
				{
					ModPowUpdateResult(ref regRes, ref regVal, ref regMod, ref regTmp);
				}
				if (exp != 1)
				{
					ModPowSquareModValue(ref regVal, ref regMod, ref regTmp);
					exp >>= 1;
					continue;
				}
				break;
			}
		}

		private static void ModPowInner32(uint exp, ref BigIntegerBuilder regRes, ref BigIntegerBuilder regVal, ref BigIntegerBuilder regMod, ref BigIntegerBuilder regTmp)
		{
			for (int i = 0; i < 32; i++)
			{
				if ((exp & 1) == 1)
				{
					ModPowUpdateResult(ref regRes, ref regVal, ref regMod, ref regTmp);
				}
				ModPowSquareModValue(ref regVal, ref regMod, ref regTmp);
				exp >>= 1;
			}
		}

		/// <summary>Performs modulus division on a number raised to the power of another number.</summary>
		/// <param name="value">The number to raise to the <paramref name="exponent" /> power.</param>
		/// <param name="exponent">The exponent to raise <paramref name="value" /> by.</param>
		/// <param name="modulus">The number by which to divide <paramref name="value" /> raised to the <paramref name="exponent" /> power.</param>
		/// <returns>The remainder after dividing <paramref name="value" />exponent by <paramref name="modulus" />.</returns>
		/// <exception cref="T:System.DivideByZeroException">
		///   <paramref name="modulus" /> is zero.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="exponent" /> is negative.</exception>
		[__DynamicallyInvokable]
		public static BigInteger ModPow(BigInteger value, BigInteger exponent, BigInteger modulus)
		{
			if (exponent.Sign < 0)
			{
				throw new ArgumentOutOfRangeException("exponent", SR.GetString("ArgumentOutOfRange_MustBeNonNeg"));
			}
			int sign = 1;
			int sign2 = 1;
			int sign3 = 1;
			bool isEven = exponent.IsEven;
			BigIntegerBuilder regRes = new BigIntegerBuilder(One, ref sign);
			BigIntegerBuilder regVal = new BigIntegerBuilder(value, ref sign2);
			BigIntegerBuilder regDen = new BigIntegerBuilder(modulus, ref sign3);
			BigIntegerBuilder regTmp = new BigIntegerBuilder(regVal.Size);
			regRes.Mod(ref regDen);
			if (exponent._bits == null)
			{
				ModPowInner((uint)exponent._sign, ref regRes, ref regVal, ref regDen, ref regTmp);
			}
			else
			{
				int num = Length(exponent._bits);
				for (int i = 0; i < num - 1; i++)
				{
					uint exp = exponent._bits[i];
					ModPowInner32(exp, ref regRes, ref regVal, ref regDen, ref regTmp);
				}
				ModPowInner(exponent._bits[num - 1], ref regRes, ref regVal, ref regDen, ref regTmp);
			}
			return regRes.GetInteger((value._sign > 0) ? 1 : (isEven ? 1 : (-1)));
		}

		/// <summary>Raises a <see cref="T:System.Numerics.BigInteger" /> value to the power of a specified value.</summary>
		/// <param name="value">The number to raise to the <paramref name="exponent" /> power.</param>
		/// <param name="exponent">The exponent to raise <paramref name="value" /> by.</param>
		/// <returns>The result of raising <paramref name="value" /> to the <paramref name="exponent" /> power.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="exponent" /> is negative.</exception>
		[__DynamicallyInvokable]
		public static BigInteger Pow(BigInteger value, int exponent)
		{
			if (exponent < 0)
			{
				throw new ArgumentOutOfRangeException("exponent", SR.GetString("ArgumentOutOfRange_MustBeNonNeg"));
			}
			switch (exponent)
			{
			case 0:
				return One;
			case 1:
				return value;
			default:
			{
				if (value._bits == null)
				{
					if (value._sign == 1)
					{
						return value;
					}
					if (value._sign == -1)
					{
						if ((exponent & 1) == 0)
						{
							return 1;
						}
						return value;
					}
					if (value._sign == 0)
					{
						return value;
					}
				}
				int sign = 1;
				BigIntegerBuilder reg = new BigIntegerBuilder(value, ref sign);
				int cuRes = reg.Size;
				int cuRes2 = cuRes;
				uint uHiRes = reg.High;
				uint uHiRes2 = uHiRes + 1;
				if (uHiRes2 == 0)
				{
					cuRes2++;
					uHiRes2 = 1u;
				}
				int cuRes3 = 1;
				int cuRes4 = 1;
				uint uHiRes3 = 1u;
				uint uHiRes4 = 1u;
				int num = exponent;
				while (true)
				{
					if (((uint)num & (true ? 1u : 0u)) != 0)
					{
						MulUpper(ref uHiRes4, ref cuRes4, uHiRes2, cuRes2);
						MulLower(ref uHiRes3, ref cuRes3, uHiRes, cuRes);
					}
					if ((num >>= 1) == 0)
					{
						break;
					}
					MulUpper(ref uHiRes2, ref cuRes2, uHiRes2, cuRes2);
					MulLower(ref uHiRes, ref cuRes, uHiRes, cuRes);
				}
				if (cuRes4 > 1)
				{
					reg.EnsureWritable(cuRes4, 0);
				}
				BigIntegerBuilder b = new BigIntegerBuilder(cuRes4);
				BigIntegerBuilder a = new BigIntegerBuilder(cuRes4);
				a.Set(1u);
				if ((exponent & 1) == 0)
				{
					sign = 1;
				}
				int num2 = exponent;
				while (true)
				{
					if (((uint)num2 & (true ? 1u : 0u)) != 0)
					{
						NumericsHelpers.Swap(ref a, ref b);
						a.Mul(ref reg, ref b);
					}
					if ((num2 >>= 1) == 0)
					{
						break;
					}
					NumericsHelpers.Swap(ref reg, ref b);
					reg.Mul(ref b, ref b);
				}
				return a.GetInteger(sign);
			}
			}
		}

		/// <summary>Defines an implicit conversion of an unsigned byte to a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		[__DynamicallyInvokable]
		public static implicit operator BigInteger(byte value)
		{
			return new BigInteger(value);
		}

		/// <summary>Defines an implicit conversion of an 8-bit signed integer to a <see cref="T:System.Numerics.BigInteger" /> value.  
		///  This API is not CLS-compliant. The compliant alternative is <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static implicit operator BigInteger(sbyte value)
		{
			return new BigInteger(value);
		}

		/// <summary>Defines an implicit conversion of a signed 16-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		[__DynamicallyInvokable]
		public static implicit operator BigInteger(short value)
		{
			return new BigInteger(value);
		}

		/// <summary>Defines an implicit conversion of a 16-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.  
		///  This API is not CLS-compliant. The compliant alternative is <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static implicit operator BigInteger(ushort value)
		{
			return new BigInteger(value);
		}

		/// <summary>Defines an implicit conversion of a signed 32-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		[__DynamicallyInvokable]
		public static implicit operator BigInteger(int value)
		{
			return new BigInteger(value);
		}

		/// <summary>Defines an implicit conversion of a 32-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.  
		///  This API is not CLS-compliant. The compliant alternative is <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static implicit operator BigInteger(uint value)
		{
			return new BigInteger(value);
		}

		/// <summary>Defines an implicit conversion of a signed 64-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		[__DynamicallyInvokable]
		public static implicit operator BigInteger(long value)
		{
			return new BigInteger(value);
		}

		/// <summary>Defines an implicit conversion of a 64-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.  
		///  This API is not CLS-compliant. The compliant alternative is <see cref="T:System.Double" />.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static implicit operator BigInteger(ulong value)
		{
			return new BigInteger(value);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Single" /> value to a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, or <see cref="F:System.Single.NegativeInfinity" />.</exception>
		[__DynamicallyInvokable]
		public static explicit operator BigInteger(float value)
		{
			return new BigInteger(value);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Double" /> value to a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" />, or <see cref="F:System.Double.NegativeInfinity" />.</exception>
		[__DynamicallyInvokable]
		public static explicit operator BigInteger(double value)
		{
			return new BigInteger(value);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Decimal" /> object to a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		[__DynamicallyInvokable]
		public static explicit operator BigInteger(decimal value)
		{
			return new BigInteger(value);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned byte value.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Byte" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is less than <see cref="F:System.Byte.MinValue" /> or greater than <see cref="F:System.Byte.MaxValue" />.</exception>
		[__DynamicallyInvokable]
		public static explicit operator byte(BigInteger value)
		{
			return checked((byte)(int)value);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a signed 8-bit value.  
		///  This API is not CLS-compliant. The compliant alternative is <see cref="T:System.Int16" />.</summary>
		/// <param name="value">The value to convert to a signed 8-bit value.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is less than <see cref="F:System.SByte.MinValue" /> or is greater than <see cref="F:System.SByte.MaxValue" />.</exception>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static explicit operator sbyte(BigInteger value)
		{
			return checked((sbyte)(int)value);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 16-bit signed integer value.</summary>
		/// <param name="value">The value to convert to a 16-bit signed integer.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is less than <see cref="F:System.Int16.MinValue" /> or is greater than <see cref="F:System.Int16.MaxValue" />.</exception>
		[__DynamicallyInvokable]
		public static explicit operator short(BigInteger value)
		{
			return checked((short)(int)value);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 16-bit integer value.  
		///  This API is not CLS-compliant. The compliant alternative is <see cref="T:System.Int32" />.</summary>
		/// <param name="value">The value to convert to an unsigned 16-bit integer.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is less than <see cref="F:System.UInt16.MinValue" /> or is greater than <see cref="F:System.UInt16.MaxValue" />.</exception>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static explicit operator ushort(BigInteger value)
		{
			return checked((ushort)(int)value);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 32-bit signed integer value.</summary>
		/// <param name="value">The value to convert to a 32-bit signed integer.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is less than <see cref="F:System.Int32.MinValue" /> or is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
		[__DynamicallyInvokable]
		public static explicit operator int(BigInteger value)
		{
			if (value._bits == null)
			{
				return value._sign;
			}
			if (Length(value._bits) > 1)
			{
				throw new OverflowException(SR.GetString("Overflow_Int32"));
			}
			if (value._sign > 0)
			{
				return checked((int)value._bits[0]);
			}
			if (value._bits[0] > 2147483648u)
			{
				throw new OverflowException(SR.GetString("Overflow_Int32"));
			}
			return (int)(0 - value._bits[0]);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 32-bit integer value.  
		///  This API is not CLS-compliant. The compliant alternative is <see cref="T:System.Int64" />.</summary>
		/// <param name="value">The value to convert to an unsigned 32-bit integer.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is less than <see cref="F:System.UInt32.MinValue" /> or is greater than <see cref="F:System.UInt32.MaxValue" />.</exception>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static explicit operator uint(BigInteger value)
		{
			if (value._bits == null)
			{
				return checked((uint)value._sign);
			}
			if (Length(value._bits) > 1 || value._sign < 0)
			{
				throw new OverflowException(SR.GetString("Overflow_UInt32"));
			}
			return value._bits[0];
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 64-bit signed integer value.</summary>
		/// <param name="value">The value to convert to a 64-bit signed integer.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is less than <see cref="F:System.Int64.MinValue" /> or is greater than <see cref="F:System.Int64.MaxValue" />.</exception>
		[__DynamicallyInvokable]
		public static explicit operator long(BigInteger value)
		{
			if (value._bits == null)
			{
				return value._sign;
			}
			int num = Length(value._bits);
			if (num > 2)
			{
				throw new OverflowException(SR.GetString("Overflow_Int64"));
			}
			ulong num2 = ((num <= 1) ? value._bits[0] : NumericsHelpers.MakeUlong(value._bits[1], value._bits[0]));
			long num3 = (long)((value._sign > 0) ? num2 : (0L - num2));
			if ((num3 > 0 && value._sign > 0) || (num3 < 0 && value._sign < 0))
			{
				return num3;
			}
			throw new OverflowException(SR.GetString("Overflow_Int64"));
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 64-bit integer value.  
		///  This API is not CLS-compliant. The compliant alternative is <see cref="T:System.Double" />.</summary>
		/// <param name="value">The value to convert to an unsigned 64-bit integer.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is less than <see cref="F:System.UInt64.MinValue" /> or is greater than <see cref="F:System.UInt64.MaxValue" />.</exception>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static explicit operator ulong(BigInteger value)
		{
			if (value._bits == null)
			{
				return checked((ulong)value._sign);
			}
			int num = Length(value._bits);
			if (num > 2 || value._sign < 0)
			{
				throw new OverflowException(SR.GetString("Overflow_UInt64"));
			}
			if (num > 1)
			{
				return NumericsHelpers.MakeUlong(value._bits[1], value._bits[0]);
			}
			return value._bits[0];
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a single-precision floating-point value.</summary>
		/// <param name="value">The value to convert to a single-precision floating-point value.</param>
		/// <returns>An object that contains the closest possible representation of the <paramref name="value" /> parameter.</returns>
		[__DynamicallyInvokable]
		public static explicit operator float(BigInteger value)
		{
			return (float)(double)value;
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a <see cref="T:System.Double" /> value.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Double" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		[__DynamicallyInvokable]
		public static explicit operator double(BigInteger value)
		{
			if (value._bits == null)
			{
				return value._sign;
			}
			int sign = 1;
			new BigIntegerBuilder(value, ref sign).GetApproxParts(out var exp, out var man);
			return NumericsHelpers.GetDoubleFromParts(sign, exp, man);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a <see cref="T:System.Decimal" /> value.</summary>
		/// <param name="value">The value to convert to a <see cref="T:System.Decimal" />.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter.</returns>
		/// <exception cref="T:System.OverflowException">
		///   <paramref name="value" /> is less than <see cref="F:System.Decimal.MinValue" /> or greater than <see cref="F:System.Decimal.MaxValue" />.</exception>
		[__DynamicallyInvokable]
		public static explicit operator decimal(BigInteger value)
		{
			if (value._bits == null)
			{
				return value._sign;
			}
			int num = Length(value._bits);
			if (num > 3)
			{
				throw new OverflowException(SR.GetString("Overflow_Decimal"));
			}
			int lo = 0;
			int mid = 0;
			int hi = 0;
			if (num > 2)
			{
				hi = (int)value._bits[2];
			}
			if (num > 1)
			{
				mid = (int)value._bits[1];
			}
			if (num > 0)
			{
				lo = (int)value._bits[0];
			}
			return new decimal(lo, mid, hi, value._sign < 0, 0);
		}

		/// <summary>Performs a bitwise <see langword="And" /> operation on two <see cref="T:System.Numerics.BigInteger" /> values.</summary>
		/// <param name="left">The first value.</param>
		/// <param name="right">The second value.</param>
		/// <returns>The result of the bitwise <see langword="And" /> operation.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator &(BigInteger left, BigInteger right)
		{
			if (left.IsZero || right.IsZero)
			{
				return Zero;
			}
			uint[] array = left.ToUInt32Array();
			uint[] array2 = right.ToUInt32Array();
			uint[] array3 = new uint[Math.Max(array.Length, array2.Length)];
			uint num = ((left._sign < 0) ? uint.MaxValue : 0u);
			uint num2 = ((right._sign < 0) ? uint.MaxValue : 0u);
			for (int i = 0; i < array3.Length; i++)
			{
				uint num3 = ((i < array.Length) ? array[i] : num);
				uint num4 = ((i < array2.Length) ? array2[i] : num2);
				array3[i] = num3 & num4;
			}
			return new BigInteger(array3);
		}

		/// <summary>Performs a bitwise <see langword="Or" /> operation on two <see cref="T:System.Numerics.BigInteger" /> values.</summary>
		/// <param name="left">The first value.</param>
		/// <param name="right">The second value.</param>
		/// <returns>The result of the bitwise <see langword="Or" /> operation.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator |(BigInteger left, BigInteger right)
		{
			if (left.IsZero)
			{
				return right;
			}
			if (right.IsZero)
			{
				return left;
			}
			uint[] array = left.ToUInt32Array();
			uint[] array2 = right.ToUInt32Array();
			uint[] array3 = new uint[Math.Max(array.Length, array2.Length)];
			uint num = ((left._sign < 0) ? uint.MaxValue : 0u);
			uint num2 = ((right._sign < 0) ? uint.MaxValue : 0u);
			for (int i = 0; i < array3.Length; i++)
			{
				uint num3 = ((i < array.Length) ? array[i] : num);
				uint num4 = ((i < array2.Length) ? array2[i] : num2);
				array3[i] = num3 | num4;
			}
			return new BigInteger(array3);
		}

		/// <summary>Performs a bitwise exclusive <see langword="Or" /> (<see langword="XOr" />) operation on two <see cref="T:System.Numerics.BigInteger" /> values.</summary>
		/// <param name="left">The first value.</param>
		/// <param name="right">The second value.</param>
		/// <returns>The result of the bitwise <see langword="Or" /> operation.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator ^(BigInteger left, BigInteger right)
		{
			uint[] array = left.ToUInt32Array();
			uint[] array2 = right.ToUInt32Array();
			uint[] array3 = new uint[Math.Max(array.Length, array2.Length)];
			uint num = ((left._sign < 0) ? uint.MaxValue : 0u);
			uint num2 = ((right._sign < 0) ? uint.MaxValue : 0u);
			for (int i = 0; i < array3.Length; i++)
			{
				uint num3 = ((i < array.Length) ? array[i] : num);
				uint num4 = ((i < array2.Length) ? array2[i] : num2);
				array3[i] = num3 ^ num4;
			}
			return new BigInteger(array3);
		}

		/// <summary>Shifts a <see cref="T:System.Numerics.BigInteger" /> value a specified number of bits to the left.</summary>
		/// <param name="value">The value whose bits are to be shifted.</param>
		/// <param name="shift">The number of bits to shift <paramref name="value" /> to the left.</param>
		/// <returns>A value that has been shifted to the left by the specified number of bits.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator <<(BigInteger value, int shift)
		{
			if (shift == 0)
			{
				return value;
			}
			if (shift == int.MinValue)
			{
				return value >> int.MaxValue >> 1;
			}
			if (shift < 0)
			{
				return value >> -shift;
			}
			int num = shift / 32;
			int num2 = shift - num * 32;
			uint[] xd;
			int xl;
			bool partsForBitManipulation = GetPartsForBitManipulation(ref value, out xd, out xl);
			int num3 = xl + num + 1;
			uint[] array = new uint[num3];
			if (num2 == 0)
			{
				for (int i = 0; i < xl; i++)
				{
					array[i + num] = xd[i];
				}
			}
			else
			{
				int num4 = 32 - num2;
				uint num5 = 0u;
				int j;
				for (j = 0; j < xl; j++)
				{
					uint num6 = xd[j];
					array[j + num] = (num6 << num2) | num5;
					num5 = num6 >> num4;
				}
				array[j + num] = num5;
			}
			return new BigInteger(array, partsForBitManipulation);
		}

		/// <summary>Shifts a <see cref="T:System.Numerics.BigInteger" /> value a specified number of bits to the right.</summary>
		/// <param name="value">The value whose bits are to be shifted.</param>
		/// <param name="shift">The number of bits to shift <paramref name="value" /> to the right.</param>
		/// <returns>A value that has been shifted to the right by the specified number of bits.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator >>(BigInteger value, int shift)
		{
			if (shift == 0)
			{
				return value;
			}
			if (shift == int.MinValue)
			{
				return value << int.MaxValue << 1;
			}
			if (shift < 0)
			{
				return value << -shift;
			}
			int num = shift / 32;
			int num2 = shift - num * 32;
			uint[] xd;
			int xl;
			bool partsForBitManipulation = GetPartsForBitManipulation(ref value, out xd, out xl);
			if (partsForBitManipulation)
			{
				if (shift >= 32 * xl)
				{
					return MinusOne;
				}
				uint[] array = new uint[xl];
				Array.Copy(xd, array, xl);
				xd = array;
				NumericsHelpers.DangerousMakeTwosComplement(xd);
			}
			int num3 = xl - num;
			if (num3 < 0)
			{
				num3 = 0;
			}
			uint[] array2 = new uint[num3];
			if (num2 == 0)
			{
				for (int num4 = xl - 1; num4 >= num; num4--)
				{
					array2[num4 - num] = xd[num4];
				}
			}
			else
			{
				int num5 = 32 - num2;
				uint num6 = 0u;
				for (int num7 = xl - 1; num7 >= num; num7--)
				{
					uint num8 = xd[num7];
					if (partsForBitManipulation && num7 == xl - 1)
					{
						array2[num7 - num] = (num8 >> num2) | (uint)(-1 << num5);
					}
					else
					{
						array2[num7 - num] = (num8 >> num2) | num6;
					}
					num6 = num8 << num5;
				}
			}
			if (partsForBitManipulation)
			{
				NumericsHelpers.DangerousMakeTwosComplement(array2);
			}
			return new BigInteger(array2, partsForBitManipulation);
		}

		/// <summary>Returns the bitwise one's complement of a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="value">An integer value.</param>
		/// <returns>The bitwise one's complement of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator ~(BigInteger value)
		{
			return -(value + One);
		}

		/// <summary>Negates a specified BigInteger value.</summary>
		/// <param name="value">The value to negate.</param>
		/// <returns>The result of the <paramref name="value" /> parameter multiplied by negative one (-1).</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator -(BigInteger value)
		{
			value._sign = -value._sign;
			return value;
		}

		/// <summary>Returns the value of the <see cref="T:System.Numerics.BigInteger" /> operand. (The sign of the operand is unchanged.)</summary>
		/// <param name="value">An integer value.</param>
		/// <returns>The value of the <paramref name="value" /> operand.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator +(BigInteger value)
		{
			return value;
		}

		/// <summary>Increments a <see cref="T:System.Numerics.BigInteger" /> value by 1.</summary>
		/// <param name="value">The value to increment.</param>
		/// <returns>The value of the <paramref name="value" /> parameter incremented by 1.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator ++(BigInteger value)
		{
			return value + One;
		}

		/// <summary>Decrements a <see cref="T:System.Numerics.BigInteger" /> value by 1.</summary>
		/// <param name="value">The value to decrement.</param>
		/// <returns>The value of the <paramref name="value" /> parameter decremented by 1.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator --(BigInteger value)
		{
			return value - One;
		}

		/// <summary>Adds the values of two specified <see cref="T:System.Numerics.BigInteger" /> objects.</summary>
		/// <param name="left">The first value to add.</param>
		/// <param name="right">The second value to add.</param>
		/// <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator +(BigInteger left, BigInteger right)
		{
			if (right.IsZero)
			{
				return left;
			}
			if (left.IsZero)
			{
				return right;
			}
			int sign = 1;
			int sign2 = 1;
			BigIntegerBuilder bigIntegerBuilder = new BigIntegerBuilder(left, ref sign);
			BigIntegerBuilder reg = new BigIntegerBuilder(right, ref sign2);
			if (sign == sign2)
			{
				bigIntegerBuilder.Add(ref reg);
			}
			else
			{
				bigIntegerBuilder.Sub(ref sign, ref reg);
			}
			return bigIntegerBuilder.GetInteger(sign);
		}

		/// <summary>Subtracts a <see cref="T:System.Numerics.BigInteger" /> value from another <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The value to subtract from (the minuend).</param>
		/// <param name="right">The value to subtract (the subtrahend).</param>
		/// <returns>The result of subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator -(BigInteger left, BigInteger right)
		{
			if (right.IsZero)
			{
				return left;
			}
			if (left.IsZero)
			{
				return -right;
			}
			int sign = 1;
			int sign2 = -1;
			BigIntegerBuilder bigIntegerBuilder = new BigIntegerBuilder(left, ref sign);
			BigIntegerBuilder reg = new BigIntegerBuilder(right, ref sign2);
			if (sign == sign2)
			{
				bigIntegerBuilder.Add(ref reg);
			}
			else
			{
				bigIntegerBuilder.Sub(ref sign, ref reg);
			}
			return bigIntegerBuilder.GetInteger(sign);
		}

		/// <summary>Multiplies two specified <see cref="T:System.Numerics.BigInteger" /> values.</summary>
		/// <param name="left">The first value to multiply.</param>
		/// <param name="right">The second value to multiply.</param>
		/// <returns>The product of <paramref name="left" /> and <paramref name="right" />.</returns>
		[__DynamicallyInvokable]
		public static BigInteger operator *(BigInteger left, BigInteger right)
		{
			int sign = 1;
			BigIntegerBuilder bigIntegerBuilder = new BigIntegerBuilder(left, ref sign);
			BigIntegerBuilder regMul = new BigIntegerBuilder(right, ref sign);
			bigIntegerBuilder.Mul(ref regMul);
			return bigIntegerBuilder.GetInteger(sign);
		}

		/// <summary>Divides a specified <see cref="T:System.Numerics.BigInteger" /> value by another specified <see cref="T:System.Numerics.BigInteger" /> value by using integer division.</summary>
		/// <param name="dividend">The value to be divided.</param>
		/// <param name="divisor">The value to divide by.</param>
		/// <returns>The integral result of the division.</returns>
		/// <exception cref="T:System.DivideByZeroException">
		///   <paramref name="divisor" /> is 0 (zero).</exception>
		[__DynamicallyInvokable]
		public static BigInteger operator /(BigInteger dividend, BigInteger divisor)
		{
			int sign = 1;
			BigIntegerBuilder bigIntegerBuilder = new BigIntegerBuilder(dividend, ref sign);
			BigIntegerBuilder regDen = new BigIntegerBuilder(divisor, ref sign);
			bigIntegerBuilder.Div(ref regDen);
			return bigIntegerBuilder.GetInteger(sign);
		}

		/// <summary>Returns the remainder that results from division with two specified <see cref="T:System.Numerics.BigInteger" /> values.</summary>
		/// <param name="dividend">The value to be divided.</param>
		/// <param name="divisor">The value to divide by.</param>
		/// <returns>The remainder that results from the division.</returns>
		/// <exception cref="T:System.DivideByZeroException">
		///   <paramref name="divisor" /> is 0 (zero).</exception>
		[__DynamicallyInvokable]
		public static BigInteger operator %(BigInteger dividend, BigInteger divisor)
		{
			int sign = 1;
			int sign2 = 1;
			BigIntegerBuilder bigIntegerBuilder = new BigIntegerBuilder(dividend, ref sign);
			BigIntegerBuilder regDen = new BigIntegerBuilder(divisor, ref sign2);
			bigIntegerBuilder.Mod(ref regDen);
			return bigIntegerBuilder.GetInteger(sign);
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than another <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator <(BigInteger left, BigInteger right)
		{
			return left.CompareTo(right) < 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to another <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator <=(BigInteger left, BigInteger right)
		{
			return left.CompareTo(right) <= 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than another <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator >(BigInteger left, BigInteger right)
		{
			return left.CompareTo(right) > 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to another <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator >=(BigInteger left, BigInteger right)
		{
			return left.CompareTo(right) >= 0;
		}

		/// <summary>Returns a value that indicates whether the values of two <see cref="T:System.Numerics.BigInteger" /> objects are equal.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator ==(BigInteger left, BigInteger right)
		{
			return left.Equals(right);
		}

		/// <summary>Returns a value that indicates whether two <see cref="T:System.Numerics.BigInteger" /> objects have different values.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator !=(BigInteger left, BigInteger right)
		{
			return !left.Equals(right);
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than a 64-bit signed integer.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator <(BigInteger left, long right)
		{
			return left.CompareTo(right) < 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to a 64-bit signed integer.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator <=(BigInteger left, long right)
		{
			return left.CompareTo(right) <= 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> is greater than a 64-bit signed integer value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator >(BigInteger left, long right)
		{
			return left.CompareTo(right) > 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to a 64-bit signed integer value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator >=(BigInteger left, long right)
		{
			return left.CompareTo(right) >= 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a signed long integer value are equal.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator ==(BigInteger left, long right)
		{
			return left.Equals(right);
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a 64-bit signed integer are not equal.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator !=(BigInteger left, long right)
		{
			return !left.Equals(right);
		}

		/// <summary>Returns a value that indicates whether a 64-bit signed integer is less than a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator <(long left, BigInteger right)
		{
			return right.CompareTo(left) > 0;
		}

		/// <summary>Returns a value that indicates whether a 64-bit signed integer is less than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator <=(long left, BigInteger right)
		{
			return right.CompareTo(left) >= 0;
		}

		/// <summary>Returns a value that indicates whether a 64-bit signed integer is greater than a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator >(long left, BigInteger right)
		{
			return right.CompareTo(left) < 0;
		}

		/// <summary>Returns a value that indicates whether a 64-bit signed integer is greater than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator >=(long left, BigInteger right)
		{
			return right.CompareTo(left) <= 0;
		}

		/// <summary>Returns a value that indicates whether a signed long integer value and a <see cref="T:System.Numerics.BigInteger" /> value are equal.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator ==(long left, BigInteger right)
		{
			return right.Equals(left);
		}

		/// <summary>Returns a value that indicates whether a 64-bit signed integer and a <see cref="T:System.Numerics.BigInteger" /> value are not equal.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator !=(long left, BigInteger right)
		{
			return !right.Equals(left);
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than a 64-bit unsigned integer.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator <(BigInteger left, ulong right)
		{
			return left.CompareTo(right) < 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to a 64-bit unsigned integer.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator <=(BigInteger left, ulong right)
		{
			return left.CompareTo(right) <= 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than a 64-bit unsigned integer.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator >(BigInteger left, ulong right)
		{
			return left.CompareTo(right) > 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to a 64-bit unsigned integer value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator >=(BigInteger left, ulong right)
		{
			return left.CompareTo(right) >= 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and an unsigned long integer value are equal.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator ==(BigInteger left, ulong right)
		{
			return left.Equals(right);
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a 64-bit unsigned integer are not equal.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator !=(BigInteger left, ulong right)
		{
			return !left.Equals(right);
		}

		/// <summary>Returns a value that indicates whether a 64-bit unsigned integer is less than a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator <(ulong left, BigInteger right)
		{
			return right.CompareTo(left) > 0;
		}

		/// <summary>Returns a value that indicates whether a 64-bit unsigned integer is less than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator <=(ulong left, BigInteger right)
		{
			return right.CompareTo(left) >= 0;
		}

		/// <summary>Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than a 64-bit unsigned integer.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator >(ulong left, BigInteger right)
		{
			return right.CompareTo(left) < 0;
		}

		/// <summary>Returns a value that indicates whether a 64-bit unsigned integer is greater than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator >=(ulong left, BigInteger right)
		{
			return right.CompareTo(left) <= 0;
		}

		/// <summary>Returns a value that indicates whether an unsigned long integer value and a <see cref="T:System.Numerics.BigInteger" /> value are equal.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator ==(ulong left, BigInteger right)
		{
			return right.Equals(left);
		}

		/// <summary>Returns a value that indicates whether a 64-bit unsigned integer and a <see cref="T:System.Numerics.BigInteger" /> value are not equal.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static bool operator !=(ulong left, BigInteger right)
		{
			return !right.Equals(left);
		}

		private void SetBitsFromDouble(double value)
		{
			NumericsHelpers.GetDoubleParts(value, out var sign, out var exp, out var man, out var _);
			if (man == 0L)
			{
				this = Zero;
				return;
			}
			if (exp <= 0)
			{
				if (exp <= -64)
				{
					this = Zero;
					return;
				}
				this = man >> -exp;
				if (sign < 0)
				{
					_sign = -_sign;
				}
				return;
			}
			if (exp <= 11)
			{
				this = man << exp;
				if (sign < 0)
				{
					_sign = -_sign;
				}
				return;
			}
			man <<= 11;
			exp -= 11;
			int num = (exp - 1) / 32 + 1;
			int num2 = num * 32 - exp;
			_bits = new uint[num + 2];
			_bits[num + 1] = (uint)(man >> num2 + 32);
			_bits[num] = (uint)(man >> num2);
			if (num2 > 0)
			{
				_bits[num - 1] = (uint)((int)man << 32 - num2);
			}
			_sign = sign;
		}

		internal static int Length(uint[] rgu)
		{
			int num = rgu.Length;
			if (rgu[num - 1] != 0)
			{
				return num;
			}
			return num - 1;
		}

		internal static int BitLengthOfUInt(uint x)
		{
			int num = 0;
			while (x != 0)
			{
				x >>= 1;
				num++;
			}
			return num;
		}

		private static bool GetPartsForBitManipulation(ref BigInteger x, out uint[] xd, out int xl)
		{
			if (x._bits == null)
			{
				if (x._sign < 0)
				{
					xd = new uint[1] { (uint)(-x._sign) };
				}
				else
				{
					xd = new uint[1] { (uint)x._sign };
				}
			}
			else
			{
				xd = x._bits;
			}
			xl = ((x._bits == null) ? 1 : x._bits.Length);
			return x._sign < 0;
		}

		private static void MulUpper(ref uint uHiRes, ref int cuRes, uint uHiMul, int cuMul)
		{
			ulong uu = (ulong)uHiRes * (ulong)uHiMul;
			uint num = NumericsHelpers.GetHi(uu);
			if (num != 0)
			{
				if (NumericsHelpers.GetLo(uu) != 0 && ++num == 0)
				{
					num = 1u;
					cuRes++;
				}
				uHiRes = num;
				cuRes += cuMul;
			}
			else
			{
				uHiRes = NumericsHelpers.GetLo(uu);
				cuRes += cuMul - 1;
			}
		}

		private static void MulLower(ref uint uHiRes, ref int cuRes, uint uHiMul, int cuMul)
		{
			ulong uu = (ulong)uHiRes * (ulong)uHiMul;
			uint hi = NumericsHelpers.GetHi(uu);
			if (hi != 0)
			{
				uHiRes = hi;
				cuRes += cuMul;
			}
			else
			{
				uHiRes = NumericsHelpers.GetLo(uu);
				cuRes += cuMul - 1;
			}
		}

		internal static int GetDiffLength(uint[] rgu1, uint[] rgu2, int cu)
		{
			int num = cu;
			while (--num >= 0)
			{
				if (rgu1[num] != rgu2[num])
				{
					return num + 1;
				}
			}
			return 0;
		}
	}
	internal struct BigIntegerBuilder
	{
		private const int kcbitUint = 32;

		private int _iuLast;

		private uint _uSmall;

		private uint[] _rgu;

		private bool _fWritable;

		private static readonly double kdblLn2To32 = 32.0 * Math.Log(2.0);

		private static readonly byte[] _rgbInv = new byte[128]
		{
			1, 171, 205, 183, 57, 163, 197, 239, 241, 27,
			61, 167, 41, 19, 53, 223, 225, 139, 173, 151,
			25, 131, 165, 207, 209, 251, 29, 135, 9, 243,
			21, 191, 193, 107, 141, 119, 249, 99, 133, 175,
			177, 219, 253, 103, 233, 211, 245, 159, 161, 75,
			109, 87, 217, 67, 101, 143, 145, 187, 221, 71,
			201, 179, 213, 127, 129, 43, 77, 55, 185, 35,
			69, 111, 113, 155, 189, 39, 169, 147, 181, 95,
			97, 11, 45, 23, 153, 3, 37, 79, 81, 123,
			157, 7, 137, 115, 149, 63, 65, 235, 13, 247,
			121, 227, 5, 47, 49, 91, 125, 231, 105, 83,
			117, 31, 33, 203, 237, 215, 89, 195, 229, 15,
			17, 59, 93, 199, 73, 51, 85, 255
		};

		public int Size => _iuLast + 1;

		public uint High
		{
			get
			{
				if (_iuLast != 0)
				{
					return _rgu[_iuLast];
				}
				return _uSmall;
			}
		}

		private int CuNonZero
		{
			get
			{
				int num = 0;
				for (int num2 = _iuLast; num2 >= 0; num2--)
				{
					if (_rgu[num2] != 0)
					{
						num++;
					}
				}
				return num;
			}
		}

		[Conditional("DEBUG")]
		private void AssertValid(bool fTrimmed)
		{
			_ = _iuLast;
			_ = 0;
		}

		public BigIntegerBuilder(ref BigIntegerBuilder reg)
		{
			this = reg;
			if (_fWritable)
			{
				_fWritable = false;
				if (_iuLast == 0)
				{
					_rgu = null;
				}
				else
				{
					reg._fWritable = false;
				}
			}
		}

		public BigIntegerBuilder(int cuAlloc)
		{
			_iuLast = 0;
			_uSmall = 0u;
			if (cuAlloc > 1)
			{
				_rgu = new uint[cuAlloc];
				_fWritable = true;
			}
			else
			{
				_rgu = null;
				_fWritable = false;
			}
		}

		public BigIntegerBuilder(BigInteger bn)
		{
			_fWritable = false;
			_rgu = bn._Bits;
			if (_rgu == null)
			{
				_iuLast = 0;
				_uSmall = NumericsHelpers.Abs(bn._Sign);
				return;
			}
			_iuLast = _rgu.Length - 1;
			_uSmall = _rgu[0];
			while (_iuLast > 0 && _rgu[_iuLast] == 0)
			{
				_iuLast--;
			}
		}

		public BigIntegerBuilder(BigInteger bn, ref int sign)
		{
			_fWritable = false;
			_rgu = bn._Bits;
			int sign2 = bn._Sign;
			int num = sign2 >> 31;
			sign = (sign ^ num) - num;
			if (_rgu == null)
			{
				_iuLast = 0;
				_uSmall = (uint)((sign2 ^ num) - num);
				return;
			}
			_iuLast = _rgu.Length - 1;
			_uSmall = _rgu[0];
			while (_iuLast > 0 && _rgu[_iuLast] == 0)
			{
				_iuLast--;
			}
		}

		public BigInteger GetInteger(int sign)
		{
			GetIntegerParts(sign, out sign, out var bits);
			return new BigInteger(sign, bits);
		}

		internal void GetIntegerParts(int signSrc, out int sign, out uint[] bits)
		{
			if (_iuLast == 0)
			{
				if (_uSmall <= int.MaxValue)
				{
					sign = signSrc * (int)_uSmall;
					bits = null;
					return;
				}
				if (_rgu == null)
				{
					_rgu = new uint[1] { _uSmall };
				}
				else if (_fWritable)
				{
					_rgu[0] = _uSmall;
				}
				else if (_rgu[0] != _uSmall)
				{
					_rgu = new uint[1] { _uSmall };
				}
			}
			sign = signSrc;
			int num = _rgu.Length - _iuLast - 1;
			if (num <= 1)
			{
				if (num == 0 || _rgu[_iuLast + 1] == 0)
				{
					_fWritable = false;
					bits = _rgu;
					return;
				}
				if (_fWritable)
				{
					_rgu[_iuLast + 1] = 0u;
					_fWritable = false;
					bits = _rgu;
					return;
				}
			}
			bits = _rgu;
			Array.Resize(ref bits, _iuLast + 1);
			if (!_fWritable)
			{
				_rgu = bits;
			}
		}

		public void Set(uint u)
		{
			_uSmall = u;
			_iuLast = 0;
		}

		public void Set(ulong uu)
		{
			uint hi = NumericsHelpers.GetHi(uu);
			if (hi == 0)
			{
				_uSmall = NumericsHelpers.GetLo(uu);
				_iuLast = 0;
			}
			else
			{
				SetSizeLazy(2);
				_rgu[0] = (uint)uu;
				_rgu[1] = hi;
			}
		}

		public void GetApproxParts(out int exp, out ulong man)
		{
			if (_iuLast == 0)
			{
				man = _uSmall;
				exp = 0;
				return;
			}
			int num = _iuLast - 1;
			man = NumericsHelpers.MakeUlong(_rgu[num + 1], _rgu[num]);
			exp = num * 32;
			int num2;
			if (num > 0 && (num2 = NumericsHelpers.CbitHighZero(_rgu[num + 1])) > 0)
			{
				man = (man << num2) | (_rgu[num - 1] >> 32 - num2);
				exp -= num2;
			}
		}

		private void Trim()
		{
			if (_iuLast > 0 && _rgu[_iuLast] == 0)
			{
				_uSmall = _rgu[0];
				while (--_iuLast > 0 && _rgu[_iuLast] == 0)
				{
				}
			}
		}

		private void SetSizeLazy(int cu)
		{
			if (cu <= 1)
			{
				_iuLast = 0;
				return;
			}
			if (!_fWritable || _rgu.Length < cu)
			{
				_rgu = new uint[cu];
				_fWritable = true;
			}
			_iuLast = cu - 1;
		}

		private void SetSizeClear(int cu)
		{
			if (cu <= 1)
			{
				_iuLast = 0;
				_uSmall = 0u;
				return;
			}
			if (!_fWritable || _rgu.Length < cu)
			{
				_rgu = new uint[cu];
				_fWritable = true;
			}
			else
			{
				Array.Clear(_rgu, 0, cu);
			}
			_iuLast = cu - 1;
		}

		private void SetSizeKeep(int cu, int cuExtra)
		{
			if (cu <= 1)
			{
				if (_iuLast > 0)
				{
					_uSmall = _rgu[0];
				}
				_iuLast = 0;
				return;
			}
			if (!_fWritable || _rgu.Length < cu)
			{
				uint[] array = new uint[cu + cuExtra];
				if (_iuLast == 0)
				{
					array[0] = _uSmall;
				}
				else
				{
					Array.Copy(_rgu, array, Math.Min(cu, _iuLast + 1));
				}
				_rgu = array;
				_fWritable = true;
			}
			else if (_iuLast + 1 < cu)
			{
				Array.Clear(_rgu, _iuLast + 1, cu - _iuLast - 1);
				if (_iuLast == 0)
				{
					_rgu[0] = _uSmall;
				}
			}
			_iuLast = cu - 1;
		}

		public void EnsureWritable(int cu, int cuExtra)
		{
			if (_fWritable && _rgu.Length >= cu)
			{
				return;
			}
			uint[] array = new uint[cu + cuExtra];
			if (_iuLast > 0)
			{
				if (_iuLast >= cu)
				{
					_iuLast = cu - 1;
				}
				Array.Copy(_rgu, array, _iuLast + 1);
			}
			_rgu = array;
			_fWritable = true;
		}

		public void EnsureWritable(int cuExtra)
		{
			if (!_fWritable)
			{
				uint[] array = new uint[_iuLast + 1 + cuExtra];
				Array.Copy(_rgu, array, _iuLast + 1);
				_rgu = array;
				_fWritable = true;
			}
		}

		public void EnsureWritable()
		{
			EnsureWritable(0);
		}

		public void Load(ref BigIntegerBuilder reg)
		{
			Load(ref reg, 0);
		}

		public void Load(ref BigIntegerBuilder reg, int cuExtra)
		{
			if (reg._iuLast == 0)
			{
				_uSmall = reg._uSmall;
				_iuLast = 0;
				return;
			}
			if (!_fWritable || _rgu.Length <= reg._iuLast)
			{
				_rgu = new uint[reg._iuLast + 1 + cuExtra];
				_fWritable = true;
			}
			_iuLast = reg._iuLast;
			Array.Copy(reg._rgu, _rgu, _iuLast + 1);
		}

		public void Add(uint u)
		{
			if (_iuLast == 0)
			{
				if ((_uSmall += u) < u)
				{
					SetSizeLazy(2);
					_rgu[0] = _uSmall;
					_rgu[1] = 1u;
				}
			}
			else if (u != 0)
			{
				uint num = _rgu[0] + u;
				if (num < u)
				{
					EnsureWritable(1);
					ApplyCarry(1);
				}
				else if (!_fWritable)
				{
					EnsureWritable();
				}
				_rgu[0] = num;
			}
		}

		public void Add(ref BigIntegerBuilder reg)
		{
			if (reg._iuLast == 0)
			{
				Add(reg._uSmall);
				return;
			}
			if (_iuLast == 0)
			{
				uint uSmall = _uSmall;
				if (uSmall == 0)
				{
					this = new BigIntegerBuilder(ref reg);
					return;
				}
				Load(ref reg, 1);
				Add(uSmall);
				return;
			}
			EnsureWritable(Math.Max(_iuLast, reg._iuLast) + 1, 1);
			int num = reg._iuLast + 1;
			if (_iuLast < reg._iuLast)
			{
				num = _iuLast + 1;
				Array.Copy(reg._rgu, _iuLast + 1, _rgu, _iuLast + 1, reg._iuLast - _iuLast);
				_iuLast = reg._iuLast;
			}
			uint num2 = 0u;
			for (int i = 0; i < num; i++)
			{
				num2 = AddCarry(ref _rgu[i], reg._rgu[i], num2);
			}
			if (num2 != 0)
			{
				ApplyCarry(num);
			}
		}

		public void Sub(ref int sign, uint u)
		{
			if (_iuLast == 0)
			{
				if (u <= _uSmall)
				{
					_uSmall -= u;
					return;
				}
				_uSmall = u - _uSmall;
				sign = -sign;
			}
			else if (u != 0)
			{
				EnsureWritable();
				uint num = _rgu[0];
				_rgu[0] = num - u;
				if (num < u)
				{
					ApplyBorrow(1);
					Trim();
				}
			}
		}

		public void Sub(ref int sign, ref BigIntegerBuilder reg)
		{
			if (reg._iuLast == 0)
			{
				Sub(ref sign, reg._uSmall);
				return;
			}
			if (_iuLast == 0)
			{
				uint uSmall = _uSmall;
				if (uSmall == 0)
				{
					this = new BigIntegerBuilder(ref reg);
				}
				else
				{
					Load(ref reg);
					Sub(ref sign, uSmall);
				}
				sign = -sign;
				return;
			}
			if (_iuLast < reg._iuLast)
			{
				SubRev(ref reg);
				sign = -sign;
				return;
			}
			int num = reg._iuLast + 1;
			if (_iuLast == reg._iuLast)
			{
				_iuLast = BigInteger.GetDiffLength(_rgu, reg._rgu, _iuLast + 1) - 1;
				if (_iuLast < 0)
				{
					_iuLast = 0;
					_uSmall = 0u;
					return;
				}
				uint num2 = _rgu[_iuLast];
				uint num3 = reg._rgu[_iuLast];
				if (_iuLast == 0)
				{
					if (num2 < num3)
					{
						_uSmall = num3 - num2;
						sign = -sign;
					}
					else
					{
						_uSmall = num2 - num3;
					}
					return;
				}
				if (num2 < num3)
				{
					reg._iuLast = _iuLast;
					SubRev(ref reg);
					reg._iuLast = num - 1;
					sign = -sign;
					return;
				}
				num = _iuLast + 1;
			}
			EnsureWritable();
			uint num4 = 0u;
			for (int i = 0; i < num; i++)
			{
				num4 = SubBorrow(ref _rgu[i], reg._rgu[i], num4);
			}
			if (num4 != 0)
			{
				ApplyBorrow(num);
			}
			Trim();
		}

		private void SubRev(ref BigIntegerBuilder reg)
		{
			EnsureWritable(reg._iuLast + 1, 0);
			int num = _iuLast + 1;
			if (_iuLast < reg._iuLast)
			{
				Array.Copy(reg._rgu, _iuLast + 1, _rgu, _iuLast + 1, reg._iuLast - _iuLast);
				_iuLast = reg._iuLast;
			}
			uint num2 = 0u;
			for (int i = 0; i < num; i++)
			{
				num2 = SubRevBorrow(ref _rgu[i], reg._rgu[i], num2);
			}
			if (num2 != 0)
			{
				ApplyBorrow(num);
			}
			Trim();
		}

		public void Mul(uint u)
		{
			switch (u)
			{
			case 0u:
				Set(0u);
				return;
			case 1u:
				return;
			}
			if (_iuLast == 0)
			{
				Set((ulong)_uSmall * (ulong)u);
				return;
			}
			EnsureWritable(1);
			uint num = 0u;
			for (int i = 0; i <= _iuLast; i++)
			{
				num = MulCarry(ref _rgu[i], u, num);
			}
			if (num != 0)
			{
				SetSizeKeep(_iuLast + 2, 0);
				_rgu[_iuLast] = num;
			}
		}

		public void Mul(ref BigIntegerBuilder regMul)
		{
			if (regMul._iuLast == 0)
			{
				Mul(regMul._uSmall);
				return;
			}
			if (_iuLast == 0)
			{
				uint uSmall = _uSmall;
				switch (uSmall)
				{
				case 1u:
					this = new BigIntegerBuilder(ref regMul);
					break;
				default:
					Load(ref regMul, 1);
					Mul(uSmall);
					break;
				case 0u:
					break;
				}
				return;
			}
			int num = _iuLast + 1;
			SetSizeKeep(num + regMul._iuLast, 1);
			int num2 = num;
			while (--num2 >= 0)
			{
				uint uMul = _rgu[num2];
				_rgu[num2] = 0u;
				uint num3 = 0u;
				for (int i = 0; i <= regMul._iuLast; i++)
				{
					num3 = AddMulCarry(ref _rgu[num2 + i], regMul._rgu[i], uMul, num3);
				}
				if (num3 != 0)
				{
					int num4 = num2 + regMul._iuLast + 1;
					while (num3 != 0 && num4 <= _iuLast)
					{
						num3 = AddCarry(ref _rgu[num4], 0u, num3);
						num4++;
					}
					if (num3 != 0)
					{
						SetSizeKeep(_iuLast + 2, 0);
						_rgu[_iuLast] = num3;
					}
				}
			}
		}

		public void Mul(ref BigIntegerBuilder reg1, ref BigIntegerBuilder reg2)
		{
			if (reg1._iuLast == 0)
			{
				if (reg2._iuLast == 0)
				{
					Set((ulong)reg1._uSmall * (ulong)reg2._uSmall);
					return;
				}
				Load(ref reg2, 1);
				Mul(reg1._uSmall);
				return;
			}
			if (reg2._iuLast == 0)
			{
				Load(ref reg1, 1);
				Mul(reg2._uSmall);
				return;
			}
			SetSizeClear(reg1._iuLast + reg2._iuLast + 2);
			uint[] rgu;
			int num;
			uint[] rgu2;
			int num2;
			if (reg1.CuNonZero <= reg2.CuNonZero)
			{
				rgu = reg1._rgu;
				num = reg1._iuLast + 1;
				rgu2 = reg2._rgu;
				num2 = reg2._iuLast + 1;
			}
			else
			{
				rgu = reg2._rgu;
				num = reg2._iuLast + 1;
				rgu2 = reg1._rgu;
				num2 = reg1._iuLast + 1;
			}
			for (int i = 0; i < num; i++)
			{
				uint num3 = rgu[i];
				if (num3 != 0)
				{
					uint num4 = 0u;
					int num5 = i;
					int num6 = 0;
					while (num6 < num2)
					{
						num4 = AddMulCarry(ref _rgu[num5], num3, rgu2[num6], num4);
						num6++;
						num5++;
					}
					while (num4 != 0)
					{
						num4 = AddCarry(ref _rgu[num5++], 0u, num4);
					}
				}
			}
			Trim();
		}

		public uint DivMod(uint uDen)
		{
			if (uDen == 1)
			{
				return 0u;
			}
			if (_iuLast == 0)
			{
				uint uSmall = _uSmall;
				_uSmall = uSmall / uDen;
				return uSmall % uDen;
			}
			EnsureWritable();
			ulong num = 0uL;
			for (int num2 = _iuLast; num2 >= 0; num2--)
			{
				num = NumericsHelpers.MakeUlong((uint)num, _rgu[num2]);
				_rgu[num2] = (uint)(num / uDen);
				num %= uDen;
			}
			Trim();
			return (uint)num;
		}

		public static uint Mod(ref BigIntegerBuilder regNum, uint uDen)
		{
			if (uDen == 1)
			{
				return 0u;
			}
			if (regNum._iuLast == 0)
			{
				return regNum._uSmall % uDen;
			}
			ulong num = 0uL;
			for (int num2 = regNum._iuLast; num2 >= 0; num2--)
			{
				num = NumericsHelpers.MakeUlong((uint)num, regNum._rgu[num2]);
				num %= uDen;
			}
			return (uint)num;
		}

		public void Mod(ref BigIntegerBuilder regDen)
		{
			if (regDen._iuLast == 0)
			{
				Set(Mod(ref this, regDen._uSmall));
			}
			else if (_iuLast != 0)
			{
				BigIntegerBuilder regQuo = default(BigIntegerBuilder);
				ModDivCore(ref this, ref regDen, fQuo: false, ref regQuo);
			}
		}

		public void Div(ref BigIntegerBuilder regDen)
		{
			if (regDen._iuLast == 0)
			{
				DivMod(regDen._uSmall);
				return;
			}
			if (_iuLast == 0)
			{
				_uSmall = 0u;
				return;
			}
			BigIntegerBuilder regQuo = default(BigIntegerBuilder);
			ModDivCore(ref this, ref regDen, fQuo: true, ref regQuo);
			NumericsHelpers.Swap(ref this, ref regQuo);
		}

		public void ModDiv(ref BigIntegerBuilder regDen, ref BigIntegerBuilder regQuo)
		{
			if (regDen._iuLast == 0)
			{
				regQuo.Set(DivMod(regDen._uSmall));
				NumericsHelpers.Swap(ref this, ref regQuo);
			}
			else if (_iuLast != 0)
			{
				ModDivCore(ref this, ref regDen, fQuo: true, ref regQuo);
			}
		}

		private static void ModDivCore(ref BigIntegerBuilder regNum, ref BigIntegerBuilder regDen, bool fQuo, ref BigIntegerBuilder regQuo)
		{
			regQuo.Set(0u);
			if (regNum._iuLast < regDen._iuLast)
			{
				return;
			}
			int num = regDen._iuLast + 1;
			int num2 = regNum._iuLast - regDen._iuLast;
			int num3 = num2;
			int num4 = regNum._iuLast;
			while (true)
			{
				if (num4 < num2)
				{
					num3++;
					break;
				}
				if (regDen._rgu[num4 - num2] != regNum._rgu[num4])
				{
					if (regDen._rgu[num4 - num2] < regNum._rgu[num4])
					{
						num3++;
					}
					break;
				}
				num4--;
			}
			if (num3 == 0)
			{
				return;
			}
			if (fQuo)
			{
				regQuo.SetSizeLazy(num3);
			}
			uint num5 = regDen._rgu[num - 1];
			uint num6 = regDen._rgu[num - 2];
			int num7 = NumericsHelpers.CbitHighZero(num5);
			int num8 = 32 - num7;
			if (num7 > 0)
			{
				num5 = (num5 << num7) | (num6 >> num8);
				num6 <<= num7;
				if (num > 2)
				{
					num6 |= regDen._rgu[num - 3] >> num8;
				}
			}
			regNum.EnsureWritable();
			int num9 = num3;
			while (--num9 >= 0)
			{
				uint num10 = ((num9 + num <= regNum._iuLast) ? regNum._rgu[num9 + num] : 0u);
				ulong num11 = NumericsHelpers.MakeUlong(num10, regNum._rgu[num9 + num - 1]);
				uint num12 = regNum._rgu[num9 + num - 2];
				if (num7 > 0)
				{
					num11 = (num11 << num7) | (num12 >> num8);
					num12 <<= num7;
					if (num9 + num >= 3)
					{
						num12 |= regNum._rgu[num9 + num - 3] >> num8;
					}
				}
				ulong num13 = num11 / num5;
				ulong num14 = (uint)(num11 % num5);
				if (num13 > uint.MaxValue)
				{
					num14 += num5 * (num13 - uint.MaxValue);
					num13 = 4294967295uL;
				}
				for (; num14 <= uint.MaxValue && num13 * num6 > NumericsHelpers.MakeUlong((uint)num14, num12); num14 += num5)
				{
					num13--;
				}
				if (num13 != 0)
				{
					ulong num15 = 0uL;
					for (int i = 0; i < num; i++)
					{
						num15 += regDen._rgu[i] * num13;
						uint num16 = (uint)num15;
						num15 >>= 32;
						if (regNum._rgu[num9 + i] < num16)
						{
							num15++;
						}
						regNum._rgu[num9 + i] -= num16;
					}
					if (num10 < num15)
					{
						uint uCarry = 0u;
						for (int j = 0; j < num; j++)
						{
							uCarry = AddCarry(ref regNum._rgu[num9 + j], regDen._rgu[j], uCarry);
						}
						num13--;
					}
					regNum._iuLast = num9 + num - 1;
				}
				if (fQuo)
				{
					if (num3 == 1)
					{
						regQuo._uSmall = (uint)num13;
					}
					else
					{
						regQuo._rgu[num9] = (uint)num13;
					}
				}
			}
			regNum._iuLast = num - 1;
			regNum.Trim();
		}

		public void ShiftRight(int cbit)
		{
			if (cbit <= 0)
			{
				if (cbit < 0)
				{
					ShiftLeft(-cbit);
				}
			}
			else
			{
				ShiftRight(cbit / 32, cbit % 32);
			}
		}

		public void ShiftRight(int cuShift, int cbitShift)
		{
			if ((cuShift | cbitShift) == 0)
			{
				return;
			}
			if (cuShift > _iuLast)
			{
				Set(0u);
				return;
			}
			if (_iuLast == 0)
			{
				_uSmall >>= cbitShift;
				return;
			}
			uint[] rgu = _rgu;
			int num = _iuLast + 1;
			_iuLast -= cuShift;
			if (_iuLast == 0)
			{
				_uSmall = rgu[cuShift] >> cbitShift;
				return;
			}
			if (!_fWritable)
			{
				_rgu = new uint[_iuLast + 1];
				_fWritable = true;
			}
			if (cbitShift > 0)
			{
				int num2 = cuShift + 1;
				int num3 = 0;
				while (num2 < num)
				{
					_rgu[num3] = (rgu[num2 - 1] >> cbitShift) | (rgu[num2] << 32 - cbitShift);
					num2++;
					num3++;
				}
				_rgu[_iuLast] = rgu[num - 1] >> cbitShift;
				Trim();
			}
			else
			{
				Array.Copy(rgu, cuShift, _rgu, 0, _iuLast + 1);
			}
		}

		public void ShiftLeft(int cbit)
		{
			if (cbit <= 0)
			{
				if (cbit < 0)
				{
					ShiftRight(-cbit);
				}
			}
			else
			{
				ShiftLeft(cbit / 32, cbit % 32);
			}
		}

		public void ShiftLeft(int cuShift, int cbitShift)
		{
			int num = _iuLast + cuShift;
			uint num2 = 0u;
			if (cbitShift > 0)
			{
				num2 = High >> 32 - cbitShift;
				if (num2 != 0)
				{
					num++;
				}
			}
			if (num == 0)
			{
				_uSmall <<= cbitShift;
				return;
			}
			uint[] rgu = _rgu;
			bool flag = cuShift > 0;
			if (!_fWritable || _rgu.Length <= num)
			{
				_rgu = new uint[num + 1];
				_fWritable = true;
				flag = false;
			}
			if (_iuLast == 0)
			{
				if (num2 != 0)
				{
					_rgu[cuShift + 1] = num2;
				}
				_rgu[cuShift] = _uSmall << cbitShift;
			}
			else if (cbitShift == 0)
			{
				Array.Copy(rgu, 0, _rgu, cuShift, _iuLast + 1);
			}
			else
			{
				int num3 = _iuLast;
				int num4 = _iuLast + cuShift;
				if (num4 < num)
				{
					_rgu[num] = num2;
				}
				while (num3 > 0)
				{
					_rgu[num4] = (rgu[num3] << cbitShift) | (rgu[num3 - 1] >> 32 - cbitShift);
					num3--;
					num4--;
				}
				_rgu[cuShift] = rgu[0] << cbitShift;
			}
			_iuLast = num;
			if (flag)
			{
				Array.Clear(_rgu, 0, cuShift);
			}
		}

		private ulong GetHigh2(int cu)
		{
			if (cu - 1 <= _iuLast)
			{
				return NumericsHelpers.MakeUlong(_rgu[cu - 1], _rgu[cu - 2]);
			}
			if (cu - 2 == _iuLast)
			{
				return _rgu[cu - 2];
			}
			return 0uL;
		}

		private void ApplyCarry(int iu)
		{
			while (true)
			{
				if (iu > _iuLast)
				{
					if (_iuLast + 1 == _rgu.Length)
					{
						Array.Resize(ref _rgu, _iuLast + 2);
					}
					_rgu[++_iuLast] = 1u;
					break;
				}
				if (++_rgu[iu] == 0)
				{
					iu++;
					continue;
				}
				break;
			}
		}

		private void ApplyBorrow(int iuMin)
		{
			for (int i = iuMin; i <= _iuLast; i++)
			{
				if (_rgu[i]-- != 0)
				{
					break;
				}
			}
		}

		private static uint AddCarry(ref uint u1, uint u2, uint uCarry)
		{
			ulong num = (ulong)((long)u1 + (long)u2 + uCarry);
			u1 = (uint)num;
			return (uint)(num >> 32);
		}

		private static uint SubBorrow(ref uint u1, uint u2, uint uBorrow)
		{
			ulong num = (ulong)((long)u1 - (long)u2 - uBorrow);
			u1 = (uint)num;
			return (uint)(-(int)(num >> 32));
		}

		private static uint SubRevBorrow(ref uint u1, uint u2, uint uBorrow)
		{
			ulong num = (ulong)((long)u2 - (long)u1 - uBorrow);
			u1 = (uint)num;
			return (uint)(-(int)(num >> 32));
		}

		private static uint MulCarry(ref uint u1, uint u2, uint uCarry)
		{
			ulong num = (ulong)((long)u1 * (long)u2 + uCarry);
			u1 = (uint)num;
			return (uint)(num >> 32);
		}

		private static uint AddMulCarry(ref uint uAdd, uint uMul1, uint uMul2, uint uCarry)
		{
			ulong num = (ulong)((long)uMul1 * (long)uMul2 + uAdd + uCarry);
			uAdd = (uint)num;
			return (uint)(num >> 32);
		}

		public static void GCD(ref BigIntegerBuilder reg1, ref BigIntegerBuilder reg2)
		{
			if ((reg1._iuLast > 0 && reg1._rgu[0] == 0) || (reg2._iuLast > 0 && reg2._rgu[0] == 0))
			{
				int val = reg1.MakeOdd();
				int val2 = reg2.MakeOdd();
				LehmerGcd(ref reg1, ref reg2);
				int num = Math.Min(val, val2);
				if (num > 0)
				{
					reg1.ShiftLeft(num);
				}
			}
			else
			{
				LehmerGcd(ref reg1, ref reg2);
			}
		}

		private static void LehmerGcd(ref BigIntegerBuilder reg1, ref BigIntegerBuilder reg2)
		{
			int sign = 1;
			while (true)
			{
				int a = reg1._iuLast + 1;
				int b = reg2._iuLast + 1;
				if (a < b)
				{
					NumericsHelpers.Swap(ref reg1, ref reg2);
					NumericsHelpers.Swap(ref a, ref b);
				}
				if (b == 1)
				{
					if (a == 1)
					{
						reg1._uSmall = NumericsHelpers.GCD(reg1._uSmall, reg2._uSmall);
					}
					else if (reg2._uSmall != 0)
					{
						reg1.Set(NumericsHelpers.GCD(Mod(ref reg1, reg2._uSmall), reg2._uSmall));
					}
					return;
				}
				if (a == 2)
				{
					break;
				}
				if (b <= a - 2)
				{
					reg1.Mod(ref reg2);
					continue;
				}
				ulong a2 = reg1.GetHigh2(a);
				ulong b2 = reg2.GetHigh2(a);
				int num = NumericsHelpers.CbitHighZero(a2 | b2);
				if (num > 0)
				{
					a2 = (a2 << num) | (reg1._rgu[a - 3] >> 32 - num);
					b2 = (b2 << num) | (reg2._rgu[a - 3] >> 32 - num);
				}
				if (a2 < b2)
				{
					NumericsHelpers.Swap(ref a2, ref b2);
					NumericsHelpers.Swap(ref reg1, ref reg2);
				}
				if (a2 == ulong.MaxValue || b2 == ulong.MaxValue)
				{
					a2 >>= 1;
					b2 >>= 1;
				}
				if (a2 == b2)
				{
					reg1.Sub(ref sign, ref reg2);
					continue;
				}
				if (NumericsHelpers.GetHi(b2) == 0)
				{
					reg1.Mod(ref reg2);
					continue;
				}
				uint num2 = 1u;
				uint num3 = 0u;
				uint num4 = 0u;
				uint num5 = 1u;
				do
				{
					uint num6 = 1u;
					ulong num7 = a2 - b2;
					while (num7 >= b2 && num6 < 32)
					{
						num7 -= b2;
						num6++;
					}
					if (num7 >= b2)
					{
						ulong num8 = a2 / b2;
						if (num8 > uint.MaxValue)
						{
							break;
						}
						num6 = (uint)num8;
						num7 = a2 - num6 * b2;
					}
					ulong num9 = (ulong)(num2 + (long)num6 * (long)num4);
					ulong num10 = (ulong)(num3 + (long)num6 * (long)num5);
					if (num9 > int.MaxValue || num10 > int.MaxValue || num7 < num10 || num7 + num9 > b2 - num4)
					{
						break;
					}
					num2 = (uint)num9;
					num3 = (uint)num10;
					a2 = num7;
					if (a2 <= num3)
					{
						break;
					}
					num6 = 1u;
					num7 = b2 - a2;
					while (num7 >= a2 && num6 < 32)
					{
						num7 -= a2;
						num6++;
					}
					if (num7 >= a2)
					{
						ulong num11 = b2 / a2;
						if (num11 > uint.MaxValue)
						{
							break;
						}
						num6 = (uint)num11;
						num7 = b2 - num6 * a2;
					}
					num9 = (ulong)(num5 + (long)num6 * (long)num3);
					num10 = (ulong)(num4 + (long)num6 * (long)num2);
					if (num9 > int.MaxValue || num10 > int.MaxValue || num7 < num10 || num7 + num9 > a2 - num3)
					{
						break;
					}
					num5 = (uint)num9;
					num4 = (uint)num10;
					b2 = num7;
				}
				while (b2 > num4);
				if (num3 == 0)
				{
					if (a2 / 2uL >= b2)
					{
						reg1.Mod(ref reg2);
					}
					else
					{
						reg1.Sub(ref sign, ref reg2);
					}
					continue;
				}
				reg1.SetSizeKeep(b, 0);
				reg2.SetSizeKeep(b, 0);
				int num12 = 0;
				int num13 = 0;
				for (int i = 0; i < b; i++)
				{
					uint num14 = reg1._rgu[i];
					uint num15 = reg2._rgu[i];
					long num16 = (long)num14 * (long)num2 - (long)num15 * (long)num3 + num12;
					long num17 = (long)num15 * (long)num5 - (long)num14 * (long)num4 + num13;
					num12 = (int)(num16 >> 32);
					num13 = (int)(num17 >> 32);
					reg1._rgu[i] = (uint)num16;
					reg2._rgu[i] = (uint)num17;
				}
				reg1.Trim();
				reg2.Trim();
			}
			reg1.Set(NumericsHelpers.GCD(reg1.GetHigh2(2), reg2.GetHigh2(2)));
		}

		public int CbitLowZero()
		{
			if (_iuLast == 0)
			{
				if ((_uSmall & (true ? 1u : 0u)) != 0 || _uSmall == 0)
				{
					return 0;
				}
				return NumericsHelpers.CbitLowZero(_uSmall);
			}
			int i;
			for (i = 0; _rgu[i] == 0; i++)
			{
			}
			int num = NumericsHelpers.CbitLowZero(_rgu[i]);
			return num + i * 32;
		}

		public int MakeOdd()
		{
			int num = CbitLowZero();
			if (num > 0)
			{
				ShiftRight(num);
			}
			return num;
		}
	}
	internal static class BigNumber
	{
		internal struct BigNumberBuffer
		{
			public StringBuilder digits;

			public int precision;

			public int scale;

			public bool sign;

			public static BigNumberBuffer Create()
			{
				BigNumberBuffer result = default(BigNumberBuffer);
				result.digits = new StringBuilder();
				return result;
			}
		}

		private const NumberStyles InvalidNumberStyles = ~(NumberStyles.Any | NumberStyles.AllowHexSpecifier);

		internal static bool TryValidateParseStyleInteger(NumberStyles style, out ArgumentException e)
		{
			if (((uint)style & 0xFFFFFC00u) != 0)
			{
				e = new ArgumentException(SR.GetString("Argument_InvalidNumberStyles", "style"));
				return false;
			}
			if ((style & NumberStyles.AllowHexSpecifier) != 0 && ((uint)style & 0xFFFFFDFCu) != 0)
			{
				e = new ArgumentException(SR.GetString("Argument_InvalidHexStyle"));
				return false;
			}
			e = null;
			return true;
		}

		[SecuritySafeCritical]
		internal unsafe static bool TryParseBigInteger(string value, NumberStyles style, NumberFormatInfo info, out BigInteger result)
		{
			result = BigInteger.Zero;
			if (!TryValidateParseStyleInteger(style, out var e))
			{
				throw e;
			}
			BigNumberBuffer number = BigNumberBuffer.Create();
			byte* stackBuffer = stackalloc byte[(int)(uint)Number.NumberBuffer.NumberBufferBytes];
			Number.NumberBuffer number2 = new Number.NumberBuffer(stackBuffer);
			result = 0;
			if (!Number.TryStringToNumber(value, style, ref number2, number.digits, info, parseDecimal: false))
			{
				return false;
			}
			number.precision = number2.precision;
			number.scale = number2.scale;
			number.sign = number2.sign;
			if ((style & NumberStyles.AllowHexSpecifier) != 0)
			{
				if (!HexNumberToBigInteger(ref number, ref result))
				{
					return false;
				}
			}
			else if (!NumberToBigInteger(ref number, ref result))
			{
				return false;
			}
			return true;
		}

		internal static BigInteger ParseBigInteger(string value, NumberStyles style, NumberFormatInfo info)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (!TryValidateParseStyleInteger(style, out var e))
			{
				throw e;
			}
			BigInteger result = BigInteger.Zero;
			if (!TryParseBigInteger(value, style, info, out result))
			{
				throw new FormatException(SR.GetString("Overflow_ParseBigInteger"));
			}
			return result;
		}

		private static bool HexNumberToBigInteger(ref BigNumberBuffer number, ref BigInteger value)
		{
			if (number.digits == null || number.digits.Length == 0)
			{
				return false;
			}
			int num = number.digits.Length - 1;
			byte[] array = new byte[num / 2 + num % 2];
			bool flag = false;
			bool flag2 = false;
			int num2 = 0;
			for (int num3 = num - 1; num3 > -1; num3--)
			{
				char c = number.digits[num3];
				byte b = ((c >= '0' && c <= '9') ? ((byte)(c - 48)) : ((c < 'A' || c > 'F') ? ((byte)(c - 97 + 10)) : ((byte)(c - 65 + 10))));
				if (num3 == 0 && (b & 8) == 8)
				{
					flag2 = true;
				}
				if (flag)
				{
					array[num2] = (byte)(array[num2] | (b << 4));
					num2++;
				}
				else
				{
					array[num2] = (flag2 ? ((byte)(b | 0xF0u)) : b);
				}
				flag = !flag;
			}
			value = new BigInteger(array);
			return true;
		}

		private static bool NumberToBigInteger(ref BigNumberBuffer number, ref BigInteger value)
		{
			int num = number.scale;
			int index = 0;
			value = 0;
			while (--num >= 0)
			{
				value *= (BigInteger)10;
				if (number.digits[index] != 0)
				{
					value += (BigInteger)(number.digits[index++] - 48);
				}
			}
			while (number.digits[index] != 0)
			{
				if (number.digits[index++] != '0')
				{
					return false;
				}
			}
			if (number.sign)
			{
				value = -value;
			}
			return true;
		}

		internal static char ParseFormatSpecifier(string format, out int digits)
		{
			digits = -1;
			if (string.IsNullOrEmpty(format))
			{
				return 'R';
			}
			int num = 0;
			char c = format[num];
			if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
			{
				num++;
				int num2 = -1;
				if (num < format.Length && format[num] >= '0' && format[num] <= '9')
				{
					num2 = format[num++] - 48;
					while (num < format.Length && format[num] >= '0' && format[num] <= '9')
					{
						num2 = num2 * 10 + (format[num++] - 48);
						if (num2 >= 10)
						{
							break;
						}
					}
				}
				if (num >= format.Length || format[num] == '\0')
				{
					digits = num2;
					return c;
				}
			}
			return '\0';
		}

		private static string FormatBigIntegerToHexString(BigInteger value, char format, int digits, NumberFormatInfo info)
		{
			StringBuilder stringBuilder = new StringBuilder();
			byte[] array = value.ToByteArray();
			string text = null;
			int num = array.Length - 1;
			if (num > -1)
			{
				bool flag = false;
				byte b = array[num];
				if (b > 247)
				{
					b = (byte)(b - 240);
					flag = true;
				}
				if (b < 8 || flag)
				{
					text = string.Format(CultureInfo.InvariantCulture, "{0}1", new object[1] { format });
					stringBuilder.Append(b.ToString(text, info));
					num--;
				}
			}
			if (num > -1)
			{
				text = string.Format(CultureInfo.InvariantCulture, "{0}2", new object[1] { format });
				while (num > -1)
				{
					stringBuilder.Append(array[num--].ToString(text, info));
				}
			}
			if (digits > 0 && digits > stringBuilder.Length)
			{
				stringBuilder.Insert(0, (value._sign >= 0) ? "0" : ((format == 'x') ? "f" : "F"), digits - stringBuilder.Length);
			}
			return stringBuilder.ToString();
		}

		[SecuritySafeCritical]
		internal unsafe static string FormatBigInteger(BigInteger value, string format, NumberFormatInfo info)
		{
			int digits = 0;
			char c = ParseFormatSpecifier(format, out digits);
			int num;
			switch (c)
			{
			case 'X':
			case 'x':
				return FormatBigIntegerToHexString(value, c, digits, info);
			default:
				num = ((c == 'R') ? 1 : 0);
				break;
			case 'D':
			case 'G':
			case 'd':
			case 'g':
			case 'r':
				num = 1;
				break;
			}
			bool flag = (byte)num != 0;
			if (value._bits == null)
			{
				if (c == 'g' || c == 'G' || c == 'r' || c == 'R')
				{
					format = ((digits <= 0) ? "D" : string.Format(CultureInfo.InvariantCulture, "D{0}", new object[1] { digits.ToString(CultureInfo.InvariantCulture) }));
				}
				return value._sign.ToString(format, info);
			}
			int num2 = BigInteger.Length(value._bits);
			uint[] array;
			int num4;
			int num5;
			checked
			{
				int num3;
				try
				{
					num3 = unchecked(checked(num2 * 10) / 9) + 2;
				}
				catch (OverflowException innerException)
				{
					throw new FormatException(SR.GetString("Format_TooLarge"), innerException);
				}
				array = new uint[num3];
				num4 = 0;
				num5 = num2;
			}
			while (--num5 >= 0)
			{
				uint num6 = value._bits[num5];
				for (int i = 0; i < num4; i++)
				{
					ulong num7 = NumericsHelpers.MakeUlong(array[i], num6);
					array[i] = (uint)(num7 % 1000000000uL);
					num6 = (uint)(num7 / 1000000000uL);
				}
				if (num6 != 0)
				{
					array[num4++] = num6 % 1000000000u;
					num6 /= 1000000000u;
					if (num6 != 0)
					{
						array[num4++] = num6;
					}
				}
			}
			int num8;
			char[] array2;
			int num10;
			checked
			{
				try
				{
					num8 = num4 * 9;
				}
				catch (OverflowException innerException2)
				{
					throw new FormatException(SR.GetString("Format_TooLarge"), innerException2);
				}
				if (flag)
				{
					if (digits > 0 && digits > num8)
					{
						num8 = digits;
					}
					if (value._sign < 0)
					{
						try
						{
							num8 += info.NegativeSign.Length;
						}
						catch (OverflowException innerException3)
						{
							throw new FormatException(SR.GetString("Format_TooLarge"), innerException3);
						}
					}
				}
				int num9;
				try
				{
					num9 = num8 + 1;
				}
				catch (OverflowException innerException4)
				{
					throw new FormatException(SR.GetString("Format_TooLarge"), innerException4);
				}
				array2 = new char[num9];
				num10 = num8;
			}
			for (int j = 0; j < num4 - 1; j++)
			{
				uint num11 = array[j];
				int num12 = 9;
				while (--num12 >= 0)
				{
					array2[--num10] = (char)(48 + num11 % 10u);
					num11 /= 10u;
				}
			}
			for (uint num13 = array[num4 - 1]; num13 != 0; num13 /= 10u)
			{
				array2[--num10] = (char)(48 + num13 % 10u);
			}
			if (!flag)
			{
				byte* stackBuffer = stackalloc byte[(int)(uint)Number.NumberBuffer.NumberBufferBytes];
				Number.NumberBuffer numberBuffer = new Number.NumberBuffer(stackBuffer);
				numberBuffer.sign = value._sign < 0;
				numberBuffer.precision = 29;
				*numberBuffer.digits = '\0';
				numberBuffer.scale = num8 - num10;
				int num14 = Math.Min(num10 + 50, num8);
				for (int k = num10; k < num14; k++)
				{
					numberBuffer.digits[k - num10] = array2[k];
				}
				fixed (char* ptr = array2)
				{
					return Number.FormatNumberBuffer(numberBuffer.PackForNative(), format, info, ptr + num10);
				}
			}
			int num15 = num8 - num10;
			while (digits > 0 && digits > num15)
			{
				array2[--num10] = '0';
				digits--;
			}
			if (value._sign < 0)
			{
				string negativeSign = info.NegativeSign;
				for (int num16 = info.NegativeSign.Length - 1; num16 > -1; num16--)
				{
					array2[--num10] = info.NegativeSign[num16];
				}
			}
			return new string(array2, num10, num8 - num10);
		}
	}
	[StructLayout(LayoutKind.Explicit)]
	internal struct DoubleUlong
	{
		[FieldOffset(0)]
		public double dbl;

		[FieldOffset(0)]
		public ulong uu;
	}
	internal static class NumericsHelpers
	{
		private const int kcbitUint = 32;

		public static void GetDoubleParts(double dbl, out int sign, out int exp, out ulong man, out bool fFinite)
		{
			DoubleUlong doubleUlong = default(DoubleUlong);
			doubleUlong.uu = 0uL;
			doubleUlong.dbl = dbl;
			sign = 1 - ((int)(doubleUlong.uu >> 62) & 2);
			man = doubleUlong.uu & 0xFFFFFFFFFFFFFuL;
			exp = (int)(doubleUlong.uu >> 52) & 0x7FF;
			if (exp == 0)
			{
				fFinite = true;
				if (man != 0L)
				{
					exp = -1074;
				}
			}
			else if (exp == 2047)
			{
				fFinite = false;
				exp = int.MaxValue;
			}
			else
			{
				fFinite = true;
				man |= 4503599627370496uL;
				exp -= 1075;
			}
		}

		public static double GetDoubleFromParts(int sign, int exp, ulong man)
		{
			DoubleUlong doubleUlong = default(DoubleUlong);
			doubleUlong.dbl = 0.0;
			if (man == 0L)
			{
				doubleUlong.uu = 0uL;
			}
			else
			{
				int num = CbitHighZero(man) - 11;
				man = ((num >= 0) ? (man << num) : (man >> -num));
				exp -= num;
				exp += 1075;
				if (exp >= 2047)
				{
					doubleUlong.uu = 9218868437227405312uL;
				}
				else if (exp <= 0)
				{
					exp--;
					if (exp < -52)
					{
						doubleUlong.uu = 0uL;
					}
					else
					{
						doubleUlong.uu = man >> -exp;
					}
				}
				else
				{
					doubleUlong.uu = (man & 0xFFFFFFFFFFFFFuL) | (ulong)((long)exp << 52);
				}
			}
			if (sign < 0)
			{
				doubleUlong.uu |= 9223372036854775808uL;
			}
			return doubleUlong.dbl;
		}

		public static uint[] DangerousMakeTwosComplement(uint[] d)
		{
			int i = 0;
			uint num = 0u;
			for (; i < d.Length; i++)
			{
				num = (d[i] = ~d[i] + 1);
				if (num != 0)
				{
					i++;
					break;
				}
			}
			if (num != 0)
			{
				for (; i < d.Length; i++)
				{
					d[i] = ~d[i];
				}
			}
			else
			{
				d = resize(d, d.Length + 1);
				d[d.Length - 1] = 1u;
			}
			return d;
		}

		public static uint[] resize(uint[] v, int len)
		{
			if (v.Length == len)
			{
				return v;
			}
			uint[] array = new uint[len];
			int num = Math.Min(v.Length, len);
			for (int i = 0; i < num; i++)
			{
				array[i] = v[i];
			}
			return array;
		}

		public static void Swap<T>(ref T a, ref T b)
		{
			T val = a;
			a = b;
			b = val;
		}

		public static uint GCD(uint u1, uint u2)
		{
			if (u1 >= u2)
			{
				goto IL_0004;
			}
			goto IL_0021;
			IL_0021:
			if (u1 == 0)
			{
				return u2;
			}
			int num = 32;
			while (true)
			{
				u2 -= u1;
				if (u2 < u1)
				{
					break;
				}
				if (--num == 0)
				{
					u2 %= u1;
					break;
				}
			}
			goto IL_0004;
			IL_0004:
			if (u2 == 0)
			{
				return u1;
			}
			int num2 = 32;
			while (true)
			{
				u1 -= u2;
				if (u1 < u2)
				{
					break;
				}
				if (--num2 == 0)
				{
					u1 %= u2;
					break;
				}
			}
			goto IL_0021;
		}

		public static ulong GCD(ulong uu1, ulong uu2)
		{
			if (uu1 >= uu2)
			{
				goto IL_0004;
			}
			goto IL_0026;
			IL_0026:
			if (uu2 > uint.MaxValue)
			{
				if (uu1 == 0L)
				{
					return uu2;
				}
				int num = 32;
				while (true)
				{
					uu2 -= uu1;
					if (uu2 < uu1)
					{
						break;
					}
					if (--num == 0)
					{
						uu2 %= uu1;
						break;
					}
				}
				goto IL_0004;
			}
			goto IL_004a;
			IL_004a:
			uint num2 = (uint)uu1;
			uint num3 = (uint)uu2;
			if (num2 >= num3)
			{
				goto IL_0054;
			}
			goto IL_0073;
			IL_0073:
			if (num2 == 0)
			{
				return num3;
			}
			int num4 = 32;
			while (true)
			{
				num3 -= num2;
				if (num3 < num2)
				{
					break;
				}
				if (--num4 == 0)
				{
					num3 %= num2;
					break;
				}
			}
			goto IL_0054;
			IL_0004:
			if (uu1 > uint.MaxValue)
			{
				if (uu2 == 0L)
				{
					return uu1;
				}
				int num5 = 32;
				while (true)
				{
					uu1 -= uu2;
					if (uu1 < uu2)
					{
						break;
					}
					if (--num5 == 0)
					{
						uu1 %= uu2;
						break;
					}
				}
				goto IL_0026;
			}
			goto IL_004a;
			IL_0054:
			if (num3 == 0)
			{
				return num2;
			}
			int num6 = 32;
			while (true)
			{
				num2 -= num3;
				if (num2 < num3)
				{
					break;
				}
				if (--num6 == 0)
				{
					num2 %= num3;
					break;
				}
			}
			goto IL_0073;
		}

		public static ulong MakeUlong(uint uHi, uint uLo)
		{
			return ((ulong)uHi << 32) | uLo;
		}

		public static uint GetLo(ulong uu)
		{
			return (uint)uu;
		}

		public static uint GetHi(ulong uu)
		{
			return (uint)(uu >> 32);
		}

		public static uint Abs(int a)
		{
			uint num = (uint)(a >> 31);
			return ((uint)a ^ num) - num;
		}

		public static uint CombineHash(uint u1, uint u2)
		{
			return ((u1 << 7) | (u1 >> 25)) ^ u2;
		}

		public static int CombineHash(int n1, int n2)
		{
			return (int)CombineHash((uint)n1, (uint)n2);
		}

		public static int CbitHighZero(uint u)
		{
			if (u == 0)
			{
				return 32;
			}
			int num = 0;
			if ((u & 0xFFFF0000u) == 0)
			{
				num += 16;
				u <<= 16;
			}
			if ((u & 0xFF000000u) == 0)
			{
				num += 8;
				u <<= 8;
			}
			if ((u & 0xF0000000u) == 0)
			{
				num += 4;
				u <<= 4;
			}
			if ((u & 0xC0000000u) == 0)
			{
				num += 2;
				u <<= 2;
			}
			if ((u & 0x80000000u) == 0)
			{
				num++;
			}
			return num;
		}

		public static int CbitLowZero(uint u)
		{
			if (u == 0)
			{
				return 32;
			}
			int num = 0;
			if ((u & 0xFFFF) == 0)
			{
				num += 16;
				u >>= 16;
			}
			if ((u & 0xFF) == 0)
			{
				num += 8;
				u >>= 8;
			}
			if ((u & 0xF) == 0)
			{
				num += 4;
				u >>= 4;
			}
			if ((u & 3) == 0)
			{
				num += 2;
				u >>= 2;
			}
			if ((u & 1) == 0)
			{
				num++;
			}
			return num;
		}

		public static int CbitHighZero(ulong uu)
		{
			if ((uu & 0xFFFFFFFF00000000uL) == 0L)
			{
				return 32 + CbitHighZero((uint)uu);
			}
			return CbitHighZero((uint)(uu >> 32));
		}
	}
	/// <summary>Represents a complex number.</summary>
	[Serializable]
	[__DynamicallyInvokable]
	public struct Complex : IEquatable<Complex>, IFormattable
	{
		private double m_real;

		private double m_imaginary;

		private const double LOG_10_INV = 0.43429448190325;

		/// <summary>Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</summary>
		[__DynamicallyInvokable]
		public static readonly Complex Zero = new Complex(0.0, 0.0);

		/// <summary>Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</summary>
		[__DynamicallyInvokable]
		public static readonly Complex One = new Complex(1.0, 0.0);

		/// <summary>Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</summary>
		[__DynamicallyInvokable]
		public static readonly Complex ImaginaryOne = new Complex(0.0, 1.0);

		/// <summary>Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</summary>
		/// <returns>The real component of a complex number.</returns>
		[__DynamicallyInvokable]
		public double Real
		{
			[__DynamicallyInvokable]
			get
			{
				return m_real;
			}
		}

		/// <summary>Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</summary>
		/// <returns>The imaginary component of a complex number.</returns>
		[__DynamicallyInvokable]
		public double Imaginary
		{
			[__DynamicallyInvokable]
			get
			{
				return m_imaginary;
			}
		}

		/// <summary>Gets the magnitude (or absolute value) of a complex number.</summary>
		/// <returns>The magnitude of the current instance.</returns>
		[__DynamicallyInvokable]
		public double Magnitude
		{
			[__DynamicallyInvokable]
			get
			{
				return Abs(this);
			}
		}

		/// <summary>Gets the phase of a complex number.</summary>
		/// <returns>The phase of a complex number, in radians.</returns>
		[__DynamicallyInvokable]
		public double Phase
		{
			[__DynamicallyInvokable]
			get
			{
				return Math.Atan2(m_imaginary, m_real);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</summary>
		/// <param name="real">The real part of the complex number.</param>
		/// <param name="imaginary">The imaginary part of the complex number.</param>
		[__DynamicallyInvokable]
		public Complex(double real, double imaginary)
		{
			m_real = real;
			m_imaginary = imaginary;
		}

		/// <summary>Creates a complex number from a point's polar coordinates.</summary>
		/// <param name="magnitude">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</param>
		/// <param name="phase">The phase, which is the angle from the line to the horizontal axis, measured in radians.</param>
		/// <returns>A complex number.</returns>
		[__DynamicallyInvokable]
		public static Complex FromPolarCoordinates(double magnitude, double phase)
		{
			return new Complex(magnitude * Math.Cos(phase), magnitude * Math.Sin(phase));
		}

		/// <summary>Returns the additive inverse of a specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</returns>
		[__DynamicallyInvokable]
		public static Complex Negate(Complex value)
		{
			return -value;
		}

		/// <summary>Adds two complex numbers and returns the result.</summary>
		/// <param name="left">The first complex number to add.</param>
		/// <param name="right">The second complex number to add.</param>
		/// <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Add(Complex left, Complex right)
		{
			return left + right;
		}

		/// <summary>Subtracts one complex number from another and returns the result.</summary>
		/// <param name="left">The value to subtract from (the minuend).</param>
		/// <param name="right">The value to subtract (the subtrahend).</param>
		/// <returns>The result of subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Subtract(Complex left, Complex right)
		{
			return left - right;
		}

		/// <summary>Returns the product of two complex numbers.</summary>
		/// <param name="left">The first complex number to multiply.</param>
		/// <param name="right">The second complex number to multiply.</param>
		/// <returns>The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</returns>
		[__DynamicallyInvokable]
		public static Complex Multiply(Complex left, Complex right)
		{
			return left * right;
		}

		/// <summary>Divides one complex number by another and returns the result.</summary>
		/// <param name="dividend">The complex number to be divided.</param>
		/// <param name="divisor">The complex number to divide by.</param>
		/// <returns>The quotient of the division.</returns>
		[__DynamicallyInvokable]
		public static Complex Divide(Complex dividend, Complex divisor)
		{
			return dividend / divisor;
		}

		/// <summary>Returns the additive inverse of a specified complex number.</summary>
		/// <param name="value">The value to negate.</param>
		/// <returns>The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</returns>
		[__DynamicallyInvokable]
		public static Complex operator -(Complex value)
		{
			return new Complex(0.0 - value.m_real, 0.0 - value.m_imaginary);
		}

		/// <summary>Adds two complex numbers.</summary>
		/// <param name="left">The first value to add.</param>
		/// <param name="right">The second value to add.</param>
		/// <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
		[__DynamicallyInvokable]
		public static Complex operator +(Complex left, Complex right)
		{
			return new Complex(left.m_real + right.m_real, left.m_imaginary + right.m_imaginary);
		}

		/// <summary>Subtracts a complex number from another complex number.</summary>
		/// <param name="left">The value to subtract from (the minuend).</param>
		/// <param name="right">The value to subtract (the subtrahend).</param>
		/// <returns>The result of subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
		[__DynamicallyInvokable]
		public static Complex operator -(Complex left, Complex right)
		{
			return new Complex(left.m_real - right.m_real, left.m_imaginary - right.m_imaginary);
		}

		/// <summary>Multiplies two specified complex numbers.</summary>
		/// <param name="left">The first value to multiply.</param>
		/// <param name="right">The second value to multiply.</param>
		/// <returns>The product of <paramref name="left" /> and <paramref name="right" />.</returns>
		[__DynamicallyInvokable]
		public static Complex operator *(Complex left, Complex right)
		{
			double real = left.m_real * right.m_real - left.m_imaginary * right.m_imaginary;
			double imaginary = left.m_imaginary * right.m_real + left.m_real * right.m_imaginary;
			return new Complex(real, imaginary);
		}

		/// <summary>Divides a specified complex number by another specified complex number.</summary>
		/// <param name="left">The value to be divided.</param>
		/// <param name="right">The value to divide by.</param>
		/// <returns>The result of dividing <paramref name="left" /> by <paramref name="right" />.</returns>
		[__DynamicallyInvokable]
		public static Complex operator /(Complex left, Complex right)
		{
			double real = left.m_real;
			double imaginary = left.m_imaginary;
			double real2 = right.m_real;
			double imaginary2 = right.m_imaginary;
			if (Math.Abs(imaginary2) < Math.Abs(real2))
			{
				double num = imaginary2 / real2;
				return new Complex((real + imaginary * num) / (real2 + imaginary2 * num), (imaginary - real * num) / (real2 + imaginary2 * num));
			}
			double num2 = real2 / imaginary2;
			return new Complex((imaginary + real * num2) / (imaginary2 + real2 * num2), (0.0 - real + imaginary * num2) / (imaginary2 + real2 * num2));
		}

		/// <summary>Gets the absolute value (or magnitude) of a complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The absolute value of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static double Abs(Complex value)
		{
			if (double.IsInfinity(value.m_real) || double.IsInfinity(value.m_imaginary))
			{
				return double.PositiveInfinity;
			}
			double num = Math.Abs(value.m_real);
			double num2 = Math.Abs(value.m_imaginary);
			if (num > num2)
			{
				double num3 = num2 / num;
				return num * Math.Sqrt(1.0 + num3 * num3);
			}
			if (num2 == 0.0)
			{
				return num;
			}
			double num4 = num / num2;
			return num2 * Math.Sqrt(1.0 + num4 * num4);
		}

		/// <summary>Computes the conjugate of a complex number and returns the result.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The conjugate of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Conjugate(Complex value)
		{
			return new Complex(value.m_real, 0.0 - value.m_imaginary);
		}

		/// <summary>Returns the multiplicative inverse of a complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The reciprocal of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Reciprocal(Complex value)
		{
			if (value.m_real == 0.0 && value.m_imaginary == 0.0)
			{
				return Zero;
			}
			return One / value;
		}

		/// <summary>Returns a value that indicates whether two complex numbers are equal.</summary>
		/// <param name="left">The first complex number to compare.</param>
		/// <param name="right">The second complex number to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator ==(Complex left, Complex right)
		{
			if (left.m_real == right.m_real)
			{
				return left.m_imaginary == right.m_imaginary;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether two complex numbers are not equal.</summary>
		/// <param name="left">The first value to compare.</param>
		/// <param name="right">The second value to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator !=(Complex left, Complex right)
		{
			if (left.m_real == right.m_real)
			{
				return left.m_imaginary != right.m_imaginary;
			}
			return true;
		}

		/// <summary>Returns a value that indicates whether the current instance and a specified object have the same value.</summary>
		/// <param name="obj">The object to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public override bool Equals(object obj)
		{
			if (!(obj is Complex))
			{
				return false;
			}
			return this == (Complex)obj;
		}

		/// <summary>Returns a value that indicates whether the current instance and a specified complex number have the same value.</summary>
		/// <param name="value">The complex number to compare.</param>
		/// <returns>
		///   <see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool Equals(Complex value)
		{
			if (m_real.Equals(value.m_real))
			{
				return m_imaginary.Equals(value.m_imaginary);
			}
			return false;
		}

		/// <summary>Defines an implicit conversion of a 16-bit signed integer to a complex number.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
		[__DynamicallyInvokable]
		public static implicit operator Complex(short value)
		{
			return new Complex(value, 0.0);
		}

		/// <summary>Defines an implicit conversion of a 32-bit signed integer to a complex number.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
		[__DynamicallyInvokable]
		public static implicit operator Complex(int value)
		{
			return new Complex(value, 0.0);
		}

		/// <summary>Defines an implicit conversion of a 64-bit signed integer to a complex number.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
		[__DynamicallyInvokable]
		public static implicit operator Complex(long value)
		{
			return new Complex(value, 0.0);
		}

		/// <summary>Defines an implicit conversion of a 16-bit unsigned integer to a complex number.   
		/// This API is not CLS-compliant.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static implicit operator Complex(ushort value)
		{
			return new Complex((int)value, 0.0);
		}

		/// <summary>Defines an implicit conversion of a 32-bit unsigned integer to a complex number.   
		/// This API is not CLS-compliant.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static implicit operator Complex(uint value)
		{
			return new Complex(value, 0.0);
		}

		/// <summary>Defines an implicit conversion of a 64-bit unsigned integer to a complex number.   
		/// This API is not CLS-compliant.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static implicit operator Complex(ulong value)
		{
			return new Complex(value, 0.0);
		}

		/// <summary>Defines an implicit conversion of a signed byte to a complex number.   
		/// This API is not CLS-compliant.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
		[CLSCompliant(false)]
		[__DynamicallyInvokable]
		public static implicit operator Complex(sbyte value)
		{
			return new Complex(value, 0.0);
		}

		/// <summary>Defines an implicit conversion of an unsigned byte to a complex number.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
		[__DynamicallyInvokable]
		public static implicit operator Complex(byte value)
		{
			return new Complex((int)value, 0.0);
		}

		/// <summary>Defines an implicit conversion of a single-precision floating-point number to a complex number.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
		[__DynamicallyInvokable]
		public static implicit operator Complex(float value)
		{
			return new Complex(value, 0.0);
		}

		/// <summary>Defines an implicit conversion of a double-precision floating-point number to a complex number.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
		[__DynamicallyInvokable]
		public static implicit operator Complex(double value)
		{
			return new Complex(value, 0.0);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</returns>
		[__DynamicallyInvokable]
		public static explicit operator Complex(BigInteger value)
		{
			return new Complex((double)value, 0.0);
		}

		/// <summary>Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</summary>
		/// <param name="value">The value to convert to a complex number.</param>
		/// <returns>A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</returns>
		[__DynamicallyInvokable]
		public static explicit operator Complex(decimal value)
		{
			return new Complex((double)value, 0.0);
		}

		/// <summary>Converts the value of the current complex number to its equivalent string representation in Cartesian form.</summary>
		/// <returns>The string representation of the current instance in Cartesian form.</returns>
		[__DynamicallyInvokable]
		public override string ToString()
		{
			return string.Format(CultureInfo.CurrentCulture, "({0}, {1})", new object[2] { m_real, m_imaginary });
		}

		/// <summary>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</summary>
		/// <param name="format">A standard or custom numeric format string.</param>
		/// <returns>The string representation of the current instance in Cartesian form.</returns>
		/// <exception cref="T:System.FormatException">
		///   <paramref name="format" /> is not a valid format string.</exception>
		[__DynamicallyInvokable]
		public string ToString(string format)
		{
			return string.Format(CultureInfo.CurrentCulture, "({0}, {1})", new object[2]
			{
				m_real.ToString(format, CultureInfo.CurrentCulture),
				m_imaginary.ToString(format, CultureInfo.CurrentCulture)
			});
		}

		/// <summary>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</summary>
		/// <param name="provider">An object that supplies culture-specific formatting information.</param>
		/// <returns>The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</returns>
		[__DynamicallyInvokable]
		public string ToString(IFormatProvider provider)
		{
			return string.Format(provider, "({0}, {1})", new object[2] { m_real, m_imaginary });
		}

		/// <summary>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</summary>
		/// <param name="format">A standard or custom numeric format string.</param>
		/// <param name="provider">An object that supplies culture-specific formatting information.</param>
		/// <returns>The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</returns>
		/// <exception cref="T:System.FormatException">
		///   <paramref name="format" /> is not a valid format string.</exception>
		[__DynamicallyInvokable]
		public string ToString(string format, IFormatProvider provider)
		{
			return string.Format(provider, "({0}, {1})", new object[2]
			{
				m_real.ToString(format, provider),
				m_imaginary.ToString(format, provider)
			});
		}

		/// <summary>Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</summary>
		/// <returns>A 32-bit signed integer hash code.</returns>
		[__DynamicallyInvokable]
		public override int GetHashCode()
		{
			int num = 99999997;
			int num2 = m_real.GetHashCode() % num;
			int hashCode = m_imaginary.GetHashCode();
			return num2 ^ hashCode;
		}

		/// <summary>Returns the sine of the specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The sine of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Sin(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Sin(real) * Math.Cosh(imaginary), Math.Cos(real) * Math.Sinh(imaginary));
		}

		/// <summary>Returns the hyperbolic sine of the specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The hyperbolic sine of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Sinh(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Sinh(real) * Math.Cos(imaginary), Math.Cosh(real) * Math.Sin(imaginary));
		}

		/// <summary>Returns the angle that is the arc sine of the specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The angle which is the arc sine of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Asin(Complex value)
		{
			return -ImaginaryOne * Log(ImaginaryOne * value + Sqrt(One - value * value));
		}

		/// <summary>Returns the cosine of the specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The cosine of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Cos(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Cos(real) * Math.Cosh(imaginary), 0.0 - Math.Sin(real) * Math.Sinh(imaginary));
		}

		/// <summary>Returns the hyperbolic cosine of the specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The hyperbolic cosine of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Cosh(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Cosh(real) * Math.Cos(imaginary), Math.Sinh(real) * Math.Sin(imaginary));
		}

		/// <summary>Returns the angle that is the arc cosine of the specified complex number.</summary>
		/// <param name="value">A complex number that represents a cosine.</param>
		/// <returns>The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Acos(Complex value)
		{
			return -ImaginaryOne * Log(value + ImaginaryOne * Sqrt(One - value * value));
		}

		/// <summary>Returns the tangent of the specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The tangent of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Tan(Complex value)
		{
			return Sin(value) / Cos(value);
		}

		/// <summary>Returns the hyperbolic tangent of the specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The hyperbolic tangent of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Tanh(Complex value)
		{
			return Sinh(value) / Cosh(value);
		}

		/// <summary>Returns the angle that is the arc tangent of the specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The angle that is the arc tangent of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Atan(Complex value)
		{
			Complex complex = new Complex(2.0, 0.0);
			return ImaginaryOne / complex * (Log(One - ImaginaryOne * value) - Log(One + ImaginaryOne * value));
		}

		/// <summary>Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Log(Complex value)
		{
			return new Complex(Math.Log(Abs(value)), Math.Atan2(value.m_imaginary, value.m_real));
		}

		/// <summary>Returns the logarithm of a specified complex number in a specified base.</summary>
		/// <param name="value">A complex number.</param>
		/// <param name="baseValue">The base of the logarithm.</param>
		/// <returns>The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Log(Complex value, double baseValue)
		{
			return Log(value) / Log(baseValue);
		}

		/// <summary>Returns the base-10 logarithm of a specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The base-10 logarithm of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Log10(Complex value)
		{
			Complex value2 = Log(value);
			return Scale(value2, 0.43429448190325);
		}

		/// <summary>Returns <see langword="e" /> raised to the power specified by a complex number.</summary>
		/// <param name="value">A complex number that specifies a power.</param>
		/// <returns>The number <see langword="e" /> raised to the power <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Exp(Complex value)
		{
			double num = Math.Exp(value.m_real);
			double real = num * Math.Cos(value.m_imaginary);
			double imaginary = num * Math.Sin(value.m_imaginary);
			return new Complex(real, imaginary);
		}

		/// <summary>Returns the square root of a specified complex number.</summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The square root of <paramref name="value" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Sqrt(Complex value)
		{
			return FromPolarCoordinates(Math.Sqrt(value.Magnitude), value.Phase / 2.0);
		}

		/// <summary>Returns a specified complex number raised to a power specified by a complex number.</summary>
		/// <param name="value">A complex number to be raised to a power.</param>
		/// <param name="power">A complex number that specifies a power.</param>
		/// <returns>The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Pow(Complex value, Complex power)
		{
			if (power == Zero)
			{
				return One;
			}
			if (value == Zero)
			{
				return Zero;
			}
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			double real2 = power.m_real;
			double imaginary2 = power.m_imaginary;
			double num = Abs(value);
			double num2 = Math.Atan2(imaginary, real);
			double num3 = real2 * num2 + imaginary2 * Math.Log(num);
			double num4 = Math.Pow(num, real2) * Math.Pow(Math.E, (0.0 - imaginary2) * num2);
			return new Complex(num4 * Math.Cos(num3), num4 * Math.Sin(num3));
		}

		/// <summary>Returns a specified complex number raised to a power specified by a double-precision floating-point number.</summary>
		/// <param name="value">A complex number to be raised to a power.</param>
		/// <param name="power">A double-precision floating-point number that specifies a power.</param>
		/// <returns>The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</returns>
		[__DynamicallyInvokable]
		public static Complex Pow(Complex value, double power)
		{
			return Pow(value, new Complex(power, 0.0));
		}

		private static Complex Scale(Complex value, double factor)
		{
			double real = factor * value.m_real;
			double imaginary = factor * value.m_imaginary;
			return new Complex(real, imaginary);
		}
	}
	internal static class HashCodeHelper
	{
		internal static int CombineHashCodes(int h1, int h2)
		{
			return ((h1 << 5) + h1) ^ h2;
		}
	}
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property)]
	internal class JitIntrinsicAttribute : Attribute
	{
	}
	/// <summary>Represents a 3x2 matrix.</summary>
	[__DynamicallyInvokable]
	public struct Matrix3x2 : IEquatable<Matrix3x2>
	{
		/// <summary>The first element of the first row.</summary>
		[__DynamicallyInvokable]
		public float M11;

		/// <summary>The second element of the first row.</summary>
		[__DynamicallyInvokable]
		public float M12;

		/// <summary>The first element of the second row.</summary>
		[__DynamicallyInvokable]
		public float M21;

		/// <summary>The second element of the second row.</summary>
		[__DynamicallyInvokable]
		public float M22;

		/// <summary>The first element of the third row.</summary>
		[__DynamicallyInvokable]
		public float M31;

		/// <summary>The second element of the third row.</summary>
		[__DynamicallyInvokable]
		public float M32;

		private static readonly Matrix3x2 _identity = new Matrix3x2(1f, 0f, 0f, 1f, 0f, 0f);

		/// <summary>Gets the multiplicative identity matrix.</summary>
		/// <returns>The multiplicative identify matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 Identity
		{
			[__DynamicallyInvokable]
			get
			{
				return _identity;
			}
		}

		/// <summary>Indicates whether the current matrix is the identity matrix.</summary>
		/// <returns>
		///   <see langword="true" /> if the current matrix is the identity matrix; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool IsIdentity
		{
			[__DynamicallyInvokable]
			get
			{
				if (M11 == 1f && M22 == 1f && M12 == 0f && M21 == 0f && M31 == 0f)
				{
					return M32 == 0f;
				}
				return false;
			}
		}

		/// <summary>Gets or sets the translation component of this matrix.</summary>
		/// <returns>The translation component of the current instance.</returns>
		[__DynamicallyInvokable]
		public Vector2 Translation
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector2(M31, M32);
			}
			[__DynamicallyInvokable]
			set
			{
				M31 = value.X;
				M32 = value.Y;
			}
		}

		/// <summary>Creates a 3x2 matrix from the specified components.</summary>
		/// <param name="m11">The value to assign to the first element in the first row.</param>
		/// <param name="m12">The value to assign to the second element in the first row.</param>
		/// <param name="m21">The value to assign to the first element in the second row.</param>
		/// <param name="m22">The value to assign to the second element in the second row.</param>
		/// <param name="m31">The value to assign to the first element in the third row.</param>
		/// <param name="m32">The value to assign to the second element in the third row.</param>
		[__DynamicallyInvokable]
		public Matrix3x2(float m11, float m12, float m21, float m22, float m31, float m32)
		{
			M11 = m11;
			M12 = m12;
			M21 = m21;
			M22 = m22;
			M31 = m31;
			M32 = m32;
		}

		/// <summary>Creates a translation matrix from the specified 2-dimensional vector.</summary>
		/// <param name="position">The translation position.</param>
		/// <returns>The translation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateTranslation(Vector2 position)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = 1f;
			result.M12 = 0f;
			result.M21 = 0f;
			result.M22 = 1f;
			result.M31 = position.X;
			result.M32 = position.Y;
			return result;
		}

		/// <summary>Creates a translation matrix from the specified X and Y components.</summary>
		/// <param name="xPosition">The X position.</param>
		/// <param name="yPosition">The Y position.</param>
		/// <returns>The translation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateTranslation(float xPosition, float yPosition)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = 1f;
			result.M12 = 0f;
			result.M21 = 0f;
			result.M22 = 1f;
			result.M31 = xPosition;
			result.M32 = yPosition;
			return result;
		}

		/// <summary>Creates a scaling matrix from the specified X and Y components.</summary>
		/// <param name="xScale">The value to scale by on the X axis.</param>
		/// <param name="yScale">The value to scale by on the Y axis.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateScale(float xScale, float yScale)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = xScale;
			result.M12 = 0f;
			result.M21 = 0f;
			result.M22 = yScale;
			result.M31 = 0f;
			result.M32 = 0f;
			return result;
		}

		/// <summary>Creates a scaling matrix that is offset by a given center point.</summary>
		/// <param name="xScale">The value to scale by on the X axis.</param>
		/// <param name="yScale">The value to scale by on the Y axis.</param>
		/// <param name="centerPoint">The center point.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateScale(float xScale, float yScale, Vector2 centerPoint)
		{
			float m = centerPoint.X * (1f - xScale);
			float m2 = centerPoint.Y * (1f - yScale);
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = xScale;
			result.M12 = 0f;
			result.M21 = 0f;
			result.M22 = yScale;
			result.M31 = m;
			result.M32 = m2;
			return result;
		}

		/// <summary>Creates a scaling matrix from the specified vector scale.</summary>
		/// <param name="scales">The scale to use.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateScale(Vector2 scales)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = scales.X;
			result.M12 = 0f;
			result.M21 = 0f;
			result.M22 = scales.Y;
			result.M31 = 0f;
			result.M32 = 0f;
			return result;
		}

		/// <summary>Creates a scaling matrix from the specified vector scale with an offset from the specified center point.</summary>
		/// <param name="scales">The scale to use.</param>
		/// <param name="centerPoint">The center offset.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateScale(Vector2 scales, Vector2 centerPoint)
		{
			float m = centerPoint.X * (1f - scales.X);
			float m2 = centerPoint.Y * (1f - scales.Y);
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = scales.X;
			result.M12 = 0f;
			result.M21 = 0f;
			result.M22 = scales.Y;
			result.M31 = m;
			result.M32 = m2;
			return result;
		}

		/// <summary>Creates a scaling matrix that scales uniformly with the given scale.</summary>
		/// <param name="scale">The uniform scale to use.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateScale(float scale)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = scale;
			result.M12 = 0f;
			result.M21 = 0f;
			result.M22 = scale;
			result.M31 = 0f;
			result.M32 = 0f;
			return result;
		}

		/// <summary>Creates a scaling matrix that scales uniformly with the specified scale with an offset from the specified center.</summary>
		/// <param name="scale">The uniform scale to use.</param>
		/// <param name="centerPoint">The center offset.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateScale(float scale, Vector2 centerPoint)
		{
			float m = centerPoint.X * (1f - scale);
			float m2 = centerPoint.Y * (1f - scale);
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = scale;
			result.M12 = 0f;
			result.M21 = 0f;
			result.M22 = scale;
			result.M31 = m;
			result.M32 = m2;
			return result;
		}

		/// <summary>Creates a skew matrix from the specified angles in radians.</summary>
		/// <param name="radiansX">The X angle, in radians.</param>
		/// <param name="radiansY">The Y angle, in radians.</param>
		/// <returns>The skew matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateSkew(float radiansX, float radiansY)
		{
			float m = (float)Math.Tan(radiansX);
			float m2 = (float)Math.Tan(radiansY);
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = 1f;
			result.M12 = m2;
			result.M21 = m;
			result.M22 = 1f;
			result.M31 = 0f;
			result.M32 = 0f;
			return result;
		}

		/// <summary>Creates a skew matrix from the specified angles in radians and a center point.</summary>
		/// <param name="radiansX">The X angle, in radians.</param>
		/// <param name="radiansY">The Y angle, in radians.</param>
		/// <param name="centerPoint">The center point.</param>
		/// <returns>The skew matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateSkew(float radiansX, float radiansY, Vector2 centerPoint)
		{
			float num = (float)Math.Tan(radiansX);
			float num2 = (float)Math.Tan(radiansY);
			float m = (0f - centerPoint.Y) * num;
			float m2 = (0f - centerPoint.X) * num2;
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = 1f;
			result.M12 = num2;
			result.M21 = num;
			result.M22 = 1f;
			result.M31 = m;
			result.M32 = m2;
			return result;
		}

		/// <summary>Creates a rotation matrix using the given rotation in radians.</summary>
		/// <param name="radians">The amount of rotation, in radians.</param>
		/// <returns>The rotation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateRotation(float radians)
		{
			radians = (float)Math.IEEERemainder(radians, Math.PI * 2.0);
			float num;
			float num2;
			if (radians > -1.74532943E-05f && radians < 1.74532943E-05f)
			{
				num = 1f;
				num2 = 0f;
			}
			else if ((double)radians > 1.57077887350062 && (double)radians < 1.5708137800891731)
			{
				num = 0f;
				num2 = 1f;
			}
			else if ((double)radians < -3.1415752002955166 || (double)radians > 3.1415752002955166)
			{
				num = -1f;
				num2 = 0f;
			}
			else if ((double)radians > -1.5708137800891731 && (double)radians < -1.57077887350062)
			{
				num = 0f;
				num2 = -1f;
			}
			else
			{
				num = (float)Math.Cos(radians);
				num2 = (float)Math.Sin(radians);
			}
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = num;
			result.M12 = num2;
			result.M21 = 0f - num2;
			result.M22 = num;
			result.M31 = 0f;
			result.M32 = 0f;
			return result;
		}

		/// <summary>Creates a rotation matrix using the specified rotation in radians and a center point.</summary>
		/// <param name="radians">The amount of rotation, in radians.</param>
		/// <param name="centerPoint">The center point.</param>
		/// <returns>The rotation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 CreateRotation(float radians, Vector2 centerPoint)
		{
			radians = (float)Math.IEEERemainder(radians, Math.PI * 2.0);
			float num;
			float num2;
			if (radians > -1.74532943E-05f && radians < 1.74532943E-05f)
			{
				num = 1f;
				num2 = 0f;
			}
			else if ((double)radians > 1.57077887350062 && (double)radians < 1.5708137800891731)
			{
				num = 0f;
				num2 = 1f;
			}
			else if ((double)radians < -3.1415752002955166 || (double)radians > 3.1415752002955166)
			{
				num = -1f;
				num2 = 0f;
			}
			else if ((double)radians > -1.5708137800891731 && (double)radians < -1.57077887350062)
			{
				num = 0f;
				num2 = -1f;
			}
			else
			{
				num = (float)Math.Cos(radians);
				num2 = (float)Math.Sin(radians);
			}
			float m = centerPoint.X * (1f - num) + centerPoint.Y * num2;
			float m2 = centerPoint.Y * (1f - num) - centerPoint.X * num2;
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = num;
			result.M12 = num2;
			result.M21 = 0f - num2;
			result.M22 = num;
			result.M31 = m;
			result.M32 = m2;
			return result;
		}

		/// <summary>Calculates the determinant for this matrix.</summary>
		/// <returns>The determinant.</returns>
		[__DynamicallyInvokable]
		public float GetDeterminant()
		{
			return M11 * M22 - M21 * M12;
		}

		/// <summary>Inverts the specified matrix. The return value indicates whether the operation succeeded.</summary>
		/// <param name="matrix">The matrix to invert.</param>
		/// <param name="result">When this method returns, contains the inverted matrix if the operation succeeded.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="matrix" /> was converted successfully; otherwise,  <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool Invert(Matrix3x2 matrix, out Matrix3x2 result)
		{
			float num = matrix.M11 * matrix.M22 - matrix.M21 * matrix.M12;
			if (Math.Abs(num) < float.Epsilon)
			{
				result = new Matrix3x2(float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN);
				return false;
			}
			float num2 = 1f / num;
			result.M11 = matrix.M22 * num2;
			result.M12 = (0f - matrix.M12) * num2;
			result.M21 = (0f - matrix.M21) * num2;
			result.M22 = matrix.M11 * num2;
			result.M31 = (matrix.M21 * matrix.M32 - matrix.M31 * matrix.M22) * num2;
			result.M32 = (matrix.M31 * matrix.M12 - matrix.M11 * matrix.M32) * num2;
			return true;
		}

		/// <summary>Performs a linear interpolation from one matrix to a second matrix based on a value that specifies the weighting of the second matrix.</summary>
		/// <param name="matrix1">The first matrix.</param>
		/// <param name="matrix2">The second matrix.</param>
		/// <param name="amount">The relative weighting of <paramref name="matrix2" />.</param>
		/// <returns>The interpolated matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 Lerp(Matrix3x2 matrix1, Matrix3x2 matrix2, float amount)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = matrix1.M11 + (matrix2.M11 - matrix1.M11) * amount;
			result.M12 = matrix1.M12 + (matrix2.M12 - matrix1.M12) * amount;
			result.M21 = matrix1.M21 + (matrix2.M21 - matrix1.M21) * amount;
			result.M22 = matrix1.M22 + (matrix2.M22 - matrix1.M22) * amount;
			result.M31 = matrix1.M31 + (matrix2.M31 - matrix1.M31) * amount;
			result.M32 = matrix1.M32 + (matrix2.M32 - matrix1.M32) * amount;
			return result;
		}

		/// <summary>Negates the specified matrix by multiplying all its values by -1.</summary>
		/// <param name="value">The matrix to negate.</param>
		/// <returns>The negated matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 Negate(Matrix3x2 value)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = 0f - value.M11;
			result.M12 = 0f - value.M12;
			result.M21 = 0f - value.M21;
			result.M22 = 0f - value.M22;
			result.M31 = 0f - value.M31;
			result.M32 = 0f - value.M32;
			return result;
		}

		/// <summary>Adds each element in one matrix with its corresponding element in a second matrix.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The matrix that contains the summed values of <paramref name="value1" /> and <paramref name="value2" />.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 Add(Matrix3x2 value1, Matrix3x2 value2)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = value1.M11 + value2.M11;
			result.M12 = value1.M12 + value2.M12;
			result.M21 = value1.M21 + value2.M21;
			result.M22 = value1.M22 + value2.M22;
			result.M31 = value1.M31 + value2.M31;
			result.M32 = value1.M32 + value2.M32;
			return result;
		}

		/// <summary>Subtracts each element in a second matrix from its corresponding element in a first matrix.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The matrix containing the values that result from subtracting each element in <paramref name="value2" /> from its corresponding element in <paramref name="value1" />.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 Subtract(Matrix3x2 value1, Matrix3x2 value2)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = value1.M11 - value2.M11;
			result.M12 = value1.M12 - value2.M12;
			result.M21 = value1.M21 - value2.M21;
			result.M22 = value1.M22 - value2.M22;
			result.M31 = value1.M31 - value2.M31;
			result.M32 = value1.M32 - value2.M32;
			return result;
		}

		/// <summary>Returns the matrix that results from multiplying two matrices together.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The product matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 Multiply(Matrix3x2 value1, Matrix3x2 value2)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = value1.M11 * value2.M11 + value1.M12 * value2.M21;
			result.M12 = value1.M11 * value2.M12 + value1.M12 * value2.M22;
			result.M21 = value1.M21 * value2.M11 + value1.M22 * value2.M21;
			result.M22 = value1.M21 * value2.M12 + value1.M22 * value2.M22;
			result.M31 = value1.M31 * value2.M11 + value1.M32 * value2.M21 + value2.M31;
			result.M32 = value1.M31 * value2.M12 + value1.M32 * value2.M22 + value2.M32;
			return result;
		}

		/// <summary>Returns the matrix that results from scaling all the elements of a specified matrix by a scalar factor.</summary>
		/// <param name="value1">The matrix to scale.</param>
		/// <param name="value2">The scaling value to use.</param>
		/// <returns>The scaled matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 Multiply(Matrix3x2 value1, float value2)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = value1.M11 * value2;
			result.M12 = value1.M12 * value2;
			result.M21 = value1.M21 * value2;
			result.M22 = value1.M22 * value2;
			result.M31 = value1.M31 * value2;
			result.M32 = value1.M32 * value2;
			return result;
		}

		/// <summary>Negates the specified matrix by multiplying all its values by -1.</summary>
		/// <param name="value">The matrix to negate.</param>
		/// <returns>The negated matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 operator -(Matrix3x2 value)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = 0f - value.M11;
			result.M12 = 0f - value.M12;
			result.M21 = 0f - value.M21;
			result.M22 = 0f - value.M22;
			result.M31 = 0f - value.M31;
			result.M32 = 0f - value.M32;
			return result;
		}

		/// <summary>Adds each element in one matrix with its corresponding element in a second matrix.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The matrix that contains the summed values.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 operator +(Matrix3x2 value1, Matrix3x2 value2)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = value1.M11 + value2.M11;
			result.M12 = value1.M12 + value2.M12;
			result.M21 = value1.M21 + value2.M21;
			result.M22 = value1.M22 + value2.M22;
			result.M31 = value1.M31 + value2.M31;
			result.M32 = value1.M32 + value2.M32;
			return result;
		}

		/// <summary>Subtracts each element in a second matrix from its corresponding element in a first matrix.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The matrix containing the values that result from subtracting each element in <paramref name="value2" /> from its corresponding element in <paramref name="value1" />.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 operator -(Matrix3x2 value1, Matrix3x2 value2)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = value1.M11 - value2.M11;
			result.M12 = value1.M12 - value2.M12;
			result.M21 = value1.M21 - value2.M21;
			result.M22 = value1.M22 - value2.M22;
			result.M31 = value1.M31 - value2.M31;
			result.M32 = value1.M32 - value2.M32;
			return result;
		}

		/// <summary>Returns the matrix that results from multiplying two matrices together.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The product matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 operator *(Matrix3x2 value1, Matrix3x2 value2)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = value1.M11 * value2.M11 + value1.M12 * value2.M21;
			result.M12 = value1.M11 * value2.M12 + value1.M12 * value2.M22;
			result.M21 = value1.M21 * value2.M11 + value1.M22 * value2.M21;
			result.M22 = value1.M21 * value2.M12 + value1.M22 * value2.M22;
			result.M31 = value1.M31 * value2.M11 + value1.M32 * value2.M21 + value2.M31;
			result.M32 = value1.M31 * value2.M12 + value1.M32 * value2.M22 + value2.M32;
			return result;
		}

		/// <summary>Returns the matrix that results from scaling all the elements of a specified matrix by a scalar factor.</summary>
		/// <param name="value1">The matrix to scale.</param>
		/// <param name="value2">The scaling value to use.</param>
		/// <returns>The scaled matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix3x2 operator *(Matrix3x2 value1, float value2)
		{
			Matrix3x2 result = default(Matrix3x2);
			result.M11 = value1.M11 * value2;
			result.M12 = value1.M12 * value2;
			result.M21 = value1.M21 * value2;
			result.M22 = value1.M22 * value2;
			result.M31 = value1.M31 * value2;
			result.M32 = value1.M32 * value2;
			return result;
		}

		/// <summary>Returns a value that indicates whether the specified matrices are equal.</summary>
		/// <param name="value1">The first matrix to compare.</param>
		/// <param name="value2">The second matrix to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="value1" /> and <paramref name="value2" /> are equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator ==(Matrix3x2 value1, Matrix3x2 value2)
		{
			if (value1.M11 == value2.M11 && value1.M22 == value2.M22 && value1.M12 == value2.M12 && value1.M21 == value2.M21 && value1.M31 == value2.M31)
			{
				return value1.M32 == value2.M32;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether the specified matrices are not equal.</summary>
		/// <param name="value1">The first matrix to compare.</param>
		/// <param name="value2">The second matrix to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="value1" /> and <paramref name="value2" /> are not equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator !=(Matrix3x2 value1, Matrix3x2 value2)
		{
			if (value1.M11 == value2.M11 && value1.M12 == value2.M12 && value1.M21 == value2.M21 && value1.M22 == value2.M22 && value1.M31 == value2.M31)
			{
				return value1.M32 != value2.M32;
			}
			return true;
		}

		/// <summary>Returns a value that indicates whether this instance and another 3x2 matrix are equal.</summary>
		/// <param name="other">The other matrix.</param>
		/// <returns>
		///   <see langword="true" /> if the two matrices are equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool Equals(Matrix3x2 other)
		{
			if (M11 == other.M11 && M22 == other.M22 && M12 == other.M12 && M21 == other.M21 && M31 == other.M31)
			{
				return M32 == other.M32;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether this instance and a specified object are equal.</summary>
		/// <param name="obj">The object to compare with the current instance.</param>
		/// <returns>
		///   <see langword="true" /> if the current instance and <paramref name="obj" /> are equal; otherwise, <see langword="false" />. If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public override bool Equals(object obj)
		{
			if (obj is Matrix3x2)
			{
				return Equals((Matrix3x2)obj);
			}
			return false;
		}

		/// <summary>Returns a string that represents this matrix.</summary>
		/// <returns>The string representation of this matrix.</returns>
		[__DynamicallyInvokable]
		public override string ToString()
		{
			CultureInfo currentCulture = CultureInfo.CurrentCulture;
			return string.Format(currentCulture, "{{ {{M11:{0} M12:{1}}} {{M21:{2} M22:{3}}} {{M31:{4} M32:{5}}} }}", M11.ToString(currentCulture), M12.ToString(currentCulture), M21.ToString(currentCulture), M22.ToString(currentCulture), M31.ToString(currentCulture), M32.ToString(currentCulture));
		}

		/// <summary>Returns the hash code for this instance.</summary>
		/// <returns>The hash code.</returns>
		[__DynamicallyInvokable]
		public override int GetHashCode()
		{
			return M11.GetHashCode() + M12.GetHashCode() + M21.GetHashCode() + M22.GetHashCode() + M31.GetHashCode() + M32.GetHashCode();
		}
	}
	/// <summary>Represents a 4x4 matrix.</summary>
	[__DynamicallyInvokable]
	public struct Matrix4x4 : IEquatable<Matrix4x4>
	{
		private struct CanonicalBasis
		{
			public Vector3 Row0;

			public Vector3 Row1;

			public Vector3 Row2;
		}

		[SecuritySafeCritical]
		private struct VectorBasis
		{
			public unsafe Vector3* Element0;

			public unsafe Vector3* Element1;

			public unsafe Vector3* Element2;
		}

		/// <summary>The first element of the first row.</summary>
		[__DynamicallyInvokable]
		public float M11;

		/// <summary>The second element of the first row.</summary>
		[__DynamicallyInvokable]
		public float M12;

		/// <summary>The third element of the first row.</summary>
		[__DynamicallyInvokable]
		public float M13;

		/// <summary>The fourth element of the first row.</summary>
		[__DynamicallyInvokable]
		public float M14;

		/// <summary>The first element of the second row.</summary>
		[__DynamicallyInvokable]
		public float M21;

		/// <summary>The second element of the second row.</summary>
		[__DynamicallyInvokable]
		public float M22;

		/// <summary>The third element of the second row.</summary>
		[__DynamicallyInvokable]
		public float M23;

		/// <summary>The fourth element of the second row.</summary>
		[__DynamicallyInvokable]
		public float M24;

		/// <summary>The first element of the third row.</summary>
		[__DynamicallyInvokable]
		public float M31;

		/// <summary>The second element of the third row.</summary>
		[__DynamicallyInvokable]
		public float M32;

		/// <summary>The third element of the third row.</summary>
		[__DynamicallyInvokable]
		public float M33;

		/// <summary>The fourth element of the third row.</summary>
		[__DynamicallyInvokable]
		public float M34;

		/// <summary>The first element of the fourth row.</summary>
		[__DynamicallyInvokable]
		public float M41;

		/// <summary>The second element of the fourth row.</summary>
		[__DynamicallyInvokable]
		public float M42;

		/// <summary>The third element of the fourth row.</summary>
		[__DynamicallyInvokable]
		public float M43;

		/// <summary>The fourth element of the fourth row.</summary>
		[__DynamicallyInvokable]
		public float M44;

		private static readonly Matrix4x4 _identity = new Matrix4x4(1f, 0f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 0f, 1f);

		/// <summary>Gets the multiplicative identity matrix.</summary>
		/// <returns>Gets the multiplicative identity matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 Identity
		{
			[__DynamicallyInvokable]
			get
			{
				return _identity;
			}
		}

		/// <summary>Indicates whether the current matrix is the identity matrix.</summary>
		/// <returns>
		///   <see langword="true" /> if the current matrix is the identity matrix; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool IsIdentity
		{
			[__DynamicallyInvokable]
			get
			{
				if (M11 == 1f && M22 == 1f && M33 == 1f && M44 == 1f && M12 == 0f && M13 == 0f && M14 == 0f && M21 == 0f && M23 == 0f && M24 == 0f && M31 == 0f && M32 == 0f && M34 == 0f && M41 == 0f && M42 == 0f)
				{
					return M43 == 0f;
				}
				return false;
			}
		}

		/// <summary>Gets or sets the translation component of this matrix.</summary>
		/// <returns>The translation component of the current instance.</returns>
		[__DynamicallyInvokable]
		public Vector3 Translation
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector3(M41, M42, M43);
			}
			[__DynamicallyInvokable]
			set
			{
				M41 = value.X;
				M42 = value.Y;
				M43 = value.Z;
			}
		}

		/// <summary>Creates a 4x4 matrix from the specified components.</summary>
		/// <param name="m11">The value to assign to the first element in the first row.</param>
		/// <param name="m12">The value to assign to the second element in the first row.</param>
		/// <param name="m13">The value to assign to the third element in the first row.</param>
		/// <param name="m14">The value to assign to the fourth element in the first row.</param>
		/// <param name="m21">The value to assign to the first element in the second row.</param>
		/// <param name="m22">The value to assign to the second element in the second row.</param>
		/// <param name="m23">The value to assign to the third element in the second row.</param>
		/// <param name="m24">The value to assign to the third element in the second row.</param>
		/// <param name="m31">The value to assign to the first element in the third row.</param>
		/// <param name="m32">The value to assign to the second element in the third row.</param>
		/// <param name="m33">The value to assign to the third element in the third row.</param>
		/// <param name="m34">The value to assign to the fourth element in the third row.</param>
		/// <param name="m41">The value to assign to the first element in the fourth row.</param>
		/// <param name="m42">The value to assign to the second element in the fourth row.</param>
		/// <param name="m43">The value to assign to the third element in the fourth row.</param>
		/// <param name="m44">The value to assign to the fourth element in the fourth row.</param>
		[__DynamicallyInvokable]
		public Matrix4x4(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44)
		{
			M11 = m11;
			M12 = m12;
			M13 = m13;
			M14 = m14;
			M21 = m21;
			M22 = m22;
			M23 = m23;
			M24 = m24;
			M31 = m31;
			M32 = m32;
			M33 = m33;
			M34 = m34;
			M41 = m41;
			M42 = m42;
			M43 = m43;
			M44 = m44;
		}

		/// <summary>Creates a <see cref="T:System.Numerics.Matrix4x4" /> object from a specified <see cref="T:System.Numerics.Matrix3x2" /> object.</summary>
		/// <param name="value">A 3x2 matrix.</param>
		[__DynamicallyInvokable]
		public Matrix4x4(Matrix3x2 value)
		{
			M11 = value.M11;
			M12 = value.M12;
			M13 = 0f;
			M14 = 0f;
			M21 = value.M21;
			M22 = value.M22;
			M23 = 0f;
			M24 = 0f;
			M31 = 0f;
			M32 = 0f;
			M33 = 1f;
			M34 = 0f;
			M41 = value.M31;
			M42 = value.M32;
			M43 = 0f;
			M44 = 1f;
		}

		/// <summary>Creates a spherical billboard that rotates around a specified object position.</summary>
		/// <param name="objectPosition">The position of the object that the billboard will rotate around.</param>
		/// <param name="cameraPosition">The position of the camera.</param>
		/// <param name="cameraUpVector">The up vector of the camera.</param>
		/// <param name="cameraForwardVector">The forward vector of the camera.</param>
		/// <returns>The created billboard.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateBillboard(Vector3 objectPosition, Vector3 cameraPosition, Vector3 cameraUpVector, Vector3 cameraForwardVector)
		{
			Vector3 left = new Vector3(objectPosition.X - cameraPosition.X, objectPosition.Y - cameraPosition.Y, objectPosition.Z - cameraPosition.Z);
			float num = left.LengthSquared();
			left = ((!(num < 0.0001f)) ? Vector3.Multiply(left, 1f / (float)Math.Sqrt(num)) : (-cameraForwardVector));
			Vector3 vector = Vector3.Normalize(Vector3.Cross(cameraUpVector, left));
			Vector3 vector2 = Vector3.Cross(left, vector);
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = vector.X;
			result.M12 = vector.Y;
			result.M13 = vector.Z;
			result.M14 = 0f;
			result.M21 = vector2.X;
			result.M22 = vector2.Y;
			result.M23 = vector2.Z;
			result.M24 = 0f;
			result.M31 = left.X;
			result.M32 = left.Y;
			result.M33 = left.Z;
			result.M34 = 0f;
			result.M41 = objectPosition.X;
			result.M42 = objectPosition.Y;
			result.M43 = objectPosition.Z;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a cylindrical billboard that rotates around a specified axis.</summary>
		/// <param name="objectPosition">The position of the object that the billboard will rotate around.</param>
		/// <param name="cameraPosition">The position of the camera.</param>
		/// <param name="rotateAxis">The axis to rotate the billboard around.</param>
		/// <param name="cameraForwardVector">The forward vector of the camera.</param>
		/// <param name="objectForwardVector">The forward vector of the object.</param>
		/// <returns>The billboard matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateConstrainedBillboard(Vector3 objectPosition, Vector3 cameraPosition, Vector3 rotateAxis, Vector3 cameraForwardVector, Vector3 objectForwardVector)
		{
			Vector3 left = new Vector3(objectPosition.X - cameraPosition.X, objectPosition.Y - cameraPosition.Y, objectPosition.Z - cameraPosition.Z);
			float num = left.LengthSquared();
			left = ((!(num < 0.0001f)) ? Vector3.Multiply(left, 1f / (float)Math.Sqrt(num)) : (-cameraForwardVector));
			Vector3 vector = rotateAxis;
			float value = Vector3.Dot(rotateAxis, left);
			Vector3 vector3;
			Vector3 vector2;
			if (Math.Abs(value) > 0.998254657f)
			{
				vector2 = objectForwardVector;
				value = Vector3.Dot(rotateAxis, vector2);
				if (Math.Abs(value) > 0.998254657f)
				{
					vector2 = ((Math.Abs(rotateAxis.Z) > 0.998254657f) ? new Vector3(1f, 0f, 0f) : new Vector3(0f, 0f, -1f));
				}
				vector3 = Vector3.Normalize(Vector3.Cross(rotateAxis, vector2));
				vector2 = Vector3.Normalize(Vector3.Cross(vector3, rotateAxis));
			}
			else
			{
				vector3 = Vector3.Normalize(Vector3.Cross(rotateAxis, left));
				vector2 = Vector3.Normalize(Vector3.Cross(vector3, vector));
			}
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = vector3.X;
			result.M12 = vector3.Y;
			result.M13 = vector3.Z;
			result.M14 = 0f;
			result.M21 = vector.X;
			result.M22 = vector.Y;
			result.M23 = vector.Z;
			result.M24 = 0f;
			result.M31 = vector2.X;
			result.M32 = vector2.Y;
			result.M33 = vector2.Z;
			result.M34 = 0f;
			result.M41 = objectPosition.X;
			result.M42 = objectPosition.Y;
			result.M43 = objectPosition.Z;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a translation matrix from the specified 3-dimensional vector.</summary>
		/// <param name="position">The amount to translate in each axis.</param>
		/// <returns>The translation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateTranslation(Vector3 position)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = 1f;
			result.M12 = 0f;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = 1f;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f;
			result.M33 = 1f;
			result.M34 = 0f;
			result.M41 = position.X;
			result.M42 = position.Y;
			result.M43 = position.Z;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a translation matrix from the specified X, Y, and Z components.</summary>
		/// <param name="xPosition">The amount to translate on the X axis.</param>
		/// <param name="yPosition">The amount to translate on the Y axis.</param>
		/// <param name="zPosition">The amount to translate on the Z axis.</param>
		/// <returns>The translation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateTranslation(float xPosition, float yPosition, float zPosition)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = 1f;
			result.M12 = 0f;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = 1f;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f;
			result.M33 = 1f;
			result.M34 = 0f;
			result.M41 = xPosition;
			result.M42 = yPosition;
			result.M43 = zPosition;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a scaling matrix from the specified X, Y, and Z components.</summary>
		/// <param name="xScale">The value to scale by on the X axis.</param>
		/// <param name="yScale">The value to scale by on the Y axis.</param>
		/// <param name="zScale">The value to scale by on the Z axis.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateScale(float xScale, float yScale, float zScale)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = xScale;
			result.M12 = 0f;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = yScale;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f;
			result.M33 = zScale;
			result.M34 = 0f;
			result.M41 = 0f;
			result.M42 = 0f;
			result.M43 = 0f;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a scaling matrix that is offset by a given center point.</summary>
		/// <param name="xScale">The value to scale by on the X axis.</param>
		/// <param name="yScale">The value to scale by on the Y axis.</param>
		/// <param name="zScale">The value to scale by on the Z axis.</param>
		/// <param name="centerPoint">The center point.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateScale(float xScale, float yScale, float zScale, Vector3 centerPoint)
		{
			float m = centerPoint.X * (1f - xScale);
			float m2 = centerPoint.Y * (1f - yScale);
			float m3 = centerPoint.Z * (1f - zScale);
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = xScale;
			result.M12 = 0f;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = yScale;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f;
			result.M33 = zScale;
			result.M34 = 0f;
			result.M41 = m;
			result.M42 = m2;
			result.M43 = m3;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a scaling matrix from the specified vector scale.</summary>
		/// <param name="scales">The scale to use.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateScale(Vector3 scales)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = scales.X;
			result.M12 = 0f;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = scales.Y;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f;
			result.M33 = scales.Z;
			result.M34 = 0f;
			result.M41 = 0f;
			result.M42 = 0f;
			result.M43 = 0f;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a scaling matrix with a center point.</summary>
		/// <param name="scales">The vector that contains the amount to scale on each axis.</param>
		/// <param name="centerPoint">The center point.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateScale(Vector3 scales, Vector3 centerPoint)
		{
			float m = centerPoint.X * (1f - scales.X);
			float m2 = centerPoint.Y * (1f - scales.Y);
			float m3 = centerPoint.Z * (1f - scales.Z);
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = scales.X;
			result.M12 = 0f;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = scales.Y;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f;
			result.M33 = scales.Z;
			result.M34 = 0f;
			result.M41 = m;
			result.M42 = m2;
			result.M43 = m3;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a uniform scaling matrix that scale equally on each axis.</summary>
		/// <param name="scale">The uniform scaling factor.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateScale(float scale)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = scale;
			result.M12 = 0f;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = scale;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f;
			result.M33 = scale;
			result.M34 = 0f;
			result.M41 = 0f;
			result.M42 = 0f;
			result.M43 = 0f;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a uniform scaling matrix that scales equally on each axis with a center point.</summary>
		/// <param name="scale">The uniform scaling factor.</param>
		/// <param name="centerPoint">The center point.</param>
		/// <returns>The scaling matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateScale(float scale, Vector3 centerPoint)
		{
			float m = centerPoint.X * (1f - scale);
			float m2 = centerPoint.Y * (1f - scale);
			float m3 = centerPoint.Z * (1f - scale);
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = scale;
			result.M12 = 0f;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = scale;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f;
			result.M33 = scale;
			result.M34 = 0f;
			result.M41 = m;
			result.M42 = m2;
			result.M43 = m3;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a matrix for rotating points around the X axis.</summary>
		/// <param name="radians">The amount, in radians, by which to rotate around the X axis.</param>
		/// <returns>The rotation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateRotationX(float radians)
		{
			float num = (float)Math.Cos(radians);
			float num2 = (float)Math.Sin(radians);
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = 1f;
			result.M12 = 0f;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = num;
			result.M23 = num2;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f - num2;
			result.M33 = num;
			result.M34 = 0f;
			result.M41 = 0f;
			result.M42 = 0f;
			result.M43 = 0f;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a matrix for rotating points around the X axis from a center point.</summary>
		/// <param name="radians">The amount, in radians, by which to rotate around the X axis.</param>
		/// <param name="centerPoint">The center point.</param>
		/// <returns>The rotation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateRotationX(float radians, Vector3 centerPoint)
		{
			float num = (float)Math.Cos(radians);
			float num2 = (float)Math.Sin(radians);
			float m = centerPoint.Y * (1f - num) + centerPoint.Z * num2;
			float m2 = centerPoint.Z * (1f - num) - centerPoint.Y * num2;
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = 1f;
			result.M12 = 0f;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = num;
			result.M23 = num2;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f - num2;
			result.M33 = num;
			result.M34 = 0f;
			result.M41 = 0f;
			result.M42 = m;
			result.M43 = m2;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a matrix for rotating points around the Y axis.</summary>
		/// <param name="radians">The amount, in radians, by which to rotate around the Y-axis.</param>
		/// <returns>The rotation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateRotationY(float radians)
		{
			float num = (float)Math.Cos(radians);
			float num2 = (float)Math.Sin(radians);
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = num;
			result.M12 = 0f;
			result.M13 = 0f - num2;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = 1f;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = num2;
			result.M32 = 0f;
			result.M33 = num;
			result.M34 = 0f;
			result.M41 = 0f;
			result.M42 = 0f;
			result.M43 = 0f;
			result.M44 = 1f;
			return result;
		}

		/// <summary>The amount, in radians, by which to rotate around the Y axis from a center point.</summary>
		/// <param name="radians">The amount, in radians, by which to rotate around the Y-axis.</param>
		/// <param name="centerPoint">The center point.</param>
		/// <returns>The rotation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateRotationY(float radians, Vector3 centerPoint)
		{
			float num = (float)Math.Cos(radians);
			float num2 = (float)Math.Sin(radians);
			float m = centerPoint.X * (1f - num) - centerPoint.Z * num2;
			float m2 = centerPoint.Z * (1f - num) + centerPoint.X * num2;
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = num;
			result.M12 = 0f;
			result.M13 = 0f - num2;
			result.M14 = 0f;
			result.M21 = 0f;
			result.M22 = 1f;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = num2;
			result.M32 = 0f;
			result.M33 = num;
			result.M34 = 0f;
			result.M41 = m;
			result.M42 = 0f;
			result.M43 = m2;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a matrix for rotating points around the Z axis.</summary>
		/// <param name="radians">The amount, in radians, by which to rotate around the Z-axis.</param>
		/// <returns>The rotation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateRotationZ(float radians)
		{
			float num = (float)Math.Cos(radians);
			float num2 = (float)Math.Sin(radians);
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = num;
			result.M12 = num2;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f - num2;
			result.M22 = num;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f;
			result.M33 = 1f;
			result.M34 = 0f;
			result.M41 = 0f;
			result.M42 = 0f;
			result.M43 = 0f;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a matrix for rotating points around the Z axis from a center point.</summary>
		/// <param name="radians">The amount, in radians, by which to rotate around the Z-axis.</param>
		/// <param name="centerPoint">The center point.</param>
		/// <returns>The rotation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateRotationZ(float radians, Vector3 centerPoint)
		{
			float num = (float)Math.Cos(radians);
			float num2 = (float)Math.Sin(radians);
			float m = centerPoint.X * (1f - num) + centerPoint.Y * num2;
			float m2 = centerPoint.Y * (1f - num) - centerPoint.X * num2;
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = num;
			result.M12 = num2;
			result.M13 = 0f;
			result.M14 = 0f;
			result.M21 = 0f - num2;
			result.M22 = num;
			result.M23 = 0f;
			result.M24 = 0f;
			result.M31 = 0f;
			result.M32 = 0f;
			result.M33 = 1f;
			result.M34 = 0f;
			result.M41 = m;
			result.M42 = m2;
			result.M43 = 0f;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a matrix that rotates around an arbitrary vector.</summary>
		/// <param name="axis">The axis to rotate around.</param>
		/// <param name="angle">The angle to rotate around <paramref name="axis" />, in radians.</param>
		/// <returns>The rotation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateFromAxisAngle(Vector3 axis, float angle)
		{
			float x = axis.X;
			float y = axis.Y;
			float z = axis.Z;
			float num = (float)Math.Sin(angle);
			float num2 = (float)Math.Cos(angle);
			float num3 = x * x;
			float num4 = y * y;
			float num5 = z * z;
			float num6 = x * y;
			float num7 = x * z;
			float num8 = y * z;
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = num3 + num2 * (1f - num3);
			result.M12 = num6 - num2 * num6 + num * z;
			result.M13 = num7 - num2 * num7 - num * y;
			result.M14 = 0f;
			result.M21 = num6 - num2 * num6 - num * z;
			result.M22 = num4 + num2 * (1f - num4);
			result.M23 = num8 - num2 * num8 + num * x;
			result.M24 = 0f;
			result.M31 = num7 - num2 * num7 + num * y;
			result.M32 = num8 - num2 * num8 - num * x;
			result.M33 = num5 + num2 * (1f - num5);
			result.M34 = 0f;
			result.M41 = 0f;
			result.M42 = 0f;
			result.M43 = 0f;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a perspective projection matrix based on a field of view, aspect ratio, and near and far view plane distances.</summary>
		/// <param name="fieldOfView">The field of view in the y direction, in radians.</param>
		/// <param name="aspectRatio">The aspect ratio, defined as view space width divided by height.</param>
		/// <param name="nearPlaneDistance">The distance to the near view plane.</param>
		/// <param name="farPlaneDistance">The distance to the far view plane.</param>
		/// <returns>The perspective projection matrix.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="fieldOfView" /> is less than or equal to zero.  
		/// -or-  
		/// <paramref name="fieldOfView" /> is greater than or equal to <see cref="F:System.Math.PI" />.  
		/// <paramref name="nearPlaneDistance" /> is less than or equal to zero.  
		/// -or-  
		/// <paramref name="farPlaneDistance" /> is less than or equal to zero.  
		/// -or-  
		/// <paramref name="nearPlaneDistance" /> is greater than or equal to <paramref name="farPlaneDistance" />.</exception>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreatePerspectiveFieldOfView(float fieldOfView, float aspectRatio, float nearPlaneDistance, float farPlaneDistance)
		{
			if (fieldOfView <= 0f || (double)fieldOfView >= Math.PI)
			{
				throw new ArgumentOutOfRangeException("fieldOfView");
			}
			if (nearPlaneDistance <= 0f)
			{
				throw new ArgumentOutOfRangeException("nearPlaneDistance");
			}
			if (farPlaneDistance <= 0f)
			{
				throw new ArgumentOutOfRangeException("farPlaneDistance");
			}
			if (nearPlaneDistance >= farPlaneDistance)
			{
				throw new ArgumentOutOfRangeException("nearPlaneDistance");
			}
			float num = 1f / (float)Math.Tan(fieldOfView * 0.5f);
			Matrix4x4 result = default(Matrix4x4);
			float num2 = (result.M11 = num / aspectRatio);
			result.M12 = (result.M13 = (result.M14 = 0f));
			result.M22 = num;
			result.M21 = (result.M23 = (result.M24 = 0f));
			result.M31 = (result.M32 = 0f);
			result.M33 = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
			result.M34 = -1f;
			result.M41 = (result.M42 = (result.M44 = 0f));
			result.M43 = nearPlaneDistance * farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
			return result;
		}

		/// <summary>Creates a perspective projection matrix from the given view volume dimensions.</summary>
		/// <param name="width">The width of the view volume at the near view plane.</param>
		/// <param name="height">The height of the view volume at the near view plane.</param>
		/// <param name="nearPlaneDistance">The distance to the near view plane.</param>
		/// <param name="farPlaneDistance">The distance to the far view plane.</param>
		/// <returns>The perspective projection matrix.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="nearPlaneDistance" /> is less than or equal to zero.  
		/// -or-  
		/// <paramref name="farPlaneDistance" /> is less than or equal to zero.  
		/// -or-  
		/// <paramref name="nearPlaneDistance" /> is greater than or equal to <paramref name="farPlaneDistance" />.</exception>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreatePerspective(float width, float height, float nearPlaneDistance, float farPlaneDistance)
		{
			if (nearPlaneDistance <= 0f)
			{
				throw new ArgumentOutOfRangeException("nearPlaneDistance");
			}
			if (farPlaneDistance <= 0f)
			{
				throw new ArgumentOutOfRangeException("farPlaneDistance");
			}
			if (nearPlaneDistance >= farPlaneDistance)
			{
				throw new ArgumentOutOfRangeException("nearPlaneDistance");
			}
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = 2f * nearPlaneDistance / width;
			result.M12 = (result.M13 = (result.M14 = 0f));
			result.M22 = 2f * nearPlaneDistance / height;
			result.M21 = (result.M23 = (result.M24 = 0f));
			result.M33 = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
			result.M31 = (result.M32 = 0f);
			result.M34 = -1f;
			result.M41 = (result.M42 = (result.M44 = 0f));
			result.M43 = nearPlaneDistance * farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
			return result;
		}

		/// <summary>Creates a customized perspective projection matrix.</summary>
		/// <param name="left">The minimum x-value of the view volume at the near view plane.</param>
		/// <param name="right">The maximum x-value of the view volume at the near view plane.</param>
		/// <param name="bottom">The minimum y-value of the view volume at the near view plane.</param>
		/// <param name="top">The maximum y-value of the view volume at the near view plane.</param>
		/// <param name="nearPlaneDistance">The distance to the near view plane.</param>
		/// <param name="farPlaneDistance">The distance to the far view plane.</param>
		/// <returns>The perspective projection matrix.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="nearPlaneDistance" /> is less than or equal to zero.  
		/// -or-  
		/// <paramref name="farPlaneDistance" /> is less than or equal to zero.  
		/// -or-  
		/// <paramref name="nearPlaneDistance" /> is greater than or equal to <paramref name="farPlaneDistance" />.</exception>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreatePerspectiveOffCenter(float left, float right, float bottom, float top, float nearPlaneDistance, float farPlaneDistance)
		{
			if (nearPlaneDistance <= 0f)
			{
				throw new ArgumentOutOfRangeException("nearPlaneDistance");
			}
			if (farPlaneDistance <= 0f)
			{
				throw new ArgumentOutOfRangeException("farPlaneDistance");
			}
			if (nearPlaneDistance >= farPlaneDistance)
			{
				throw new ArgumentOutOfRangeException("nearPlaneDistance");
			}
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = 2f * nearPlaneDistance / (right - left);
			result.M12 = (result.M13 = (result.M14 = 0f));
			result.M22 = 2f * nearPlaneDistance / (top - bottom);
			result.M21 = (result.M23 = (result.M24 = 0f));
			result.M31 = (left + right) / (right - left);
			result.M32 = (top + bottom) / (top - bottom);
			result.M33 = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
			result.M34 = -1f;
			result.M43 = nearPlaneDistance * farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
			result.M41 = (result.M42 = (result.M44 = 0f));
			return result;
		}

		/// <summary>Creates an orthographic perspective matrix from the given view volume dimensions.</summary>
		/// <param name="width">The width of the view volume.</param>
		/// <param name="height">The height of the view volume.</param>
		/// <param name="zNearPlane">The minimum Z-value of the view volume.</param>
		/// <param name="zFarPlane">The maximum Z-value of the view volume.</param>
		/// <returns>The orthographic projection matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateOrthographic(float width, float height, float zNearPlane, float zFarPlane)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = 2f / width;
			result.M12 = (result.M13 = (result.M14 = 0f));
			result.M22 = 2f / height;
			result.M21 = (result.M23 = (result.M24 = 0f));
			result.M33 = 1f / (zNearPlane - zFarPlane);
			result.M31 = (result.M32 = (result.M34 = 0f));
			result.M41 = (result.M42 = 0f);
			result.M43 = zNearPlane / (zNearPlane - zFarPlane);
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a customized orthographic projection matrix.</summary>
		/// <param name="left">The minimum X-value of the view volume.</param>
		/// <param name="right">The maximum X-value of the view volume.</param>
		/// <param name="bottom">The minimum Y-value of the view volume.</param>
		/// <param name="top">The maximum Y-value of the view volume.</param>
		/// <param name="zNearPlane">The minimum Z-value of the view volume.</param>
		/// <param name="zFarPlane">The maximum Z-value of the view volume.</param>
		/// <returns>The orthographic projection matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateOrthographicOffCenter(float left, float right, float bottom, float top, float zNearPlane, float zFarPlane)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = 2f / (right - left);
			result.M12 = (result.M13 = (result.M14 = 0f));
			result.M22 = 2f / (top - bottom);
			result.M21 = (result.M23 = (result.M24 = 0f));
			result.M33 = 1f / (zNearPlane - zFarPlane);
			result.M31 = (result.M32 = (result.M34 = 0f));
			result.M41 = (left + right) / (left - right);
			result.M42 = (top + bottom) / (bottom - top);
			result.M43 = zNearPlane / (zNearPlane - zFarPlane);
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a view matrix.</summary>
		/// <param name="cameraPosition">The position of the camera.</param>
		/// <param name="cameraTarget">The target towards which the camera is pointing.</param>
		/// <param name="cameraUpVector">The direction that is "up" from the camera's point of view.</param>
		/// <returns>The view matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateLookAt(Vector3 cameraPosition, Vector3 cameraTarget, Vector3 cameraUpVector)
		{
			Vector3 vector = Vector3.Normalize(cameraPosition - cameraTarget);
			Vector3 vector2 = Vector3.Normalize(Vector3.Cross(cameraUpVector, vector));
			Vector3 vector3 = Vector3.Cross(vector, vector2);
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = vector2.X;
			result.M12 = vector3.X;
			result.M13 = vector.X;
			result.M14 = 0f;
			result.M21 = vector2.Y;
			result.M22 = vector3.Y;
			result.M23 = vector.Y;
			result.M24 = 0f;
			result.M31 = vector2.Z;
			result.M32 = vector3.Z;
			result.M33 = vector.Z;
			result.M34 = 0f;
			result.M41 = 0f - Vector3.Dot(vector2, cameraPosition);
			result.M42 = 0f - Vector3.Dot(vector3, cameraPosition);
			result.M43 = 0f - Vector3.Dot(vector, cameraPosition);
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a world matrix with the specified parameters.</summary>
		/// <param name="position">The position of the object.</param>
		/// <param name="forward">The forward direction of the object.</param>
		/// <param name="up">The upward direction of the object. Its value is usually <c>[0, 1, 0]</c>.</param>
		/// <returns>The world matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateWorld(Vector3 position, Vector3 forward, Vector3 up)
		{
			Vector3 vector = Vector3.Normalize(-forward);
			Vector3 vector2 = Vector3.Normalize(Vector3.Cross(up, vector));
			Vector3 vector3 = Vector3.Cross(vector, vector2);
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = vector2.X;
			result.M12 = vector2.Y;
			result.M13 = vector2.Z;
			result.M14 = 0f;
			result.M21 = vector3.X;
			result.M22 = vector3.Y;
			result.M23 = vector3.Z;
			result.M24 = 0f;
			result.M31 = vector.X;
			result.M32 = vector.Y;
			result.M33 = vector.Z;
			result.M34 = 0f;
			result.M41 = position.X;
			result.M42 = position.Y;
			result.M43 = position.Z;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a rotation matrix from the specified Quaternion rotation value.</summary>
		/// <param name="quaternion">The source Quaternion.</param>
		/// <returns>The rotation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateFromQuaternion(Quaternion quaternion)
		{
			float num = quaternion.X * quaternion.X;
			float num2 = quaternion.Y * quaternion.Y;
			float num3 = quaternion.Z * quaternion.Z;
			float num4 = quaternion.X * quaternion.Y;
			float num5 = quaternion.Z * quaternion.W;
			float num6 = quaternion.Z * quaternion.X;
			float num7 = quaternion.Y * quaternion.W;
			float num8 = quaternion.Y * quaternion.Z;
			float num9 = quaternion.X * quaternion.W;
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = 1f - 2f * (num2 + num3);
			result.M12 = 2f * (num4 + num5);
			result.M13 = 2f * (num6 - num7);
			result.M14 = 0f;
			result.M21 = 2f * (num4 - num5);
			result.M22 = 1f - 2f * (num3 + num);
			result.M23 = 2f * (num8 + num9);
			result.M24 = 0f;
			result.M31 = 2f * (num6 + num7);
			result.M32 = 2f * (num8 - num9);
			result.M33 = 1f - 2f * (num2 + num);
			result.M34 = 0f;
			result.M41 = 0f;
			result.M42 = 0f;
			result.M43 = 0f;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Creates a rotation matrix from the specified yaw, pitch, and roll.</summary>
		/// <param name="yaw">The angle of rotation, in radians, around the Y axis.</param>
		/// <param name="pitch">The angle of rotation, in radians, around the X axis.</param>
		/// <param name="roll">The angle of rotation, in radians, around the Z axis.</param>
		/// <returns>The rotation matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateFromYawPitchRoll(float yaw, float pitch, float roll)
		{
			Quaternion quaternion = Quaternion.CreateFromYawPitchRoll(yaw, pitch, roll);
			return CreateFromQuaternion(quaternion);
		}

		/// <summary>Creates a matrix that flattens geometry into a specified plane as if casting a shadow from a specified light source.</summary>
		/// <param name="lightDirection">The direction from which the light that will cast the shadow is coming.</param>
		/// <param name="plane">The plane onto which the new matrix should flatten geometry so as to cast a shadow.</param>
		/// <returns>A new matrix that can be used to flatten geometry onto the specified plane from the specified direction.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateShadow(Vector3 lightDirection, Plane plane)
		{
			Plane plane2 = Plane.Normalize(plane);
			float num = plane2.Normal.X * lightDirection.X + plane2.Normal.Y * lightDirection.Y + plane2.Normal.Z * lightDirection.Z;
			float num2 = 0f - plane2.Normal.X;
			float num3 = 0f - plane2.Normal.Y;
			float num4 = 0f - plane2.Normal.Z;
			float num5 = 0f - plane2.D;
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = num2 * lightDirection.X + num;
			result.M21 = num3 * lightDirection.X;
			result.M31 = num4 * lightDirection.X;
			result.M41 = num5 * lightDirection.X;
			result.M12 = num2 * lightDirection.Y;
			result.M22 = num3 * lightDirection.Y + num;
			result.M32 = num4 * lightDirection.Y;
			result.M42 = num5 * lightDirection.Y;
			result.M13 = num2 * lightDirection.Z;
			result.M23 = num3 * lightDirection.Z;
			result.M33 = num4 * lightDirection.Z + num;
			result.M43 = num5 * lightDirection.Z;
			result.M14 = 0f;
			result.M24 = 0f;
			result.M34 = 0f;
			result.M44 = num;
			return result;
		}

		/// <summary>Creates a matrix that reflects the coordinate system about a specified plane.</summary>
		/// <param name="value">The plane about which to create a reflection.</param>
		/// <returns>A new matrix expressing the reflection.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 CreateReflection(Plane value)
		{
			value = Plane.Normalize(value);
			float x = value.Normal.X;
			float y = value.Normal.Y;
			float z = value.Normal.Z;
			float num = -2f * x;
			float num2 = -2f * y;
			float num3 = -2f * z;
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = num * x + 1f;
			result.M12 = num2 * x;
			result.M13 = num3 * x;
			result.M14 = 0f;
			result.M21 = num * y;
			result.M22 = num2 * y + 1f;
			result.M23 = num3 * y;
			result.M24 = 0f;
			result.M31 = num * z;
			result.M32 = num2 * z;
			result.M33 = num3 * z + 1f;
			result.M34 = 0f;
			result.M41 = num * value.D;
			result.M42 = num2 * value.D;
			result.M43 = num3 * value.D;
			result.M44 = 1f;
			return result;
		}

		/// <summary>Calculates the determinant of the current 4x4 matrix.</summary>
		/// <returns>The determinant.</returns>
		[__DynamicallyInvokable]
		public float GetDeterminant()
		{
			float m = M11;
			float m2 = M12;
			float m3 = M13;
			float m4 = M14;
			float m5 = M21;
			float m6 = M22;
			float m7 = M23;
			float m8 = M24;
			float m9 = M31;
			float m10 = M32;
			float m11 = M33;
			float m12 = M34;
			float m13 = M41;
			float m14 = M42;
			float m15 = M43;
			float m16 = M44;
			float num = m11 * m16 - m12 * m15;
			float num2 = m10 * m16 - m12 * m14;
			float num3 = m10 * m15 - m11 * m14;
			float num4 = m9 * m16 - m12 * m13;
			float num5 = m9 * m15 - m11 * m13;
			float num6 = m9 * m14 - m10 * m13;
			return m * (m6 * num - m7 * num2 + m8 * num3) - m2 * (m5 * num - m7 * num4 + m8 * num5) + m3 * (m5 * num2 - m6 * num4 + m8 * num6) - m4 * (m5 * num3 - m6 * num5 + m7 * num6);
		}

		/// <summary>Inverts the specified matrix. The return value indicates whether the operation succeeded.</summary>
		/// <param name="matrix">The matrix to invert.</param>
		/// <param name="result">When this method returns, contains the inverted matrix if the operation succeeded.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="matrix" /> was converted successfully; otherwise,  <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool Invert(Matrix4x4 matrix, out Matrix4x4 result)
		{
			float m = matrix.M11;
			float m2 = matrix.M12;
			float m3 = matrix.M13;
			float m4 = matrix.M14;
			float m5 = matrix.M21;
			float m6 = matrix.M22;
			float m7 = matrix.M23;
			float m8 = matrix.M24;
			float m9 = matrix.M31;
			float m10 = matrix.M32;
			float m11 = matrix.M33;
			float m12 = matrix.M34;
			float m13 = matrix.M41;
			float m14 = matrix.M42;
			float m15 = matrix.M43;
			float m16 = matrix.M44;
			float num = m11 * m16 - m12 * m15;
			float num2 = m10 * m16 - m12 * m14;
			float num3 = m10 * m15 - m11 * m14;
			float num4 = m9 * m16 - m12 * m13;
			float num5 = m9 * m15 - m11 * m13;
			float num6 = m9 * m14 - m10 * m13;
			float num7 = m6 * num - m7 * num2 + m8 * num3;
			float num8 = 0f - (m5 * num - m7 * num4 + m8 * num5);
			float num9 = m5 * num2 - m6 * num4 + m8 * num6;
			float num10 = 0f - (m5 * num3 - m6 * num5 + m7 * num6);
			float num11 = m * num7 + m2 * num8 + m3 * num9 + m4 * num10;
			if (Math.Abs(num11) < float.Epsilon)
			{
				result = new Matrix4x4(float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN, float.NaN);
				return false;
			}
			float num12 = 1f / num11;
			result.M11 = num7 * num12;
			result.M21 = num8 * num12;
			result.M31 = num9 * num12;
			result.M41 = num10 * num12;
			result.M12 = (0f - (m2 * num - m3 * num2 + m4 * num3)) * num12;
			result.M22 = (m * num - m3 * num4 + m4 * num5) * num12;
			result.M32 = (0f - (m * num2 - m2 * num4 + m4 * num6)) * num12;
			result.M42 = (m * num3 - m2 * num5 + m3 * num6) * num12;
			float num13 = m7 * m16 - m8 * m15;
			float num14 = m6 * m16 - m8 * m14;
			float num15 = m6 * m15 - m7 * m14;
			float num16 = m5 * m16 - m8 * m13;
			float num17 = m5 * m15 - m7 * m13;
			float num18 = m5 * m14 - m6 * m13;
			result.M13 = (m2 * num13 - m3 * num14 + m4 * num15) * num12;
			result.M23 = (0f - (m * num13 - m3 * num16 + m4 * num17)) * num12;
			result.M33 = (m * num14 - m2 * num16 + m4 * num18) * num12;
			result.M43 = (0f - (m * num15 - m2 * num17 + m3 * num18)) * num12;
			float num19 = m7 * m12 - m8 * m11;
			float num20 = m6 * m12 - m8 * m10;
			float num21 = m6 * m11 - m7 * m10;
			float num22 = m5 * m12 - m8 * m9;
			float num23 = m5 * m11 - m7 * m9;
			float num24 = m5 * m10 - m6 * m9;
			result.M14 = (0f - (m2 * num19 - m3 * num20 + m4 * num21)) * num12;
			result.M24 = (m * num19 - m3 * num22 + m4 * num23) * num12;
			result.M34 = (0f - (m * num20 - m2 * num22 + m4 * num24)) * num12;
			result.M44 = (m * num21 - m2 * num23 + m3 * num24) * num12;
			return true;
		}

		/// <summary>Attempts to extract the scale, translation, and rotation components from the given scale, rotation, or translation matrix. The return value indicates whether the operation succeeded.</summary>
		/// <param name="matrix">The source matrix.</param>
		/// <param name="scale">When this method returns, contains the scaling component of the transformation matrix if the operation succeeded.</param>
		/// <param name="rotation">When this method returns, contains the rotation component of the transformation matrix if the operation succeeded.</param>
		/// <param name="translation">When the method returns, contains the translation component of the transformation matrix if the operation succeeded.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="matrix" /> was decomposed successfully; otherwise,  <see langword="false" />.</returns>
		[SecuritySafeCritical]
		[__DynamicallyInvokable]
		public unsafe static bool Decompose(Matrix4x4 matrix, out Vector3 scale, out Quaternion rotation, out Vector3 translation)
		{
			bool result = true;
			fixed (Vector3* ptr = &scale)
			{
				float* ptr2 = (float*)ptr;
				VectorBasis vectorBasis = default(VectorBasis);
				Vector3** ptr3 = (Vector3**)(&vectorBasis);
				Matrix4x4 identity = Identity;
				CanonicalBasis canonicalBasis = default(CanonicalBasis);
				Vector3* ptr4 = &canonicalBasis.Row0;
				canonicalBasis.Row0 = new Vector3(1f, 0f, 0f);
				canonicalBasis.Row1 = new Vector3(0f, 1f, 0f);
				canonicalBasis.Row2 = new Vector3(0f, 0f, 1f);
				translation = new Vector3(matrix.M41, matrix.M42, matrix.M43);
				*ptr3 = (Vector3*)(&identity.M11);
				ptr3[1] = (Vector3*)(&identity.M21);
				ptr3[2] = (Vector3*)(&identity.M31);
				*(*ptr3) = new Vector3(matrix.M11, matrix.M12, matrix.M13);
				*ptr3[1] = new Vector3(matrix.M21, matrix.M22, matrix.M23);
				*ptr3[2] = new Vector3(matrix.M31, matrix.M32, matrix.M33);
				scale.X = (*ptr3)->Length();
				scale.Y = ptr3[1]->Length();
				scale.Z = ptr3[2]->Length();
				float num = *ptr2;
				float num2 = ptr2[1];
				float num3 = ptr2[2];
				uint num4;
				uint num5;
				uint num6;
				if (num < num2)
				{
					if (num2 < num3)
					{
						num4 = 2u;
						num5 = 1u;
						num6 = 0u;
					}
					else
					{
						num4 = 1u;
						if (num < num3)
						{
							num5 = 2u;
							num6 = 0u;
						}
						else
						{
							num5 = 0u;
							num6 = 2u;
						}
					}
				}
				else if (num < num3)
				{
					num4 = 2u;
					num5 = 0u;
					num6 = 1u;
				}
				else
				{
					num4 = 0u;
					if (num2 < num3)
					{
						num5 = 2u;
						num6 = 1u;
					}
					else
					{
						num5 = 1u;
						num6 = 2u;
					}
				}
				if (ptr2[num4] < 0.0001f)
				{
					*ptr3[num4] = ptr4[num4];
				}
				*ptr3[num4] = Vector3.Normalize(*ptr3[num4]);
				if (ptr2[num5] < 0.0001f)
				{
					float num7 = Math.Abs(ptr3[num4]->X);
					float num8 = Math.Abs(ptr3[num4]->Y);
					float num9 = Math.Abs(ptr3[num4]->Z);
					uint num10 = ((num7 < num8) ? ((!(num8 < num9)) ? ((!(num7 < num9)) ? 2u : 0u) : 0u) : ((num7 < num9) ? 1u : ((num8 < num9) ? 1u : 2u)));
					*ptr3[num5] = Vector3.Cross(*ptr3[num4], ptr4[num10]);
				}
				*ptr3[num5] = Vector3.Normalize(*ptr3[num5]);
				if (ptr2[num6] < 0.0001f)
				{
					*ptr3[num6] = Vector3.Cross(*ptr3[num4], *ptr3[num5]);
				}
				*ptr3[num6] = Vector3.Normalize(*ptr3[num6]);
				float num11 = identity.GetDeterminant();
				if (num11 < 0f)
				{
					ptr2[num4] = 0f - ptr2[num4];
					*ptr3[num4] = -(*ptr3[num4]);
					num11 = 0f - num11;
				}
				num11 -= 1f;
				num11 *= num11;
				if (0.0001f < num11)
				{
					rotation = Quaternion.Identity;
					result = false;
				}
				else
				{
					rotation = Quaternion.CreateFromRotationMatrix(identity);
				}
			}
			return result;
		}

		/// <summary>Transforms the specified matrix by applying the specified Quaternion rotation.</summary>
		/// <param name="value">The matrix to transform.</param>
		/// <param name="rotation">The rotation t apply.</param>
		/// <returns>The transformed matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 Transform(Matrix4x4 value, Quaternion rotation)
		{
			float num = rotation.X + rotation.X;
			float num2 = rotation.Y + rotation.Y;
			float num3 = rotation.Z + rotation.Z;
			float num4 = rotation.W * num;
			float num5 = rotation.W * num2;
			float num6 = rotation.W * num3;
			float num7 = rotation.X * num;
			float num8 = rotation.X * num2;
			float num9 = rotation.X * num3;
			float num10 = rotation.Y * num2;
			float num11 = rotation.Y * num3;
			float num12 = rotation.Z * num3;
			float num13 = 1f - num10 - num12;
			float num14 = num8 - num6;
			float num15 = num9 + num5;
			float num16 = num8 + num6;
			float num17 = 1f - num7 - num12;
			float num18 = num11 - num4;
			float num19 = num9 - num5;
			float num20 = num11 + num4;
			float num21 = 1f - num7 - num10;
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = value.M11 * num13 + value.M12 * num14 + value.M13 * num15;
			result.M12 = value.M11 * num16 + value.M12 * num17 + value.M13 * num18;
			result.M13 = value.M11 * num19 + value.M12 * num20 + value.M13 * num21;
			result.M14 = value.M14;
			result.M21 = value.M21 * num13 + value.M22 * num14 + value.M23 * num15;
			result.M22 = value.M21 * num16 + value.M22 * num17 + value.M23 * num18;
			result.M23 = value.M21 * num19 + value.M22 * num20 + value.M23 * num21;
			result.M24 = value.M24;
			result.M31 = value.M31 * num13 + value.M32 * num14 + value.M33 * num15;
			result.M32 = value.M31 * num16 + value.M32 * num17 + value.M33 * num18;
			result.M33 = value.M31 * num19 + value.M32 * num20 + value.M33 * num21;
			result.M34 = value.M34;
			result.M41 = value.M41 * num13 + value.M42 * num14 + value.M43 * num15;
			result.M42 = value.M41 * num16 + value.M42 * num17 + value.M43 * num18;
			result.M43 = value.M41 * num19 + value.M42 * num20 + value.M43 * num21;
			result.M44 = value.M44;
			return result;
		}

		/// <summary>Transposes the rows and columns of a matrix.</summary>
		/// <param name="matrix">The matrix to transpose.</param>
		/// <returns>The transposed matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 Transpose(Matrix4x4 matrix)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = matrix.M11;
			result.M12 = matrix.M21;
			result.M13 = matrix.M31;
			result.M14 = matrix.M41;
			result.M21 = matrix.M12;
			result.M22 = matrix.M22;
			result.M23 = matrix.M32;
			result.M24 = matrix.M42;
			result.M31 = matrix.M13;
			result.M32 = matrix.M23;
			result.M33 = matrix.M33;
			result.M34 = matrix.M43;
			result.M41 = matrix.M14;
			result.M42 = matrix.M24;
			result.M43 = matrix.M34;
			result.M44 = matrix.M44;
			return result;
		}

		/// <summary>Performs a linear interpolation from one matrix to a second matrix based on a value that specifies the weighting of the second matrix.</summary>
		/// <param name="matrix1">The first matrix.</param>
		/// <param name="matrix2">The second matrix.</param>
		/// <param name="amount">The relative weighting of <paramref name="matrix2" />.</param>
		/// <returns>The interpolated matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 Lerp(Matrix4x4 matrix1, Matrix4x4 matrix2, float amount)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = matrix1.M11 + (matrix2.M11 - matrix1.M11) * amount;
			result.M12 = matrix1.M12 + (matrix2.M12 - matrix1.M12) * amount;
			result.M13 = matrix1.M13 + (matrix2.M13 - matrix1.M13) * amount;
			result.M14 = matrix1.M14 + (matrix2.M14 - matrix1.M14) * amount;
			result.M21 = matrix1.M21 + (matrix2.M21 - matrix1.M21) * amount;
			result.M22 = matrix1.M22 + (matrix2.M22 - matrix1.M22) * amount;
			result.M23 = matrix1.M23 + (matrix2.M23 - matrix1.M23) * amount;
			result.M24 = matrix1.M24 + (matrix2.M24 - matrix1.M24) * amount;
			result.M31 = matrix1.M31 + (matrix2.M31 - matrix1.M31) * amount;
			result.M32 = matrix1.M32 + (matrix2.M32 - matrix1.M32) * amount;
			result.M33 = matrix1.M33 + (matrix2.M33 - matrix1.M33) * amount;
			result.M34 = matrix1.M34 + (matrix2.M34 - matrix1.M34) * amount;
			result.M41 = matrix1.M41 + (matrix2.M41 - matrix1.M41) * amount;
			result.M42 = matrix1.M42 + (matrix2.M42 - matrix1.M42) * amount;
			result.M43 = matrix1.M43 + (matrix2.M43 - matrix1.M43) * amount;
			result.M44 = matrix1.M44 + (matrix2.M44 - matrix1.M44) * amount;
			return result;
		}

		/// <summary>Negates the specified matrix by multiplying all its values by -1.</summary>
		/// <param name="value">The matrix to negate.</param>
		/// <returns>The negated matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 Negate(Matrix4x4 value)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = 0f - value.M11;
			result.M12 = 0f - value.M12;
			result.M13 = 0f - value.M13;
			result.M14 = 0f - value.M14;
			result.M21 = 0f - value.M21;
			result.M22 = 0f - value.M22;
			result.M23 = 0f - value.M23;
			result.M24 = 0f - value.M24;
			result.M31 = 0f - value.M31;
			result.M32 = 0f - value.M32;
			result.M33 = 0f - value.M33;
			result.M34 = 0f - value.M34;
			result.M41 = 0f - value.M41;
			result.M42 = 0f - value.M42;
			result.M43 = 0f - value.M43;
			result.M44 = 0f - value.M44;
			return result;
		}

		/// <summary>Adds each element in one matrix with its corresponding element in a second matrix.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The matrix that contains the summed values of <paramref name="value1" /> and <paramref name="value2" />.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 Add(Matrix4x4 value1, Matrix4x4 value2)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = value1.M11 + value2.M11;
			result.M12 = value1.M12 + value2.M12;
			result.M13 = value1.M13 + value2.M13;
			result.M14 = value1.M14 + value2.M14;
			result.M21 = value1.M21 + value2.M21;
			result.M22 = value1.M22 + value2.M22;
			result.M23 = value1.M23 + value2.M23;
			result.M24 = value1.M24 + value2.M24;
			result.M31 = value1.M31 + value2.M31;
			result.M32 = value1.M32 + value2.M32;
			result.M33 = value1.M33 + value2.M33;
			result.M34 = value1.M34 + value2.M34;
			result.M41 = value1.M41 + value2.M41;
			result.M42 = value1.M42 + value2.M42;
			result.M43 = value1.M43 + value2.M43;
			result.M44 = value1.M44 + value2.M44;
			return result;
		}

		/// <summary>Subtracts each element in a second matrix from its corresponding element in a first matrix.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The matrix containing the values that result from subtracting each element in <paramref name="value2" /> from its corresponding element in <paramref name="value1" />.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 Subtract(Matrix4x4 value1, Matrix4x4 value2)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = value1.M11 - value2.M11;
			result.M12 = value1.M12 - value2.M12;
			result.M13 = value1.M13 - value2.M13;
			result.M14 = value1.M14 - value2.M14;
			result.M21 = value1.M21 - value2.M21;
			result.M22 = value1.M22 - value2.M22;
			result.M23 = value1.M23 - value2.M23;
			result.M24 = value1.M24 - value2.M24;
			result.M31 = value1.M31 - value2.M31;
			result.M32 = value1.M32 - value2.M32;
			result.M33 = value1.M33 - value2.M33;
			result.M34 = value1.M34 - value2.M34;
			result.M41 = value1.M41 - value2.M41;
			result.M42 = value1.M42 - value2.M42;
			result.M43 = value1.M43 - value2.M43;
			result.M44 = value1.M44 - value2.M44;
			return result;
		}

		/// <summary>Returns the matrix that results from multiplying two matrices together.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The product matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 Multiply(Matrix4x4 value1, Matrix4x4 value2)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = value1.M11 * value2.M11 + value1.M12 * value2.M21 + value1.M13 * value2.M31 + value1.M14 * value2.M41;
			result.M12 = value1.M11 * value2.M12 + value1.M12 * value2.M22 + value1.M13 * value2.M32 + value1.M14 * value2.M42;
			result.M13 = value1.M11 * value2.M13 + value1.M12 * value2.M23 + value1.M13 * value2.M33 + value1.M14 * value2.M43;
			result.M14 = value1.M11 * value2.M14 + value1.M12 * value2.M24 + value1.M13 * value2.M34 + value1.M14 * value2.M44;
			result.M21 = value1.M21 * value2.M11 + value1.M22 * value2.M21 + value1.M23 * value2.M31 + value1.M24 * value2.M41;
			result.M22 = value1.M21 * value2.M12 + value1.M22 * value2.M22 + value1.M23 * value2.M32 + value1.M24 * value2.M42;
			result.M23 = value1.M21 * value2.M13 + value1.M22 * value2.M23 + value1.M23 * value2.M33 + value1.M24 * value2.M43;
			result.M24 = value1.M21 * value2.M14 + value1.M22 * value2.M24 + value1.M23 * value2.M34 + value1.M24 * value2.M44;
			result.M31 = value1.M31 * value2.M11 + value1.M32 * value2.M21 + value1.M33 * value2.M31 + value1.M34 * value2.M41;
			result.M32 = value1.M31 * value2.M12 + value1.M32 * value2.M22 + value1.M33 * value2.M32 + value1.M34 * value2.M42;
			result.M33 = value1.M31 * value2.M13 + value1.M32 * value2.M23 + value1.M33 * value2.M33 + value1.M34 * value2.M43;
			result.M34 = value1.M31 * value2.M14 + value1.M32 * value2.M24 + value1.M33 * value2.M34 + value1.M34 * value2.M44;
			result.M41 = value1.M41 * value2.M11 + value1.M42 * value2.M21 + value1.M43 * value2.M31 + value1.M44 * value2.M41;
			result.M42 = value1.M41 * value2.M12 + value1.M42 * value2.M22 + value1.M43 * value2.M32 + value1.M44 * value2.M42;
			result.M43 = value1.M41 * value2.M13 + value1.M42 * value2.M23 + value1.M43 * value2.M33 + value1.M44 * value2.M43;
			result.M44 = value1.M41 * value2.M14 + value1.M42 * value2.M24 + value1.M43 * value2.M34 + value1.M44 * value2.M44;
			return result;
		}

		/// <summary>Returns the matrix that results from scaling all the elements of a specified matrix by a scalar factor.</summary>
		/// <param name="value1">The matrix to scale.</param>
		/// <param name="value2">The scaling value to use.</param>
		/// <returns>The scaled matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 Multiply(Matrix4x4 value1, float value2)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = value1.M11 * value2;
			result.M12 = value1.M12 * value2;
			result.M13 = value1.M13 * value2;
			result.M14 = value1.M14 * value2;
			result.M21 = value1.M21 * value2;
			result.M22 = value1.M22 * value2;
			result.M23 = value1.M23 * value2;
			result.M24 = value1.M24 * value2;
			result.M31 = value1.M31 * value2;
			result.M32 = value1.M32 * value2;
			result.M33 = value1.M33 * value2;
			result.M34 = value1.M34 * value2;
			result.M41 = value1.M41 * value2;
			result.M42 = value1.M42 * value2;
			result.M43 = value1.M43 * value2;
			result.M44 = value1.M44 * value2;
			return result;
		}

		/// <summary>Negates the specified matrix by multiplying all its values by -1.</summary>
		/// <param name="value">The matrix to negate.</param>
		/// <returns>The negated matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 operator -(Matrix4x4 value)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = 0f - value.M11;
			result.M12 = 0f - value.M12;
			result.M13 = 0f - value.M13;
			result.M14 = 0f - value.M14;
			result.M21 = 0f - value.M21;
			result.M22 = 0f - value.M22;
			result.M23 = 0f - value.M23;
			result.M24 = 0f - value.M24;
			result.M31 = 0f - value.M31;
			result.M32 = 0f - value.M32;
			result.M33 = 0f - value.M33;
			result.M34 = 0f - value.M34;
			result.M41 = 0f - value.M41;
			result.M42 = 0f - value.M42;
			result.M43 = 0f - value.M43;
			result.M44 = 0f - value.M44;
			return result;
		}

		/// <summary>Adds each element in one matrix with its corresponding element in a second matrix.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The matrix that contains the summed values.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 operator +(Matrix4x4 value1, Matrix4x4 value2)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = value1.M11 + value2.M11;
			result.M12 = value1.M12 + value2.M12;
			result.M13 = value1.M13 + value2.M13;
			result.M14 = value1.M14 + value2.M14;
			result.M21 = value1.M21 + value2.M21;
			result.M22 = value1.M22 + value2.M22;
			result.M23 = value1.M23 + value2.M23;
			result.M24 = value1.M24 + value2.M24;
			result.M31 = value1.M31 + value2.M31;
			result.M32 = value1.M32 + value2.M32;
			result.M33 = value1.M33 + value2.M33;
			result.M34 = value1.M34 + value2.M34;
			result.M41 = value1.M41 + value2.M41;
			result.M42 = value1.M42 + value2.M42;
			result.M43 = value1.M43 + value2.M43;
			result.M44 = value1.M44 + value2.M44;
			return result;
		}

		/// <summary>Subtracts each element in a second matrix from its corresponding element in a first matrix.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The matrix containing the values that result from subtracting each element in <paramref name="value2" /> from its corresponding element in <paramref name="value1" />.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 operator -(Matrix4x4 value1, Matrix4x4 value2)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = value1.M11 - value2.M11;
			result.M12 = value1.M12 - value2.M12;
			result.M13 = value1.M13 - value2.M13;
			result.M14 = value1.M14 - value2.M14;
			result.M21 = value1.M21 - value2.M21;
			result.M22 = value1.M22 - value2.M22;
			result.M23 = value1.M23 - value2.M23;
			result.M24 = value1.M24 - value2.M24;
			result.M31 = value1.M31 - value2.M31;
			result.M32 = value1.M32 - value2.M32;
			result.M33 = value1.M33 - value2.M33;
			result.M34 = value1.M34 - value2.M34;
			result.M41 = value1.M41 - value2.M41;
			result.M42 = value1.M42 - value2.M42;
			result.M43 = value1.M43 - value2.M43;
			result.M44 = value1.M44 - value2.M44;
			return result;
		}

		/// <summary>Returns the matrix that results from multiplying two matrices together.</summary>
		/// <param name="value1">The first matrix.</param>
		/// <param name="value2">The second matrix.</param>
		/// <returns>The product matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 operator *(Matrix4x4 value1, Matrix4x4 value2)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = value1.M11 * value2.M11 + value1.M12 * value2.M21 + value1.M13 * value2.M31 + value1.M14 * value2.M41;
			result.M12 = value1.M11 * value2.M12 + value1.M12 * value2.M22 + value1.M13 * value2.M32 + value1.M14 * value2.M42;
			result.M13 = value1.M11 * value2.M13 + value1.M12 * value2.M23 + value1.M13 * value2.M33 + value1.M14 * value2.M43;
			result.M14 = value1.M11 * value2.M14 + value1.M12 * value2.M24 + value1.M13 * value2.M34 + value1.M14 * value2.M44;
			result.M21 = value1.M21 * value2.M11 + value1.M22 * value2.M21 + value1.M23 * value2.M31 + value1.M24 * value2.M41;
			result.M22 = value1.M21 * value2.M12 + value1.M22 * value2.M22 + value1.M23 * value2.M32 + value1.M24 * value2.M42;
			result.M23 = value1.M21 * value2.M13 + value1.M22 * value2.M23 + value1.M23 * value2.M33 + value1.M24 * value2.M43;
			result.M24 = value1.M21 * value2.M14 + value1.M22 * value2.M24 + value1.M23 * value2.M34 + value1.M24 * value2.M44;
			result.M31 = value1.M31 * value2.M11 + value1.M32 * value2.M21 + value1.M33 * value2.M31 + value1.M34 * value2.M41;
			result.M32 = value1.M31 * value2.M12 + value1.M32 * value2.M22 + value1.M33 * value2.M32 + value1.M34 * value2.M42;
			result.M33 = value1.M31 * value2.M13 + value1.M32 * value2.M23 + value1.M33 * value2.M33 + value1.M34 * value2.M43;
			result.M34 = value1.M31 * value2.M14 + value1.M32 * value2.M24 + value1.M33 * value2.M34 + value1.M34 * value2.M44;
			result.M41 = value1.M41 * value2.M11 + value1.M42 * value2.M21 + value1.M43 * value2.M31 + value1.M44 * value2.M41;
			result.M42 = value1.M41 * value2.M12 + value1.M42 * value2.M22 + value1.M43 * value2.M32 + value1.M44 * value2.M42;
			result.M43 = value1.M41 * value2.M13 + value1.M42 * value2.M23 + value1.M43 * value2.M33 + value1.M44 * value2.M43;
			result.M44 = value1.M41 * value2.M14 + value1.M42 * value2.M24 + value1.M43 * value2.M34 + value1.M44 * value2.M44;
			return result;
		}

		/// <summary>Returns the matrix that results from scaling all the elements of a specified matrix by a scalar factor.</summary>
		/// <param name="value1">The matrix to scale.</param>
		/// <param name="value2">The scaling value to use.</param>
		/// <returns>The scaled matrix.</returns>
		[__DynamicallyInvokable]
		public static Matrix4x4 operator *(Matrix4x4 value1, float value2)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.M11 = value1.M11 * value2;
			result.M12 = value1.M12 * value2;
			result.M13 = value1.M13 * value2;
			result.M14 = value1.M14 * value2;
			result.M21 = value1.M21 * value2;
			result.M22 = value1.M22 * value2;
			result.M23 = value1.M23 * value2;
			result.M24 = value1.M24 * value2;
			result.M31 = value1.M31 * value2;
			result.M32 = value1.M32 * value2;
			result.M33 = value1.M33 * value2;
			result.M34 = value1.M34 * value2;
			result.M41 = value1.M41 * value2;
			result.M42 = value1.M42 * value2;
			result.M43 = value1.M43 * value2;
			result.M44 = value1.M44 * value2;
			return result;
		}

		/// <summary>Returns a value that indicates whether the specified matrices are equal.</summary>
		/// <param name="value1">The first matrix to compare.</param>
		/// <param name="value2">The second matrix to care</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="value1" /> and <paramref name="value2" /> are equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator ==(Matrix4x4 value1, Matrix4x4 value2)
		{
			if (value1.M11 == value2.M11 && value1.M22 == value2.M22 && value1.M33 == value2.M33 && value1.M44 == value2.M44 && value1.M12 == value2.M12 && value1.M13 == value2.M13 && value1.M14 == value2.M14 && value1.M21 == value2.M21 && value1.M23 == value2.M23 && value1.M24 == value2.M24 && value1.M31 == value2.M31 && value1.M32 == value2.M32 && value1.M34 == value2.M34 && value1.M41 == value2.M41 && value1.M42 == value2.M42)
			{
				return value1.M43 == value2.M43;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether the specified matrices are not equal.</summary>
		/// <param name="value1">The first matrix to compare.</param>
		/// <param name="value2">The second matrix to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="value1" /> and <paramref name="value2" /> are not equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator !=(Matrix4x4 value1, Matrix4x4 value2)
		{
			if (value1.M11 == value2.M11 && value1.M12 == value2.M12 && value1.M13 == value2.M13 && value1.M14 == value2.M14 && value1.M21 == value2.M21 && value1.M22 == value2.M22 && value1.M23 == value2.M23 && value1.M24 == value2.M24 && value1.M31 == value2.M31 && value1.M32 == value2.M32 && value1.M33 == value2.M33 && value1.M34 == value2.M34 && value1.M41 == value2.M41 && value1.M42 == value2.M42 && value1.M43 == value2.M43)
			{
				return value1.M44 != value2.M44;
			}
			return true;
		}

		/// <summary>Returns a value that indicates whether this instance and another 4x4 matrix are equal.</summary>
		/// <param name="other">The other matrix.</param>
		/// <returns>
		///   <see langword="true" /> if the two matrices are equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool Equals(Matrix4x4 other)
		{
			if (M11 == other.M11 && M22 == other.M22 && M33 == other.M33 && M44 == other.M44 && M12 == other.M12 && M13 == other.M13 && M14 == other.M14 && M21 == other.M21 && M23 == other.M23 && M24 == other.M24 && M31 == other.M31 && M32 == other.M32 && M34 == other.M34 && M41 == other.M41 && M42 == other.M42)
			{
				return M43 == other.M43;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether this instance and a specified object are equal.</summary>
		/// <param name="obj">The object to compare with the current instance.</param>
		/// <returns>
		///   <see langword="true" /> if the current instance and <paramref name="obj" /> are equal; otherwise, <see langword="false" />. If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public override bool Equals(object obj)
		{
			if (obj is Matrix4x4)
			{
				return Equals((Matrix4x4)obj);
			}
			return false;
		}

		/// <summary>Returns a string that represents this matrix.</summary>
		/// <returns>The string representation of this matrix.</returns>
		[__DynamicallyInvokable]
		public override string ToString()
		{
			CultureInfo currentCulture = CultureInfo.CurrentCulture;
			return string.Format(currentCulture, "{{ {{M11:{0} M12:{1} M13:{2} M14:{3}}} {{M21:{4} M22:{5} M23:{6} M24:{7}}} {{M31:{8} M32:{9} M33:{10} M34:{11}}} {{M41:{12} M42:{13} M43:{14} M44:{15}}} }}", M11.ToString(currentCulture), M12.ToString(currentCulture), M13.ToString(currentCulture), M14.ToString(currentCulture), M21.ToString(currentCulture), M22.ToString(currentCulture), M23.ToString(currentCulture), M24.ToString(currentCulture), M31.ToString(currentCulture), M32.ToString(currentCulture), M33.ToString(currentCulture), M34.ToString(currentCulture), M41.ToString(currentCulture), M42.ToString(currentCulture), M43.ToString(currentCulture), M44.ToString(currentCulture));
		}

		/// <summary>Returns the hash code for this instance.</summary>
		/// <returns>The hash code.</returns>
		[__DynamicallyInvokable]
		public override int GetHashCode()
		{
			return M11.GetHashCode() + M12.GetHashCode() + M13.GetHashCode() + M14.GetHashCode() + M21.GetHashCode() + M22.GetHashCode() + M23.GetHashCode() + M24.GetHashCode() + M31.GetHashCode() + M32.GetHashCode() + M33.GetHashCode() + M34.GetHashCode() + M41.GetHashCode() + M42.GetHashCode() + M43.GetHashCode() + M44.GetHashCode();
		}
	}
	/// <summary>Represents a plane in three-dimensional space.</summary>
	[__DynamicallyInvokable]
	public struct Plane : IEquatable<Plane>
	{
		/// <summary>The normal vector of the plane.</summary>
		[__DynamicallyInvokable]
		public Vector3 Normal;

		/// <summary>The distance of the plane along its normal from the origin.</summary>
		[__DynamicallyInvokable]
		public float D;

		/// <summary>Creates a <see cref="T:System.Numerics.Plane" /> object from the X, Y, and Z components of its normal, and its distance from the origin on that normal.</summary>
		/// <param name="x">The X component of the normal.</param>
		/// <param name="y">The Y component of the normal.</param>
		/// <param name="z">The Z component of the normal.</param>
		/// <param name="d">The distance of the plane along its normal from the origin.</param>
		[__DynamicallyInvokable]
		public Plane(float x, float y, float z, float d)
		{
			Normal = new Vector3(x, y, z);
			D = d;
		}

		/// <summary>Creates a <see cref="T:System.Numerics.Plane" /> object from a specified normal and the distance along the normal from the origin.</summary>
		/// <param name="normal">The plane's normal vector.</param>
		/// <param name="d">The plane's distance from the origin along its normal vector.</param>
		[__DynamicallyInvokable]
		public Plane(Vector3 normal, float d)
		{
			Normal = normal;
			D = d;
		}

		/// <summary>Creates a <see cref="T:System.Numerics.Plane" /> object from a specified four-dimensional vector.</summary>
		/// <param name="value">A vector whose first three elements describe the normal vector, and whose <see cref="F:System.Numerics.Vector4.W" /> defines the distance along that normal from the origin.</param>
		[__DynamicallyInvokable]
		public Plane(Vector4 value)
		{
			Normal = new Vector3(value.X, value.Y, value.Z);
			D = value.W;
		}

		/// <summary>Creates a <see cref="T:System.Numerics.Plane" /> object that contains three specified points.</summary>
		/// <param name="point1">The first point defining the plane.</param>
		/// <param name="point2">The second point defining the plane.</param>
		/// <param name="point3">The third point defining the plane.</param>
		/// <returns>The plane containing the three points.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Plane CreateFromVertices(Vector3 point1, Vector3 point2, Vector3 point3)
		{
			if (Vector.IsHardwareAccelerated)
			{
				Vector3 vector = point2 - point1;
				Vector3 vector2 = point3 - point1;
				Vector3 value = Vector3.Cross(vector, vector2);
				Vector3 vector3 = Vector3.Normalize(value);
				float d = 0f - Vector3.Dot(vector3, point1);
				return new Plane(vector3, d);
			}
			float num = point2.X - point1.X;
			float num2 = point2.Y - point1.Y;
			float num3 = point2.Z - point1.Z;
			float num4 = point3.X - point1.X;
			float num5 = point3.Y - point1.Y;
			float num6 = point3.Z - point1.Z;
			float num7 = num2 * num6 - num3 * num5;
			float num8 = num3 * num4 - num * num6;
			float num9 = num * num5 - num2 * num4;
			float num10 = num7 * num7 + num8 * num8 + num9 * num9;
			float num11 = 1f / (float)Math.Sqrt(num10);
			Vector3 normal = new Vector3(num7 * num11, num8 * num11, num9 * num11);
			return new Plane(normal, 0f - (normal.X * point1.X + normal.Y * point1.Y + normal.Z * point1.Z));
		}

		/// <summary>Creates a new <see cref="T:System.Numerics.Plane" /> object whose normal vector is the source plane's normal vector normalized.</summary>
		/// <param name="value">The source plane.</param>
		/// <returns>The normalized plane.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Plane Normalize(Plane value)
		{
			if (Vector.IsHardwareAccelerated)
			{
				float num = value.Normal.LengthSquared();
				if (Math.Abs(num - 1f) < 1.1920929E-07f)
				{
					return value;
				}
				float num2 = (float)Math.Sqrt(num);
				return new Plane(value.Normal / num2, value.D / num2);
			}
			float num3 = value.Normal.X * value.Normal.X + value.Normal.Y * value.Normal.Y + value.Normal.Z * value.Normal.Z;
			if (Math.Abs(num3 - 1f) < 1.1920929E-07f)
			{
				return value;
			}
			float num4 = 1f / (float)Math.Sqrt(num3);
			return new Plane(value.Normal.X * num4, value.Normal.Y * num4, value.Normal.Z * num4, value.D * num4);
		}

		/// <summary>Transforms a normalized plane by a 4x4 matrix.</summary>
		/// <param name="plane">The normalized plane to transform.</param>
		/// <param name="matrix">The transformation matrix to apply to <paramref name="plane" />.</param>
		/// <returns>The transformed plane.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Plane Transform(Plane plane, Matrix4x4 matrix)
		{
			Matrix4x4.Invert(matrix, out var result);
			float x = plane.Normal.X;
			float y = plane.Normal.Y;
			float z = plane.Normal.Z;
			float d = plane.D;
			return new Plane(x * result.M11 + y * result.M12 + z * result.M13 + d * result.M14, x * result.M21 + y * result.M22 + z * result.M23 + d * result.M24, x * result.M31 + y * result.M32 + z * result.M33 + d * result.M34, x * result.M41 + y * result.M42 + z * result.M43 + d * result.M44);
		}

		/// <summary>Transforms a normalized plane by a Quaternion rotation.</summary>
		/// <param name="plane">The normalized plane to transform.</param>
		/// <param name="rotation">The Quaternion rotation to apply to the plane.</param>
		/// <returns>A new plane that results from applying the Quaternion rotation.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Plane Transform(Plane plane, Quaternion rotation)
		{
			float num = rotation.X + rotation.X;
			float num2 = rotation.Y + rotation.Y;
			float num3 = rotation.Z + rotation.Z;
			float num4 = rotation.W * num;
			float num5 = rotation.W * num2;
			float num6 = rotation.W * num3;
			float num7 = rotation.X * num;
			float num8 = rotation.X * num2;
			float num9 = rotation.X * num3;
			float num10 = rotation.Y * num2;
			float num11 = rotation.Y * num3;
			float num12 = rotation.Z * num3;
			float num13 = 1f - num10 - num12;
			float num14 = num8 - num6;
			float num15 = num9 + num5;
			float num16 = num8 + num6;
			float num17 = 1f - num7 - num12;
			float num18 = num11 - num4;
			float num19 = num9 - num5;
			float num20 = num11 + num4;
			float num21 = 1f - num7 - num10;
			float x = plane.Normal.X;
			float y = plane.Normal.Y;
			float z = plane.Normal.Z;
			return new Plane(x * num13 + y * num14 + z * num15, x * num16 + y * num17 + z * num18, x * num19 + y * num20 + z * num21, plane.D);
		}

		/// <summary>Calculates the dot product of a plane and a 4-dimensional vector.</summary>
		/// <param name="plane">The plane.</param>
		/// <param name="value">The four-dimensional vector.</param>
		/// <returns>The dot product.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static float Dot(Plane plane, Vector4 value)
		{
			return plane.Normal.X * value.X + plane.Normal.Y * value.Y + plane.Normal.Z * value.Z + plane.D * value.W;
		}

		/// <summary>Returns the dot product of a specified three-dimensional vector and the normal vector of this plane plus the distance (<see cref="F:System.Numerics.Plane.D" />) value of the plane.</summary>
		/// <param name="plane">The plane.</param>
		/// <param name="value">The 3-dimensional vector.</param>
		/// <returns>The dot product.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static float DotCoordinate(Plane plane, Vector3 value)
		{
			if (Vector.IsHardwareAccelerated)
			{
				return Vector3.Dot(plane.Normal, value) + plane.D;
			}
			return plane.Normal.X * value.X + plane.Normal.Y * value.Y + plane.Normal.Z * value.Z + plane.D;
		}

		/// <summary>Returns the dot product of a specified three-dimensional vector and the <see cref="F:System.Numerics.Plane.Normal" /> vector of this plane.</summary>
		/// <param name="plane">The plane.</param>
		/// <param name="value">The three-dimensional vector.</param>
		/// <returns>The dot product.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static float DotNormal(Plane plane, Vector3 value)
		{
			if (Vector.IsHardwareAccelerated)
			{
				return Vector3.Dot(plane.Normal, value);
			}
			return plane.Normal.X * value.X + plane.Normal.Y * value.Y + plane.Normal.Z * value.Z;
		}

		/// <summary>Returns a value that indicates whether two planes are equal.</summary>
		/// <param name="value1">The first plane to compare.</param>
		/// <param name="value2">The second plane to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="value1" /> and <paramref name="value2" /> are equal; otherwise, <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static bool operator ==(Plane value1, Plane value2)
		{
			if (value1.Normal.X == value2.Normal.X && value1.Normal.Y == value2.Normal.Y && value1.Normal.Z == value2.Normal.Z)
			{
				return value1.D == value2.D;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether two planes are not equal.</summary>
		/// <param name="value1">The first plane to compare.</param>
		/// <param name="value2">The second plane to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="value1" /> and <paramref name="value2" /> are not equal; otherwise, <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static bool operator !=(Plane value1, Plane value2)
		{
			if (value1.Normal.X == value2.Normal.X && value1.Normal.Y == value2.Normal.Y && value1.Normal.Z == value2.Normal.Z)
			{
				return value1.D != value2.D;
			}
			return true;
		}

		/// <summary>Returns a value that indicates whether this instance and another plane object are equal.</summary>
		/// <param name="other">The other plane.</param>
		/// <returns>
		///   <see langword="true" /> if the two planes are equal; otherwise, <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public bool Equals(Plane other)
		{
			if (Vector.IsHardwareAccelerated)
			{
				if (Normal.Equals(other.Normal))
				{
					return D == other.D;
				}
				return false;
			}
			if (Normal.X == other.Normal.X && Normal.Y == other.Normal.Y && Normal.Z == other.Normal.Z)
			{
				return D == other.D;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether this instance and a specified object are equal.</summary>
		/// <param name="obj">The object to compare with the current instance.</param>
		/// <returns>
		///   <see langword="true" /> if the current instance and <paramref name="obj" /> are equal; otherwise, <see langword="false" />. If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public override bool Equals(object obj)
		{
			if (obj is Plane)
			{
				return Equals((Plane)obj);
			}
			return false;
		}

		/// <summary>Returns the string representation of this plane object.</summary>
		/// <returns>A string that represents this <see cref="T:System.Numerics.Plane" /> object.</returns>
		[__DynamicallyInvokable]
		public override string ToString()
		{
			CultureInfo currentCulture = CultureInfo.CurrentCulture;
			return string.Format(currentCulture, "{{Normal:{0} D:{1}}}", new object[2]
			{
				Normal.ToString(),
				D.ToString(currentCulture)
			});
		}

		/// <summary>Returns the hash code for this instance.</summary>
		/// <returns>The hash code.</returns>
		[__DynamicallyInvokable]
		public override int GetHashCode()
		{
			return Normal.GetHashCode() + D.GetHashCode();
		}
	}
	/// <summary>Represents a vector that is used to encode three-dimensional physical rotations.</summary>
	[__DynamicallyInvokable]
	public struct Quaternion : IEquatable<Quaternion>
	{
		/// <summary>The X value of the vector component of the quaternion.</summary>
		[__DynamicallyInvokable]
		public float X;

		/// <summary>The Y value of the vector component of the quaternion.</summary>
		[__DynamicallyInvokable]
		public float Y;

		/// <summary>The Z value of the vector component of the quaternion.</summary>
		[__DynamicallyInvokable]
		public float Z;

		/// <summary>The rotation component of the quaternion.</summary>
		[__DynamicallyInvokable]
		public float W;

		/// <summary>Gets a quaternion that represents no rotation.</summary>
		/// <returns>A quaternion whose values are <c>(0, 0, 0, 1)</c>.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Identity
		{
			[__DynamicallyInvokable]
			get
			{
				return new Quaternion(0f, 0f, 0f, 1f);
			}
		}

		/// <summary>Gets a value that indicates whether the current instance is the identity quaternion.</summary>
		/// <returns>
		///   <see langword="true" /> if the current instance is the identity quaternion; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool IsIdentity
		{
			[__DynamicallyInvokable]
			get
			{
				if (X == 0f && Y == 0f && Z == 0f)
				{
					return W == 1f;
				}
				return false;
			}
		}

		/// <summary>Constructs a quaternion from the specified components.</summary>
		/// <param name="x">The value to assign to the X component of the quaternion.</param>
		/// <param name="y">The value to assign to the Y component of the quaternion.</param>
		/// <param name="z">The value to assign to the Z component of the quaternion.</param>
		/// <param name="w">The value to assign to the W component of the quaternion.</param>
		[__DynamicallyInvokable]
		public Quaternion(float x, float y, float z, float w)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}

		/// <summary>Creates a quaternion from the specified vector and rotation parts.</summary>
		/// <param name="vectorPart">The vector part of the quaternion.</param>
		/// <param name="scalarPart">The rotation part of the quaternion.</param>
		[__DynamicallyInvokable]
		public Quaternion(Vector3 vectorPart, float scalarPart)
		{
			X = vectorPart.X;
			Y = vectorPart.Y;
			Z = vectorPart.Z;
			W = scalarPart;
		}

		/// <summary>Calculates the length of the quaternion.</summary>
		/// <returns>The computed length of the quaternion.</returns>
		[__DynamicallyInvokable]
		public float Length()
		{
			float num = X * X + Y * Y + Z * Z + W * W;
			return (float)Math.Sqrt(num);
		}

		/// <summary>Calculates the squared length of the quaternion.</summary>
		/// <returns>The length squared of the quaternion.</returns>
		[__DynamicallyInvokable]
		public float LengthSquared()
		{
			return X * X + Y * Y + Z * Z + W * W;
		}

		/// <summary>Divides each component of a specified <see cref="T:System.Numerics.Quaternion" /> by its length.</summary>
		/// <param name="value">The quaternion to normalize.</param>
		/// <returns>The normalized quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Normalize(Quaternion value)
		{
			float num = value.X * value.X + value.Y * value.Y + value.Z * value.Z + value.W * value.W;
			float num2 = 1f / (float)Math.Sqrt(num);
			Quaternion result = default(Quaternion);
			result.X = value.X * num2;
			result.Y = value.Y * num2;
			result.Z = value.Z * num2;
			result.W = value.W * num2;
			return result;
		}

		/// <summary>Returns the conjugate of a specified quaternion.</summary>
		/// <param name="value">The quaternion.</param>
		/// <returns>A new quaternion that is the conjugate of <see langword="value" />.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Conjugate(Quaternion value)
		{
			Quaternion result = default(Quaternion);
			result.X = 0f - value.X;
			result.Y = 0f - value.Y;
			result.Z = 0f - value.Z;
			result.W = value.W;
			return result;
		}

		/// <summary>Returns the inverse of a quaternion.</summary>
		/// <param name="value">The quaternion.</param>
		/// <returns>The inverted quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Inverse(Quaternion value)
		{
			float num = value.X * value.X + value.Y * value.Y + value.Z * value.Z + value.W * value.W;
			float num2 = 1f / num;
			Quaternion result = default(Quaternion);
			result.X = (0f - value.X) * num2;
			result.Y = (0f - value.Y) * num2;
			result.Z = (0f - value.Z) * num2;
			result.W = value.W * num2;
			return result;
		}

		/// <summary>Creates a quaternion from a unit vector and an angle to rotate around the vector.</summary>
		/// <param name="axis">The unit vector to rotate around.</param>
		/// <param name="angle">The angle, in radians, to rotate around the vector.</param>
		/// <returns>The newly created quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion CreateFromAxisAngle(Vector3 axis, float angle)
		{
			float num = angle * 0.5f;
			float num2 = (float)Math.Sin(num);
			float w = (float)Math.Cos(num);
			Quaternion result = default(Quaternion);
			result.X = axis.X * num2;
			result.Y = axis.Y * num2;
			result.Z = axis.Z * num2;
			result.W = w;
			return result;
		}

		/// <summary>Creates a new quaternion from the given yaw, pitch, and roll.</summary>
		/// <param name="yaw">The yaw angle, in radians, around the Y axis.</param>
		/// <param name="pitch">The pitch angle, in radians, around the X axis.</param>
		/// <param name="roll">The roll angle, in radians, around the Z axis.</param>
		/// <returns>The resulting quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion CreateFromYawPitchRoll(float yaw, float pitch, float roll)
		{
			float num = roll * 0.5f;
			float num2 = (float)Math.Sin(num);
			float num3 = (float)Math.Cos(num);
			float num4 = pitch * 0.5f;
			float num5 = (float)Math.Sin(num4);
			float num6 = (float)Math.Cos(num4);
			float num7 = yaw * 0.5f;
			float num8 = (float)Math.Sin(num7);
			float num9 = (float)Math.Cos(num7);
			Quaternion result = default(Quaternion);
			result.X = num9 * num5 * num3 + num8 * num6 * num2;
			result.Y = num8 * num6 * num3 - num9 * num5 * num2;
			result.Z = num9 * num6 * num2 - num8 * num5 * num3;
			result.W = num9 * num6 * num3 + num8 * num5 * num2;
			return result;
		}

		/// <summary>Creates a quaternion from the specified rotation matrix.</summary>
		/// <param name="matrix">The rotation matrix.</param>
		/// <returns>The newly created quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion CreateFromRotationMatrix(Matrix4x4 matrix)
		{
			float num = matrix.M11 + matrix.M22 + matrix.M33;
			Quaternion result = default(Quaternion);
			if (num > 0f)
			{
				float num2 = (float)Math.Sqrt(num + 1f);
				result.W = num2 * 0.5f;
				num2 = 0.5f / num2;
				result.X = (matrix.M23 - matrix.M32) * num2;
				result.Y = (matrix.M31 - matrix.M13) * num2;
				result.Z = (matrix.M12 - matrix.M21) * num2;
			}
			else if (matrix.M11 >= matrix.M22 && matrix.M11 >= matrix.M33)
			{
				float num3 = (float)Math.Sqrt(1f + matrix.M11 - matrix.M22 - matrix.M33);
				float num4 = 0.5f / num3;
				result.X = 0.5f * num3;
				result.Y = (matrix.M12 + matrix.M21) * num4;
				result.Z = (matrix.M13 + matrix.M31) * num4;
				result.W = (matrix.M23 - matrix.M32) * num4;
			}
			else if (matrix.M22 > matrix.M33)
			{
				float num5 = (float)Math.Sqrt(1f + matrix.M22 - matrix.M11 - matrix.M33);
				float num6 = 0.5f / num5;
				result.X = (matrix.M21 + matrix.M12) * num6;
				result.Y = 0.5f * num5;
				result.Z = (matrix.M32 + matrix.M23) * num6;
				result.W = (matrix.M31 - matrix.M13) * num6;
			}
			else
			{
				float num7 = (float)Math.Sqrt(1f + matrix.M33 - matrix.M11 - matrix.M22);
				float num8 = 0.5f / num7;
				result.X = (matrix.M31 + matrix.M13) * num8;
				result.Y = (matrix.M32 + matrix.M23) * num8;
				result.Z = 0.5f * num7;
				result.W = (matrix.M12 - matrix.M21) * num8;
			}
			return result;
		}

		/// <summary>Calculates the dot product of two quaternions.</summary>
		/// <param name="quaternion1">The first quaternion.</param>
		/// <param name="quaternion2">The second quaternion.</param>
		/// <returns>The dot product.</returns>
		[__DynamicallyInvokable]
		public static float Dot(Quaternion quaternion1, Quaternion quaternion2)
		{
			return quaternion1.X * quaternion2.X + quaternion1.Y * quaternion2.Y + quaternion1.Z * quaternion2.Z + quaternion1.W * quaternion2.W;
		}

		/// <summary>Interpolates between two quaternions, using spherical linear interpolation.</summary>
		/// <param name="quaternion1">The first quaternion.</param>
		/// <param name="quaternion2">The second quaternion.</param>
		/// <param name="amount">The relative weight of the second quaternion in the interpolation.</param>
		/// <returns>The interpolated quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Slerp(Quaternion quaternion1, Quaternion quaternion2, float amount)
		{
			float num = quaternion1.X * quaternion2.X + quaternion1.Y * quaternion2.Y + quaternion1.Z * quaternion2.Z + quaternion1.W * quaternion2.W;
			bool flag = false;
			if (num < 0f)
			{
				flag = true;
				num = 0f - num;
			}
			float num2;
			float num3;
			if (num > 0.999999f)
			{
				num2 = 1f - amount;
				num3 = (flag ? (0f - amount) : amount);
			}
			else
			{
				float num4 = (float)Math.Acos(num);
				float num5 = (float)(1.0 / Math.Sin(num4));
				num2 = (float)Math.Sin((1f - amount) * num4) * num5;
				num3 = (flag ? ((float)(0.0 - Math.Sin(amount * num4)) * num5) : ((float)Math.Sin(amount * num4) * num5));
			}
			Quaternion result = default(Quaternion);
			result.X = num2 * quaternion1.X + num3 * quaternion2.X;
			result.Y = num2 * quaternion1.Y + num3 * quaternion2.Y;
			result.Z = num2 * quaternion1.Z + num3 * quaternion2.Z;
			result.W = num2 * quaternion1.W + num3 * quaternion2.W;
			return result;
		}

		/// <summary>Performs a linear interpolation between two quaternions based on a value that specifies the weighting of the second quaternion.</summary>
		/// <param name="quaternion1">The first quaternion.</param>
		/// <param name="quaternion2">The second quaternion.</param>
		/// <param name="amount">The relative weight of <paramref name="quaternion2" /> in the interpolation.</param>
		/// <returns>The interpolated quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Lerp(Quaternion quaternion1, Quaternion quaternion2, float amount)
		{
			float num = 1f - amount;
			Quaternion result = default(Quaternion);
			float num2 = quaternion1.X * quaternion2.X + quaternion1.Y * quaternion2.Y + quaternion1.Z * quaternion2.Z + quaternion1.W * quaternion2.W;
			if (num2 >= 0f)
			{
				result.X = num * quaternion1.X + amount * quaternion2.X;
				result.Y = num * quaternion1.Y + amount * quaternion2.Y;
				result.Z = num * quaternion1.Z + amount * quaternion2.Z;
				result.W = num * quaternion1.W + amount * quaternion2.W;
			}
			else
			{
				result.X = num * quaternion1.X - amount * quaternion2.X;
				result.Y = num * quaternion1.Y - amount * quaternion2.Y;
				result.Z = num * quaternion1.Z - amount * quaternion2.Z;
				result.W = num * quaternion1.W - amount * quaternion2.W;
			}
			float num3 = result.X * result.X + result.Y * result.Y + result.Z * result.Z + result.W * result.W;
			float num4 = 1f / (float)Math.Sqrt(num3);
			result.X *= num4;
			result.Y *= num4;
			result.Z *= num4;
			result.W *= num4;
			return result;
		}

		/// <summary>Concatenates two quaternions.</summary>
		/// <param name="value1">The first quaternion rotation in the series.</param>
		/// <param name="value2">The second quaternion rotation in the series.</param>
		/// <returns>A new quaternion representing the concatenation of the <paramref name="value1" /> rotation followed by the <paramref name="value2" /> rotation.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Concatenate(Quaternion value1, Quaternion value2)
		{
			float x = value2.X;
			float y = value2.Y;
			float z = value2.Z;
			float w = value2.W;
			float x2 = value1.X;
			float y2 = value1.Y;
			float z2 = value1.Z;
			float w2 = value1.W;
			float num = y * z2 - z * y2;
			float num2 = z * x2 - x * z2;
			float num3 = x * y2 - y * x2;
			float num4 = x * x2 + y * y2 + z * z2;
			Quaternion result = default(Quaternion);
			result.X = x * w2 + x2 * w + num;
			result.Y = y * w2 + y2 * w + num2;
			result.Z = z * w2 + z2 * w + num3;
			result.W = w * w2 - num4;
			return result;
		}

		/// <summary>Reverses the sign of each component of the quaternion.</summary>
		/// <param name="value">The quaternion to negate.</param>
		/// <returns>The negated quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Negate(Quaternion value)
		{
			Quaternion result = default(Quaternion);
			result.X = 0f - value.X;
			result.Y = 0f - value.Y;
			result.Z = 0f - value.Z;
			result.W = 0f - value.W;
			return result;
		}

		/// <summary>Adds each element in one quaternion with its corresponding element in a second quaternion.</summary>
		/// <param name="value1">The first quaternion.</param>
		/// <param name="value2">The second quaternion.</param>
		/// <returns>The quaternion that contains the summed values of <paramref name="value1" /> and <paramref name="value2" />.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Add(Quaternion value1, Quaternion value2)
		{
			Quaternion result = default(Quaternion);
			result.X = value1.X + value2.X;
			result.Y = value1.Y + value2.Y;
			result.Z = value1.Z + value2.Z;
			result.W = value1.W + value2.W;
			return result;
		}

		/// <summary>Subtracts each element in a second quaternion from its corresponding element in a first quaternion.</summary>
		/// <param name="value1">The first quaternion.</param>
		/// <param name="value2">The second quaternion.</param>
		/// <returns>The quaternion containing the values that result from subtracting each element in <paramref name="value2" /> from its corresponding element in <paramref name="value1" />.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Subtract(Quaternion value1, Quaternion value2)
		{
			Quaternion result = default(Quaternion);
			result.X = value1.X - value2.X;
			result.Y = value1.Y - value2.Y;
			result.Z = value1.Z - value2.Z;
			result.W = value1.W - value2.W;
			return result;
		}

		/// <summary>Returns the quaternion that results from multiplying two quaternions together.</summary>
		/// <param name="value1">The first quaternion.</param>
		/// <param name="value2">The second quaternion.</param>
		/// <returns>The product quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Multiply(Quaternion value1, Quaternion value2)
		{
			float x = value1.X;
			float y = value1.Y;
			float z = value1.Z;
			float w = value1.W;
			float x2 = value2.X;
			float y2 = value2.Y;
			float z2 = value2.Z;
			float w2 = value2.W;
			float num = y * z2 - z * y2;
			float num2 = z * x2 - x * z2;
			float num3 = x * y2 - y * x2;
			float num4 = x * x2 + y * y2 + z * z2;
			Quaternion result = default(Quaternion);
			result.X = x * w2 + x2 * w + num;
			result.Y = y * w2 + y2 * w + num2;
			result.Z = z * w2 + z2 * w + num3;
			result.W = w * w2 - num4;
			return result;
		}

		/// <summary>Returns the quaternion that results from scaling all the components of a specified quaternion by a scalar factor.</summary>
		/// <param name="value1">The source quaternion.</param>
		/// <param name="value2">The scalar value.</param>
		/// <returns>The scaled quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Multiply(Quaternion value1, float value2)
		{
			Quaternion result = default(Quaternion);
			result.X = value1.X * value2;
			result.Y = value1.Y * value2;
			result.Z = value1.Z * value2;
			result.W = value1.W * value2;
			return result;
		}

		/// <summary>Divides one quaternion by a second quaternion.</summary>
		/// <param name="value1">The dividend.</param>
		/// <param name="value2">The divisor.</param>
		/// <returns>The quaternion that results from dividing <paramref name="value1" /> by <paramref name="value2" />.</returns>
		[__DynamicallyInvokable]
		public static Quaternion Divide(Quaternion value1, Quaternion value2)
		{
			float x = value1.X;
			float y = value1.Y;
			float z = value1.Z;
			float w = value1.W;
			float num = value2.X * value2.X + value2.Y * value2.Y + value2.Z * value2.Z + value2.W * value2.W;
			float num2 = 1f / num;
			float num3 = (0f - value2.X) * num2;
			float num4 = (0f - value2.Y) * num2;
			float num5 = (0f - value2.Z) * num2;
			float num6 = value2.W * num2;
			float num7 = y * num5 - z * num4;
			float num8 = z * num3 - x * num5;
			float num9 = x * num4 - y * num3;
			float num10 = x * num3 + y * num4 + z * num5;
			Quaternion result = default(Quaternion);
			result.X = x * num6 + num3 * w + num7;
			result.Y = y * num6 + num4 * w + num8;
			result.Z = z * num6 + num5 * w + num9;
			result.W = w * num6 - num10;
			return result;
		}

		/// <summary>Reverses the sign of each component of the quaternion.</summary>
		/// <param name="value">The quaternion to negate.</param>
		/// <returns>The negated quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion operator -(Quaternion value)
		{
			Quaternion result = default(Quaternion);
			result.X = 0f - value.X;
			result.Y = 0f - value.Y;
			result.Z = 0f - value.Z;
			result.W = 0f - value.W;
			return result;
		}

		/// <summary>Adds each element in one quaternion with its corresponding element in a second quaternion.</summary>
		/// <param name="value1">The first quaternion.</param>
		/// <param name="value2">The second quaternion.</param>
		/// <returns>The quaternion that contains the summed values of <paramref name="value1" /> and <paramref name="value2" />.</returns>
		[__DynamicallyInvokable]
		public static Quaternion operator +(Quaternion value1, Quaternion value2)
		{
			Quaternion result = default(Quaternion);
			result.X = value1.X + value2.X;
			result.Y = value1.Y + value2.Y;
			result.Z = value1.Z + value2.Z;
			result.W = value1.W + value2.W;
			return result;
		}

		/// <summary>Subtracts each element in a second quaternion from its corresponding element in a first quaternion.</summary>
		/// <param name="value1">The first quaternion.</param>
		/// <param name="value2">The second quaternion.</param>
		/// <returns>The quaternion containing the values that result from subtracting each element in <paramref name="value2" /> from its corresponding element in <paramref name="value1" />.</returns>
		[__DynamicallyInvokable]
		public static Quaternion operator -(Quaternion value1, Quaternion value2)
		{
			Quaternion result = default(Quaternion);
			result.X = value1.X - value2.X;
			result.Y = value1.Y - value2.Y;
			result.Z = value1.Z - value2.Z;
			result.W = value1.W - value2.W;
			return result;
		}

		/// <summary>Returns the quaternion that results from multiplying two quaternions together.</summary>
		/// <param name="value1">The first quaternion.</param>
		/// <param name="value2">The second quaternion.</param>
		/// <returns>The product quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion operator *(Quaternion value1, Quaternion value2)
		{
			float x = value1.X;
			float y = value1.Y;
			float z = value1.Z;
			float w = value1.W;
			float x2 = value2.X;
			float y2 = value2.Y;
			float z2 = value2.Z;
			float w2 = value2.W;
			float num = y * z2 - z * y2;
			float num2 = z * x2 - x * z2;
			float num3 = x * y2 - y * x2;
			float num4 = x * x2 + y * y2 + z * z2;
			Quaternion result = default(Quaternion);
			result.X = x * w2 + x2 * w + num;
			result.Y = y * w2 + y2 * w + num2;
			result.Z = z * w2 + z2 * w + num3;
			result.W = w * w2 - num4;
			return result;
		}

		/// <summary>Returns the quaternion that results from scaling all the components of a specified quaternion by a scalar factor.</summary>
		/// <param name="value1">The source quaternion.</param>
		/// <param name="value2">The scalar value.</param>
		/// <returns>The scaled quaternion.</returns>
		[__DynamicallyInvokable]
		public static Quaternion operator *(Quaternion value1, float value2)
		{
			Quaternion result = default(Quaternion);
			result.X = value1.X * value2;
			result.Y = value1.Y * value2;
			result.Z = value1.Z * value2;
			result.W = value1.W * value2;
			return result;
		}

		/// <summary>Divides one quaternion by a second quaternion.</summary>
		/// <param name="value1">The dividend.</param>
		/// <param name="value2">The divisor.</param>
		/// <returns>The quaternion that results from dividing <paramref name="value1" /> by <paramref name="value2" />.</returns>
		[__DynamicallyInvokable]
		public static Quaternion operator /(Quaternion value1, Quaternion value2)
		{
			float x = value1.X;
			float y = value1.Y;
			float z = value1.Z;
			float w = value1.W;
			float num = value2.X * value2.X + value2.Y * value2.Y + value2.Z * value2.Z + value2.W * value2.W;
			float num2 = 1f / num;
			float num3 = (0f - value2.X) * num2;
			float num4 = (0f - value2.Y) * num2;
			float num5 = (0f - value2.Z) * num2;
			float num6 = value2.W * num2;
			float num7 = y * num5 - z * num4;
			float num8 = z * num3 - x * num5;
			float num9 = x * num4 - y * num3;
			float num10 = x * num3 + y * num4 + z * num5;
			Quaternion result = default(Quaternion);
			result.X = x * num6 + num3 * w + num7;
			result.Y = y * num6 + num4 * w + num8;
			result.Z = z * num6 + num5 * w + num9;
			result.W = w * num6 - num10;
			return result;
		}

		/// <summary>Returns a value that indicates whether two quaternions are equal.</summary>
		/// <param name="value1">The first quaternion to compare.</param>
		/// <param name="value2">The second quaternion to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the two quaternions are equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator ==(Quaternion value1, Quaternion value2)
		{
			if (value1.X == value2.X && value1.Y == value2.Y && value1.Z == value2.Z)
			{
				return value1.W == value2.W;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether two quaternions are not equal.</summary>
		/// <param name="value1">The first quaternion to compare.</param>
		/// <param name="value2">The second quaternion to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="value1" /> and <paramref name="value2" /> are not equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public static bool operator !=(Quaternion value1, Quaternion value2)
		{
			if (value1.X == value2.X && value1.Y == value2.Y && value1.Z == value2.Z)
			{
				return value1.W != value2.W;
			}
			return true;
		}

		/// <summary>Returns a value that indicates whether this instance and another quaternion are equal.</summary>
		/// <param name="other">The other quaternion.</param>
		/// <returns>
		///   <see langword="true" /> if the two quaternions are equal; otherwise, <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public bool Equals(Quaternion other)
		{
			if (X == other.X && Y == other.Y && Z == other.Z)
			{
				return W == other.W;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether this instance and a specified object are equal.</summary>
		/// <param name="obj">The object to compare with the current instance.</param>
		/// <returns>
		///   <see langword="true" /> if the current instance and <paramref name="obj" /> are equal; otherwise, <see langword="false" />. If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
		[__DynamicallyInvokable]
		public override bool Equals(object obj)
		{
			if (obj is Quaternion)
			{
				return Equals((Quaternion)obj);
			}
			return false;
		}

		/// <summary>Returns a string that represents this quaternion.</summary>
		/// <returns>The string representation of this quaternion.</returns>
		[__DynamicallyInvokable]
		public override string ToString()
		{
			CultureInfo currentCulture = CultureInfo.CurrentCulture;
			return string.Format(currentCulture, "{{X:{0} Y:{1} Z:{2} W:{3}}}", X.ToString(currentCulture), Y.ToString(currentCulture), Z.ToString(currentCulture), W.ToString(currentCulture));
		}

		/// <summary>Returns the hash code for this instance.</summary>
		/// <returns>The hash code.</returns>
		[__DynamicallyInvokable]
		public override int GetHashCode()
		{
			return X.GetHashCode() + Y.GetHashCode() + Z.GetHashCode() + W.GetHashCode();
		}
	}
	/// <summary>Represents a vector with two single-precision floating-point values.</summary>
	[__DynamicallyInvokable]
	public struct Vector2 : IEquatable<Vector2>, IFormattable
	{
		/// <summary>The X component of the vector.</summary>
		[__DynamicallyInvokable]
		public float X;

		/// <summary>The Y component of the vector.</summary>
		[__DynamicallyInvokable]
		public float Y;

		/// <summary>Returns a vector whose 2 elements are equal to zero.</summary>
		/// <returns>A vector whose two elements are equal to zero (that is, it returns the vector <c>(0,0)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector2 Zero
		{
			[__DynamicallyInvokable]
			get
			{
				return default(Vector2);
			}
		}

		/// <summary>Gets a vector whose 2 elements are equal to one.</summary>
		/// <returns>A vector whose two elements are equal to one (that is, it returns the vector <c>(1,1)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector2 One
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector2(1f, 1f);
			}
		}

		/// <summary>Gets the vector (1,0).</summary>
		/// <returns>The vector <c>(1,0)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector2 UnitX
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector2(1f, 0f);
			}
		}

		/// <summary>Gets the vector (0,1).</summary>
		/// <returns>The vector <c>(0,1)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector2 UnitY
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector2(0f, 1f);
			}
		}

		/// <summary>Returns the hash code for this instance.</summary>
		/// <returns>The hash code.</returns>
		[__DynamicallyInvokable]
		public override int GetHashCode()
		{
			int hashCode = X.GetHashCode();
			return HashCodeHelper.CombineHashCodes(hashCode, Y.GetHashCode());
		}

		/// <summary>Returns a value that indicates whether this instance and a specified object are equal.</summary>
		/// <param name="obj">The object to compare with the current instance.</param>
		/// <returns>
		///   <see langword="true" /> if the current instance and <paramref name="obj" /> are equal; otherwise, <see langword="false" />. If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public override bool Equals(object obj)
		{
			if (!(obj is Vector2))
			{
				return false;
			}
			return Equals((Vector2)obj);
		}

		/// <summary>Returns the string representation of the current instance using default formatting.</summary>
		/// <returns>The string representation of the current instance.</returns>
		[__DynamicallyInvokable]
		public override string ToString()
		{
			return ToString("G", CultureInfo.CurrentCulture);
		}

		/// <summary>Returns the string representation of the current instance using the specified format string to format individual elements.</summary>
		/// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
		/// <returns>The string representation of the current instance.</returns>
		[__DynamicallyInvokable]
		public string ToString(string format)
		{
			return ToString(format, CultureInfo.CurrentCulture);
		}

		/// <summary>Returns the string representation of the current instance using the specified format string to format individual elements and the specified format provider to define culture-specific formatting.</summary>
		/// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
		/// <param name="formatProvider">A format provider that supplies culture-specific formatting information.</param>
		/// <returns>The string representation of the current instance.</returns>
		[__DynamicallyInvokable]
		public string ToString(string format, IFormatProvider formatProvider)
		{
			StringBuilder stringBuilder = new StringBuilder();
			string numberGroupSeparator = NumberFormatInfo.GetInstance(formatProvider).NumberGroupSeparator;
			stringBuilder.Append('<');
			stringBuilder.Append(X.ToString(format, formatProvider));
			stringBuilder.Append(numberGroupSeparator);
			stringBuilder.Append(' ');
			stringBuilder.Append(Y.ToString(format, formatProvider));
			stringBuilder.Append('>');
			return stringBuilder.ToString();
		}

		/// <summary>Returns the length of the vector.</summary>
		/// <returns>The vector's length.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public float Length()
		{
			if (Vector.IsHardwareAccelerated)
			{
				float num = Dot(this, this);
				return (float)Math.Sqrt(num);
			}
			float num2 = X * X + Y * Y;
			return (float)Math.Sqrt(num2);
		}

		/// <summary>Returns the length of the vector squared.</summary>
		/// <returns>The vector's length squared.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public float LengthSquared()
		{
			if (Vector.IsHardwareAccelerated)
			{
				return Dot(this, this);
			}
			return X * X + Y * Y;
		}

		/// <summary>Computes the Euclidean distance between the two given points.</summary>
		/// <param name="value1">The first point.</param>
		/// <param name="value2">The second point.</param>
		/// <returns>The distance.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static float Distance(Vector2 value1, Vector2 value2)
		{
			if (Vector.IsHardwareAccelerated)
			{
				Vector2 vector = value1 - value2;
				float num = Dot(vector, vector);
				return (float)Math.Sqrt(num);
			}
			float num2 = value1.X - value2.X;
			float num3 = value1.Y - value2.Y;
			float num4 = num2 * num2 + num3 * num3;
			return (float)Math.Sqrt(num4);
		}

		/// <summary>Returns the Euclidean distance squared between two specified points.</summary>
		/// <param name="value1">The first point.</param>
		/// <param name="value2">The second point.</param>
		/// <returns>The distance squared.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static float DistanceSquared(Vector2 value1, Vector2 value2)
		{
			if (Vector.IsHardwareAccelerated)
			{
				Vector2 vector = value1 - value2;
				return Dot(vector, vector);
			}
			float num = value1.X - value2.X;
			float num2 = value1.Y - value2.Y;
			return num * num + num2 * num2;
		}

		/// <summary>Returns a vector with the same direction as the specified vector, but with a length of one.</summary>
		/// <param name="value">The vector to normalize.</param>
		/// <returns>The normalized vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Normalize(Vector2 value)
		{
			if (Vector.IsHardwareAccelerated)
			{
				float num = value.Length();
				return value / num;
			}
			float num2 = value.X * value.X + value.Y * value.Y;
			float num3 = 1f / (float)Math.Sqrt(num2);
			return new Vector2(value.X * num3, value.Y * num3);
		}

		/// <summary>Returns the reflection of a vector off a surface that has the specified normal.</summary>
		/// <param name="vector">The source vector.</param>
		/// <param name="normal">The normal of the surface being reflected off.</param>
		/// <returns>The reflected vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Reflect(Vector2 vector, Vector2 normal)
		{
			if (Vector.IsHardwareAccelerated)
			{
				float num = Dot(vector, normal);
				return vector - 2f * num * normal;
			}
			float num2 = vector.X * normal.X + vector.Y * normal.Y;
			return new Vector2(vector.X - 2f * num2 * normal.X, vector.Y - 2f * num2 * normal.Y);
		}

		/// <summary>Restricts a vector between a minimum and a maximum value.</summary>
		/// <param name="value1">The vector to restrict.</param>
		/// <param name="min">The minimum value.</param>
		/// <param name="max">The maximum value.</param>
		/// <returns>The restricted vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Clamp(Vector2 value1, Vector2 min, Vector2 max)
		{
			float x = value1.X;
			x = ((x > max.X) ? max.X : x);
			x = ((x < min.X) ? min.X : x);
			float y = value1.Y;
			y = ((y > max.Y) ? max.Y : y);
			y = ((y < min.Y) ? min.Y : y);
			return new Vector2(x, y);
		}

		/// <summary>Performs a linear interpolation between two vectors based on the given weighting.</summary>
		/// <param name="value1">The first vector.</param>
		/// <param name="value2">The second vector.</param>
		/// <param name="amount">A value between 0 and 1 that indicates the weight of <paramref name="value2" />.</param>
		/// <returns>The interpolated vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Lerp(Vector2 value1, Vector2 value2, float amount)
		{
			return new Vector2(value1.X + (value2.X - value1.X) * amount, value1.Y + (value2.Y - value1.Y) * amount);
		}

		/// <summary>Transforms a vector by a specified 3x2 matrix.</summary>
		/// <param name="position">The vector to transform.</param>
		/// <param name="matrix">The transformation matrix.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Transform(Vector2 position, Matrix3x2 matrix)
		{
			return new Vector2(position.X * matrix.M11 + position.Y * matrix.M21 + matrix.M31, position.X * matrix.M12 + position.Y * matrix.M22 + matrix.M32);
		}

		/// <summary>Transforms a vector by a specified 4x4 matrix.</summary>
		/// <param name="position">The vector to transform.</param>
		/// <param name="matrix">The transformation matrix.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Transform(Vector2 position, Matrix4x4 matrix)
		{
			return new Vector2(position.X * matrix.M11 + position.Y * matrix.M21 + matrix.M41, position.X * matrix.M12 + position.Y * matrix.M22 + matrix.M42);
		}

		/// <summary>Transforms a vector normal by the given 3x2 matrix.</summary>
		/// <param name="normal">The source vector.</param>
		/// <param name="matrix">The matrix.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 TransformNormal(Vector2 normal, Matrix3x2 matrix)
		{
			return new Vector2(normal.X * matrix.M11 + normal.Y * matrix.M21, normal.X * matrix.M12 + normal.Y * matrix.M22);
		}

		/// <summary>Transforms a vector normal by the given 4x4 matrix.</summary>
		/// <param name="normal">The source vector.</param>
		/// <param name="matrix">The matrix.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 TransformNormal(Vector2 normal, Matrix4x4 matrix)
		{
			return new Vector2(normal.X * matrix.M11 + normal.Y * matrix.M21, normal.X * matrix.M12 + normal.Y * matrix.M22);
		}

		/// <summary>Transforms a vector by the specified Quaternion rotation value.</summary>
		/// <param name="value">The vector to rotate.</param>
		/// <param name="rotation">The rotation to apply.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Transform(Vector2 value, Quaternion rotation)
		{
			float num = rotation.X + rotation.X;
			float num2 = rotation.Y + rotation.Y;
			float num3 = rotation.Z + rotation.Z;
			float num4 = rotation.W * num3;
			float num5 = rotation.X * num;
			float num6 = rotation.X * num2;
			float num7 = rotation.Y * num2;
			float num8 = rotation.Z * num3;
			return new Vector2(value.X * (1f - num7 - num8) + value.Y * (num6 - num4), value.X * (num6 + num4) + value.Y * (1f - num5 - num8));
		}

		/// <summary>Adds two vectors together.</summary>
		/// <param name="left">The first vector to add.</param>
		/// <param name="right">The second vector to add.</param>
		/// <returns>The summed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Add(Vector2 left, Vector2 right)
		{
			return left + right;
		}

		/// <summary>Subtracts the second vector from the first.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The difference vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Subtract(Vector2 left, Vector2 right)
		{
			return left - right;
		}

		/// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The element-wise product vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Multiply(Vector2 left, Vector2 right)
		{
			return left * right;
		}

		/// <summary>Multiplies a vector by a specified scalar.</summary>
		/// <param name="left">The vector to multiply.</param>
		/// <param name="right">The scalar value.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Multiply(Vector2 left, float right)
		{
			return left * right;
		}

		/// <summary>Multiplies a scalar value by a specified vector.</summary>
		/// <param name="left">The scaled value.</param>
		/// <param name="right">The vector.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Multiply(float left, Vector2 right)
		{
			return left * right;
		}

		/// <summary>Divides the first vector by the second.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The vector resulting from the division.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Divide(Vector2 left, Vector2 right)
		{
			return left / right;
		}

		/// <summary>Divides the specified vector by a specified scalar value.</summary>
		/// <param name="left">The vector.</param>
		/// <param name="divisor">The scalar value.</param>
		/// <returns>The vector that results from the division.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Divide(Vector2 left, float divisor)
		{
			return left / divisor;
		}

		/// <summary>Negates a specified vector.</summary>
		/// <param name="value">The vector to negate.</param>
		/// <returns>The negated vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 Negate(Vector2 value)
		{
			return -value;
		}

		/// <summary>Creates a new <see cref="T:System.Numerics.Vector2" /> object whose two elements have the same value.</summary>
		/// <param name="value">The value to assign to both elements.</param>
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public Vector2(float value)
			: this(value, value)
		{
		}

		/// <summary>Creates a vector whose elements have the specified values.</summary>
		/// <param name="x">The value to assign to the <see cref="F:System.Numerics.Vector2.X" /> field.</param>
		/// <param name="y">The value to assign to the <see cref="F:System.Numerics.Vector2.Y" /> field.</param>
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public Vector2(float x, float y)
		{
			X = x;
			Y = y;
		}

		/// <summary>Copies the elements of the vector to a specified array.</summary>
		/// <param name="array">The destination array.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="array" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
		/// <exception cref="T:System.RankException">
		///   <paramref name="array" /> is multidimensional.</exception>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public void CopyTo(float[] array)
		{
			CopyTo(array, 0);
		}

		/// <summary>Copies the elements of the vector to a specified array starting at a specified index position.</summary>
		/// <param name="array">The destination array.</param>
		/// <param name="index">The index at which to copy the first element of the vector.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="array" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="index" /> is less than zero.  
		/// -or-  
		/// <paramref name="index" /> is greater than or equal to the array length.</exception>
		/// <exception cref="T:System.RankException">
		///   <paramref name="array" /> is multidimensional.</exception>
		[__DynamicallyInvokable]
		public void CopyTo(float[] array, int index)
		{
			if (array == null)
			{
				throw new NullReferenceException(SR.GetString("Arg_NullArgumentNullRef"));
			}
			if (index < 0 || index >= array.Length)
			{
				throw new ArgumentOutOfRangeException(SR.GetString("Arg_ArgumentOutOfRangeException", index));
			}
			if (array.Length - index < 2)
			{
				throw new ArgumentException(SR.GetString("Arg_ElementsInSourceIsGreaterThanDestination", index));
			}
			array[index] = X;
			array[index + 1] = Y;
		}

		/// <summary>Returns a value that indicates whether this instance and another vector are equal.</summary>
		/// <param name="other">The other vector.</param>
		/// <returns>
		///   <see langword="true" /> if the two vectors are equal; otherwise, <see langword="false" />.</returns>
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public bool Equals(Vector2 other)
		{
			if (X == other.X)
			{
				return Y == other.Y;
			}
			return false;
		}

		/// <summary>Returns the dot product of two vectors.</summary>
		/// <param name="value1">The first vector.</param>
		/// <param name="value2">The second vector.</param>
		/// <returns>The dot product.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static float Dot(Vector2 value1, Vector2 value2)
		{
			return value1.X * value2.X + value1.Y * value2.Y;
		}

		/// <summary>Returns a vector whose elements are the minimum of each of the pairs of elements in two specified vectors.</summary>
		/// <param name="value1">The first vector.</param>
		/// <param name="value2">The second vector.</param>
		/// <returns>The minimized vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector2 Min(Vector2 value1, Vector2 value2)
		{
			return new Vector2((value1.X < value2.X) ? value1.X : value2.X, (value1.Y < value2.Y) ? value1.Y : value2.Y);
		}

		/// <summary>Returns a vector whose elements are the maximum of each of the pairs of elements in two specified vectors.</summary>
		/// <param name="value1">The first vector.</param>
		/// <param name="value2">The second vector.</param>
		/// <returns>The maximized vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector2 Max(Vector2 value1, Vector2 value2)
		{
			return new Vector2((value1.X > value2.X) ? value1.X : value2.X, (value1.Y > value2.Y) ? value1.Y : value2.Y);
		}

		/// <summary>Returns a vector whose elements are the absolute values of each of the specified vector's elements.</summary>
		/// <param name="value">A vector.</param>
		/// <returns>The absolute value vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector2 Abs(Vector2 value)
		{
			return new Vector2(Math.Abs(value.X), Math.Abs(value.Y));
		}

		/// <summary>Returns a vector whose elements are the square root of each of a specified vector's elements.</summary>
		/// <param name="value">A vector.</param>
		/// <returns>The square root vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector2 SquareRoot(Vector2 value)
		{
			return new Vector2((float)Math.Sqrt(value.X), (float)Math.Sqrt(value.Y));
		}

		/// <summary>Adds two vectors together.</summary>
		/// <param name="left">The first vector to add.</param>
		/// <param name="right">The second vector to add.</param>
		/// <returns>The summed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector2 operator +(Vector2 left, Vector2 right)
		{
			return new Vector2(left.X + right.X, left.Y + right.Y);
		}

		/// <summary>Subtracts the second vector from the first.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The vector that results from subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector2 operator -(Vector2 left, Vector2 right)
		{
			return new Vector2(left.X - right.X, left.Y - right.Y);
		}

		/// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The element-wise product vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector2 operator *(Vector2 left, Vector2 right)
		{
			return new Vector2(left.X * right.X, left.Y * right.Y);
		}

		/// <summary>Multiples the scalar value by the specified vector.</summary>
		/// <param name="left">The vector.</param>
		/// <param name="right">The scalar value.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector2 operator *(float left, Vector2 right)
		{
			return new Vector2(left, left) * right;
		}

		/// <summary>Multiples the specified vector by the specified scalar value.</summary>
		/// <param name="left">The vector.</param>
		/// <param name="right">The scalar value.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector2 operator *(Vector2 left, float right)
		{
			return left * new Vector2(right, right);
		}

		/// <summary>Divides the first vector by the second.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The vector that results from dividing <paramref name="left" /> by <paramref name="right" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector2 operator /(Vector2 left, Vector2 right)
		{
			return new Vector2(left.X / right.X, left.Y / right.Y);
		}

		/// <summary>Divides the specified vector by a specified scalar value.</summary>
		/// <param name="value1">The vector.</param>
		/// <param name="value2">The scalar value.</param>
		/// <returns>The result of the division.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector2 operator /(Vector2 value1, float value2)
		{
			float num = 1f / value2;
			return new Vector2(value1.X * num, value1.Y * num);
		}

		/// <summary>Negates the specified vector.</summary>
		/// <param name="value">The vector to negate.</param>
		/// <returns>The negated vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector2 operator -(Vector2 value)
		{
			return Zero - value;
		}

		/// <summary>Returns a value that indicates whether each pair of elements in two specified vectors is equal.</summary>
		/// <param name="left">The first vector to compare.</param>
		/// <param name="right">The second vector to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static bool operator ==(Vector2 left, Vector2 right)
		{
			return left.Equals(right);
		}

		/// <summary>Returns a value that indicates whether two specified vectors are not equal.</summary>
		/// <param name="left">The first vector to compare.</param>
		/// <param name="right">The second vector to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static bool operator !=(Vector2 left, Vector2 right)
		{
			return !(left == right);
		}
	}
	/// <summary>Represents a vector with three  single-precision floating-point values.</summary>
	[__DynamicallyInvokable]
	public struct Vector3 : IEquatable<Vector3>, IFormattable
	{
		/// <summary>The X component of the vector.</summary>
		[__DynamicallyInvokable]
		public float X;

		/// <summary>The Y component of the vector.</summary>
		[__DynamicallyInvokable]
		public float Y;

		/// <summary>The Z component of the vector.</summary>
		[__DynamicallyInvokable]
		public float Z;

		/// <summary>Gets a vector whose 3 elements are equal to zero.</summary>
		/// <returns>A vector whose three elements are equal to zero (that is, it returns the vector <c>(0,0,0)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector3 Zero
		{
			[__DynamicallyInvokable]
			get
			{
				return default(Vector3);
			}
		}

		/// <summary>Gets a vector whose 3 elements are equal to one.</summary>
		/// <returns>A vector whose three elements are equal to one (that is, it returns the vector <c>(1,1,1)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector3 One
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector3(1f, 1f, 1f);
			}
		}

		/// <summary>Gets the vector (1,0,0).</summary>
		/// <returns>The vector <c>(1,0,0)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector3 UnitX
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector3(1f, 0f, 0f);
			}
		}

		/// <summary>Gets the vector (0,1,0).</summary>
		/// <returns>The vector <c>(0,1,0)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector3 UnitY
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector3(0f, 1f, 0f);
			}
		}

		/// <summary>Gets the vector (0,0,1).</summary>
		/// <returns>The vector <c>(0,0,1)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector3 UnitZ
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector3(0f, 0f, 1f);
			}
		}

		/// <summary>Returns the hash code for this instance.</summary>
		/// <returns>The hash code.</returns>
		[__DynamicallyInvokable]
		public override int GetHashCode()
		{
			int hashCode = X.GetHashCode();
			hashCode = HashCodeHelper.CombineHashCodes(hashCode, Y.GetHashCode());
			return HashCodeHelper.CombineHashCodes(hashCode, Z.GetHashCode());
		}

		/// <summary>Returns a value that indicates whether this instance and a specified object are equal.</summary>
		/// <param name="obj">The object to compare with the current instance.</param>
		/// <returns>
		///   <see langword="true" /> if the current instance and <paramref name="obj" /> are equal; otherwise, <see langword="false" />. If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public override bool Equals(object obj)
		{
			if (!(obj is Vector3))
			{
				return false;
			}
			return Equals((Vector3)obj);
		}

		/// <summary>Returns the string representation of the current instance using default formatting.</summary>
		/// <returns>The string representation of the current instance.</returns>
		[__DynamicallyInvokable]
		public override string ToString()
		{
			return ToString("G", CultureInfo.CurrentCulture);
		}

		/// <summary>Returns the string representation of the current instance using the specified format string to format individual elements.</summary>
		/// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
		/// <returns>The string representation of the current instance.</returns>
		[__DynamicallyInvokable]
		public string ToString(string format)
		{
			return ToString(format, CultureInfo.CurrentCulture);
		}

		/// <summary>Returns the string representation of the current instance using the specified format string to format individual elements and the specified format provider to define culture-specific formatting.</summary>
		/// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
		/// <param name="formatProvider">A format provider that supplies culture-specific formatting information.</param>
		/// <returns>The string representation of the current instance.</returns>
		[__DynamicallyInvokable]
		public string ToString(string format, IFormatProvider formatProvider)
		{
			StringBuilder stringBuilder = new StringBuilder();
			string numberGroupSeparator = NumberFormatInfo.GetInstance(formatProvider).NumberGroupSeparator;
			stringBuilder.Append('<');
			stringBuilder.Append(((IFormattable)X).ToString(format, formatProvider));
			stringBuilder.Append(numberGroupSeparator);
			stringBuilder.Append(' ');
			stringBuilder.Append(((IFormattable)Y).ToString(format, formatProvider));
			stringBuilder.Append(numberGroupSeparator);
			stringBuilder.Append(' ');
			stringBuilder.Append(((IFormattable)Z).ToString(format, formatProvider));
			stringBuilder.Append('>');
			return stringBuilder.ToString();
		}

		/// <summary>Returns the length of this vector object.</summary>
		/// <returns>The vector's length.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public float Length()
		{
			if (Vector.IsHardwareAccelerated)
			{
				float num = Dot(this, this);
				return (float)Math.Sqrt(num);
			}
			float num2 = X * X + Y * Y + Z * Z;
			return (float)Math.Sqrt(num2);
		}

		/// <summary>Returns the length of the vector squared.</summary>
		/// <returns>The vector's length squared.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public float LengthSquared()
		{
			if (Vector.IsHardwareAccelerated)
			{
				return Dot(this, this);
			}
			return X * X + Y * Y + Z * Z;
		}

		/// <summary>Computes the Euclidean distance between the two given points.</summary>
		/// <param name="value1">The first point.</param>
		/// <param name="value2">The second point.</param>
		/// <returns>The distance.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static float Distance(Vector3 value1, Vector3 value2)
		{
			if (Vector.IsHardwareAccelerated)
			{
				Vector3 vector = value1 - value2;
				float num = Dot(vector, vector);
				return (float)Math.Sqrt(num);
			}
			float num2 = value1.X - value2.X;
			float num3 = value1.Y - value2.Y;
			float num4 = value1.Z - value2.Z;
			float num5 = num2 * num2 + num3 * num3 + num4 * num4;
			return (float)Math.Sqrt(num5);
		}

		/// <summary>Returns the Euclidean distance squared between two specified points.</summary>
		/// <param name="value1">The first point.</param>
		/// <param name="value2">The second point.</param>
		/// <returns>The distance squared.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static float DistanceSquared(Vector3 value1, Vector3 value2)
		{
			if (Vector.IsHardwareAccelerated)
			{
				Vector3 vector = value1 - value2;
				return Dot(vector, vector);
			}
			float num = value1.X - value2.X;
			float num2 = value1.Y - value2.Y;
			float num3 = value1.Z - value2.Z;
			return num * num + num2 * num2 + num3 * num3;
		}

		/// <summary>Returns a vector with the same direction as the specified vector, but with a length of one.</summary>
		/// <param name="value">The vector to normalize.</param>
		/// <returns>The normalized vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Normalize(Vector3 value)
		{
			if (Vector.IsHardwareAccelerated)
			{
				float num = value.Length();
				return value / num;
			}
			float num2 = value.X * value.X + value.Y * value.Y + value.Z * value.Z;
			float num3 = (float)Math.Sqrt(num2);
			return new Vector3(value.X / num3, value.Y / num3, value.Z / num3);
		}

		/// <summary>Computes the cross product of two vectors.</summary>
		/// <param name="vector1">The first vector.</param>
		/// <param name="vector2">The second vector.</param>
		/// <returns>The cross product.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Cross(Vector3 vector1, Vector3 vector2)
		{
			return new Vector3(vector1.Y * vector2.Z - vector1.Z * vector2.Y, vector1.Z * vector2.X - vector1.X * vector2.Z, vector1.X * vector2.Y - vector1.Y * vector2.X);
		}

		/// <summary>Returns the reflection of a vector off a surface that has the specified normal.</summary>
		/// <param name="vector">The source vector.</param>
		/// <param name="normal">The normal of the surface being reflected off.</param>
		/// <returns>The reflected vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Reflect(Vector3 vector, Vector3 normal)
		{
			if (Vector.IsHardwareAccelerated)
			{
				float num = Dot(vector, normal);
				Vector3 vector2 = normal * num * 2f;
				return vector - vector2;
			}
			float num2 = vector.X * normal.X + vector.Y * normal.Y + vector.Z * normal.Z;
			float num3 = normal.X * num2 * 2f;
			float num4 = normal.Y * num2 * 2f;
			float num5 = normal.Z * num2 * 2f;
			return new Vector3(vector.X - num3, vector.Y - num4, vector.Z - num5);
		}

		/// <summary>Restricts a vector between a minimum and a maximum value.</summary>
		/// <param name="value1">The vector to restrict.</param>
		/// <param name="min">The minimum value.</param>
		/// <param name="max">The maximum value.</param>
		/// <returns>The restricted vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Clamp(Vector3 value1, Vector3 min, Vector3 max)
		{
			float x = value1.X;
			x = ((x > max.X) ? max.X : x);
			x = ((x < min.X) ? min.X : x);
			float y = value1.Y;
			y = ((y > max.Y) ? max.Y : y);
			y = ((y < min.Y) ? min.Y : y);
			float z = value1.Z;
			z = ((z > max.Z) ? max.Z : z);
			z = ((z < min.Z) ? min.Z : z);
			return new Vector3(x, y, z);
		}

		/// <summary>Performs a linear interpolation between two vectors based on the given weighting.</summary>
		/// <param name="value1">The first vector.</param>
		/// <param name="value2">The second vector.</param>
		/// <param name="amount">A value between 0 and 1 that indicates the weight of <paramref name="value2" />.</param>
		/// <returns>The interpolated vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Lerp(Vector3 value1, Vector3 value2, float amount)
		{
			if (Vector.IsHardwareAccelerated)
			{
				Vector3 vector = value1 * (1f - amount);
				Vector3 vector2 = value2 * amount;
				return vector + vector2;
			}
			return new Vector3(value1.X + (value2.X - value1.X) * amount, value1.Y + (value2.Y - value1.Y) * amount, value1.Z + (value2.Z - value1.Z) * amount);
		}

		/// <summary>Transforms a vector by a specified 4x4 matrix.</summary>
		/// <param name="position">The vector to transform.</param>
		/// <param name="matrix">The transformation matrix.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Transform(Vector3 position, Matrix4x4 matrix)
		{
			return new Vector3(position.X * matrix.M11 + position.Y * matrix.M21 + position.Z * matrix.M31 + matrix.M41, position.X * matrix.M12 + position.Y * matrix.M22 + position.Z * matrix.M32 + matrix.M42, position.X * matrix.M13 + position.Y * matrix.M23 + position.Z * matrix.M33 + matrix.M43);
		}

		/// <summary>Transforms a vector normal by the given 4x4 matrix.</summary>
		/// <param name="normal">The source vector.</param>
		/// <param name="matrix">The matrix.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 TransformNormal(Vector3 normal, Matrix4x4 matrix)
		{
			return new Vector3(normal.X * matrix.M11 + normal.Y * matrix.M21 + normal.Z * matrix.M31, normal.X * matrix.M12 + normal.Y * matrix.M22 + normal.Z * matrix.M32, normal.X * matrix.M13 + normal.Y * matrix.M23 + normal.Z * matrix.M33);
		}

		/// <summary>Transforms a vector by the specified Quaternion rotation value.</summary>
		/// <param name="value">The vector to rotate.</param>
		/// <param name="rotation">The rotation to apply.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Transform(Vector3 value, Quaternion rotation)
		{
			float num = rotation.X + rotation.X;
			float num2 = rotation.Y + rotation.Y;
			float num3 = rotation.Z + rotation.Z;
			float num4 = rotation.W * num;
			float num5 = rotation.W * num2;
			float num6 = rotation.W * num3;
			float num7 = rotation.X * num;
			float num8 = rotation.X * num2;
			float num9 = rotation.X * num3;
			float num10 = rotation.Y * num2;
			float num11 = rotation.Y * num3;
			float num12 = rotation.Z * num3;
			return new Vector3(value.X * (1f - num10 - num12) + value.Y * (num8 - num6) + value.Z * (num9 + num5), value.X * (num8 + num6) + value.Y * (1f - num7 - num12) + value.Z * (num11 - num4), value.X * (num9 - num5) + value.Y * (num11 + num4) + value.Z * (1f - num7 - num10));
		}

		/// <summary>Adds two vectors together.</summary>
		/// <param name="left">The first vector to add.</param>
		/// <param name="right">The second vector to add.</param>
		/// <returns>The summed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Add(Vector3 left, Vector3 right)
		{
			return left + right;
		}

		/// <summary>Subtracts the second vector from the first.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The difference vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Subtract(Vector3 left, Vector3 right)
		{
			return left - right;
		}

		/// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The element-wise product vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Multiply(Vector3 left, Vector3 right)
		{
			return left * right;
		}

		/// <summary>Multiplies a vector by a specified scalar.</summary>
		/// <param name="left">The vector to multiply.</param>
		/// <param name="right">The scalar value.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Multiply(Vector3 left, float right)
		{
			return left * right;
		}

		/// <summary>Multiplies a scalar value by a specified vector.</summary>
		/// <param name="left">The scaled value.</param>
		/// <param name="right">The vector.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Multiply(float left, Vector3 right)
		{
			return left * right;
		}

		/// <summary>Divides the first vector by the second.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The vector resulting from the division.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Divide(Vector3 left, Vector3 right)
		{
			return left / right;
		}

		/// <summary>Divides the specified vector by a specified scalar value.</summary>
		/// <param name="left">The vector.</param>
		/// <param name="divisor">The scalar value.</param>
		/// <returns>The vector that results from the division.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Divide(Vector3 left, float divisor)
		{
			return left / divisor;
		}

		/// <summary>Negates a specified vector.</summary>
		/// <param name="value">The vector to negate.</param>
		/// <returns>The negated vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 Negate(Vector3 value)
		{
			return -value;
		}

		/// <summary>Creates a new <see cref="T:System.Numerics.Vector3" /> object whose three elements have the same value.</summary>
		/// <param name="value">The value to assign to all three elements.</param>
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public Vector3(float value)
			: this(value, value, value)
		{
		}

		/// <summary>Creates a   new <see cref="T:System.Numerics.Vector3" /> object from the specified <see cref="T:System.Numerics.Vector2" /> object and the specified value.</summary>
		/// <param name="value">The vector with two elements.</param>
		/// <param name="z">The additional value to assign to the <see cref="F:System.Numerics.Vector3.Z" /> field.</param>
		[__DynamicallyInvokable]
		public Vector3(Vector2 value, float z)
			: this(value.X, value.Y, z)
		{
		}

		/// <summary>Creates a vector whose elements have the specified values.</summary>
		/// <param name="x">The value to assign to the <see cref="F:System.Numerics.Vector3.X" /> field.</param>
		/// <param name="y">The value to assign to the <see cref="F:System.Numerics.Vector3.Y" /> field.</param>
		/// <param name="z">The value to assign to the <see cref="F:System.Numerics.Vector3.Z" /> field.</param>
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public Vector3(float x, float y, float z)
		{
			X = x;
			Y = y;
			Z = z;
		}

		/// <summary>Copies the elements of the vector to a specified array.</summary>
		/// <param name="array">The destination array.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="array" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
		/// <exception cref="T:System.RankException">
		///   <paramref name="array" /> is multidimensional.</exception>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public void CopyTo(float[] array)
		{
			CopyTo(array, 0);
		}

		/// <summary>Copies the elements of the vector to a specified array starting at a specified index position.</summary>
		/// <param name="array">The destination array.</param>
		/// <param name="index">The index at which to copy the first element of the vector.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="array" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="index" /> is less than zero.  
		/// -or-  
		/// <paramref name="index" /> is greater than or equal to the array length.</exception>
		/// <exception cref="T:System.RankException">
		///   <paramref name="array" /> is multidimensional.</exception>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public void CopyTo(float[] array, int index)
		{
			if (array == null)
			{
				throw new NullReferenceException(SR.GetString("Arg_NullArgumentNullRef"));
			}
			if (index < 0 || index >= array.Length)
			{
				throw new ArgumentOutOfRangeException(SR.GetString("Arg_ArgumentOutOfRangeException", index));
			}
			if (array.Length - index < 3)
			{
				throw new ArgumentException(SR.GetString("Arg_ElementsInSourceIsGreaterThanDestination", index));
			}
			array[index] = X;
			array[index + 1] = Y;
			array[index + 2] = Z;
		}

		/// <summary>Returns a value that indicates whether this instance and another vector are equal.</summary>
		/// <param name="other">The other vector.</param>
		/// <returns>
		///   <see langword="true" /> if the two vectors are equal; otherwise, <see langword="false" />.</returns>
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public bool Equals(Vector3 other)
		{
			if (X == other.X && Y == other.Y)
			{
				return Z == other.Z;
			}
			return false;
		}

		/// <summary>Returns the dot product of two vectors.</summary>
		/// <param name="vector1">The first vector.</param>
		/// <param name="vector2">The second vector.</param>
		/// <returns>The dot product.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static float Dot(Vector3 vector1, Vector3 vector2)
		{
			return vector1.X * vector2.X + vector1.Y * vector2.Y + vector1.Z * vector2.Z;
		}

		/// <summary>Returns a vector whose elements are the minimum of each of the pairs of elements in two specified vectors.</summary>
		/// <param name="value1">The first vector.</param>
		/// <param name="value2">The second vector.</param>
		/// <returns>The minimized vector.</returns>
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector3 Min(Vector3 value1, Vector3 value2)
		{
			return new Vector3((value1.X < value2.X) ? value1.X : value2.X, (value1.Y < value2.Y) ? value1.Y : value2.Y, (value1.Z < value2.Z) ? value1.Z : value2.Z);
		}

		/// <summary>Returns a vector whose elements are the maximum of each of the pairs of elements in two specified vectors.</summary>
		/// <param name="value1">The first vector.</param>
		/// <param name="value2">The second vector.</param>
		/// <returns>The maximized vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector3 Max(Vector3 value1, Vector3 value2)
		{
			return new Vector3((value1.X > value2.X) ? value1.X : value2.X, (value1.Y > value2.Y) ? value1.Y : value2.Y, (value1.Z > value2.Z) ? value1.Z : value2.Z);
		}

		/// <summary>Returns a vector whose elements are the absolute values of each of the specified vector's elements.</summary>
		/// <param name="value">A vector.</param>
		/// <returns>The absolute value vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector3 Abs(Vector3 value)
		{
			return new Vector3(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z));
		}

		/// <summary>Returns a vector whose elements are the square root of each of a specified vector's elements.</summary>
		/// <param name="value">A vector.</param>
		/// <returns>The square root vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector3 SquareRoot(Vector3 value)
		{
			return new Vector3((float)Math.Sqrt(value.X), (float)Math.Sqrt(value.Y), (float)Math.Sqrt(value.Z));
		}

		/// <summary>Adds two vectors together.</summary>
		/// <param name="left">The first vector to add.</param>
		/// <param name="right">The second vector to add.</param>
		/// <returns>The summed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector3 operator +(Vector3 left, Vector3 right)
		{
			return new Vector3(left.X + right.X, left.Y + right.Y, left.Z + right.Z);
		}

		/// <summary>Subtracts the second vector from the first.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The vector that results from subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector3 operator -(Vector3 left, Vector3 right)
		{
			return new Vector3(left.X - right.X, left.Y - right.Y, left.Z - right.Z);
		}

		/// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The element-wise product vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector3 operator *(Vector3 left, Vector3 right)
		{
			return new Vector3(left.X * right.X, left.Y * right.Y, left.Z * right.Z);
		}

		/// <summary>Multiples the specified vector by the specified scalar value.</summary>
		/// <param name="left">The vector.</param>
		/// <param name="right">The scalar value.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector3 operator *(Vector3 left, float right)
		{
			return left * new Vector3(right);
		}

		/// <summary>Multiples the scalar value by the specified vector.</summary>
		/// <param name="left">The vector.</param>
		/// <param name="right">The scalar value.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector3 operator *(float left, Vector3 right)
		{
			return new Vector3(left) * right;
		}

		/// <summary>Divides the first vector by the second.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The vector that results from dividing <paramref name="left" /> by <paramref name="right" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector3 operator /(Vector3 left, Vector3 right)
		{
			return new Vector3(left.X / right.X, left.Y / right.Y, left.Z / right.Z);
		}

		/// <summary>Divides the specified vector by a specified scalar value.</summary>
		/// <param name="value1">The vector.</param>
		/// <param name="value2">The scalar value.</param>
		/// <returns>The result of the division.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector3 operator /(Vector3 value1, float value2)
		{
			float num = 1f / value2;
			return new Vector3(value1.X * num, value1.Y * num, value1.Z * num);
		}

		/// <summary>Negates the specified vector.</summary>
		/// <param name="value">The vector to negate.</param>
		/// <returns>The negated vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector3 operator -(Vector3 value)
		{
			return Zero - value;
		}

		/// <summary>Returns a value that indicates whether each pair of elements in two specified vectors is equal.</summary>
		/// <param name="left">The first vector to compare.</param>
		/// <param name="right">The second vector to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static bool operator ==(Vector3 left, Vector3 right)
		{
			if (left.X == right.X && left.Y == right.Y)
			{
				return left.Z == right.Z;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether two specified vectors are not equal.</summary>
		/// <param name="left">The first vector to compare.</param>
		/// <param name="right">The second vector to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static bool operator !=(Vector3 left, Vector3 right)
		{
			if (left.X == right.X && left.Y == right.Y)
			{
				return left.Z != right.Z;
			}
			return true;
		}
	}
	/// <summary>Represents a vector with four single-precision floating-point values.</summary>
	[__DynamicallyInvokable]
	public struct Vector4 : IEquatable<Vector4>, IFormattable
	{
		/// <summary>The X component of the vector.</summary>
		[__DynamicallyInvokable]
		public float X;

		/// <summary>The Y component of the vector.</summary>
		[__DynamicallyInvokable]
		public float Y;

		/// <summary>The Z component of the vector.</summary>
		[__DynamicallyInvokable]
		public float Z;

		/// <summary>The W component of the vector.</summary>
		[__DynamicallyInvokable]
		public float W;

		/// <summary>Gets a vector whose 4 elements are equal to zero.</summary>
		/// <returns>A vector whose four elements are equal to zero (that is, it returns the vector <c>(0,0,0,0)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector4 Zero
		{
			[__DynamicallyInvokable]
			get
			{
				return default(Vector4);
			}
		}

		/// <summary>Gets a vector whose 4 elements are equal to one.</summary>
		/// <returns>Returns <see cref="T:System.Numerics.Vector4" />.</returns>
		[__DynamicallyInvokable]
		public static Vector4 One
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector4(1f, 1f, 1f, 1f);
			}
		}

		/// <summary>Gets the vector (1,0,0,0).</summary>
		/// <returns>The vector <c>(1,0,0,0)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector4 UnitX
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector4(1f, 0f, 0f, 0f);
			}
		}

		/// <summary>Gets the vector (0,1,0,0).</summary>
		/// <returns>The vector <c>(0,1,0,0)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector4 UnitY
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector4(0f, 1f, 0f, 0f);
			}
		}

		/// <summary>Gets the vector (0,0,1,0).</summary>
		/// <returns>The vector <c>(0,0,1,0)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector4 UnitZ
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector4(0f, 0f, 1f, 0f);
			}
		}

		/// <summary>Gets the vector (0,0,0,1).</summary>
		/// <returns>The vector <c>(0,0,0,1)</c>.</returns>
		[__DynamicallyInvokable]
		public static Vector4 UnitW
		{
			[__DynamicallyInvokable]
			get
			{
				return new Vector4(0f, 0f, 0f, 1f);
			}
		}

		/// <summary>Returns the hash code for this instance.</summary>
		/// <returns>The hash code.</returns>
		[__DynamicallyInvokable]
		public override int GetHashCode()
		{
			int hashCode = X.GetHashCode();
			hashCode = HashCodeHelper.CombineHashCodes(hashCode, Y.GetHashCode());
			hashCode = HashCodeHelper.CombineHashCodes(hashCode, Z.GetHashCode());
			return HashCodeHelper.CombineHashCodes(hashCode, W.GetHashCode());
		}

		/// <summary>Returns a value that indicates whether this instance and a specified object are equal.</summary>
		/// <param name="obj">The object to compare with the current instance.</param>
		/// <returns>
		///   <see langword="true" /> if the current instance and <paramref name="obj" /> are equal; otherwise, <see langword="false" />. If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public override bool Equals(object obj)
		{
			if (!(obj is Vector4))
			{
				return false;
			}
			return Equals((Vector4)obj);
		}

		/// <summary>Returns the string representation of the current instance using default formatting.</summary>
		/// <returns>The string representation of the current instance.</returns>
		[__DynamicallyInvokable]
		public override string ToString()
		{
			return ToString("G", CultureInfo.CurrentCulture);
		}

		/// <summary>Returns the string representation of the current instance using the specified format string to format individual elements.</summary>
		/// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
		/// <returns>The string representation of the current instance.</returns>
		[__DynamicallyInvokable]
		public string ToString(string format)
		{
			return ToString(format, CultureInfo.CurrentCulture);
		}

		/// <summary>Returns the string representation of the current instance using the specified format string to format individual elements and the specified format provider to define culture-specific formatting.</summary>
		/// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
		/// <param name="formatProvider">A format provider that supplies culture-specific formatting information.</param>
		/// <returns>The string representation of the current instance.</returns>
		[__DynamicallyInvokable]
		public string ToString(string format, IFormatProvider formatProvider)
		{
			StringBuilder stringBuilder = new StringBuilder();
			string numberGroupSeparator = NumberFormatInfo.GetInstance(formatProvider).NumberGroupSeparator;
			stringBuilder.Append('<');
			stringBuilder.Append(X.ToString(format, formatProvider));
			stringBuilder.Append(numberGroupSeparator);
			stringBuilder.Append(' ');
			stringBuilder.Append(Y.ToString(format, formatProvider));
			stringBuilder.Append(numberGroupSeparator);
			stringBuilder.Append(' ');
			stringBuilder.Append(Z.ToString(format, formatProvider));
			stringBuilder.Append(numberGroupSeparator);
			stringBuilder.Append(' ');
			stringBuilder.Append(W.ToString(format, formatProvider));
			stringBuilder.Append('>');
			return stringBuilder.ToString();
		}

		/// <summary>Returns the length of this vector object.</summary>
		/// <returns>The vector's length.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public float Length()
		{
			if (Vector.IsHardwareAccelerated)
			{
				float num = Dot(this, this);
				return (float)Math.Sqrt(num);
			}
			float num2 = X * X + Y * Y + Z * Z + W * W;
			return (float)Math.Sqrt(num2);
		}

		/// <summary>Returns the length of the vector squared.</summary>
		/// <returns>The vector's length squared.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public float LengthSquared()
		{
			if (Vector.IsHardwareAccelerated)
			{
				return Dot(this, this);
			}
			return X * X + Y * Y + Z * Z + W * W;
		}

		/// <summary>Computes the Euclidean distance between the two given points.</summary>
		/// <param name="value1">The first point.</param>
		/// <param name="value2">The second point.</param>
		/// <returns>The distance.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static float Distance(Vector4 value1, Vector4 value2)
		{
			if (Vector.IsHardwareAccelerated)
			{
				Vector4 vector = value1 - value2;
				float num = Dot(vector, vector);
				return (float)Math.Sqrt(num);
			}
			float num2 = value1.X - value2.X;
			float num3 = value1.Y - value2.Y;
			float num4 = value1.Z - value2.Z;
			float num5 = value1.W - value2.W;
			float num6 = num2 * num2 + num3 * num3 + num4 * num4 + num5 * num5;
			return (float)Math.Sqrt(num6);
		}

		/// <summary>Returns the Euclidean distance squared between two specified points.</summary>
		/// <param name="value1">The first point.</param>
		/// <param name="value2">The second point.</param>
		/// <returns>The distance squared.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static float DistanceSquared(Vector4 value1, Vector4 value2)
		{
			if (Vector.IsHardwareAccelerated)
			{
				Vector4 vector = value1 - value2;
				return Dot(vector, vector);
			}
			float num = value1.X - value2.X;
			float num2 = value1.Y - value2.Y;
			float num3 = value1.Z - value2.Z;
			float num4 = value1.W - value2.W;
			return num * num + num2 * num2 + num3 * num3 + num4 * num4;
		}

		/// <summary>Returns a vector with the same direction as the specified vector, but with a length of one.</summary>
		/// <param name="vector">The vector to normalize.</param>
		/// <returns>The normalized vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Normalize(Vector4 vector)
		{
			if (Vector.IsHardwareAccelerated)
			{
				float num = vector.Length();
				return vector / num;
			}
			float num2 = vector.X * vector.X + vector.Y * vector.Y + vector.Z * vector.Z + vector.W * vector.W;
			float num3 = 1f / (float)Math.Sqrt(num2);
			return new Vector4(vector.X * num3, vector.Y * num3, vector.Z * num3, vector.W * num3);
		}

		/// <summary>Restricts a vector between a minimum and a maximum value.</summary>
		/// <param name="value1">The vector to restrict.</param>
		/// <param name="min">The minimum value.</param>
		/// <param name="max">The maximum value.</param>
		/// <returns>The restricted vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Clamp(Vector4 value1, Vector4 min, Vector4 max)
		{
			float x = value1.X;
			x = ((x > max.X) ? max.X : x);
			x = ((x < min.X) ? min.X : x);
			float y = value1.Y;
			y = ((y > max.Y) ? max.Y : y);
			y = ((y < min.Y) ? min.Y : y);
			float z = value1.Z;
			z = ((z > max.Z) ? max.Z : z);
			z = ((z < min.Z) ? min.Z : z);
			float w = value1.W;
			w = ((w > max.W) ? max.W : w);
			w = ((w < min.W) ? min.W : w);
			return new Vector4(x, y, z, w);
		}

		/// <summary>Performs a linear interpolation between two vectors based on the given weighting.</summary>
		/// <param name="value1">The first vector.</param>
		/// <param name="value2">The second vector.</param>
		/// <param name="amount">A value between 0 and 1 that indicates the weight of <paramref name="value2" />.</param>
		/// <returns>The interpolated vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Lerp(Vector4 value1, Vector4 value2, float amount)
		{
			return new Vector4(value1.X + (value2.X - value1.X) * amount, value1.Y + (value2.Y - value1.Y) * amount, value1.Z + (value2.Z - value1.Z) * amount, value1.W + (value2.W - value1.W) * amount);
		}

		/// <summary>Transforms a two-dimensional vector by a specified 4x4 matrix.</summary>
		/// <param name="position">The vector to transform.</param>
		/// <param name="matrix">The transformation matrix.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Transform(Vector2 position, Matrix4x4 matrix)
		{
			return new Vector4(position.X * matrix.M11 + position.Y * matrix.M21 + matrix.M41, position.X * matrix.M12 + position.Y * matrix.M22 + matrix.M42, position.X * matrix.M13 + position.Y * matrix.M23 + matrix.M43, position.X * matrix.M14 + position.Y * matrix.M24 + matrix.M44);
		}

		/// <summary>Transforms a three-dimensional vector by a specified 4x4 matrix.</summary>
		/// <param name="position">The vector to transform.</param>
		/// <param name="matrix">The transformation matrix.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Transform(Vector3 position, Matrix4x4 matrix)
		{
			return new Vector4(position.X * matrix.M11 + position.Y * matrix.M21 + position.Z * matrix.M31 + matrix.M41, position.X * matrix.M12 + position.Y * matrix.M22 + position.Z * matrix.M32 + matrix.M42, position.X * matrix.M13 + position.Y * matrix.M23 + position.Z * matrix.M33 + matrix.M43, position.X * matrix.M14 + position.Y * matrix.M24 + position.Z * matrix.M34 + matrix.M44);
		}

		/// <summary>Transforms a four-dimensional vector by a specified 4x4 matrix.</summary>
		/// <param name="vector">The vector to transform.</param>
		/// <param name="matrix">The transformation matrix.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Transform(Vector4 vector, Matrix4x4 matrix)
		{
			return new Vector4(vector.X * matrix.M11 + vector.Y * matrix.M21 + vector.Z * matrix.M31 + vector.W * matrix.M41, vector.X * matrix.M12 + vector.Y * matrix.M22 + vector.Z * matrix.M32 + vector.W * matrix.M42, vector.X * matrix.M13 + vector.Y * matrix.M23 + vector.Z * matrix.M33 + vector.W * matrix.M43, vector.X * matrix.M14 + vector.Y * matrix.M24 + vector.Z * matrix.M34 + vector.W * matrix.M44);
		}

		/// <summary>Transforms a two-dimensional vector by the specified Quaternion rotation value.</summary>
		/// <param name="value">The vector to rotate.</param>
		/// <param name="rotation">The rotation to apply.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Transform(Vector2 value, Quaternion rotation)
		{
			float num = rotation.X + rotation.X;
			float num2 = rotation.Y + rotation.Y;
			float num3 = rotation.Z + rotation.Z;
			float num4 = rotation.W * num;
			float num5 = rotation.W * num2;
			float num6 = rotation.W * num3;
			float num7 = rotation.X * num;
			float num8 = rotation.X * num2;
			float num9 = rotation.X * num3;
			float num10 = rotation.Y * num2;
			float num11 = rotation.Y * num3;
			float num12 = rotation.Z * num3;
			return new Vector4(value.X * (1f - num10 - num12) + value.Y * (num8 - num6), value.X * (num8 + num6) + value.Y * (1f - num7 - num12), value.X * (num9 - num5) + value.Y * (num11 + num4), 1f);
		}

		/// <summary>Transforms a three-dimensional vector by the specified Quaternion rotation value.</summary>
		/// <param name="value">The vector to rotate.</param>
		/// <param name="rotation">The rotation to apply.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Transform(Vector3 value, Quaternion rotation)
		{
			float num = rotation.X + rotation.X;
			float num2 = rotation.Y + rotation.Y;
			float num3 = rotation.Z + rotation.Z;
			float num4 = rotation.W * num;
			float num5 = rotation.W * num2;
			float num6 = rotation.W * num3;
			float num7 = rotation.X * num;
			float num8 = rotation.X * num2;
			float num9 = rotation.X * num3;
			float num10 = rotation.Y * num2;
			float num11 = rotation.Y * num3;
			float num12 = rotation.Z * num3;
			return new Vector4(value.X * (1f - num10 - num12) + value.Y * (num8 - num6) + value.Z * (num9 + num5), value.X * (num8 + num6) + value.Y * (1f - num7 - num12) + value.Z * (num11 - num4), value.X * (num9 - num5) + value.Y * (num11 + num4) + value.Z * (1f - num7 - num10), 1f);
		}

		/// <summary>Transforms a four-dimensional vector by the specified Quaternion rotation value.</summary>
		/// <param name="value">The vector to rotate.</param>
		/// <param name="rotation">The rotation to apply.</param>
		/// <returns>The transformed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Transform(Vector4 value, Quaternion rotation)
		{
			float num = rotation.X + rotation.X;
			float num2 = rotation.Y + rotation.Y;
			float num3 = rotation.Z + rotation.Z;
			float num4 = rotation.W * num;
			float num5 = rotation.W * num2;
			float num6 = rotation.W * num3;
			float num7 = rotation.X * num;
			float num8 = rotation.X * num2;
			float num9 = rotation.X * num3;
			float num10 = rotation.Y * num2;
			float num11 = rotation.Y * num3;
			float num12 = rotation.Z * num3;
			return new Vector4(value.X * (1f - num10 - num12) + value.Y * (num8 - num6) + value.Z * (num9 + num5), value.X * (num8 + num6) + value.Y * (1f - num7 - num12) + value.Z * (num11 - num4), value.X * (num9 - num5) + value.Y * (num11 + num4) + value.Z * (1f - num7 - num10), value.W);
		}

		/// <summary>Adds two vectors together.</summary>
		/// <param name="left">The first vector to add.</param>
		/// <param name="right">The second vector to add.</param>
		/// <returns>The summed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Add(Vector4 left, Vector4 right)
		{
			return left + right;
		}

		/// <summary>Subtracts the second vector from the first.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The difference vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Subtract(Vector4 left, Vector4 right)
		{
			return left - right;
		}

		/// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The element-wise product vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Multiply(Vector4 left, Vector4 right)
		{
			return left * right;
		}

		/// <summary>Multiplies a vector by a specified scalar.</summary>
		/// <param name="left">The vector to multiply.</param>
		/// <param name="right">The scalar value.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Multiply(Vector4 left, float right)
		{
			return left * new Vector4(right, right, right, right);
		}

		/// <summary>Multiplies a scalar value by a specified vector.</summary>
		/// <param name="left">The scaled value.</param>
		/// <param name="right">The vector.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Multiply(float left, Vector4 right)
		{
			return new Vector4(left, left, left, left) * right;
		}

		/// <summary>Divides the first vector by the second.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The vector resulting from the division.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Divide(Vector4 left, Vector4 right)
		{
			return left / right;
		}

		/// <summary>Divides the specified vector by a specified scalar value.</summary>
		/// <param name="left">The vector.</param>
		/// <param name="divisor">The scalar value.</param>
		/// <returns>The vector that results from the division.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Divide(Vector4 left, float divisor)
		{
			return left / divisor;
		}

		/// <summary>Negates a specified vector.</summary>
		/// <param name="value">The vector to negate.</param>
		/// <returns>The negated vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 Negate(Vector4 value)
		{
			return -value;
		}

		/// <summary>Creates a new <see cref="T:System.Numerics.Vector4" /> object whose four elements have the same value.</summary>
		/// <param name="value">The value to assign to all four elements.</param>
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public Vector4(float value)
			: this(value, value, value, value)
		{
		}

		/// <summary>Creates a vector whose elements have the specified values.</summary>
		/// <param name="x">The value to assign to the <see cref="F:System.Numerics.Vector4.X" /> field.</param>
		/// <param name="y">The value to assign to the <see cref="F:System.Numerics.Vector4.Y" /> field.</param>
		/// <param name="z">The value to assign to the <see cref="F:System.Numerics.Vector4.Z" /> field.</param>
		/// <param name="w">The value to assign to the <see cref="F:System.Numerics.Vector4.W" /> field.</param>
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public Vector4(float x, float y, float z, float w)
		{
			W = w;
			X = x;
			Y = y;
			Z = z;
		}

		/// <summary>Creates a   new <see cref="T:System.Numerics.Vector4" /> object from the specified <see cref="T:System.Numerics.Vector2" /> object and a Z and a W component.</summary>
		/// <param name="value">The vector to use for the X and Y components.</param>
		/// <param name="z">The Z component.</param>
		/// <param name="w">The W component.</param>
		[__DynamicallyInvokable]
		public Vector4(Vector2 value, float z, float w)
		{
			X = value.X;
			Y = value.Y;
			Z = z;
			W = w;
		}

		/// <summary>Constructs a new <see cref="T:System.Numerics.Vector4" /> object from the specified <see cref="T:System.Numerics.Vector3" /> object and a W component.</summary>
		/// <param name="value">The vector to use for the X, Y, and Z components.</param>
		/// <param name="w">The W component.</param>
		[__DynamicallyInvokable]
		public Vector4(Vector3 value, float w)
		{
			X = value.X;
			Y = value.Y;
			Z = value.Z;
			W = w;
		}

		/// <summary>Copies the elements of the vector to a specified array.</summary>
		/// <param name="array">The destination array.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="array" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
		/// <exception cref="T:System.RankException">
		///   <paramref name="array" /> is multidimensional.</exception>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public void CopyTo(float[] array)
		{
			CopyTo(array, 0);
		}

		/// <summary>Copies the elements of the vector to a specified array starting at a specified index position.</summary>
		/// <param name="array">The destination array.</param>
		/// <param name="index">The index at which to copy the first element of the vector.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="array" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="index" /> is less than zero.  
		/// -or-  
		/// <paramref name="index" /> is greater than or equal to the array length.</exception>
		/// <exception cref="T:System.RankException">
		///   <paramref name="array" /> is multidimensional.</exception>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public void CopyTo(float[] array, int index)
		{
			if (array == null)
			{
				throw new NullReferenceException(SR.GetString("Arg_NullArgumentNullRef"));
			}
			if (index < 0 || index >= array.Length)
			{
				throw new ArgumentOutOfRangeException(SR.GetString("Arg_ArgumentOutOfRangeException", index));
			}
			if (array.Length - index < 4)
			{
				throw new ArgumentException(SR.GetString("Arg_ElementsInSourceIsGreaterThanDestination", index));
			}
			array[index] = X;
			array[index + 1] = Y;
			array[index + 2] = Z;
			array[index + 3] = W;
		}

		/// <summary>Returns a value that indicates whether this instance and another vector are equal.</summary>
		/// <param name="other">The other vector.</param>
		/// <returns>
		///   <see langword="true" /> if the two vectors are equal; otherwise, <see langword="false" />.</returns>
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public bool Equals(Vector4 other)
		{
			if (X == other.X && Y == other.Y && Z == other.Z)
			{
				return W == other.W;
			}
			return false;
		}

		/// <summary>Returns the dot product of two vectors.</summary>
		/// <param name="vector1">The first vector.</param>
		/// <param name="vector2">The second vector.</param>
		/// <returns>The dot product.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static float Dot(Vector4 vector1, Vector4 vector2)
		{
			return vector1.X * vector2.X + vector1.Y * vector2.Y + vector1.Z * vector2.Z + vector1.W * vector2.W;
		}

		/// <summary>Returns a vector whose elements are the minimum of each of the pairs of elements in two specified vectors.</summary>
		/// <param name="value1">The first vector.</param>
		/// <param name="value2">The second vector.</param>
		/// <returns>The minimized vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector4 Min(Vector4 value1, Vector4 value2)
		{
			return new Vector4((value1.X < value2.X) ? value1.X : value2.X, (value1.Y < value2.Y) ? value1.Y : value2.Y, (value1.Z < value2.Z) ? value1.Z : value2.Z, (value1.W < value2.W) ? value1.W : value2.W);
		}

		/// <summary>Returns a vector whose elements are the maximum of each of the pairs of elements in two specified vectors.</summary>
		/// <param name="value1">The first vector.</param>
		/// <param name="value2">The second vector.</param>
		/// <returns>The maximized vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector4 Max(Vector4 value1, Vector4 value2)
		{
			return new Vector4((value1.X > value2.X) ? value1.X : value2.X, (value1.Y > value2.Y) ? value1.Y : value2.Y, (value1.Z > value2.Z) ? value1.Z : value2.Z, (value1.W > value2.W) ? value1.W : value2.W);
		}

		/// <summary>Returns a vector whose elements are the absolute values of each of the specified vector's elements.</summary>
		/// <param name="value">A vector.</param>
		/// <returns>The absolute value vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector4 Abs(Vector4 value)
		{
			return new Vector4(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W));
		}

		/// <summary>Returns a vector whose elements are the square root of each of a specified vector's elements.</summary>
		/// <param name="value">A vector.</param>
		/// <returns>The square root vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector4 SquareRoot(Vector4 value)
		{
			return new Vector4((float)Math.Sqrt(value.X), (float)Math.Sqrt(value.Y), (float)Math.Sqrt(value.Z), (float)Math.Sqrt(value.W));
		}

		/// <summary>Adds two vectors together.</summary>
		/// <param name="left">The first vector to add.</param>
		/// <param name="right">The second vector to add.</param>
		/// <returns>The summed vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector4 operator +(Vector4 left, Vector4 right)
		{
			return new Vector4(left.X + right.X, left.Y + right.Y, left.Z + right.Z, left.W + right.W);
		}

		/// <summary>Subtracts the second vector from the first.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The vector that results from subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector4 operator -(Vector4 left, Vector4 right)
		{
			return new Vector4(left.X - right.X, left.Y - right.Y, left.Z - right.Z, left.W - right.W);
		}

		/// <summary>Returns a new vector whose values are the product of each pair of elements in two specified vectors.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The element-wise product vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector4 operator *(Vector4 left, Vector4 right)
		{
			return new Vector4(left.X * right.X, left.Y * right.Y, left.Z * right.Z, left.W * right.W);
		}

		/// <summary>Multiples the specified vector by the specified scalar value.</summary>
		/// <param name="left">The vector.</param>
		/// <param name="right">The scalar value.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector4 operator *(Vector4 left, float right)
		{
			return left * new Vector4(right);
		}

		/// <summary>Multiples the scalar value by the specified vector.</summary>
		/// <param name="left">The vector.</param>
		/// <param name="right">The scalar value.</param>
		/// <returns>The scaled vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector4 operator *(float left, Vector4 right)
		{
			return new Vector4(left) * right;
		}

		/// <summary>Divides the first vector by the second.</summary>
		/// <param name="left">The first vector.</param>
		/// <param name="right">The second vector.</param>
		/// <returns>The vector that results from dividing <paramref name="left" /> by <paramref name="right" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector4 operator /(Vector4 left, Vector4 right)
		{
			return new Vector4(left.X / right.X, left.Y / right.Y, left.Z / right.Z, left.W / right.W);
		}

		/// <summary>Divides the specified vector by a specified scalar value.</summary>
		/// <param name="value1">The vector.</param>
		/// <param name="value2">The scalar value.</param>
		/// <returns>The result of the division.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static Vector4 operator /(Vector4 value1, float value2)
		{
			float num = 1f / value2;
			return new Vector4(value1.X * num, value1.Y * num, value1.Z * num, value1.W * num);
		}

		/// <summary>Negates the specified vector.</summary>
		/// <param name="value">The vector to negate.</param>
		/// <returns>The negated vector.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static Vector4 operator -(Vector4 value)
		{
			return Zero - value;
		}

		/// <summary>Returns a value that indicates whether each pair of elements in two specified vectors is equal.</summary>
		/// <param name="left">The first vector to compare.</param>
		/// <param name="right">The second vector to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[JitIntrinsic]
		[__DynamicallyInvokable]
		public static bool operator ==(Vector4 left, Vector4 right)
		{
			return left.Equals(right);
		}

		/// <summary>Returns a value that indicates whether two specified vectors are not equal.</summary>
		/// <param name="left">The first vector to compare.</param>
		/// <param name="right">The second vector to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[__DynamicallyInvokable]
		public static bool operator !=(Vector4 left, Vector4 right)
		{
			return !(left == right);
		}
	}
	internal static class Vector
	{
		[JitIntrinsic]
		public static bool IsHardwareAccelerated => false;
	}
}
[AttributeUsage(AttributeTargets.All, Inherited = false)]
internal sealed class __DynamicallyInvokableAttribute : Attribute
{
}
