
// C:\WINDOWS\Microsoft.NET\assembly\GAC_MSIL\System.Security\v4.0_4.0.0.0__b03f5f7f11d50a3a\System.Security.dll
// System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v4.0.30319
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293

#define TRACE
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Cryptography.Pkcs;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Xml;
using System.Security.Permissions;
using System.Security.Policy;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Xsl;
using Microsoft.Win32;
using Microsoft.Win32.SafeHandles;

[assembly: CompilationRelaxations(8)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: ComVisible(false)]
[assembly: CLSCompliant(true)]
[assembly: AllowPartiallyTrustedCallers]
[assembly: SecurityRules(SecurityRuleSet.Level2, SkipVerificationInFullTrust = true)]
[assembly: AssemblyTitle("System.Security.dll")]
[assembly: AssemblyDescription("System.Security.dll")]
[assembly: AssemblyDefaultAlias("System.Security.dll")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyFileVersion("4.8.9037.0")]
[assembly: AssemblyInformationalVersion("4.8.9037.0")]
[assembly: SatelliteContractVersion("4.0.0.0")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: AssemblyDelaySign(true)]
[assembly: AssemblyKeyFile("f:\\dd\\tools\\devdiv\\FinalPublicKey.snk")]
[assembly: AssemblySignatureKey("002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3", "a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d")]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: DefaultDllImportSearchPaths(DllImportSearchPath.System32 | DllImportSearchPath.AssemblyDirectory)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("4.0.0.0")]
[module: UnverifiableCode]
internal static class FXAssembly
{
	internal const string Version = "4.0.0.0";
}
internal static class ThisAssembly
{
	internal const string Title = "System.Security.dll";

	internal const string Description = "System.Security.dll";

	internal const string DefaultAlias = "System.Security.dll";

	internal const string Copyright = "© Microsoft Corporation.  All rights reserved.";

	internal const string Version = "4.0.0.0";

	internal const string InformationalVersion = "4.8.9037.0";

	internal const string DailyBuildNumberStr = "30319";

	internal const string BuildRevisionStr = "0";

	internal const int DailyBuildNumber = 30319;
}
internal static class AssemblyRef
{
	internal const string EcmaPublicKey = "b77a5c561934e089";

	internal const string EcmaPublicKeyToken = "b77a5c561934e089";

	internal const string EcmaPublicKeyFull = "00000000000000000400000000000000";

	internal const string SilverlightPublicKey = "31bf3856ad364e35";

	internal const string SilverlightPublicKeyToken = "31bf3856ad364e35";

	internal const string SilverlightPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9";

	internal const string SilverlightPlatformPublicKey = "7cec85d7bea7798e";

	internal const string SilverlightPlatformPublicKeyToken = "7cec85d7bea7798e";

	internal const string SilverlightPlatformPublicKeyFull = "00240000048000009400000006020000002400005253413100040000010001008D56C76F9E8649383049F383C44BE0EC204181822A6C31CF5EB7EF486944D032188EA1D3920763712CCB12D75FB77E9811149E6148E5D32FBAAB37611C1878DDC19E20EF135D0CB2CFF2BFEC3D115810C3D9069638FE4BE215DBF795861920E5AB6F7DB2E2CEEF136AC23D5DD2BF031700AEC232F6C6B1C785B4305C123B37AB";

	internal const string PlatformPublicKey = "b77a5c561934e089";

	internal const string PlatformPublicKeyToken = "b77a5c561934e089";

	internal const string PlatformPublicKeyFull = "00000000000000000400000000000000";

	internal const string Mscorlib = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemData = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemDataOracleClient = "System.Data.OracleClient, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string System = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemCore = "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemNumerics = "System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemRuntimeRemoting = "System.Runtime.Remoting, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemThreadingTasksDataflow = "System.Threading.Tasks.Dataflow, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWindowsForms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemXml = "System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string MicrosoftPublicKey = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyToken = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyFull = "002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293";

	internal const string SharedLibPublicKey = "31bf3856ad364e35";

	internal const string SharedLibPublicKeyToken = "31bf3856ad364e35";

	internal const string SharedLibPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9";

	internal const string SystemComponentModelDataAnnotations = "System.ComponentModel.DataAnnotations, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemConfiguration = "System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemConfigurationInstall = "System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDeployment = "System.Deployment, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDesign = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDirectoryServices = "System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawingDesign = "System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemEnterpriseServices = "System.EnterpriseServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemManagement = "System.Management, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemMessaging = "System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemNetHttp = "System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemNetHttpWebRequest = "System.Net.Http.WebRequest, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemRuntimeSerializationFormattersSoap = "System.Runtime.Serialization.Formatters.Soap, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemRuntimeWindowsRuntime = "System.Runtime.WindowsRuntime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemRuntimeWindowsRuntimeUIXaml = "System.Runtime.WindowsRuntimeUIXaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemSecurity = "System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemServiceModelWeb = "System.ServiceModel.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemServiceProcess = "System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWeb = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebAbstractions = "System.Web.Abstractions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebDynamicData = "System.Web.DynamicData, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebDynamicDataDesign = "System.Web.DynamicData.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebEntityDesign = "System.Web.Entity.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWebExtensions = "System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebExtensionsDesign = "System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebMobile = "System.Web.Mobile, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRegularExpressions = "System.Web.RegularExpressions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRouting = "System.Web.Routing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebServices = "System.Web.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string WindowsBase = "WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string MicrosoftVisualStudio = "Microsoft.VisualStudio, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWindowsForms = "Microsoft.VisualStudio.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string VJSharpCodeProvider = "VJSharpCodeProvider, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string ASPBrowserCapsPublicKey = "b7bd7678b977bd8f";

	internal const string ASPBrowserCapsFactory = "ASP.BrowserCapsFactory, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b7bd7678b977bd8f";

	internal const string MicrosoftVSDesigner = "Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWeb = "Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftWebDesign = "Microsoft.Web.Design.Client, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVSDesignerMobile = "Microsoft.VSDesigner.Mobile, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftJScript = "Microsoft.JScript, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
}
namespace System
{
	internal static class LocalAppContextSwitches
	{
		private static int _xmlUseInsecureHashAlgorithms;

		internal static readonly string SwitchXmlUseInsecureHashAlgorithms = "Switch.System.Security.Cryptography.Xml.UseInsecureHashAlgorithms";

		private static int _signedXmlUseLegacyCertificatePrivateKey;

		internal static readonly string SwitchSignedXmlUseLegacyCertificatePrivateKey = "Switch.System.Security.Cryptography.Xml.SignedXmlUseLegacyCertificatePrivateKey";

		private static int _cmsUseInsecureHashAlgorithms;

		internal static readonly string SwitchCmsUseInsecureHashAlgorithms = "Switch.System.Security.Cryptography.Pkcs.UseInsecureHashAlgorithms";

		private static int _envelopedCmsUseLegacyDefaultAlgorithm;

		internal static readonly string SwitchEnvelopedCmsUseLegacyDefaultAlgorithm = "Switch.System.Security.Cryptography.Pkcs.EnvelopedCmsUseLegacyDefaultAlgorithm";

		public static bool XmlUseInsecureHashAlgorithms
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return LocalAppContext.GetCachedSwitchValue(SwitchXmlUseInsecureHashAlgorithms, ref _xmlUseInsecureHashAlgorithms);
			}
		}

		public static bool SignedXmlUseLegacyCertificatePrivateKey
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return LocalAppContext.GetCachedSwitchValue(SwitchSignedXmlUseLegacyCertificatePrivateKey, ref _signedXmlUseLegacyCertificatePrivateKey);
			}
		}

		public static bool CmsUseInsecureHashAlgorithms
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return LocalAppContext.GetCachedSwitchValue(SwitchCmsUseInsecureHashAlgorithms, ref _cmsUseInsecureHashAlgorithms);
			}
		}

		public static bool EnvelopedCmsUseLegacyDefaultAlgorithm
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return LocalAppContext.GetCachedSwitchValue(SwitchEnvelopedCmsUseLegacyDefaultAlgorithm, ref _envelopedCmsUseLegacyDefaultAlgorithm);
			}
		}
	}
	internal static class AppContextDefaultValues
	{
		public static void PopulateDefaultValues()
		{
			ParseTargetFrameworkName(out var identifier, out var profile, out var version);
			PopulateDefaultValuesPartial(identifier, profile, version);
		}

		private static void ParseTargetFrameworkName(out string identifier, out string profile, out int version)
		{
			string targetFrameworkName = AppDomain.CurrentDomain.SetupInformation.TargetFrameworkName;
			if (!TryParseFrameworkName(targetFrameworkName, out identifier, out version, out profile))
			{
				identifier = ".NETFramework";
				version = 40000;
				profile = string.Empty;
			}
		}

		private static bool TryParseFrameworkName(string frameworkName, out string identifier, out int version, out string profile)
		{
			identifier = (profile = string.Empty);
			version = 0;
			if (frameworkName == null || frameworkName.Length == 0)
			{
				return false;
			}
			string[] array = frameworkName.Split(',');
			version = 0;
			if (array.Length < 2 || array.Length > 3)
			{
				return false;
			}
			identifier = array[0].Trim();
			if (identifier.Length == 0)
			{
				return false;
			}
			bool flag = false;
			profile = null;
			for (int i = 1; i < array.Length; i++)
			{
				string[] array2 = array[i].Split('=');
				if (array2.Length != 2)
				{
					return false;
				}
				string text = array2[0].Trim();
				string text2 = array2[1].Trim();
				if (text.Equals("Version", StringComparison.OrdinalIgnoreCase))
				{
					flag = true;
					if (text2.Length > 0 && (text2[0] == 'v' || text2[0] == 'V'))
					{
						text2 = text2.Substring(1);
					}
					Version version2 = new Version(text2);
					version = version2.Major * 10000;
					if (version2.Minor > 0)
					{
						version += version2.Minor * 100;
					}
					if (version2.Build > 0)
					{
						version += version2.Build;
					}
				}
				else
				{
					if (!text.Equals("Profile", StringComparison.OrdinalIgnoreCase))
					{
						return false;
					}
					if (!string.IsNullOrEmpty(text2))
					{
						profile = text2;
					}
				}
			}
			if (!flag)
			{
				return false;
			}
			return true;
		}

		private static void PopulateDefaultValuesPartial(string platformIdentifier, string profile, int version)
		{
			if (platformIdentifier == ".NETCore" || platformIdentifier == ".NETFramework")
			{
				if (version <= 40700)
				{
					LocalAppContext.DefineSwitchDefault(LocalAppContextSwitches.SwitchXmlUseInsecureHashAlgorithms, initialValue: true);
					LocalAppContext.DefineSwitchDefault(LocalAppContextSwitches.SwitchCmsUseInsecureHashAlgorithms, initialValue: true);
				}
				if (version <= 40702)
				{
					LocalAppContext.DefineSwitchDefault(LocalAppContextSwitches.SwitchEnvelopedCmsUseLegacyDefaultAlgorithm, initialValue: true);
				}
			}
		}
	}
	internal static class LocalAppContext
	{
		private delegate bool TryGetSwitchDelegate(string switchName, out bool value);

		private static TryGetSwitchDelegate TryGetSwitchFromCentralAppContext;

		private static bool s_canForwardCalls;

		private static Dictionary<string, bool> s_switchMap;

		private static readonly object s_syncLock;

		private static bool DisableCaching { get; set; }

		static LocalAppContext()
		{
			s_switchMap = new Dictionary<string, bool>();
			s_syncLock = new object();
			s_canForwardCalls = SetupDelegate();
			AppContextDefaultValues.PopulateDefaultValues();
			DisableCaching = IsSwitchEnabled("TestSwitch.LocalAppContext.DisableCaching");
		}

		public static bool IsSwitchEnabled(string switchName)
		{
			if (s_canForwardCalls && TryGetSwitchFromCentralAppContext(switchName, out var value))
			{
				return value;
			}
			return IsSwitchEnabledLocal(switchName);
		}

		private static bool IsSwitchEnabledLocal(string switchName)
		{
			bool flag;
			bool value;
			lock (s_switchMap)
			{
				flag = s_switchMap.TryGetValue(switchName, out value);
			}
			if (flag)
			{
				return value;
			}
			return false;
		}

		private static bool SetupDelegate()
		{
			Type type = typeof(object).Assembly.GetType("System.AppContext");
			if (type == null)
			{
				return false;
			}
			MethodInfo method = type.GetMethod("TryGetSwitch", BindingFlags.Static | BindingFlags.Public, null, new Type[2]
			{
				typeof(string),
				typeof(bool).MakeByRefType()
			}, null);
			if (method == null)
			{
				return false;
			}
			TryGetSwitchFromCentralAppContext = (TryGetSwitchDelegate)Delegate.CreateDelegate(typeof(TryGetSwitchDelegate), method);
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool GetCachedSwitchValue(string switchName, ref int switchValue)
		{
			if (switchValue < 0)
			{
				return false;
			}
			if (switchValue > 0)
			{
				return true;
			}
			return GetCachedSwitchValueInternal(switchName, ref switchValue);
		}

		private static bool GetCachedSwitchValueInternal(string switchName, ref int switchValue)
		{
			if (DisableCaching)
			{
				return IsSwitchEnabled(switchName);
			}
			bool flag = IsSwitchEnabled(switchName);
			switchValue = (flag ? 1 : (-1));
			return flag;
		}

		internal static void DefineSwitchDefault(string switchName, bool initialValue)
		{
			s_switchMap[switchName] = initialValue;
		}
	}
}
namespace System.Security
{
	internal static class SecurityResources
	{
		private static volatile ResourceManager s_resMgr;

		internal static string GetResourceString(string key)
		{
			if (s_resMgr == null)
			{
				s_resMgr = new ResourceManager("system.security", typeof(SecurityResources).Assembly);
			}
			return s_resMgr.GetString(key, null);
		}
	}
}
namespace System.Security.Permissions
{
	/// <summary>Controls the ability to access encrypted data and memory. This class cannot be inherited.</summary>
	[Serializable]
	public sealed class DataProtectionPermission : CodeAccessPermission, IUnrestrictedPermission
	{
		private DataProtectionPermissionFlags m_flags;

		/// <summary>Gets or sets the data and memory protection flags.</summary>
		/// <returns>A bitwise combination of the <see cref="T:System.Security.Permissions.DataProtectionPermissionFlags" /> values.</returns>
		/// <exception cref="T:System.ArgumentException">The specified value is not a valid combination of the <see cref="T:System.Security.Permissions.DataProtectionPermissionFlags" /> values.</exception>
		public DataProtectionPermissionFlags Flags
		{
			get
			{
				return m_flags;
			}
			set
			{
				VerifyFlags(value);
				m_flags = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Permissions.DataProtectionPermission" /> class with the specified permission state.</summary>
		/// <param name="state">One of the <see cref="T:System.Security.Permissions.PermissionState" /> values.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="state" /> is not a valid <see cref="T:System.Security.Permissions.PermissionState" /> value.</exception>
		public DataProtectionPermission(PermissionState state)
		{
			switch (state)
			{
			case PermissionState.Unrestricted:
				m_flags = DataProtectionPermissionFlags.AllFlags;
				break;
			case PermissionState.None:
				m_flags = DataProtectionPermissionFlags.NoFlags;
				break;
			default:
				throw new ArgumentException(SecurityResources.GetResourceString("Argument_InvalidPermissionState"));
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Permissions.DataProtectionPermission" /> class with the specified permission flags.</summary>
		/// <param name="flag">A bitwise combination of the <see cref="T:System.Security.Permissions.DataProtectionPermissionFlags" /> values.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="flag" /> is not a valid combination of the <see cref="T:System.Security.Permissions.DataProtectionPermissionFlags" /> values.</exception>
		public DataProtectionPermission(DataProtectionPermissionFlags flag)
		{
			Flags = flag;
		}

		/// <summary>Returns a value indicating whether the current permission is unrestricted.</summary>
		/// <returns>
		///   <see langword="true" /> if the current permission is unrestricted; otherwise, <see langword="false" />.</returns>
		public bool IsUnrestricted()
		{
			return m_flags == DataProtectionPermissionFlags.AllFlags;
		}

		/// <summary>Creates a permission that is the union of the current permission and the specified permission.</summary>
		/// <param name="target">A permission to combine with the current permission. It must be of the same type as the current permission.</param>
		/// <returns>A new permission that represents the union of the current permission and the specified permission.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="target" /> is not <see langword="null" /> and does not specify a permission of the same type as the current permission.</exception>
		public override IPermission Union(IPermission target)
		{
			if (target == null)
			{
				return Copy();
			}
			try
			{
				DataProtectionPermission dataProtectionPermission = (DataProtectionPermission)target;
				DataProtectionPermissionFlags dataProtectionPermissionFlags = m_flags | dataProtectionPermission.m_flags;
				if (dataProtectionPermissionFlags == DataProtectionPermissionFlags.NoFlags)
				{
					return null;
				}
				return new DataProtectionPermission(dataProtectionPermissionFlags);
			}
			catch (InvalidCastException)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Argument_WrongType"), new object[1] { GetType().FullName }));
			}
		}

		/// <summary>Determines whether the current permission is a subset of the specified permission.</summary>
		/// <param name="target">A permission to test for the subset relationship. This permission must be the same type as the current permission.</param>
		/// <returns>
		///   <see langword="true" /> if the current permission is a subset of the specified permission; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="target" /> is not <see langword="null" /> and does not specify a permission of the same type as the current permission.</exception>
		public override bool IsSubsetOf(IPermission target)
		{
			if (target == null)
			{
				return m_flags == DataProtectionPermissionFlags.NoFlags;
			}
			try
			{
				DataProtectionPermission dataProtectionPermission = (DataProtectionPermission)target;
				DataProtectionPermissionFlags flags = m_flags;
				DataProtectionPermissionFlags flags2 = dataProtectionPermission.m_flags;
				return (flags & flags2) == flags;
			}
			catch (InvalidCastException)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Argument_WrongType"), new object[1] { GetType().FullName }));
			}
		}

		/// <summary>Creates and returns a permission that is the intersection of the current permission and the specified permission.</summary>
		/// <param name="target">A permission to intersect with the current permission. It must be the same type as the current permission.</param>
		/// <returns>A new permission that represents the intersection of the current permission and the specified permission. This new permission is <see langword="null" /> if the intersection is empty.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="target" /> is not <see langword="null" /> and does not specify a permission of the same type as the current permission.</exception>
		public override IPermission Intersect(IPermission target)
		{
			if (target == null)
			{
				return null;
			}
			try
			{
				DataProtectionPermission dataProtectionPermission = (DataProtectionPermission)target;
				DataProtectionPermissionFlags dataProtectionPermissionFlags = dataProtectionPermission.m_flags & m_flags;
				if (dataProtectionPermissionFlags == DataProtectionPermissionFlags.NoFlags)
				{
					return null;
				}
				return new DataProtectionPermission(dataProtectionPermissionFlags);
			}
			catch (InvalidCastException)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Argument_WrongType"), new object[1] { GetType().FullName }));
			}
		}

		/// <summary>Creates and returns an identical copy of the current permission.</summary>
		/// <returns>A copy of the current permission.</returns>
		public override IPermission Copy()
		{
			if (Flags == DataProtectionPermissionFlags.NoFlags)
			{
				return null;
			}
			return new DataProtectionPermission(m_flags);
		}

		/// <summary>Creates an XML encoding of the permission and its current state.</summary>
		/// <returns>An XML encoding of the permission, including state information.</returns>
		public override SecurityElement ToXml()
		{
			SecurityElement securityElement = new SecurityElement("IPermission");
			securityElement.AddAttribute("class", GetType().FullName + ", " + GetType().Module.Assembly.FullName.Replace('"', '\''));
			securityElement.AddAttribute("version", "1");
			if (!IsUnrestricted())
			{
				securityElement.AddAttribute("Flags", m_flags.ToString());
			}
			else
			{
				securityElement.AddAttribute("Unrestricted", "true");
			}
			return securityElement;
		}

		/// <summary>Reconstructs a permission with a specific state from an XML encoding.</summary>
		/// <param name="securityElement">A <see cref="T:System.Security.SecurityElement" /> that contains the XML encoding used to reconstruct the permission.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="securityElement" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="securityElement" /> is not a valid permission element.  
		/// -or-  
		/// The version number of <paramref name="securityElement" /> is not supported.</exception>
		public override void FromXml(SecurityElement securityElement)
		{
			if (securityElement == null)
			{
				throw new ArgumentNullException("securityElement");
			}
			string text = securityElement.Attribute("class");
			if (text == null || text.IndexOf(GetType().FullName, StringComparison.Ordinal) == -1)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Argument_InvalidClassAttribute"), "securityElement");
			}
			string text2 = securityElement.Attribute("Unrestricted");
			if (text2 != null && string.Compare(text2, "true", StringComparison.OrdinalIgnoreCase) == 0)
			{
				m_flags = DataProtectionPermissionFlags.AllFlags;
				return;
			}
			m_flags = DataProtectionPermissionFlags.NoFlags;
			string text3 = securityElement.Attribute("Flags");
			if (text3 != null)
			{
				DataProtectionPermissionFlags flags = (DataProtectionPermissionFlags)Enum.Parse(typeof(DataProtectionPermissionFlags), text3);
				VerifyFlags(flags);
				m_flags = flags;
			}
		}

		internal static void VerifyFlags(DataProtectionPermissionFlags flags)
		{
			if (((uint)flags & 0xFFFFFFF0u) != 0)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Arg_EnumIllegalVal"), new object[1] { (int)flags }));
			}
		}
	}
	/// <summary>Allows security actions for <see cref="T:System.Security.Permissions.DataProtectionPermission" /> to be applied to code using declarative security. This class cannot be inherited.</summary>
	[Serializable]
	[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = true, Inherited = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class DataProtectionPermissionAttribute : CodeAccessSecurityAttribute
	{
		private DataProtectionPermissionFlags m_flags;

		/// <summary>Gets or sets the data protection permissions.</summary>
		/// <returns>A bitwise combination of the <see cref="T:System.Security.Permissions.DataProtectionPermissionFlags" /> values. The default is <see cref="F:System.Security.Permissions.DataProtectionPermissionFlags.NoFlags" />.</returns>
		public DataProtectionPermissionFlags Flags
		{
			get
			{
				return m_flags;
			}
			set
			{
				DataProtectionPermission.VerifyFlags(value);
				m_flags = value;
			}
		}

		/// <summary>Gets or sets a value indicating whether data can be encrypted using the <see cref="T:System.Security.Cryptography.ProtectedData" /> class.</summary>
		/// <returns>
		///   <see langword="true" /> if data can be encrypted; otherwise, <see langword="false" />.</returns>
		public bool ProtectData
		{
			get
			{
				return (m_flags & DataProtectionPermissionFlags.ProtectData) != 0;
			}
			set
			{
				m_flags = (value ? (m_flags | DataProtectionPermissionFlags.ProtectData) : (m_flags & ~DataProtectionPermissionFlags.ProtectData));
			}
		}

		/// <summary>Gets or sets a value indicating whether data can be unencrypted using the <see cref="T:System.Security.Cryptography.ProtectedData" /> class.</summary>
		/// <returns>
		///   <see langword="true" /> if data can be unencrypted; otherwise, <see langword="false" />.</returns>
		public bool UnprotectData
		{
			get
			{
				return (m_flags & DataProtectionPermissionFlags.UnprotectData) != 0;
			}
			set
			{
				m_flags = (value ? (m_flags | DataProtectionPermissionFlags.UnprotectData) : (m_flags & ~DataProtectionPermissionFlags.UnprotectData));
			}
		}

		/// <summary>Gets or sets a value indicating whether memory can be encrypted using the <see cref="T:System.Security.Cryptography.ProtectedMemory" /> class.</summary>
		/// <returns>
		///   <see langword="true" /> if memory can be encrypted; otherwise, <see langword="false" />.</returns>
		public bool ProtectMemory
		{
			get
			{
				return (m_flags & DataProtectionPermissionFlags.ProtectMemory) != 0;
			}
			set
			{
				m_flags = (value ? (m_flags | DataProtectionPermissionFlags.ProtectMemory) : (m_flags & ~DataProtectionPermissionFlags.ProtectMemory));
			}
		}

		/// <summary>Gets or sets a value indicating whether memory can be unencrypted using the <see cref="T:System.Security.Cryptography.ProtectedMemory" /> class.</summary>
		/// <returns>
		///   <see langword="true" /> if memory can be unencrypted; otherwise, <see langword="false" />.</returns>
		public bool UnprotectMemory
		{
			get
			{
				return (m_flags & DataProtectionPermissionFlags.UnprotectMemory) != 0;
			}
			set
			{
				m_flags = (value ? (m_flags | DataProtectionPermissionFlags.UnprotectMemory) : (m_flags & ~DataProtectionPermissionFlags.UnprotectMemory));
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Permissions.DataProtectionPermissionAttribute" /> class with the specified <see cref="T:System.Security.Permissions.SecurityAction" />.</summary>
		/// <param name="action">One of the <see cref="T:System.Security.Permissions.SecurityAction" /> values.</param>
		public DataProtectionPermissionAttribute(SecurityAction action)
			: base(action)
		{
		}

		/// <summary>Creates and returns a new <see cref="T:System.Security.Permissions.DataProtectionPermission" />.</summary>
		/// <returns>A <see cref="T:System.Security.Permissions.DataProtectionPermission" /> that corresponds to the attribute.</returns>
		public override IPermission CreatePermission()
		{
			if (base.Unrestricted)
			{
				return new DataProtectionPermission(PermissionState.Unrestricted);
			}
			return new DataProtectionPermission(m_flags);
		}
	}
	/// <summary>Specifies the access permissions for encrypting data and memory.</summary>
	[Serializable]
	[Flags]
	public enum DataProtectionPermissionFlags
	{
		/// <summary>No protection abilities.</summary>
		NoFlags = 0,
		/// <summary>The ability to encrypt data.</summary>
		ProtectData = 1,
		/// <summary>The ability to unencrypt data.</summary>
		UnprotectData = 2,
		/// <summary>The ability to encrypt memory.</summary>
		ProtectMemory = 4,
		/// <summary>The ability to unencrypt memory.</summary>
		UnprotectMemory = 8,
		/// <summary>The ability to encrypt data, encrypt memory, unencrypt data, and unencrypt memory.</summary>
		AllFlags = 0xF
	}
}
namespace System.Security.Cryptography
{
	internal static class CngLightup
	{
		private const string DsaOid = "1.2.840.10040.4.1";

		private const string RsaOid = "1.2.840.113549.1.1.1";

		private const string HashAlgorithmNameTypeName = "System.Security.Cryptography.HashAlgorithmName";

		private const string RSASignaturePaddingTypeName = "System.Security.Cryptography.RSASignaturePadding";

		private const string RSAEncryptionPaddingTypeName = "System.Security.Cryptography.RSAEncryptionPadding";

		private const string RSACngTypeName = "System.Security.Cryptography.RSACng";

		private const string DSACngTypeName = "System.Security.Cryptography.DSACng";

		private static readonly Type s_hashAlgorithmNameType = typeof(object).Assembly.GetType("System.Security.Cryptography.HashAlgorithmName", throwOnError: false);

		private static readonly Type s_rsaSignaturePaddingType = typeof(object).Assembly.GetType("System.Security.Cryptography.RSASignaturePadding", throwOnError: false);

		private static readonly Type s_rsaEncryptionPaddingType = typeof(object).Assembly.GetType("System.Security.Cryptography.RSAEncryptionPadding", throwOnError: false);

		private static readonly object s_pkcs1SignaturePadding = ((s_rsaSignaturePaddingType == null) ? null : s_rsaSignaturePaddingType.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null));

		private static readonly object s_pkcs1EncryptionPadding = ((s_rsaEncryptionPaddingType == null) ? null : s_rsaEncryptionPaddingType.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null));

		private static readonly object s_oaepSha1EncryptionPadding = ((s_rsaEncryptionPaddingType == null) ? null : s_rsaEncryptionPaddingType.GetProperty("OaepSHA1", BindingFlags.Static | BindingFlags.Public).GetValue(null));

		private static readonly Lazy<bool> s_preferRsaCng = new Lazy<bool>(DetectRsaCngSupport);

		private static volatile Func<X509Certificate2, DSA> s_getDsaPublicKey;

		private static volatile Func<X509Certificate2, DSA> s_getDsaPrivateKey;

		private static volatile Func<X509Certificate2, RSA> s_getRsaPublicKey;

		private static volatile Func<X509Certificate2, RSA> s_getRsaPrivateKey;

		private static volatile Func<RSA, byte[], string, byte[]> s_rsaPkcs1SignMethod;

		private static volatile Func<RSA, byte[], byte[], string, bool> s_rsaPkcs1VerifyMethod;

		private static volatile Func<RSA, byte[], byte[]> s_rsaPkcs1EncryptMethod;

		private static volatile Func<RSA, byte[], byte[]> s_rsaPkcs1DecryptMethod;

		private static volatile Func<RSA, byte[], byte[]> s_rsaOaepSha1EncryptMethod;

		private static volatile Func<RSA, byte[], byte[]> s_rsaOaepSha1DecryptMethod;

		internal static RSA GetRSAPublicKey(X509Certificate2 cert)
		{
			if (s_getRsaPublicKey == null)
			{
				if (s_preferRsaCng.Value)
				{
					s_getRsaPublicKey = BindCoreDelegate<RSA>("RSA", isPublic: true) ?? BindGetCapiPublicKey<RSA, RSACryptoServiceProvider>("1.2.840.113549.1.1.1");
				}
				else
				{
					s_getRsaPublicKey = BindGetCapiPublicKey<RSA, RSACryptoServiceProvider>("1.2.840.113549.1.1.1");
				}
			}
			return s_getRsaPublicKey(cert);
		}

		internal static RSA GetRSAPrivateKey(X509Certificate2 cert)
		{
			if (s_getRsaPrivateKey == null)
			{
				if (s_preferRsaCng.Value)
				{
					s_getRsaPrivateKey = BindCoreDelegate<RSA>("RSA", isPublic: false) ?? BindGetCapiPrivateKey("1.2.840.113549.1.1.1", (Func<CspParameters, RSA>)((CspParameters csp) => new RSACryptoServiceProvider(csp)));
				}
				else
				{
					s_getRsaPrivateKey = BindGetCapiPrivateKey("1.2.840.113549.1.1.1", (Func<CspParameters, RSA>)((CspParameters csp) => new RSACryptoServiceProvider(csp)));
				}
			}
			return s_getRsaPrivateKey(cert);
		}

		internal static DSA GetDSAPublicKey(X509Certificate2 cert)
		{
			if (s_getDsaPublicKey == null)
			{
				s_getDsaPublicKey = BindCoreDelegate<DSA>("DSA", isPublic: true) ?? BindGetCapiPublicKey<DSA, DSACryptoServiceProvider>("1.2.840.10040.4.1");
			}
			return s_getDsaPublicKey(cert);
		}

		internal static DSA GetDSAPrivateKey(X509Certificate2 cert)
		{
			if (s_getDsaPrivateKey == null)
			{
				s_getDsaPrivateKey = BindCoreDelegate<DSA>("DSA", isPublic: false) ?? BindGetCapiPrivateKey("1.2.840.10040.4.1", (Func<CspParameters, DSA>)((CspParameters csp) => new DSACryptoServiceProvider(csp)));
			}
			return s_getDsaPrivateKey(cert);
		}

		internal static byte[] Pkcs1SignData(RSA rsa, byte[] data, string hashAlgorithmName)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.SignData(data, hashAlgorithmName);
			}
			if (s_rsaPkcs1SignMethod == null)
			{
				Type[] types = new Type[3]
				{
					typeof(byte[]),
					s_hashAlgorithmNameType,
					s_rsaSignaturePaddingType
				};
				MethodInfo method = typeof(RSA).GetMethod("SignData", BindingFlags.Instance | BindingFlags.Public, null, types, null);
				Type type = typeof(Func<, , , , >).MakeGenericType(typeof(RSA), typeof(byte[]), s_hashAlgorithmNameType, s_rsaSignaturePaddingType, typeof(byte[]));
				Delegate openDelegate = Delegate.CreateDelegate(type, method);
				s_rsaPkcs1SignMethod = delegate(RSA delegateRsa, byte[] delegateData, string delegateAlgorithm)
				{
					object obj = Activator.CreateInstance(s_hashAlgorithmNameType, delegateAlgorithm);
					object[] args = new object[4] { delegateRsa, delegateData, obj, s_pkcs1SignaturePadding };
					return (byte[])openDelegate.DynamicInvoke(args);
				};
			}
			return s_rsaPkcs1SignMethod(rsa, data, hashAlgorithmName);
		}

		internal static bool Pkcs1VerifyData(RSA rsa, byte[] data, byte[] signature, string hashAlgorithmName)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.VerifyData(data, hashAlgorithmName, signature);
			}
			if (s_rsaPkcs1VerifyMethod == null)
			{
				Type[] types = new Type[4]
				{
					typeof(byte[]),
					typeof(byte[]),
					s_hashAlgorithmNameType,
					s_rsaSignaturePaddingType
				};
				MethodInfo method = typeof(RSA).GetMethod("VerifyData", BindingFlags.Instance | BindingFlags.Public, null, types, null);
				Type type = typeof(Func<, , , , , >).MakeGenericType(typeof(RSA), typeof(byte[]), typeof(byte[]), s_hashAlgorithmNameType, s_rsaSignaturePaddingType, typeof(bool));
				Delegate openDelegate = Delegate.CreateDelegate(type, method);
				s_rsaPkcs1VerifyMethod = delegate(RSA delegateRsa, byte[] delegateData, byte[] delegateSignature, string delegateAlgorithm)
				{
					object obj = Activator.CreateInstance(s_hashAlgorithmNameType, delegateAlgorithm);
					object[] args = new object[5] { delegateRsa, delegateData, delegateSignature, obj, s_pkcs1SignaturePadding };
					return (bool)openDelegate.DynamicInvoke(args);
				};
			}
			return s_rsaPkcs1VerifyMethod(rsa, data, signature, hashAlgorithmName);
		}

		internal static byte[] Pkcs1Encrypt(RSA rsa, byte[] data)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.Encrypt(data, fOAEP: false);
			}
			if (s_rsaPkcs1EncryptMethod == null)
			{
				Delegate openDelegate = BindRsaCryptMethod("Encrypt");
				s_rsaPkcs1EncryptMethod = (RSA delegateRsa, byte[] delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_pkcs1EncryptionPadding);
			}
			return s_rsaPkcs1EncryptMethod(rsa, data);
		}

		internal static byte[] Pkcs1Decrypt(RSA rsa, byte[] data)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.Decrypt(data, fOAEP: false);
			}
			if (s_rsaPkcs1DecryptMethod == null)
			{
				Delegate openDelegate = BindRsaCryptMethod("Decrypt");
				s_rsaPkcs1DecryptMethod = (RSA delegateRsa, byte[] delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_pkcs1EncryptionPadding);
			}
			return s_rsaPkcs1DecryptMethod(rsa, data);
		}

		internal static byte[] OaepSha1Encrypt(RSA rsa, byte[] data)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.Encrypt(data, fOAEP: true);
			}
			if (s_rsaOaepSha1EncryptMethod == null)
			{
				Delegate openDelegate = BindRsaCryptMethod("Encrypt");
				s_rsaOaepSha1EncryptMethod = (RSA delegateRsa, byte[] delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_oaepSha1EncryptionPadding);
			}
			return s_rsaOaepSha1EncryptMethod(rsa, data);
		}

		internal static byte[] OaepSha1Decrypt(RSA rsa, byte[] data)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.Decrypt(data, fOAEP: true);
			}
			if (s_rsaOaepSha1DecryptMethod == null)
			{
				Delegate openDelegate = BindRsaCryptMethod("Decrypt");
				s_rsaOaepSha1DecryptMethod = (RSA delegateRsa, byte[] delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_oaepSha1EncryptionPadding);
			}
			return s_rsaOaepSha1DecryptMethod(rsa, data);
		}

		private static Delegate BindRsaCryptMethod(string methodName)
		{
			Type[] types = new Type[2]
			{
				typeof(byte[]),
				s_rsaEncryptionPaddingType
			};
			MethodInfo method = typeof(RSA).GetMethod(methodName, BindingFlags.Instance | BindingFlags.Public, null, types, null);
			Type type = typeof(Func<, , , >).MakeGenericType(typeof(RSA), typeof(byte[]), s_rsaEncryptionPaddingType, typeof(byte[]));
			return Delegate.CreateDelegate(type, method);
		}

		private static bool DetectRsaCngSupport()
		{
			Type systemCoreType = GetSystemCoreType("System.Security.Cryptography.RSACng", throwOnError: false);
			if (systemCoreType == null)
			{
				return false;
			}
			Type systemCoreType2 = GetSystemCoreType("System.Security.Cryptography.DSACng", throwOnError: false);
			if (systemCoreType2 == null)
			{
				return false;
			}
			Type[] types = new Type[2]
			{
				typeof(byte[]),
				s_hashAlgorithmNameType
			};
			MethodInfo method = typeof(DSA).GetMethod("SignData", BindingFlags.Instance | BindingFlags.Public, null, types, null);
			if (method == null)
			{
				return false;
			}
			return true;
		}

		private static Func<X509Certificate2, T> BindGetCapiPublicKey<T, TCryptoServiceProvider>(string algorithmOid) where T : AsymmetricAlgorithm where TCryptoServiceProvider : T, ICspAsymmetricAlgorithm, new()
		{
			return delegate(X509Certificate2 cert)
			{
				PublicKey publicKey = cert.PublicKey;
				if (publicKey.Oid.Value != algorithmOid)
				{
					return null;
				}
				AsymmetricAlgorithm key = publicKey.Key;
				ICspAsymmetricAlgorithm cspAsymmetricAlgorithm = (ICspAsymmetricAlgorithm)key;
				byte[] rawData = cspAsymmetricAlgorithm.ExportCspBlob(includePrivateParameters: false);
				TCryptoServiceProvider val = new TCryptoServiceProvider();
				val.ImportCspBlob(rawData);
				return (T)val;
			};
		}

		private static Func<X509Certificate2, T> BindGetCapiPrivateKey<T>(string algorithmOid, Func<CspParameters, T> instanceFactory) where T : AsymmetricAlgorithm
		{
			return delegate(X509Certificate2 cert)
			{
				if (!cert.HasPrivateKey)
				{
					return null;
				}
				PublicKey publicKey = cert.PublicKey;
				if (publicKey.Oid.Value != algorithmOid)
				{
					return null;
				}
				AsymmetricAlgorithm privateKey = cert.PrivateKey;
				ICspAsymmetricAlgorithm cspAlgorithm = (ICspAsymmetricAlgorithm)privateKey;
				CspParameters arg = CopyCspParameters(cspAlgorithm);
				return instanceFactory(arg);
			};
		}

		private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmName, bool isPublic)
		{
			string namespaceQualifiedTypeName = "System.Security.Cryptography.X509Certificates." + algorithmName + "CertificateExtensions";
			Type systemCoreType = GetSystemCoreType(namespaceQualifiedTypeName, throwOnError: false);
			if (systemCoreType == null)
			{
				return null;
			}
			string name = "Get" + algorithmName + (isPublic ? "Public" : "Private") + "Key";
			MethodInfo method = systemCoreType.GetMethod(name, BindingFlags.Static | BindingFlags.Public, null, new Type[1] { typeof(X509Certificate2) }, null);
			return (Func<X509Certificate2, T>)method.CreateDelegate(typeof(Func<X509Certificate2, T>));
		}

		private static CspParameters CopyCspParameters(ICspAsymmetricAlgorithm cspAlgorithm)
		{
			CspKeyContainerInfo cspKeyContainerInfo = cspAlgorithm.CspKeyContainerInfo;
			CspParameters cspParameters = new CspParameters(cspKeyContainerInfo.ProviderType, cspKeyContainerInfo.ProviderName, cspKeyContainerInfo.KeyContainerName)
			{
				Flags = CspProviderFlags.UseExistingKey,
				KeyNumber = (int)cspKeyContainerInfo.KeyNumber
			};
			if (cspKeyContainerInfo.MachineKeyStore)
			{
				cspParameters.Flags |= CspProviderFlags.UseMachineKeyStore;
			}
			return cspParameters;
		}

		private static Type GetSystemCoreType(string namespaceQualifiedTypeName, bool throwOnError = true)
		{
			string typeName = namespaceQualifiedTypeName + ", System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
			return Type.GetType(typeName, throwOnError: false, ignoreCase: false);
		}
	}
	internal sealed class BigInt
	{
		private byte[] m_elements;

		private const int m_maxbytes = 128;

		private const int m_base = 256;

		private int m_size;

		private static readonly char[] decValues = new char[10] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

		internal int Size
		{
			get
			{
				return m_size;
			}
			set
			{
				if (value > 128)
				{
					m_size = 128;
				}
				if (value < 0)
				{
					m_size = 0;
				}
				m_size = value;
			}
		}

		internal BigInt()
		{
			m_elements = new byte[128];
		}

		internal BigInt(byte b)
		{
			m_elements = new byte[128];
			SetDigit(0, b);
		}

		internal byte GetDigit(int index)
		{
			if (index < 0 || index >= m_size)
			{
				return 0;
			}
			return m_elements[index];
		}

		internal void SetDigit(int index, byte digit)
		{
			if (index >= 0 && index < 128)
			{
				m_elements[index] = digit;
				if (index >= m_size && digit != 0)
				{
					m_size = index + 1;
				}
				if (index == m_size - 1 && digit == 0)
				{
					m_size--;
				}
			}
		}

		internal void SetDigit(int index, byte digit, ref int size)
		{
			if (index >= 0 && index < 128)
			{
				m_elements[index] = digit;
				if (index >= size && digit != 0)
				{
					size = index + 1;
				}
				if (index == size - 1 && digit == 0)
				{
					size--;
				}
			}
		}

		public static bool operator <(BigInt value1, BigInt value2)
		{
			if (value1 == null)
			{
				return true;
			}
			if (value2 == null)
			{
				return false;
			}
			int size = value1.Size;
			int size2 = value2.Size;
			if (size != size2)
			{
				return size < size2;
			}
			while (size-- > 0)
			{
				if (value1.m_elements[size] != value2.m_elements[size])
				{
					return value1.m_elements[size] < value2.m_elements[size];
				}
			}
			return false;
		}

		public static bool operator >(BigInt value1, BigInt value2)
		{
			if (value1 == null)
			{
				return false;
			}
			if (value2 == null)
			{
				return true;
			}
			int size = value1.Size;
			int size2 = value2.Size;
			if (size != size2)
			{
				return size > size2;
			}
			while (size-- > 0)
			{
				if (value1.m_elements[size] != value2.m_elements[size])
				{
					return value1.m_elements[size] > value2.m_elements[size];
				}
			}
			return false;
		}

		public static bool operator ==(BigInt value1, BigInt value2)
		{
			if ((object)value1 == null)
			{
				return (object)value2 == null;
			}
			if ((object)value2 == null)
			{
				return (object)value1 == null;
			}
			int size = value1.Size;
			int size2 = value2.Size;
			if (size != size2)
			{
				return false;
			}
			for (int i = 0; i < size; i++)
			{
				if (value1.m_elements[i] != value2.m_elements[i])
				{
					return false;
				}
			}
			return true;
		}

		public static bool operator !=(BigInt value1, BigInt value2)
		{
			return !(value1 == value2);
		}

		public override bool Equals(object obj)
		{
			if (obj is BigInt)
			{
				return this == (BigInt)obj;
			}
			return false;
		}

		public override int GetHashCode()
		{
			int num = 0;
			for (int i = 0; i < m_size; i++)
			{
				num += GetDigit(i);
			}
			return num;
		}

		internal static void Add(BigInt a, byte b, ref BigInt c)
		{
			byte b2 = b;
			int num = 0;
			int size = a.Size;
			int size2 = 0;
			for (int i = 0; i < size; i++)
			{
				num = a.GetDigit(i) + b2;
				c.SetDigit(i, (byte)((uint)num & 0xFFu), ref size2);
				b2 = (byte)((uint)(num >> 8) & 0xFFu);
			}
			if (b2 != 0)
			{
				c.SetDigit(a.Size, b2, ref size2);
			}
			c.Size = size2;
		}

		internal static void Negate(ref BigInt a)
		{
			int size = 0;
			for (int i = 0; i < 128; i++)
			{
				a.SetDigit(i, (byte)((uint)(~a.GetDigit(i)) & 0xFFu), ref size);
			}
			for (int j = 0; j < 128; j++)
			{
				a.SetDigit(j, (byte)(a.GetDigit(j) + 1), ref size);
				if ((a.GetDigit(j) & 0xFFu) != 0)
				{
					break;
				}
				a.SetDigit(j, (byte)(a.GetDigit(j) & 0xFFu), ref size);
			}
			a.Size = size;
		}

		internal static void Subtract(BigInt a, BigInt b, ref BigInt c)
		{
			byte b2 = 0;
			int num = 0;
			if (a < b)
			{
				Subtract(b, a, ref c);
				Negate(ref c);
				return;
			}
			int num2 = 0;
			int size = a.Size;
			int size2 = 0;
			for (num2 = 0; num2 < size; num2++)
			{
				num = a.GetDigit(num2) - b.GetDigit(num2) - b2;
				b2 = 0;
				if (num < 0)
				{
					num += 256;
					b2 = 1;
				}
				c.SetDigit(num2, (byte)((uint)num & 0xFFu), ref size2);
			}
			c.Size = size2;
		}

		private void Multiply(int b)
		{
			if (b == 0)
			{
				Clear();
				return;
			}
			int num = 0;
			int num2 = 0;
			int size = Size;
			int size2 = 0;
			for (int i = 0; i < size; i++)
			{
				num2 = b * GetDigit(i) + num;
				num = num2 / 256;
				SetDigit(i, (byte)(num2 % 256), ref size2);
			}
			if (num != 0)
			{
				byte[] bytes = BitConverter.GetBytes(num);
				for (int j = 0; j < bytes.Length; j++)
				{
					SetDigit(size + j, bytes[j], ref size2);
				}
			}
			Size = size2;
		}

		private static void Multiply(BigInt a, int b, ref BigInt c)
		{
			if (b == 0)
			{
				c.Clear();
				return;
			}
			int num = 0;
			int num2 = 0;
			int size = a.Size;
			int size2 = 0;
			for (int i = 0; i < size; i++)
			{
				num2 = b * a.GetDigit(i) + num;
				num = num2 / 256;
				c.SetDigit(i, (byte)(num2 % 256), ref size2);
			}
			if (num != 0)
			{
				byte[] bytes = BitConverter.GetBytes(num);
				for (int j = 0; j < bytes.Length; j++)
				{
					c.SetDigit(size + j, bytes[j], ref size2);
				}
			}
			c.Size = size2;
		}

		private void Divide(int b)
		{
			int num = 0;
			int num2 = 0;
			int size = Size;
			int size2 = 0;
			while (size-- > 0)
			{
				num2 = 256 * num + GetDigit(size);
				num = num2 % b;
				SetDigit(size, (byte)(num2 / b), ref size2);
			}
			Size = size2;
		}

		internal static void Divide(BigInt numerator, BigInt denominator, ref BigInt quotient, ref BigInt remainder)
		{
			if (numerator < denominator)
			{
				quotient.Clear();
				remainder.CopyFrom(numerator);
				return;
			}
			if (numerator == denominator)
			{
				quotient.Clear();
				quotient.SetDigit(0, 1);
				remainder.Clear();
				return;
			}
			BigInt c = new BigInt();
			c.CopyFrom(numerator);
			BigInt bigInt = new BigInt();
			bigInt.CopyFrom(denominator);
			uint num = 0u;
			while (bigInt.Size < c.Size)
			{
				bigInt.Multiply(256);
				num++;
			}
			if (bigInt > c)
			{
				bigInt.Divide(256);
				num--;
			}
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			BigInt c2 = new BigInt();
			quotient.Clear();
			for (int i = 0; i <= num; i++)
			{
				num2 = ((c.Size == bigInt.Size) ? c.GetDigit(c.Size - 1) : (256 * c.GetDigit(c.Size - 1) + c.GetDigit(c.Size - 2)));
				num3 = bigInt.GetDigit(bigInt.Size - 1);
				num4 = num2 / num3;
				if (num4 >= 256)
				{
					num4 = 255;
				}
				Multiply(bigInt, num4, ref c2);
				while (c2 > c)
				{
					num4--;
					Multiply(bigInt, num4, ref c2);
				}
				quotient.Multiply(256);
				Add(quotient, (byte)num4, ref quotient);
				Subtract(c, c2, ref c);
				bigInt.Divide(256);
			}
			remainder.CopyFrom(c);
		}

		internal void CopyFrom(BigInt a)
		{
			Array.Copy(a.m_elements, m_elements, 128);
			m_size = a.m_size;
		}

		internal bool IsZero()
		{
			for (int i = 0; i < m_size; i++)
			{
				if (m_elements[i] != 0)
				{
					return false;
				}
			}
			return true;
		}

		internal byte[] ToByteArray()
		{
			byte[] array = new byte[Size];
			Array.Copy(m_elements, array, Size);
			return array;
		}

		internal void Clear()
		{
			m_size = 0;
		}

		internal void FromHexadecimal(string hexNum)
		{
			byte[] array = System.Security.Cryptography.X509Certificates.X509Utils.DecodeHexString(hexNum);
			Array.Reverse(array);
			int hexArraySize = System.Security.Cryptography.Xml.Utils.GetHexArraySize(array);
			Array.Copy(array, m_elements, hexArraySize);
			Size = hexArraySize;
		}

		internal void FromDecimal(string decNum)
		{
			BigInt c = new BigInt();
			BigInt c2 = new BigInt();
			int length = decNum.Length;
			for (int i = 0; i < length; i++)
			{
				if (decNum[i] <= '9' && decNum[i] >= '0')
				{
					Multiply(c, 10, ref c2);
					Add(c2, (byte)(decNum[i] - 48), ref c);
				}
			}
			CopyFrom(c);
		}

		internal string ToDecimal()
		{
			if (IsZero())
			{
				return "0";
			}
			BigInt denominator = new BigInt(10);
			BigInt bigInt = new BigInt();
			BigInt quotient = new BigInt();
			BigInt remainder = new BigInt();
			bigInt.CopyFrom(this);
			char[] array = new char[(int)Math.Ceiling((double)(m_size * 2) * 1.21)];
			int length = 0;
			do
			{
				Divide(bigInt, denominator, ref quotient, ref remainder);
				array[length++] = decValues[(!remainder.IsZero()) ? remainder.m_elements[0] : 0];
				bigInt.CopyFrom(quotient);
			}
			while (!quotient.IsZero());
			Array.Reverse(array, 0, length);
			return new string(array, 0, length);
		}
	}
	internal static class CAPI
	{
		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct BLOBHEADER
		{
			internal byte bType;

			internal byte bVersion;

			internal short reserved;

			internal uint aiKeyAlg;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_ALT_NAME_INFO
		{
			internal uint cAltEntry;

			internal IntPtr rgAltEntry;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_BASIC_CONSTRAINTS_INFO
		{
			internal CRYPT_BIT_BLOB SubjectType;

			internal bool fPathLenConstraint;

			internal uint dwPathLenConstraint;

			internal uint cSubtreesConstraint;

			internal IntPtr rgSubtreesConstraint;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_BASIC_CONSTRAINTS2_INFO
		{
			internal int fCA;

			internal int fPathLenConstraint;

			internal uint dwPathLenConstraint;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_CHAIN_PARA
		{
			internal uint cbSize;

			internal CERT_USAGE_MATCH RequestedUsage;

			internal CERT_USAGE_MATCH RequestedIssuancePolicy;

			internal uint dwUrlRetrievalTimeout;

			internal bool fCheckRevocationFreshnessTime;

			internal uint dwRevocationFreshnessTime;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_CHAIN_POLICY_PARA
		{
			internal uint cbSize;

			internal uint dwFlags;

			internal IntPtr pvExtraPolicyPara;

			internal CERT_CHAIN_POLICY_PARA(int size)
			{
				cbSize = (uint)size;
				dwFlags = 0u;
				pvExtraPolicyPara = IntPtr.Zero;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_CHAIN_POLICY_STATUS
		{
			internal uint cbSize;

			internal uint dwError;

			internal IntPtr lChainIndex;

			internal IntPtr lElementIndex;

			internal IntPtr pvExtraPolicyStatus;

			internal CERT_CHAIN_POLICY_STATUS(int size)
			{
				cbSize = (uint)size;
				dwError = 0u;
				lChainIndex = IntPtr.Zero;
				lElementIndex = IntPtr.Zero;
				pvExtraPolicyStatus = IntPtr.Zero;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_CONTEXT
		{
			internal uint dwCertEncodingType;

			internal IntPtr pbCertEncoded;

			internal uint cbCertEncoded;

			internal IntPtr pCertInfo;

			internal IntPtr hCertStore;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_DSS_PARAMETERS
		{
			internal CRYPTOAPI_BLOB p;

			internal CRYPTOAPI_BLOB q;

			internal CRYPTOAPI_BLOB g;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_ENHKEY_USAGE
		{
			internal uint cUsageIdentifier;

			internal IntPtr rgpszUsageIdentifier;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_EXTENSION
		{
			[MarshalAs(UnmanagedType.LPStr)]
			internal string pszObjId;

			internal bool fCritical;

			internal CRYPTOAPI_BLOB Value;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_ID
		{
			internal uint dwIdChoice;

			internal CERT_ID_UNION Value;
		}

		[StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
		internal struct CERT_ID_UNION
		{
			[FieldOffset(0)]
			internal CERT_ISSUER_SERIAL_NUMBER IssuerSerialNumber;

			[FieldOffset(0)]
			internal CRYPTOAPI_BLOB KeyId;

			[FieldOffset(0)]
			internal CRYPTOAPI_BLOB HashId;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_ISSUER_SERIAL_NUMBER
		{
			internal CRYPTOAPI_BLOB Issuer;

			internal CRYPTOAPI_BLOB SerialNumber;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_INFO
		{
			internal uint dwVersion;

			internal CRYPTOAPI_BLOB SerialNumber;

			internal CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;

			internal CRYPTOAPI_BLOB Issuer;

			internal System.Runtime.InteropServices.ComTypes.FILETIME NotBefore;

			internal System.Runtime.InteropServices.ComTypes.FILETIME NotAfter;

			internal CRYPTOAPI_BLOB Subject;

			internal CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;

			internal CRYPT_BIT_BLOB IssuerUniqueId;

			internal CRYPT_BIT_BLOB SubjectUniqueId;

			internal uint cExtension;

			internal IntPtr rgExtension;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_KEY_USAGE_RESTRICTION_INFO
		{
			internal uint cCertPolicyId;

			internal IntPtr rgCertPolicyId;

			internal CRYPT_BIT_BLOB RestrictedKeyUsage;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_NAME_INFO
		{
			internal uint cRDN;

			internal IntPtr rgRDN;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_NAME_VALUE
		{
			internal uint dwValueType;

			internal CRYPTOAPI_BLOB Value;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_OTHER_NAME
		{
			[MarshalAs(UnmanagedType.LPStr)]
			internal string pszObjId;

			internal CRYPTOAPI_BLOB Value;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_POLICY_ID
		{
			internal uint cCertPolicyElementId;

			internal IntPtr rgpszCertPolicyElementId;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_POLICIES_INFO
		{
			internal uint cPolicyInfo;

			internal IntPtr rgPolicyInfo;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_POLICY_INFO
		{
			[MarshalAs(UnmanagedType.LPStr)]
			internal string pszPolicyIdentifier;

			internal uint cPolicyQualifier;

			internal IntPtr rgPolicyQualifier;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_POLICY_QUALIFIER_INFO
		{
			[MarshalAs(UnmanagedType.LPStr)]
			internal string pszPolicyQualifierId;

			private CRYPTOAPI_BLOB Qualifier;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_PUBLIC_KEY_INFO
		{
			internal CRYPT_ALGORITHM_IDENTIFIER Algorithm;

			internal CRYPT_BIT_BLOB PublicKey;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_PUBLIC_KEY_INFO2
		{
			internal CRYPT_ALGORITHM_IDENTIFIER2 Algorithm;

			internal CRYPT_BIT_BLOB PublicKey;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_RDN
		{
			internal uint cRDNAttr;

			internal IntPtr rgRDNAttr;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_RDN_ATTR
		{
			[MarshalAs(UnmanagedType.LPStr)]
			internal string pszObjId;

			internal uint dwValueType;

			internal CRYPTOAPI_BLOB Value;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_TEMPLATE_EXT
		{
			[MarshalAs(UnmanagedType.LPStr)]
			internal string pszObjId;

			internal uint dwMajorVersion;

			private bool fMinorVersion;

			private uint dwMinorVersion;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_TRUST_STATUS
		{
			internal uint dwErrorStatus;

			internal uint dwInfoStatus;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CERT_USAGE_MATCH
		{
			internal uint dwType;

			internal CERT_ENHKEY_USAGE Usage;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_CMS_RECIPIENT_INFO
		{
			internal uint dwRecipientChoice;

			internal IntPtr pRecipientInfo;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_CMS_SIGNER_INFO
		{
			internal uint dwVersion;

			internal CERT_ID SignerId;

			internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;

			internal CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;

			internal CRYPTOAPI_BLOB EncryptedHash;

			internal CRYPT_ATTRIBUTES AuthAttrs;

			internal CRYPT_ATTRIBUTES UnauthAttrs;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA
		{
			internal uint cbSize;

			internal uint dwSignerIndex;

			internal CRYPTOAPI_BLOB blob;

			internal CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA(int size)
			{
				cbSize = (uint)size;
				dwSignerIndex = 0u;
				blob = default(CRYPTOAPI_BLOB);
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_CTRL_DECRYPT_PARA
		{
			internal uint cbSize;

			internal IntPtr hCryptProv;

			internal uint dwKeySpec;

			internal uint dwRecipientIndex;

			internal CMSG_CTRL_DECRYPT_PARA(int size)
			{
				cbSize = (uint)size;
				hCryptProv = IntPtr.Zero;
				dwKeySpec = 0u;
				dwRecipientIndex = 0u;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA
		{
			internal uint cbSize;

			internal uint dwSignerIndex;

			internal uint dwUnauthAttrIndex;

			internal CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA(int size)
			{
				cbSize = (uint)size;
				dwSignerIndex = 0u;
				dwUnauthAttrIndex = 0u;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_CTRL_KEY_TRANS_DECRYPT_PARA
		{
			internal uint cbSize;

			[SecurityCritical]
			internal SafeCryptProvHandle hCryptProv;

			internal uint dwKeySpec;

			internal IntPtr pKeyTrans;

			internal uint dwRecipientIndex;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO
		{
			internal uint cbSize;

			internal CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;

			internal IntPtr pvKeyEncryptionAuxInfo;

			internal CRYPT_ALGORITHM_IDENTIFIER KeyWrapAlgorithm;

			internal IntPtr pvKeyWrapAuxInfo;

			internal IntPtr hCryptProv;

			internal uint dwKeySpec;

			internal uint dwKeyChoice;

			internal IntPtr pEphemeralAlgorithmOrSenderId;

			internal CRYPTOAPI_BLOB UserKeyingMaterial;

			internal uint cRecipientEncryptedKeys;

			internal IntPtr rgpRecipientEncryptedKeys;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO
		{
			internal uint cbSize;

			internal CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;

			internal IntPtr pvKeyEncryptionAuxInfo;

			internal IntPtr hCryptProv;

			internal CRYPT_BIT_BLOB RecipientPublicKey;

			internal CERT_ID RecipientId;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_RC2_AUX_INFO
		{
			internal uint cbSize;

			internal uint dwBitLen;

			internal CMSG_RC2_AUX_INFO(int size)
			{
				cbSize = (uint)size;
				dwBitLen = 0u;
			}
		}

		internal struct CMSG_RECIPIENT_ENCODE_INFO
		{
			internal uint dwRecipientChoice;

			internal IntPtr pRecipientInfo;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO
		{
			internal uint cbSize;

			internal CRYPT_BIT_BLOB RecipientPublicKey;

			internal CERT_ID RecipientId;

			internal System.Runtime.InteropServices.ComTypes.FILETIME Date;

			internal IntPtr pOtherAttr;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_ENVELOPED_ENCODE_INFO
		{
			internal uint cbSize;

			internal IntPtr hCryptProv;

			internal CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;

			internal IntPtr pvEncryptionAuxInfo;

			internal uint cRecipients;

			internal IntPtr rgpRecipients;

			internal IntPtr rgCmsRecipients;

			internal uint cCertEncoded;

			internal IntPtr rgCertEncoded;

			internal uint cCrlEncoded;

			internal IntPtr rgCrlEncoded;

			internal uint cAttrCertEncoded;

			internal IntPtr rgAttrCertEncoded;

			internal uint cUnprotectedAttr;

			internal IntPtr rgUnprotectedAttr;

			internal CMSG_ENVELOPED_ENCODE_INFO(int size)
			{
				cbSize = (uint)size;
				hCryptProv = IntPtr.Zero;
				ContentEncryptionAlgorithm = default(CRYPT_ALGORITHM_IDENTIFIER);
				pvEncryptionAuxInfo = IntPtr.Zero;
				cRecipients = 0u;
				rgpRecipients = IntPtr.Zero;
				rgCmsRecipients = IntPtr.Zero;
				cCertEncoded = 0u;
				rgCertEncoded = IntPtr.Zero;
				cCrlEncoded = 0u;
				rgCrlEncoded = IntPtr.Zero;
				cAttrCertEncoded = 0u;
				rgAttrCertEncoded = IntPtr.Zero;
				cUnprotectedAttr = 0u;
				rgUnprotectedAttr = IntPtr.Zero;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_CTRL_KEY_AGREE_DECRYPT_PARA
		{
			internal uint cbSize;

			internal IntPtr hCryptProv;

			internal uint dwKeySpec;

			internal IntPtr pKeyAgree;

			internal uint dwRecipientIndex;

			internal uint dwRecipientEncryptedKeyIndex;

			internal CRYPT_BIT_BLOB OriginatorPublicKey;

			internal CMSG_CTRL_KEY_AGREE_DECRYPT_PARA(int size)
			{
				cbSize = (uint)size;
				hCryptProv = IntPtr.Zero;
				dwKeySpec = 0u;
				pKeyAgree = IntPtr.Zero;
				dwRecipientIndex = 0u;
				dwRecipientEncryptedKeyIndex = 0u;
				OriginatorPublicKey = default(CRYPT_BIT_BLOB);
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_KEY_AGREE_RECIPIENT_INFO
		{
			internal uint dwVersion;

			internal uint dwOriginatorChoice;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_KEY_AGREE_CERT_ID_RECIPIENT_INFO
		{
			internal uint dwVersion;

			internal uint dwOriginatorChoice;

			internal CERT_ID OriginatorCertId;

			internal IntPtr Padding;

			internal CRYPTOAPI_BLOB UserKeyingMaterial;

			internal CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;

			internal uint cRecipientEncryptedKeys;

			internal IntPtr rgpRecipientEncryptedKeys;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_KEY_AGREE_PUBLIC_KEY_RECIPIENT_INFO
		{
			internal uint dwVersion;

			internal uint dwOriginatorChoice;

			internal CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;

			internal CRYPTOAPI_BLOB UserKeyingMaterial;

			internal CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;

			internal uint cRecipientEncryptedKeys;

			internal IntPtr rgpRecipientEncryptedKeys;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_RECIPIENT_ENCRYPTED_KEY_INFO
		{
			internal CERT_ID RecipientId;

			internal CRYPTOAPI_BLOB EncryptedKey;

			internal System.Runtime.InteropServices.ComTypes.FILETIME Date;

			internal IntPtr pOtherAttr;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA
		{
			internal uint cbSize;

			internal IntPtr hCryptProv;

			internal uint dwSignerIndex;

			internal uint dwSignerType;

			internal IntPtr pvSigner;

			internal CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA(int size)
			{
				cbSize = (uint)size;
				hCryptProv = IntPtr.Zero;
				dwSignerIndex = 0u;
				dwSignerType = 0u;
				pvSigner = IntPtr.Zero;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_KEY_TRANS_RECIPIENT_INFO
		{
			internal uint dwVersion;

			internal CERT_ID RecipientId;

			internal CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;

			internal CRYPTOAPI_BLOB EncryptedKey;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_SIGNED_ENCODE_INFO
		{
			internal uint cbSize;

			internal uint cSigners;

			internal IntPtr rgSigners;

			internal uint cCertEncoded;

			internal IntPtr rgCertEncoded;

			internal uint cCrlEncoded;

			internal IntPtr rgCrlEncoded;

			internal uint cAttrCertEncoded;

			internal IntPtr rgAttrCertEncoded;

			internal CMSG_SIGNED_ENCODE_INFO(int size)
			{
				cbSize = (uint)size;
				cSigners = 0u;
				rgSigners = IntPtr.Zero;
				cCertEncoded = 0u;
				rgCertEncoded = IntPtr.Zero;
				cCrlEncoded = 0u;
				rgCrlEncoded = IntPtr.Zero;
				cAttrCertEncoded = 0u;
				rgAttrCertEncoded = IntPtr.Zero;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_SIGNER_ENCODE_INFO
		{
			internal uint cbSize;

			internal IntPtr pCertInfo;

			internal IntPtr hCryptProv;

			internal uint dwKeySpec;

			internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;

			internal IntPtr pvHashAuxInfo;

			internal uint cAuthAttr;

			internal IntPtr rgAuthAttr;

			internal uint cUnauthAttr;

			internal IntPtr rgUnauthAttr;

			internal CERT_ID SignerId;

			internal CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;

			internal IntPtr pvHashEncryptionAuxInfo;

			[DllImport("kernel32.dll", SetLastError = true)]
			internal static extern IntPtr LocalFree(IntPtr hMem);

			[DllImport("advapi32.dll", SetLastError = true)]
			internal static extern bool CryptReleaseContext([In] IntPtr hProv, [In] uint dwFlags);

			internal CMSG_SIGNER_ENCODE_INFO(int size)
			{
				cbSize = (uint)size;
				pCertInfo = IntPtr.Zero;
				hCryptProv = IntPtr.Zero;
				dwKeySpec = 0u;
				HashAlgorithm = default(CRYPT_ALGORITHM_IDENTIFIER);
				pvHashAuxInfo = IntPtr.Zero;
				cAuthAttr = 0u;
				rgAuthAttr = IntPtr.Zero;
				cUnauthAttr = 0u;
				rgUnauthAttr = IntPtr.Zero;
				SignerId = default(CERT_ID);
				HashEncryptionAlgorithm = default(CRYPT_ALGORITHM_IDENTIFIER);
				pvHashEncryptionAuxInfo = IntPtr.Zero;
			}

			[SecuritySafeCritical]
			internal void Dispose()
			{
				hCryptProv = IntPtr.Zero;
				if (SignerId.Value.KeyId.pbData != IntPtr.Zero)
				{
					LocalFree(SignerId.Value.KeyId.pbData);
				}
				if (rgAuthAttr != IntPtr.Zero)
				{
					LocalFree(rgAuthAttr);
				}
				if (rgUnauthAttr != IntPtr.Zero)
				{
					LocalFree(rgUnauthAttr);
				}
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CMSG_SIGNER_INFO
		{
			internal uint dwVersion;

			internal CRYPTOAPI_BLOB Issuer;

			internal CRYPTOAPI_BLOB SerialNumber;

			internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;

			internal CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;

			internal CRYPTOAPI_BLOB EncryptedHash;

			internal CRYPT_ATTRIBUTES AuthAttrs;

			internal CRYPT_ATTRIBUTES UnauthAttrs;
		}

		internal delegate bool PFN_CMSG_STREAM_OUTPUT(IntPtr pvArg, IntPtr pbData, uint cbData, bool fFinal);

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal class CMSG_STREAM_INFO
		{
			internal uint cbContent;

			internal PFN_CMSG_STREAM_OUTPUT pfnStreamOutput;

			internal IntPtr pvArg;

			internal CMSG_STREAM_INFO(uint cbContent, PFN_CMSG_STREAM_OUTPUT pfnStreamOutput, IntPtr pvArg)
			{
				this.cbContent = cbContent;
				this.pfnStreamOutput = pfnStreamOutput;
				this.pvArg = pvArg;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPT_ALGORITHM_IDENTIFIER
		{
			[MarshalAs(UnmanagedType.LPStr)]
			internal string pszObjId;

			internal CRYPTOAPI_BLOB Parameters;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPT_ALGORITHM_IDENTIFIER2
		{
			internal IntPtr pszObjId;

			internal CRYPTOAPI_BLOB Parameters;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPT_ATTRIBUTE
		{
			[MarshalAs(UnmanagedType.LPStr)]
			internal string pszObjId;

			internal uint cValue;

			internal IntPtr rgValue;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPT_ATTRIBUTES
		{
			internal uint cAttr;

			internal IntPtr rgAttr;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPT_ATTRIBUTE_TYPE_VALUE
		{
			[MarshalAs(UnmanagedType.LPStr)]
			internal string pszObjId;

			internal CRYPTOAPI_BLOB Value;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPT_BIT_BLOB
		{
			internal uint cbData;

			internal IntPtr pbData;

			internal uint cUnusedBits;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPT_KEY_PROV_INFO
		{
			internal string pwszContainerName;

			internal string pwszProvName;

			internal uint dwProvType;

			internal uint dwFlags;

			internal uint cProvParam;

			internal IntPtr rgProvParam;

			internal uint dwKeySpec;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPT_OID_INFO
		{
			internal uint cbSize;

			[MarshalAs(UnmanagedType.LPStr)]
			internal string pszOID;

			internal string pwszName;

			internal uint dwGroupId;

			internal uint Algid;

			internal CRYPTOAPI_BLOB ExtraInfo;

			internal CRYPT_OID_INFO(int size)
			{
				cbSize = (uint)size;
				pszOID = null;
				pwszName = null;
				dwGroupId = 0u;
				Algid = 0u;
				ExtraInfo = default(CRYPTOAPI_BLOB);
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPT_RC2_CBC_PARAMETERS
		{
			internal uint dwVersion;

			internal bool fIV;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
			internal byte[] rgbIV;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPTOAPI_BLOB
		{
			internal uint cbData;

			internal IntPtr pbData;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal class CRYPTUI_SELECTCERTIFICATE_STRUCTW
		{
			internal uint dwSize;

			internal IntPtr hwndParent;

			internal uint dwFlags;

			internal string szTitle;

			internal uint dwDontUseColumn;

			internal string szDisplayString;

			internal IntPtr pFilterCallback;

			internal IntPtr pDisplayCallback;

			internal IntPtr pvCallbackData;

			internal uint cDisplayStores;

			internal IntPtr rghDisplayStores;

			internal uint cStores;

			internal IntPtr rghStores;

			internal uint cPropSheetPages;

			internal IntPtr rgPropSheetPages;

			internal IntPtr hSelectedCertStore;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal class CRYPTUI_VIEWCERTIFICATE_STRUCTW
		{
			internal uint dwSize;

			internal IntPtr hwndParent;

			internal uint dwFlags;

			internal string szTitle;

			internal IntPtr pCertContext;

			internal IntPtr rgszPurposes;

			internal uint cPurposes;

			internal IntPtr pCryptProviderData;

			internal bool fpCryptProviderDataTrustedUsage;

			internal uint idxSigner;

			internal uint idxCert;

			internal bool fCounterSigner;

			internal uint idxCounterSigner;

			internal uint cStores;

			internal IntPtr rghStores;

			internal uint cPropSheetPages;

			internal IntPtr rgPropSheetPages;

			internal uint nStartPage;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct DSSPUBKEY
		{
			internal uint magic;

			internal uint bitlen;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct PROV_ENUMALGS_EX
		{
			internal uint aiAlgid;

			internal uint dwDefaultLen;

			internal uint dwMinLen;

			internal uint dwMaxLen;

			internal uint dwProtocols;

			internal uint dwNameLen;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 20)]
			internal byte[] szName;

			internal uint dwLongNameLen;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 40)]
			internal byte[] szLongName;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct RSAPUBKEY
		{
			internal uint magic;

			internal uint bitlen;

			internal uint pubexp;
		}

		[SuppressUnmanagedCodeSecurity]
		[SecurityCritical]
		internal static class CAPISafe
		{
			[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern IntPtr GetProcAddress([In] SafeLibraryHandle hModule, [In][MarshalAs(UnmanagedType.LPStr)] string lpProcName);

			[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern SafeLocalAllocHandle LocalAlloc([In] uint uFlags, [In] IntPtr sizetdwBytes);

			[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, EntryPoint = "LoadLibraryA", SetLastError = true)]
			internal static extern SafeLibraryHandle LoadLibrary([In][MarshalAs(UnmanagedType.LPStr)] string lpFileName);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern SafeCertContextHandle CertCreateCertificateContext([In] uint dwCertEncodingType, [In] SafeLocalAllocHandle pbCertEncoded, [In] uint cbCertEncoded);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern SafeCertContextHandle CertDuplicateCertificateContext([In] IntPtr pCertContext);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CertFreeCertificateContext([In] IntPtr pCertContext);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CertGetCertificateChain([In] IntPtr hChainEngine, [In] SafeCertContextHandle pCertContext, [In] ref System.Runtime.InteropServices.ComTypes.FILETIME pTime, [In] SafeCertStoreHandle hAdditionalStore, [In] ref CERT_CHAIN_PARA pChainPara, [In] uint dwFlags, [In] IntPtr pvReserved, [In][Out] ref SafeCertChainHandle ppChainContext);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CertGetCertificateContextProperty([In] SafeCertContextHandle pCertContext, [In] uint dwPropId, [In][Out] SafeLocalAllocHandle pvData, [In][Out] ref uint pcbData);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CertGetCertificateContextProperty([In] SafeCertContextHandle pCertContext, [In] uint dwPropId, out IntPtr data, [In][Out] ref uint pcbData);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern uint CertGetPublicKeyLength([In] uint dwCertEncodingType, [In] IntPtr pPublicKey);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern uint CertNameToStrW([In] uint dwCertEncodingType, [In] IntPtr pName, [In] uint dwStrType, [In][Out] SafeLocalAllocHandle psz, [In] uint csz);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CertVerifyCertificateChainPolicy([In] IntPtr pszPolicyOID, [In] SafeCertChainHandle pChainContext, [In] ref CERT_CHAIN_POLICY_PARA pPolicyPara, [In][Out] ref CERT_CHAIN_POLICY_STATUS pPolicyStatus);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptAcquireCertificatePrivateKey([In] SafeCertContextHandle pCert, [In] uint dwFlags, [In] IntPtr pvReserved, [In][Out] ref IntPtr phCryptProv, [In][Out] ref uint pdwKeySpec, [In][Out] ref bool pfCallerFreeProv);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptDecodeObject([In] uint dwCertEncodingType, [In] IntPtr lpszStructType, [In] IntPtr pbEncoded, [In] uint cbEncoded, [In] uint dwFlags, [In][Out] SafeLocalAllocHandle pvStructInfo, [In][Out] IntPtr pcbStructInfo);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptDecodeObject([In] uint dwCertEncodingType, [In] IntPtr lpszStructType, [In] byte[] pbEncoded, [In] uint cbEncoded, [In] uint dwFlags, [In][Out] SafeLocalAllocHandle pvStructInfo, [In][Out] IntPtr pcbStructInfo);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptEncodeObject([In] uint dwCertEncodingType, [In] IntPtr lpszStructType, [In] IntPtr pvStructInfo, [In][Out] SafeLocalAllocHandle pbEncoded, [In][Out] IntPtr pcbEncoded);

			[DllImport("crypt32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptEncodeObject([In] uint dwCertEncodingType, [In][MarshalAs(UnmanagedType.LPStr)] string lpszStructType, [In] IntPtr pvStructInfo, [In][Out] SafeLocalAllocHandle pbEncoded, [In][Out] IntPtr pcbEncoded);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern IntPtr CryptFindOIDInfo([In] uint dwKeyType, [In] IntPtr pvKey, [In] uint dwGroupId);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern IntPtr CryptFindOIDInfo([In] uint dwKeyType, [In] SafeLocalAllocHandle pvKey, [In] uint dwGroupId);

			[DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptGetProvParam([In] SafeCryptProvHandle hProv, [In] uint dwParam, [In] IntPtr pbData, [In] IntPtr pdwDataLen, [In] uint dwFlags);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptMsgGetParam([In] SafeCryptMsgHandle hCryptMsg, [In] uint dwParamType, [In] uint dwIndex, [In][Out] IntPtr pvData, [In][Out] IntPtr pcbData);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptMsgGetParam([In] SafeCryptMsgHandle hCryptMsg, [In] uint dwParamType, [In] uint dwIndex, [In][Out] SafeLocalAllocHandle pvData, [In][Out] IntPtr pcbData);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern SafeCryptMsgHandle CryptMsgOpenToDecode([In] uint dwMsgEncodingType, [In] uint dwFlags, [In] uint dwMsgType, [In] IntPtr hCryptProv, [In] IntPtr pRecipientInfo, [In] IntPtr pStreamInfo);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptMsgUpdate([In] SafeCryptMsgHandle hCryptMsg, [In] byte[] pbData, [In] uint cbData, [In] bool fFinal);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptMsgUpdate([In] SafeCryptMsgHandle hCryptMsg, [In] IntPtr pbData, [In] uint cbData, [In] bool fFinal);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptMsgVerifyCountersignatureEncoded([In] IntPtr hCryptProv, [In] uint dwEncodingType, [In] IntPtr pbSignerInfo, [In] uint cbSignerInfo, [In] IntPtr pbSignerInfoCountersignature, [In] uint cbSignerInfoCountersignature, [In] IntPtr pciCountersigner);

			[DllImport("kernel32.dll", SetLastError = true)]
			[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
			internal static extern IntPtr LocalFree(IntPtr handle);

			[DllImport("kernel32.dll", SetLastError = true)]
			[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
			internal static extern void ZeroMemory(IntPtr handle, uint length);

			[DllImport("advapi32.dll", SetLastError = true)]
			[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
			internal static extern int LsaNtStatusToWinError([In] int status);
		}

		[SuppressUnmanagedCodeSecurity]
		[SecurityCritical]
		internal static class CAPIUnsafe
		{
			[DllImport("advapi32.dll", BestFitMapping = false, CharSet = CharSet.Auto, EntryPoint = "CryptAcquireContextA")]
			internal static extern bool CryptAcquireContext([In][Out] ref SafeCryptProvHandle hCryptProv, [In][MarshalAs(UnmanagedType.LPStr)] string pszContainer, [In][MarshalAs(UnmanagedType.LPStr)] string pszProvider, [In] uint dwProvType, [In] uint dwFlags);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CertAddCertificateContextToStore([In] SafeCertStoreHandle hCertStore, [In] SafeCertContextHandle pCertContext, [In] uint dwAddDisposition, [In][Out] SafeCertContextHandle ppStoreContext);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CertAddCertificateLinkToStore([In] SafeCertStoreHandle hCertStore, [In] SafeCertContextHandle pCertContext, [In] uint dwAddDisposition, [In][Out] SafeCertContextHandle ppStoreContext);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern IntPtr CertEnumCertificatesInStore([In] SafeCertStoreHandle hCertStore, [In] IntPtr pPrevCertContext);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern SafeCertContextHandle CertFindCertificateInStore([In] SafeCertStoreHandle hCertStore, [In] uint dwCertEncodingType, [In] uint dwFindFlags, [In] uint dwFindType, [In] IntPtr pvFindPara, [In] SafeCertContextHandle pPrevCertContext);

			[DllImport("crypt32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
			internal static extern SafeCertStoreHandle CertOpenStore([In] IntPtr lpszStoreProvider, [In] uint dwMsgAndCertEncodingType, [In] IntPtr hCryptProv, [In] uint dwFlags, [In] string pvPara);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern SafeCertContextHandle CertCreateSelfSignCertificate([In] SafeCryptProvHandle hProv, [In] IntPtr pSubjectIssuerBlob, [In] uint dwFlags, [In] IntPtr pKeyProvInfo, [In] IntPtr pSignatureAlgorithm, [In] IntPtr pStartTime, [In] IntPtr pEndTime, [In] IntPtr pExtensions);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptMsgControl([In] SafeCryptMsgHandle hCryptMsg, [In] uint dwFlags, [In] uint dwCtrlType, [In] IntPtr pvCtrlPara);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern bool CryptMsgCountersign([In] SafeCryptMsgHandle hCryptMsg, [In] uint dwIndex, [In] uint cCountersigners, [In] IntPtr rgCountersigners);

			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern SafeCryptMsgHandle CryptMsgOpenToEncode([In] uint dwMsgEncodingType, [In] uint dwFlags, [In] uint dwMsgType, [In] IntPtr pvMsgEncodeInfo, [In] IntPtr pszInnerContentObjID, [In] IntPtr pStreamInfo);

			[DllImport("crypt32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
			internal static extern SafeCryptMsgHandle CryptMsgOpenToEncode([In] uint dwMsgEncodingType, [In] uint dwFlags, [In] uint dwMsgType, [In] IntPtr pvMsgEncodeInfo, [In][MarshalAs(UnmanagedType.LPStr)] string pszInnerContentObjID, [In] IntPtr pStreamInfo);

			[DllImport("crypt32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
			internal static extern bool CryptProtectData([In] IntPtr pDataIn, [In] string szDataDescr, [In] IntPtr pOptionalEntropy, [In] IntPtr pvReserved, [In] IntPtr pPromptStruct, [In] uint dwFlags, [In][Out] IntPtr pDataBlob);

			[DllImport("crypt32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
			internal static extern bool CryptUnprotectData([In] IntPtr pDataIn, [In] IntPtr ppszDataDescr, [In] IntPtr pOptionalEntropy, [In] IntPtr pvReserved, [In] IntPtr pPromptStruct, [In] uint dwFlags, [In][Out] IntPtr pDataBlob);

			[DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
			internal static extern int SystemFunction040([In][Out] byte[] pDataIn, [In] uint cbDataIn, [In] uint dwFlags);

			[DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
			internal static extern int SystemFunction041([In][Out] byte[] pDataIn, [In] uint cbDataIn, [In] uint dwFlags);

			[DllImport("cryptui.dll", CharSet = CharSet.Unicode, SetLastError = true)]
			internal static extern SafeCertContextHandle CryptUIDlgSelectCertificateW([In][Out][MarshalAs(UnmanagedType.LPStruct)] CRYPTUI_SELECTCERTIFICATE_STRUCTW csc);

			[DllImport("cryptui.dll", CharSet = CharSet.Unicode, SetLastError = true)]
			internal static extern bool CryptUIDlgViewCertificateW([In][MarshalAs(UnmanagedType.LPStruct)] CRYPTUI_VIEWCERTIFICATE_STRUCTW ViewInfo, [In][Out] IntPtr pfPropertiesChanged);
		}

		internal const string ADVAPI32 = "advapi32.dll";

		internal const string CRYPT32 = "crypt32.dll";

		internal const string CRYPTUI = "cryptui.dll";

		internal const string KERNEL32 = "kernel32.dll";

		internal const uint LMEM_FIXED = 0u;

		internal const uint LMEM_ZEROINIT = 64u;

		internal const uint LPTR = 64u;

		internal const int S_OK = 0;

		internal const int S_FALSE = 1;

		internal const uint FORMAT_MESSAGE_FROM_SYSTEM = 4096u;

		internal const uint FORMAT_MESSAGE_IGNORE_INSERTS = 512u;

		internal const uint VER_PLATFORM_WIN32s = 0u;

		internal const uint VER_PLATFORM_WIN32_WINDOWS = 1u;

		internal const uint VER_PLATFORM_WIN32_NT = 2u;

		internal const uint VER_PLATFORM_WINCE = 3u;

		internal const uint ASN_TAG_NULL = 5u;

		internal const uint ASN_TAG_OBJID = 6u;

		internal const uint CERT_QUERY_OBJECT_FILE = 1u;

		internal const uint CERT_QUERY_OBJECT_BLOB = 2u;

		internal const uint CERT_QUERY_CONTENT_CERT = 1u;

		internal const uint CERT_QUERY_CONTENT_CTL = 2u;

		internal const uint CERT_QUERY_CONTENT_CRL = 3u;

		internal const uint CERT_QUERY_CONTENT_SERIALIZED_STORE = 4u;

		internal const uint CERT_QUERY_CONTENT_SERIALIZED_CERT = 5u;

		internal const uint CERT_QUERY_CONTENT_SERIALIZED_CTL = 6u;

		internal const uint CERT_QUERY_CONTENT_SERIALIZED_CRL = 7u;

		internal const uint CERT_QUERY_CONTENT_PKCS7_SIGNED = 8u;

		internal const uint CERT_QUERY_CONTENT_PKCS7_UNSIGNED = 9u;

		internal const uint CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED = 10u;

		internal const uint CERT_QUERY_CONTENT_PKCS10 = 11u;

		internal const uint CERT_QUERY_CONTENT_PFX = 12u;

		internal const uint CERT_QUERY_CONTENT_CERT_PAIR = 13u;

		internal const uint CERT_QUERY_CONTENT_FLAG_CERT = 2u;

		internal const uint CERT_QUERY_CONTENT_FLAG_CTL = 4u;

		internal const uint CERT_QUERY_CONTENT_FLAG_CRL = 8u;

		internal const uint CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE = 16u;

		internal const uint CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT = 32u;

		internal const uint CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL = 64u;

		internal const uint CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL = 128u;

		internal const uint CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED = 256u;

		internal const uint CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED = 512u;

		internal const uint CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED = 1024u;

		internal const uint CERT_QUERY_CONTENT_FLAG_PKCS10 = 2048u;

		internal const uint CERT_QUERY_CONTENT_FLAG_PFX = 4096u;

		internal const uint CERT_QUERY_CONTENT_FLAG_CERT_PAIR = 8192u;

		internal const uint CERT_QUERY_CONTENT_FLAG_ALL = 16382u;

		internal const uint CERT_QUERY_FORMAT_BINARY = 1u;

		internal const uint CERT_QUERY_FORMAT_BASE64_ENCODED = 2u;

		internal const uint CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED = 3u;

		internal const uint CERT_QUERY_FORMAT_FLAG_BINARY = 2u;

		internal const uint CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED = 4u;

		internal const uint CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED = 8u;

		internal const uint CERT_QUERY_FORMAT_FLAG_ALL = 14u;

		internal const uint CRYPTPROTECT_UI_FORBIDDEN = 1u;

		internal const uint CRYPTPROTECT_LOCAL_MACHINE = 4u;

		internal const uint CRYPTPROTECT_CRED_SYNC = 8u;

		internal const uint CRYPTPROTECT_AUDIT = 16u;

		internal const uint CRYPTPROTECT_NO_RECOVERY = 32u;

		internal const uint CRYPTPROTECT_VERIFY_PROTECTION = 64u;

		internal const uint CRYPTPROTECTMEMORY_BLOCK_SIZE = 16u;

		internal const uint CRYPTPROTECTMEMORY_SAME_PROCESS = 0u;

		internal const uint CRYPTPROTECTMEMORY_CROSS_PROCESS = 1u;

		internal const uint CRYPTPROTECTMEMORY_SAME_LOGON = 2u;

		internal const uint CRYPT_OID_INFO_OID_KEY = 1u;

		internal const uint CRYPT_OID_INFO_NAME_KEY = 2u;

		internal const uint CRYPT_OID_INFO_ALGID_KEY = 3u;

		internal const uint CRYPT_OID_INFO_SIGN_KEY = 4u;

		internal const uint CRYPT_HASH_ALG_OID_GROUP_ID = 1u;

		internal const uint CRYPT_ENCRYPT_ALG_OID_GROUP_ID = 2u;

		internal const uint CRYPT_PUBKEY_ALG_OID_GROUP_ID = 3u;

		internal const uint CRYPT_SIGN_ALG_OID_GROUP_ID = 4u;

		internal const uint CRYPT_RDN_ATTR_OID_GROUP_ID = 5u;

		internal const uint CRYPT_EXT_OR_ATTR_OID_GROUP_ID = 6u;

		internal const uint CRYPT_ENHKEY_USAGE_OID_GROUP_ID = 7u;

		internal const uint CRYPT_POLICY_OID_GROUP_ID = 8u;

		internal const uint CRYPT_TEMPLATE_OID_GROUP_ID = 9u;

		internal const uint CRYPT_LAST_OID_GROUP_ID = 9u;

		internal const uint CRYPT_FIRST_ALG_OID_GROUP_ID = 1u;

		internal const uint CRYPT_LAST_ALG_OID_GROUP_ID = 4u;

		internal const uint CRYPT_ASN_ENCODING = 1u;

		internal const uint CRYPT_NDR_ENCODING = 2u;

		internal const uint X509_ASN_ENCODING = 1u;

		internal const uint X509_NDR_ENCODING = 2u;

		internal const uint PKCS_7_ASN_ENCODING = 65536u;

		internal const uint PKCS_7_NDR_ENCODING = 131072u;

		internal const uint PKCS_7_OR_X509_ASN_ENCODING = 65537u;

		internal const uint CERT_STORE_PROV_MSG = 1u;

		internal const uint CERT_STORE_PROV_MEMORY = 2u;

		internal const uint CERT_STORE_PROV_FILE = 3u;

		internal const uint CERT_STORE_PROV_REG = 4u;

		internal const uint CERT_STORE_PROV_PKCS7 = 5u;

		internal const uint CERT_STORE_PROV_SERIALIZED = 6u;

		internal const uint CERT_STORE_PROV_FILENAME_A = 7u;

		internal const uint CERT_STORE_PROV_FILENAME_W = 8u;

		internal const uint CERT_STORE_PROV_FILENAME = 8u;

		internal const uint CERT_STORE_PROV_SYSTEM_A = 9u;

		internal const uint CERT_STORE_PROV_SYSTEM_W = 10u;

		internal const uint CERT_STORE_PROV_SYSTEM = 10u;

		internal const uint CERT_STORE_PROV_COLLECTION = 11u;

		internal const uint CERT_STORE_PROV_SYSTEM_REGISTRY_A = 12u;

		internal const uint CERT_STORE_PROV_SYSTEM_REGISTRY_W = 13u;

		internal const uint CERT_STORE_PROV_SYSTEM_REGISTRY = 13u;

		internal const uint CERT_STORE_PROV_PHYSICAL_W = 14u;

		internal const uint CERT_STORE_PROV_PHYSICAL = 14u;

		internal const uint CERT_STORE_PROV_SMART_CARD_W = 15u;

		internal const uint CERT_STORE_PROV_SMART_CARD = 15u;

		internal const uint CERT_STORE_PROV_LDAP_W = 16u;

		internal const uint CERT_STORE_PROV_LDAP = 16u;

		internal const uint CERT_STORE_NO_CRYPT_RELEASE_FLAG = 1u;

		internal const uint CERT_STORE_SET_LOCALIZED_NAME_FLAG = 2u;

		internal const uint CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = 4u;

		internal const uint CERT_STORE_DELETE_FLAG = 16u;

		internal const uint CERT_STORE_SHARE_STORE_FLAG = 64u;

		internal const uint CERT_STORE_SHARE_CONTEXT_FLAG = 128u;

		internal const uint CERT_STORE_MANIFOLD_FLAG = 256u;

		internal const uint CERT_STORE_ENUM_ARCHIVED_FLAG = 512u;

		internal const uint CERT_STORE_UPDATE_KEYID_FLAG = 1024u;

		internal const uint CERT_STORE_BACKUP_RESTORE_FLAG = 2048u;

		internal const uint CERT_STORE_READONLY_FLAG = 32768u;

		internal const uint CERT_STORE_OPEN_EXISTING_FLAG = 16384u;

		internal const uint CERT_STORE_CREATE_NEW_FLAG = 8192u;

		internal const uint CERT_STORE_MAXIMUM_ALLOWED_FLAG = 4096u;

		internal const uint CERT_SYSTEM_STORE_UNPROTECTED_FLAG = 1073741824u;

		internal const uint CERT_SYSTEM_STORE_LOCATION_MASK = 16711680u;

		internal const uint CERT_SYSTEM_STORE_LOCATION_SHIFT = 16u;

		internal const uint CERT_SYSTEM_STORE_CURRENT_USER_ID = 1u;

		internal const uint CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = 2u;

		internal const uint CERT_SYSTEM_STORE_CURRENT_SERVICE_ID = 4u;

		internal const uint CERT_SYSTEM_STORE_SERVICES_ID = 5u;

		internal const uint CERT_SYSTEM_STORE_USERS_ID = 6u;

		internal const uint CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID = 7u;

		internal const uint CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID = 8u;

		internal const uint CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID = 9u;

		internal const uint CERT_SYSTEM_STORE_CURRENT_USER = 65536u;

		internal const uint CERT_SYSTEM_STORE_LOCAL_MACHINE = 131072u;

		internal const uint CERT_SYSTEM_STORE_CURRENT_SERVICE = 262144u;

		internal const uint CERT_SYSTEM_STORE_SERVICES = 327680u;

		internal const uint CERT_SYSTEM_STORE_USERS = 393216u;

		internal const uint CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY = 458752u;

		internal const uint CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY = 524288u;

		internal const uint CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE = 589824u;

		internal const uint CERT_NAME_EMAIL_TYPE = 1u;

		internal const uint CERT_NAME_RDN_TYPE = 2u;

		internal const uint CERT_NAME_ATTR_TYPE = 3u;

		internal const uint CERT_NAME_SIMPLE_DISPLAY_TYPE = 4u;

		internal const uint CERT_NAME_FRIENDLY_DISPLAY_TYPE = 5u;

		internal const uint CERT_NAME_DNS_TYPE = 6u;

		internal const uint CERT_NAME_URL_TYPE = 7u;

		internal const uint CERT_NAME_UPN_TYPE = 8u;

		internal const uint CERT_SIMPLE_NAME_STR = 1u;

		internal const uint CERT_OID_NAME_STR = 2u;

		internal const uint CERT_X500_NAME_STR = 3u;

		internal const uint CERT_NAME_STR_SEMICOLON_FLAG = 1073741824u;

		internal const uint CERT_NAME_STR_NO_PLUS_FLAG = 536870912u;

		internal const uint CERT_NAME_STR_NO_QUOTING_FLAG = 268435456u;

		internal const uint CERT_NAME_STR_CRLF_FLAG = 134217728u;

		internal const uint CERT_NAME_STR_COMMA_FLAG = 67108864u;

		internal const uint CERT_NAME_STR_REVERSE_FLAG = 33554432u;

		internal const uint CERT_NAME_ISSUER_FLAG = 1u;

		internal const uint CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG = 65536u;

		internal const uint CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG = 131072u;

		internal const uint CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG = 262144u;

		internal const uint CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG = 524288u;

		internal const uint CERT_KEY_PROV_HANDLE_PROP_ID = 1u;

		internal const uint CERT_KEY_PROV_INFO_PROP_ID = 2u;

		internal const uint CERT_SHA1_HASH_PROP_ID = 3u;

		internal const uint CERT_MD5_HASH_PROP_ID = 4u;

		internal const uint CERT_HASH_PROP_ID = 3u;

		internal const uint CERT_KEY_CONTEXT_PROP_ID = 5u;

		internal const uint CERT_KEY_SPEC_PROP_ID = 6u;

		internal const uint CERT_IE30_RESERVED_PROP_ID = 7u;

		internal const uint CERT_PUBKEY_HASH_RESERVED_PROP_ID = 8u;

		internal const uint CERT_ENHKEY_USAGE_PROP_ID = 9u;

		internal const uint CERT_CTL_USAGE_PROP_ID = 9u;

		internal const uint CERT_NEXT_UPDATE_LOCATION_PROP_ID = 10u;

		internal const uint CERT_FRIENDLY_NAME_PROP_ID = 11u;

		internal const uint CERT_PVK_FILE_PROP_ID = 12u;

		internal const uint CERT_DESCRIPTION_PROP_ID = 13u;

		internal const uint CERT_ACCESS_STATE_PROP_ID = 14u;

		internal const uint CERT_SIGNATURE_HASH_PROP_ID = 15u;

		internal const uint CERT_SMART_CARD_DATA_PROP_ID = 16u;

		internal const uint CERT_EFS_PROP_ID = 17u;

		internal const uint CERT_FORTEZZA_DATA_PROP_ID = 18u;

		internal const uint CERT_ARCHIVED_PROP_ID = 19u;

		internal const uint CERT_KEY_IDENTIFIER_PROP_ID = 20u;

		internal const uint CERT_AUTO_ENROLL_PROP_ID = 21u;

		internal const uint CERT_PUBKEY_ALG_PARA_PROP_ID = 22u;

		internal const uint CERT_CROSS_CERT_DIST_POINTS_PROP_ID = 23u;

		internal const uint CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID = 24u;

		internal const uint CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID = 25u;

		internal const uint CERT_ENROLLMENT_PROP_ID = 26u;

		internal const uint CERT_DATE_STAMP_PROP_ID = 27u;

		internal const uint CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = 28u;

		internal const uint CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = 29u;

		internal const uint CERT_EXTENDED_ERROR_INFO_PROP_ID = 30u;

		internal const uint CERT_RENEWAL_PROP_ID = 64u;

		internal const uint CERT_ARCHIVED_KEY_HASH_PROP_ID = 65u;

		internal const uint CERT_FIRST_RESERVED_PROP_ID = 66u;

		internal const uint CERT_NCRYPT_KEY_HANDLE_PROP_ID = 78u;

		internal const uint CERT_DELETE_KEYSET_PROP_ID = 125u;

		internal const uint CERT_INFO_VERSION_FLAG = 1u;

		internal const uint CERT_INFO_SERIAL_NUMBER_FLAG = 2u;

		internal const uint CERT_INFO_SIGNATURE_ALGORITHM_FLAG = 3u;

		internal const uint CERT_INFO_ISSUER_FLAG = 4u;

		internal const uint CERT_INFO_NOT_BEFORE_FLAG = 5u;

		internal const uint CERT_INFO_NOT_AFTER_FLAG = 6u;

		internal const uint CERT_INFO_SUBJECT_FLAG = 7u;

		internal const uint CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG = 8u;

		internal const uint CERT_INFO_ISSUER_UNIQUE_ID_FLAG = 9u;

		internal const uint CERT_INFO_SUBJECT_UNIQUE_ID_FLAG = 10u;

		internal const uint CERT_INFO_EXTENSION_FLAG = 11u;

		internal const uint CERT_COMPARE_MASK = 65535u;

		internal const uint CERT_COMPARE_SHIFT = 16u;

		internal const uint CERT_COMPARE_ANY = 0u;

		internal const uint CERT_COMPARE_SHA1_HASH = 1u;

		internal const uint CERT_COMPARE_NAME = 2u;

		internal const uint CERT_COMPARE_ATTR = 3u;

		internal const uint CERT_COMPARE_MD5_HASH = 4u;

		internal const uint CERT_COMPARE_PROPERTY = 5u;

		internal const uint CERT_COMPARE_PUBLIC_KEY = 6u;

		internal const uint CERT_COMPARE_HASH = 1u;

		internal const uint CERT_COMPARE_NAME_STR_A = 7u;

		internal const uint CERT_COMPARE_NAME_STR_W = 8u;

		internal const uint CERT_COMPARE_KEY_SPEC = 9u;

		internal const uint CERT_COMPARE_ENHKEY_USAGE = 10u;

		internal const uint CERT_COMPARE_CTL_USAGE = 10u;

		internal const uint CERT_COMPARE_SUBJECT_CERT = 11u;

		internal const uint CERT_COMPARE_ISSUER_OF = 12u;

		internal const uint CERT_COMPARE_EXISTING = 13u;

		internal const uint CERT_COMPARE_SIGNATURE_HASH = 14u;

		internal const uint CERT_COMPARE_KEY_IDENTIFIER = 15u;

		internal const uint CERT_COMPARE_CERT_ID = 16u;

		internal const uint CERT_COMPARE_CROSS_CERT_DIST_POINTS = 17u;

		internal const uint CERT_COMPARE_PUBKEY_MD5_HASH = 18u;

		internal const uint CERT_FIND_ANY = 0u;

		internal const uint CERT_FIND_SHA1_HASH = 65536u;

		internal const uint CERT_FIND_MD5_HASH = 262144u;

		internal const uint CERT_FIND_SIGNATURE_HASH = 917504u;

		internal const uint CERT_FIND_KEY_IDENTIFIER = 983040u;

		internal const uint CERT_FIND_HASH = 65536u;

		internal const uint CERT_FIND_PROPERTY = 327680u;

		internal const uint CERT_FIND_PUBLIC_KEY = 393216u;

		internal const uint CERT_FIND_SUBJECT_NAME = 131079u;

		internal const uint CERT_FIND_SUBJECT_ATTR = 196615u;

		internal const uint CERT_FIND_ISSUER_NAME = 131076u;

		internal const uint CERT_FIND_ISSUER_ATTR = 196612u;

		internal const uint CERT_FIND_SUBJECT_STR_A = 458759u;

		internal const uint CERT_FIND_SUBJECT_STR_W = 524295u;

		internal const uint CERT_FIND_SUBJECT_STR = 524295u;

		internal const uint CERT_FIND_ISSUER_STR_A = 458756u;

		internal const uint CERT_FIND_ISSUER_STR_W = 524292u;

		internal const uint CERT_FIND_ISSUER_STR = 524292u;

		internal const uint CERT_FIND_KEY_SPEC = 589824u;

		internal const uint CERT_FIND_ENHKEY_USAGE = 655360u;

		internal const uint CERT_FIND_CTL_USAGE = 655360u;

		internal const uint CERT_FIND_SUBJECT_CERT = 720896u;

		internal const uint CERT_FIND_ISSUER_OF = 786432u;

		internal const uint CERT_FIND_EXISTING = 851968u;

		internal const uint CERT_FIND_CERT_ID = 1048576u;

		internal const uint CERT_FIND_CROSS_CERT_DIST_POINTS = 1114112u;

		internal const uint CERT_FIND_PUBKEY_MD5_HASH = 1179648u;

		internal const uint CERT_ENCIPHER_ONLY_KEY_USAGE = 1u;

		internal const uint CERT_CRL_SIGN_KEY_USAGE = 2u;

		internal const uint CERT_KEY_CERT_SIGN_KEY_USAGE = 4u;

		internal const uint CERT_KEY_AGREEMENT_KEY_USAGE = 8u;

		internal const uint CERT_DATA_ENCIPHERMENT_KEY_USAGE = 16u;

		internal const uint CERT_KEY_ENCIPHERMENT_KEY_USAGE = 32u;

		internal const uint CERT_NON_REPUDIATION_KEY_USAGE = 64u;

		internal const uint CERT_DIGITAL_SIGNATURE_KEY_USAGE = 128u;

		internal const uint CERT_DECIPHER_ONLY_KEY_USAGE = 32768u;

		internal const uint CERT_STORE_ADD_NEW = 1u;

		internal const uint CERT_STORE_ADD_USE_EXISTING = 2u;

		internal const uint CERT_STORE_ADD_REPLACE_EXISTING = 3u;

		internal const uint CERT_STORE_ADD_ALWAYS = 4u;

		internal const uint CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES = 5u;

		internal const uint CERT_STORE_ADD_NEWER = 6u;

		internal const uint CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES = 7u;

		internal const uint CERT_STORE_SAVE_AS_STORE = 1u;

		internal const uint CERT_STORE_SAVE_AS_PKCS7 = 2u;

		internal const uint CERT_STORE_SAVE_TO_FILE = 1u;

		internal const uint CERT_STORE_SAVE_TO_MEMORY = 2u;

		internal const uint CERT_STORE_SAVE_TO_FILENAME_A = 3u;

		internal const uint CERT_STORE_SAVE_TO_FILENAME_W = 4u;

		internal const uint CERT_STORE_SAVE_TO_FILENAME = 4u;

		internal const uint CERT_CA_SUBJECT_FLAG = 128u;

		internal const uint CERT_END_ENTITY_SUBJECT_FLAG = 64u;

		internal const uint RSA_CSP_PUBLICKEYBLOB = 19u;

		internal const uint X509_MULTI_BYTE_UINT = 38u;

		internal const uint X509_DSS_PUBLICKEY = 38u;

		internal const uint X509_DSS_PARAMETERS = 39u;

		internal const uint X509_DSS_SIGNATURE = 40u;

		internal const uint X509_EXTENSIONS = 5u;

		internal const uint X509_NAME_VALUE = 6u;

		internal const uint X509_NAME = 7u;

		internal const uint X509_AUTHORITY_KEY_ID = 9u;

		internal const uint X509_KEY_USAGE_RESTRICTION = 11u;

		internal const uint X509_BASIC_CONSTRAINTS = 13u;

		internal const uint X509_KEY_USAGE = 14u;

		internal const uint X509_BASIC_CONSTRAINTS2 = 15u;

		internal const uint X509_CERT_POLICIES = 16u;

		internal const uint PKCS_UTC_TIME = 17u;

		internal const uint PKCS_ATTRIBUTE = 22u;

		internal const uint X509_UNICODE_NAME_VALUE = 24u;

		internal const uint X509_OCTET_STRING = 25u;

		internal const uint X509_BITS = 26u;

		internal const uint X509_ANY_STRING = 6u;

		internal const uint X509_UNICODE_ANY_STRING = 24u;

		internal const uint X509_ENHANCED_KEY_USAGE = 36u;

		internal const uint PKCS_RC2_CBC_PARAMETERS = 41u;

		internal const uint X509_CERTIFICATE_TEMPLATE = 64u;

		internal const uint PKCS7_SIGNER_INFO = 500u;

		internal const uint CMS_SIGNER_INFO = 501u;

		internal const string szOID_AUTHORITY_KEY_IDENTIFIER = "2.5.29.1";

		internal const string szOID_KEY_USAGE_RESTRICTION = "2.5.29.4";

		internal const string szOID_KEY_USAGE = "2.5.29.15";

		internal const string szOID_KEYID_RDN = "1.3.6.1.4.1.311.10.7.1";

		internal const string szOID_RDN_DUMMY_SIGNER = "1.3.6.1.4.1.311.21.9";

		internal const uint CERT_CHAIN_POLICY_BASE = 1u;

		internal const uint CERT_CHAIN_POLICY_AUTHENTICODE = 2u;

		internal const uint CERT_CHAIN_POLICY_AUTHENTICODE_TS = 3u;

		internal const uint CERT_CHAIN_POLICY_SSL = 4u;

		internal const uint CERT_CHAIN_POLICY_BASIC_CONSTRAINTS = 5u;

		internal const uint CERT_CHAIN_POLICY_NT_AUTH = 6u;

		internal const uint CERT_CHAIN_POLICY_MICROSOFT_ROOT = 7u;

		internal const uint USAGE_MATCH_TYPE_AND = 0u;

		internal const uint USAGE_MATCH_TYPE_OR = 1u;

		internal const uint CERT_CHAIN_REVOCATION_CHECK_END_CERT = 268435456u;

		internal const uint CERT_CHAIN_REVOCATION_CHECK_CHAIN = 536870912u;

		internal const uint CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = 1073741824u;

		internal const uint CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY = 2147483648u;

		internal const uint CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT = 134217728u;

		internal const uint CERT_TRUST_NO_ERROR = 0u;

		internal const uint CERT_TRUST_IS_NOT_TIME_VALID = 1u;

		internal const uint CERT_TRUST_IS_NOT_TIME_NESTED = 2u;

		internal const uint CERT_TRUST_IS_REVOKED = 4u;

		internal const uint CERT_TRUST_IS_NOT_SIGNATURE_VALID = 8u;

		internal const uint CERT_TRUST_IS_NOT_VALID_FOR_USAGE = 16u;

		internal const uint CERT_TRUST_IS_UNTRUSTED_ROOT = 32u;

		internal const uint CERT_TRUST_REVOCATION_STATUS_UNKNOWN = 64u;

		internal const uint CERT_TRUST_IS_CYCLIC = 128u;

		internal const uint CERT_TRUST_INVALID_EXTENSION = 256u;

		internal const uint CERT_TRUST_INVALID_POLICY_CONSTRAINTS = 512u;

		internal const uint CERT_TRUST_INVALID_BASIC_CONSTRAINTS = 1024u;

		internal const uint CERT_TRUST_INVALID_NAME_CONSTRAINTS = 2048u;

		internal const uint CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT = 4096u;

		internal const uint CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT = 8192u;

		internal const uint CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = 16384u;

		internal const uint CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT = 32768u;

		internal const uint CERT_TRUST_IS_OFFLINE_REVOCATION = 16777216u;

		internal const uint CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY = 33554432u;

		internal const uint CERT_TRUST_IS_PARTIAL_CHAIN = 65536u;

		internal const uint CERT_TRUST_CTL_IS_NOT_TIME_VALID = 131072u;

		internal const uint CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID = 262144u;

		internal const uint CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE = 524288u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG = 1u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG = 2u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG = 4u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = 8u;

		internal const uint CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG = 16u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG = 32u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG = 64u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG = 128u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG = 256u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG = 512u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG = 1024u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG = 2048u;

		internal const uint CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS = 3840u;

		internal const uint CERT_TRUST_HAS_EXACT_MATCH_ISSUER = 1u;

		internal const uint CERT_TRUST_HAS_KEY_MATCH_ISSUER = 2u;

		internal const uint CERT_TRUST_HAS_NAME_MATCH_ISSUER = 4u;

		internal const uint CERT_TRUST_IS_SELF_SIGNED = 8u;

		internal const uint CERT_TRUST_HAS_PREFERRED_ISSUER = 256u;

		internal const uint CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY = 512u;

		internal const uint CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS = 1024u;

		internal const uint CERT_TRUST_IS_COMPLEX_CHAIN = 65536u;

		internal const string szOID_PKIX_NO_SIGNATURE = "1.3.6.1.5.5.7.6.2";

		internal const string szOID_PKIX_KP_SERVER_AUTH = "1.3.6.1.5.5.7.3.1";

		internal const string szOID_PKIX_KP_CLIENT_AUTH = "1.3.6.1.5.5.7.3.2";

		internal const string szOID_PKIX_KP_CODE_SIGNING = "1.3.6.1.5.5.7.3.3";

		internal const string szOID_PKIX_KP_EMAIL_PROTECTION = "1.3.6.1.5.5.7.3.4";

		internal const string SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID = "1.3.6.1.4.1.311.2.1.21";

		internal const string SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID = "1.3.6.1.4.1.311.2.1.22";

		internal const uint HCCE_CURRENT_USER = 0u;

		internal const uint HCCE_LOCAL_MACHINE = 1u;

		internal const string szOID_PKCS_1 = "1.2.840.113549.1.1";

		internal const string szOID_PKCS_2 = "1.2.840.113549.1.2";

		internal const string szOID_PKCS_3 = "1.2.840.113549.1.3";

		internal const string szOID_PKCS_4 = "1.2.840.113549.1.4";

		internal const string szOID_PKCS_5 = "1.2.840.113549.1.5";

		internal const string szOID_PKCS_6 = "1.2.840.113549.1.6";

		internal const string szOID_PKCS_7 = "1.2.840.113549.1.7";

		internal const string szOID_PKCS_8 = "1.2.840.113549.1.8";

		internal const string szOID_PKCS_9 = "1.2.840.113549.1.9";

		internal const string szOID_PKCS_10 = "1.2.840.113549.1.10";

		internal const string szOID_PKCS_12 = "1.2.840.113549.1.12";

		internal const string szOID_RSA_data = "1.2.840.113549.1.7.1";

		internal const string szOID_RSA_signedData = "1.2.840.113549.1.7.2";

		internal const string szOID_RSA_envelopedData = "1.2.840.113549.1.7.3";

		internal const string szOID_RSA_signEnvData = "1.2.840.113549.1.7.4";

		internal const string szOID_RSA_digestedData = "1.2.840.113549.1.7.5";

		internal const string szOID_RSA_hashedData = "1.2.840.113549.1.7.5";

		internal const string szOID_RSA_encryptedData = "1.2.840.113549.1.7.6";

		internal const string szOID_RSA_emailAddr = "1.2.840.113549.1.9.1";

		internal const string szOID_RSA_unstructName = "1.2.840.113549.1.9.2";

		internal const string szOID_RSA_contentType = "1.2.840.113549.1.9.3";

		internal const string szOID_RSA_messageDigest = "1.2.840.113549.1.9.4";

		internal const string szOID_RSA_signingTime = "1.2.840.113549.1.9.5";

		internal const string szOID_RSA_counterSign = "1.2.840.113549.1.9.6";

		internal const string szOID_RSA_challengePwd = "1.2.840.113549.1.9.7";

		internal const string szOID_RSA_unstructAddr = "1.2.840.113549.1.9.8";

		internal const string szOID_RSA_extCertAttrs = "1.2.840.113549.1.9.9";

		internal const string szOID_RSA_SMIMECapabilities = "1.2.840.113549.1.9.15";

		internal const string szOID_CAPICOM = "1.3.6.1.4.1.311.88";

		internal const string szOID_CAPICOM_version = "1.3.6.1.4.1.311.88.1";

		internal const string szOID_CAPICOM_attribute = "1.3.6.1.4.1.311.88.2";

		internal const string szOID_CAPICOM_documentName = "1.3.6.1.4.1.311.88.2.1";

		internal const string szOID_CAPICOM_documentDescription = "1.3.6.1.4.1.311.88.2.2";

		internal const string szOID_CAPICOM_encryptedData = "1.3.6.1.4.1.311.88.3";

		internal const string szOID_CAPICOM_encryptedContent = "1.3.6.1.4.1.311.88.3.1";

		internal const string szOID_OIWSEC_sha1 = "1.3.14.3.2.26";

		internal const string szOID_RSA_MD5 = "1.2.840.113549.2.5";

		internal const string szOID_OIWSEC_SHA256 = "2.16.840.1.101.3.4.1";

		internal const string szOID_OIWSEC_SHA384 = "2.16.840.1.101.3.4.2";

		internal const string szOID_OIWSEC_SHA512 = "2.16.840.1.101.3.4.3";

		internal const string szOID_RSA_RC2CBC = "1.2.840.113549.3.2";

		internal const string szOID_RSA_RC4 = "1.2.840.113549.3.4";

		internal const string szOID_RSA_DES_EDE3_CBC = "1.2.840.113549.3.7";

		internal const string szOID_OIWSEC_desCBC = "1.3.14.3.2.7";

		internal const string szOID_NIST_AES128_CBC = "2.16.840.1.101.3.4.1.2";

		internal const string szOID_NIST_AES192_CBC = "2.16.840.1.101.3.4.1.22";

		internal const string szOID_NIST_AES256_CBC = "2.16.840.1.101.3.4.1.42";

		internal const string szOID_RSA_SMIMEalg = "1.2.840.113549.1.9.16.3";

		internal const string szOID_RSA_SMIMEalgESDH = "1.2.840.113549.1.9.16.3.5";

		internal const string szOID_RSA_SMIMEalgCMS3DESwrap = "1.2.840.113549.1.9.16.3.6";

		internal const string szOID_RSA_SMIMEalgCMSRC2wrap = "1.2.840.113549.1.9.16.3.7";

		internal const string szOID_X957_DSA = "1.2.840.10040.4.1";

		internal const string szOID_X957_sha1DSA = "1.2.840.10040.4.3";

		internal const string szOID_OIWSEC_sha1RSASign = "1.3.14.3.2.29";

		internal const uint CERT_ALT_NAME_OTHER_NAME = 1u;

		internal const uint CERT_ALT_NAME_RFC822_NAME = 2u;

		internal const uint CERT_ALT_NAME_DNS_NAME = 3u;

		internal const uint CERT_ALT_NAME_X400_ADDRESS = 4u;

		internal const uint CERT_ALT_NAME_DIRECTORY_NAME = 5u;

		internal const uint CERT_ALT_NAME_EDI_PARTY_NAME = 6u;

		internal const uint CERT_ALT_NAME_URL = 7u;

		internal const uint CERT_ALT_NAME_IP_ADDRESS = 8u;

		internal const uint CERT_ALT_NAME_REGISTERED_ID = 9u;

		internal const uint CERT_RDN_ANY_TYPE = 0u;

		internal const uint CERT_RDN_ENCODED_BLOB = 1u;

		internal const uint CERT_RDN_OCTET_STRING = 2u;

		internal const uint CERT_RDN_NUMERIC_STRING = 3u;

		internal const uint CERT_RDN_PRINTABLE_STRING = 4u;

		internal const uint CERT_RDN_TELETEX_STRING = 5u;

		internal const uint CERT_RDN_T61_STRING = 5u;

		internal const uint CERT_RDN_VIDEOTEX_STRING = 6u;

		internal const uint CERT_RDN_IA5_STRING = 7u;

		internal const uint CERT_RDN_GRAPHIC_STRING = 8u;

		internal const uint CERT_RDN_VISIBLE_STRING = 9u;

		internal const uint CERT_RDN_ISO646_STRING = 9u;

		internal const uint CERT_RDN_GENERAL_STRING = 10u;

		internal const uint CERT_RDN_UNIVERSAL_STRING = 11u;

		internal const uint CERT_RDN_INT4_STRING = 11u;

		internal const uint CERT_RDN_BMP_STRING = 12u;

		internal const uint CERT_RDN_UNICODE_STRING = 12u;

		internal const uint CERT_RDN_UTF8_STRING = 13u;

		internal const uint CERT_RDN_TYPE_MASK = 255u;

		internal const uint CERT_RDN_FLAGS_MASK = 4278190080u;

		internal const uint CERT_STORE_CTRL_RESYNC = 1u;

		internal const uint CERT_STORE_CTRL_NOTIFY_CHANGE = 2u;

		internal const uint CERT_STORE_CTRL_COMMIT = 3u;

		internal const uint CERT_STORE_CTRL_AUTO_RESYNC = 4u;

		internal const uint CERT_STORE_CTRL_CANCEL_NOTIFY = 5u;

		internal const uint CERT_ID_ISSUER_SERIAL_NUMBER = 1u;

		internal const uint CERT_ID_KEY_IDENTIFIER = 2u;

		internal const uint CERT_ID_SHA1_HASH = 3u;

		internal const string MS_ENHANCED_PROV = "Microsoft Enhanced Cryptographic Provider v1.0";

		internal const string MS_STRONG_PROV = "Microsoft Strong Cryptographic Provider";

		internal const string MS_DEF_PROV = "Microsoft Base Cryptographic Provider v1.0";

		internal const string MS_DEF_DSS_DH_PROV = "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider";

		internal const string MS_ENH_DSS_DH_PROV = "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider";

		internal const string DummySignerCommonName = "CN=Dummy Signer";

		internal const uint PROV_RSA_FULL = 1u;

		internal const uint PROV_DSS_DH = 13u;

		internal const uint ALG_TYPE_ANY = 0u;

		internal const uint ALG_TYPE_DSS = 512u;

		internal const uint ALG_TYPE_RSA = 1024u;

		internal const uint ALG_TYPE_BLOCK = 1536u;

		internal const uint ALG_TYPE_STREAM = 2048u;

		internal const uint ALG_TYPE_DH = 2560u;

		internal const uint ALG_TYPE_SECURECHANNEL = 3072u;

		internal const uint ALG_CLASS_ANY = 0u;

		internal const uint ALG_CLASS_SIGNATURE = 8192u;

		internal const uint ALG_CLASS_MSG_ENCRYPT = 16384u;

		internal const uint ALG_CLASS_DATA_ENCRYPT = 24576u;

		internal const uint ALG_CLASS_HASH = 32768u;

		internal const uint ALG_CLASS_KEY_EXCHANGE = 40960u;

		internal const uint ALG_CLASS_ALL = 57344u;

		internal const uint ALG_SID_ANY = 0u;

		internal const uint ALG_SID_RSA_ANY = 0u;

		internal const uint ALG_SID_RSA_PKCS = 1u;

		internal const uint ALG_SID_RSA_MSATWORK = 2u;

		internal const uint ALG_SID_RSA_ENTRUST = 3u;

		internal const uint ALG_SID_RSA_PGP = 4u;

		internal const uint ALG_SID_DSS_ANY = 0u;

		internal const uint ALG_SID_DSS_PKCS = 1u;

		internal const uint ALG_SID_DSS_DMS = 2u;

		internal const uint ALG_SID_DES = 1u;

		internal const uint ALG_SID_3DES = 3u;

		internal const uint ALG_SID_DESX = 4u;

		internal const uint ALG_SID_IDEA = 5u;

		internal const uint ALG_SID_CAST = 6u;

		internal const uint ALG_SID_SAFERSK64 = 7u;

		internal const uint ALG_SID_SAFERSK128 = 8u;

		internal const uint ALG_SID_3DES_112 = 9u;

		internal const uint ALG_SID_CYLINK_MEK = 12u;

		internal const uint ALG_SID_RC5 = 13u;

		internal const uint ALG_SID_AES_128 = 14u;

		internal const uint ALG_SID_AES_192 = 15u;

		internal const uint ALG_SID_AES_256 = 16u;

		internal const uint ALG_SID_AES = 17u;

		internal const uint ALG_SID_SKIPJACK = 10u;

		internal const uint ALG_SID_TEK = 11u;

		internal const uint ALG_SID_RC2 = 2u;

		internal const uint ALG_SID_RC4 = 1u;

		internal const uint ALG_SID_SEAL = 2u;

		internal const uint ALG_SID_DH_SANDF = 1u;

		internal const uint ALG_SID_DH_EPHEM = 2u;

		internal const uint ALG_SID_AGREED_KEY_ANY = 3u;

		internal const uint ALG_SID_KEA = 4u;

		internal const uint ALG_SID_MD2 = 1u;

		internal const uint ALG_SID_MD4 = 2u;

		internal const uint ALG_SID_MD5 = 3u;

		internal const uint ALG_SID_SHA = 4u;

		internal const uint ALG_SID_SHA1 = 4u;

		internal const uint ALG_SID_MAC = 5u;

		internal const uint ALG_SID_RIPEMD = 6u;

		internal const uint ALG_SID_RIPEMD160 = 7u;

		internal const uint ALG_SID_SSL3SHAMD5 = 8u;

		internal const uint ALG_SID_HMAC = 9u;

		internal const uint ALG_SID_TLS1PRF = 10u;

		internal const uint ALG_SID_HASH_REPLACE_OWF = 11u;

		internal const uint ALG_SID_SSL3_MASTER = 1u;

		internal const uint ALG_SID_SCHANNEL_MASTER_HASH = 2u;

		internal const uint ALG_SID_SCHANNEL_MAC_KEY = 3u;

		internal const uint ALG_SID_PCT1_MASTER = 4u;

		internal const uint ALG_SID_SSL2_MASTER = 5u;

		internal const uint ALG_SID_TLS1_MASTER = 6u;

		internal const uint ALG_SID_SCHANNEL_ENC_KEY = 7u;

		internal const uint CALG_MD2 = 32769u;

		internal const uint CALG_MD4 = 32770u;

		internal const uint CALG_MD5 = 32771u;

		internal const uint CALG_SHA = 32772u;

		internal const uint CALG_SHA1 = 32772u;

		internal const uint CALG_MAC = 32773u;

		internal const uint CALG_RSA_SIGN = 9216u;

		internal const uint CALG_DSS_SIGN = 8704u;

		internal const uint CALG_NO_SIGN = 8192u;

		internal const uint CALG_RSA_KEYX = 41984u;

		internal const uint CALG_DES = 26113u;

		internal const uint CALG_3DES_112 = 26121u;

		internal const uint CALG_3DES = 26115u;

		internal const uint CALG_DESX = 26116u;

		internal const uint CALG_RC2 = 26114u;

		internal const uint CALG_RC4 = 26625u;

		internal const uint CALG_SEAL = 26626u;

		internal const uint CALG_DH_SF = 43521u;

		internal const uint CALG_DH_EPHEM = 43522u;

		internal const uint CALG_AGREEDKEY_ANY = 43523u;

		internal const uint CALG_KEA_KEYX = 43524u;

		internal const uint CALG_HUGHES_MD5 = 40963u;

		internal const uint CALG_SKIPJACK = 26122u;

		internal const uint CALG_TEK = 26123u;

		internal const uint CALG_CYLINK_MEK = 26124u;

		internal const uint CALG_SSL3_SHAMD5 = 32776u;

		internal const uint CALG_SSL3_MASTER = 19457u;

		internal const uint CALG_SCHANNEL_MASTER_HASH = 19458u;

		internal const uint CALG_SCHANNEL_MAC_KEY = 19459u;

		internal const uint CALG_SCHANNEL_ENC_KEY = 19463u;

		internal const uint CALG_PCT1_MASTER = 19460u;

		internal const uint CALG_SSL2_MASTER = 19461u;

		internal const uint CALG_TLS1_MASTER = 19462u;

		internal const uint CALG_RC5 = 26125u;

		internal const uint CALG_HMAC = 32777u;

		internal const uint CALG_TLS1PRF = 32778u;

		internal const uint CALG_HASH_REPLACE_OWF = 32779u;

		internal const uint CALG_AES_128 = 26126u;

		internal const uint CALG_AES_192 = 26127u;

		internal const uint CALG_AES_256 = 26128u;

		internal const uint CALG_AES = 26129u;

		internal const uint CRYPT_FIRST = 1u;

		internal const uint CRYPT_NEXT = 2u;

		internal const uint PP_ENUMALGS_EX = 22u;

		internal const uint CRYPT_VERIFYCONTEXT = 4026531840u;

		internal const uint CRYPT_NEWKEYSET = 8u;

		internal const uint CRYPT_DELETEKEYSET = 16u;

		internal const uint CRYPT_MACHINE_KEYSET = 32u;

		internal const uint CRYPT_SILENT = 64u;

		internal const uint CRYPT_USER_KEYSET = 4096u;

		internal const uint PKCS12_ALWAYS_CNG_KSP = 512u;

		internal const uint PKCS12_NO_PERSIST_KEY = 32768u;

		internal const uint CRYPT_EXPORTABLE = 1u;

		internal const uint CRYPT_USER_PROTECTED = 2u;

		internal const uint CRYPT_CREATE_SALT = 4u;

		internal const uint CRYPT_UPDATE_KEY = 8u;

		internal const uint CRYPT_NO_SALT = 16u;

		internal const uint CRYPT_PREGEN = 64u;

		internal const uint CRYPT_RECIPIENT = 16u;

		internal const uint CRYPT_INITIATOR = 64u;

		internal const uint CRYPT_ONLINE = 128u;

		internal const uint CRYPT_SF = 256u;

		internal const uint CRYPT_CREATE_IV = 512u;

		internal const uint CRYPT_KEK = 1024u;

		internal const uint CRYPT_DATA_KEY = 2048u;

		internal const uint CRYPT_VOLATILE = 4096u;

		internal const uint CRYPT_SGCKEY = 8192u;

		internal const uint CRYPT_ARCHIVABLE = 16384u;

		internal const byte CUR_BLOB_VERSION = 2;

		internal const byte SIMPLEBLOB = 1;

		internal const byte PUBLICKEYBLOB = 6;

		internal const byte PRIVATEKEYBLOB = 7;

		internal const byte PLAINTEXTKEYBLOB = 8;

		internal const byte OPAQUEKEYBLOB = 9;

		internal const byte PUBLICKEYBLOBEX = 10;

		internal const byte SYMMETRICWRAPKEYBLOB = 11;

		internal const uint DSS_MAGIC = 827544388u;

		internal const uint DSS_PRIVATE_MAGIC = 844321604u;

		internal const uint DSS_PUB_MAGIC_VER3 = 861098820u;

		internal const uint DSS_PRIV_MAGIC_VER3 = 877876036u;

		internal const uint RSA_PUB_MAGIC = 826364754u;

		internal const uint RSA_PRIV_MAGIC = 843141970u;

		internal const uint CRYPT_ACQUIRE_CACHE_FLAG = 1u;

		internal const uint CRYPT_ACQUIRE_USE_PROV_INFO_FLAG = 2u;

		internal const uint CRYPT_ACQUIRE_COMPARE_KEY_FLAG = 4u;

		internal const uint CRYPT_ACQUIRE_SILENT_FLAG = 64u;

		internal const uint CRYPT_ACQUIRE_PREFER_NCRYPT_KEY_FLAG = 131072u;

		internal const uint CMSG_BARE_CONTENT_FLAG = 1u;

		internal const uint CMSG_LENGTH_ONLY_FLAG = 2u;

		internal const uint CMSG_DETACHED_FLAG = 4u;

		internal const uint CMSG_AUTHENTICATED_ATTRIBUTES_FLAG = 8u;

		internal const uint CMSG_CONTENTS_OCTETS_FLAG = 16u;

		internal const uint CMSG_MAX_LENGTH_FLAG = 32u;

		internal const uint CMSG_TYPE_PARAM = 1u;

		internal const uint CMSG_CONTENT_PARAM = 2u;

		internal const uint CMSG_BARE_CONTENT_PARAM = 3u;

		internal const uint CMSG_INNER_CONTENT_TYPE_PARAM = 4u;

		internal const uint CMSG_SIGNER_COUNT_PARAM = 5u;

		internal const uint CMSG_SIGNER_INFO_PARAM = 6u;

		internal const uint CMSG_SIGNER_CERT_INFO_PARAM = 7u;

		internal const uint CMSG_SIGNER_HASH_ALGORITHM_PARAM = 8u;

		internal const uint CMSG_SIGNER_AUTH_ATTR_PARAM = 9u;

		internal const uint CMSG_SIGNER_UNAUTH_ATTR_PARAM = 10u;

		internal const uint CMSG_CERT_COUNT_PARAM = 11u;

		internal const uint CMSG_CERT_PARAM = 12u;

		internal const uint CMSG_CRL_COUNT_PARAM = 13u;

		internal const uint CMSG_CRL_PARAM = 14u;

		internal const uint CMSG_ENVELOPE_ALGORITHM_PARAM = 15u;

		internal const uint CMSG_RECIPIENT_COUNT_PARAM = 17u;

		internal const uint CMSG_RECIPIENT_INDEX_PARAM = 18u;

		internal const uint CMSG_RECIPIENT_INFO_PARAM = 19u;

		internal const uint CMSG_HASH_ALGORITHM_PARAM = 20u;

		internal const uint CMSG_HASH_DATA_PARAM = 21u;

		internal const uint CMSG_COMPUTED_HASH_PARAM = 22u;

		internal const uint CMSG_ENCRYPT_PARAM = 26u;

		internal const uint CMSG_ENCRYPTED_DIGEST = 27u;

		internal const uint CMSG_ENCODED_SIGNER = 28u;

		internal const uint CMSG_ENCODED_MESSAGE = 29u;

		internal const uint CMSG_VERSION_PARAM = 30u;

		internal const uint CMSG_ATTR_CERT_COUNT_PARAM = 31u;

		internal const uint CMSG_ATTR_CERT_PARAM = 32u;

		internal const uint CMSG_CMS_RECIPIENT_COUNT_PARAM = 33u;

		internal const uint CMSG_CMS_RECIPIENT_INDEX_PARAM = 34u;

		internal const uint CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM = 35u;

		internal const uint CMSG_CMS_RECIPIENT_INFO_PARAM = 36u;

		internal const uint CMSG_UNPROTECTED_ATTR_PARAM = 37u;

		internal const uint CMSG_SIGNER_CERT_ID_PARAM = 38u;

		internal const uint CMSG_CMS_SIGNER_INFO_PARAM = 39u;

		internal const uint CMSG_CTRL_VERIFY_SIGNATURE = 1u;

		internal const uint CMSG_CTRL_DECRYPT = 2u;

		internal const uint CMSG_CTRL_VERIFY_HASH = 5u;

		internal const uint CMSG_CTRL_ADD_SIGNER = 6u;

		internal const uint CMSG_CTRL_DEL_SIGNER = 7u;

		internal const uint CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR = 8u;

		internal const uint CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR = 9u;

		internal const uint CMSG_CTRL_ADD_CERT = 10u;

		internal const uint CMSG_CTRL_DEL_CERT = 11u;

		internal const uint CMSG_CTRL_ADD_CRL = 12u;

		internal const uint CMSG_CTRL_DEL_CRL = 13u;

		internal const uint CMSG_CTRL_ADD_ATTR_CERT = 14u;

		internal const uint CMSG_CTRL_DEL_ATTR_CERT = 15u;

		internal const uint CMSG_CTRL_KEY_TRANS_DECRYPT = 16u;

		internal const uint CMSG_CTRL_KEY_AGREE_DECRYPT = 17u;

		internal const uint CMSG_CTRL_MAIL_LIST_DECRYPT = 18u;

		internal const uint CMSG_CTRL_VERIFY_SIGNATURE_EX = 19u;

		internal const uint CMSG_CTRL_ADD_CMS_SIGNER_INFO = 20u;

		internal const uint CMSG_VERIFY_SIGNER_PUBKEY = 1u;

		internal const uint CMSG_VERIFY_SIGNER_CERT = 2u;

		internal const uint CMSG_VERIFY_SIGNER_CHAIN = 3u;

		internal const uint CMSG_VERIFY_SIGNER_NULL = 4u;

		internal const uint CMSG_DATA = 1u;

		internal const uint CMSG_SIGNED = 2u;

		internal const uint CMSG_ENVELOPED = 3u;

		internal const uint CMSG_SIGNED_AND_ENVELOPED = 4u;

		internal const uint CMSG_HASHED = 5u;

		internal const uint CMSG_ENCRYPTED = 6u;

		internal const uint CMSG_KEY_TRANS_RECIPIENT = 1u;

		internal const uint CMSG_KEY_AGREE_RECIPIENT = 2u;

		internal const uint CMSG_MAIL_LIST_RECIPIENT = 3u;

		internal const uint CMSG_KEY_AGREE_ORIGINATOR_CERT = 1u;

		internal const uint CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY = 2u;

		internal const uint CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE = 1u;

		internal const uint CMSG_KEY_AGREE_STATIC_KEY_CHOICE = 2u;

		internal const uint CMSG_ENVELOPED_RECIPIENT_V0 = 0u;

		internal const uint CMSG_ENVELOPED_RECIPIENT_V2 = 2u;

		internal const uint CMSG_ENVELOPED_RECIPIENT_V3 = 3u;

		internal const uint CMSG_ENVELOPED_RECIPIENT_V4 = 4u;

		internal const uint CMSG_KEY_TRANS_PKCS_1_5_VERSION = 0u;

		internal const uint CMSG_KEY_TRANS_CMS_VERSION = 2u;

		internal const uint CMSG_KEY_AGREE_VERSION = 3u;

		internal const uint CMSG_MAIL_LIST_VERSION = 4u;

		internal const uint CRYPT_RC2_40BIT_VERSION = 160u;

		internal const uint CRYPT_RC2_56BIT_VERSION = 52u;

		internal const uint CRYPT_RC2_64BIT_VERSION = 120u;

		internal const uint CRYPT_RC2_128BIT_VERSION = 58u;

		internal const int E_NOTIMPL = -2147483647;

		internal const int E_FILENOTFOUND = -2147024894;

		internal const int E_OUTOFMEMORY = -2147024882;

		internal const int NTE_NO_KEY = -2146893811;

		internal const int NTE_BAD_PUBLIC_KEY = -2146893803;

		internal const int NTE_BAD_KEYSET = -2146893802;

		internal const int CRYPT_E_MSG_ERROR = -2146889727;

		internal const int CRYPT_E_UNKNOWN_ALGO = -2146889726;

		internal const int CRYPT_E_INVALID_MSG_TYPE = -2146889724;

		internal const int CRYPT_E_RECIPIENT_NOT_FOUND = -2146889717;

		internal const int CRYPT_E_SIGNER_NOT_FOUND = -2146889714;

		internal const int CRYPT_E_ATTRIBUTES_MISSING = -2146889713;

		internal const int CRYPT_E_BAD_ENCODE = -2146885630;

		internal const int CRYPT_E_NOT_FOUND = -2146885628;

		internal const int CRYPT_E_NO_MATCH = -2146885623;

		internal const int CRYPT_E_NO_SIGNER = -2146885618;

		internal const int CRYPT_E_REVOKED = -2146885616;

		internal const int CRYPT_E_NO_REVOCATION_CHECK = -2146885614;

		internal const int CRYPT_E_REVOCATION_OFFLINE = -2146885613;

		internal const int CRYPT_E_ASN1_BADTAG = -2146881269;

		internal const int TRUST_E_CERT_SIGNATURE = -2146869244;

		internal const int TRUST_E_BASIC_CONSTRAINTS = -2146869223;

		internal const int CERT_E_EXPIRED = -2146762495;

		internal const int CERT_E_VALIDITYPERIODNESTING = -2146762494;

		internal const int CERT_E_UNTRUSTEDROOT = -2146762487;

		internal const int CERT_E_CHAINING = -2146762486;

		internal const int TRUST_E_FAIL = -2146762485;

		internal const int CERT_E_REVOKED = -2146762484;

		internal const int CERT_E_UNTRUSTEDTESTROOT = -2146762483;

		internal const int CERT_E_REVOCATION_FAILURE = -2146762482;

		internal const int CERT_E_WRONG_USAGE = -2146762480;

		internal const int CERT_E_INVALID_POLICY = -2146762477;

		internal const int CERT_E_INVALID_NAME = -2146762476;

		internal const int ERROR_SUCCESS = 0;

		internal const int ERROR_FILE_NOT_FOUND = 2;

		internal const int ERROR_CALL_NOT_IMPLEMENTED = 120;

		internal const int ERROR_CANCELLED = 1223;

		[SecurityCritical]
		internal static byte[] BlobToByteArray(IntPtr pBlob)
		{
			CRYPTOAPI_BLOB blob = (CRYPTOAPI_BLOB)Marshal.PtrToStructure(pBlob, typeof(CRYPTOAPI_BLOB));
			if (blob.cbData == 0)
			{
				return new byte[0];
			}
			return BlobToByteArray(blob);
		}

		[SecurityCritical]
		internal static byte[] BlobToByteArray(CRYPTOAPI_BLOB blob)
		{
			if (blob.cbData == 0)
			{
				return new byte[0];
			}
			byte[] array = new byte[blob.cbData];
			Marshal.Copy(blob.pbData, array, 0, array.Length);
			return array;
		}

		[SecurityCritical]
		internal unsafe static bool DecodeObject(IntPtr pszStructType, IntPtr pbEncoded, uint cbEncoded, out SafeLocalAllocHandle decodedValue, out uint cbDecodedValue)
		{
			decodedValue = SafeLocalAllocHandle.InvalidHandle;
			cbDecodedValue = 0u;
			uint num = 0u;
			SafeLocalAllocHandle invalidHandle = SafeLocalAllocHandle.InvalidHandle;
			if (!CAPISafe.CryptDecodeObject(65537u, pszStructType, pbEncoded, cbEncoded, 0u, invalidHandle, new IntPtr(&num)))
			{
				return false;
			}
			invalidHandle = LocalAlloc(0u, new IntPtr(num));
			if (!CAPISafe.CryptDecodeObject(65537u, pszStructType, pbEncoded, cbEncoded, 0u, invalidHandle, new IntPtr(&num)))
			{
				return false;
			}
			decodedValue = invalidHandle;
			cbDecodedValue = num;
			return true;
		}

		[SecurityCritical]
		internal unsafe static bool DecodeObject(IntPtr pszStructType, byte[] pbEncoded, out SafeLocalAllocHandle decodedValue, out uint cbDecodedValue)
		{
			decodedValue = SafeLocalAllocHandle.InvalidHandle;
			cbDecodedValue = 0u;
			uint num = 0u;
			SafeLocalAllocHandle invalidHandle = SafeLocalAllocHandle.InvalidHandle;
			if (!CAPISafe.CryptDecodeObject(65537u, pszStructType, pbEncoded, (uint)pbEncoded.Length, 0u, invalidHandle, new IntPtr(&num)))
			{
				return false;
			}
			invalidHandle = LocalAlloc(0u, new IntPtr(num));
			if (!CAPISafe.CryptDecodeObject(65537u, pszStructType, pbEncoded, (uint)pbEncoded.Length, 0u, invalidHandle, new IntPtr(&num)))
			{
				return false;
			}
			decodedValue = invalidHandle;
			cbDecodedValue = num;
			return true;
		}

		[SecuritySafeCritical]
		internal unsafe static bool EncodeObject(IntPtr lpszStructType, IntPtr pvStructInfo, out byte[] encodedData)
		{
			encodedData = new byte[0];
			uint num = 0u;
			SafeLocalAllocHandle invalidHandle = SafeLocalAllocHandle.InvalidHandle;
			if (!CAPISafe.CryptEncodeObject(65537u, lpszStructType, pvStructInfo, invalidHandle, new IntPtr(&num)))
			{
				return false;
			}
			invalidHandle = LocalAlloc(0u, new IntPtr(num));
			if (!CAPISafe.CryptEncodeObject(65537u, lpszStructType, pvStructInfo, invalidHandle, new IntPtr(&num)))
			{
				return false;
			}
			encodedData = new byte[num];
			Marshal.Copy(invalidHandle.DangerousGetHandle(), encodedData, 0, (int)num);
			invalidHandle.Dispose();
			return true;
		}

		[SecurityCritical]
		internal unsafe static bool EncodeObject(string lpszStructType, IntPtr pvStructInfo, out byte[] encodedData)
		{
			encodedData = new byte[0];
			uint num = 0u;
			SafeLocalAllocHandle invalidHandle = SafeLocalAllocHandle.InvalidHandle;
			if (!CAPISafe.CryptEncodeObject(65537u, lpszStructType, pvStructInfo, invalidHandle, new IntPtr(&num)))
			{
				return false;
			}
			invalidHandle = LocalAlloc(0u, new IntPtr(num));
			if (!CAPISafe.CryptEncodeObject(65537u, lpszStructType, pvStructInfo, invalidHandle, new IntPtr(&num)))
			{
				return false;
			}
			encodedData = new byte[num];
			Marshal.Copy(invalidHandle.DangerousGetHandle(), encodedData, 0, (int)num);
			invalidHandle.Dispose();
			return true;
		}

		internal static bool ErrorMayBeCausedByUnloadedProfile(int errorCode)
		{
			if (errorCode != -2147024894)
			{
				return errorCode == 2;
			}
			return true;
		}

		[SecurityCritical]
		internal static SafeLocalAllocHandle LocalAlloc(uint uFlags, IntPtr sizetdwBytes)
		{
			SafeLocalAllocHandle safeLocalAllocHandle = CAPISafe.LocalAlloc(uFlags, sizetdwBytes);
			if (safeLocalAllocHandle == null || safeLocalAllocHandle.IsInvalid)
			{
				throw new OutOfMemoryException();
			}
			return safeLocalAllocHandle;
		}

		[SecurityCritical]
		internal static bool CryptAcquireContext([In][Out] ref SafeCryptProvHandle hCryptProv, [In][MarshalAs(UnmanagedType.LPStr)] string pwszContainer, [In][MarshalAs(UnmanagedType.LPStr)] string pwszProvider, [In] uint dwProvType, [In] uint dwFlags)
		{
			CspParameters cspParameters = new CspParameters();
			cspParameters.ProviderName = pwszProvider;
			cspParameters.KeyContainerName = pwszContainer;
			cspParameters.ProviderType = (int)dwProvType;
			cspParameters.KeyNumber = -1;
			cspParameters.Flags = (((dwFlags & 0x20) == 32) ? CspProviderFlags.UseMachineKeyStore : CspProviderFlags.NoFlags);
			KeyContainerPermission keyContainerPermission = new KeyContainerPermission(KeyContainerPermissionFlags.NoFlags);
			KeyContainerPermissionAccessEntry accessEntry = new KeyContainerPermissionAccessEntry(cspParameters, KeyContainerPermissionFlags.Open);
			keyContainerPermission.AccessEntries.Add(accessEntry);
			keyContainerPermission.Demand();
			bool flag = CAPIUnsafe.CryptAcquireContext(ref hCryptProv, pwszContainer, pwszProvider, dwProvType, dwFlags);
			if (!flag && Marshal.GetLastWin32Error() == -2146893802)
			{
				flag = CAPIUnsafe.CryptAcquireContext(ref hCryptProv, pwszContainer, pwszProvider, dwProvType, dwFlags | 8u);
			}
			return flag;
		}

		[SecurityCritical]
		internal static bool CryptAcquireContext(ref SafeCryptProvHandle hCryptProv, IntPtr pwszContainer, IntPtr pwszProvider, uint dwProvType, uint dwFlags)
		{
			string pwszContainer2 = null;
			if (pwszContainer != IntPtr.Zero)
			{
				pwszContainer2 = Marshal.PtrToStringUni(pwszContainer);
			}
			string pwszProvider2 = null;
			if (pwszProvider != IntPtr.Zero)
			{
				pwszProvider2 = Marshal.PtrToStringUni(pwszProvider);
			}
			return CryptAcquireContext(ref hCryptProv, pwszContainer2, pwszProvider2, dwProvType, dwFlags);
		}

		[SecurityCritical]
		internal static CRYPT_OID_INFO CryptFindOIDInfo([In] uint dwKeyType, [In] IntPtr pvKey, [In] uint dwGroupId)
		{
			if (pvKey == IntPtr.Zero)
			{
				throw new ArgumentNullException("pvKey");
			}
			CRYPT_OID_INFO result = new CRYPT_OID_INFO(Marshal.SizeOf(typeof(CRYPT_OID_INFO)));
			IntPtr intPtr = CAPISafe.CryptFindOIDInfo(dwKeyType, pvKey, dwGroupId);
			if (intPtr != IntPtr.Zero)
			{
				return (CRYPT_OID_INFO)Marshal.PtrToStructure(intPtr, typeof(CRYPT_OID_INFO));
			}
			return result;
		}

		[SecurityCritical]
		internal static CRYPT_OID_INFO CryptFindOIDInfo([In] uint dwKeyType, [In] SafeLocalAllocHandle pvKey, [In] uint dwGroupId)
		{
			if (pvKey == null)
			{
				throw new ArgumentNullException("pvKey");
			}
			if (pvKey.IsInvalid)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_InvalidHandle"), "pvKey");
			}
			CRYPT_OID_INFO result = new CRYPT_OID_INFO(Marshal.SizeOf(typeof(CRYPT_OID_INFO)));
			IntPtr intPtr = CAPISafe.CryptFindOIDInfo(dwKeyType, pvKey, dwGroupId);
			if (intPtr != IntPtr.Zero)
			{
				return (CRYPT_OID_INFO)Marshal.PtrToStructure(intPtr, typeof(CRYPT_OID_INFO));
			}
			return result;
		}

		[SecurityCritical]
		internal static bool CryptMsgControl([In] SafeCryptMsgHandle hCryptMsg, [In] uint dwFlags, [In] uint dwCtrlType, [In] IntPtr pvCtrlPara)
		{
			return CAPIUnsafe.CryptMsgControl(hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara);
		}

		[SecurityCritical]
		internal static bool CryptMsgCountersign([In] SafeCryptMsgHandle hCryptMsg, [In] uint dwIndex, [In] uint cCountersigners, [In] IntPtr rgCountersigners)
		{
			return CAPIUnsafe.CryptMsgCountersign(hCryptMsg, dwIndex, cCountersigners, rgCountersigners);
		}

		[SecurityCritical]
		internal static SafeCryptMsgHandle CryptMsgOpenToEncode([In] uint dwMsgEncodingType, [In] uint dwFlags, [In] uint dwMsgType, [In] IntPtr pvMsgEncodeInfo, [In] IntPtr pszInnerContentObjID, [In] IntPtr pStreamInfo)
		{
			return CAPIUnsafe.CryptMsgOpenToEncode(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo);
		}

		[SecurityCritical]
		internal static SafeCryptMsgHandle CryptMsgOpenToEncode([In] uint dwMsgEncodingType, [In] uint dwFlags, [In] uint dwMsgType, [In] IntPtr pvMsgEncodeInfo, [In] string pszInnerContentObjID, [In] IntPtr pStreamInfo)
		{
			return CAPIUnsafe.CryptMsgOpenToEncode(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo);
		}

		[SecurityCritical]
		internal static SafeCertContextHandle CertDuplicateCertificateContext([In] IntPtr pCertContext)
		{
			if (pCertContext == IntPtr.Zero)
			{
				return SafeCertContextHandle.InvalidHandle;
			}
			return CAPISafe.CertDuplicateCertificateContext(pCertContext);
		}

		[SecurityCritical]
		internal static IntPtr CertEnumCertificatesInStore([In] SafeCertStoreHandle hCertStore, [In] IntPtr pPrevCertContext)
		{
			if (hCertStore == null)
			{
				throw new ArgumentNullException("hCertStore");
			}
			if (hCertStore.IsInvalid)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_InvalidHandle"), "hCertStore");
			}
			if (pPrevCertContext == IntPtr.Zero)
			{
				StorePermission storePermission = new StorePermission(StorePermissionFlags.EnumerateCertificates);
				storePermission.Demand();
			}
			IntPtr intPtr = CAPIUnsafe.CertEnumCertificatesInStore(hCertStore, pPrevCertContext);
			if (intPtr == IntPtr.Zero)
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error != -2146885628)
				{
					CAPISafe.CertFreeCertificateContext(intPtr);
					throw new CryptographicException(lastWin32Error);
				}
			}
			return intPtr;
		}

		[SecurityCritical]
		internal static bool CertAddCertificateContextToStore([In] SafeCertStoreHandle hCertStore, [In] SafeCertContextHandle pCertContext, [In] uint dwAddDisposition, [In][Out] SafeCertContextHandle ppStoreContext)
		{
			if (hCertStore == null)
			{
				throw new ArgumentNullException("hCertStore");
			}
			if (hCertStore.IsInvalid)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_InvalidHandle"), "hCertStore");
			}
			if (pCertContext == null)
			{
				throw new ArgumentNullException("pCertContext");
			}
			if (pCertContext.IsInvalid)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_InvalidHandle"), "pCertContext");
			}
			StorePermission storePermission = new StorePermission(StorePermissionFlags.AddToStore);
			storePermission.Demand();
			return CAPIUnsafe.CertAddCertificateContextToStore(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
		}

		[SecurityCritical]
		internal static bool CertAddCertificateLinkToStore([In] SafeCertStoreHandle hCertStore, [In] SafeCertContextHandle pCertContext, [In] uint dwAddDisposition, [In][Out] SafeCertContextHandle ppStoreContext)
		{
			if (hCertStore == null)
			{
				throw new ArgumentNullException("hCertStore");
			}
			if (hCertStore.IsInvalid)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_InvalidHandle"), "hCertStore");
			}
			if (pCertContext == null)
			{
				throw new ArgumentNullException("pCertContext");
			}
			if (pCertContext.IsInvalid)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_InvalidHandle"), "pCertContext");
			}
			StorePermission storePermission = new StorePermission(StorePermissionFlags.AddToStore);
			storePermission.Demand();
			return CAPIUnsafe.CertAddCertificateLinkToStore(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
		}

		[SecurityCritical]
		internal static SafeCertStoreHandle CertOpenStore([In] IntPtr lpszStoreProvider, [In] uint dwMsgAndCertEncodingType, [In] IntPtr hCryptProv, [In] uint dwFlags, [In] string pvPara)
		{
			if (lpszStoreProvider != new IntPtr(2L) && lpszStoreProvider != new IntPtr(10L))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Argument_InvalidValue"), "lpszStoreProvider");
			}
			if (((dwFlags & 0x20000) == 131072 || (dwFlags & 0x80000) == 524288 || (dwFlags & 0x90000) == 589824) && pvPara != null && pvPara.StartsWith("\\\\", StringComparison.Ordinal))
			{
				new PermissionSet(PermissionState.Unrestricted).Demand();
			}
			if ((dwFlags & 0x10) == 16)
			{
				StorePermission storePermission = new StorePermission(StorePermissionFlags.DeleteStore);
				storePermission.Demand();
			}
			else
			{
				StorePermission storePermission2 = new StorePermission(StorePermissionFlags.OpenStore);
				storePermission2.Demand();
			}
			if ((dwFlags & 0x2000) == 8192)
			{
				StorePermission storePermission3 = new StorePermission(StorePermissionFlags.CreateStore);
				storePermission3.Demand();
			}
			if ((dwFlags & 0x4000) == 0)
			{
				StorePermission storePermission4 = new StorePermission(StorePermissionFlags.CreateStore);
				storePermission4.Demand();
			}
			return CAPIUnsafe.CertOpenStore(lpszStoreProvider, dwMsgAndCertEncodingType, hCryptProv, dwFlags | 4u, pvPara);
		}

		[SecurityCritical]
		internal static bool CryptProtectData([In] IntPtr pDataIn, [In] string szDataDescr, [In] IntPtr pOptionalEntropy, [In] IntPtr pvReserved, [In] IntPtr pPromptStruct, [In] uint dwFlags, [In][Out] IntPtr pDataBlob)
		{
			DataProtectionPermission dataProtectionPermission = new DataProtectionPermission(DataProtectionPermissionFlags.ProtectData);
			dataProtectionPermission.Demand();
			return CAPIUnsafe.CryptProtectData(pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataBlob);
		}

		[SecurityCritical]
		internal static bool CryptUnprotectData([In] IntPtr pDataIn, [In] IntPtr ppszDataDescr, [In] IntPtr pOptionalEntropy, [In] IntPtr pvReserved, [In] IntPtr pPromptStruct, [In] uint dwFlags, [In][Out] IntPtr pDataBlob)
		{
			DataProtectionPermission dataProtectionPermission = new DataProtectionPermission(DataProtectionPermissionFlags.UnprotectData);
			dataProtectionPermission.Demand();
			return CAPIUnsafe.CryptUnprotectData(pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataBlob);
		}

		[SecurityCritical]
		internal static int SystemFunction040([In][Out] byte[] pDataIn, [In] uint cbDataIn, [In] uint dwFlags)
		{
			DataProtectionPermission dataProtectionPermission = new DataProtectionPermission(DataProtectionPermissionFlags.ProtectMemory);
			dataProtectionPermission.Demand();
			return CAPIUnsafe.SystemFunction040(pDataIn, cbDataIn, dwFlags);
		}

		[SecurityCritical]
		internal static int SystemFunction041([In][Out] byte[] pDataIn, [In] uint cbDataIn, [In] uint dwFlags)
		{
			DataProtectionPermission dataProtectionPermission = new DataProtectionPermission(DataProtectionPermissionFlags.UnprotectMemory);
			dataProtectionPermission.Demand();
			return CAPIUnsafe.SystemFunction041(pDataIn, cbDataIn, dwFlags);
		}

		[SecurityCritical]
		internal static SafeCertContextHandle CryptUIDlgSelectCertificateW([In][Out][MarshalAs(UnmanagedType.LPStruct)] CRYPTUI_SELECTCERTIFICATE_STRUCTW csc)
		{
			if (!Environment.UserInteractive)
			{
				throw new InvalidOperationException(SecurityResources.GetResourceString("Environment_NotInteractive"));
			}
			UIPermission uIPermission = new UIPermission(UIPermissionWindow.SafeTopLevelWindows);
			uIPermission.Demand();
			return CAPIUnsafe.CryptUIDlgSelectCertificateW(csc);
		}

		[SecurityCritical]
		internal static bool CryptUIDlgViewCertificateW([In][MarshalAs(UnmanagedType.LPStruct)] CRYPTUI_VIEWCERTIFICATE_STRUCTW ViewInfo, [In][Out] IntPtr pfPropertiesChanged)
		{
			if (!Environment.UserInteractive)
			{
				throw new InvalidOperationException(SecurityResources.GetResourceString("Environment_NotInteractive"));
			}
			UIPermission uIPermission = new UIPermission(UIPermissionWindow.SafeTopLevelWindows);
			uIPermission.Demand();
			return CAPIUnsafe.CryptUIDlgViewCertificateW(ViewInfo, pfPropertiesChanged);
		}

		[SecurityCritical]
		internal static SafeCertContextHandle CertFindCertificateInStore([In] SafeCertStoreHandle hCertStore, [In] uint dwCertEncodingType, [In] uint dwFindFlags, [In] uint dwFindType, [In] IntPtr pvFindPara, [In] SafeCertContextHandle pPrevCertContext)
		{
			if (hCertStore == null)
			{
				throw new ArgumentNullException("hCertStore");
			}
			if (hCertStore.IsInvalid)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_InvalidHandle"), "hCertStore");
			}
			return CAPIUnsafe.CertFindCertificateInStore(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext);
		}
	}
	[SecurityCritical]
	internal sealed class SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private SafeLibraryHandle()
			: base(ownsHandle: true)
		{
		}

		[DllImport("kernel32.dll", SetLastError = true)]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool FreeLibrary([In] IntPtr hModule);

		[SecurityCritical]
		protected override bool ReleaseHandle()
		{
			return FreeLibrary(handle);
		}
	}
	[SecurityCritical]
	internal sealed class SafeLocalAllocHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		internal static SafeLocalAllocHandle InvalidHandle
		{
			get
			{
				SafeLocalAllocHandle safeLocalAllocHandle = new SafeLocalAllocHandle(IntPtr.Zero);
				GC.SuppressFinalize(safeLocalAllocHandle);
				return safeLocalAllocHandle;
			}
		}

		private SafeLocalAllocHandle()
			: base(ownsHandle: true)
		{
		}

		internal SafeLocalAllocHandle(IntPtr handle)
			: base(ownsHandle: true)
		{
			SetHandle(handle);
		}

		[DllImport("kernel32.dll", SetLastError = true)]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		private static extern IntPtr LocalFree(IntPtr handle);

		[SecurityCritical]
		protected override bool ReleaseHandle()
		{
			return LocalFree(handle) == IntPtr.Zero;
		}
	}
	[SecurityCritical]
	internal sealed class SafeCryptProvHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private SafeHandle _parentHandle;

		internal static SafeCryptProvHandle InvalidHandle
		{
			get
			{
				SafeCryptProvHandle safeCryptProvHandle = new SafeCryptProvHandle(IntPtr.Zero);
				GC.SuppressFinalize(safeCryptProvHandle);
				return safeCryptProvHandle;
			}
		}

		private SafeCryptProvHandle()
			: base(ownsHandle: true)
		{
		}

		internal SafeCryptProvHandle(IntPtr handle)
			: base(ownsHandle: true)
		{
			SetHandle(handle);
		}

		internal SafeCryptProvHandle(IntPtr handle, bool ownsHandle)
			: base(ownsHandle)
		{
			SetHandle(handle);
		}

		internal SafeCryptProvHandle(IntPtr handle, SafeHandle parentHandle)
			: base(ownsHandle: true)
		{
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
			}
			finally
			{
				bool success = false;
				parentHandle.DangerousAddRef(ref success);
				if (success)
				{
					_parentHandle = parentHandle;
					SetHandle(handle);
				}
			}
		}

		[DllImport("ncrypt.dll", SetLastError = true)]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		private static extern bool NCryptIsKeyHandle(IntPtr hCryptProv);

		[DllImport("advapi32.dll", SetLastError = true)]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		private static extern bool CryptReleaseContext(IntPtr hCryptProv, uint dwFlags);

		[DllImport("ncrypt.dll", SetLastError = true)]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		private static extern int NCryptFreeObject(IntPtr hObject);

		[SecurityCritical]
		protected override bool ReleaseHandle()
		{
			IntPtr intPtr = handle;
			if (_parentHandle != null)
			{
				_parentHandle.DangerousRelease();
				_parentHandle = null;
				SetHandle(IntPtr.Zero);
				return true;
			}
			if (NCryptIsKeyHandle(intPtr))
			{
				int num = NCryptFreeObject(intPtr);
				return num == 0;
			}
			return CryptReleaseContext(intPtr, 0u);
		}
	}
	[SecurityCritical]
	internal sealed class SafeCertContextHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		internal static SafeCertContextHandle InvalidHandle
		{
			get
			{
				SafeCertContextHandle safeCertContextHandle = new SafeCertContextHandle(IntPtr.Zero);
				GC.SuppressFinalize(safeCertContextHandle);
				return safeCertContextHandle;
			}
		}

		private SafeCertContextHandle()
			: base(ownsHandle: true)
		{
		}

		internal SafeCertContextHandle(IntPtr handle)
			: base(ownsHandle: true)
		{
			SetHandle(handle);
		}

		[DllImport("crypt32.dll", SetLastError = true)]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		private static extern bool CertFreeCertificateContext(IntPtr pCertContext);

		[SecurityCritical]
		protected override bool ReleaseHandle()
		{
			return CertFreeCertificateContext(handle);
		}
	}
	[SecurityCritical]
	internal sealed class SafeCertStoreHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		internal static SafeCertStoreHandle InvalidHandle
		{
			get
			{
				SafeCertStoreHandle safeCertStoreHandle = new SafeCertStoreHandle(IntPtr.Zero);
				GC.SuppressFinalize(safeCertStoreHandle);
				return safeCertStoreHandle;
			}
		}

		private SafeCertStoreHandle()
			: base(ownsHandle: true)
		{
		}

		internal SafeCertStoreHandle(IntPtr handle)
			: base(ownsHandle: true)
		{
			SetHandle(handle);
		}

		[DllImport("crypt32.dll", SetLastError = true)]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		private static extern bool CertCloseStore(IntPtr hCertStore, uint dwFlags);

		[SecurityCritical]
		protected override bool ReleaseHandle()
		{
			return CertCloseStore(handle, 0u);
		}
	}
	[SecurityCritical]
	internal sealed class SafeCryptMsgHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		internal static SafeCryptMsgHandle InvalidHandle
		{
			get
			{
				SafeCryptMsgHandle safeCryptMsgHandle = new SafeCryptMsgHandle(IntPtr.Zero);
				GC.SuppressFinalize(safeCryptMsgHandle);
				return safeCryptMsgHandle;
			}
		}

		private SafeCryptMsgHandle()
			: base(ownsHandle: true)
		{
		}

		internal SafeCryptMsgHandle(IntPtr handle)
			: base(ownsHandle: true)
		{
			SetHandle(handle);
		}

		[DllImport("crypt32.dll", SetLastError = true)]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		private static extern bool CryptMsgClose(IntPtr handle);

		[SecurityCritical]
		protected override bool ReleaseHandle()
		{
			return CryptMsgClose(handle);
		}
	}
	[SecurityCritical]
	internal sealed class SafeCertChainHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		internal static SafeCertChainHandle InvalidHandle
		{
			get
			{
				SafeCertChainHandle safeCertChainHandle = new SafeCertChainHandle(IntPtr.Zero);
				GC.SuppressFinalize(safeCertChainHandle);
				return safeCertChainHandle;
			}
		}

		private SafeCertChainHandle()
			: base(ownsHandle: true)
		{
		}

		internal SafeCertChainHandle(IntPtr handle)
			: base(ownsHandle: true)
		{
			SetHandle(handle);
		}

		[DllImport("crypt32.dll", SetLastError = true)]
		[SuppressUnmanagedCodeSecurity]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		private static extern void CertFreeCertificateChain(IntPtr handle);

		[SecurityCritical]
		protected override bool ReleaseHandle()
		{
			CertFreeCertificateChain(handle);
			return true;
		}
	}
	/// <summary>Contains a type and a collection of values associated with that type.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CryptographicAttributeObject
	{
		private Oid m_oid;

		private AsnEncodedDataCollection m_values;

		/// <summary>Gets the <see cref="T:System.Security.Cryptography.Oid" /> object that specifies the object identifier for the attribute.</summary>
		/// <returns>The object identifier for the attribute.</returns>
		public Oid Oid => new Oid(m_oid);

		/// <summary>Gets the <see cref="T:System.Security.Cryptography.AsnEncodedDataCollection" /> collection that contains the set of values that are associated with the attribute.</summary>
		/// <returns>The set of values that is associated with the attribute.</returns>
		public AsnEncodedDataCollection Values => m_values;

		private CryptographicAttributeObject()
		{
		}

		[SecurityCritical]
		internal CryptographicAttributeObject(IntPtr pAttribute)
			: this((CAPI.CRYPT_ATTRIBUTE)Marshal.PtrToStructure(pAttribute, typeof(CAPI.CRYPT_ATTRIBUTE)))
		{
		}

		[SecurityCritical]
		internal CryptographicAttributeObject(CAPI.CRYPT_ATTRIBUTE cryptAttribute)
			: this(new Oid(cryptAttribute.pszObjId), PkcsUtils.GetAsnEncodedDataCollection(cryptAttribute))
		{
		}

		[SecurityCritical]
		internal CryptographicAttributeObject(CAPI.CRYPT_ATTRIBUTE_TYPE_VALUE cryptAttribute)
			: this(new Oid(cryptAttribute.pszObjId), PkcsUtils.GetAsnEncodedDataCollection(cryptAttribute))
		{
		}

		internal CryptographicAttributeObject(AsnEncodedData asnEncodedData)
			: this(asnEncodedData.Oid, new AsnEncodedDataCollection(asnEncodedData))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> class using an attribute represented by the specified <see cref="T:System.Security.Cryptography.Oid" /> object.</summary>
		/// <param name="oid">The attribute to store in this <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object.</param>
		public CryptographicAttributeObject(Oid oid)
			: this(oid, new AsnEncodedDataCollection())
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> class using an attribute represented by the specified <see cref="T:System.Security.Cryptography.Oid" /> object and the set of values associated with that attribute represented by the specified <see cref="T:System.Security.Cryptography.AsnEncodedDataCollection" /> collection.</summary>
		/// <param name="oid">The attribute to store in this <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object.</param>
		/// <param name="values">The set of values associated with the attribute represented by the <paramref name="oid" /> parameter.</param>
		/// <exception cref="T:System.InvalidOperationException">The collection contains duplicate items.</exception>
		public CryptographicAttributeObject(Oid oid, AsnEncodedDataCollection values)
		{
			m_oid = new Oid(oid);
			if (values == null)
			{
				m_values = new AsnEncodedDataCollection();
				return;
			}
			AsnEncodedDataEnumerator enumerator = values.GetEnumerator();
			while (enumerator.MoveNext())
			{
				AsnEncodedData current = enumerator.Current;
				if (string.Compare(current.Oid.Value, oid.Value, StringComparison.Ordinal) != 0)
				{
					throw new InvalidOperationException(SecurityResources.GetResourceString("InvalidOperation_DuplicateItemNotAllowed"));
				}
			}
			m_values = values;
		}
	}
	/// <summary>Contains a set of <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> objects.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CryptographicAttributeObjectCollection : ICollection, IEnumerable
	{
		private ArrayList m_list;

		/// <summary>Gets the <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object at the specified index in the collection.</summary>
		/// <param name="index">An <see cref="T:System.Int32" /> value that represents the zero-based index of the <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object to retrieve.</param>
		/// <returns>The <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object at the specified index.</returns>
		public CryptographicAttributeObject this[int index] => (CryptographicAttributeObject)m_list[index];

		/// <summary>Gets the number of items in the collection.</summary>
		/// <returns>The number of items in the collection.</returns>
		public int Count => m_list.Count;

		/// <summary>Gets a value that indicates whether access to the collection is synchronized, or thread safe.</summary>
		/// <returns>
		///   <see langword="true" /> if access to the collection is thread safe; otherwise <see langword="false" />.</returns>
		public bool IsSynchronized => false;

		/// <summary>Gets an <see cref="T:System.Object" /> object used to synchronize access to the collection.</summary>
		/// <returns>An <see cref="T:System.Object" /> object used to synchronize access to the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection.</returns>
		public object SyncRoot => this;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> class.</summary>
		public CryptographicAttributeObjectCollection()
		{
			m_list = new ArrayList();
		}

		[SecurityCritical]
		private CryptographicAttributeObjectCollection(IntPtr pCryptAttributes)
			: this((CAPI.CRYPT_ATTRIBUTES)Marshal.PtrToStructure(pCryptAttributes, typeof(CAPI.CRYPT_ATTRIBUTES)))
		{
		}

		[SecurityCritical]
		internal CryptographicAttributeObjectCollection(SafeLocalAllocHandle pCryptAttributes)
			: this(pCryptAttributes.DangerousGetHandle())
		{
		}

		[SecurityCritical]
		internal CryptographicAttributeObjectCollection(CAPI.CRYPT_ATTRIBUTES cryptAttributes)
		{
			m_list = new ArrayList((int)cryptAttributes.cAttr);
			for (uint num = 0u; num < cryptAttributes.cAttr; num++)
			{
				IntPtr pAttribute = new IntPtr((long)cryptAttributes.rgAttr + num * Marshal.SizeOf(typeof(CAPI.CRYPT_ATTRIBUTE)));
				m_list.Add(new CryptographicAttributeObject(pAttribute));
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> class, adding a specified <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> to the collection.</summary>
		/// <param name="attribute">A <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object that is added to the collection.</param>
		public CryptographicAttributeObjectCollection(CryptographicAttributeObject attribute)
		{
			m_list = new ArrayList();
			m_list.Add(attribute);
		}

		private CryptographicAttributeObjectCollection(CryptographicAttributeObjectCollection other)
		{
			m_list = new ArrayList(other.m_list.Count);
			foreach (CryptographicAttributeObject item in other.m_list)
			{
				CryptographicAttributeObject cryptographicAttributeObject2 = new CryptographicAttributeObject(item.Oid);
				AsnEncodedDataEnumerator enumerator2 = item.Values.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					AsnEncodedData current = enumerator2.Current;
					cryptographicAttributeObject2.Values.Add(new AsnEncodedData(current.Oid, current.RawData));
				}
				m_list.Add(cryptographicAttributeObject2);
			}
		}

		/// <summary>Adds the specified <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object to the collection.</summary>
		/// <param name="asnEncodedData">The <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object to add to the collection.</param>
		/// <returns>
		///   <see langword="true" /> if the method returns the zero-based index of the added item; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="asnEncodedData" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public int Add(AsnEncodedData asnEncodedData)
		{
			if (asnEncodedData == null)
			{
				throw new ArgumentNullException("asnEncodedData");
			}
			return Add(new CryptographicAttributeObject(asnEncodedData));
		}

		/// <summary>Adds the specified <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object to the collection.</summary>
		/// <param name="attribute">The <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object to add to the collection.</param>
		/// <returns>
		///   <see langword="true" /> if the method returns the zero-based index of the added item; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="asnEncodedData" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		/// <exception cref="T:System.InvalidOperationException">The specified item already exists in the collection.</exception>
		public int Add(CryptographicAttributeObject attribute)
		{
			if (attribute == null)
			{
				throw new ArgumentNullException("attribute");
			}
			string text = null;
			if (attribute.Oid != null)
			{
				text = attribute.Oid.Value;
			}
			for (int i = 0; i < m_list.Count; i++)
			{
				CryptographicAttributeObject cryptographicAttributeObject = (CryptographicAttributeObject)m_list[i];
				if (cryptographicAttributeObject.Values == attribute.Values)
				{
					throw new InvalidOperationException(SecurityResources.GetResourceString("InvalidOperation_DuplicateItemNotAllowed"));
				}
				string text2 = null;
				if (cryptographicAttributeObject.Oid != null)
				{
					text2 = cryptographicAttributeObject.Oid.Value;
				}
				if (text == null && text2 == null)
				{
					AsnEncodedDataEnumerator enumerator = attribute.Values.GetEnumerator();
					while (enumerator.MoveNext())
					{
						AsnEncodedData current = enumerator.Current;
						cryptographicAttributeObject.Values.Add(current);
					}
					return i;
				}
				if (text != null && text2 != null && string.Compare(text, text2, StringComparison.OrdinalIgnoreCase) == 0)
				{
					if (string.Compare(text, "1.2.840.113549.1.9.5", StringComparison.OrdinalIgnoreCase) == 0)
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Pkcs9_MultipleSigningTimeNotAllowed"));
					}
					AsnEncodedDataEnumerator enumerator2 = attribute.Values.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						AsnEncodedData current2 = enumerator2.Current;
						cryptographicAttributeObject.Values.Add(current2);
					}
					return i;
				}
			}
			return m_list.Add(attribute);
		}

		/// <summary>Removes the specified <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object from the collection.</summary>
		/// <param name="attribute">The <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object to remove from the collection.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="attribute" /> is <see langword="null" />.</exception>
		public void Remove(CryptographicAttributeObject attribute)
		{
			if (attribute == null)
			{
				throw new ArgumentNullException("attribute");
			}
			m_list.Remove(attribute);
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectEnumerator" /> object for the collection.</summary>
		/// <returns>
		///   <see langword="true" /> if the method returns a <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectEnumerator" /> object that can be used to enumerate the collection; otherwise, <see langword="false" />.</returns>
		public CryptographicAttributeObjectEnumerator GetEnumerator()
		{
			return new CryptographicAttributeObjectEnumerator(this);
		}

		/// <summary>Returns an enumerator that iterates through the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return new CryptographicAttributeObjectEnumerator(this);
		}

		/// <summary>Copies the elements of this <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection to an <see cref="T:System.Array" /> array, starting at a particular index.</summary>
		/// <param name="array">The one-dimensional <see cref="T:System.Array" /> array that is the destination of the elements copied from this <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" />. The <see cref="T:System.Array" /> array must have zero-based indexing.</param>
		/// <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
		void ICollection.CopyTo(Array array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (array.Rank != 1)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Arg_RankMultiDimNotSupported"));
			}
			if (index < 0 || index >= array.Length)
			{
				throw new ArgumentOutOfRangeException("index", SecurityResources.GetResourceString("ArgumentOutOfRange_Index"));
			}
			if (index + Count > array.Length)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Argument_InvalidOffLen"));
			}
			for (int i = 0; i < Count; i++)
			{
				array.SetValue(this[i], index);
				index++;
			}
		}

		/// <summary>Copies the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection to an array of <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> objects.</summary>
		/// <param name="array">An array of <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> objects that the collection is copied to.</param>
		/// <param name="index">The zero-based index in <paramref name="array" /> to which the collection is to be copied.</param>
		/// <exception cref="T:System.ArgumentException">One of the arguments provided to a method was not valid.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <see langword="null" /> was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of an argument was outside the allowable range of values as defined by the called method.</exception>
		public void CopyTo(CryptographicAttributeObject[] array, int index)
		{
			((ICollection)this).CopyTo((Array)array, index);
		}

		internal CryptographicAttributeObjectCollection DeepCopy()
		{
			return new CryptographicAttributeObjectCollection(this);
		}
	}
	/// <summary>Provides enumeration functionality for the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CryptographicAttributeObjectEnumerator : IEnumerator
	{
		private CryptographicAttributeObjectCollection m_attributes;

		private int m_current;

		/// <summary>Gets the current <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object from the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object that represents the current cryptographic attribute in the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection.</returns>
		public CryptographicAttributeObject Current => m_attributes[m_current];

		/// <summary>Gets the current <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object from the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object that represents the current cryptographic attribute in the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection.</returns>
		object IEnumerator.Current => m_attributes[m_current];

		private CryptographicAttributeObjectEnumerator()
		{
		}

		internal CryptographicAttributeObjectEnumerator(CryptographicAttributeObjectCollection attributes)
		{
			m_attributes = attributes;
			m_current = -1;
		}

		/// <summary>Advances the enumeration to the next <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object in the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection.</summary>
		/// <returns>
		///   <see langword="true" /> if the enumeration successfully moved to the next <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object; <see langword="false" /> if the enumerator is at the end of the enumeration.</returns>
		public bool MoveNext()
		{
			if (m_current == m_attributes.Count - 1)
			{
				return false;
			}
			m_current++;
			return true;
		}

		/// <summary>Resets the enumeration to the first <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> object in the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection.</summary>
		public void Reset()
		{
			m_current = -1;
		}
	}
	/// <summary>Specifies the scope of the data protection to be applied by the <see cref="M:System.Security.Cryptography.ProtectedData.Protect(System.Byte[],System.Byte[],System.Security.Cryptography.DataProtectionScope)" /> method.</summary>
	public enum DataProtectionScope
	{
		/// <summary>The protected data is associated with the current user. Only threads running under the current user context can unprotect the data.</summary>
		CurrentUser,
		/// <summary>The protected data is associated with the machine context. Any process running on the computer can unprotect data. This enumeration value is usually used in server-specific applications that run on a server where untrusted users are not allowed access.</summary>
		LocalMachine
	}
	/// <summary>Specifies the scope of memory protection to be applied by the <see cref="M:System.Security.Cryptography.ProtectedMemory.Protect(System.Byte[],System.Security.Cryptography.MemoryProtectionScope)" /> method.</summary>
	public enum MemoryProtectionScope
	{
		/// <summary>Only code running in the same process as the code that called the <see cref="M:System.Security.Cryptography.ProtectedMemory.Protect(System.Byte[],System.Security.Cryptography.MemoryProtectionScope)" /> method can unprotect memory.</summary>
		SameProcess,
		/// <summary>All code in any process can unprotect memory that was protected using the <see cref="M:System.Security.Cryptography.ProtectedMemory.Protect(System.Byte[],System.Security.Cryptography.MemoryProtectionScope)" /> method.</summary>
		CrossProcess,
		/// <summary>Only code running in the same user context as the code that called the <see cref="M:System.Security.Cryptography.ProtectedMemory.Protect(System.Byte[],System.Security.Cryptography.MemoryProtectionScope)" /> method can unprotect memory.</summary>
		SameLogon
	}
	/// <summary>Provides methods for encrypting and decrypting data. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public static class ProtectedData
	{
		/// <summary>Encrypts the data in a specified byte array and returns a byte array that contains the encrypted data.</summary>
		/// <param name="userData">A byte array that contains data to encrypt.</param>
		/// <param name="optionalEntropy">An optional additional byte array used to increase the complexity of the encryption, or <see langword="null" /> for no additional complexity.</param>
		/// <param name="scope">One of the enumeration values that specifies the scope of encryption.</param>
		/// <returns>A byte array representing the encrypted data.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="userData" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The encryption failed.</exception>
		/// <exception cref="T:System.NotSupportedException">The operating system does not support this method.</exception>
		/// <exception cref="T:System.OutOfMemoryException">The system ran out of memory while encrypting the data.</exception>
		[SecuritySafeCritical]
		public unsafe static byte[] Protect(byte[] userData, byte[] optionalEntropy, DataProtectionScope scope)
		{
			if (userData == null)
			{
				throw new ArgumentNullException("userData");
			}
			if (Environment.OSVersion.Platform == PlatformID.Win32Windows)
			{
				throw new NotSupportedException(SecurityResources.GetResourceString("NotSupported_PlatformRequiresNT"));
			}
			GCHandle gCHandle = default(GCHandle);
			GCHandle gCHandle2 = default(GCHandle);
			CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB = default(CAPI.CRYPTOAPI_BLOB);
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				gCHandle = GCHandle.Alloc(userData, GCHandleType.Pinned);
				CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB2 = default(CAPI.CRYPTOAPI_BLOB);
				cRYPTOAPI_BLOB2.cbData = (uint)userData.Length;
				cRYPTOAPI_BLOB2.pbData = gCHandle.AddrOfPinnedObject();
				CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB3 = default(CAPI.CRYPTOAPI_BLOB);
				if (optionalEntropy != null)
				{
					gCHandle2 = GCHandle.Alloc(optionalEntropy, GCHandleType.Pinned);
					cRYPTOAPI_BLOB3.cbData = (uint)optionalEntropy.Length;
					cRYPTOAPI_BLOB3.pbData = gCHandle2.AddrOfPinnedObject();
				}
				uint num = 1u;
				if (scope == DataProtectionScope.LocalMachine)
				{
					num |= 4u;
				}
				if (!CAPI.CryptProtectData(new IntPtr(&cRYPTOAPI_BLOB2), string.Empty, new IntPtr(&cRYPTOAPI_BLOB3), IntPtr.Zero, IntPtr.Zero, num, new IntPtr(&cRYPTOAPI_BLOB)))
				{
					int lastWin32Error = Marshal.GetLastWin32Error();
					if (CAPI.ErrorMayBeCausedByUnloadedProfile(lastWin32Error))
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_DpApi_ProfileMayNotBeLoaded"));
					}
					throw new CryptographicException(lastWin32Error);
				}
				if (cRYPTOAPI_BLOB.pbData == IntPtr.Zero)
				{
					throw new OutOfMemoryException();
				}
				byte[] array = new byte[cRYPTOAPI_BLOB.cbData];
				Marshal.Copy(cRYPTOAPI_BLOB.pbData, array, 0, array.Length);
				return array;
			}
			catch (EntryPointNotFoundException)
			{
				throw new NotSupportedException(SecurityResources.GetResourceString("NotSupported_PlatformRequiresNT"));
			}
			finally
			{
				if (gCHandle.IsAllocated)
				{
					gCHandle.Free();
				}
				if (gCHandle2.IsAllocated)
				{
					gCHandle2.Free();
				}
				if (cRYPTOAPI_BLOB.pbData != IntPtr.Zero)
				{
					CAPI.CAPISafe.ZeroMemory(cRYPTOAPI_BLOB.pbData, cRYPTOAPI_BLOB.cbData);
					CAPI.CAPISafe.LocalFree(cRYPTOAPI_BLOB.pbData);
				}
			}
		}

		/// <summary>Decrypts the data in a specified byte array and returns a byte array that contains the decrypted data.</summary>
		/// <param name="encryptedData">A byte array containing data encrypted using the <see cref="M:System.Security.Cryptography.ProtectedData.Protect(System.Byte[],System.Byte[],System.Security.Cryptography.DataProtectionScope)" /> method.</param>
		/// <param name="optionalEntropy">An optional additional byte array that was used to encrypt the data, or <see langword="null" /> if the additional byte array was not used.</param>
		/// <param name="scope">One of the enumeration values that specifies the scope of data protection that was used to encrypt the data.</param>
		/// <returns>A byte array representing the decrypted data.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="encryptedData" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The decryption failed.</exception>
		/// <exception cref="T:System.NotSupportedException">The operating system does not support this method.</exception>
		/// <exception cref="T:System.OutOfMemoryException">Out of memory.</exception>
		[SecuritySafeCritical]
		public unsafe static byte[] Unprotect(byte[] encryptedData, byte[] optionalEntropy, DataProtectionScope scope)
		{
			if (encryptedData == null)
			{
				throw new ArgumentNullException("encryptedData");
			}
			if (Environment.OSVersion.Platform == PlatformID.Win32Windows)
			{
				throw new NotSupportedException(SecurityResources.GetResourceString("NotSupported_PlatformRequiresNT"));
			}
			GCHandle gCHandle = default(GCHandle);
			GCHandle gCHandle2 = default(GCHandle);
			CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB = default(CAPI.CRYPTOAPI_BLOB);
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
				gCHandle = GCHandle.Alloc(encryptedData, GCHandleType.Pinned);
				CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB2 = default(CAPI.CRYPTOAPI_BLOB);
				cRYPTOAPI_BLOB2.cbData = (uint)encryptedData.Length;
				cRYPTOAPI_BLOB2.pbData = gCHandle.AddrOfPinnedObject();
				CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB3 = default(CAPI.CRYPTOAPI_BLOB);
				if (optionalEntropy != null)
				{
					gCHandle2 = GCHandle.Alloc(optionalEntropy, GCHandleType.Pinned);
					cRYPTOAPI_BLOB3.cbData = (uint)optionalEntropy.Length;
					cRYPTOAPI_BLOB3.pbData = gCHandle2.AddrOfPinnedObject();
				}
				uint num = 1u;
				if (scope == DataProtectionScope.LocalMachine)
				{
					num |= 4u;
				}
				if (!CAPI.CryptUnprotectData(new IntPtr(&cRYPTOAPI_BLOB2), IntPtr.Zero, new IntPtr(&cRYPTOAPI_BLOB3), IntPtr.Zero, IntPtr.Zero, num, new IntPtr(&cRYPTOAPI_BLOB)))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
				if (cRYPTOAPI_BLOB.pbData == IntPtr.Zero)
				{
					throw new OutOfMemoryException();
				}
				byte[] array = new byte[cRYPTOAPI_BLOB.cbData];
				Marshal.Copy(cRYPTOAPI_BLOB.pbData, array, 0, array.Length);
				return array;
			}
			catch (EntryPointNotFoundException)
			{
				throw new NotSupportedException(SecurityResources.GetResourceString("NotSupported_PlatformRequiresNT"));
			}
			finally
			{
				if (gCHandle.IsAllocated)
				{
					gCHandle.Free();
				}
				if (gCHandle2.IsAllocated)
				{
					gCHandle2.Free();
				}
				if (cRYPTOAPI_BLOB.pbData != IntPtr.Zero)
				{
					CAPI.CAPISafe.ZeroMemory(cRYPTOAPI_BLOB.pbData, cRYPTOAPI_BLOB.cbData);
					CAPI.CAPISafe.LocalFree(cRYPTOAPI_BLOB.pbData);
				}
			}
		}
	}
	/// <summary>Provides methods for protecting and unprotecting memory. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public static class ProtectedMemory
	{
		/// <summary>Protects the specified data.</summary>
		/// <param name="userData">The byte array containing data in memory to protect. The array must be a multiple of 16 bytes.</param>
		/// <param name="scope">One of the enumeration values that specifies the scope of memory protection.</param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///   <paramref name="userData" /> must be 16 bytes in length or in multiples of 16 bytes.</exception>
		/// <exception cref="T:System.NotSupportedException">The operating system does not support this method. This method can be used only with the Windows 2000 or later operating systems.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="userData" /> is <see langword="null" />.</exception>
		[SecuritySafeCritical]
		public static void Protect(byte[] userData, MemoryProtectionScope scope)
		{
			if (userData == null)
			{
				throw new ArgumentNullException("userData");
			}
			if (Environment.OSVersion.Platform == PlatformID.Win32Windows)
			{
				throw new NotSupportedException(SecurityResources.GetResourceString("NotSupported_PlatformRequiresNT"));
			}
			VerifyScope(scope);
			if (userData.Length == 0 || (long)userData.Length % 16L != 0L)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_DpApi_InvalidMemoryLength"));
			}
			try
			{
				int num = CAPI.SystemFunction040(userData, (uint)userData.Length, (uint)scope);
				if (num < 0)
				{
					throw new CryptographicException(CAPI.CAPISafe.LsaNtStatusToWinError(num));
				}
			}
			catch (EntryPointNotFoundException)
			{
				throw new NotSupportedException(SecurityResources.GetResourceString("NotSupported_PlatformRequiresNT"));
			}
		}

		/// <summary>Unprotects data in memory that was protected using the <see cref="M:System.Security.Cryptography.ProtectedMemory.Protect(System.Byte[],System.Security.Cryptography.MemoryProtectionScope)" /> method.</summary>
		/// <param name="encryptedData">The byte array in memory to unencrypt.</param>
		/// <param name="scope">One of the enumeration values that specifies the scope of memory protection.</param>
		/// <exception cref="T:System.NotSupportedException">The operating system does not support this method. This method can be used only with the Windows 2000 or later operating systems.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="encryptedData" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///   <paramref name="encryptedData" /> is empty.  
		/// -or-  
		/// This call was not implemented.  
		/// -or-  
		/// NTSTATUS contains an error.</exception>
		[SecuritySafeCritical]
		public static void Unprotect(byte[] encryptedData, MemoryProtectionScope scope)
		{
			if (encryptedData == null)
			{
				throw new ArgumentNullException("encryptedData");
			}
			if (Environment.OSVersion.Platform == PlatformID.Win32Windows)
			{
				throw new NotSupportedException(SecurityResources.GetResourceString("NotSupported_PlatformRequiresNT"));
			}
			VerifyScope(scope);
			if (encryptedData.Length == 0 || (long)encryptedData.Length % 16L != 0L)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_DpApi_InvalidMemoryLength"));
			}
			try
			{
				int num = CAPI.SystemFunction041(encryptedData, (uint)encryptedData.Length, (uint)scope);
				if (num < 0)
				{
					throw new CryptographicException(CAPI.CAPISafe.LsaNtStatusToWinError(num));
				}
			}
			catch (EntryPointNotFoundException)
			{
				throw new NotSupportedException(SecurityResources.GetResourceString("NotSupported_PlatformRequiresNT"));
			}
		}

		private static void VerifyScope(MemoryProtectionScope scope)
		{
			if (scope != 0 && scope != MemoryProtectionScope.CrossProcess && scope != MemoryProtectionScope.SameLogon)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Arg_EnumIllegalVal"), new object[1] { (int)scope }));
			}
		}
	}
	/// <summary>Provides the base class for data protectors.</summary>
	public abstract class DataProtector
	{
		private string m_applicationName;

		private string m_primaryPurpose;

		private IEnumerable<string> m_specificPurposes;

		private volatile byte[] m_hashedPurpose;

		/// <summary>Gets the name of the application.</summary>
		/// <returns>The name of the application.</returns>
		protected string ApplicationName => m_applicationName;

		/// <summary>Specifies whether the hash is prepended to the text array before encryption.</summary>
		/// <returns>Always <see langword="true" />.</returns>
		protected virtual bool PrependHashedPurposeToPlaintext => true;

		/// <summary>Gets the primary purpose for the protected data.</summary>
		/// <returns>The primary purpose for the protected data.</returns>
		protected string PrimaryPurpose => m_primaryPurpose;

		/// <summary>Gets the specific purposes for the protected data.</summary>
		/// <returns>A collection of the specific purposes for the protected data.</returns>
		protected IEnumerable<string> SpecificPurposes => m_specificPurposes;

		/// <summary>Creates a new instance of the <see cref="T:System.Security.Cryptography.DataProtector" /> class by using the provided application name, primary purpose, and specific purposes.</summary>
		/// <param name="applicationName">The name of the application.</param>
		/// <param name="primaryPurpose">The primary purpose for the protected data.</param>
		/// <param name="specificPurposes">The specific purposes for the protected data.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="applicationName" /> is an empty string or <see langword="null" />.  
		/// -or-  
		/// <paramref name="primaryPurpose" /> is an empty string or <see langword="null" />.  
		/// -or-  
		/// <paramref name="specificPurposes" /> contains an empty string or <see langword="null" />.</exception>
		protected DataProtector(string applicationName, string primaryPurpose, string[] specificPurposes)
		{
			if (string.IsNullOrWhiteSpace(applicationName))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_DataProtector_InvalidAppNameOrPurpose"), "applicationName");
			}
			if (string.IsNullOrWhiteSpace(primaryPurpose))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_DataProtector_InvalidAppNameOrPurpose"), "primaryPurpose");
			}
			if (specificPurposes != null)
			{
				foreach (string value in specificPurposes)
				{
					if (string.IsNullOrWhiteSpace(value))
					{
						throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_DataProtector_InvalidAppNameOrPurpose"), "specificPurposes");
					}
				}
			}
			m_applicationName = applicationName;
			m_primaryPurpose = primaryPurpose;
			List<string> list = new List<string>();
			if (specificPurposes != null)
			{
				list.AddRange(specificPurposes);
			}
			m_specificPurposes = list;
		}

		/// <summary>Creates a hash of the property values specified by the constructor.</summary>
		/// <returns>An array of bytes that contain the hash of the <see cref="P:System.Security.Cryptography.DataProtector.ApplicationName" />, <see cref="P:System.Security.Cryptography.DataProtector.PrimaryPurpose" />, and <see cref="P:System.Security.Cryptography.DataProtector.SpecificPurposes" /> properties.</returns>
		protected virtual byte[] GetHashedPurpose()
		{
			if (m_hashedPurpose == null)
			{
				using HashAlgorithm hashAlgorithm = HashAlgorithm.Create("System.Security.Cryptography.Sha256Cng");
				using (BinaryWriter binaryWriter = new BinaryWriter(new CryptoStream(new MemoryStream(), hashAlgorithm, CryptoStreamMode.Write), new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true)))
				{
					binaryWriter.Write(ApplicationName);
					binaryWriter.Write(PrimaryPurpose);
					foreach (string specificPurpose in SpecificPurposes)
					{
						binaryWriter.Write(specificPurpose);
					}
				}
				m_hashedPurpose = hashAlgorithm.Hash;
			}
			return m_hashedPurpose;
		}

		/// <summary>Determines if re-encryption is required for the specified encrypted data.</summary>
		/// <param name="encryptedData">The encrypted data to be evaluated.</param>
		/// <returns>
		///   <see langword="true" /> if the data must be re-encrypted; otherwise, <see langword="false" />.</returns>
		public abstract bool IsReprotectRequired(byte[] encryptedData);

		/// <summary>Creates an instance of a data protector implementation by using the specified class name of the data protector, the application name, the primary purpose, and the specific purposes.</summary>
		/// <param name="providerClass">The class name for the data protector.</param>
		/// <param name="applicationName">The name of the application.</param>
		/// <param name="primaryPurpose">The primary purpose for the protected data.</param>
		/// <param name="specificPurposes">The specific purposes for the protected data.</param>
		/// <returns>A data protector implementation object.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="providerClass" /> is <see langword="null" />.</exception>
		public static DataProtector Create(string providerClass, string applicationName, string primaryPurpose, params string[] specificPurposes)
		{
			if (providerClass == null)
			{
				throw new ArgumentNullException("providerClass");
			}
			return (DataProtector)CryptoConfig.CreateFromName(providerClass, applicationName, primaryPurpose, specificPurposes);
		}

		/// <summary>Protects the specified user data.</summary>
		/// <param name="userData">The data to be protected.</param>
		/// <returns>A byte array that contains the encrypted data.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="userData" /> is <see langword="null" />.</exception>
		public byte[] Protect(byte[] userData)
		{
			if (userData == null)
			{
				throw new ArgumentNullException("userData");
			}
			if (PrependHashedPurposeToPlaintext)
			{
				byte[] hashedPurpose = GetHashedPurpose();
				byte[] array = new byte[userData.Length + hashedPurpose.Length];
				Array.Copy(hashedPurpose, 0, array, 0, hashedPurpose.Length);
				Array.Copy(userData, 0, array, hashedPurpose.Length, userData.Length);
				userData = array;
			}
			return ProviderProtect(userData);
		}

		/// <summary>Specifies the delegate method in the derived class that the <see cref="M:System.Security.Cryptography.DataProtector.Protect(System.Byte[])" /> method in the base class calls back into.</summary>
		/// <param name="userData">The data to be encrypted.</param>
		/// <returns>A byte array that contains the encrypted data.</returns>
		protected abstract byte[] ProviderProtect(byte[] userData);

		/// <summary>Specifies the delegate method in the derived class that the <see cref="M:System.Security.Cryptography.DataProtector.Unprotect(System.Byte[])" /> method in the base class calls back into.</summary>
		/// <param name="encryptedData">The data to be unencrypted.</param>
		/// <returns>The unencrypted data.</returns>
		protected abstract byte[] ProviderUnprotect(byte[] encryptedData);

		/// <summary>Unprotects the specified protected data.</summary>
		/// <param name="encryptedData">The encrypted data to be unprotected.</param>
		/// <returns>A byte array that contains the plain-text data.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="encryptedData" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///   <paramref name="encryptedData" /> contained an invalid purpose.</exception>
		public byte[] Unprotect(byte[] encryptedData)
		{
			if (encryptedData == null)
			{
				throw new ArgumentNullException("encryptedData");
			}
			if (PrependHashedPurposeToPlaintext)
			{
				byte[] array = ProviderUnprotect(encryptedData);
				byte[] hashedPurpose = GetHashedPurpose();
				if (!SignedXml.CryptographicEquals(hashedPurpose, array, hashedPurpose.Length))
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_DataProtector_InvalidPurpose"));
				}
				byte[] array2 = new byte[array.Length - hashedPurpose.Length];
				Array.Copy(array, hashedPurpose.Length, array2, 0, array2.Length);
				return array2;
			}
			return ProviderUnprotect(encryptedData);
		}
	}
	/// <summary>Provides simple data protection methods.</summary>
	public sealed class DpapiDataProtector : DataProtector
	{
		/// <summary>Gets or sets the scope of the data protection.</summary>
		/// <returns>One of the enumeration values that specifies the scope of the data protection (either the current user or the local machine). The default is <see cref="F:System.Security.Cryptography.DataProtectionScope.CurrentUser" />.</returns>
		public DataProtectionScope Scope { get; set; }

		protected override bool PrependHashedPurposeToPlaintext => false;

		[SecuritySafeCritical]
		[DataProtectionPermission(SecurityAction.Assert, ProtectData = true)]
		protected override byte[] ProviderProtect(byte[] userData)
		{
			return ProtectedData.Protect(userData, GetHashedPurpose(), Scope);
		}

		[SecuritySafeCritical]
		[DataProtectionPermission(SecurityAction.Assert, UnprotectData = true)]
		protected override byte[] ProviderUnprotect(byte[] encryptedData)
		{
			return ProtectedData.Unprotect(encryptedData, GetHashedPurpose(), Scope);
		}

		/// <summary>Determines if the data must be re-encrypted.</summary>
		/// <param name="encryptedData">The encrypted data to be checked.</param>
		/// <returns>
		///   <see langword="true" /> if the data must be re-encrypted; otherwise, <see langword="false" />.</returns>
		public override bool IsReprotectRequired(byte[] encryptedData)
		{
			return true;
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Security.Cryptography.DpapiDataProtector" /> class by using the specified application name, primary purpose, and specific purposes.</summary>
		/// <param name="appName">The name of the application.</param>
		/// <param name="primaryPurpose">The primary purpose for the data protector.</param>
		/// <param name="specificPurpose">The specific purpose(s) for the data protector.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="appName" /> is an empty string or <see langword="null" />.  
		/// -or-  
		/// <paramref name="primaryPurpose" /> is an empty string or <see langword="null" />.  
		/// -or-  
		/// <paramref name="specificPurposes" /> contains an empty string or <see langword="null" />.</exception>
		[SecuritySafeCritical]
		[DataProtectionPermission(SecurityAction.Demand, Unrestricted = true)]
		public DpapiDataProtector(string appName, string primaryPurpose, params string[] specificPurpose)
			: base(appName, primaryPurpose, specificPurpose)
		{
		}
	}
}
namespace System.Security.Cryptography.Xml
{
	internal enum DocPosition
	{
		BeforeRootElement,
		InRootElement,
		AfterRootElement
	}
	internal interface ICanonicalizableNode
	{
		bool IsInNodeSet { get; set; }

		void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc);

		void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc);
	}
	internal class CanonicalizationDispatcher
	{
		private CanonicalizationDispatcher()
		{
		}

		public static void Write(XmlNode node, StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (node is ICanonicalizableNode)
			{
				((ICanonicalizableNode)node).Write(strBuilder, docPos, anc);
			}
			else
			{
				WriteGenericNode(node, strBuilder, docPos, anc);
			}
		}

		public static void WriteGenericNode(XmlNode node, StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (node == null)
			{
				throw new ArgumentNullException("node");
			}
			XmlNodeList childNodes = node.ChildNodes;
			foreach (XmlNode item in childNodes)
			{
				Write(item, strBuilder, docPos, anc);
			}
		}

		public static void WriteHash(XmlNode node, HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (node is ICanonicalizableNode)
			{
				((ICanonicalizableNode)node).WriteHash(hash, docPos, anc);
			}
			else
			{
				WriteHashGenericNode(node, hash, docPos, anc);
			}
		}

		public static void WriteHashGenericNode(XmlNode node, HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (node == null)
			{
				throw new ArgumentNullException("node");
			}
			XmlNodeList childNodes = node.ChildNodes;
			foreach (XmlNode item in childNodes)
			{
				WriteHash(item, hash, docPos, anc);
			}
		}
	}
	internal class CanonicalXmlDocument : XmlDocument, ICanonicalizableNode
	{
		private bool m_defaultNodeSetInclusionState;

		private bool m_includeComments;

		private bool m_isInNodeSet;

		public bool IsInNodeSet
		{
			get
			{
				return m_isInNodeSet;
			}
			set
			{
				m_isInNodeSet = value;
			}
		}

		public CanonicalXmlDocument(bool defaultNodeSetInclusionState, bool includeComments)
		{
			base.PreserveWhitespace = true;
			m_includeComments = includeComments;
			m_isInNodeSet = (m_defaultNodeSetInclusionState = defaultNodeSetInclusionState);
		}

		public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			docPos = DocPosition.BeforeRootElement;
			foreach (XmlNode childNode in ChildNodes)
			{
				if (childNode.NodeType == XmlNodeType.Element)
				{
					CanonicalizationDispatcher.Write(childNode, strBuilder, DocPosition.InRootElement, anc);
					docPos = DocPosition.AfterRootElement;
				}
				else
				{
					CanonicalizationDispatcher.Write(childNode, strBuilder, docPos, anc);
				}
			}
		}

		public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			docPos = DocPosition.BeforeRootElement;
			foreach (XmlNode childNode in ChildNodes)
			{
				if (childNode.NodeType == XmlNodeType.Element)
				{
					CanonicalizationDispatcher.WriteHash(childNode, hash, DocPosition.InRootElement, anc);
					docPos = DocPosition.AfterRootElement;
				}
				else
				{
					CanonicalizationDispatcher.WriteHash(childNode, hash, docPos, anc);
				}
			}
		}

		public override XmlElement CreateElement(string prefix, string localName, string namespaceURI)
		{
			return new CanonicalXmlElement(prefix, localName, namespaceURI, this, m_defaultNodeSetInclusionState);
		}

		public override XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI)
		{
			return new CanonicalXmlAttribute(prefix, localName, namespaceURI, this, m_defaultNodeSetInclusionState);
		}

		protected override XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI)
		{
			return new CanonicalXmlAttribute(prefix, localName, namespaceURI, this, m_defaultNodeSetInclusionState);
		}

		public override XmlText CreateTextNode(string text)
		{
			return new CanonicalXmlText(text, this, m_defaultNodeSetInclusionState);
		}

		public override XmlWhitespace CreateWhitespace(string prefix)
		{
			return new CanonicalXmlWhitespace(prefix, this, m_defaultNodeSetInclusionState);
		}

		public override XmlSignificantWhitespace CreateSignificantWhitespace(string text)
		{
			return new CanonicalXmlSignificantWhitespace(text, this, m_defaultNodeSetInclusionState);
		}

		public override XmlProcessingInstruction CreateProcessingInstruction(string target, string data)
		{
			return new CanonicalXmlProcessingInstruction(target, data, this, m_defaultNodeSetInclusionState);
		}

		public override XmlComment CreateComment(string data)
		{
			return new CanonicalXmlComment(data, this, m_defaultNodeSetInclusionState, m_includeComments);
		}

		public override XmlEntityReference CreateEntityReference(string name)
		{
			return new CanonicalXmlEntityReference(name, this, m_defaultNodeSetInclusionState);
		}

		public override XmlCDataSection CreateCDataSection(string data)
		{
			return new CanonicalXmlCDataSection(data, this, m_defaultNodeSetInclusionState);
		}
	}
	internal class CanonicalXmlElement : XmlElement, ICanonicalizableNode
	{
		private bool m_isInNodeSet;

		public bool IsInNodeSet
		{
			get
			{
				return m_isInNodeSet;
			}
			set
			{
				m_isInNodeSet = value;
			}
		}

		public CanonicalXmlElement(string prefix, string localName, string namespaceURI, XmlDocument doc, bool defaultNodeSetInclusionState)
			: base(prefix, localName, namespaceURI, doc)
		{
			m_isInNodeSet = defaultNodeSetInclusionState;
		}

		public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			Hashtable nsLocallyDeclared = new Hashtable();
			SortedList sortedList = new SortedList(new NamespaceSortOrder());
			SortedList sortedList2 = new SortedList(new AttributeSortOrder());
			XmlAttributeCollection xmlAttributeCollection = Attributes;
			if (xmlAttributeCollection != null)
			{
				foreach (XmlAttribute item in xmlAttributeCollection)
				{
					if (((CanonicalXmlAttribute)item).IsInNodeSet || Utils.IsNamespaceNode(item) || Utils.IsXmlNamespaceNode(item))
					{
						if (Utils.IsNamespaceNode(item))
						{
							anc.TrackNamespaceNode(item, sortedList, nsLocallyDeclared);
						}
						else if (Utils.IsXmlNamespaceNode(item))
						{
							anc.TrackXmlNamespaceNode(item, sortedList, sortedList2, nsLocallyDeclared);
						}
						else if (IsInNodeSet)
						{
							sortedList2.Add(item, null);
						}
					}
				}
			}
			if (!Utils.IsCommittedNamespace(this, Prefix, NamespaceURI))
			{
				string text = ((Prefix.Length > 0) ? ("xmlns:" + Prefix) : "xmlns");
				XmlAttribute xmlAttribute2 = OwnerDocument.CreateAttribute(text);
				xmlAttribute2.Value = NamespaceURI;
				anc.TrackNamespaceNode(xmlAttribute2, sortedList, nsLocallyDeclared);
			}
			if (IsInNodeSet)
			{
				anc.GetNamespacesToRender(this, sortedList2, sortedList, nsLocallyDeclared);
				strBuilder.Append("<" + Name);
				foreach (object key in sortedList.GetKeyList())
				{
					(key as CanonicalXmlAttribute).Write(strBuilder, docPos, anc);
				}
				foreach (object key2 in sortedList2.GetKeyList())
				{
					(key2 as CanonicalXmlAttribute).Write(strBuilder, docPos, anc);
				}
				strBuilder.Append(">");
			}
			anc.EnterElementContext();
			anc.LoadUnrenderedNamespaces(nsLocallyDeclared);
			anc.LoadRenderedNamespaces(sortedList);
			XmlNodeList childNodes = ChildNodes;
			foreach (XmlNode item2 in childNodes)
			{
				CanonicalizationDispatcher.Write(item2, strBuilder, docPos, anc);
			}
			anc.ExitElementContext();
			if (IsInNodeSet)
			{
				strBuilder.Append("</" + Name + ">");
			}
		}

		public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			Hashtable nsLocallyDeclared = new Hashtable();
			SortedList sortedList = new SortedList(new NamespaceSortOrder());
			SortedList sortedList2 = new SortedList(new AttributeSortOrder());
			UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
			XmlAttributeCollection xmlAttributeCollection = Attributes;
			if (xmlAttributeCollection != null)
			{
				foreach (XmlAttribute item in xmlAttributeCollection)
				{
					if (((CanonicalXmlAttribute)item).IsInNodeSet || Utils.IsNamespaceNode(item) || Utils.IsXmlNamespaceNode(item))
					{
						if (Utils.IsNamespaceNode(item))
						{
							anc.TrackNamespaceNode(item, sortedList, nsLocallyDeclared);
						}
						else if (Utils.IsXmlNamespaceNode(item))
						{
							anc.TrackXmlNamespaceNode(item, sortedList, sortedList2, nsLocallyDeclared);
						}
						else if (IsInNodeSet)
						{
							sortedList2.Add(item, null);
						}
					}
				}
			}
			if (!Utils.IsCommittedNamespace(this, Prefix, NamespaceURI))
			{
				string text = ((Prefix.Length > 0) ? ("xmlns:" + Prefix) : "xmlns");
				XmlAttribute xmlAttribute2 = OwnerDocument.CreateAttribute(text);
				xmlAttribute2.Value = NamespaceURI;
				anc.TrackNamespaceNode(xmlAttribute2, sortedList, nsLocallyDeclared);
			}
			if (IsInNodeSet)
			{
				anc.GetNamespacesToRender(this, sortedList2, sortedList, nsLocallyDeclared);
				byte[] bytes = uTF8Encoding.GetBytes("<" + Name);
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				foreach (object key in sortedList.GetKeyList())
				{
					(key as CanonicalXmlAttribute).WriteHash(hash, docPos, anc);
				}
				foreach (object key2 in sortedList2.GetKeyList())
				{
					(key2 as CanonicalXmlAttribute).WriteHash(hash, docPos, anc);
				}
				bytes = uTF8Encoding.GetBytes(">");
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
			}
			anc.EnterElementContext();
			anc.LoadUnrenderedNamespaces(nsLocallyDeclared);
			anc.LoadRenderedNamespaces(sortedList);
			XmlNodeList childNodes = ChildNodes;
			foreach (XmlNode item2 in childNodes)
			{
				CanonicalizationDispatcher.WriteHash(item2, hash, docPos, anc);
			}
			anc.ExitElementContext();
			if (IsInNodeSet)
			{
				byte[] bytes = uTF8Encoding.GetBytes("</" + Name + ">");
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
			}
		}
	}
	internal class CanonicalXmlAttribute : XmlAttribute, ICanonicalizableNode
	{
		private bool m_isInNodeSet;

		public bool IsInNodeSet
		{
			get
			{
				return m_isInNodeSet;
			}
			set
			{
				m_isInNodeSet = value;
			}
		}

		public CanonicalXmlAttribute(string prefix, string localName, string namespaceURI, XmlDocument doc, bool defaultNodeSetInclusionState)
			: base(prefix, localName, namespaceURI, doc)
		{
			IsInNodeSet = defaultNodeSetInclusionState;
		}

		public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			strBuilder.Append(" " + Name + "=\"");
			strBuilder.Append(Utils.EscapeAttributeValue(Value));
			strBuilder.Append("\"");
		}

		public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
			byte[] bytes = uTF8Encoding.GetBytes(" " + Name + "=\"");
			hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
			bytes = uTF8Encoding.GetBytes(Utils.EscapeAttributeValue(Value));
			hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
			bytes = uTF8Encoding.GetBytes("\"");
			hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
		}
	}
	internal class CanonicalXmlText : XmlText, ICanonicalizableNode
	{
		private bool m_isInNodeSet;

		public bool IsInNodeSet
		{
			get
			{
				return m_isInNodeSet;
			}
			set
			{
				m_isInNodeSet = value;
			}
		}

		public CanonicalXmlText(string strData, XmlDocument doc, bool defaultNodeSetInclusionState)
			: base(strData, doc)
		{
			m_isInNodeSet = defaultNodeSetInclusionState;
		}

		public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet)
			{
				strBuilder.Append(Utils.EscapeTextData(Value));
			}
		}

		public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet)
			{
				UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
				byte[] bytes = uTF8Encoding.GetBytes(Utils.EscapeTextData(Value));
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
			}
		}
	}
	internal class CanonicalXmlWhitespace : XmlWhitespace, ICanonicalizableNode
	{
		private bool m_isInNodeSet;

		public bool IsInNodeSet
		{
			get
			{
				return m_isInNodeSet;
			}
			set
			{
				m_isInNodeSet = value;
			}
		}

		public CanonicalXmlWhitespace(string strData, XmlDocument doc, bool defaultNodeSetInclusionState)
			: base(strData, doc)
		{
			m_isInNodeSet = defaultNodeSetInclusionState;
		}

		public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet && docPos == DocPosition.InRootElement)
			{
				strBuilder.Append(Utils.EscapeWhitespaceData(Value));
			}
		}

		public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet && docPos == DocPosition.InRootElement)
			{
				UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
				byte[] bytes = uTF8Encoding.GetBytes(Utils.EscapeWhitespaceData(Value));
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
			}
		}
	}
	internal class CanonicalXmlSignificantWhitespace : XmlSignificantWhitespace, ICanonicalizableNode
	{
		private bool m_isInNodeSet;

		public bool IsInNodeSet
		{
			get
			{
				return m_isInNodeSet;
			}
			set
			{
				m_isInNodeSet = value;
			}
		}

		public CanonicalXmlSignificantWhitespace(string strData, XmlDocument doc, bool defaultNodeSetInclusionState)
			: base(strData, doc)
		{
			m_isInNodeSet = defaultNodeSetInclusionState;
		}

		public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet && docPos == DocPosition.InRootElement)
			{
				strBuilder.Append(Utils.EscapeWhitespaceData(Value));
			}
		}

		public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet && docPos == DocPosition.InRootElement)
			{
				UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
				byte[] bytes = uTF8Encoding.GetBytes(Utils.EscapeWhitespaceData(Value));
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
			}
		}
	}
	internal class CanonicalXmlComment : XmlComment, ICanonicalizableNode
	{
		private bool m_isInNodeSet;

		private bool m_includeComments;

		public bool IsInNodeSet
		{
			get
			{
				return m_isInNodeSet;
			}
			set
			{
				m_isInNodeSet = value;
			}
		}

		public bool IncludeComments => m_includeComments;

		public CanonicalXmlComment(string comment, XmlDocument doc, bool defaultNodeSetInclusionState, bool includeComments)
			: base(comment, doc)
		{
			m_isInNodeSet = defaultNodeSetInclusionState;
			m_includeComments = includeComments;
		}

		public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet && IncludeComments)
			{
				if (docPos == DocPosition.AfterRootElement)
				{
					strBuilder.Append('\n');
				}
				strBuilder.Append("<!--");
				strBuilder.Append(Value);
				strBuilder.Append("-->");
				if (docPos == DocPosition.BeforeRootElement)
				{
					strBuilder.Append('\n');
				}
			}
		}

		public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet && IncludeComments)
			{
				UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
				byte[] bytes = uTF8Encoding.GetBytes("(char) 10");
				if (docPos == DocPosition.AfterRootElement)
				{
					hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				}
				bytes = uTF8Encoding.GetBytes("<!--");
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				bytes = uTF8Encoding.GetBytes(Value);
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				bytes = uTF8Encoding.GetBytes("-->");
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				if (docPos == DocPosition.BeforeRootElement)
				{
					bytes = uTF8Encoding.GetBytes("(char) 10");
					hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				}
			}
		}
	}
	internal class CanonicalXmlProcessingInstruction : XmlProcessingInstruction, ICanonicalizableNode
	{
		private bool m_isInNodeSet;

		public bool IsInNodeSet
		{
			get
			{
				return m_isInNodeSet;
			}
			set
			{
				m_isInNodeSet = value;
			}
		}

		public CanonicalXmlProcessingInstruction(string target, string data, XmlDocument doc, bool defaultNodeSetInclusionState)
			: base(target, data, doc)
		{
			m_isInNodeSet = defaultNodeSetInclusionState;
		}

		public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet)
			{
				if (docPos == DocPosition.AfterRootElement)
				{
					strBuilder.Append('\n');
				}
				strBuilder.Append("<?");
				strBuilder.Append(Name);
				if (Value != null && Value.Length > 0)
				{
					strBuilder.Append(" " + Value);
				}
				strBuilder.Append("?>");
				if (docPos == DocPosition.BeforeRootElement)
				{
					strBuilder.Append('\n');
				}
			}
		}

		public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet)
			{
				UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
				byte[] bytes;
				if (docPos == DocPosition.AfterRootElement)
				{
					bytes = uTF8Encoding.GetBytes("(char) 10");
					hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				}
				bytes = uTF8Encoding.GetBytes("<?");
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				bytes = uTF8Encoding.GetBytes(Name);
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				if (Value != null && Value.Length > 0)
				{
					bytes = uTF8Encoding.GetBytes(" " + Value);
					hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				}
				bytes = uTF8Encoding.GetBytes("?>");
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				if (docPos == DocPosition.BeforeRootElement)
				{
					bytes = uTF8Encoding.GetBytes("(char) 10");
					hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
				}
			}
		}
	}
	internal class CanonicalXmlEntityReference : XmlEntityReference, ICanonicalizableNode
	{
		private bool m_isInNodeSet;

		public bool IsInNodeSet
		{
			get
			{
				return m_isInNodeSet;
			}
			set
			{
				m_isInNodeSet = value;
			}
		}

		public CanonicalXmlEntityReference(string name, XmlDocument doc, bool defaultNodeSetInclusionState)
			: base(name, doc)
		{
			m_isInNodeSet = defaultNodeSetInclusionState;
		}

		public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet)
			{
				CanonicalizationDispatcher.WriteGenericNode(this, strBuilder, docPos, anc);
			}
		}

		public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet)
			{
				CanonicalizationDispatcher.WriteHashGenericNode(this, hash, docPos, anc);
			}
		}
	}
	internal class CanonicalXmlCDataSection : XmlCDataSection, ICanonicalizableNode
	{
		private bool m_isInNodeSet;

		public bool IsInNodeSet
		{
			get
			{
				return m_isInNodeSet;
			}
			set
			{
				m_isInNodeSet = value;
			}
		}

		public CanonicalXmlCDataSection(string data, XmlDocument doc, bool defaultNodeSetInclusionState)
			: base(data, doc)
		{
			m_isInNodeSet = defaultNodeSetInclusionState;
		}

		public void Write(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet)
			{
				strBuilder.Append(Utils.EscapeCData(Data));
			}
		}

		public void WriteHash(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)
		{
			if (IsInNodeSet)
			{
				UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
				byte[] bytes = uTF8Encoding.GetBytes(Utils.EscapeCData(Data));
				hash.TransformBlock(bytes, 0, bytes.Length, bytes, 0);
			}
		}
	}
	internal class CanonicalXmlNodeList : XmlNodeList, IList, ICollection, IEnumerable
	{
		private ArrayList m_nodeArray;

		public override int Count => m_nodeArray.Count;

		public bool IsFixedSize => m_nodeArray.IsFixedSize;

		public bool IsReadOnly => m_nodeArray.IsReadOnly;

		object IList.this[int index]
		{
			get
			{
				return m_nodeArray[index];
			}
			set
			{
				if (!(value is XmlNode))
				{
					throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "value");
				}
				m_nodeArray[index] = value;
			}
		}

		public object SyncRoot => m_nodeArray.SyncRoot;

		public bool IsSynchronized => m_nodeArray.IsSynchronized;

		internal CanonicalXmlNodeList()
		{
			m_nodeArray = new ArrayList();
		}

		public override XmlNode Item(int index)
		{
			return (XmlNode)m_nodeArray[index];
		}

		public override IEnumerator GetEnumerator()
		{
			return m_nodeArray.GetEnumerator();
		}

		public int Add(object value)
		{
			if (!(value is XmlNode))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "node");
			}
			return m_nodeArray.Add(value);
		}

		public void Clear()
		{
			m_nodeArray.Clear();
		}

		public bool Contains(object value)
		{
			return m_nodeArray.Contains(value);
		}

		public int IndexOf(object value)
		{
			return m_nodeArray.IndexOf(value);
		}

		public void Insert(int index, object value)
		{
			if (!(value is XmlNode))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "value");
			}
			m_nodeArray.Insert(index, value);
		}

		public void Remove(object value)
		{
			m_nodeArray.Remove(value);
		}

		public void RemoveAt(int index)
		{
			m_nodeArray.RemoveAt(index);
		}

		public void CopyTo(Array array, int index)
		{
			m_nodeArray.CopyTo(array, index);
		}
	}
	internal class AttributeSortOrder : IComparer
	{
		internal AttributeSortOrder()
		{
		}

		public int Compare(object a, object b)
		{
			XmlNode xmlNode = a as XmlNode;
			XmlNode xmlNode2 = b as XmlNode;
			if (a == null || b == null)
			{
				throw new ArgumentException();
			}
			int num = string.CompareOrdinal(xmlNode.NamespaceURI, xmlNode2.NamespaceURI);
			if (num != 0)
			{
				return num;
			}
			return string.CompareOrdinal(xmlNode.LocalName, xmlNode2.LocalName);
		}
	}
	internal class NamespaceSortOrder : IComparer
	{
		internal NamespaceSortOrder()
		{
		}

		public int Compare(object a, object b)
		{
			XmlNode xmlNode = a as XmlNode;
			XmlNode xmlNode2 = b as XmlNode;
			if (a == null || b == null)
			{
				throw new ArgumentException();
			}
			bool flag = Utils.IsDefaultNamespaceNode(xmlNode);
			bool flag2 = Utils.IsDefaultNamespaceNode(xmlNode2);
			if (flag && flag2)
			{
				return 0;
			}
			if (flag)
			{
				return -1;
			}
			if (flag2)
			{
				return 1;
			}
			return string.CompareOrdinal(xmlNode.LocalName, xmlNode2.LocalName);
		}
	}
	internal class NamespaceFrame
	{
		private Hashtable m_rendered = new Hashtable();

		private Hashtable m_unrendered = new Hashtable();

		internal NamespaceFrame()
		{
		}

		internal void AddRendered(XmlAttribute attr)
		{
			m_rendered.Add(Utils.GetNamespacePrefix(attr), attr);
		}

		internal XmlAttribute GetRendered(string nsPrefix)
		{
			return (XmlAttribute)m_rendered[nsPrefix];
		}

		internal void AddUnrendered(XmlAttribute attr)
		{
			m_unrendered.Add(Utils.GetNamespacePrefix(attr), attr);
		}

		internal XmlAttribute GetUnrendered(string nsPrefix)
		{
			return (XmlAttribute)m_unrendered[nsPrefix];
		}

		internal Hashtable GetUnrendered()
		{
			return m_unrendered;
		}
	}
	internal abstract class AncestralNamespaceContextManager
	{
		internal ArrayList m_ancestorStack = new ArrayList();

		internal NamespaceFrame GetScopeAt(int i)
		{
			return (NamespaceFrame)m_ancestorStack[i];
		}

		internal NamespaceFrame GetCurrentScope()
		{
			return GetScopeAt(m_ancestorStack.Count - 1);
		}

		protected XmlAttribute GetNearestRenderedNamespaceWithMatchingPrefix(string nsPrefix, out int depth)
		{
			XmlAttribute xmlAttribute = null;
			depth = -1;
			for (int num = m_ancestorStack.Count - 1; num >= 0; num--)
			{
				if ((xmlAttribute = GetScopeAt(num).GetRendered(nsPrefix)) != null)
				{
					depth = num;
					return xmlAttribute;
				}
			}
			return null;
		}

		protected XmlAttribute GetNearestUnrenderedNamespaceWithMatchingPrefix(string nsPrefix, out int depth)
		{
			XmlAttribute xmlAttribute = null;
			depth = -1;
			for (int num = m_ancestorStack.Count - 1; num >= 0; num--)
			{
				if ((xmlAttribute = GetScopeAt(num).GetUnrendered(nsPrefix)) != null)
				{
					depth = num;
					return xmlAttribute;
				}
			}
			return null;
		}

		internal void EnterElementContext()
		{
			m_ancestorStack.Add(new NamespaceFrame());
		}

		internal void ExitElementContext()
		{
			m_ancestorStack.RemoveAt(m_ancestorStack.Count - 1);
		}

		internal abstract void TrackNamespaceNode(XmlAttribute attr, SortedList nsListToRender, Hashtable nsLocallyDeclared);

		internal abstract void TrackXmlNamespaceNode(XmlAttribute attr, SortedList nsListToRender, SortedList attrListToRender, Hashtable nsLocallyDeclared);

		internal abstract void GetNamespacesToRender(XmlElement element, SortedList attrListToRender, SortedList nsListToRender, Hashtable nsLocallyDeclared);

		internal void LoadUnrenderedNamespaces(Hashtable nsLocallyDeclared)
		{
			object[] array = new object[nsLocallyDeclared.Count];
			nsLocallyDeclared.Values.CopyTo(array, 0);
			object[] array2 = array;
			foreach (object obj in array2)
			{
				AddUnrendered((XmlAttribute)obj);
			}
		}

		internal void LoadRenderedNamespaces(SortedList nsRenderedList)
		{
			foreach (object key in nsRenderedList.GetKeyList())
			{
				AddRendered((XmlAttribute)key);
			}
		}

		internal void AddRendered(XmlAttribute attr)
		{
			GetCurrentScope().AddRendered(attr);
		}

		internal void AddUnrendered(XmlAttribute attr)
		{
			GetCurrentScope().AddUnrendered(attr);
		}
	}
	internal class CanonicalXml
	{
		private CanonicalXmlDocument m_c14nDoc;

		private C14NAncestralNamespaceContextManager m_ancMgr;

		internal CanonicalXml(Stream inputStream, bool includeComments, XmlResolver resolver, string strBaseUri)
		{
			if (inputStream == null)
			{
				throw new ArgumentNullException("inputStream");
			}
			m_c14nDoc = new CanonicalXmlDocument(defaultNodeSetInclusionState: true, includeComments);
			m_c14nDoc.XmlResolver = resolver;
			m_c14nDoc.Load(Utils.PreProcessStreamInput(inputStream, resolver, strBaseUri));
			m_ancMgr = new C14NAncestralNamespaceContextManager();
		}

		internal CanonicalXml(XmlDocument document, XmlResolver resolver)
			: this(document, resolver, includeComments: false)
		{
		}

		internal CanonicalXml(XmlDocument document, XmlResolver resolver, bool includeComments)
		{
			if (document == null)
			{
				throw new ArgumentNullException("document");
			}
			m_c14nDoc = new CanonicalXmlDocument(defaultNodeSetInclusionState: true, includeComments);
			m_c14nDoc.XmlResolver = resolver;
			m_c14nDoc.Load(new XmlNodeReader(document));
			m_ancMgr = new C14NAncestralNamespaceContextManager();
		}

		internal CanonicalXml(XmlNodeList nodeList, XmlResolver resolver, bool includeComments)
		{
			if (nodeList == null)
			{
				throw new ArgumentNullException("nodeList");
			}
			XmlDocument ownerDocument = Utils.GetOwnerDocument(nodeList);
			if (ownerDocument == null)
			{
				throw new ArgumentException("nodeList");
			}
			m_c14nDoc = new CanonicalXmlDocument(defaultNodeSetInclusionState: false, includeComments);
			m_c14nDoc.XmlResolver = resolver;
			m_c14nDoc.Load(new XmlNodeReader(ownerDocument));
			m_ancMgr = new C14NAncestralNamespaceContextManager();
			MarkInclusionStateForNodes(nodeList, ownerDocument, m_c14nDoc);
		}

		private static void MarkNodeAsIncluded(XmlNode node)
		{
			if (node is ICanonicalizableNode)
			{
				((ICanonicalizableNode)node).IsInNodeSet = true;
			}
		}

		private static void MarkInclusionStateForNodes(XmlNodeList nodeList, XmlDocument inputRoot, XmlDocument root)
		{
			CanonicalXmlNodeList canonicalXmlNodeList = new CanonicalXmlNodeList();
			CanonicalXmlNodeList canonicalXmlNodeList2 = new CanonicalXmlNodeList();
			canonicalXmlNodeList.Add(inputRoot);
			canonicalXmlNodeList2.Add(root);
			int num = 0;
			do
			{
				XmlNode xmlNode = canonicalXmlNodeList[num];
				XmlNode xmlNode2 = canonicalXmlNodeList2[num];
				XmlNodeList childNodes = xmlNode.ChildNodes;
				XmlNodeList childNodes2 = xmlNode2.ChildNodes;
				for (int i = 0; i < childNodes.Count; i++)
				{
					canonicalXmlNodeList.Add(childNodes[i]);
					canonicalXmlNodeList2.Add(childNodes2[i]);
					if (Utils.NodeInList(childNodes[i], nodeList))
					{
						MarkNodeAsIncluded(childNodes2[i]);
					}
					XmlAttributeCollection attributes = childNodes[i].Attributes;
					if (attributes == null)
					{
						continue;
					}
					for (int j = 0; j < attributes.Count; j++)
					{
						if (Utils.NodeInList(attributes[j], nodeList))
						{
							MarkNodeAsIncluded(childNodes2[i].Attributes.Item(j));
						}
					}
				}
				num++;
			}
			while (num < canonicalXmlNodeList.Count);
		}

		internal byte[] GetBytes()
		{
			StringBuilder stringBuilder = new StringBuilder();
			m_c14nDoc.Write(stringBuilder, DocPosition.BeforeRootElement, m_ancMgr);
			UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
			return uTF8Encoding.GetBytes(stringBuilder.ToString());
		}

		internal byte[] GetDigestedBytes(HashAlgorithm hash)
		{
			m_c14nDoc.WriteHash(hash, DocPosition.BeforeRootElement, m_ancMgr);
			hash.TransformFinalBlock(new byte[0], 0, 0);
			byte[] result = (byte[])hash.Hash.Clone();
			hash.Initialize();
			return result;
		}
	}
	internal class C14NAncestralNamespaceContextManager : AncestralNamespaceContextManager
	{
		internal C14NAncestralNamespaceContextManager()
		{
		}

		private void GetNamespaceToRender(string nsPrefix, SortedList attrListToRender, SortedList nsListToRender, Hashtable nsLocallyDeclared)
		{
			foreach (object key in nsListToRender.GetKeyList())
			{
				if (Utils.HasNamespacePrefix((XmlAttribute)key, nsPrefix))
				{
					return;
				}
			}
			foreach (object key2 in attrListToRender.GetKeyList())
			{
				if (((XmlAttribute)key2).LocalName.Equals(nsPrefix))
				{
					return;
				}
			}
			XmlAttribute xmlAttribute = (XmlAttribute)nsLocallyDeclared[nsPrefix];
			int depth;
			XmlAttribute nearestRenderedNamespaceWithMatchingPrefix = GetNearestRenderedNamespaceWithMatchingPrefix(nsPrefix, out depth);
			if (xmlAttribute != null)
			{
				if (Utils.IsNonRedundantNamespaceDecl(xmlAttribute, nearestRenderedNamespaceWithMatchingPrefix))
				{
					nsLocallyDeclared.Remove(nsPrefix);
					if (Utils.IsXmlNamespaceNode(xmlAttribute))
					{
						attrListToRender.Add(xmlAttribute, null);
					}
					else
					{
						nsListToRender.Add(xmlAttribute, null);
					}
				}
				return;
			}
			int depth2;
			XmlAttribute nearestUnrenderedNamespaceWithMatchingPrefix = GetNearestUnrenderedNamespaceWithMatchingPrefix(nsPrefix, out depth2);
			if (nearestUnrenderedNamespaceWithMatchingPrefix != null && depth2 > depth && Utils.IsNonRedundantNamespaceDecl(nearestUnrenderedNamespaceWithMatchingPrefix, nearestRenderedNamespaceWithMatchingPrefix))
			{
				if (Utils.IsXmlNamespaceNode(nearestUnrenderedNamespaceWithMatchingPrefix))
				{
					attrListToRender.Add(nearestUnrenderedNamespaceWithMatchingPrefix, null);
				}
				else
				{
					nsListToRender.Add(nearestUnrenderedNamespaceWithMatchingPrefix, null);
				}
			}
		}

		internal override void GetNamespacesToRender(XmlElement element, SortedList attrListToRender, SortedList nsListToRender, Hashtable nsLocallyDeclared)
		{
			XmlAttribute xmlAttribute = null;
			object[] array = new object[nsLocallyDeclared.Count];
			nsLocallyDeclared.Values.CopyTo(array, 0);
			object[] array2 = array;
			foreach (object obj in array2)
			{
				xmlAttribute = (XmlAttribute)obj;
				int depth;
				XmlAttribute nearestRenderedNamespaceWithMatchingPrefix = GetNearestRenderedNamespaceWithMatchingPrefix(Utils.GetNamespacePrefix(xmlAttribute), out depth);
				if (Utils.IsNonRedundantNamespaceDecl(xmlAttribute, nearestRenderedNamespaceWithMatchingPrefix))
				{
					nsLocallyDeclared.Remove(Utils.GetNamespacePrefix(xmlAttribute));
					if (Utils.IsXmlNamespaceNode(xmlAttribute))
					{
						attrListToRender.Add(xmlAttribute, null);
					}
					else
					{
						nsListToRender.Add(xmlAttribute, null);
					}
				}
			}
			for (int num = m_ancestorStack.Count - 1; num >= 0; num--)
			{
				foreach (object value in GetScopeAt(num).GetUnrendered().Values)
				{
					xmlAttribute = (XmlAttribute)value;
					if (xmlAttribute != null)
					{
						GetNamespaceToRender(Utils.GetNamespacePrefix(xmlAttribute), attrListToRender, nsListToRender, nsLocallyDeclared);
					}
				}
			}
		}

		internal override void TrackNamespaceNode(XmlAttribute attr, SortedList nsListToRender, Hashtable nsLocallyDeclared)
		{
			nsLocallyDeclared.Add(Utils.GetNamespacePrefix(attr), attr);
		}

		internal override void TrackXmlNamespaceNode(XmlAttribute attr, SortedList nsListToRender, SortedList attrListToRender, Hashtable nsLocallyDeclared)
		{
			nsLocallyDeclared.Add(Utils.GetNamespacePrefix(attr), attr);
		}
	}
	/// <summary>Represents the <see langword="&lt;CipherData&gt;" /> element in XML encryption. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CipherData
	{
		private XmlElement m_cachedXml;

		private CipherReference m_cipherReference;

		private byte[] m_cipherValue;

		private bool CacheValid => m_cachedXml != null;

		/// <summary>Gets or sets the <see langword="&lt;CipherReference&gt;" /> element.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Xml.CipherReference" /> object.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Security.Cryptography.Xml.CipherData.CipherReference" /> property was set to <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.CipherData.CipherReference" /> property was set more than once.</exception>
		public CipherReference CipherReference
		{
			get
			{
				return m_cipherReference;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (CipherValue != null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CipherValueElementRequired"));
				}
				m_cipherReference = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the <see langword="&lt;CipherValue&gt;" /> element.</summary>
		/// <returns>A byte array that represents the <see langword="&lt;CipherValue&gt;" /> element.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Security.Cryptography.Xml.CipherData.CipherValue" /> property was set to <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.CipherData.CipherValue" /> property was set more than once.</exception>
		public byte[] CipherValue
		{
			get
			{
				return m_cipherValue;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (CipherReference != null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CipherValueElementRequired"));
				}
				m_cipherValue = (byte[])value.Clone();
				m_cachedXml = null;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.CipherData" /> class.</summary>
		public CipherData()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.CipherData" /> class using a byte array as the <see cref="P:System.Security.Cryptography.Xml.CipherData.CipherValue" /> value.</summary>
		/// <param name="cipherValue">The encrypted data to use for the <see langword="&lt;CipherValue&gt;" /> element.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="cipherValue" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.CipherData.CipherValue" /> property has already been set.</exception>
		public CipherData(byte[] cipherValue)
		{
			CipherValue = cipherValue;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.CipherData" /> class using a <see cref="T:System.Security.Cryptography.Xml.CipherReference" /> object.</summary>
		/// <param name="cipherReference">The <see cref="T:System.Security.Cryptography.Xml.CipherReference" /> object to use.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="cipherValue" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.CipherData.CipherValue" /> property has already been set.</exception>
		public CipherData(CipherReference cipherReference)
		{
			CipherReference = cipherReference;
		}

		/// <summary>Gets the XML values for the <see cref="T:System.Security.Cryptography.Xml.CipherData" /> object.</summary>
		/// <returns>A <see cref="T:System.Xml.XmlElement" /> object that represents the XML information for the <see cref="T:System.Security.Cryptography.Xml.CipherData" /> object.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.CipherData.CipherValue" /> property and the <see cref="P:System.Security.Cryptography.Xml.CipherData.CipherReference" /> property are <see langword="null" />.</exception>
		public XmlElement GetXml()
		{
			if (CacheValid)
			{
				return m_cachedXml;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument document)
		{
			XmlElement xmlElement = document.CreateElement("CipherData", "http://www.w3.org/2001/04/xmlenc#");
			if (CipherValue != null)
			{
				XmlElement xmlElement2 = document.CreateElement("CipherValue", "http://www.w3.org/2001/04/xmlenc#");
				xmlElement2.AppendChild(document.CreateTextNode(Convert.ToBase64String(CipherValue)));
				xmlElement.AppendChild(xmlElement2);
			}
			else
			{
				if (CipherReference == null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CipherValueElementRequired"));
				}
				xmlElement.AppendChild(CipherReference.GetXml(document));
			}
			return xmlElement;
		}

		/// <summary>Loads XML data from an <see cref="T:System.Xml.XmlElement" /> into a <see cref="T:System.Security.Cryptography.Xml.CipherData" /> object.</summary>
		/// <param name="value">An <see cref="T:System.Xml.XmlElement" /> that represents the XML data to load.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.CipherData.CipherValue" /> property and the <see cref="P:System.Security.Cryptography.Xml.CipherData.CipherReference" /> property are <see langword="null" />.</exception>
		public void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(value.OwnerDocument.NameTable);
			xmlNamespaceManager.AddNamespace("enc", "http://www.w3.org/2001/04/xmlenc#");
			XmlNode xmlNode = value.SelectSingleNode("enc:CipherValue", xmlNamespaceManager);
			XmlNode xmlNode2 = value.SelectSingleNode("enc:CipherReference", xmlNamespaceManager);
			if (xmlNode != null)
			{
				if (xmlNode2 != null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CipherValueElementRequired"));
				}
				m_cipherValue = Convert.FromBase64String(Utils.DiscardWhiteSpaces(xmlNode.InnerText));
			}
			else
			{
				if (xmlNode2 == null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CipherValueElementRequired"));
				}
				m_cipherReference = new CipherReference();
				m_cipherReference.LoadXml((XmlElement)xmlNode2);
			}
			m_cachedXml = value;
		}
	}
	/// <summary>Represents the object element of an XML signature that holds data to be signed.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class DataObject
	{
		private string m_id;

		private string m_mimeType;

		private string m_encoding;

		private CanonicalXmlNodeList m_elData;

		private XmlElement m_cachedXml;

		/// <summary>Gets or sets the identification of the current <see cref="T:System.Security.Cryptography.Xml.DataObject" /> object.</summary>
		/// <returns>The name of the element that contains data to be used.</returns>
		public string Id
		{
			get
			{
				return m_id;
			}
			set
			{
				m_id = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the MIME type of the current <see cref="T:System.Security.Cryptography.Xml.DataObject" /> object.</summary>
		/// <returns>The MIME type of the current <see cref="T:System.Security.Cryptography.Xml.DataObject" /> object. The default is <see langword="null" />.</returns>
		public string MimeType
		{
			get
			{
				return m_mimeType;
			}
			set
			{
				m_mimeType = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the encoding of the current <see cref="T:System.Security.Cryptography.Xml.DataObject" /> object.</summary>
		/// <returns>The type of encoding of the current <see cref="T:System.Security.Cryptography.Xml.DataObject" /> object.</returns>
		public string Encoding
		{
			get
			{
				return m_encoding;
			}
			set
			{
				m_encoding = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the data value of the current <see cref="T:System.Security.Cryptography.Xml.DataObject" /> object.</summary>
		/// <returns>The data of the current <see cref="T:System.Security.Cryptography.Xml.DataObject" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value used to set the property is <see langword="null" />.</exception>
		public XmlNodeList Data
		{
			get
			{
				return m_elData;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				m_elData = new CanonicalXmlNodeList();
				foreach (XmlNode item in value)
				{
					m_elData.Add(item);
				}
				m_cachedXml = null;
			}
		}

		private bool CacheValid => m_cachedXml != null;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.DataObject" /> class.</summary>
		public DataObject()
		{
			m_cachedXml = null;
			m_elData = new CanonicalXmlNodeList();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.DataObject" /> class with the specified identification, MIME type, encoding, and data.</summary>
		/// <param name="id">The identification to initialize the new instance of <see cref="T:System.Security.Cryptography.Xml.DataObject" /> with.</param>
		/// <param name="mimeType">The MIME type of the data used to initialize the new instance of <see cref="T:System.Security.Cryptography.Xml.DataObject" />.</param>
		/// <param name="encoding">The encoding of the data used to initialize the new instance of <see cref="T:System.Security.Cryptography.Xml.DataObject" />.</param>
		/// <param name="data">The data to initialize the new instance of <see cref="T:System.Security.Cryptography.Xml.DataObject" /> with.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="data" /> parameter is <see langword="null" />.</exception>
		public DataObject(string id, string mimeType, string encoding, XmlElement data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			m_id = id;
			m_mimeType = mimeType;
			m_encoding = encoding;
			m_elData = new CanonicalXmlNodeList();
			m_elData.Add(data);
			m_cachedXml = null;
		}

		/// <summary>Returns the XML representation of the <see cref="T:System.Security.Cryptography.Xml.DataObject" /> object.</summary>
		/// <returns>The XML representation of the <see cref="T:System.Security.Cryptography.Xml.DataObject" /> object.</returns>
		public XmlElement GetXml()
		{
			if (CacheValid)
			{
				return m_cachedXml;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument document)
		{
			XmlElement xmlElement = document.CreateElement("Object", "http://www.w3.org/2000/09/xmldsig#");
			if (!string.IsNullOrEmpty(m_id))
			{
				xmlElement.SetAttribute("Id", m_id);
			}
			if (!string.IsNullOrEmpty(m_mimeType))
			{
				xmlElement.SetAttribute("MimeType", m_mimeType);
			}
			if (!string.IsNullOrEmpty(m_encoding))
			{
				xmlElement.SetAttribute("Encoding", m_encoding);
			}
			if (m_elData != null)
			{
				foreach (XmlNode elDatum in m_elData)
				{
					xmlElement.AppendChild(document.ImportNode(elDatum, deep: true));
				}
				return xmlElement;
			}
			return xmlElement;
		}

		/// <summary>Loads a <see cref="T:System.Security.Cryptography.Xml.DataObject" /> state from an XML element.</summary>
		/// <param name="value">The XML element to load the <see cref="T:System.Security.Cryptography.Xml.DataObject" /> state from.</param>
		/// <exception cref="T:System.ArgumentNullException">The value from the XML element is <see langword="null" />.</exception>
		public void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			m_id = Utils.GetAttribute(value, "Id", "http://www.w3.org/2000/09/xmldsig#");
			m_mimeType = Utils.GetAttribute(value, "MimeType", "http://www.w3.org/2000/09/xmldsig#");
			m_encoding = Utils.GetAttribute(value, "Encoding", "http://www.w3.org/2000/09/xmldsig#");
			foreach (XmlNode childNode in value.ChildNodes)
			{
				m_elData.Add(childNode);
			}
			m_cachedXml = value;
		}
	}
	/// <summary>Represents the <see langword="&lt;EncryptedData&gt;" /> element in XML encryption. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EncryptedData : EncryptedType
	{
		/// <summary>Loads XML information into the <see langword="&lt;EncryptedData&gt;" /> element in XML encryption.</summary>
		/// <param name="value">An <see cref="T:System.Xml.XmlElement" /> object representing an XML element to use for the <see langword="&lt;EncryptedData&gt;" /> element.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> provided is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="value" /> parameter does not contain a &lt;<see langword="CypherData" />&gt; node.</exception>
		public override void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(value.OwnerDocument.NameTable);
			xmlNamespaceManager.AddNamespace("enc", "http://www.w3.org/2001/04/xmlenc#");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			Id = Utils.GetAttribute(value, "Id", "http://www.w3.org/2001/04/xmlenc#");
			Type = Utils.GetAttribute(value, "Type", "http://www.w3.org/2001/04/xmlenc#");
			MimeType = Utils.GetAttribute(value, "MimeType", "http://www.w3.org/2001/04/xmlenc#");
			Encoding = Utils.GetAttribute(value, "Encoding", "http://www.w3.org/2001/04/xmlenc#");
			XmlNode xmlNode = value.SelectSingleNode("enc:EncryptionMethod", xmlNamespaceManager);
			EncryptionMethod = new EncryptionMethod();
			if (xmlNode != null)
			{
				EncryptionMethod.LoadXml(xmlNode as XmlElement);
			}
			base.KeyInfo = new KeyInfo();
			XmlNode xmlNode2 = value.SelectSingleNode("ds:KeyInfo", xmlNamespaceManager);
			if (xmlNode2 != null)
			{
				base.KeyInfo.LoadXml(xmlNode2 as XmlElement);
			}
			XmlNode xmlNode3 = value.SelectSingleNode("enc:CipherData", xmlNamespaceManager);
			if (xmlNode3 == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingCipherData"));
			}
			CipherData = new CipherData();
			CipherData.LoadXml(xmlNode3 as XmlElement);
			XmlNode xmlNode4 = value.SelectSingleNode("enc:EncryptionProperties", xmlNamespaceManager);
			if (xmlNode4 != null)
			{
				XmlNodeList xmlNodeList = xmlNode4.SelectNodes("enc:EncryptionProperty", xmlNamespaceManager);
				if (xmlNodeList != null)
				{
					foreach (XmlNode item in xmlNodeList)
					{
						EncryptionProperty encryptionProperty = new EncryptionProperty();
						encryptionProperty.LoadXml(item as XmlElement);
						EncryptionProperties.Add(encryptionProperty);
					}
				}
			}
			m_cachedXml = value;
		}

		/// <summary>Returns the XML representation of the <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> object.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlElement" /> that represents the <see langword="&lt;EncryptedData&gt;" /> element in XML encryption.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> value is <see langword="null" />.</exception>
		public override XmlElement GetXml()
		{
			if (base.CacheValid)
			{
				return m_cachedXml;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument document)
		{
			XmlElement xmlElement = document.CreateElement("EncryptedData", "http://www.w3.org/2001/04/xmlenc#");
			if (!string.IsNullOrEmpty(Id))
			{
				xmlElement.SetAttribute("Id", Id);
			}
			if (!string.IsNullOrEmpty(Type))
			{
				xmlElement.SetAttribute("Type", Type);
			}
			if (!string.IsNullOrEmpty(MimeType))
			{
				xmlElement.SetAttribute("MimeType", MimeType);
			}
			if (!string.IsNullOrEmpty(Encoding))
			{
				xmlElement.SetAttribute("Encoding", Encoding);
			}
			if (EncryptionMethod != null)
			{
				xmlElement.AppendChild(EncryptionMethod.GetXml(document));
			}
			if (base.KeyInfo.Count > 0)
			{
				xmlElement.AppendChild(base.KeyInfo.GetXml(document));
			}
			if (CipherData == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingCipherData"));
			}
			xmlElement.AppendChild(CipherData.GetXml(document));
			if (EncryptionProperties.Count > 0)
			{
				XmlElement xmlElement2 = document.CreateElement("EncryptionProperties", "http://www.w3.org/2001/04/xmlenc#");
				for (int i = 0; i < EncryptionProperties.Count; i++)
				{
					EncryptionProperty encryptionProperty = EncryptionProperties.Item(i);
					xmlElement2.AppendChild(encryptionProperty.GetXml(document));
				}
				xmlElement.AppendChild(xmlElement2);
			}
			return xmlElement;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> class.</summary>
		public EncryptedData()
		{
		}
	}
	/// <summary>Represents the <see langword="&lt;EncryptedKey&gt;" /> element in XML encryption. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EncryptedKey : EncryptedType
	{
		private string m_recipient;

		private string m_carriedKeyName;

		private ReferenceList m_referenceList;

		/// <summary>Gets or sets the optional <see langword="Recipient" /> attribute in XML encryption.</summary>
		/// <returns>A string representing the value of the <see langword="Recipient" /> attribute.</returns>
		public string Recipient
		{
			get
			{
				if (m_recipient == null)
				{
					m_recipient = string.Empty;
				}
				return m_recipient;
			}
			set
			{
				m_recipient = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the optional <see langword="&lt;CarriedKeyName&gt;" /> element in XML encryption.</summary>
		/// <returns>A string that represents a name for the key value.</returns>
		public string CarriedKeyName
		{
			get
			{
				return m_carriedKeyName;
			}
			set
			{
				m_carriedKeyName = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the <see langword="&lt;ReferenceList&gt;" /> element in XML encryption.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> object.</returns>
		public ReferenceList ReferenceList
		{
			get
			{
				if (m_referenceList == null)
				{
					m_referenceList = new ReferenceList();
				}
				return m_referenceList;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptedKey" /> class.</summary>
		public EncryptedKey()
		{
		}

		/// <summary>Adds a <see langword="&lt;DataReference&gt;" /> element to the <see langword="&lt;ReferenceList&gt;" /> element.</summary>
		/// <param name="dataReference">A <see cref="T:System.Security.Cryptography.Xml.DataReference" /> object to add to the <see cref="P:System.Security.Cryptography.Xml.EncryptedKey.ReferenceList" /> property.</param>
		public void AddReference(DataReference dataReference)
		{
			ReferenceList.Add(dataReference);
		}

		/// <summary>Adds a <see langword="&lt;KeyReference&gt;" /> element to the <see langword="&lt;ReferenceList&gt;" /> element.</summary>
		/// <param name="keyReference">A <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object to add to the <see cref="P:System.Security.Cryptography.Xml.EncryptedKey.ReferenceList" /> property.</param>
		public void AddReference(KeyReference keyReference)
		{
			ReferenceList.Add(keyReference);
		}

		/// <summary>Loads the specified XML information into the <see langword="&lt;EncryptedKey&gt;" /> element in XML encryption.</summary>
		/// <param name="value">An <see cref="T:System.Xml.XmlElement" /> representing an XML element to use for the <see langword="&lt;EncryptedKey&gt;" /> element.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="value" /> parameter does not contain a <see cref="T:System.Security.Cryptography.Xml.CipherData" /> element.</exception>
		public override void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(value.OwnerDocument.NameTable);
			xmlNamespaceManager.AddNamespace("enc", "http://www.w3.org/2001/04/xmlenc#");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			Id = Utils.GetAttribute(value, "Id", "http://www.w3.org/2001/04/xmlenc#");
			Type = Utils.GetAttribute(value, "Type", "http://www.w3.org/2001/04/xmlenc#");
			MimeType = Utils.GetAttribute(value, "MimeType", "http://www.w3.org/2001/04/xmlenc#");
			Encoding = Utils.GetAttribute(value, "Encoding", "http://www.w3.org/2001/04/xmlenc#");
			Recipient = Utils.GetAttribute(value, "Recipient", "http://www.w3.org/2001/04/xmlenc#");
			XmlNode xmlNode = value.SelectSingleNode("enc:EncryptionMethod", xmlNamespaceManager);
			EncryptionMethod = new EncryptionMethod();
			if (xmlNode != null)
			{
				EncryptionMethod.LoadXml(xmlNode as XmlElement);
			}
			base.KeyInfo = new KeyInfo();
			XmlNode xmlNode2 = value.SelectSingleNode("ds:KeyInfo", xmlNamespaceManager);
			if (xmlNode2 != null)
			{
				base.KeyInfo.LoadXml(xmlNode2 as XmlElement);
			}
			XmlNode xmlNode3 = value.SelectSingleNode("enc:CipherData", xmlNamespaceManager);
			if (xmlNode3 == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingCipherData"));
			}
			CipherData = new CipherData();
			CipherData.LoadXml(xmlNode3 as XmlElement);
			XmlNode xmlNode4 = value.SelectSingleNode("enc:EncryptionProperties", xmlNamespaceManager);
			if (xmlNode4 != null)
			{
				XmlNodeList xmlNodeList = xmlNode4.SelectNodes("enc:EncryptionProperty", xmlNamespaceManager);
				if (xmlNodeList != null)
				{
					foreach (XmlNode item in xmlNodeList)
					{
						EncryptionProperty encryptionProperty = new EncryptionProperty();
						encryptionProperty.LoadXml(item as XmlElement);
						EncryptionProperties.Add(encryptionProperty);
					}
				}
			}
			XmlNode xmlNode6 = value.SelectSingleNode("enc:CarriedKeyName", xmlNamespaceManager);
			if (xmlNode6 != null)
			{
				CarriedKeyName = xmlNode6.InnerText;
			}
			XmlNode xmlNode7 = value.SelectSingleNode("enc:ReferenceList", xmlNamespaceManager);
			if (xmlNode7 != null)
			{
				XmlNodeList xmlNodeList2 = xmlNode7.SelectNodes("enc:DataReference", xmlNamespaceManager);
				if (xmlNodeList2 != null)
				{
					foreach (XmlNode item2 in xmlNodeList2)
					{
						DataReference dataReference = new DataReference();
						dataReference.LoadXml(item2 as XmlElement);
						ReferenceList.Add(dataReference);
					}
				}
				XmlNodeList xmlNodeList3 = xmlNode7.SelectNodes("enc:KeyReference", xmlNamespaceManager);
				if (xmlNodeList3 != null)
				{
					foreach (XmlNode item3 in xmlNodeList3)
					{
						KeyReference keyReference = new KeyReference();
						keyReference.LoadXml(item3 as XmlElement);
						ReferenceList.Add(keyReference);
					}
				}
			}
			m_cachedXml = value;
		}

		/// <summary>Returns the XML representation of the <see cref="T:System.Security.Cryptography.Xml.EncryptedKey" /> object.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlElement" /> that represents the <see langword="&lt;EncryptedKey&gt;" /> element in XML encryption.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="T:System.Security.Cryptography.Xml.EncryptedKey" /> value is <see langword="null" />.</exception>
		public override XmlElement GetXml()
		{
			if (base.CacheValid)
			{
				return m_cachedXml;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument document)
		{
			XmlElement xmlElement = document.CreateElement("EncryptedKey", "http://www.w3.org/2001/04/xmlenc#");
			if (!string.IsNullOrEmpty(Id))
			{
				xmlElement.SetAttribute("Id", Id);
			}
			if (!string.IsNullOrEmpty(Type))
			{
				xmlElement.SetAttribute("Type", Type);
			}
			if (!string.IsNullOrEmpty(MimeType))
			{
				xmlElement.SetAttribute("MimeType", MimeType);
			}
			if (!string.IsNullOrEmpty(Encoding))
			{
				xmlElement.SetAttribute("Encoding", Encoding);
			}
			if (!string.IsNullOrEmpty(Recipient))
			{
				xmlElement.SetAttribute("Recipient", Recipient);
			}
			if (EncryptionMethod != null)
			{
				xmlElement.AppendChild(EncryptionMethod.GetXml(document));
			}
			if (base.KeyInfo.Count > 0)
			{
				xmlElement.AppendChild(base.KeyInfo.GetXml(document));
			}
			if (CipherData == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingCipherData"));
			}
			xmlElement.AppendChild(CipherData.GetXml(document));
			if (EncryptionProperties.Count > 0)
			{
				XmlElement xmlElement2 = document.CreateElement("EncryptionProperties", "http://www.w3.org/2001/04/xmlenc#");
				for (int i = 0; i < EncryptionProperties.Count; i++)
				{
					EncryptionProperty encryptionProperty = EncryptionProperties.Item(i);
					xmlElement2.AppendChild(encryptionProperty.GetXml(document));
				}
				xmlElement.AppendChild(xmlElement2);
			}
			if (ReferenceList.Count > 0)
			{
				XmlElement xmlElement3 = document.CreateElement("ReferenceList", "http://www.w3.org/2001/04/xmlenc#");
				for (int j = 0; j < ReferenceList.Count; j++)
				{
					xmlElement3.AppendChild(ReferenceList[j].GetXml(document));
				}
				xmlElement.AppendChild(xmlElement3);
			}
			if (CarriedKeyName != null)
			{
				XmlElement xmlElement4 = document.CreateElement("CarriedKeyName", "http://www.w3.org/2001/04/xmlenc#");
				XmlText newChild = document.CreateTextNode(CarriedKeyName);
				xmlElement4.AppendChild(newChild);
				xmlElement.AppendChild(xmlElement4);
			}
			return xmlElement;
		}
	}
	/// <summary>Represents the <see langword="&lt;ReferenceList&gt;" /> element used in XML encryption. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ReferenceList : IList, ICollection, IEnumerable
	{
		private ArrayList m_references;

		/// <summary>Gets the number of elements contained in the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> object.</summary>
		/// <returns>The number of elements contained in the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> object.</returns>
		public int Count => m_references.Count;

		/// <summary>Gets or sets the <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object at the specified index.</summary>
		/// <param name="index">The index of the <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object to return.</param>
		/// <returns>The <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> object at the specified index.</returns>
		[IndexerName("ItemOf")]
		public EncryptedReference this[int index]
		{
			get
			{
				return Item(index);
			}
			set
			{
				((IList)this)[index] = value;
			}
		}

		/// <summary>For a description of this member, see <see cref="P:System.Collections.IList.Item(System.Int32)" />.</summary>
		/// <param name="index">The zero-based index of the element to get or set.</param>
		/// <returns>The element at the specified index.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.IList" />.</exception>
		object IList.this[int index]
		{
			get
			{
				return m_references[index];
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (!(value is DataReference) && !(value is KeyReference))
				{
					throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "value");
				}
				m_references[index] = value;
			}
		}

		/// <summary>For a description of this member, see <see cref="P:System.Collections.IList.IsFixedSize" />.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="T:System.Collections.IList" /> has a fixed size; otherwise, <see langword="false" />.</returns>
		bool IList.IsFixedSize => m_references.IsFixedSize;

		/// <summary>For a description of this member, see <see cref="P:System.Collections.IList.IsReadOnly" />.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="T:System.Collections.IList" /> is read-only; otherwise, <see langword="false" />.</returns>
		bool IList.IsReadOnly => m_references.IsReadOnly;

		/// <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> object.</summary>
		/// <returns>An object that can be used to synchronize access to the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> object.</returns>
		public object SyncRoot => m_references.SyncRoot;

		/// <summary>Gets a value that indicates whether access to the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> object is synchronized (thread safe).</summary>
		/// <returns>
		///   <see langword="true" /> if access to the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> object is synchronized (thread safe); otherwise, <see langword="false" />.</returns>
		public bool IsSynchronized => m_references.IsSynchronized;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> class.</summary>
		public ReferenceList()
		{
			m_references = new ArrayList();
		}

		/// <summary>Returns an enumerator that iterates through a <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through a <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection.</returns>
		public IEnumerator GetEnumerator()
		{
			return m_references.GetEnumerator();
		}

		/// <summary>Adds a <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object to the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection.</summary>
		/// <param name="value">A <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object to add to the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection.</param>
		/// <returns>The position at which the new element was inserted.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="value" /> parameter is not a <see cref="T:System.Security.Cryptography.Xml.DataReference" /> object.  
		///  -or-  
		///  The <paramref name="value" /> parameter is not a <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object.</exception>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		public int Add(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (!(value is DataReference) && !(value is KeyReference))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "value");
			}
			return m_references.Add(value);
		}

		/// <summary>Removes all items from the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection.</summary>
		public void Clear()
		{
			m_references.Clear();
		}

		/// <summary>Determines whether the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection contains a specific <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object.</summary>
		/// <param name="value">The <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object to locate in the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object is found in the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection; otherwise, <see langword="false" />.</returns>
		public bool Contains(object value)
		{
			return m_references.Contains(value);
		}

		/// <summary>Determines the index of a specific item in the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection.</summary>
		/// <param name="value">The <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object to locate in the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection.</param>
		/// <returns>The index of <paramref name="value" /> if found in the collection; otherwise, -1.</returns>
		public int IndexOf(object value)
		{
			return m_references.IndexOf(value);
		}

		/// <summary>Inserts a <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object into the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection at the specified position.</summary>
		/// <param name="index">The zero-based index at which <paramref name="value" /> should be inserted.</param>
		/// <param name="value">A <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object to insert into the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="value" /> parameter is not a <see cref="T:System.Security.Cryptography.Xml.DataReference" /> object.  
		///  -or-  
		///  The <paramref name="value" /> parameter is not a <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object.</exception>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		public void Insert(int index, object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (!(value is DataReference) && !(value is KeyReference))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "value");
			}
			m_references.Insert(index, value);
		}

		/// <summary>Removes the first occurrence of a specific <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object from the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection.</summary>
		/// <param name="value">The <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object to remove from the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> collection.</param>
		public void Remove(object value)
		{
			m_references.Remove(value);
		}

		/// <summary>Removes the <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object at the specified index.</summary>
		/// <param name="index">The zero-based index of the <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object to remove.</param>
		public void RemoveAt(int index)
		{
			m_references.RemoveAt(index);
		}

		/// <summary>Returns the <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object at the specified index.</summary>
		/// <param name="index">The index of the <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object to return.</param>
		/// <returns>The <see cref="T:System.Security.Cryptography.Xml.DataReference" /> or <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> object at the specified index.</returns>
		public EncryptedReference Item(int index)
		{
			return (EncryptedReference)m_references[index];
		}

		/// <summary>Copies the elements of the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> object to an array, starting at a specified array index.</summary>
		/// <param name="array">The one-dimensional <see cref="T:System.Array" /> object that is the destination of the elements copied from the <see cref="T:System.Security.Cryptography.Xml.ReferenceList" /> object. The array must have zero-based indexing.</param>
		/// <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
		public void CopyTo(Array array, int index)
		{
			m_references.CopyTo(array, index);
		}
	}
	/// <summary>Represents the abstract base class used in XML encryption from which the <see cref="T:System.Security.Cryptography.Xml.CipherReference" />, <see cref="T:System.Security.Cryptography.Xml.KeyReference" />, and <see cref="T:System.Security.Cryptography.Xml.DataReference" /> classes derive.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class EncryptedReference
	{
		private string m_uri;

		private string m_referenceType;

		private TransformChain m_transformChain;

		internal XmlElement m_cachedXml;

		/// <summary>Gets or sets the Uniform Resource Identifier (URI) of an <see cref="T:System.Security.Cryptography.Xml.EncryptedReference" /> object.</summary>
		/// <returns>The Uniform Resource Identifier (URI) of the <see cref="T:System.Security.Cryptography.Xml.EncryptedReference" /> object.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Security.Cryptography.Xml.EncryptedReference.Uri" /> property was set to <see langword="null" />.</exception>
		public string Uri
		{
			get
			{
				return m_uri;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException(SecurityResources.GetResourceString("Cryptography_Xml_UriRequired"));
				}
				m_uri = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the transform chain of an <see cref="T:System.Security.Cryptography.Xml.EncryptedReference" /> object.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object that describes transforms used on the encrypted data.</returns>
		public TransformChain TransformChain
		{
			get
			{
				if (m_transformChain == null)
				{
					m_transformChain = new TransformChain();
				}
				return m_transformChain;
			}
			set
			{
				m_transformChain = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets a reference type.</summary>
		/// <returns>The reference type of the encrypted data.</returns>
		protected string ReferenceType
		{
			get
			{
				return m_referenceType;
			}
			set
			{
				m_referenceType = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets a value that indicates whether the cache is valid.</summary>
		/// <returns>
		///   <see langword="true" /> if the cache is valid; otherwise, <see langword="false" />.</returns>
		protected internal bool CacheValid => m_cachedXml != null;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptedReference" /> class.</summary>
		protected EncryptedReference()
			: this(string.Empty, new TransformChain())
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptedReference" /> class using the specified Uniform Resource Identifier (URI).</summary>
		/// <param name="uri">The Uniform Resource Identifier (URI) that points to the data to encrypt.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="uri" /> parameter is <see langword="null" />.</exception>
		protected EncryptedReference(string uri)
			: this(uri, new TransformChain())
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptedReference" /> class using the specified Uniform Resource Identifier (URI) and transform chain.</summary>
		/// <param name="uri">The Uniform Resource Identifier (URI) that points to the data to encrypt.</param>
		/// <param name="transformChain">A <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object that describes transforms to be done on the data to encrypt.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="uri" /> parameter is <see langword="null" />.</exception>
		protected EncryptedReference(string uri, TransformChain transformChain)
		{
			TransformChain = transformChain;
			Uri = uri;
			m_cachedXml = null;
		}

		/// <summary>Adds a <see cref="T:System.Security.Cryptography.Xml.Transform" /> object to the current transform chain of an <see cref="T:System.Security.Cryptography.Xml.EncryptedReference" /> object.</summary>
		/// <param name="transform">A <see cref="T:System.Security.Cryptography.Xml.Transform" /> object to add to the transform chain.</param>
		public void AddTransform(Transform transform)
		{
			TransformChain.Add(transform);
		}

		/// <summary>Returns the XML representation of an <see cref="T:System.Security.Cryptography.Xml.EncryptedReference" /> object.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlElement" /> object that represents the values of the <see langword="&lt;EncryptedReference&gt;" /> element in XML encryption.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.EncryptedReference.ReferenceType" /> property is <see langword="null" />.</exception>
		public virtual XmlElement GetXml()
		{
			if (CacheValid)
			{
				return m_cachedXml;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument document)
		{
			if (ReferenceType == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_ReferenceTypeRequired"));
			}
			XmlElement xmlElement = document.CreateElement(ReferenceType, "http://www.w3.org/2001/04/xmlenc#");
			if (!string.IsNullOrEmpty(m_uri))
			{
				xmlElement.SetAttribute("URI", m_uri);
			}
			if (TransformChain.Count > 0)
			{
				xmlElement.AppendChild(TransformChain.GetXml(document, "http://www.w3.org/2000/09/xmldsig#"));
			}
			return xmlElement;
		}

		/// <summary>Loads an XML element into an <see cref="T:System.Security.Cryptography.Xml.EncryptedReference" /> object.</summary>
		/// <param name="value">An <see cref="T:System.Xml.XmlElement" /> object that represents an XML element.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		public virtual void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			ReferenceType = value.LocalName;
			Uri = Utils.GetAttribute(value, "URI", "http://www.w3.org/2001/04/xmlenc#");
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(value.OwnerDocument.NameTable);
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			XmlNode xmlNode = value.SelectSingleNode("ds:Transforms", xmlNamespaceManager);
			if (xmlNode != null)
			{
				TransformChain.LoadXml(xmlNode as XmlElement);
			}
			m_cachedXml = value;
		}
	}
	/// <summary>Represents the <see langword="&lt;CipherReference&gt;" /> element in XML encryption. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CipherReference : EncryptedReference
	{
		private byte[] m_cipherValue;

		internal byte[] CipherValue
		{
			get
			{
				if (!base.CacheValid)
				{
					return null;
				}
				return m_cipherValue;
			}
			set
			{
				m_cipherValue = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.CipherReference" /> class.</summary>
		public CipherReference()
		{
			base.ReferenceType = "CipherReference";
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.CipherReference" /> class using the specified Uniform Resource Identifier (URI).</summary>
		/// <param name="uri">A Uniform Resource Identifier (URI) pointing to the encrypted data.</param>
		public CipherReference(string uri)
			: base(uri)
		{
			base.ReferenceType = "CipherReference";
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.CipherReference" /> class using the specified Uniform Resource Identifier (URI) and transform chain information.</summary>
		/// <param name="uri">A Uniform Resource Identifier (URI) pointing to the encrypted data.</param>
		/// <param name="transformChain">A <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object that describes transforms to do on the encrypted data.</param>
		public CipherReference(string uri, TransformChain transformChain)
			: base(uri, transformChain)
		{
			base.ReferenceType = "CipherReference";
		}

		/// <summary>Returns the XML representation of a <see cref="T:System.Security.Cryptography.Xml.CipherReference" /> object.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlElement" /> that represents the <see langword="&lt;CipherReference&gt;" /> element in XML encryption.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="T:System.Security.Cryptography.Xml.CipherReference" /> value is <see langword="null" />.</exception>
		public override XmlElement GetXml()
		{
			if (base.CacheValid)
			{
				return m_cachedXml;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal new XmlElement GetXml(XmlDocument document)
		{
			if (base.ReferenceType == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_ReferenceTypeRequired"));
			}
			XmlElement xmlElement = document.CreateElement(base.ReferenceType, "http://www.w3.org/2001/04/xmlenc#");
			if (!string.IsNullOrEmpty(base.Uri))
			{
				xmlElement.SetAttribute("URI", base.Uri);
			}
			if (base.TransformChain.Count > 0)
			{
				xmlElement.AppendChild(base.TransformChain.GetXml(document, "http://www.w3.org/2001/04/xmlenc#"));
			}
			return xmlElement;
		}

		/// <summary>Loads XML information into the <see langword="&lt;CipherReference&gt;" /> element in XML encryption.</summary>
		/// <param name="value">An <see cref="T:System.Xml.XmlElement" /> object that represents an XML element to use as the reference.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> provided is <see langword="null" />.</exception>
		public override void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			base.ReferenceType = value.LocalName;
			string attribute = Utils.GetAttribute(value, "URI", "http://www.w3.org/2001/04/xmlenc#");
			if (!Utils.GetSkipSignatureAttributeEnforcement() && attribute == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriRequired"));
			}
			base.Uri = attribute;
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(value.OwnerDocument.NameTable);
			xmlNamespaceManager.AddNamespace("enc", "http://www.w3.org/2001/04/xmlenc#");
			XmlNode xmlNode = value.SelectSingleNode("enc:Transforms", xmlNamespaceManager);
			if (xmlNode != null)
			{
				base.TransformChain.LoadXml(xmlNode as XmlElement);
			}
			m_cachedXml = value;
		}
	}
	/// <summary>Represents the <see langword="&lt;DataReference&gt;" /> element used in XML encryption. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class DataReference : EncryptedReference
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.DataReference" /> class.</summary>
		public DataReference()
		{
			base.ReferenceType = "DataReference";
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.DataReference" /> class using the specified Uniform Resource Identifier (URI).</summary>
		/// <param name="uri">A Uniform Resource Identifier (URI) that points to the encrypted data.</param>
		public DataReference(string uri)
			: base(uri)
		{
			base.ReferenceType = "DataReference";
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.DataReference" /> class using the specified Uniform Resource Identifier (URI) and a <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object.</summary>
		/// <param name="uri">A Uniform Resource Identifier (URI) that points to the encrypted data.</param>
		/// <param name="transformChain">A <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object that describes transforms to do on the encrypted data.</param>
		public DataReference(string uri, TransformChain transformChain)
			: base(uri, transformChain)
		{
			base.ReferenceType = "DataReference";
		}
	}
	/// <summary>Represents the <see langword="&lt;KeyReference&gt;" /> element used in XML encryption. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class KeyReference : EncryptedReference
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> class for XML encryption.</summary>
		public KeyReference()
		{
			base.ReferenceType = "KeyReference";
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> class for XML encryption using the supplied Uniform Resource Identifier (URI).</summary>
		/// <param name="uri">A Uniform Resource Identifier (URI) that points to the encrypted key.</param>
		public KeyReference(string uri)
			: base(uri)
		{
			base.ReferenceType = "KeyReference";
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyReference" /> class for XML encryption using the specified Uniform Resource Identifier (URI) and a <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object.</summary>
		/// <param name="uri">A Uniform Resource Identifier (URI) that points to the encrypted key.</param>
		/// <param name="transformChain">A <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object that describes transforms to do on the encrypted key.</param>
		public KeyReference(string uri, TransformChain transformChain)
			: base(uri, transformChain)
		{
			base.ReferenceType = "KeyReference";
		}
	}
	/// <summary>Represents the abstract base class from which the classes <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> and <see cref="T:System.Security.Cryptography.Xml.EncryptedKey" /> derive.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class EncryptedType
	{
		private string m_id;

		private string m_type;

		private string m_mimeType;

		private string m_encoding;

		private EncryptionMethod m_encryptionMethod;

		private CipherData m_cipherData;

		private EncryptionPropertyCollection m_props;

		private KeyInfo m_keyInfo;

		internal XmlElement m_cachedXml;

		internal bool CacheValid => m_cachedXml != null;

		/// <summary>Gets or sets the <see langword="Id" /> attribute of an <see cref="T:System.Security.Cryptography.Xml.EncryptedType" /> instance in XML encryption.</summary>
		/// <returns>A string of the <see langword="Id" /> attribute of the <see langword="&lt;EncryptedType&gt;" /> element.</returns>
		public virtual string Id
		{
			get
			{
				return m_id;
			}
			set
			{
				m_id = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the <see langword="Type" /> attribute of an <see cref="T:System.Security.Cryptography.Xml.EncryptedType" /> instance in XML encryption.</summary>
		/// <returns>A string that describes the text form of the encrypted data.</returns>
		public virtual string Type
		{
			get
			{
				return m_type;
			}
			set
			{
				m_type = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the <see langword="MimeType" /> attribute of an <see cref="T:System.Security.Cryptography.Xml.EncryptedType" /> instance in XML encryption.</summary>
		/// <returns>A string that describes the media type of the encrypted data.</returns>
		public virtual string MimeType
		{
			get
			{
				return m_mimeType;
			}
			set
			{
				m_mimeType = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the <see langword="Encoding" /> attribute of an <see cref="T:System.Security.Cryptography.Xml.EncryptedType" /> instance in XML encryption.</summary>
		/// <returns>A string that describes the encoding of the encrypted data.</returns>
		public virtual string Encoding
		{
			get
			{
				return m_encoding;
			}
			set
			{
				m_encoding = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets of sets the <see langword="&lt;KeyInfo&gt;" /> element in XML encryption.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object.</returns>
		public KeyInfo KeyInfo
		{
			get
			{
				if (m_keyInfo == null)
				{
					m_keyInfo = new KeyInfo();
				}
				return m_keyInfo;
			}
			set
			{
				m_keyInfo = value;
			}
		}

		/// <summary>Gets or sets the <see langword="&lt;EncryptionMethod&gt;" /> element for XML encryption.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Xml.EncryptionMethod" /> object that represents the <see langword="&lt;EncryptionMethod&gt;" /> element.</returns>
		public virtual EncryptionMethod EncryptionMethod
		{
			get
			{
				return m_encryptionMethod;
			}
			set
			{
				m_encryptionMethod = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the <see langword="&lt;EncryptionProperties&gt;" /> element in XML encryption.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</returns>
		public virtual EncryptionPropertyCollection EncryptionProperties
		{
			get
			{
				if (m_props == null)
				{
					m_props = new EncryptionPropertyCollection();
				}
				return m_props;
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Security.Cryptography.Xml.CipherData" /> value for an instance of an <see cref="T:System.Security.Cryptography.Xml.EncryptedType" /> class.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Xml.CipherData" /> object.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Security.Cryptography.Xml.EncryptedType.CipherData" /> property was set to <see langword="null" />.</exception>
		public virtual CipherData CipherData
		{
			get
			{
				if (m_cipherData == null)
				{
					m_cipherData = new CipherData();
				}
				return m_cipherData;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				m_cipherData = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Adds an <see langword="&lt;EncryptionProperty&gt;" /> child element to the <see langword="&lt;EncryptedProperties&gt;" /> element in the current <see cref="T:System.Security.Cryptography.Xml.EncryptedType" /> object in XML encryption.</summary>
		/// <param name="ep">An <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object.</param>
		public void AddProperty(EncryptionProperty ep)
		{
			EncryptionProperties.Add(ep);
		}

		/// <summary>Loads XML information into the <see langword="&lt;EncryptedType&gt;" /> element in XML encryption.</summary>
		/// <param name="value">An <see cref="T:System.Xml.XmlElement" /> object representing an XML element to use in the <see langword="&lt;EncryptedType&gt;" /> element.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> provided is <see langword="null" />.</exception>
		public abstract void LoadXml(XmlElement value);

		/// <summary>Returns the XML representation of the <see cref="T:System.Security.Cryptography.Xml.EncryptedType" /> object.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlElement" /> object that represents the <see langword="&lt;EncryptedType&gt;" /> element in XML encryption.</returns>
		public abstract XmlElement GetXml();

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptedType" /> class.</summary>
		protected EncryptedType()
		{
		}
	}
	/// <summary>Encapsulates the encryption algorithm used for XML encryption.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EncryptionMethod
	{
		private XmlElement m_cachedXml;

		private int m_keySize;

		private string m_algorithm;

		private bool CacheValid => m_cachedXml != null;

		/// <summary>Gets or sets the algorithm key size used for XML encryption.</summary>
		/// <returns>The algorithm key size, in bits, used for XML encryption.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The <see cref="P:System.Security.Cryptography.Xml.EncryptionMethod.KeySize" /> property was set to a value that was less than 0.</exception>
		public int KeySize
		{
			get
			{
				return m_keySize;
			}
			set
			{
				if (value <= 0)
				{
					throw new ArgumentOutOfRangeException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidKeySize"));
				}
				m_keySize = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets a Uniform Resource Identifier (URI) that describes the algorithm to use for XML encryption.</summary>
		/// <returns>A Uniform Resource Identifier (URI) that describes the algorithm to use for XML encryption.</returns>
		public string KeyAlgorithm
		{
			get
			{
				return m_algorithm;
			}
			set
			{
				m_algorithm = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptionMethod" /> class.</summary>
		public EncryptionMethod()
		{
			m_cachedXml = null;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptionMethod" /> class specifying an algorithm Uniform Resource Identifier (URI).</summary>
		/// <param name="algorithm">The Uniform Resource Identifier (URI) that describes the algorithm represented by an instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptionMethod" /> class.</param>
		public EncryptionMethod(string algorithm)
		{
			m_algorithm = algorithm;
			m_cachedXml = null;
		}

		/// <summary>Returns an <see cref="T:System.Xml.XmlElement" /> object that encapsulates an instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptionMethod" /> class.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlElement" /> object that encapsulates an instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptionMethod" /> class.</returns>
		public XmlElement GetXml()
		{
			if (CacheValid)
			{
				return m_cachedXml;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument document)
		{
			XmlElement xmlElement = document.CreateElement("EncryptionMethod", "http://www.w3.org/2001/04/xmlenc#");
			if (!string.IsNullOrEmpty(m_algorithm))
			{
				xmlElement.SetAttribute("Algorithm", m_algorithm);
			}
			if (m_keySize > 0)
			{
				XmlElement xmlElement2 = document.CreateElement("KeySize", "http://www.w3.org/2001/04/xmlenc#");
				xmlElement2.AppendChild(document.CreateTextNode(m_keySize.ToString(null, null)));
				xmlElement.AppendChild(xmlElement2);
			}
			return xmlElement;
		}

		/// <summary>Parses the specified <see cref="T:System.Xml.XmlElement" /> object and configures the internal state of the <see cref="T:System.Security.Cryptography.Xml.EncryptionMethod" /> object to match.</summary>
		/// <param name="value">An <see cref="T:System.Xml.XmlElement" /> object to parse.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The key size expressed in the <paramref name="value" /> parameter was less than 0.</exception>
		public void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(value.OwnerDocument.NameTable);
			xmlNamespaceManager.AddNamespace("enc", "http://www.w3.org/2001/04/xmlenc#");
			m_algorithm = Utils.GetAttribute(value, "Algorithm", "http://www.w3.org/2001/04/xmlenc#");
			XmlNode xmlNode = value.SelectSingleNode("enc:KeySize", xmlNamespaceManager);
			if (xmlNode != null)
			{
				KeySize = Convert.ToInt32(Utils.DiscardWhiteSpaces(xmlNode.InnerText), null);
			}
			m_cachedXml = value;
		}
	}
	/// <summary>Represents the <see langword="&lt;EncryptionProperty&gt;" /> element used in XML encryption. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EncryptionProperty
	{
		private string m_target;

		private string m_id;

		private XmlElement m_elemProp;

		private XmlElement m_cachedXml;

		/// <summary>Gets the ID of the current <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object.</summary>
		/// <returns>The ID of the current <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object.</returns>
		public string Id => m_id;

		/// <summary>Gets the target of the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object.</summary>
		/// <returns>The target of the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object.</returns>
		public string Target => m_target;

		/// <summary>Gets or sets an <see cref="T:System.Xml.XmlElement" /> object that represents an <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlElement" /> object that represents an <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Security.Cryptography.Xml.EncryptionProperty.PropertyElement" /> property was set to <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Xml.XmlElement.LocalName" /> property of the value set to the <see cref="P:System.Security.Cryptography.Xml.EncryptionProperty.PropertyElement" /> property is not "EncryptionProperty".  
		///  -or-  
		///  The <see cref="P:System.Xml.XmlElement.NamespaceURI" /> property of the value set to the <see cref="P:System.Security.Cryptography.Xml.EncryptionProperty.PropertyElement" /> property is not "http://www.w3.org/2001/04/xmlenc#".</exception>
		public XmlElement PropertyElement
		{
			get
			{
				return m_elemProp;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (value.LocalName != "EncryptionProperty" || value.NamespaceURI != "http://www.w3.org/2001/04/xmlenc#")
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidEncryptionProperty"));
				}
				m_elemProp = value;
				m_cachedXml = null;
			}
		}

		private bool CacheValid => m_cachedXml != null;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> class.</summary>
		public EncryptionProperty()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> class using an <see cref="T:System.Xml.XmlElement" /> object.</summary>
		/// <param name="elementProperty">An <see cref="T:System.Xml.XmlElement" /> object to use for initialization.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="elementProperty" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Xml.XmlElement.LocalName" /> property of the <paramref name="elementProperty" /> parameter is not "EncryptionProperty".  
		///  -or-  
		///  The <see cref="P:System.Xml.XmlElement.NamespaceURI" /> property of the <paramref name="elementProperty" /> parameter is not "http://www.w3.org/2001/04/xmlenc#".</exception>
		public EncryptionProperty(XmlElement elementProperty)
		{
			if (elementProperty == null)
			{
				throw new ArgumentNullException("elementProperty");
			}
			if (elementProperty.LocalName != "EncryptionProperty" || elementProperty.NamespaceURI != "http://www.w3.org/2001/04/xmlenc#")
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidEncryptionProperty"));
			}
			m_elemProp = elementProperty;
			m_cachedXml = null;
		}

		/// <summary>Returns an <see cref="T:System.Xml.XmlElement" /> object that encapsulates an instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> class.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlElement" /> object that encapsulates an instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> class.</returns>
		public XmlElement GetXml()
		{
			if (CacheValid)
			{
				return m_cachedXml;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument document)
		{
			return document.ImportNode(m_elemProp, deep: true) as XmlElement;
		}

		/// <summary>Parses the input <see cref="T:System.Xml.XmlElement" /> and configures the internal state of the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object to match.</summary>
		/// <param name="value">An <see cref="T:System.Xml.XmlElement" /> object to parse.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Xml.XmlElement.LocalName" /> property of the <paramref name="value" /> parameter is not "EncryptionProperty".  
		///  -or-  
		///  The <see cref="P:System.Xml.XmlElement.NamespaceURI" /> property of the <paramref name="value" /> parameter is not "http://www.w3.org/2001/04/xmlenc#".</exception>
		public void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (value.LocalName != "EncryptionProperty" || value.NamespaceURI != "http://www.w3.org/2001/04/xmlenc#")
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidEncryptionProperty"));
			}
			m_cachedXml = value;
			m_id = Utils.GetAttribute(value, "Id", "http://www.w3.org/2001/04/xmlenc#");
			m_target = Utils.GetAttribute(value, "Target", "http://www.w3.org/2001/04/xmlenc#");
			m_elemProp = value;
		}
	}
	/// <summary>Represents a collection of <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> classes used in XML encryption. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EncryptionPropertyCollection : IList, ICollection, IEnumerable
	{
		private ArrayList m_props;

		/// <summary>Gets the number of elements contained in the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</summary>
		/// <returns>The number of elements contained in the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</returns>
		public int Count => m_props.Count;

		/// <summary>Gets a value that indicates whether the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object has a fixed size.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object has a fixed size; otherwise, <see langword="false" />.</returns>
		public bool IsFixedSize => m_props.IsFixedSize;

		/// <summary>Gets a value that indicates whether the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object is read-only.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object is read-only; otherwise, <see langword="false" />.</returns>
		public bool IsReadOnly => m_props.IsReadOnly;

		/// <summary>Gets or sets the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object at the specified index.</summary>
		/// <param name="index">The index of the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object to return.</param>
		/// <returns>The <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object at the specified index.</returns>
		[IndexerName("ItemOf")]
		public EncryptionProperty this[int index]
		{
			get
			{
				return (EncryptionProperty)((IList)this)[index];
			}
			set
			{
				((IList)this)[index] = value;
			}
		}

		/// <summary>Gets the element at the specified index.</summary>
		/// <param name="index">The <see cref="T:System.Object" /> to remove from the <see cref="T:System.Collections.IList" />.</param>
		/// <returns>The element at the specified index.</returns>
		object IList.this[int index]
		{
			get
			{
				return m_props[index];
			}
			set
			{
				if (!(value is EncryptionProperty))
				{
					throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "value");
				}
				m_props[index] = value;
			}
		}

		/// <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</summary>
		/// <returns>An object that can be used to synchronize access to the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</returns>
		public object SyncRoot => m_props.SyncRoot;

		/// <summary>Gets a value that indicates whether access to the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object is synchronized (thread safe).</summary>
		/// <returns>
		///   <see langword="true" /> if access to the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object is synchronized (thread safe); otherwise, <see langword="false" />.</returns>
		public bool IsSynchronized => m_props.IsSynchronized;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> class.</summary>
		public EncryptionPropertyCollection()
		{
			m_props = new ArrayList();
		}

		/// <summary>Returns an enumerator that iterates through an <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through an <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</returns>
		public IEnumerator GetEnumerator()
		{
			return m_props.GetEnumerator();
		}

		/// <summary>Adds an item to the <see cref="T:System.Collections.IList" />.</summary>
		/// <param name="value">The <see cref="T:System.Object" /> to add to the <see cref="T:System.Collections.IList" />.</param>
		/// <returns>The position into which the new element was inserted.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="value" /> uses an incorrect object type.</exception>
		int IList.Add(object value)
		{
			if (!(value is EncryptionProperty))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "value");
			}
			return m_props.Add(value);
		}

		/// <summary>Adds an <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object to the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</summary>
		/// <param name="value">An <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object to add to the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</param>
		/// <returns>The position at which the new element is inserted.</returns>
		public int Add(EncryptionProperty value)
		{
			return m_props.Add(value);
		}

		/// <summary>Removes all items from the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</summary>
		public void Clear()
		{
			m_props.Clear();
		}

		/// <summary>Determines whether the <see cref="T:System.Collections.IList" /> contains a specific value.</summary>
		/// <param name="value">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.IList" />.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="T:System.Object" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="value" /> uses an incorrect object type.</exception>
		bool IList.Contains(object value)
		{
			if (!(value is EncryptionProperty))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "value");
			}
			return m_props.Contains(value);
		}

		/// <summary>Determines whether the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object contains a specific <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object.</summary>
		/// <param name="value">The <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object to locate in the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object is found in the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object; otherwise, <see langword="false" />.</returns>
		public bool Contains(EncryptionProperty value)
		{
			return m_props.Contains(value);
		}

		/// <summary>Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.</summary>
		/// <param name="value">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.IList" />.</param>
		/// <returns>The index of <paramref name="value" /> if found in the list; otherwise, -1.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="value" /> uses an incorrect object type.</exception>
		int IList.IndexOf(object value)
		{
			if (!(value is EncryptionProperty))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "value");
			}
			return m_props.IndexOf(value);
		}

		/// <summary>Determines the index of a specific item in the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</summary>
		/// <param name="value">The <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object to locate in the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</param>
		/// <returns>The index of <paramref name="value" /> if found in the collection; otherwise, -1.</returns>
		public int IndexOf(EncryptionProperty value)
		{
			return m_props.IndexOf(value);
		}

		/// <summary>Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.</summary>
		/// <param name="index">The zero-based index at which <paramref name="value" /> should be inserted.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to insert into the <see cref="T:System.Collections.IList" />.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="value" /> uses an incorrect object type.</exception>
		void IList.Insert(int index, object value)
		{
			if (!(value is EncryptionProperty))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "value");
			}
			m_props.Insert(index, value);
		}

		/// <summary>Inserts an <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object into the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object at the specified position.</summary>
		/// <param name="index">The zero-based index at which <paramref name="value" /> should be inserted.</param>
		/// <param name="value">An <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object to insert into the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</param>
		public void Insert(int index, EncryptionProperty value)
		{
			m_props.Insert(index, value);
		}

		/// <summary>Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.</summary>
		/// <param name="value">The <see cref="T:System.Object" /> to remove from the <see cref="T:System.Collections.IList" />.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="value" /> uses an incorrect object type.</exception>
		void IList.Remove(object value)
		{
			if (!(value is EncryptionProperty))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "value");
			}
			m_props.Remove(value);
		}

		/// <summary>Removes the first occurrence of a specific <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object from the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</summary>
		/// <param name="value">The <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object to remove from the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object.</param>
		public void Remove(EncryptionProperty value)
		{
			m_props.Remove(value);
		}

		/// <summary>Removes the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object at the specified index.</summary>
		/// <param name="index">The zero-based index of the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object to remove.</param>
		public void RemoveAt(int index)
		{
			m_props.RemoveAt(index);
		}

		/// <summary>Returns the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object at the specified index.</summary>
		/// <param name="index">The index of the <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object to return.</param>
		/// <returns>The <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> object at the specified index.</returns>
		public EncryptionProperty Item(int index)
		{
			return (EncryptionProperty)m_props[index];
		}

		/// <summary>Copies the elements of the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object to an array, starting at a particular array index.</summary>
		/// <param name="array">The one-dimensional <see cref="T:System.Array" /> object that is the destination of the elements copied from the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object. The array must have zero-based indexing.</param>
		/// <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
		public void CopyTo(Array array, int index)
		{
			m_props.CopyTo(array, index);
		}

		/// <summary>Copies the elements of the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object to an array of <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> objects, starting at a particular array index.</summary>
		/// <param name="array">The one-dimensional array of  <see cref="T:System.Security.Cryptography.Xml.EncryptionProperty" /> objects that is the destination of the elements copied from the <see cref="T:System.Security.Cryptography.Xml.EncryptionPropertyCollection" /> object. The array must have zero-based indexing.</param>
		/// <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
		public void CopyTo(EncryptionProperty[] array, int index)
		{
			m_props.CopyTo(array, index);
		}
	}
	[Serializable]
	internal class CryptoSignedXmlRecursionException : XmlException
	{
		public CryptoSignedXmlRecursionException()
		{
		}

		public CryptoSignedXmlRecursionException(string message)
			: base(message)
		{
		}

		public CryptoSignedXmlRecursionException(string message, Exception inner)
			: base(message, inner)
		{
		}

		protected CryptoSignedXmlRecursionException(SerializationInfo info, StreamingContext context)
		{
		}
	}
	/// <summary>Represents the process model for implementing XML encryption.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EncryptedXml
	{
		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for XML encryption syntax and processing. This field is constant.</summary>
		public const string XmlEncNamespaceUrl = "http://www.w3.org/2001/04/xmlenc#";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for an XML encryption element. This field is constant.</summary>
		public const string XmlEncElementUrl = "http://www.w3.org/2001/04/xmlenc#Element";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for XML encryption element content. This field is constant.</summary>
		public const string XmlEncElementContentUrl = "http://www.w3.org/2001/04/xmlenc#Content";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the XML encryption <see langword="&lt;EncryptedKey&gt;" /> element. This field is constant.</summary>
		public const string XmlEncEncryptedKeyUrl = "http://www.w3.org/2001/04/xmlenc#EncryptedKey";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the Digital Encryption Standard (DES) algorithm. This field is constant.</summary>
		public const string XmlEncDESUrl = "http://www.w3.org/2001/04/xmlenc#des-cbc";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the Triple DES algorithm. This field is constant.</summary>
		public const string XmlEncTripleDESUrl = "http://www.w3.org/2001/04/xmlenc#tripledes-cbc";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the 128-bit Advanced Encryption Standard (AES) algorithm (also known as the Rijndael algorithm). This field is constant.</summary>
		public const string XmlEncAES128Url = "http://www.w3.org/2001/04/xmlenc#aes128-cbc";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the 256-bit Advanced Encryption Standard (AES) algorithm (also known as the Rijndael algorithm). This field is constant.</summary>
		public const string XmlEncAES256Url = "http://www.w3.org/2001/04/xmlenc#aes256-cbc";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the 192-bit Advanced Encryption Standard (AES) algorithm (also known as the Rijndael algorithm). This field is constant.</summary>
		public const string XmlEncAES192Url = "http://www.w3.org/2001/04/xmlenc#aes192-cbc";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the RSA Public Key Cryptography Standard (PKCS) Version 1.5 algorithm. This field is constant.</summary>
		public const string XmlEncRSA15Url = "http://www.w3.org/2001/04/xmlenc#rsa-1_5";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the RSA Optimal Asymmetric Encryption Padding (OAEP) encryption algorithm. This field is constant.</summary>
		public const string XmlEncRSAOAEPUrl = "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the TRIPLEDES key wrap algorithm. This field is constant.</summary>
		public const string XmlEncTripleDESKeyWrapUrl = "http://www.w3.org/2001/04/xmlenc#kw-tripledes";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the 128-bit Advanced Encryption Standard (AES) Key Wrap algorithm (also known as the Rijndael Key Wrap algorithm). This field is constant.</summary>
		public const string XmlEncAES128KeyWrapUrl = "http://www.w3.org/2001/04/xmlenc#kw-aes128";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the 256-bit Advanced Encryption Standard (AES) Key Wrap algorithm (also known as the Rijndael Key Wrap algorithm). This field is constant.</summary>
		public const string XmlEncAES256KeyWrapUrl = "http://www.w3.org/2001/04/xmlenc#kw-aes256";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the 192-bit Advanced Encryption Standard (AES) Key Wrap algorithm (also known as the Rijndael Key Wrap algorithm). This field is constant.</summary>
		public const string XmlEncAES192KeyWrapUrl = "http://www.w3.org/2001/04/xmlenc#kw-aes192";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the SHA-256 algorithm. This field is constant.</summary>
		public const string XmlEncSHA256Url = "http://www.w3.org/2001/04/xmlenc#sha256";

		/// <summary>Represents the namespace Uniform Resource Identifier (URI) for the SHA-512 algorithm. This field is constant.</summary>
		public const string XmlEncSHA512Url = "http://www.w3.org/2001/04/xmlenc#sha512";

		private XmlDocument m_document;

		private Evidence m_evidence;

		private XmlResolver m_xmlResolver;

		private const int m_capacity = 4;

		private Hashtable m_keyNameMapping;

		private PaddingMode m_padding;

		private CipherMode m_mode;

		private Encoding m_encoding;

		private string m_recipient;

		private int m_xmlDsigSearchDepthCounter;

		private int m_xmlDsigSearchDepth;

		/// <summary>Gets or sets the XML digital signature recursion depth to prevent infinite recursion and stack overflow. This might happen if the digital signature XML contains the URI which then points back to the original XML.</summary>
		/// <returns>Returns <see cref="T:System.Int32" />.</returns>
		public int XmlDSigSearchDepth
		{
			get
			{
				return m_xmlDsigSearchDepth;
			}
			set
			{
				m_xmlDsigSearchDepth = value;
			}
		}

		/// <summary>Gets or sets the evidence of the <see cref="T:System.Xml.XmlDocument" /> object from which the <see cref="T:System.Security.Cryptography.Xml.EncryptedXml" /> object is constructed.</summary>
		/// <returns>An <see cref="T:System.Security.Policy.Evidence" /> object.</returns>
		public Evidence DocumentEvidence
		{
			get
			{
				return m_evidence;
			}
			set
			{
				m_evidence = value;
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Xml.XmlResolver" /> object used by the Document Object Model (DOM) to resolve external XML references.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlResolver" /> object.</returns>
		public XmlResolver Resolver
		{
			get
			{
				return m_xmlResolver;
			}
			set
			{
				m_xmlResolver = value;
			}
		}

		/// <summary>Gets or sets the padding mode used for XML encryption.</summary>
		/// <returns>One of the <see cref="T:System.Security.Cryptography.PaddingMode" /> values that specifies the type of padding used for encryption.</returns>
		public PaddingMode Padding
		{
			get
			{
				return m_padding;
			}
			set
			{
				m_padding = value;
			}
		}

		/// <summary>Gets or sets the cipher mode used for XML encryption.</summary>
		/// <returns>One of the <see cref="T:System.Security.Cryptography.CipherMode" /> values.</returns>
		public CipherMode Mode
		{
			get
			{
				return m_mode;
			}
			set
			{
				m_mode = value;
			}
		}

		/// <summary>Gets or sets the encoding used for XML encryption.</summary>
		/// <returns>An <see cref="T:System.Text.Encoding" /> object.</returns>
		public Encoding Encoding
		{
			get
			{
				return m_encoding;
			}
			set
			{
				m_encoding = value;
			}
		}

		/// <summary>Gets or sets the recipient of the encrypted key information.</summary>
		/// <returns>The recipient of the encrypted key information.</returns>
		public string Recipient
		{
			get
			{
				if (m_recipient == null)
				{
					m_recipient = string.Empty;
				}
				return m_recipient;
			}
			set
			{
				m_recipient = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptedXml" /> class.</summary>
		public EncryptedXml()
			: this(new XmlDocument())
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptedXml" /> class using the specified XML document.</summary>
		/// <param name="document">An <see cref="T:System.Xml.XmlDocument" /> object used to initialize the <see cref="T:System.Security.Cryptography.Xml.EncryptedXml" /> object.</param>
		public EncryptedXml(XmlDocument document)
			: this(document, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.EncryptedXml" /> class using the specified XML document and evidence.</summary>
		/// <param name="document">An <see cref="T:System.Xml.XmlDocument" /> object used to initialize the <see cref="T:System.Security.Cryptography.Xml.EncryptedXml" /> object.</param>
		/// <param name="evidence">An <see cref="T:System.Security.Policy.Evidence" /> object associated with the <see cref="T:System.Xml.XmlDocument" /> object.</param>
		public EncryptedXml(XmlDocument document, Evidence evidence)
		{
			m_document = document;
			m_evidence = evidence;
			m_xmlResolver = null;
			m_padding = PaddingMode.ISO10126;
			m_mode = CipherMode.CBC;
			m_encoding = Encoding.UTF8;
			m_keyNameMapping = new Hashtable(4);
			m_xmlDsigSearchDepth = Utils.GetXmlDsigSearchDepth();
		}

		private bool IsOverXmlDsigRecursionLimit()
		{
			if (m_xmlDsigSearchDepthCounter > XmlDSigSearchDepth)
			{
				return true;
			}
			return false;
		}

		private byte[] GetCipherValue(CipherData cipherData)
		{
			if (cipherData == null)
			{
				throw new ArgumentNullException("cipherData");
			}
			WebResponse response = null;
			Stream inputStream = null;
			if (cipherData.CipherValue != null)
			{
				return cipherData.CipherValue;
			}
			if (cipherData.CipherReference != null)
			{
				if (cipherData.CipherReference.CipherValue != null)
				{
					return cipherData.CipherReference.CipherValue;
				}
				Stream decInputStream = null;
				if (!Utils.GetLeaveCipherValueUnchecked() && cipherData.CipherReference.Uri == null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriNotSupported"));
				}
				if (cipherData.CipherReference.Uri.Length == 0)
				{
					string baseUri = ((m_document == null) ? null : m_document.BaseURI);
					TransformChain transformChain = cipherData.CipherReference.TransformChain;
					if (!Utils.GetLeaveCipherValueUnchecked() && transformChain == null)
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriNotSupported"));
					}
					decInputStream = transformChain.TransformToOctetStream(m_document, m_xmlResolver, baseUri);
				}
				else if (cipherData.CipherReference.Uri[0] == '#')
				{
					string idValue = Utils.ExtractIdFromLocalUri(cipherData.CipherReference.Uri);
					if (Utils.GetLeaveCipherValueUnchecked())
					{
						inputStream = new MemoryStream(m_encoding.GetBytes(GetIdElement(m_document, idValue).OuterXml));
					}
					else
					{
						XmlElement idElement = GetIdElement(m_document, idValue);
						if (idElement == null || idElement.OuterXml == null)
						{
							throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriNotSupported"));
						}
						inputStream = new MemoryStream(m_encoding.GetBytes(idElement.OuterXml));
					}
					string baseUri2 = ((m_document == null) ? null : m_document.BaseURI);
					TransformChain transformChain2 = cipherData.CipherReference.TransformChain;
					if (!Utils.GetLeaveCipherValueUnchecked() && transformChain2 == null)
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriNotSupported"));
					}
					decInputStream = transformChain2.TransformToOctetStream(inputStream, m_xmlResolver, baseUri2);
				}
				else
				{
					DownloadCipherValue(cipherData, out inputStream, out decInputStream, out response);
				}
				byte[] array = null;
				using (MemoryStream memoryStream = new MemoryStream())
				{
					Utils.Pump(decInputStream, memoryStream);
					array = memoryStream.ToArray();
					response?.Close();
					inputStream?.Close();
					decInputStream.Close();
				}
				cipherData.CipherReference.CipherValue = array;
				return array;
			}
			throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingCipherData"));
		}

		private void DownloadCipherValue(CipherData cipherData, out Stream inputStream, out Stream decInputStream, out WebResponse response)
		{
			PermissionSet standardSandbox = SecurityManager.GetStandardSandbox(m_evidence);
			standardSandbox.PermitOnly();
			WebRequest webRequest = WebRequest.Create(cipherData.CipherReference.Uri);
			if (webRequest == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriNotResolved"), cipherData.CipherReference.Uri);
			}
			response = webRequest.GetResponse();
			if (response == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriNotResolved"), cipherData.CipherReference.Uri);
			}
			inputStream = response.GetResponseStream();
			if (inputStream == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriNotResolved"), cipherData.CipherReference.Uri);
			}
			TransformChain transformChain = cipherData.CipherReference.TransformChain;
			decInputStream = transformChain.TransformToOctetStream(inputStream, m_xmlResolver, cipherData.CipherReference.Uri);
		}

		/// <summary>Determines how to resolve internal Uniform Resource Identifier (URI) references.</summary>
		/// <param name="document">An <see cref="T:System.Xml.XmlDocument" /> object that contains an element with an ID value.</param>
		/// <param name="idValue">A string that represents the ID value.</param>
		/// <returns>An <see cref="T:System.Xml.XmlElement" /> object that contains an ID indicating how internal Uniform Resource Identifiers (URIs) are to be resolved.</returns>
		public virtual XmlElement GetIdElement(XmlDocument document, string idValue)
		{
			return SignedXml.DefaultGetIdElement(document, idValue);
		}

		/// <summary>Retrieves the decryption initialization vector (IV) from an <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> object.</summary>
		/// <param name="encryptedData">The <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> object that contains the initialization vector (IV) to retrieve.</param>
		/// <param name="symmetricAlgorithmUri">The Uniform Resource Identifier (URI) that describes the cryptographic algorithm associated with the <paramref name="encryptedData" /> value.</param>
		/// <returns>A byte array that contains the decryption initialization vector (IV).</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="encryptedData" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The value of the <paramref name="encryptedData" /> parameter has an <see cref="P:System.Security.Cryptography.Xml.EncryptedType.EncryptionMethod" /> property that is null.  
		///  -or-  
		///  The value of the <paramref name="symmetricAlgorithmUrisymAlgUri" /> parameter is not a supported algorithm.</exception>
		public virtual byte[] GetDecryptionIV(EncryptedData encryptedData, string symmetricAlgorithmUri)
		{
			if (encryptedData == null)
			{
				throw new ArgumentNullException("encryptedData");
			}
			int num = 0;
			if (symmetricAlgorithmUri == null)
			{
				if (encryptedData.EncryptionMethod == null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingAlgorithm"));
				}
				symmetricAlgorithmUri = encryptedData.EncryptionMethod.KeyAlgorithm;
			}
			switch (symmetricAlgorithmUri)
			{
			case "http://www.w3.org/2001/04/xmlenc#des-cbc":
			case "http://www.w3.org/2001/04/xmlenc#tripledes-cbc":
				num = 8;
				break;
			case "http://www.w3.org/2001/04/xmlenc#aes128-cbc":
			case "http://www.w3.org/2001/04/xmlenc#aes192-cbc":
			case "http://www.w3.org/2001/04/xmlenc#aes256-cbc":
				num = 16;
				break;
			default:
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriNotSupported"));
			}
			byte[] array = new byte[num];
			byte[] cipherValue = GetCipherValue(encryptedData.CipherData);
			Buffer.BlockCopy(cipherValue, 0, array, 0, array.Length);
			return array;
		}

		/// <summary>Retrieves the decryption key from the specified <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> object.</summary>
		/// <param name="encryptedData">The <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> object that contains the decryption key to retrieve.</param>
		/// <param name="symmetricAlgorithmUri">The size of the decryption key to retrieve.</param>
		/// <returns>A <see cref="T:System.Security.Cryptography.SymmetricAlgorithm" /> object associated with the decryption key.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="encryptedData" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The encryptedData parameter has an <see cref="P:System.Security.Cryptography.Xml.EncryptedType.EncryptionMethod" /> property that is null.  
		///  -or-  
		///  The encrypted key cannot be retrieved using the specified parameters.</exception>
		public virtual SymmetricAlgorithm GetDecryptionKey(EncryptedData encryptedData, string symmetricAlgorithmUri)
		{
			if (encryptedData == null)
			{
				throw new ArgumentNullException("encryptedData");
			}
			if (encryptedData.KeyInfo == null)
			{
				return null;
			}
			IEnumerator enumerator = encryptedData.KeyInfo.GetEnumerator();
			EncryptedKey encryptedKey = null;
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is KeyInfoName keyInfoName)
				{
					string value = keyInfoName.Value;
					if ((SymmetricAlgorithm)m_keyNameMapping[value] != null)
					{
						return (SymmetricAlgorithm)m_keyNameMapping[value];
					}
					XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(m_document.NameTable);
					xmlNamespaceManager.AddNamespace("enc", "http://www.w3.org/2001/04/xmlenc#");
					XmlNodeList xmlNodeList = m_document.SelectNodes("//enc:EncryptedKey", xmlNamespaceManager);
					if (xmlNodeList == null)
					{
						break;
					}
					foreach (XmlNode item in xmlNodeList)
					{
						XmlElement value2 = item as XmlElement;
						EncryptedKey encryptedKey2 = new EncryptedKey();
						encryptedKey2.LoadXml(value2);
						if (encryptedKey2.CarriedKeyName == value && encryptedKey2.Recipient == Recipient)
						{
							encryptedKey = encryptedKey2;
							break;
						}
					}
					break;
				}
				if (enumerator.Current is KeyInfoRetrievalMethod keyInfoRetrievalMethod)
				{
					string idValue = Utils.ExtractIdFromLocalUri(keyInfoRetrievalMethod.Uri);
					encryptedKey = new EncryptedKey();
					encryptedKey.LoadXml(GetIdElement(m_document, idValue));
					break;
				}
				if (enumerator.Current is KeyInfoEncryptedKey keyInfoEncryptedKey)
				{
					encryptedKey = keyInfoEncryptedKey.EncryptedKey;
					break;
				}
			}
			if (encryptedKey != null)
			{
				if (symmetricAlgorithmUri == null)
				{
					if (encryptedData.EncryptionMethod == null)
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingAlgorithm"));
					}
					symmetricAlgorithmUri = encryptedData.EncryptionMethod.KeyAlgorithm;
				}
				byte[] array = DecryptEncryptedKey(encryptedKey);
				if (array == null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingDecryptionKey"));
				}
				SymmetricAlgorithm symmetricAlgorithm = Utils.CreateFromName<SymmetricAlgorithm>(symmetricAlgorithmUri);
				if (symmetricAlgorithm == null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingAlgorithm"));
				}
				symmetricAlgorithm.Key = array;
				return symmetricAlgorithm;
			}
			return null;
		}

		/// <summary>Determines the key represented by the <see cref="T:System.Security.Cryptography.Xml.EncryptedKey" /> element.</summary>
		/// <param name="encryptedKey">The <see cref="T:System.Security.Cryptography.Xml.EncryptedKey" /> object that contains the key to retrieve.</param>
		/// <returns>A byte array that contains the key.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="encryptedKey" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The value of the <paramref name="encryptedKey" /> parameter is not the Triple DES Key Wrap algorithm or the Advanced Encryption Standard (AES) Key Wrap algorithm (also called Rijndael).</exception>
		public virtual byte[] DecryptEncryptedKey(EncryptedKey encryptedKey)
		{
			if (encryptedKey == null)
			{
				throw new ArgumentNullException("encryptedKey");
			}
			if (encryptedKey.KeyInfo == null)
			{
				return null;
			}
			IEnumerator enumerator = encryptedKey.KeyInfo.GetEnumerator();
			EncryptedKey encryptedKey2 = null;
			bool flag = false;
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is KeyInfoName keyInfoName)
				{
					string value = keyInfoName.Value;
					object obj = m_keyNameMapping[value];
					if (obj == null)
					{
						break;
					}
					if (!Utils.GetLeaveCipherValueUnchecked() && (encryptedKey.CipherData == null || encryptedKey.CipherData.CipherValue == null))
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingAlgorithm"));
					}
					if (obj is SymmetricAlgorithm)
					{
						return DecryptKey(encryptedKey.CipherData.CipherValue, (SymmetricAlgorithm)obj);
					}
					flag = encryptedKey.EncryptionMethod != null && encryptedKey.EncryptionMethod.KeyAlgorithm == "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p";
					return DecryptKey(encryptedKey.CipherData.CipherValue, (RSA)obj, flag);
				}
				if (enumerator.Current is KeyInfoX509Data keyInfoX509Data)
				{
					X509Certificate2Collection x509Certificate2Collection = Utils.BuildBagOfCerts(keyInfoX509Data, CertUsageType.Decryption);
					X509Certificate2Enumerator enumerator2 = x509Certificate2Collection.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						X509Certificate2 current = enumerator2.Current;
						using RSA rSA = current.GetRSAPrivateKey();
						if (rSA != null)
						{
							if (!Utils.GetLeaveCipherValueUnchecked() && (encryptedKey.CipherData == null || encryptedKey.CipherData.CipherValue == null))
							{
								throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingAlgorithm"));
							}
							flag = encryptedKey.EncryptionMethod != null && encryptedKey.EncryptionMethod.KeyAlgorithm == "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p";
							return DecryptKey(encryptedKey.CipherData.CipherValue, rSA, flag);
						}
					}
					break;
				}
				if (enumerator.Current is KeyInfoRetrievalMethod keyInfoRetrievalMethod)
				{
					string idValue = Utils.ExtractIdFromLocalUri(keyInfoRetrievalMethod.Uri);
					encryptedKey2 = new EncryptedKey();
					encryptedKey2.LoadXml(GetIdElement(m_document, idValue));
					try
					{
						m_xmlDsigSearchDepthCounter++;
						if (IsOverXmlDsigRecursionLimit())
						{
							throw new CryptoSignedXmlRecursionException();
						}
						return DecryptEncryptedKey(encryptedKey2);
					}
					finally
					{
						m_xmlDsigSearchDepthCounter--;
					}
				}
				if (!(enumerator.Current is KeyInfoEncryptedKey keyInfoEncryptedKey))
				{
					continue;
				}
				encryptedKey2 = keyInfoEncryptedKey.EncryptedKey;
				byte[] array = DecryptEncryptedKey(encryptedKey2);
				if (array != null)
				{
					SymmetricAlgorithm symmetricAlgorithm = Utils.CreateFromName<SymmetricAlgorithm>(encryptedKey.EncryptionMethod.KeyAlgorithm);
					if (symmetricAlgorithm == null)
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingAlgorithm"));
					}
					symmetricAlgorithm.Key = array;
					if (!Utils.GetLeaveCipherValueUnchecked() && (encryptedKey.CipherData == null || encryptedKey.CipherData.CipherValue == null))
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingAlgorithm"));
					}
					return DecryptKey(encryptedKey.CipherData.CipherValue, symmetricAlgorithm);
				}
			}
			return null;
		}

		/// <summary>Defines a mapping between a key name and a symmetric key or an asymmetric key.</summary>
		/// <param name="keyName">The name to map to <paramref name="keyObject" />.</param>
		/// <param name="keyObject">The symmetric key to map to <paramref name="keyName" />.</param>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="keyName" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="keyObject" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The value of the <paramref name="keyObject" /> parameter is not an RSA algorithm or a symmetric key.</exception>
		public void AddKeyNameMapping(string keyName, object keyObject)
		{
			if (keyName == null)
			{
				throw new ArgumentNullException("keyName");
			}
			if (keyObject == null)
			{
				throw new ArgumentNullException("keyObject");
			}
			if (!(keyObject is SymmetricAlgorithm) && !(keyObject is RSA))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_NotSupportedCryptographicTransform"));
			}
			m_keyNameMapping.Add(keyName, keyObject);
		}

		/// <summary>Resets all key name mapping.</summary>
		public void ClearKeyNameMappings()
		{
			m_keyNameMapping.Clear();
		}

		/// <summary>Encrypts the outer XML of an element using the specified X.509 certificate.</summary>
		/// <param name="inputElement">The XML element to encrypt.</param>
		/// <param name="certificate">The X.509 certificate to use for encryption.</param>
		/// <returns>An <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> element that represents the encrypted XML data.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="inputElement" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="certificate" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.NotSupportedException">The value of the <paramref name="certificate" /> parameter does not represent an RSA key algorithm.</exception>
		public EncryptedData Encrypt(XmlElement inputElement, X509Certificate2 certificate)
		{
			if (inputElement == null)
			{
				throw new ArgumentNullException("inputElement");
			}
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			using RSA rSA = certificate.GetRSAPublicKey();
			if (rSA == null)
			{
				throw new NotSupportedException(SecurityResources.GetResourceString("NotSupported_KeyAlgorithm"));
			}
			EncryptedData encryptedData = new EncryptedData();
			encryptedData.Type = "http://www.w3.org/2001/04/xmlenc#Element";
			encryptedData.EncryptionMethod = new EncryptionMethod("http://www.w3.org/2001/04/xmlenc#aes256-cbc");
			EncryptedKey encryptedKey = new EncryptedKey();
			encryptedKey.EncryptionMethod = new EncryptionMethod("http://www.w3.org/2001/04/xmlenc#rsa-1_5");
			encryptedKey.KeyInfo.AddClause(new KeyInfoX509Data(certificate));
			using (Aes aes = Aes.Create())
			{
				encryptedKey.CipherData.CipherValue = EncryptKey(aes.Key, rSA, useOAEP: false);
				KeyInfoEncryptedKey clause = new KeyInfoEncryptedKey(encryptedKey);
				encryptedData.KeyInfo.AddClause(clause);
				encryptedData.CipherData.CipherValue = EncryptData(inputElement, aes, content: false);
			}
			return encryptedData;
		}

		/// <summary>Encrypts the outer XML of an element using the specified key in the key mapping table.</summary>
		/// <param name="inputElement">The XML element to encrypt.</param>
		/// <param name="keyName">A key name that can be found in the key mapping table.</param>
		/// <returns>An <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> object that represents the encrypted XML data.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="inputElement" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="keyName" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The value of the <paramref name="keyName" /> parameter does not match a registered key name pair.  
		///  -or-  
		///  The cryptographic key described by the <paramref name="keyName" /> parameter is not supported.</exception>
		public EncryptedData Encrypt(XmlElement inputElement, string keyName)
		{
			if (inputElement == null)
			{
				throw new ArgumentNullException("inputElement");
			}
			if (keyName == null)
			{
				throw new ArgumentNullException("keyName");
			}
			object obj = null;
			if (m_keyNameMapping != null)
			{
				obj = m_keyNameMapping[keyName];
			}
			if (obj == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingEncryptionKey"));
			}
			SymmetricAlgorithm symmetricAlgorithm = obj as SymmetricAlgorithm;
			RSA rsa = obj as RSA;
			EncryptedData encryptedData = new EncryptedData();
			encryptedData.Type = "http://www.w3.org/2001/04/xmlenc#Element";
			encryptedData.EncryptionMethod = new EncryptionMethod("http://www.w3.org/2001/04/xmlenc#aes256-cbc");
			string algorithm = null;
			if (symmetricAlgorithm == null)
			{
				algorithm = "http://www.w3.org/2001/04/xmlenc#rsa-1_5";
			}
			else if (symmetricAlgorithm is TripleDES)
			{
				algorithm = "http://www.w3.org/2001/04/xmlenc#kw-tripledes";
			}
			else
			{
				if (!(symmetricAlgorithm is Rijndael) && !(symmetricAlgorithm is Aes))
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_NotSupportedCryptographicTransform"));
				}
				switch (symmetricAlgorithm.KeySize)
				{
				case 128:
					algorithm = "http://www.w3.org/2001/04/xmlenc#kw-aes128";
					break;
				case 192:
					algorithm = "http://www.w3.org/2001/04/xmlenc#kw-aes192";
					break;
				case 256:
					algorithm = "http://www.w3.org/2001/04/xmlenc#kw-aes256";
					break;
				}
			}
			EncryptedKey encryptedKey = new EncryptedKey();
			encryptedKey.EncryptionMethod = new EncryptionMethod(algorithm);
			encryptedKey.KeyInfo.AddClause(new KeyInfoName(keyName));
			using Aes aes = Aes.Create();
			encryptedKey.CipherData.CipherValue = ((symmetricAlgorithm == null) ? EncryptKey(aes.Key, rsa, useOAEP: false) : EncryptKey(aes.Key, symmetricAlgorithm));
			KeyInfoEncryptedKey clause = new KeyInfoEncryptedKey(encryptedKey);
			encryptedData.KeyInfo.AddClause(clause);
			encryptedData.CipherData.CipherValue = EncryptData(inputElement, aes, content: false);
			return encryptedData;
		}

		/// <summary>Decrypts all <see langword="&lt;EncryptedData&gt;" /> elements of the XML document that were specified during initialization of the <see cref="T:System.Security.Cryptography.Xml.EncryptedXml" /> class.</summary>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The cryptographic key used to decrypt the document was not found.</exception>
		public void DecryptDocument()
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(m_document.NameTable);
			xmlNamespaceManager.AddNamespace("enc", "http://www.w3.org/2001/04/xmlenc#");
			XmlNodeList xmlNodeList = m_document.SelectNodes("//enc:EncryptedData", xmlNamespaceManager);
			if (xmlNodeList == null)
			{
				return;
			}
			foreach (XmlNode item in xmlNodeList)
			{
				XmlElement xmlElement = item as XmlElement;
				EncryptedData encryptedData = new EncryptedData();
				encryptedData.LoadXml(xmlElement);
				SymmetricAlgorithm decryptionKey = GetDecryptionKey(encryptedData, null);
				if (decryptionKey == null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingDecryptionKey"));
				}
				byte[] decryptedData = DecryptData(encryptedData, decryptionKey);
				ReplaceData(xmlElement, decryptedData);
			}
		}

		/// <summary>Encrypts data in the specified byte array using the specified symmetric algorithm.</summary>
		/// <param name="plaintext">The data to encrypt.</param>
		/// <param name="symmetricAlgorithm">The symmetric algorithm to use for encryption.</param>
		/// <returns>A byte array of encrypted data.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="plaintext" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="symmetricAlgorithm" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The data could not be encrypted using the specified parameters.</exception>
		public byte[] EncryptData(byte[] plaintext, SymmetricAlgorithm symmetricAlgorithm)
		{
			if (plaintext == null)
			{
				throw new ArgumentNullException("plaintext");
			}
			if (symmetricAlgorithm == null)
			{
				throw new ArgumentNullException("symmetricAlgorithm");
			}
			CipherMode mode = symmetricAlgorithm.Mode;
			PaddingMode padding = symmetricAlgorithm.Padding;
			byte[] array = null;
			try
			{
				symmetricAlgorithm.Mode = m_mode;
				symmetricAlgorithm.Padding = m_padding;
				ICryptoTransform cryptoTransform = symmetricAlgorithm.CreateEncryptor();
				array = cryptoTransform.TransformFinalBlock(plaintext, 0, plaintext.Length);
			}
			finally
			{
				symmetricAlgorithm.Mode = mode;
				symmetricAlgorithm.Padding = padding;
			}
			byte[] array2 = null;
			if (m_mode == CipherMode.ECB)
			{
				array2 = array;
			}
			else
			{
				byte[] iV = symmetricAlgorithm.IV;
				array2 = new byte[array.Length + iV.Length];
				Buffer.BlockCopy(iV, 0, array2, 0, iV.Length);
				Buffer.BlockCopy(array, 0, array2, iV.Length, array.Length);
			}
			return array2;
		}

		/// <summary>Encrypts the specified element or its contents using the specified symmetric algorithm.</summary>
		/// <param name="inputElement">The element or its contents to encrypt.</param>
		/// <param name="symmetricAlgorithm">The symmetric algorithm to use for encryption.</param>
		/// <param name="content">
		///   <see langword="true" /> to encrypt only the contents of the element; <see langword="false" /> to encrypt the entire element.</param>
		/// <returns>A byte array that contains the encrypted data.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="inputElement" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="symmetricAlgorithm" /> parameter is <see langword="null" />.</exception>
		public byte[] EncryptData(XmlElement inputElement, SymmetricAlgorithm symmetricAlgorithm, bool content)
		{
			if (inputElement == null)
			{
				throw new ArgumentNullException("inputElement");
			}
			if (symmetricAlgorithm == null)
			{
				throw new ArgumentNullException("symmetricAlgorithm");
			}
			byte[] plaintext = (content ? m_encoding.GetBytes(inputElement.InnerXml) : m_encoding.GetBytes(inputElement.OuterXml));
			return EncryptData(plaintext, symmetricAlgorithm);
		}

		/// <summary>Decrypts an <see langword="&lt;EncryptedData&gt;" /> element using the specified symmetric algorithm.</summary>
		/// <param name="encryptedData">The data to decrypt.</param>
		/// <param name="symmetricAlgorithm">The symmetric key used to decrypt <paramref name="encryptedData" />.</param>
		/// <returns>A byte array that contains the raw decrypted plain text.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="encryptedData" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="symmetricAlgorithm" /> parameter is <see langword="null" />.</exception>
		public byte[] DecryptData(EncryptedData encryptedData, SymmetricAlgorithm symmetricAlgorithm)
		{
			if (encryptedData == null)
			{
				throw new ArgumentNullException("encryptedData");
			}
			if (symmetricAlgorithm == null)
			{
				throw new ArgumentNullException("symmetricAlgorithm");
			}
			byte[] cipherValue = GetCipherValue(encryptedData.CipherData);
			CipherMode mode = symmetricAlgorithm.Mode;
			PaddingMode padding = symmetricAlgorithm.Padding;
			byte[] iV = symmetricAlgorithm.IV;
			byte[] array = null;
			if (m_mode != CipherMode.ECB)
			{
				array = GetDecryptionIV(encryptedData, null);
			}
			byte[] array2 = null;
			try
			{
				int num = 0;
				if (array != null)
				{
					symmetricAlgorithm.IV = array;
					num = array.Length;
				}
				symmetricAlgorithm.Mode = m_mode;
				symmetricAlgorithm.Padding = m_padding;
				ICryptoTransform cryptoTransform = symmetricAlgorithm.CreateDecryptor();
				return cryptoTransform.TransformFinalBlock(cipherValue, num, cipherValue.Length - num);
			}
			finally
			{
				symmetricAlgorithm.Mode = mode;
				symmetricAlgorithm.Padding = padding;
				symmetricAlgorithm.IV = iV;
			}
		}

		/// <summary>Replaces an <see langword="&lt;EncryptedData&gt;" /> element with a specified decrypted sequence of bytes.</summary>
		/// <param name="inputElement">The <see langword="&lt;EncryptedData&gt;" /> element to replace.</param>
		/// <param name="decryptedData">The decrypted data to replace <paramref name="inputElement" /> with.</param>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="inputElement" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="decryptedData" /> parameter is <see langword="null" />.</exception>
		public void ReplaceData(XmlElement inputElement, byte[] decryptedData)
		{
			if (inputElement == null)
			{
				throw new ArgumentNullException("inputElement");
			}
			if (decryptedData == null)
			{
				throw new ArgumentNullException("decryptedData");
			}
			XmlNode parentNode = inputElement.ParentNode;
			if (parentNode.NodeType == XmlNodeType.Document)
			{
				XmlDocument xmlDocument = new XmlDocument();
				xmlDocument.PreserveWhitespace = true;
				string @string = m_encoding.GetString(decryptedData);
				using (StringReader input = new StringReader(@string))
				{
					using XmlReader reader = XmlReader.Create(input, Utils.GetSecureXmlReaderSettings(m_xmlResolver));
					xmlDocument.Load(reader);
				}
				XmlNode newChild = inputElement.OwnerDocument.ImportNode(xmlDocument.DocumentElement, deep: true);
				parentNode.RemoveChild(inputElement);
				parentNode.AppendChild(newChild);
				return;
			}
			XmlNode xmlNode = parentNode.OwnerDocument.CreateElement(parentNode.Prefix, parentNode.LocalName, parentNode.NamespaceURI);
			try
			{
				parentNode.AppendChild(xmlNode);
				xmlNode.InnerXml = m_encoding.GetString(decryptedData);
				XmlNode xmlNode2 = xmlNode.FirstChild;
				XmlNode nextSibling = inputElement.NextSibling;
				XmlNode xmlNode3 = null;
				while (xmlNode2 != null)
				{
					xmlNode3 = xmlNode2.NextSibling;
					parentNode.InsertBefore(xmlNode2, nextSibling);
					xmlNode2 = xmlNode3;
				}
			}
			finally
			{
				parentNode.RemoveChild(xmlNode);
			}
			parentNode.RemoveChild(inputElement);
		}

		/// <summary>Replaces the specified element with the specified <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> object.</summary>
		/// <param name="inputElement">The element to replace with an <see langword="&lt;EncryptedData&gt;" /> element.</param>
		/// <param name="encryptedData">The <see cref="T:System.Security.Cryptography.Xml.EncryptedData" /> object to replace the <paramref name="inputElement" /> parameter with.</param>
		/// <param name="content">
		///   <see langword="true" /> to replace only the contents of the element; <see langword="false" /> to replace the entire element.</param>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="inputElement" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="encryptedData" /> parameter is <see langword="null" />.</exception>
		public static void ReplaceElement(XmlElement inputElement, EncryptedData encryptedData, bool content)
		{
			if (inputElement == null)
			{
				throw new ArgumentNullException("inputElement");
			}
			if (encryptedData == null)
			{
				throw new ArgumentNullException("encryptedData");
			}
			XmlElement xml = encryptedData.GetXml(inputElement.OwnerDocument);
			if (content)
			{
				Utils.RemoveAllChildren(inputElement);
				inputElement.AppendChild(xml);
			}
			else
			{
				XmlNode parentNode = inputElement.ParentNode;
				parentNode.ReplaceChild(xml, inputElement);
			}
		}

		/// <summary>Encrypts a key using a symmetric algorithm that a recipient uses to decrypt an <see langword="&lt;EncryptedData&gt;" /> element.</summary>
		/// <param name="keyData">The key to encrypt.</param>
		/// <param name="symmetricAlgorithm">The symmetric key used to encrypt <paramref name="keyData" />.</param>
		/// <returns>A byte array that represents the encrypted value of the <paramref name="keyData" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="keyData" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="symmetricAlgorithm" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The value of the <paramref name="symmetricAlgorithm" /> parameter is not the Triple DES Key Wrap algorithm or the Advanced Encryption Standard (AES) Key Wrap algorithm (also called Rijndael).</exception>
		public static byte[] EncryptKey(byte[] keyData, SymmetricAlgorithm symmetricAlgorithm)
		{
			if (keyData == null)
			{
				throw new ArgumentNullException("keyData");
			}
			if (symmetricAlgorithm == null)
			{
				throw new ArgumentNullException("symmetricAlgorithm");
			}
			if (symmetricAlgorithm is TripleDES)
			{
				return SymmetricKeyWrap.TripleDESKeyWrapEncrypt(symmetricAlgorithm.Key, keyData);
			}
			if (symmetricAlgorithm is Rijndael || symmetricAlgorithm is Aes)
			{
				return SymmetricKeyWrap.AESKeyWrapEncrypt(symmetricAlgorithm.Key, keyData);
			}
			throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_NotSupportedCryptographicTransform"));
		}

		/// <summary>Encrypts the key that a recipient uses to decrypt an <see langword="&lt;EncryptedData&gt;" /> element.</summary>
		/// <param name="keyData">The key to encrypt.</param>
		/// <param name="rsa">The asymmetric key used to encrypt <paramref name="keyData" />.</param>
		/// <param name="useOAEP">A value that specifies whether to use Optimal Asymmetric Encryption Padding (OAEP).</param>
		/// <returns>A byte array that represents the encrypted value of the <paramref name="keyData" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="keyData" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="rsa" /> parameter is <see langword="null" />.</exception>
		public static byte[] EncryptKey(byte[] keyData, RSA rsa, bool useOAEP)
		{
			if (keyData == null)
			{
				throw new ArgumentNullException("keyData");
			}
			if (rsa == null)
			{
				throw new ArgumentNullException("rsa");
			}
			if (useOAEP)
			{
				RSAOAEPKeyExchangeFormatter rSAOAEPKeyExchangeFormatter = new RSAOAEPKeyExchangeFormatter(rsa);
				return rSAOAEPKeyExchangeFormatter.CreateKeyExchange(keyData);
			}
			RSAPKCS1KeyExchangeFormatter rSAPKCS1KeyExchangeFormatter = new RSAPKCS1KeyExchangeFormatter(rsa);
			return rSAPKCS1KeyExchangeFormatter.CreateKeyExchange(keyData);
		}

		/// <summary>Decrypts an <see langword="&lt;EncryptedKey&gt;" /> element using a symmetric algorithm.</summary>
		/// <param name="keyData">An array of bytes that represents an encrypted <see langword="&lt;EncryptedKey&gt;" /> element.</param>
		/// <param name="symmetricAlgorithm">The symmetric key used to decrypt <paramref name="keyData" />.</param>
		/// <returns>A byte array that contains the plain text key.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="keyData" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="symmetricAlgorithm" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The value of the <paramref name="symmetricAlgorithm" /> element is not the Triple DES Key Wrap algorithm or the Advanced Encryption Standard (AES) Key Wrap algorithm (also called Rijndael).</exception>
		public static byte[] DecryptKey(byte[] keyData, SymmetricAlgorithm symmetricAlgorithm)
		{
			if (keyData == null)
			{
				throw new ArgumentNullException("keyData");
			}
			if (symmetricAlgorithm == null)
			{
				throw new ArgumentNullException("symmetricAlgorithm");
			}
			if (symmetricAlgorithm is TripleDES)
			{
				return SymmetricKeyWrap.TripleDESKeyWrapDecrypt(symmetricAlgorithm.Key, keyData);
			}
			if (symmetricAlgorithm is Rijndael || symmetricAlgorithm is Aes)
			{
				return SymmetricKeyWrap.AESKeyWrapDecrypt(symmetricAlgorithm.Key, keyData);
			}
			throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_NotSupportedCryptographicTransform"));
		}

		/// <summary>Decrypts an <see langword="&lt;EncryptedKey&gt;" /> element using an asymmetric algorithm.</summary>
		/// <param name="keyData">An array of bytes that represents an encrypted <see langword="&lt;EncryptedKey&gt;" /> element.</param>
		/// <param name="rsa">The asymmetric key used to decrypt <paramref name="keyData" />.</param>
		/// <param name="useOAEP">A value that specifies whether to use Optimal Asymmetric Encryption Padding (OAEP).</param>
		/// <returns>A byte array that contains the plain text key.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value of the <paramref name="keyData" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The value of the <paramref name="rsa" /> parameter is <see langword="null" />.</exception>
		public static byte[] DecryptKey(byte[] keyData, RSA rsa, bool useOAEP)
		{
			if (keyData == null)
			{
				throw new ArgumentNullException("keyData");
			}
			if (rsa == null)
			{
				throw new ArgumentNullException("rsa");
			}
			if (useOAEP)
			{
				RSAOAEPKeyExchangeDeformatter rSAOAEPKeyExchangeDeformatter = new RSAOAEPKeyExchangeDeformatter(rsa);
				return rSAOAEPKeyExchangeDeformatter.DecryptKeyExchange(keyData);
			}
			RSAPKCS1KeyExchangeDeformatter rSAPKCS1KeyExchangeDeformatter = new RSAPKCS1KeyExchangeDeformatter(rsa);
			return rSAPKCS1KeyExchangeDeformatter.DecryptKeyExchange(keyData);
		}
	}
	internal class ExcCanonicalXml
	{
		private CanonicalXmlDocument m_c14nDoc;

		private ExcAncestralNamespaceContextManager m_ancMgr;

		internal ExcCanonicalXml(Stream inputStream, bool includeComments, string inclusiveNamespacesPrefixList, XmlResolver resolver, string strBaseUri)
		{
			if (inputStream == null)
			{
				throw new ArgumentNullException("inputStream");
			}
			m_c14nDoc = new CanonicalXmlDocument(defaultNodeSetInclusionState: true, includeComments);
			m_c14nDoc.XmlResolver = resolver;
			m_c14nDoc.Load(Utils.PreProcessStreamInput(inputStream, resolver, strBaseUri));
			m_ancMgr = new ExcAncestralNamespaceContextManager(inclusiveNamespacesPrefixList);
		}

		internal ExcCanonicalXml(XmlDocument document, bool includeComments, string inclusiveNamespacesPrefixList, XmlResolver resolver)
		{
			if (document == null)
			{
				throw new ArgumentNullException("document");
			}
			m_c14nDoc = new CanonicalXmlDocument(defaultNodeSetInclusionState: true, includeComments);
			m_c14nDoc.XmlResolver = resolver;
			m_c14nDoc.Load(new XmlNodeReader(document));
			m_ancMgr = new ExcAncestralNamespaceContextManager(inclusiveNamespacesPrefixList);
		}

		internal ExcCanonicalXml(XmlNodeList nodeList, bool includeComments, string inclusiveNamespacesPrefixList, XmlResolver resolver)
		{
			if (nodeList == null)
			{
				throw new ArgumentNullException("nodeList");
			}
			XmlDocument ownerDocument = Utils.GetOwnerDocument(nodeList);
			if (ownerDocument == null)
			{
				throw new ArgumentException("nodeList");
			}
			m_c14nDoc = new CanonicalXmlDocument(defaultNodeSetInclusionState: false, includeComments);
			m_c14nDoc.XmlResolver = resolver;
			m_c14nDoc.Load(new XmlNodeReader(ownerDocument));
			m_ancMgr = new ExcAncestralNamespaceContextManager(inclusiveNamespacesPrefixList);
			MarkInclusionStateForNodes(nodeList, ownerDocument, m_c14nDoc);
		}

		internal byte[] GetBytes()
		{
			StringBuilder stringBuilder = new StringBuilder();
			m_c14nDoc.Write(stringBuilder, DocPosition.BeforeRootElement, m_ancMgr);
			UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
			return uTF8Encoding.GetBytes(stringBuilder.ToString());
		}

		internal byte[] GetDigestedBytes(HashAlgorithm hash)
		{
			m_c14nDoc.WriteHash(hash, DocPosition.BeforeRootElement, m_ancMgr);
			hash.TransformFinalBlock(new byte[0], 0, 0);
			byte[] result = (byte[])hash.Hash.Clone();
			hash.Initialize();
			return result;
		}

		private static void MarkInclusionStateForNodes(XmlNodeList nodeList, XmlDocument inputRoot, XmlDocument root)
		{
			CanonicalXmlNodeList canonicalXmlNodeList = new CanonicalXmlNodeList();
			CanonicalXmlNodeList canonicalXmlNodeList2 = new CanonicalXmlNodeList();
			canonicalXmlNodeList.Add(inputRoot);
			canonicalXmlNodeList2.Add(root);
			int num = 0;
			do
			{
				XmlNode xmlNode = canonicalXmlNodeList[num];
				XmlNode xmlNode2 = canonicalXmlNodeList2[num];
				XmlNodeList childNodes = xmlNode.ChildNodes;
				XmlNodeList childNodes2 = xmlNode2.ChildNodes;
				for (int i = 0; i < childNodes.Count; i++)
				{
					canonicalXmlNodeList.Add(childNodes[i]);
					canonicalXmlNodeList2.Add(childNodes2[i]);
					if (Utils.NodeInList(childNodes[i], nodeList))
					{
						MarkNodeAsIncluded(childNodes2[i]);
					}
					XmlAttributeCollection attributes = childNodes[i].Attributes;
					if (attributes == null)
					{
						continue;
					}
					for (int j = 0; j < attributes.Count; j++)
					{
						if (Utils.NodeInList(attributes[j], nodeList))
						{
							MarkNodeAsIncluded(childNodes2[i].Attributes.Item(j));
						}
					}
				}
				num++;
			}
			while (num < canonicalXmlNodeList.Count);
		}

		private static void MarkNodeAsIncluded(XmlNode node)
		{
			if (node is ICanonicalizableNode)
			{
				((ICanonicalizableNode)node).IsInNodeSet = true;
			}
		}
	}
	internal class ExcAncestralNamespaceContextManager : AncestralNamespaceContextManager
	{
		private Hashtable m_inclusivePrefixSet;

		internal ExcAncestralNamespaceContextManager(string inclusiveNamespacesPrefixList)
		{
			m_inclusivePrefixSet = Utils.TokenizePrefixListString(inclusiveNamespacesPrefixList);
		}

		private bool HasNonRedundantInclusivePrefix(XmlAttribute attr)
		{
			string namespacePrefix = Utils.GetNamespacePrefix(attr);
			int depth;
			if (m_inclusivePrefixSet.ContainsKey(namespacePrefix))
			{
				return Utils.IsNonRedundantNamespaceDecl(attr, GetNearestRenderedNamespaceWithMatchingPrefix(namespacePrefix, out depth));
			}
			return false;
		}

		private void GatherNamespaceToRender(string nsPrefix, SortedList nsListToRender, Hashtable nsLocallyDeclared)
		{
			foreach (object key in nsListToRender.GetKeyList())
			{
				if (Utils.HasNamespacePrefix((XmlAttribute)key, nsPrefix))
				{
					return;
				}
			}
			XmlAttribute xmlAttribute = (XmlAttribute)nsLocallyDeclared[nsPrefix];
			int depth;
			XmlAttribute nearestRenderedNamespaceWithMatchingPrefix = GetNearestRenderedNamespaceWithMatchingPrefix(nsPrefix, out depth);
			if (xmlAttribute != null)
			{
				if (Utils.IsNonRedundantNamespaceDecl(xmlAttribute, nearestRenderedNamespaceWithMatchingPrefix))
				{
					nsLocallyDeclared.Remove(nsPrefix);
					nsListToRender.Add(xmlAttribute, null);
				}
			}
			else
			{
				int depth2;
				XmlAttribute nearestUnrenderedNamespaceWithMatchingPrefix = GetNearestUnrenderedNamespaceWithMatchingPrefix(nsPrefix, out depth2);
				if (nearestUnrenderedNamespaceWithMatchingPrefix != null && depth2 > depth && Utils.IsNonRedundantNamespaceDecl(nearestUnrenderedNamespaceWithMatchingPrefix, nearestRenderedNamespaceWithMatchingPrefix))
				{
					nsListToRender.Add(nearestUnrenderedNamespaceWithMatchingPrefix, null);
				}
			}
		}

		internal override void GetNamespacesToRender(XmlElement element, SortedList attrListToRender, SortedList nsListToRender, Hashtable nsLocallyDeclared)
		{
			GatherNamespaceToRender(element.Prefix, nsListToRender, nsLocallyDeclared);
			foreach (object key in attrListToRender.GetKeyList())
			{
				string prefix = ((XmlAttribute)key).Prefix;
				if (prefix.Length > 0)
				{
					GatherNamespaceToRender(prefix, nsListToRender, nsLocallyDeclared);
				}
			}
		}

		internal override void TrackNamespaceNode(XmlAttribute attr, SortedList nsListToRender, Hashtable nsLocallyDeclared)
		{
			if (!Utils.IsXmlPrefixDefinitionNode(attr))
			{
				if (HasNonRedundantInclusivePrefix(attr))
				{
					nsListToRender.Add(attr, null);
				}
				else
				{
					nsLocallyDeclared.Add(Utils.GetNamespacePrefix(attr), attr);
				}
			}
		}

		internal override void TrackXmlNamespaceNode(XmlAttribute attr, SortedList nsListToRender, SortedList attrListToRender, Hashtable nsLocallyDeclared)
		{
			attrListToRender.Add(attr, null);
		}
	}
	/// <summary>Represents an XML digital signature or XML encryption <see langword="&lt;KeyInfo&gt;" /> element.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class KeyInfo : IEnumerable
	{
		private string m_id;

		private ArrayList m_KeyInfoClauses;

		/// <summary>Gets or sets the key information identity.</summary>
		/// <returns>The key information identity.</returns>
		public string Id
		{
			get
			{
				return m_id;
			}
			set
			{
				m_id = value;
			}
		}

		/// <summary>Gets the number of <see cref="T:System.Security.Cryptography.Xml.KeyInfoClause" /> objects contained in the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object.</summary>
		/// <returns>The number of <see cref="T:System.Security.Cryptography.Xml.KeyInfoClause" /> objects contained in the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object.</returns>
		public int Count => m_KeyInfoClauses.Count;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> class.</summary>
		public KeyInfo()
		{
			m_KeyInfoClauses = new ArrayList();
		}

		/// <summary>Returns the XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object.</summary>
		/// <returns>The XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object.</returns>
		public XmlElement GetXml()
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument xmlDocument)
		{
			XmlElement xmlElement = xmlDocument.CreateElement("KeyInfo", "http://www.w3.org/2000/09/xmldsig#");
			if (!string.IsNullOrEmpty(m_id))
			{
				xmlElement.SetAttribute("Id", m_id);
			}
			for (int i = 0; i < m_KeyInfoClauses.Count; i++)
			{
				XmlElement xml = ((KeyInfoClause)m_KeyInfoClauses[i]).GetXml(xmlDocument);
				if (xml != null)
				{
					xmlElement.AppendChild(xml);
				}
			}
			return xmlElement;
		}

		/// <summary>Loads a <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> state from an XML element.</summary>
		/// <param name="value">The XML element from which to load the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> state.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		public void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			m_id = Utils.GetAttribute(value, "Id", "http://www.w3.org/2000/09/xmldsig#");
			if (!Utils.VerifyAttributes(value, "Id"))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "KeyInfo");
			}
			for (XmlNode xmlNode = value.FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
			{
				if (xmlNode is XmlElement xmlElement)
				{
					string text = xmlElement.NamespaceURI + " " + xmlElement.LocalName;
					if (text == "http://www.w3.org/2000/09/xmldsig# KeyValue")
					{
						if (!Utils.VerifyAttributes(xmlElement, (string[])null))
						{
							throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "KeyInfo/KeyValue");
						}
						XmlNodeList childNodes = xmlElement.ChildNodes;
						foreach (XmlNode item in childNodes)
						{
							if (item is XmlElement xmlElement2)
							{
								text = text + "/" + xmlElement2.LocalName;
								break;
							}
						}
					}
					KeyInfoClause keyInfoClause = Utils.CreateFromName<KeyInfoClause>(text);
					if (keyInfoClause == null)
					{
						keyInfoClause = new KeyInfoNode();
					}
					keyInfoClause.LoadXml(xmlElement);
					AddClause(keyInfoClause);
				}
			}
		}

		/// <summary>Adds a <see cref="T:System.Security.Cryptography.Xml.KeyInfoClause" /> that represents a particular type of <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> information to the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object.</summary>
		/// <param name="clause">The <see cref="T:System.Security.Cryptography.Xml.KeyInfoClause" /> to add to the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object.</param>
		public void AddClause(KeyInfoClause clause)
		{
			m_KeyInfoClauses.Add(clause);
		}

		/// <summary>Returns an enumerator of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoClause" /> objects in the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object.</summary>
		/// <returns>An enumerator of the subelements of <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> that can be used to iterate through the collection.</returns>
		public IEnumerator GetEnumerator()
		{
			return m_KeyInfoClauses.GetEnumerator();
		}

		/// <summary>Returns an enumerator of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoClause" /> objects of the specified type in the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object.</summary>
		/// <param name="requestedObjectType">The type of object to enumerate.</param>
		/// <returns>An enumerator of the subelements of <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> that can be used to iterate through the collection.</returns>
		public IEnumerator GetEnumerator(Type requestedObjectType)
		{
			ArrayList arrayList = new ArrayList();
			IEnumerator enumerator = m_KeyInfoClauses.GetEnumerator();
			while (enumerator.MoveNext())
			{
				object current = enumerator.Current;
				if (requestedObjectType.Equals(current.GetType()))
				{
					arrayList.Add(current);
				}
			}
			return arrayList.GetEnumerator();
		}
	}
	/// <summary>Represents the abstract base class from which all implementations of <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> subelements inherit.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class KeyInfoClause
	{
		/// <summary>Initializes a new instance of <see cref="T:System.Security.Cryptography.Xml.KeyInfoClause" />.</summary>
		protected KeyInfoClause()
		{
		}

		/// <summary>When overridden in a derived class, returns an XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoClause" />.</summary>
		/// <returns>An XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoClause" />.</returns>
		public abstract XmlElement GetXml();

		internal virtual XmlElement GetXml(XmlDocument xmlDocument)
		{
			XmlElement xml = GetXml();
			return (XmlElement)xmlDocument.ImportNode(xml, deep: true);
		}

		/// <summary>When overridden in a derived class, parses the input <see cref="T:System.Xml.XmlElement" /> and configures the internal state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoClause" /> to match.</summary>
		/// <param name="element">The <see cref="T:System.Xml.XmlElement" /> that specifies the state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoClause" />.</param>
		public abstract void LoadXml(XmlElement element);
	}
	/// <summary>Represents a <see langword="&lt;KeyName&gt;" /> subelement of an XMLDSIG or XML Encryption <see langword="&lt;KeyInfo&gt;" /> element.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class KeyInfoName : KeyInfoClause
	{
		private string m_keyName;

		/// <summary>Gets or sets the string identifier contained within a <see langword="&lt;KeyName&gt;" /> element.</summary>
		/// <returns>The string identifier that is the value of the <see langword="&lt;KeyName&gt;" /> element.</returns>
		public string Value
		{
			get
			{
				return m_keyName;
			}
			set
			{
				m_keyName = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoName" /> class.</summary>
		public KeyInfoName()
			: this(null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoName" /> class by specifying the string identifier that is the value of the <see langword="&lt;KeyName&gt;" /> element.</summary>
		/// <param name="keyName">The string identifier that is the value of the <see langword="&lt;KeyName&gt;" /> element.</param>
		public KeyInfoName(string keyName)
		{
			Value = keyName;
		}

		/// <summary>Returns an XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoName" /> object.</summary>
		/// <returns>An XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoName" /> object.</returns>
		public override XmlElement GetXml()
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal override XmlElement GetXml(XmlDocument xmlDocument)
		{
			XmlElement xmlElement = xmlDocument.CreateElement("KeyName", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement.AppendChild(xmlDocument.CreateTextNode(m_keyName));
			return xmlElement;
		}

		/// <summary>Parses the input <see cref="T:System.Xml.XmlElement" /> object and configures the internal state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoName" /> object to match.</summary>
		/// <param name="value">The <see cref="T:System.Xml.XmlElement" /> object that specifies the state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoName" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		public override void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			m_keyName = value.InnerText.Trim();
		}
	}
	/// <summary>Represents the <see cref="T:System.Security.Cryptography.DSA" /> private key of the <see langword="&lt;KeyInfo&gt;" /> element.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class DSAKeyValue : KeyInfoClause
	{
		private DSA m_key;

		/// <summary>Gets or sets the key value represented by a <see cref="T:System.Security.Cryptography.DSA" /> object.</summary>
		/// <returns>The public key represented by a <see cref="T:System.Security.Cryptography.DSA" /> object.</returns>
		public DSA Key
		{
			get
			{
				return m_key;
			}
			set
			{
				m_key = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.DSAKeyValue" /> class with a new, randomly-generated <see cref="T:System.Security.Cryptography.DSA" /> public key.</summary>
		public DSAKeyValue()
		{
			m_key = DSA.Create();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.DSAKeyValue" /> class with the specified <see cref="T:System.Security.Cryptography.DSA" /> public key.</summary>
		/// <param name="key">The instance of an implementation of the <see cref="T:System.Security.Cryptography.DSA" /> class that holds the public key.</param>
		public DSAKeyValue(DSA key)
		{
			m_key = key;
		}

		/// <summary>Returns the XML representation of a <see cref="T:System.Security.Cryptography.Xml.DSAKeyValue" /> element.</summary>
		/// <returns>The XML representation of the <see cref="T:System.Security.Cryptography.Xml.DSAKeyValue" /> element.</returns>
		public override XmlElement GetXml()
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal override XmlElement GetXml(XmlDocument xmlDocument)
		{
			DSAParameters dSAParameters = m_key.ExportParameters(includePrivateParameters: false);
			XmlElement xmlElement = xmlDocument.CreateElement("KeyValue", "http://www.w3.org/2000/09/xmldsig#");
			XmlElement xmlElement2 = xmlDocument.CreateElement("DSAKeyValue", "http://www.w3.org/2000/09/xmldsig#");
			XmlElement xmlElement3 = xmlDocument.CreateElement("P", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement3.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(dSAParameters.P)));
			xmlElement2.AppendChild(xmlElement3);
			XmlElement xmlElement4 = xmlDocument.CreateElement("Q", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement4.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(dSAParameters.Q)));
			xmlElement2.AppendChild(xmlElement4);
			XmlElement xmlElement5 = xmlDocument.CreateElement("G", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement5.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(dSAParameters.G)));
			xmlElement2.AppendChild(xmlElement5);
			XmlElement xmlElement6 = xmlDocument.CreateElement("Y", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement6.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(dSAParameters.Y)));
			xmlElement2.AppendChild(xmlElement6);
			if (dSAParameters.J != null)
			{
				XmlElement xmlElement7 = xmlDocument.CreateElement("J", "http://www.w3.org/2000/09/xmldsig#");
				xmlElement7.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(dSAParameters.J)));
				xmlElement2.AppendChild(xmlElement7);
			}
			if (dSAParameters.Seed != null)
			{
				XmlElement xmlElement8 = xmlDocument.CreateElement("Seed", "http://www.w3.org/2000/09/xmldsig#");
				xmlElement8.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(dSAParameters.Seed)));
				xmlElement2.AppendChild(xmlElement8);
				XmlElement xmlElement9 = xmlDocument.CreateElement("PgenCounter", "http://www.w3.org/2000/09/xmldsig#");
				xmlElement9.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(Utils.ConvertIntToByteArray(dSAParameters.Counter))));
				xmlElement2.AppendChild(xmlElement9);
			}
			xmlElement.AppendChild(xmlElement2);
			return xmlElement;
		}

		/// <summary>Loads a <see cref="T:System.Security.Cryptography.Xml.DSAKeyValue" /> state from an XML element.</summary>
		/// <param name="value">The XML element to load the <see cref="T:System.Security.Cryptography.Xml.DSAKeyValue" /> state from.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="value" /> parameter is not a valid <see cref="T:System.Security.Cryptography.Xml.DSAKeyValue" /> XML element.</exception>
		public override void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			m_key.FromXmlString(value.OuterXml);
		}
	}
	/// <summary>Represents the &lt;<see langword="RSAKeyValue" />&gt; element of an XML signature.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class RSAKeyValue : KeyInfoClause
	{
		private RSA m_key;

		/// <summary>Gets or sets the instance of <see cref="T:System.Security.Cryptography.RSA" /> that holds the public key.</summary>
		/// <returns>The instance of <see cref="T:System.Security.Cryptography.RSA" /> that holds the public key.</returns>
		public RSA Key
		{
			get
			{
				return m_key;
			}
			set
			{
				m_key = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.RSAKeyValue" /> class with a new randomly generated <see cref="T:System.Security.Cryptography.RSA" /> public key.</summary>
		public RSAKeyValue()
		{
			m_key = RSA.Create();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.RSAKeyValue" /> class with the specified <see cref="T:System.Security.Cryptography.RSA" /> public key.</summary>
		/// <param name="key">The instance of an implementation of <see cref="T:System.Security.Cryptography.RSA" /> that holds the public key.</param>
		public RSAKeyValue(RSA key)
		{
			m_key = key;
		}

		/// <summary>Returns the XML representation of the <see cref="T:System.Security.Cryptography.RSA" /> key clause.</summary>
		/// <returns>The XML representation of the <see cref="T:System.Security.Cryptography.RSA" /> key clause.</returns>
		public override XmlElement GetXml()
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal override XmlElement GetXml(XmlDocument xmlDocument)
		{
			RSAParameters rSAParameters = m_key.ExportParameters(includePrivateParameters: false);
			XmlElement xmlElement = xmlDocument.CreateElement("KeyValue", "http://www.w3.org/2000/09/xmldsig#");
			XmlElement xmlElement2 = xmlDocument.CreateElement("RSAKeyValue", "http://www.w3.org/2000/09/xmldsig#");
			XmlElement xmlElement3 = xmlDocument.CreateElement("Modulus", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement3.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(rSAParameters.Modulus)));
			xmlElement2.AppendChild(xmlElement3);
			XmlElement xmlElement4 = xmlDocument.CreateElement("Exponent", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement4.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(rSAParameters.Exponent)));
			xmlElement2.AppendChild(xmlElement4);
			xmlElement.AppendChild(xmlElement2);
			return xmlElement;
		}

		/// <summary>Loads an <see cref="T:System.Security.Cryptography.RSA" /> key clause from an XML element.</summary>
		/// <param name="value">The XML element from which to load the <see cref="T:System.Security.Cryptography.RSA" /> key clause.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="value" /> parameter is not a valid <see cref="T:System.Security.Cryptography.RSA" /> key clause XML element.</exception>
		public override void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			m_key.FromXmlString(value.OuterXml);
		}
	}
	/// <summary>References <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> objects stored at a different location when using XMLDSIG or XML encryption.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class KeyInfoRetrievalMethod : KeyInfoClause
	{
		private string m_uri;

		private string m_type;

		/// <summary>Gets or sets the Uniform Resource Identifier (URI) of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoRetrievalMethod" /> object.</summary>
		/// <returns>The Uniform Resource Identifier (URI) of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoRetrievalMethod" /> object.</returns>
		public string Uri
		{
			get
			{
				return m_uri;
			}
			set
			{
				m_uri = value;
			}
		}

		/// <summary>Gets or sets a Uniform Resource Identifier (URI) that describes the type of data to be retrieved.</summary>
		/// <returns>A Uniform Resource Identifier (URI) that describes the type of data to be retrieved.</returns>
		[ComVisible(false)]
		public string Type
		{
			get
			{
				return m_type;
			}
			set
			{
				m_type = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoRetrievalMethod" /> class.</summary>
		public KeyInfoRetrievalMethod()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoRetrievalMethod" /> class with the specified Uniform Resource Identifier (URI) pointing to the referenced <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object.</summary>
		/// <param name="strUri">The Uniform Resource Identifier (URI) of the information to be referenced by the new instance of <see cref="T:System.Security.Cryptography.Xml.KeyInfoRetrievalMethod" />.</param>
		public KeyInfoRetrievalMethod(string strUri)
		{
			m_uri = strUri;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoRetrievalMethod" /> class with the specified Uniform Resource Identifier (URI) pointing to the referenced <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object and the URI that describes the type of data to retrieve.</summary>
		/// <param name="strUri">The Uniform Resource Identifier (URI) of the information to be referenced by the new instance of <see cref="T:System.Security.Cryptography.Xml.KeyInfoRetrievalMethod" />.</param>
		/// <param name="typeName">The URI that describes the type of data to retrieve.</param>
		public KeyInfoRetrievalMethod(string strUri, string typeName)
		{
			m_uri = strUri;
			m_type = typeName;
		}

		/// <summary>Returns the XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoRetrievalMethod" /> object.</summary>
		/// <returns>The XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoRetrievalMethod" /> object.</returns>
		public override XmlElement GetXml()
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal override XmlElement GetXml(XmlDocument xmlDocument)
		{
			XmlElement xmlElement = xmlDocument.CreateElement("RetrievalMethod", "http://www.w3.org/2000/09/xmldsig#");
			if (!string.IsNullOrEmpty(m_uri))
			{
				xmlElement.SetAttribute("URI", m_uri);
			}
			if (!string.IsNullOrEmpty(m_type))
			{
				xmlElement.SetAttribute("Type", m_type);
			}
			return xmlElement;
		}

		/// <summary>Parses the input <see cref="T:System.Xml.XmlElement" /> object and configures the internal state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoRetrievalMethod" /> object to match.</summary>
		/// <param name="value">The XML element that specifies the state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoRetrievalMethod" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		public override void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			m_uri = Utils.GetAttribute(value, "URI", "http://www.w3.org/2000/09/xmldsig#");
			m_type = Utils.GetAttribute(value, "Type", "http://www.w3.org/2000/09/xmldsig#");
		}
	}
	/// <summary>Wraps the <see cref="T:System.Security.Cryptography.Xml.EncryptedKey" /> class, it to be placed as a subelement of the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> class.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class KeyInfoEncryptedKey : KeyInfoClause
	{
		private EncryptedKey m_encryptedKey;

		/// <summary>Gets or sets an <see cref="T:System.Security.Cryptography.Xml.EncryptedKey" /> object that encapsulates an encrypted key.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Xml.EncryptedKey" /> object that encapsulates an encrypted key.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.KeyInfoEncryptedKey.EncryptedKey" /> property is <see langword="null" />.</exception>
		public EncryptedKey EncryptedKey
		{
			get
			{
				return m_encryptedKey;
			}
			set
			{
				m_encryptedKey = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoEncryptedKey" /> class.</summary>
		public KeyInfoEncryptedKey()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoEncryptedKey" /> class using an <see cref="T:System.Security.Cryptography.Xml.EncryptedKey" /> object.</summary>
		/// <param name="encryptedKey">An <see cref="T:System.Security.Cryptography.Xml.EncryptedKey" /> object that encapsulates an encrypted key.</param>
		public KeyInfoEncryptedKey(EncryptedKey encryptedKey)
		{
			m_encryptedKey = encryptedKey;
		}

		/// <summary>Returns an XML representation of a <see cref="T:System.Security.Cryptography.Xml.KeyInfoEncryptedKey" /> object.</summary>
		/// <returns>An XML representation of a <see cref="T:System.Security.Cryptography.Xml.KeyInfoEncryptedKey" /> object.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The encrypted key is <see langword="null" />.</exception>
		public override XmlElement GetXml()
		{
			if (m_encryptedKey == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "KeyInfoEncryptedKey");
			}
			return m_encryptedKey.GetXml();
		}

		internal override XmlElement GetXml(XmlDocument xmlDocument)
		{
			if (m_encryptedKey == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "KeyInfoEncryptedKey");
			}
			return m_encryptedKey.GetXml(xmlDocument);
		}

		/// <summary>Parses the input <see cref="T:System.Xml.XmlElement" /> object and configures the internal state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoEncryptedKey" /> object to match.</summary>
		/// <param name="value">The <see cref="T:System.Xml.XmlElement" /> object that specifies the state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoEncryptedKey" /> object.</param>
		public override void LoadXml(XmlElement value)
		{
			m_encryptedKey = new EncryptedKey();
			m_encryptedKey.LoadXml(value);
		}
	}
	/// <summary>Represents the &lt;<see langword="X509IssuerSerial" />&gt; element of an XML digital signature.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public struct X509IssuerSerial
	{
		private string issuerName;

		private string serialNumber;

		/// <summary>Gets or sets an X.509 certificate issuer's distinguished name.</summary>
		/// <returns>An X.509 certificate issuer's distinguished name.</returns>
		public string IssuerName
		{
			get
			{
				return issuerName;
			}
			set
			{
				issuerName = value;
			}
		}

		/// <summary>Gets or sets an X.509 certificate issuer's serial number.</summary>
		/// <returns>An X.509 certificate issuer's serial number.</returns>
		public string SerialNumber
		{
			get
			{
				return serialNumber;
			}
			set
			{
				serialNumber = value;
			}
		}

		internal X509IssuerSerial(string issuerName, string serialNumber)
		{
			if (issuerName == null || issuerName.Length == 0)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Arg_EmptyOrNullString"), "issuerName");
			}
			if (serialNumber == null || serialNumber.Length == 0)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Arg_EmptyOrNullString"), "serialNumber");
			}
			this.issuerName = issuerName;
			this.serialNumber = serialNumber;
		}
	}
	/// <summary>Represents an <see langword="&lt;X509Data&gt;" /> subelement of an XMLDSIG or XML Encryption <see langword="&lt;KeyInfo&gt;" /> element.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class KeyInfoX509Data : KeyInfoClause
	{
		private ArrayList m_certificates;

		private ArrayList m_issuerSerials;

		private ArrayList m_subjectKeyIds;

		private ArrayList m_subjectNames;

		private byte[] m_CRL;

		/// <summary>Gets a list of the X.509v3 certificates contained in the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</summary>
		/// <returns>A list of the X.509 certificates contained in the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</returns>
		public ArrayList Certificates => m_certificates;

		/// <summary>Gets a list of the subject key identifiers (SKIs) contained in the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</summary>
		/// <returns>A list of the subject key identifiers (SKIs) contained in the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</returns>
		public ArrayList SubjectKeyIds => m_subjectKeyIds;

		/// <summary>Gets a list of the subject names of the entities contained in the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</summary>
		/// <returns>A list of the subject names of the entities contained in the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</returns>
		public ArrayList SubjectNames => m_subjectNames;

		/// <summary>Gets a list of <see cref="T:System.Security.Cryptography.Xml.X509IssuerSerial" /> structures that represent an issuer name and serial number pair.</summary>
		/// <returns>A list of <see cref="T:System.Security.Cryptography.Xml.X509IssuerSerial" /> structures that represent an issuer name and serial number pair.</returns>
		public ArrayList IssuerSerials => m_issuerSerials;

		/// <summary>Gets or sets the Certificate Revocation List (CRL) contained within the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</summary>
		/// <returns>The Certificate Revocation List (CRL) contained within the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</returns>
		public byte[] CRL
		{
			get
			{
				return m_CRL;
			}
			set
			{
				m_CRL = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> class.</summary>
		public KeyInfoX509Data()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> class from the specified ASN.1 DER encoding of an X.509v3 certificate.</summary>
		/// <param name="rgbCert">The ASN.1 DER encoding of an <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> object to initialize the new instance of <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> from.</param>
		public KeyInfoX509Data(byte[] rgbCert)
		{
			X509Certificate2 certificate = new X509Certificate2(rgbCert);
			AddCertificate(certificate);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> class from the specified X.509v3 certificate.</summary>
		/// <param name="cert">The <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> object to initialize the new instance of <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> from.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="cert" /> parameter is <see langword="null" />.</exception>
		public KeyInfoX509Data(X509Certificate cert)
		{
			AddCertificate(cert);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> class from the specified X.509v3 certificate.</summary>
		/// <param name="cert">The <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> object to initialize the new instance of <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> from.</param>
		/// <param name="includeOption">One of the <see cref="T:System.Security.Cryptography.X509Certificates.X509IncludeOption" /> values that specifies how much of the certificate chain to include.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="cert" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The certificate has only a partial certificate chain.</exception>
		[SecuritySafeCritical]
		public KeyInfoX509Data(X509Certificate cert, X509IncludeOption includeOption)
		{
			if (cert == null)
			{
				throw new ArgumentNullException("cert");
			}
			X509Certificate2 certificate = new X509Certificate2(cert);
			X509ChainElementCollection x509ChainElementCollection = null;
			X509Chain x509Chain = null;
			switch (includeOption)
			{
			case X509IncludeOption.ExcludeRoot:
			{
				x509Chain = new X509Chain();
				x509Chain.Build(certificate);
				if (x509Chain.ChainStatus.Length != 0 && (x509Chain.ChainStatus[0].Status & X509ChainStatusFlags.PartialChain) == X509ChainStatusFlags.PartialChain)
				{
					throw new CryptographicException(-2146762486);
				}
				x509ChainElementCollection = x509Chain.ChainElements;
				for (int i = 0; i < (System.Security.Cryptography.X509Certificates.X509Utils.IsSelfSigned(x509Chain) ? 1 : (x509ChainElementCollection.Count - 1)); i++)
				{
					AddCertificate(x509ChainElementCollection[i].Certificate);
				}
				break;
			}
			case X509IncludeOption.EndCertOnly:
				AddCertificate(certificate);
				break;
			case X509IncludeOption.WholeChain:
			{
				x509Chain = new X509Chain();
				x509Chain.Build(certificate);
				if (x509Chain.ChainStatus.Length != 0 && (x509Chain.ChainStatus[0].Status & X509ChainStatusFlags.PartialChain) == X509ChainStatusFlags.PartialChain)
				{
					throw new CryptographicException(-2146762486);
				}
				x509ChainElementCollection = x509Chain.ChainElements;
				X509ChainElementEnumerator enumerator = x509ChainElementCollection.GetEnumerator();
				while (enumerator.MoveNext())
				{
					X509ChainElement current = enumerator.Current;
					AddCertificate(current.Certificate);
				}
				break;
			}
			}
		}

		/// <summary>Adds the specified X.509v3 certificate to the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" />.</summary>
		/// <param name="certificate">The <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> object to add to the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="certificate" /> parameter is <see langword="null" />.</exception>
		public void AddCertificate(X509Certificate certificate)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			if (m_certificates == null)
			{
				m_certificates = new ArrayList();
			}
			X509Certificate2 value = new X509Certificate2(certificate);
			m_certificates.Add(value);
		}

		/// <summary>Adds the specified subject key identifier (SKI) byte array to the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</summary>
		/// <param name="subjectKeyId">A byte array that represents the subject key identifier (SKI) to add to the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</param>
		public void AddSubjectKeyId(byte[] subjectKeyId)
		{
			if (m_subjectKeyIds == null)
			{
				m_subjectKeyIds = new ArrayList();
			}
			m_subjectKeyIds.Add(subjectKeyId);
		}

		/// <summary>Adds the specified subject key identifier (SKI) string to the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</summary>
		/// <param name="subjectKeyId">A string that represents the subject key identifier (SKI) to add to the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</param>
		[ComVisible(false)]
		public void AddSubjectKeyId(string subjectKeyId)
		{
			if (m_subjectKeyIds == null)
			{
				m_subjectKeyIds = new ArrayList();
			}
			m_subjectKeyIds.Add(System.Security.Cryptography.X509Certificates.X509Utils.DecodeHexString(subjectKeyId));
		}

		/// <summary>Adds the subject name of the entity that was issued an X.509v3 certificate to the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</summary>
		/// <param name="subjectName">The name of the entity that was issued an X.509 certificate to add to the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</param>
		public void AddSubjectName(string subjectName)
		{
			if (m_subjectNames == null)
			{
				m_subjectNames = new ArrayList();
			}
			m_subjectNames.Add(subjectName);
		}

		/// <summary>Adds the specified issuer name and serial number pair to the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</summary>
		/// <param name="issuerName">The issuer name portion of the pair to add to the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</param>
		/// <param name="serialNumber">The serial number portion of the pair to add to the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</param>
		public void AddIssuerSerial(string issuerName, string serialNumber)
		{
			BigInt bigInt = new BigInt();
			bigInt.FromHexadecimal(serialNumber);
			if (m_issuerSerials == null)
			{
				m_issuerSerials = new ArrayList();
			}
			m_issuerSerials.Add(new X509IssuerSerial(issuerName, bigInt.ToDecimal()));
		}

		internal void InternalAddIssuerSerial(string issuerName, string serialNumber)
		{
			if (m_issuerSerials == null)
			{
				m_issuerSerials = new ArrayList();
			}
			m_issuerSerials.Add(new X509IssuerSerial(issuerName, serialNumber));
		}

		private void Clear()
		{
			m_CRL = null;
			if (m_subjectKeyIds != null)
			{
				m_subjectKeyIds.Clear();
			}
			if (m_subjectNames != null)
			{
				m_subjectNames.Clear();
			}
			if (m_issuerSerials != null)
			{
				m_issuerSerials.Clear();
			}
			if (m_certificates != null)
			{
				m_certificates.Clear();
			}
		}

		/// <summary>Returns an XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</summary>
		/// <returns>An XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</returns>
		public override XmlElement GetXml()
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal override XmlElement GetXml(XmlDocument xmlDocument)
		{
			XmlElement xmlElement = xmlDocument.CreateElement("X509Data", "http://www.w3.org/2000/09/xmldsig#");
			if (m_issuerSerials != null)
			{
				foreach (X509IssuerSerial issuerSerial in m_issuerSerials)
				{
					XmlElement xmlElement2 = xmlDocument.CreateElement("X509IssuerSerial", "http://www.w3.org/2000/09/xmldsig#");
					XmlElement xmlElement3 = xmlDocument.CreateElement("X509IssuerName", "http://www.w3.org/2000/09/xmldsig#");
					xmlElement3.AppendChild(xmlDocument.CreateTextNode(issuerSerial.IssuerName));
					xmlElement2.AppendChild(xmlElement3);
					XmlElement xmlElement4 = xmlDocument.CreateElement("X509SerialNumber", "http://www.w3.org/2000/09/xmldsig#");
					xmlElement4.AppendChild(xmlDocument.CreateTextNode(issuerSerial.SerialNumber));
					xmlElement2.AppendChild(xmlElement4);
					xmlElement.AppendChild(xmlElement2);
				}
			}
			if (m_subjectKeyIds != null)
			{
				foreach (byte[] subjectKeyId in m_subjectKeyIds)
				{
					XmlElement xmlElement5 = xmlDocument.CreateElement("X509SKI", "http://www.w3.org/2000/09/xmldsig#");
					xmlElement5.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(subjectKeyId)));
					xmlElement.AppendChild(xmlElement5);
				}
			}
			if (m_subjectNames != null)
			{
				foreach (string subjectName in m_subjectNames)
				{
					XmlElement xmlElement6 = xmlDocument.CreateElement("X509SubjectName", "http://www.w3.org/2000/09/xmldsig#");
					xmlElement6.AppendChild(xmlDocument.CreateTextNode(subjectName));
					xmlElement.AppendChild(xmlElement6);
				}
			}
			if (m_certificates != null)
			{
				foreach (X509Certificate certificate in m_certificates)
				{
					XmlElement xmlElement7 = xmlDocument.CreateElement("X509Certificate", "http://www.w3.org/2000/09/xmldsig#");
					xmlElement7.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(certificate.GetRawCertData())));
					xmlElement.AppendChild(xmlElement7);
				}
			}
			if (m_CRL != null)
			{
				XmlElement xmlElement8 = xmlDocument.CreateElement("X509CRL", "http://www.w3.org/2000/09/xmldsig#");
				xmlElement8.AppendChild(xmlDocument.CreateTextNode(Convert.ToBase64String(m_CRL)));
				xmlElement.AppendChild(xmlElement8);
			}
			return xmlElement;
		}

		/// <summary>Parses the input <see cref="T:System.Xml.XmlElement" /> object and configures the internal state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object to match.</summary>
		/// <param name="element">The <see cref="T:System.Xml.XmlElement" /> object that specifies the state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoX509Data" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="element" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="element" /> parameter does not contain an &lt;<see langword="X509IssuerName" />&gt; node.  
		///  -or-  
		///  The <paramref name="element" /> parameter does not contain an &lt;<see langword="X509SerialNumber" />&gt; node.</exception>
		public override void LoadXml(XmlElement element)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(element.OwnerDocument.NameTable);
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			XmlNodeList xmlNodeList = element.SelectNodes("ds:X509IssuerSerial", xmlNamespaceManager);
			XmlNodeList xmlNodeList2 = element.SelectNodes("ds:X509SKI", xmlNamespaceManager);
			XmlNodeList xmlNodeList3 = element.SelectNodes("ds:X509SubjectName", xmlNamespaceManager);
			XmlNodeList xmlNodeList4 = element.SelectNodes("ds:X509Certificate", xmlNamespaceManager);
			XmlNodeList xmlNodeList5 = element.SelectNodes("ds:X509CRL", xmlNamespaceManager);
			if (xmlNodeList5.Count == 0 && xmlNodeList.Count == 0 && xmlNodeList2.Count == 0 && xmlNodeList3.Count == 0 && xmlNodeList4.Count == 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "X509Data");
			}
			Clear();
			if (xmlNodeList5.Count != 0)
			{
				m_CRL = Convert.FromBase64String(Utils.DiscardWhiteSpaces(xmlNodeList5.Item(0).InnerText));
			}
			foreach (XmlNode item in xmlNodeList)
			{
				XmlNode xmlNode2 = item.SelectSingleNode("ds:X509IssuerName", xmlNamespaceManager);
				XmlNode xmlNode3 = item.SelectSingleNode("ds:X509SerialNumber", xmlNamespaceManager);
				if (xmlNode2 == null || xmlNode3 == null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "IssuerSerial");
				}
				InternalAddIssuerSerial(xmlNode2.InnerText.Trim(), xmlNode3.InnerText.Trim());
			}
			foreach (XmlNode item2 in xmlNodeList2)
			{
				AddSubjectKeyId(Convert.FromBase64String(Utils.DiscardWhiteSpaces(item2.InnerText)));
			}
			foreach (XmlNode item3 in xmlNodeList3)
			{
				AddSubjectName(item3.InnerText.Trim());
			}
			foreach (XmlNode item4 in xmlNodeList4)
			{
				AddCertificate(new X509Certificate2(Convert.FromBase64String(Utils.DiscardWhiteSpaces(item4.InnerText))));
			}
		}
	}
	/// <summary>Handles <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> subelements that do not have specific implementations or handlers registered on the machine.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class KeyInfoNode : KeyInfoClause
	{
		private XmlElement m_node;

		/// <summary>Gets or sets the XML content of the current <see cref="T:System.Security.Cryptography.Xml.KeyInfoNode" />.</summary>
		/// <returns>The XML content of the current <see cref="T:System.Security.Cryptography.Xml.KeyInfoNode" />.</returns>
		public XmlElement Value
		{
			get
			{
				return m_node;
			}
			set
			{
				m_node = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoNode" /> class.</summary>
		public KeyInfoNode()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoNode" /> class with content taken from the specified <see cref="T:System.Xml.XmlElement" />.</summary>
		/// <param name="node">An XML element from which to take the content used to create the new instance of <see cref="T:System.Security.Cryptography.Xml.KeyInfoNode" />.</param>
		public KeyInfoNode(XmlElement node)
		{
			m_node = node;
		}

		/// <summary>Returns an XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoNode" />.</summary>
		/// <returns>An XML representation of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoNode" />.</returns>
		public override XmlElement GetXml()
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal override XmlElement GetXml(XmlDocument xmlDocument)
		{
			return xmlDocument.ImportNode(m_node, deep: true) as XmlElement;
		}

		/// <summary>Parses the input <see cref="T:System.Xml.XmlElement" /> and configures the internal state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoNode" /> to match.</summary>
		/// <param name="value">The <see cref="T:System.Xml.XmlElement" /> that specifies the state of the <see cref="T:System.Security.Cryptography.Xml.KeyInfoNode" />.</param>
		public override void LoadXml(XmlElement value)
		{
			m_node = value;
		}
	}
	[Serializable]
	internal enum ReferenceTargetType
	{
		Stream,
		XmlElement,
		UriReference
	}
	/// <summary>Represents the <see langword="&lt;reference&gt;" /> element of an XML signature.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class Reference
	{
		private string m_id;

		private string m_uri;

		private string m_type;

		private TransformChain m_transformChain;

		private string m_digestMethod;

		private byte[] m_digestValue;

		private HashAlgorithm m_hashAlgorithm;

		private object m_refTarget;

		private ReferenceTargetType m_refTargetType;

		private XmlElement m_cachedXml;

		private SignedXml m_signedXml;

		internal CanonicalXmlNodeList m_namespaces;

		/// <summary>Gets or sets the ID of the current <see cref="T:System.Security.Cryptography.Xml.Reference" />.</summary>
		/// <returns>The ID of the current <see cref="T:System.Security.Cryptography.Xml.Reference" />. The default is <see langword="null" />.</returns>
		public string Id
		{
			get
			{
				return m_id;
			}
			set
			{
				m_id = value;
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Uri" /> of the current <see cref="T:System.Security.Cryptography.Xml.Reference" />.</summary>
		/// <returns>The <see cref="T:System.Uri" /> of the current <see cref="T:System.Security.Cryptography.Xml.Reference" />.</returns>
		public string Uri
		{
			get
			{
				return m_uri;
			}
			set
			{
				m_uri = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the type of the object being signed.</summary>
		/// <returns>The type of the object being signed.</returns>
		public string Type
		{
			get
			{
				return m_type;
			}
			set
			{
				m_type = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the digest method Uniform Resource Identifier (URI) of the current <see cref="T:System.Security.Cryptography.Xml.Reference" />.</summary>
		/// <returns>The digest method URI of the current <see cref="T:System.Security.Cryptography.Xml.Reference" />. The default value is "http://www.w3.org/2000/09/xmldsig#sha1".</returns>
		public string DigestMethod
		{
			get
			{
				return m_digestMethod;
			}
			set
			{
				m_digestMethod = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the digest value of the current <see cref="T:System.Security.Cryptography.Xml.Reference" />.</summary>
		/// <returns>The digest value of the current <see cref="T:System.Security.Cryptography.Xml.Reference" />.</returns>
		public byte[] DigestValue
		{
			get
			{
				return m_digestValue;
			}
			set
			{
				m_digestValue = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets the transform chain of the current <see cref="T:System.Security.Cryptography.Xml.Reference" />.</summary>
		/// <returns>The transform chain of the current <see cref="T:System.Security.Cryptography.Xml.Reference" />.</returns>
		public TransformChain TransformChain
		{
			get
			{
				if (m_transformChain == null)
				{
					m_transformChain = new TransformChain();
				}
				return m_transformChain;
			}
			[ComVisible(false)]
			set
			{
				m_transformChain = value;
				m_cachedXml = null;
			}
		}

		internal bool CacheValid => m_cachedXml != null;

		internal SignedXml SignedXml
		{
			get
			{
				return m_signedXml;
			}
			set
			{
				m_signedXml = value;
			}
		}

		internal ReferenceTargetType ReferenceTargetType => m_refTargetType;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.Reference" /> class with default properties.</summary>
		public Reference()
		{
			m_transformChain = new TransformChain();
			m_refTarget = null;
			m_refTargetType = ReferenceTargetType.UriReference;
			m_cachedXml = null;
			m_digestMethod = SignedXml.XmlDsigDigestDefault;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.Reference" /> class with a hash value of the specified <see cref="T:System.IO.Stream" />.</summary>
		/// <param name="stream">The <see cref="T:System.IO.Stream" /> with which to initialize the new instance of <see cref="T:System.Security.Cryptography.Xml.Reference" />.</param>
		public Reference(Stream stream)
		{
			m_transformChain = new TransformChain();
			m_refTarget = stream;
			m_refTargetType = ReferenceTargetType.Stream;
			m_cachedXml = null;
			m_digestMethod = SignedXml.XmlDsigDigestDefault;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.Reference" /> class with the specified <see cref="T:System.Uri" />.</summary>
		/// <param name="uri">The <see cref="T:System.Uri" /> with which to initialize the new instance of <see cref="T:System.Security.Cryptography.Xml.Reference" />.</param>
		public Reference(string uri)
		{
			m_transformChain = new TransformChain();
			m_refTarget = uri;
			m_uri = uri;
			m_refTargetType = ReferenceTargetType.UriReference;
			m_cachedXml = null;
			m_digestMethod = SignedXml.XmlDsigDigestDefault;
		}

		internal Reference(XmlElement element)
		{
			m_transformChain = new TransformChain();
			m_refTarget = element;
			m_refTargetType = ReferenceTargetType.XmlElement;
			m_cachedXml = null;
			m_digestMethod = SignedXml.XmlDsigDigestDefault;
		}

		/// <summary>Returns the XML representation of the <see cref="T:System.Security.Cryptography.Xml.Reference" />.</summary>
		/// <returns>The XML representation of the <see cref="T:System.Security.Cryptography.Xml.Reference" />.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.Reference.DigestMethod" /> property is <see langword="null" />.  
		///  -or-  
		///  The <see cref="P:System.Security.Cryptography.Xml.Reference.DigestValue" /> property is <see langword="null" />.</exception>
		public XmlElement GetXml()
		{
			if (CacheValid)
			{
				return m_cachedXml;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument document)
		{
			XmlElement xmlElement = document.CreateElement("Reference", "http://www.w3.org/2000/09/xmldsig#");
			if (!string.IsNullOrEmpty(m_id))
			{
				xmlElement.SetAttribute("Id", m_id);
			}
			if (m_uri != null)
			{
				xmlElement.SetAttribute("URI", m_uri);
			}
			if (!string.IsNullOrEmpty(m_type))
			{
				xmlElement.SetAttribute("Type", m_type);
			}
			if (TransformChain.Count != 0)
			{
				xmlElement.AppendChild(TransformChain.GetXml(document, "http://www.w3.org/2000/09/xmldsig#"));
			}
			if (string.IsNullOrEmpty(m_digestMethod))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_DigestMethodRequired"));
			}
			XmlElement xmlElement2 = document.CreateElement("DigestMethod", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement2.SetAttribute("Algorithm", m_digestMethod);
			xmlElement.AppendChild(xmlElement2);
			if (DigestValue == null)
			{
				if (m_hashAlgorithm.Hash == null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_DigestValueRequired"));
				}
				DigestValue = m_hashAlgorithm.Hash;
			}
			XmlElement xmlElement3 = document.CreateElement("DigestValue", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement3.AppendChild(document.CreateTextNode(Convert.ToBase64String(m_digestValue)));
			xmlElement.AppendChild(xmlElement3);
			return xmlElement;
		}

		/// <summary>Loads a <see cref="T:System.Security.Cryptography.Xml.Reference" /> state from an XML element.</summary>
		/// <param name="value">The XML element from which to load the <see cref="T:System.Security.Cryptography.Xml.Reference" /> state.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="value" /> parameter does not contain any transforms.  
		///  -or-  
		///  The <paramref name="value" /> parameter contains an unknown transform.</exception>
		public void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			m_id = Utils.GetAttribute(value, "Id", "http://www.w3.org/2000/09/xmldsig#");
			m_uri = Utils.GetAttribute(value, "URI", "http://www.w3.org/2000/09/xmldsig#");
			m_type = Utils.GetAttribute(value, "Type", "http://www.w3.org/2000/09/xmldsig#");
			if (!Utils.VerifyAttributes(value, new string[3] { "Id", "URI", "Type" }))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference");
			}
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(value.OwnerDocument.NameTable);
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			bool flag = false;
			TransformChain = new TransformChain();
			XmlNodeList xmlNodeList = value.SelectNodes("ds:Transforms", xmlNamespaceManager);
			if (xmlNodeList != null && xmlNodeList.Count != 0)
			{
				if (!Utils.GetAllowAdditionalSignatureNodes() && xmlNodeList.Count > 1)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference/Transforms");
				}
				flag = true;
				XmlElement xmlElement = xmlNodeList[0] as XmlElement;
				if (!Utils.VerifyAttributes(xmlElement, (string[])null))
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference/Transforms");
				}
				XmlNodeList xmlNodeList2 = xmlElement.SelectNodes("ds:Transform", xmlNamespaceManager);
				if (xmlNodeList2 != null)
				{
					if (!Utils.GetAllowAdditionalSignatureNodes() && xmlNodeList2.Count != xmlElement.SelectNodes("*").Count)
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference/Transforms");
					}
					if (xmlNodeList2.Count > Utils.GetMaxTransformsPerReference())
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference/Transforms");
					}
					foreach (XmlNode item in xmlNodeList2)
					{
						XmlElement xmlElement2 = item as XmlElement;
						string attribute = Utils.GetAttribute(xmlElement2, "Algorithm", "http://www.w3.org/2000/09/xmldsig#");
						if ((attribute == null && !Utils.GetSkipSignatureAttributeEnforcement()) || !Utils.VerifyAttributes(xmlElement2, "Algorithm"))
						{
							throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
						}
						Transform transform = Utils.CreateFromName<Transform>(attribute);
						if (transform == null)
						{
							throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
						}
						AddTransform(transform);
						transform.LoadInnerXml(xmlElement2.ChildNodes);
						if (!(transform is XmlDsigEnvelopedSignatureTransform))
						{
							continue;
						}
						XmlNode xmlNode2 = xmlElement2.SelectSingleNode("ancestor::ds:Signature[1]", xmlNamespaceManager);
						XmlNodeList xmlNodeList3 = xmlElement2.SelectNodes("//ds:Signature", xmlNamespaceManager);
						if (xmlNodeList3 == null)
						{
							continue;
						}
						int num = 0;
						foreach (XmlNode item2 in xmlNodeList3)
						{
							num++;
							if (item2 == xmlNode2)
							{
								((XmlDsigEnvelopedSignatureTransform)transform).SignaturePosition = num;
								break;
							}
						}
					}
				}
			}
			XmlNodeList xmlNodeList4 = value.SelectNodes("ds:DigestMethod", xmlNamespaceManager);
			if (xmlNodeList4 == null || xmlNodeList4.Count == 0 || (!Utils.GetAllowAdditionalSignatureNodes() && xmlNodeList4.Count > 1))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference/DigestMethod");
			}
			XmlElement element = xmlNodeList4[0] as XmlElement;
			m_digestMethod = Utils.GetAttribute(element, "Algorithm", "http://www.w3.org/2000/09/xmldsig#");
			if ((m_digestMethod == null && !Utils.GetSkipSignatureAttributeEnforcement()) || !Utils.VerifyAttributes(element, "Algorithm"))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference/DigestMethod");
			}
			XmlNodeList xmlNodeList5 = value.SelectNodes("ds:DigestValue", xmlNamespaceManager);
			if (xmlNodeList5 == null || xmlNodeList5.Count == 0 || (!Utils.GetAllowAdditionalSignatureNodes() && xmlNodeList5.Count > 1))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference/DigestValue");
			}
			XmlElement xmlElement3 = xmlNodeList5[0] as XmlElement;
			m_digestValue = Convert.FromBase64String(Utils.DiscardWhiteSpaces(xmlElement3.InnerText));
			if (!Utils.VerifyAttributes(xmlElement3, (string[])null))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference/DigestValue");
			}
			int num2 = (flag ? 3 : 2);
			if (!Utils.GetAllowAdditionalSignatureNodes() && value.SelectNodes("*").Count != num2)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference");
			}
			m_cachedXml = value;
		}

		/// <summary>Adds a <see cref="T:System.Security.Cryptography.Xml.Transform" /> object to the list of transforms to be performed on the data before passing it to the digest algorithm.</summary>
		/// <param name="transform">The transform to be added to the list of transforms.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="transform" /> parameter is <see langword="null" />.</exception>
		public void AddTransform(Transform transform)
		{
			if (transform == null)
			{
				throw new ArgumentNullException("transform");
			}
			transform.Reference = this;
			TransformChain.Add(transform);
		}

		internal void UpdateHashValue(XmlDocument document, CanonicalXmlNodeList refList)
		{
			DigestValue = CalculateHashValue(document, refList);
		}

		internal byte[] CalculateHashValue(XmlDocument document, CanonicalXmlNodeList refList)
		{
			m_hashAlgorithm = Utils.CreateFromName<HashAlgorithm>(m_digestMethod);
			if (m_hashAlgorithm == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CreateHashAlgorithmFailed"));
			}
			string text = ((document == null) ? (Environment.CurrentDirectory + "\\") : document.BaseURI);
			Stream stream = null;
			WebRequest webRequest = null;
			WebResponse webResponse = null;
			Stream stream2 = null;
			XmlResolver xmlResolver = null;
			byte[] array = null;
			try
			{
				switch (m_refTargetType)
				{
				case ReferenceTargetType.Stream:
					xmlResolver = (SignedXml.ResolverSet ? SignedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), text));
					stream = TransformChain.TransformToOctetStream((Stream)m_refTarget, xmlResolver, text);
					break;
				case ReferenceTargetType.UriReference:
					if (m_uri == null)
					{
						xmlResolver = (SignedXml.ResolverSet ? SignedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), text));
						stream = TransformChain.TransformToOctetStream((Stream)null, xmlResolver, text);
						break;
					}
					if (m_uri.Length == 0)
					{
						if (document == null)
						{
							throw new CryptographicException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Cryptography_Xml_SelfReferenceRequiresContext"), new object[1] { m_uri }));
						}
						xmlResolver = (SignedXml.ResolverSet ? SignedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), text));
						XmlDocument document2 = Utils.DiscardComments(Utils.PreProcessDocumentInput(document, xmlResolver, text));
						stream = TransformChain.TransformToOctetStream(document2, xmlResolver, text);
						break;
					}
					if (m_uri[0] == '#')
					{
						bool discardComments = true;
						string idFromLocalUri = Utils.GetIdFromLocalUri(m_uri, out discardComments);
						if (idFromLocalUri == "xpointer(/)")
						{
							if (document == null)
							{
								throw new CryptographicException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Cryptography_Xml_SelfReferenceRequiresContext"), new object[1] { m_uri }));
							}
							xmlResolver = (SignedXml.ResolverSet ? SignedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), text));
							stream = TransformChain.TransformToOctetStream(Utils.PreProcessDocumentInput(document, xmlResolver, text), xmlResolver, text);
							break;
						}
						XmlElement xmlElement = SignedXml.GetIdElement(document, idFromLocalUri);
						if (xmlElement != null)
						{
							m_namespaces = Utils.GetPropagatedAttributes(xmlElement.ParentNode as XmlElement);
						}
						if (xmlElement == null && refList != null)
						{
							foreach (XmlNode @ref in refList)
							{
								if (@ref is XmlElement xmlElement2 && Utils.HasAttribute(xmlElement2, "Id", "http://www.w3.org/2000/09/xmldsig#") && Utils.GetAttribute(xmlElement2, "Id", "http://www.w3.org/2000/09/xmldsig#").Equals(idFromLocalUri))
								{
									xmlElement = xmlElement2;
									if (m_signedXml.m_context != null)
									{
										m_namespaces = Utils.GetPropagatedAttributes(m_signedXml.m_context);
									}
									break;
								}
							}
						}
						if (xmlElement == null)
						{
							throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidReference"));
						}
						XmlDocument xmlDocument = Utils.PreProcessElementInput(xmlElement, xmlResolver, text);
						Utils.AddNamespaces(xmlDocument.DocumentElement, m_namespaces);
						xmlResolver = (SignedXml.ResolverSet ? SignedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), text));
						if (discardComments)
						{
							XmlDocument document3 = Utils.DiscardComments(xmlDocument);
							stream = TransformChain.TransformToOctetStream(document3, xmlResolver, text);
						}
						else
						{
							stream = TransformChain.TransformToOctetStream(xmlDocument, xmlResolver, text);
						}
						break;
					}
					if (Utils.AllowDetachedSignature())
					{
						Uri uri = new Uri(m_uri, UriKind.RelativeOrAbsolute);
						if (!uri.IsAbsoluteUri)
						{
							uri = new Uri(new Uri(text), uri);
						}
						webRequest = WebRequest.Create(uri);
						if (webRequest != null)
						{
							webResponse = webRequest.GetResponse();
							if (webResponse != null)
							{
								stream2 = webResponse.GetResponseStream();
								if (stream2 != null)
								{
									xmlResolver = (SignedXml.ResolverSet ? SignedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), text));
									stream = TransformChain.TransformToOctetStream(stream2, xmlResolver, m_uri);
									break;
								}
							}
						}
						goto default;
					}
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriNotResolved"), m_uri);
				case ReferenceTargetType.XmlElement:
					xmlResolver = (SignedXml.ResolverSet ? SignedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), text));
					stream = TransformChain.TransformToOctetStream(Utils.PreProcessElementInput((XmlElement)m_refTarget, xmlResolver, text), xmlResolver, text);
					break;
				default:
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriNotResolved"), m_uri);
				}
				stream = SignedXmlDebugLog.LogReferenceData(this, stream);
				return m_hashAlgorithm.ComputeHash(stream);
			}
			finally
			{
				stream?.Close();
				webResponse?.Close();
				stream2?.Close();
			}
		}
	}
	/// <summary>Represents the <see langword="&lt;Signature&gt;" /> element of an XML signature.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class Signature
	{
		private string m_id;

		private SignedInfo m_signedInfo;

		private byte[] m_signatureValue;

		private string m_signatureValueId;

		private KeyInfo m_keyInfo;

		private IList m_embeddedObjects;

		private CanonicalXmlNodeList m_referencedItems;

		private SignedXml m_signedXml;

		internal SignedXml SignedXml
		{
			get
			{
				return m_signedXml;
			}
			set
			{
				m_signedXml = value;
			}
		}

		/// <summary>Gets or sets the ID of the current <see cref="T:System.Security.Cryptography.Xml.Signature" />.</summary>
		/// <returns>The ID of the current <see cref="T:System.Security.Cryptography.Xml.Signature" />. The default is <see langword="null" />.</returns>
		public string Id
		{
			get
			{
				return m_id;
			}
			set
			{
				m_id = value;
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> of the current <see cref="T:System.Security.Cryptography.Xml.Signature" />.</summary>
		/// <returns>The <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> of the current <see cref="T:System.Security.Cryptography.Xml.Signature" />.</returns>
		public SignedInfo SignedInfo
		{
			get
			{
				return m_signedInfo;
			}
			set
			{
				m_signedInfo = value;
				if (SignedXml != null && m_signedInfo != null)
				{
					m_signedInfo.SignedXml = SignedXml;
				}
			}
		}

		/// <summary>Gets or sets the value of the digital signature.</summary>
		/// <returns>A byte array that contains the value of the digital signature.</returns>
		public byte[] SignatureValue
		{
			get
			{
				return m_signatureValue;
			}
			set
			{
				m_signatureValue = value;
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> of the current <see cref="T:System.Security.Cryptography.Xml.Signature" />.</summary>
		/// <returns>The <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> of the current <see cref="T:System.Security.Cryptography.Xml.Signature" />.</returns>
		public KeyInfo KeyInfo
		{
			get
			{
				if (m_keyInfo == null)
				{
					m_keyInfo = new KeyInfo();
				}
				return m_keyInfo;
			}
			set
			{
				m_keyInfo = value;
			}
		}

		/// <summary>Gets or sets a list of objects to be signed.</summary>
		/// <returns>A list of objects to be signed.</returns>
		public IList ObjectList
		{
			get
			{
				return m_embeddedObjects;
			}
			set
			{
				m_embeddedObjects = value;
			}
		}

		internal CanonicalXmlNodeList ReferencedItems => m_referencedItems;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.Signature" /> class.</summary>
		public Signature()
		{
			m_embeddedObjects = new ArrayList();
			m_referencedItems = new CanonicalXmlNodeList();
		}

		/// <summary>Returns the XML representation of the <see cref="T:System.Security.Cryptography.Xml.Signature" />.</summary>
		/// <returns>The XML representation of the <see cref="T:System.Security.Cryptography.Xml.Signature" />.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.Signature.SignedInfo" /> property is <see langword="null" />.  
		///  -or-  
		///  The <see cref="P:System.Security.Cryptography.Xml.Signature.SignatureValue" /> property is <see langword="null" />.</exception>
		public XmlElement GetXml()
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument document)
		{
			XmlElement xmlElement = document.CreateElement("Signature", "http://www.w3.org/2000/09/xmldsig#");
			if (!string.IsNullOrEmpty(m_id))
			{
				xmlElement.SetAttribute("Id", m_id);
			}
			if (m_signedInfo == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignedInfoRequired"));
			}
			xmlElement.AppendChild(m_signedInfo.GetXml(document));
			if (m_signatureValue == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureValueRequired"));
			}
			XmlElement xmlElement2 = document.CreateElement("SignatureValue", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement2.AppendChild(document.CreateTextNode(Convert.ToBase64String(m_signatureValue)));
			if (!string.IsNullOrEmpty(m_signatureValueId))
			{
				xmlElement2.SetAttribute("Id", m_signatureValueId);
			}
			xmlElement.AppendChild(xmlElement2);
			if (KeyInfo.Count > 0)
			{
				xmlElement.AppendChild(KeyInfo.GetXml(document));
			}
			foreach (object embeddedObject in m_embeddedObjects)
			{
				if (embeddedObject is DataObject dataObject)
				{
					xmlElement.AppendChild(dataObject.GetXml(document));
				}
			}
			return xmlElement;
		}

		/// <summary>Loads a <see cref="T:System.Security.Cryptography.Xml.Signature" /> state from an XML element.</summary>
		/// <param name="value">The XML element from which to load the <see cref="T:System.Security.Cryptography.Xml.Signature" /> state.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="value" /> parameter does not contain a valid <see cref="P:System.Security.Cryptography.Xml.Signature.SignatureValue" />.  
		///  -or-  
		///  The <paramref name="value" /> parameter does not contain a valid <see cref="P:System.Security.Cryptography.Xml.Signature.SignedInfo" />.</exception>
		public void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (!value.LocalName.Equals("Signature"))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Signature");
			}
			m_id = Utils.GetAttribute(value, "Id", "http://www.w3.org/2000/09/xmldsig#");
			if (!Utils.VerifyAttributes(value, "Id"))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Signature");
			}
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(value.OwnerDocument.NameTable);
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			int num = 0;
			XmlNodeList xmlNodeList = value.SelectNodes("ds:SignedInfo", xmlNamespaceManager);
			if (xmlNodeList == null || xmlNodeList.Count == 0 || (!Utils.GetAllowAdditionalSignatureNodes() && xmlNodeList.Count > 1))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignedInfo");
			}
			XmlElement value2 = xmlNodeList[0] as XmlElement;
			num += xmlNodeList.Count;
			SignedInfo = new SignedInfo();
			SignedInfo.LoadXml(value2);
			XmlNodeList xmlNodeList2 = value.SelectNodes("ds:SignatureValue", xmlNamespaceManager);
			if (xmlNodeList2 == null || xmlNodeList2.Count == 0 || (!Utils.GetAllowAdditionalSignatureNodes() && xmlNodeList2.Count > 1))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignatureValue");
			}
			XmlElement xmlElement = xmlNodeList2[0] as XmlElement;
			num += xmlNodeList2.Count;
			m_signatureValue = Convert.FromBase64String(Utils.DiscardWhiteSpaces(xmlElement.InnerText));
			m_signatureValueId = Utils.GetAttribute(xmlElement, "Id", "http://www.w3.org/2000/09/xmldsig#");
			if (!Utils.VerifyAttributes(xmlElement, "Id"))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignatureValue");
			}
			XmlNodeList xmlNodeList3 = value.SelectNodes("ds:KeyInfo", xmlNamespaceManager);
			m_keyInfo = new KeyInfo();
			if (xmlNodeList3 != null)
			{
				if (!Utils.GetAllowAdditionalSignatureNodes() && xmlNodeList3.Count > 1)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "KeyInfo");
				}
				foreach (XmlNode item in xmlNodeList3)
				{
					if (item is XmlElement value3)
					{
						m_keyInfo.LoadXml(value3);
					}
				}
				num += xmlNodeList3.Count;
			}
			XmlNodeList xmlNodeList4 = value.SelectNodes("ds:Object", xmlNamespaceManager);
			m_embeddedObjects.Clear();
			if (xmlNodeList4 != null)
			{
				foreach (XmlNode item2 in xmlNodeList4)
				{
					if (item2 is XmlElement value4)
					{
						DataObject dataObject = new DataObject();
						dataObject.LoadXml(value4);
						m_embeddedObjects.Add(dataObject);
					}
				}
				num += xmlNodeList4.Count;
			}
			XmlNodeList xmlNodeList5 = value.SelectNodes("//*[@Id]", xmlNamespaceManager);
			if (xmlNodeList5 != null)
			{
				foreach (XmlNode item3 in xmlNodeList5)
				{
					m_referencedItems.Add(item3);
				}
			}
			if (!Utils.GetAllowAdditionalSignatureNodes() && value.SelectNodes("*").Count != num)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Signature");
			}
		}

		/// <summary>Adds a <see cref="T:System.Security.Cryptography.Xml.DataObject" /> to the list of objects to be signed.</summary>
		/// <param name="dataObject">The <see cref="T:System.Security.Cryptography.Xml.DataObject" /> to be added to the list of objects to be signed.</param>
		public void AddObject(DataObject dataObject)
		{
			m_embeddedObjects.Add(dataObject);
		}
	}
	/// <summary>Contains information about the canonicalization algorithm and signature algorithm used for the XML signature.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class SignedInfo : ICollection, IEnumerable
	{
		private string m_id;

		private string m_canonicalizationMethod;

		private string m_signatureMethod;

		private string m_signatureLength;

		private ArrayList m_references;

		private XmlElement m_cachedXml;

		private SignedXml m_signedXml;

		private Transform m_canonicalizationMethodTransform;

		internal SignedXml SignedXml
		{
			get
			{
				return m_signedXml;
			}
			set
			{
				m_signedXml = value;
			}
		}

		/// <summary>Gets the number of references in the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</summary>
		/// <returns>The number of references in the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</returns>
		/// <exception cref="T:System.NotSupportedException">This property is not supported.</exception>
		public int Count
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		/// <summary>Gets a value that indicates whether the collection is read-only.</summary>
		/// <returns>
		///   <see langword="true" /> if the collection is read-only; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.NotSupportedException">This property is not supported.</exception>
		public bool IsReadOnly
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		/// <summary>Gets a value that indicates whether the collection is synchronized.</summary>
		/// <returns>
		///   <see langword="true" /> if the collection is synchronized; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.NotSupportedException">This property is not supported.</exception>
		public bool IsSynchronized
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		/// <summary>Gets an object to use for synchronization.</summary>
		/// <returns>An object to use for synchronization.</returns>
		/// <exception cref="T:System.NotSupportedException">This property is not supported.</exception>
		public object SyncRoot
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		/// <summary>Gets or sets the ID of the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</summary>
		/// <returns>The ID of the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</returns>
		public string Id
		{
			get
			{
				return m_id;
			}
			set
			{
				m_id = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the canonicalization algorithm that is used before signing for the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</summary>
		/// <returns>The canonicalization algorithm used before signing for the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</returns>
		public string CanonicalizationMethod
		{
			get
			{
				if (m_canonicalizationMethod == null)
				{
					return "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";
				}
				return m_canonicalizationMethod;
			}
			set
			{
				m_canonicalizationMethod = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.Xml.Transform" /> object used for canonicalization.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Xml.Transform" /> object used for canonicalization.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///   <see cref="T:System.Security.Cryptography.Xml.Transform" /> is <see langword="null" />.</exception>
		[ComVisible(false)]
		public Transform CanonicalizationMethodObject
		{
			get
			{
				if (m_canonicalizationMethodTransform == null)
				{
					m_canonicalizationMethodTransform = Utils.CreateFromName<Transform>(CanonicalizationMethod);
					if (m_canonicalizationMethodTransform == null)
					{
						throw new CryptographicException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Cryptography_Xml_CreateTransformFailed"), new object[1] { CanonicalizationMethod }));
					}
					m_canonicalizationMethodTransform.SignedXml = SignedXml;
					m_canonicalizationMethodTransform.Reference = null;
				}
				return m_canonicalizationMethodTransform;
			}
		}

		/// <summary>Gets or sets the name of the algorithm used for signature generation and validation for the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</summary>
		/// <returns>The name of the algorithm used for signature generation and validation for the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</returns>
		public string SignatureMethod
		{
			get
			{
				return m_signatureMethod;
			}
			set
			{
				m_signatureMethod = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets or sets the length of the signature for the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</summary>
		/// <returns>The length of the signature for the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</returns>
		public string SignatureLength
		{
			get
			{
				return m_signatureLength;
			}
			set
			{
				m_signatureLength = value;
				m_cachedXml = null;
			}
		}

		/// <summary>Gets a list of the <see cref="T:System.Security.Cryptography.Xml.Reference" /> objects of the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</summary>
		/// <returns>A list of the <see cref="T:System.Security.Cryptography.Xml.Reference" /> elements of the current <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</returns>
		public ArrayList References => m_references;

		internal bool CacheValid
		{
			get
			{
				if (m_cachedXml == null)
				{
					return false;
				}
				foreach (Reference reference in References)
				{
					if (!reference.CacheValid)
					{
						return false;
					}
				}
				return true;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> class.</summary>
		public SignedInfo()
		{
			m_references = new ArrayList();
		}

		/// <summary>Returns an enumerator that iterates through the collection of references.</summary>
		/// <returns>An enumerator that iterates through the collection of references.</returns>
		/// <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
		public IEnumerator GetEnumerator()
		{
			throw new NotSupportedException();
		}

		/// <summary>Copies the elements of this instance into an <see cref="T:System.Array" /> object, starting at a specified index in the array.</summary>
		/// <param name="array">An <see cref="T:System.Array" /> object that holds the collection's elements.</param>
		/// <param name="index">The beginning index in the array where the elements are copied.</param>
		/// <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
		public void CopyTo(Array array, int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>Returns the XML representation of the <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object.</summary>
		/// <returns>The XML representation of the <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> instance.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.SignedInfo.SignatureMethod" /> property is <see langword="null" />.  
		///  -or-  
		///  The <see cref="P:System.Security.Cryptography.Xml.SignedInfo.References" /> property is empty.</exception>
		public XmlElement GetXml()
		{
			if (CacheValid)
			{
				return m_cachedXml;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument document)
		{
			XmlElement xmlElement = document.CreateElement("SignedInfo", "http://www.w3.org/2000/09/xmldsig#");
			if (!string.IsNullOrEmpty(m_id))
			{
				xmlElement.SetAttribute("Id", m_id);
			}
			XmlElement xml = CanonicalizationMethodObject.GetXml(document, "CanonicalizationMethod");
			xmlElement.AppendChild(xml);
			if (string.IsNullOrEmpty(m_signatureMethod))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureMethodRequired"));
			}
			XmlElement xmlElement2 = document.CreateElement("SignatureMethod", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement2.SetAttribute("Algorithm", m_signatureMethod);
			if (m_signatureLength != null)
			{
				XmlElement xmlElement3 = document.CreateElement(null, "HMACOutputLength", "http://www.w3.org/2000/09/xmldsig#");
				XmlText newChild = document.CreateTextNode(m_signatureLength);
				xmlElement3.AppendChild(newChild);
				xmlElement2.AppendChild(xmlElement3);
			}
			xmlElement.AppendChild(xmlElement2);
			if (m_references.Count == 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_ReferenceElementRequired"));
			}
			for (int i = 0; i < m_references.Count; i++)
			{
				Reference reference = (Reference)m_references[i];
				xmlElement.AppendChild(reference.GetXml(document));
			}
			return xmlElement;
		}

		/// <summary>Loads a <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> state from an XML element.</summary>
		/// <param name="value">The XML element from which to load the <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> state.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="value" /> parameter is not a valid <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> element.  
		///  -or-  
		///  The <paramref name="value" /> parameter does not contain a valid <see cref="P:System.Security.Cryptography.Xml.SignedInfo.CanonicalizationMethod" /> property.  
		///  -or-  
		///  The <paramref name="value" /> parameter does not contain a valid <see cref="P:System.Security.Cryptography.Xml.SignedInfo.SignatureMethod" /> property.</exception>
		public void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (!value.LocalName.Equals("SignedInfo"))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignedInfo");
			}
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(value.OwnerDocument.NameTable);
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			int num = 0;
			m_id = Utils.GetAttribute(value, "Id", "http://www.w3.org/2000/09/xmldsig#");
			if (!Utils.VerifyAttributes(value, "Id"))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignedInfo");
			}
			XmlNodeList xmlNodeList = value.SelectNodes("ds:CanonicalizationMethod", xmlNamespaceManager);
			if (xmlNodeList == null || xmlNodeList.Count == 0 || (!Utils.GetAllowAdditionalSignatureNodes() && xmlNodeList.Count > 1))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignedInfo/CanonicalizationMethod");
			}
			XmlElement xmlElement = xmlNodeList.Item(0) as XmlElement;
			num += xmlNodeList.Count;
			m_canonicalizationMethod = Utils.GetAttribute(xmlElement, "Algorithm", "http://www.w3.org/2000/09/xmldsig#");
			if ((m_canonicalizationMethod == null && !Utils.GetSkipSignatureAttributeEnforcement()) || !Utils.VerifyAttributes(xmlElement, "Algorithm"))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignedInfo/CanonicalizationMethod");
			}
			m_canonicalizationMethodTransform = null;
			if (xmlElement.ChildNodes.Count > 0)
			{
				CanonicalizationMethodObject.LoadInnerXml(xmlElement.ChildNodes);
			}
			XmlNodeList xmlNodeList2 = value.SelectNodes("ds:SignatureMethod", xmlNamespaceManager);
			if (xmlNodeList2 == null || xmlNodeList2.Count == 0 || (!Utils.GetAllowAdditionalSignatureNodes() && xmlNodeList2.Count > 1))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignedInfo/SignatureMethod");
			}
			XmlElement xmlElement2 = xmlNodeList2.Item(0) as XmlElement;
			num += xmlNodeList2.Count;
			m_signatureMethod = Utils.GetAttribute(xmlElement2, "Algorithm", "http://www.w3.org/2000/09/xmldsig#");
			if ((m_signatureMethod == null && !Utils.GetSkipSignatureAttributeEnforcement()) || !Utils.VerifyAttributes(xmlElement2, "Algorithm"))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignedInfo/SignatureMethod");
			}
			if (xmlElement2.SelectSingleNode("ds:HMACOutputLength", xmlNamespaceManager) is XmlElement xmlElement3)
			{
				m_signatureLength = xmlElement3.InnerXml;
			}
			m_references.Clear();
			XmlNodeList xmlNodeList3 = value.SelectNodes("ds:Reference", xmlNamespaceManager);
			if (xmlNodeList3 != null)
			{
				if (xmlNodeList3.Count > Utils.GetMaxReferencesPerSignedInfo())
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignedInfo/Reference");
				}
				foreach (XmlNode item in xmlNodeList3)
				{
					XmlElement value2 = item as XmlElement;
					Reference reference = new Reference();
					AddReference(reference);
					reference.LoadXml(value2);
				}
				num += xmlNodeList3.Count;
			}
			if (!Utils.GetAllowAdditionalSignatureNodes() && value.SelectNodes("*").Count != num)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignedInfo");
			}
			m_cachedXml = value;
		}

		/// <summary>Adds a <see cref="T:System.Security.Cryptography.Xml.Reference" /> object to the list of references to digest and sign.</summary>
		/// <param name="reference">The reference to add to the list of references.</param>
		/// <exception cref="T:System.ArgumentNullException">The reference parameter is <see langword="null" />.</exception>
		public void AddReference(Reference reference)
		{
			if (reference == null)
			{
				throw new ArgumentNullException("reference");
			}
			reference.SignedXml = SignedXml;
			m_references.Add(reference);
		}
	}
	/// <summary>Provides a wrapper on a core XML signature object to facilitate creating XML signatures.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class SignedXml
	{
		private class ReferenceLevelSortOrder : IComparer
		{
			private ArrayList m_references;

			public ArrayList References
			{
				get
				{
					return m_references;
				}
				set
				{
					m_references = value;
				}
			}

			public int Compare(object a, object b)
			{
				Reference reference = a as Reference;
				Reference reference2 = b as Reference;
				int index = 0;
				int index2 = 0;
				int num = 0;
				foreach (Reference reference3 in References)
				{
					if (reference3 == reference)
					{
						index = num;
					}
					if (reference3 == reference2)
					{
						index2 = num;
					}
					num++;
				}
				int referenceLevel = reference.SignedXml.GetReferenceLevel(index, References);
				int referenceLevel2 = reference2.SignedXml.GetReferenceLevel(index2, References);
				return referenceLevel.CompareTo(referenceLevel2);
			}
		}

		/// <summary>Represents the <see cref="T:System.Security.Cryptography.Xml.Signature" /> object of the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</summary>
		protected Signature m_signature;

		/// <summary>Represents the name of the installed key to be used for signing the <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</summary>
		protected string m_strSigningKeyName;

		private AsymmetricAlgorithm m_signingKey;

		private XmlDocument m_containingDocument;

		private IEnumerator m_keyInfoEnum;

		private X509Certificate2Collection m_x509Collection;

		private IEnumerator m_x509Enum;

		private bool[] m_refProcessed;

		private int[] m_refLevelCache;

		internal XmlResolver m_xmlResolver;

		internal XmlElement m_context;

		private bool m_bResolverSet;

		private Func<SignedXml, bool> m_signatureFormatValidator = DefaultSignatureFormatValidator;

		private Collection<string> m_safeCanonicalizationMethods;

		private static IList<string> s_knownCanonicalizationMethods = null;

		private static IList<string> s_defaultSafeTransformMethods = null;

		private const string XmlDsigMoreHMACMD5Url = "http://www.w3.org/2001/04/xmldsig-more#hmac-md5";

		private const string XmlDsigMoreHMACSHA256Url = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha256";

		private const string XmlDsigMoreHMACSHA384Url = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha384";

		private const string XmlDsigMoreHMACSHA512Url = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha512";

		private const string XmlDsigMoreHMACRIPEMD160Url = "http://www.w3.org/2001/04/xmldsig-more#hmac-ripemd160";

		private EncryptedXml m_exml;

		/// <summary>Represents the Uniform Resource Identifier (URI) for the standard namespace for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigNamespaceUrl = "http://www.w3.org/2000/09/xmldsig#";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the standard minimal canonicalization algorithm for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigMinimalCanonicalizationUrl = "http://www.w3.org/2000/09/xmldsig#minimal";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the standard canonicalization algorithm for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigCanonicalizationUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the standard canonicalization algorithm for XML digital signatures and includes comments. This field is constant.</summary>
		public const string XmlDsigCanonicalizationWithCommentsUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the standard <see cref="T:System.Security.Cryptography.SHA1" /> digest method for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigSHA1Url = "http://www.w3.org/2000/09/xmldsig#sha1";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the standard <see cref="T:System.Security.Cryptography.DSA" /> algorithm for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigDSAUrl = "http://www.w3.org/2000/09/xmldsig#dsa-sha1";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the standard <see cref="T:System.Security.Cryptography.RSA" /> signature method for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigRSASHA1Url = "http://www.w3.org/2000/09/xmldsig#rsa-sha1";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the standard <see cref="T:System.Security.Cryptography.HMACSHA1" /> algorithm for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigHMACSHA1Url = "http://www.w3.org/2000/09/xmldsig#hmac-sha1";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the standard <see cref="T:System.Security.Cryptography.SHA256" /> digest method for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigSHA256Url = "http://www.w3.org/2001/04/xmlenc#sha256";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the  <see cref="T:System.Security.Cryptography.RSA" /> SHA-256 signature method variation for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigRSASHA256Url = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the standard <see cref="T:System.Security.Cryptography.SHA384" /> digest method for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigSHA384Url = "http://www.w3.org/2001/04/xmldsig-more#sha384";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the  <see cref="T:System.Security.Cryptography.RSA" /> SHA-384 signature method variation for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigRSASHA384Url = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the standard <see cref="T:System.Security.Cryptography.SHA512" /> digest method for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigSHA512Url = "http://www.w3.org/2001/04/xmlenc#sha512";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the  <see cref="T:System.Security.Cryptography.RSA" /> SHA-512 signature method variation for XML digital signatures. This field is constant.</summary>
		public const string XmlDsigRSASHA512Url = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512";

		internal static readonly string XmlDsigDigestDefault = (LocalAppContextSwitches.XmlUseInsecureHashAlgorithms ? "http://www.w3.org/2000/09/xmldsig#sha1" : "http://www.w3.org/2001/04/xmlenc#sha256");

		internal static readonly string XmlDsigRSADefault = (LocalAppContextSwitches.XmlUseInsecureHashAlgorithms ? "http://www.w3.org/2000/09/xmldsig#rsa-sha1" : "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256");

		/// <summary>Represents the Uniform Resource Identifier (URI) for the Canonical XML transformation. This field is constant.</summary>
		public const string XmlDsigC14NTransformUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the Canonical XML transformation, with comments. This field is constant.</summary>
		public const string XmlDsigC14NWithCommentsTransformUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";

		/// <summary>Represents the Uniform Resource Identifier (URI) for exclusive XML canonicalization. This field is constant.</summary>
		public const string XmlDsigExcC14NTransformUrl = "http://www.w3.org/2001/10/xml-exc-c14n#";

		/// <summary>Represents the Uniform Resource Identifier (URI) for exclusive XML canonicalization, with comments. This field is constant.</summary>
		public const string XmlDsigExcC14NWithCommentsTransformUrl = "http://www.w3.org/2001/10/xml-exc-c14n#WithComments";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the base 64 transformation. This field is constant.</summary>
		public const string XmlDsigBase64TransformUrl = "http://www.w3.org/2000/09/xmldsig#base64";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the XML Path Language (XPath). This field is constant.</summary>
		public const string XmlDsigXPathTransformUrl = "http://www.w3.org/TR/1999/REC-xpath-19991116";

		/// <summary>Represents the Uniform Resource Identifier (URI) for XSLT transformations. This field is constant.</summary>
		public const string XmlDsigXsltTransformUrl = "http://www.w3.org/TR/1999/REC-xslt-19991116";

		/// <summary>Represents the Uniform Resource Identifier (URI) for enveloped signature transformation. This field is constant.</summary>
		public const string XmlDsigEnvelopedSignatureTransformUrl = "http://www.w3.org/2000/09/xmldsig#enveloped-signature";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the XML mode decryption transformation. This field is constant.</summary>
		public const string XmlDecryptionTransformUrl = "http://www.w3.org/2002/07/decrypt#XML";

		/// <summary>Represents the Uniform Resource Identifier (URI) for the license transform algorithm used to normalize XrML licenses for signatures.</summary>
		public const string XmlLicenseTransformUrl = "urn:mpeg:mpeg21:2003:01-REL-R-NS:licenseTransform";

		private bool bCacheValid;

		private byte[] _digestedSignedInfo;

		/// <summary>Gets or sets the name of the installed key to be used for signing the <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</summary>
		/// <returns>The name of the installed key to be used for signing the <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</returns>
		public string SigningKeyName
		{
			get
			{
				return m_strSigningKeyName;
			}
			set
			{
				m_strSigningKeyName = value;
			}
		}

		/// <summary>Sets the current <see cref="T:System.Xml.XmlResolver" /> object.</summary>
		/// <returns>The current <see cref="T:System.Xml.XmlResolver" /> object. The defaults is a <see cref="T:System.Xml.XmlSecureResolver" /> object.</returns>
		[ComVisible(false)]
		public XmlResolver Resolver
		{
			set
			{
				m_xmlResolver = value;
				m_bResolverSet = true;
			}
		}

		internal bool ResolverSet => m_bResolverSet;

		/// <summary>Gets a delegate that will be called to validate the format (not the cryptographic security) of an XML signature.</summary>
		/// <returns>
		///   <see langword="true" /> if the format is acceptable; otherwise, <see langword="false" />.</returns>
		public Func<SignedXml, bool> SignatureFormatValidator
		{
			get
			{
				return m_signatureFormatValidator;
			}
			set
			{
				m_signatureFormatValidator = value;
			}
		}

		/// <summary>Gets the names of methods whose canonicalization algorithms are explicitly allowed.</summary>
		/// <returns>A collection of the names of methods that safely produce canonical XML.</returns>
		public Collection<string> SafeCanonicalizationMethods => m_safeCanonicalizationMethods;

		/// <summary>Gets or sets the asymmetric algorithm key used for signing a <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</summary>
		/// <returns>The asymmetric algorithm key used for signing the <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</returns>
		public AsymmetricAlgorithm SigningKey
		{
			get
			{
				return m_signingKey;
			}
			set
			{
				m_signingKey = value;
			}
		}

		/// <summary>Gets or sets an <see cref="T:System.Security.Cryptography.Xml.EncryptedXml" /> object that defines the XML encryption processing rules.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Xml.EncryptedXml" /> object that defines the XML encryption processing rules.</returns>
		[ComVisible(false)]
		public EncryptedXml EncryptedXml
		{
			get
			{
				if (m_exml == null)
				{
					m_exml = new EncryptedXml(m_containingDocument);
				}
				return m_exml;
			}
			set
			{
				m_exml = value;
			}
		}

		/// <summary>Gets the <see cref="T:System.Security.Cryptography.Xml.Signature" /> object of the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</summary>
		/// <returns>The <see cref="T:System.Security.Cryptography.Xml.Signature" /> object of the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</returns>
		public Signature Signature => m_signature;

		/// <summary>Gets the <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object of the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</summary>
		/// <returns>The <see cref="T:System.Security.Cryptography.Xml.SignedInfo" /> object of the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</returns>
		public SignedInfo SignedInfo => m_signature.SignedInfo;

		/// <summary>Gets the signature method of the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</summary>
		/// <returns>The signature method of the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</returns>
		public string SignatureMethod => m_signature.SignedInfo.SignatureMethod;

		/// <summary>Gets the length of the signature for the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</summary>
		/// <returns>The length of the signature for the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</returns>
		public string SignatureLength => m_signature.SignedInfo.SignatureLength;

		/// <summary>Gets the signature value of the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</summary>
		/// <returns>A byte array that contains the signature value of the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</returns>
		public byte[] SignatureValue => m_signature.SignatureValue;

		/// <summary>Gets or sets the <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object of the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</summary>
		/// <returns>The <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object of the current <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</returns>
		public KeyInfo KeyInfo
		{
			get
			{
				return m_signature.KeyInfo;
			}
			set
			{
				m_signature.KeyInfo = value;
			}
		}

		private static IList<string> KnownCanonicalizationMethods
		{
			get
			{
				if (s_knownCanonicalizationMethods == null)
				{
					List<string> list = ReadAdditionalSafeCanonicalizationMethods();
					list.Add("http://www.w3.org/TR/2001/REC-xml-c14n-20010315");
					list.Add("http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments");
					list.Add("http://www.w3.org/2001/10/xml-exc-c14n#");
					list.Add("http://www.w3.org/2001/10/xml-exc-c14n#WithComments");
					s_knownCanonicalizationMethods = list;
				}
				return s_knownCanonicalizationMethods;
			}
		}

		private static IList<string> DefaultSafeTransformMethods
		{
			get
			{
				if (s_defaultSafeTransformMethods == null)
				{
					List<string> list = ReadAdditionalSafeTransformMethods();
					list.Add("http://www.w3.org/2000/09/xmldsig#enveloped-signature");
					list.Add("http://www.w3.org/2000/09/xmldsig#base64");
					list.Add("urn:mpeg:mpeg21:2003:01-REL-R-NS:licenseTransform");
					list.Add("http://www.w3.org/2002/07/decrypt#XML");
					s_defaultSafeTransformMethods = list;
				}
				return s_defaultSafeTransformMethods;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> class.</summary>
		public SignedXml()
		{
			Initialize(null);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> class from the specified XML document.</summary>
		/// <param name="document">The <see cref="T:System.Xml.XmlDocument" /> object to use to initialize the new instance of <see cref="T:System.Security.Cryptography.Xml.SignedXml" />.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="document" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The <paramref name="document" /> parameter contains a null <see cref="P:System.Xml.XmlDocument.DocumentElement" /> property.</exception>
		public SignedXml(XmlDocument document)
		{
			if (document == null)
			{
				throw new ArgumentNullException("document");
			}
			Initialize(document.DocumentElement);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> class from the specified <see cref="T:System.Xml.XmlElement" /> object.</summary>
		/// <param name="elem">The <see cref="T:System.Xml.XmlElement" /> object to use to initialize the new instance of <see cref="T:System.Security.Cryptography.Xml.SignedXml" />.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="elem" /> parameter is <see langword="null" />.</exception>
		public SignedXml(XmlElement elem)
		{
			if (elem == null)
			{
				throw new ArgumentNullException("elem");
			}
			Initialize(elem);
		}

		private void Initialize(XmlElement element)
		{
			m_containingDocument = element?.OwnerDocument;
			m_context = element;
			m_signature = new Signature();
			m_signature.SignedXml = this;
			m_signature.SignedInfo = new SignedInfo();
			m_signingKey = null;
			m_safeCanonicalizationMethods = new Collection<string>(KnownCanonicalizationMethods);
		}

		/// <summary>Returns the XML representation of a <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object.</summary>
		/// <returns>The XML representation of the <see cref="T:System.Security.Cryptography.Xml.Signature" /> object.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.SignedXml.SignedInfo" /> property is <see langword="null" />.  
		///  -or-  
		///  The <see cref="P:System.Security.Cryptography.Xml.SignedXml.SignatureValue" /> property is <see langword="null" />.</exception>
		public XmlElement GetXml()
		{
			if (m_containingDocument != null)
			{
				return m_signature.GetXml(m_containingDocument);
			}
			return m_signature.GetXml();
		}

		/// <summary>Loads a <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> state from an XML element.</summary>
		/// <param name="value">The XML element to load the <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> state from.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="value" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="value" /> parameter does not contain a valid <see cref="P:System.Security.Cryptography.Xml.SignedXml.SignatureValue" /> property.  
		///  -or-  
		///  The <paramref name="value" /> parameter does not contain a valid <see cref="P:System.Security.Cryptography.Xml.SignedXml.SignedInfo" /> property.</exception>
		public void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			m_signature.LoadXml(value);
			if (m_context == null)
			{
				m_context = value;
			}
			bCacheValid = false;
		}

		/// <summary>Adds a <see cref="T:System.Security.Cryptography.Xml.Reference" /> object to the <see cref="T:System.Security.Cryptography.Xml.SignedXml" /> object that describes a digest method, digest value, and transform to use for creating an XML digital signature.</summary>
		/// <param name="reference">The  <see cref="T:System.Security.Cryptography.Xml.Reference" /> object that describes a digest method, digest value, and transform to use for creating an XML digital signature.</param>
		public void AddReference(Reference reference)
		{
			m_signature.SignedInfo.AddReference(reference);
		}

		/// <summary>Adds a <see cref="T:System.Security.Cryptography.Xml.DataObject" /> object to the list of objects to be signed.</summary>
		/// <param name="dataObject">The <see cref="T:System.Security.Cryptography.Xml.DataObject" /> object to add to the list of objects to be signed.</param>
		public void AddObject(DataObject dataObject)
		{
			m_signature.AddObject(dataObject);
		}

		/// <summary>Determines whether the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property verifies using the public key in the signature.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property verifies; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.SignatureAlgorithm" /> property of the public key in the signature does not match the <see cref="P:System.Security.Cryptography.Xml.SignedXml.SignatureMethod" /> property.  
		///  -or-  
		///  The signature description could not be created.  
		///  -or  
		///  The hash algorithm could not be created.</exception>
		public bool CheckSignature()
		{
			AsymmetricAlgorithm signingKey;
			return CheckSignatureReturningKey(out signingKey);
		}

		/// <summary>Determines whether the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property verifies using the public key in the signature.</summary>
		/// <param name="signingKey">When this method returns, contains the implementation of <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> that holds the public key in the signature. This parameter is passed uninitialized.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property verifies using the public key in the signature; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="signingKey" /> parameter is null.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.SignatureAlgorithm" /> property of the public key in the signature does not match the <see cref="P:System.Security.Cryptography.Xml.SignedXml.SignatureMethod" /> property.  
		///  -or-  
		///  The signature description could not be created.  
		///  -or  
		///  The hash algorithm could not be created.</exception>
		public bool CheckSignatureReturningKey(out AsymmetricAlgorithm signingKey)
		{
			SignedXmlDebugLog.LogBeginSignatureVerification(this, m_context);
			signingKey = null;
			bool flag = false;
			AsymmetricAlgorithm asymmetricAlgorithm = null;
			if (!CheckSignatureFormat())
			{
				return false;
			}
			do
			{
				asymmetricAlgorithm = GetPublicKey();
				if (asymmetricAlgorithm != null)
				{
					flag = CheckSignature(asymmetricAlgorithm);
					SignedXmlDebugLog.LogVerificationResult(this, asymmetricAlgorithm, flag);
				}
			}
			while (asymmetricAlgorithm != null && !flag);
			signingKey = asymmetricAlgorithm;
			return flag;
		}

		/// <summary>Determines whether the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property verifies for the specified key.</summary>
		/// <param name="key">The implementation of the <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> property that holds the key to be used to verify the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property verifies for the specified key; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="key" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.SignatureAlgorithm" /> property of the <paramref name="key" /> parameter does not match the <see cref="P:System.Security.Cryptography.Xml.SignedXml.SignatureMethod" /> property.  
		///  -or-  
		///  The signature description could not be created.  
		///  -or  
		///  The hash algorithm could not be created.</exception>
		public bool CheckSignature(AsymmetricAlgorithm key)
		{
			if (!CheckSignatureFormat())
			{
				return false;
			}
			if (!CheckSignedInfo(key))
			{
				SignedXmlDebugLog.LogVerificationFailure(this, SecurityResources.GetResourceString("Log_VerificationFailed_SignedInfo"));
				return false;
			}
			if (!CheckDigestedReferences())
			{
				SignedXmlDebugLog.LogVerificationFailure(this, SecurityResources.GetResourceString("Log_VerificationFailed_References"));
				return false;
			}
			SignedXmlDebugLog.LogVerificationResult(this, key, verified: true);
			return true;
		}

		/// <summary>Determines whether the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property verifies for the specified message authentication code (MAC) algorithm.</summary>
		/// <param name="macAlg">The implementation of <see cref="T:System.Security.Cryptography.KeyedHashAlgorithm" /> that holds the MAC to be used to verify the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property verifies for the specified MAC; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="macAlg" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.HashAlgorithm.HashSize" /> property of the specified <see cref="T:System.Security.Cryptography.KeyedHashAlgorithm" /> object is not valid.  
		///  -or-  
		///  The <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property is <see langword="null" />.  
		///  -or-  
		///  The cryptographic transform used to check the signature could not be created.</exception>
		public bool CheckSignature(KeyedHashAlgorithm macAlg)
		{
			if (!CheckSignatureFormat())
			{
				return false;
			}
			if (!CheckSignedInfo(macAlg))
			{
				SignedXmlDebugLog.LogVerificationFailure(this, SecurityResources.GetResourceString("Log_VerificationFailed_SignedInfo"));
				return false;
			}
			if (!CheckDigestedReferences())
			{
				SignedXmlDebugLog.LogVerificationFailure(this, SecurityResources.GetResourceString("Log_VerificationFailed_References"));
				return false;
			}
			SignedXmlDebugLog.LogVerificationResult(this, macAlg, verified: true);
			return true;
		}

		/// <summary>Determines whether the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property verifies for the specified <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object and, optionally, whether the certificate is valid.</summary>
		/// <param name="certificate">The <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object to use to verify the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property.</param>
		/// <param name="verifySignatureOnly">
		///   <see langword="true" /> to verify the signature only; <see langword="false" /> to verify both the signature and certificate.</param>
		/// <returns>
		///   <see langword="true" /> if the signature is valid; otherwise, <see langword="false" />.  
		/// -or-  
		/// <see langword="true" /> if the signature and certificate are valid; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="certificate" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A signature description could not be created for the <paramref name="certificate" /> parameter.</exception>
		[ComVisible(false)]
		[SecuritySafeCritical]
		public bool CheckSignature(X509Certificate2 certificate, bool verifySignatureOnly)
		{
			if (!verifySignatureOnly)
			{
				X509ExtensionEnumerator enumerator = certificate.Extensions.GetEnumerator();
				while (enumerator.MoveNext())
				{
					X509Extension current = enumerator.Current;
					if (string.Compare(current.Oid.Value, "2.5.29.15", StringComparison.OrdinalIgnoreCase) == 0)
					{
						X509KeyUsageExtension x509KeyUsageExtension = new X509KeyUsageExtension();
						x509KeyUsageExtension.CopyFrom(current);
						SignedXmlDebugLog.LogVerifyKeyUsage(this, certificate, x509KeyUsageExtension);
						if ((x509KeyUsageExtension.KeyUsages & X509KeyUsageFlags.DigitalSignature) != 0 || (x509KeyUsageExtension.KeyUsages & X509KeyUsageFlags.NonRepudiation) != 0)
						{
							break;
						}
						SignedXmlDebugLog.LogVerificationFailure(this, SecurityResources.GetResourceString("Log_VerificationFailed_X509KeyUsage"));
						return false;
					}
				}
				X509Chain x509Chain = new X509Chain();
				x509Chain.ChainPolicy.ExtraStore.AddRange(BuildBagOfCerts());
				bool flag = x509Chain.Build(certificate);
				SignedXmlDebugLog.LogVerifyX509Chain(this, x509Chain, certificate);
				if (!flag)
				{
					SignedXmlDebugLog.LogVerificationFailure(this, SecurityResources.GetResourceString("Log_VerificationFailed_X509Chain"));
					return false;
				}
			}
			if (!CheckSignature(certificate.GetAnyPublicKey()))
			{
				return false;
			}
			SignedXmlDebugLog.LogVerificationResult(this, certificate, verified: true);
			return true;
		}

		/// <summary>Computes an XML digital signature.</summary>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.SignedXml.SigningKey" /> property is <see langword="null" />.  
		///  -or-  
		///  The <see cref="P:System.Security.Cryptography.Xml.SignedXml.SigningKey" /> property is not a <see cref="T:System.Security.Cryptography.DSA" /> object or <see cref="T:System.Security.Cryptography.RSA" /> object.  
		///  -or-  
		///  The key could not be loaded.</exception>
		public void ComputeSignature()
		{
			SignedXmlDebugLog.LogBeginSignatureComputation(this, m_context);
			BuildDigestedReferences();
			AsymmetricAlgorithm signingKey = SigningKey;
			if (signingKey == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_LoadKeyFailed"));
			}
			if (SignedInfo.SignatureMethod == null)
			{
				if (signingKey is DSA)
				{
					SignedInfo.SignatureMethod = "http://www.w3.org/2000/09/xmldsig#dsa-sha1";
				}
				else
				{
					if (!(signingKey is RSA))
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CreatedKeyFailed"));
					}
					if (SignedInfo.SignatureMethod == null)
					{
						SignedInfo.SignatureMethod = XmlDsigRSADefault;
					}
				}
			}
			SignatureDescription signatureDescription = Utils.CreateFromName<SignatureDescription>(SignedInfo.SignatureMethod);
			if (signatureDescription == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureDescriptionNotCreated"));
			}
			HashAlgorithm hashAlgorithm = signatureDescription.CreateDigest();
			if (hashAlgorithm == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CreateHashAlgorithmFailed"));
			}
			byte[] c14NDigest = GetC14NDigest(hashAlgorithm);
			AsymmetricSignatureFormatter asymmetricSignatureFormatter = signatureDescription.CreateFormatter(signingKey);
			SignedXmlDebugLog.LogSigning(this, signingKey, signatureDescription, hashAlgorithm, asymmetricSignatureFormatter);
			m_signature.SignatureValue = asymmetricSignatureFormatter.CreateSignature(hashAlgorithm);
		}

		/// <summary>Computes an XML digital signature using the specified message authentication code (MAC) algorithm.</summary>
		/// <param name="macAlg">A <see cref="T:System.Security.Cryptography.KeyedHashAlgorithm" /> object that holds the MAC to be used to compute the value of the <see cref="P:System.Security.Cryptography.Xml.SignedXml.Signature" /> property.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="macAlg" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="T:System.Security.Cryptography.KeyedHashAlgorithm" /> object specified by the <paramref name="macAlg" /> parameter is not an instance of <see cref="T:System.Security.Cryptography.HMACSHA1" />.  
		///  -or-  
		///  The <see cref="P:System.Security.Cryptography.HashAlgorithm.HashSize" /> property of the specified <see cref="T:System.Security.Cryptography.KeyedHashAlgorithm" /> object is not valid.  
		///  -or-  
		///  The cryptographic transform used to check the signature could not be created.</exception>
		public void ComputeSignature(KeyedHashAlgorithm macAlg)
		{
			if (macAlg == null)
			{
				throw new ArgumentNullException("macAlg");
			}
			if (!(macAlg is HMAC hMAC))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureMethodKeyMismatch"));
			}
			int num = ((m_signature.SignedInfo.SignatureLength != null) ? Convert.ToInt32(m_signature.SignedInfo.SignatureLength, null) : hMAC.HashSize);
			if (num < 0 || num > hMAC.HashSize)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidSignatureLength"));
			}
			if (num % 8 != 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidSignatureLength2"));
			}
			BuildDigestedReferences();
			switch (hMAC.HashName)
			{
			case "SHA1":
				SignedInfo.SignatureMethod = "http://www.w3.org/2000/09/xmldsig#hmac-sha1";
				break;
			case "SHA256":
				SignedInfo.SignatureMethod = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha256";
				break;
			case "SHA384":
				SignedInfo.SignatureMethod = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha384";
				break;
			case "SHA512":
				SignedInfo.SignatureMethod = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha512";
				break;
			case "MD5":
				SignedInfo.SignatureMethod = "http://www.w3.org/2001/04/xmldsig-more#hmac-md5";
				break;
			case "RIPEMD160":
				SignedInfo.SignatureMethod = "http://www.w3.org/2001/04/xmldsig-more#hmac-ripemd160";
				break;
			default:
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureMethodKeyMismatch"));
			}
			byte[] c14NDigest = GetC14NDigest(hMAC);
			SignedXmlDebugLog.LogSigning(this, hMAC);
			m_signature.SignatureValue = new byte[num / 8];
			Buffer.BlockCopy(c14NDigest, 0, m_signature.SignatureValue, 0, num / 8);
		}

		/// <summary>Returns the public key of a signature.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> object that contains the public key of the signature, or <see langword="null" /> if the key cannot be found.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <see cref="P:System.Security.Cryptography.Xml.SignedXml.KeyInfo" /> property is <see langword="null" />.</exception>
		protected virtual AsymmetricAlgorithm GetPublicKey()
		{
			if (KeyInfo == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_KeyInfoRequired"));
			}
			if (m_x509Enum != null)
			{
				AsymmetricAlgorithm nextCertificatePublicKey = GetNextCertificatePublicKey();
				if (nextCertificatePublicKey != null)
				{
					return nextCertificatePublicKey;
				}
			}
			if (m_keyInfoEnum == null)
			{
				m_keyInfoEnum = KeyInfo.GetEnumerator();
			}
			while (m_keyInfoEnum.MoveNext())
			{
				if (m_keyInfoEnum.Current is RSAKeyValue rSAKeyValue)
				{
					return rSAKeyValue.Key;
				}
				if (m_keyInfoEnum.Current is DSAKeyValue dSAKeyValue)
				{
					return dSAKeyValue.Key;
				}
				if (!(m_keyInfoEnum.Current is KeyInfoX509Data keyInfoX509Data))
				{
					continue;
				}
				m_x509Collection = Utils.BuildBagOfCerts(keyInfoX509Data, CertUsageType.Verification);
				if (m_x509Collection.Count > 0)
				{
					m_x509Enum = m_x509Collection.GetEnumerator();
					AsymmetricAlgorithm nextCertificatePublicKey2 = GetNextCertificatePublicKey();
					if (nextCertificatePublicKey2 != null)
					{
						return nextCertificatePublicKey2;
					}
				}
			}
			return null;
		}

		private X509Certificate2Collection BuildBagOfCerts()
		{
			X509Certificate2Collection x509Certificate2Collection = new X509Certificate2Collection();
			if (KeyInfo != null)
			{
				foreach (KeyInfoClause item in KeyInfo)
				{
					if (item is KeyInfoX509Data keyInfoX509Data)
					{
						x509Certificate2Collection.AddRange(Utils.BuildBagOfCerts(keyInfoX509Data, CertUsageType.Verification));
					}
				}
				return x509Certificate2Collection;
			}
			return x509Certificate2Collection;
		}

		private AsymmetricAlgorithm GetNextCertificatePublicKey()
		{
			while (m_x509Enum.MoveNext())
			{
				X509Certificate2 x509Certificate = (X509Certificate2)m_x509Enum.Current;
				if (x509Certificate != null)
				{
					if (!LocalAppContextSwitches.SignedXmlUseLegacyCertificatePrivateKey)
					{
						return x509Certificate.GetAnyPublicKey();
					}
					return x509Certificate.PublicKey.Key;
				}
			}
			return null;
		}

		/// <summary>Returns the <see cref="T:System.Xml.XmlElement" /> object with the specified ID from the specified <see cref="T:System.Xml.XmlDocument" /> object.</summary>
		/// <param name="document">The <see cref="T:System.Xml.XmlDocument" /> object to retrieve the <see cref="T:System.Xml.XmlElement" /> object from.</param>
		/// <param name="idValue">The ID of the <see cref="T:System.Xml.XmlElement" /> object to retrieve from the <see cref="T:System.Xml.XmlDocument" /> object.</param>
		/// <returns>The <see cref="T:System.Xml.XmlElement" /> object with the specified ID from the specified <see cref="T:System.Xml.XmlDocument" /> object, or <see langword="null" /> if it could not be found.</returns>
		public virtual XmlElement GetIdElement(XmlDocument document, string idValue)
		{
			return DefaultGetIdElement(document, idValue);
		}

		internal static XmlElement DefaultGetIdElement(XmlDocument document, string idValue)
		{
			if (document == null)
			{
				return null;
			}
			if (Utils.RequireNCNameIdentifier())
			{
				try
				{
					XmlConvert.VerifyNCName(idValue);
				}
				catch (XmlException)
				{
					return null;
				}
			}
			XmlElement elementById = document.GetElementById(idValue);
			if (elementById != null)
			{
				if (!Utils.AllowAmbiguousReferenceTargets())
				{
					XmlDocument xmlDocument = (XmlDocument)document.CloneNode(deep: true);
					XmlElement elementById2 = xmlDocument.GetElementById(idValue);
					if (elementById2 != null)
					{
						elementById2.Attributes.RemoveAll();
						XmlElement elementById3 = xmlDocument.GetElementById(idValue);
						if (elementById3 != null)
						{
							throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidReference"));
						}
					}
				}
				return elementById;
			}
			elementById = GetSingleReferenceTarget(document, "Id", idValue);
			if (elementById != null)
			{
				return elementById;
			}
			elementById = GetSingleReferenceTarget(document, "id", idValue);
			if (elementById != null)
			{
				return elementById;
			}
			return GetSingleReferenceTarget(document, "ID", idValue);
		}

		private static bool DefaultSignatureFormatValidator(SignedXml signedXml)
		{
			if (signedXml.DoesSignatureUseTruncatedHmac())
			{
				return false;
			}
			if (!signedXml.DoesSignatureUseSafeCanonicalizationMethod())
			{
				return false;
			}
			return true;
		}

		private bool DoesSignatureUseTruncatedHmac()
		{
			if (SignedInfo.SignatureLength == null)
			{
				return false;
			}
			HMAC hMAC = Utils.CreateFromName<HMAC>(SignatureMethod);
			if (hMAC == null)
			{
				return false;
			}
			int result = 0;
			if (!int.TryParse(SignedInfo.SignatureLength, out result))
			{
				return true;
			}
			return result != hMAC.HashSize;
		}

		private bool DoesSignatureUseSafeCanonicalizationMethod()
		{
			foreach (string safeCanonicalizationMethod in SafeCanonicalizationMethods)
			{
				if (string.Equals(safeCanonicalizationMethod, SignedInfo.CanonicalizationMethod, StringComparison.OrdinalIgnoreCase))
				{
					return true;
				}
			}
			SignedXmlDebugLog.LogUnsafeCanonicalizationMethod(this, SignedInfo.CanonicalizationMethod, SafeCanonicalizationMethods);
			return false;
		}

		private bool ReferenceUsesSafeTransformMethods(Reference reference)
		{
			TransformChain transformChain = reference.TransformChain;
			int count = transformChain.Count;
			for (int i = 0; i < count; i++)
			{
				Transform transform = transformChain[i];
				if (!IsSafeTransform(transform.Algorithm))
				{
					return false;
				}
			}
			return true;
		}

		private bool IsSafeTransform(string transformAlgorithm)
		{
			foreach (string safeCanonicalizationMethod in SafeCanonicalizationMethods)
			{
				if (string.Equals(safeCanonicalizationMethod, transformAlgorithm, StringComparison.OrdinalIgnoreCase))
				{
					return true;
				}
			}
			foreach (string defaultSafeTransformMethod in DefaultSafeTransformMethods)
			{
				if (string.Equals(defaultSafeTransformMethod, transformAlgorithm, StringComparison.OrdinalIgnoreCase))
				{
					return true;
				}
			}
			SignedXmlDebugLog.LogUnsafeTransformMethod(this, transformAlgorithm, SafeCanonicalizationMethods, DefaultSafeTransformMethods);
			return false;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		private static List<string> ReadAdditionalSafeCanonicalizationMethods()
		{
			return ReadFxSecurityStringValues("SafeCanonicalizationMethods");
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		private static List<string> ReadAdditionalSafeTransformMethods()
		{
			return ReadFxSecurityStringValues("SafeTransformMethods");
		}

		private static List<string> ReadFxSecurityStringValues(string subkey)
		{
			List<string> list = new List<string>();
			try
			{
				using RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\.NETFramework\\Security\\" + subkey, writable: false);
				if (registryKey != null)
				{
					string[] valueNames = registryKey.GetValueNames();
					foreach (string name in valueNames)
					{
						if (registryKey.GetValueKind(name) == RegistryValueKind.String)
						{
							string text = registryKey.GetValue(name) as string;
							if (!string.IsNullOrWhiteSpace(text))
							{
								list.Add(text);
							}
						}
					}
					return list;
				}
				return list;
			}
			catch (SecurityException)
			{
				return list;
			}
		}

		private byte[] GetC14NDigest(HashAlgorithm hash)
		{
			if (!bCacheValid || !SignedInfo.CacheValid)
			{
				string text = ((m_containingDocument == null) ? null : m_containingDocument.BaseURI);
				XmlResolver xmlResolver = (m_bResolverSet ? m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), text));
				XmlDocument xmlDocument = Utils.PreProcessElementInput(SignedInfo.GetXml(), xmlResolver, text);
				CanonicalXmlNodeList namespaces = ((m_context == null) ? null : Utils.GetPropagatedAttributes(m_context));
				SignedXmlDebugLog.LogNamespacePropagation(this, namespaces);
				Utils.AddNamespaces(xmlDocument.DocumentElement, namespaces);
				Transform canonicalizationMethodObject = SignedInfo.CanonicalizationMethodObject;
				canonicalizationMethodObject.Resolver = xmlResolver;
				canonicalizationMethodObject.BaseURI = text;
				SignedXmlDebugLog.LogBeginCanonicalization(this, canonicalizationMethodObject);
				canonicalizationMethodObject.LoadInput(xmlDocument);
				SignedXmlDebugLog.LogCanonicalizedOutput(this, canonicalizationMethodObject);
				_digestedSignedInfo = canonicalizationMethodObject.GetDigestedOutput(hash);
				bCacheValid = true;
			}
			return _digestedSignedInfo;
		}

		private int GetReferenceLevel(int index, ArrayList references)
		{
			if (m_refProcessed[index])
			{
				return m_refLevelCache[index];
			}
			m_refProcessed[index] = true;
			Reference reference = (Reference)references[index];
			if (reference.Uri == null || reference.Uri.Length == 0 || (reference.Uri.Length > 0 && reference.Uri[0] != '#'))
			{
				m_refLevelCache[index] = 0;
				return 0;
			}
			if (reference.Uri.Length > 0 && reference.Uri[0] == '#')
			{
				string text = Utils.ExtractIdFromLocalUri(reference.Uri);
				if (text == "xpointer(/)")
				{
					m_refLevelCache[index] = 0;
					return 0;
				}
				for (int i = 0; i < references.Count; i++)
				{
					if (((Reference)references[i]).Id == text)
					{
						m_refLevelCache[index] = GetReferenceLevel(i, references) + 1;
						return m_refLevelCache[index];
					}
				}
				m_refLevelCache[index] = 0;
				return 0;
			}
			throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidReference"));
		}

		private void BuildDigestedReferences()
		{
			ArrayList references = SignedInfo.References;
			m_refProcessed = new bool[references.Count];
			m_refLevelCache = new int[references.Count];
			ReferenceLevelSortOrder referenceLevelSortOrder = new ReferenceLevelSortOrder();
			referenceLevelSortOrder.References = references;
			ArrayList arrayList = new ArrayList();
			foreach (Reference item in references)
			{
				arrayList.Add(item);
			}
			arrayList.Sort(referenceLevelSortOrder);
			CanonicalXmlNodeList canonicalXmlNodeList = new CanonicalXmlNodeList();
			foreach (DataObject @object in m_signature.ObjectList)
			{
				canonicalXmlNodeList.Add(@object.GetXml());
			}
			foreach (Reference item2 in arrayList)
			{
				if (item2.DigestMethod == null)
				{
					item2.DigestMethod = XmlDsigDigestDefault;
				}
				SignedXmlDebugLog.LogSigningReference(this, item2);
				item2.UpdateHashValue(m_containingDocument, canonicalXmlNodeList);
				if (item2.Id != null)
				{
					canonicalXmlNodeList.Add(item2.GetXml());
				}
			}
		}

		private bool CheckDigestedReferences()
		{
			ArrayList references = m_signature.SignedInfo.References;
			for (int i = 0; i < references.Count; i++)
			{
				Reference reference = (Reference)references[i];
				if (!ReferenceUsesSafeTransformMethods(reference))
				{
					return false;
				}
				SignedXmlDebugLog.LogVerifyReference(this, reference);
				byte[] array = null;
				try
				{
					array = reference.CalculateHashValue(m_containingDocument, m_signature.ReferencedItems);
				}
				catch (CryptoSignedXmlRecursionException)
				{
					SignedXmlDebugLog.LogSignedXmlRecursionLimit(this, reference);
					return false;
				}
				SignedXmlDebugLog.LogVerifyReferenceHash(this, reference, array, reference.DigestValue);
				if (!CryptographicEquals(array, reference.DigestValue, array.Length))
				{
					return false;
				}
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
		internal static bool CryptographicEquals(byte[] a, byte[] b, int count)
		{
			int num = 0;
			if (a.Length < count || b.Length < count)
			{
				return false;
			}
			for (int i = 0; i < count; i++)
			{
				num |= a[i] - b[i];
			}
			return num == 0;
		}

		private bool CheckSignatureFormat()
		{
			if (m_signatureFormatValidator == null)
			{
				return true;
			}
			SignedXmlDebugLog.LogBeginCheckSignatureFormat(this, m_signatureFormatValidator);
			bool result = m_signatureFormatValidator(this);
			SignedXmlDebugLog.LogFormatValidationResult(this, result);
			return result;
		}

		private bool CheckSignedInfo(AsymmetricAlgorithm key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			SignedXmlDebugLog.LogBeginCheckSignedInfo(this, m_signature.SignedInfo);
			SignatureDescription signatureDescription = Utils.CreateFromName<SignatureDescription>(SignatureMethod);
			if (signatureDescription == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureDescriptionNotCreated"));
			}
			Type type = Type.GetType(signatureDescription.KeyAlgorithm);
			if (!IsKeyTheCorrectAlgorithm(key, type))
			{
				return false;
			}
			HashAlgorithm hashAlgorithm = signatureDescription.CreateDigest();
			if (hashAlgorithm == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CreateHashAlgorithmFailed"));
			}
			byte[] c14NDigest = GetC14NDigest(hashAlgorithm);
			AsymmetricSignatureDeformatter asymmetricSignatureDeformatter = signatureDescription.CreateDeformatter(key);
			SignedXmlDebugLog.LogVerifySignedInfo(this, key, signatureDescription, hashAlgorithm, asymmetricSignatureDeformatter, c14NDigest, m_signature.SignatureValue);
			return asymmetricSignatureDeformatter.VerifySignature(c14NDigest, m_signature.SignatureValue);
		}

		private bool CheckSignedInfo(KeyedHashAlgorithm macAlg)
		{
			if (macAlg == null)
			{
				throw new ArgumentNullException("macAlg");
			}
			SignedXmlDebugLog.LogBeginCheckSignedInfo(this, m_signature.SignedInfo);
			int num = ((m_signature.SignedInfo.SignatureLength != null) ? Convert.ToInt32(m_signature.SignedInfo.SignatureLength, null) : macAlg.HashSize);
			if (num < 0 || num > macAlg.HashSize)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidSignatureLength"));
			}
			if (num % 8 != 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidSignatureLength2"));
			}
			if (m_signature.SignatureValue == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureValueRequired"));
			}
			if (m_signature.SignatureValue.Length != num / 8)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidSignatureLength"));
			}
			byte[] c14NDigest = GetC14NDigest(macAlg);
			SignedXmlDebugLog.LogVerifySignedInfo(this, macAlg, c14NDigest, m_signature.SignatureValue);
			for (int i = 0; i < m_signature.SignatureValue.Length; i++)
			{
				if (m_signature.SignatureValue[i] != c14NDigest[i])
				{
					return false;
				}
			}
			return true;
		}

		private static XmlElement GetSingleReferenceTarget(XmlDocument document, string idAttributeName, string idValue)
		{
			string xpath = "//*[@" + idAttributeName + "=\"" + idValue + "\"]";
			if (Utils.AllowAmbiguousReferenceTargets())
			{
				return document.SelectSingleNode(xpath) as XmlElement;
			}
			XmlNodeList xmlNodeList = document.SelectNodes(xpath);
			if (xmlNodeList == null || xmlNodeList.Count == 0)
			{
				return null;
			}
			if (xmlNodeList.Count == 1)
			{
				return xmlNodeList[0] as XmlElement;
			}
			throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidReference"));
		}

		private static bool IsKeyTheCorrectAlgorithm(AsymmetricAlgorithm key, Type expectedType)
		{
			Type type = key.GetType();
			if (type == expectedType)
			{
				return true;
			}
			if (expectedType.IsSubclassOf(type))
			{
				return true;
			}
			while (expectedType != null && expectedType.BaseType != typeof(AsymmetricAlgorithm))
			{
				expectedType = expectedType.BaseType;
			}
			if (expectedType == null)
			{
				return false;
			}
			if (type.IsSubclassOf(expectedType))
			{
				return true;
			}
			return false;
		}
	}
	internal static class SignedXmlDebugLog
	{
		internal enum SignedXmlDebugEvent
		{
			BeginCanonicalization,
			BeginCheckSignatureFormat,
			BeginCheckSignedInfo,
			BeginSignatureComputation,
			BeginSignatureVerification,
			CanonicalizedData,
			FormatValidationResult,
			NamespacePropagation,
			ReferenceData,
			SignatureVerificationResult,
			Signing,
			SigningReference,
			VerificationFailure,
			VerifyReference,
			VerifySignedInfo,
			X509Verification,
			UnsafeCanonicalizationMethod,
			UnsafeTransformMethod
		}

		private const string NullString = "(null)";

		private static TraceSource s_traceSource = new TraceSource("System.Security.Cryptography.Xml.SignedXml");

		private static volatile bool s_haveVerboseLogging;

		private static volatile bool s_verboseLogging;

		private static volatile bool s_haveInformationLogging;

		private static volatile bool s_informationLogging;

		private static bool InformationLoggingEnabled
		{
			get
			{
				if (!s_haveInformationLogging)
				{
					s_informationLogging = s_traceSource.Switch.ShouldTrace(TraceEventType.Information);
					s_haveInformationLogging = true;
				}
				return s_informationLogging;
			}
		}

		private static bool VerboseLoggingEnabled
		{
			get
			{
				if (!s_haveVerboseLogging)
				{
					s_verboseLogging = s_traceSource.Switch.ShouldTrace(TraceEventType.Verbose);
					s_haveVerboseLogging = true;
				}
				return s_verboseLogging;
			}
		}

		private static string FormatBytes(byte[] bytes)
		{
			if (bytes == null)
			{
				return "(null)";
			}
			StringBuilder stringBuilder = new StringBuilder(bytes.Length * 2);
			foreach (byte b in bytes)
			{
				stringBuilder.Append(b.ToString("x2", CultureInfo.InvariantCulture));
			}
			return stringBuilder.ToString();
		}

		private static string GetKeyName(object key)
		{
			ICspAsymmetricAlgorithm cspAsymmetricAlgorithm = key as ICspAsymmetricAlgorithm;
			X509Certificate x509Certificate = key as X509Certificate;
			X509Certificate2 x509Certificate2 = key as X509Certificate2;
			string text = null;
			text = ((cspAsymmetricAlgorithm != null && cspAsymmetricAlgorithm.CspKeyContainerInfo.KeyContainerName != null) ? string.Format(CultureInfo.InvariantCulture, "\"{0}\"", new object[1] { cspAsymmetricAlgorithm.CspKeyContainerInfo.KeyContainerName }) : ((x509Certificate2 != null) ? string.Format(CultureInfo.InvariantCulture, "\"{0}\"", new object[1] { x509Certificate2.GetNameInfo(X509NameType.SimpleName, forIssuer: false) }) : ((x509Certificate == null) ? key.GetHashCode().ToString("x8", CultureInfo.InvariantCulture) : string.Format(CultureInfo.InvariantCulture, "\"{0}\"", new object[1] { x509Certificate.Subject }))));
			return string.Format(CultureInfo.InvariantCulture, "{0}#{1}", new object[2]
			{
				key.GetType().Name,
				text
			});
		}

		private static string GetObjectId(object o)
		{
			return string.Format(CultureInfo.InvariantCulture, "{0}#{1}", new object[2]
			{
				o.GetType().Name,
				o.GetHashCode().ToString("x8", CultureInfo.InvariantCulture)
			});
		}

		private static string GetOidName(Oid oid)
		{
			string text = oid.FriendlyName;
			if (string.IsNullOrEmpty(text))
			{
				text = oid.Value;
			}
			return text;
		}

		internal static void LogBeginCanonicalization(SignedXml signedXml, Transform canonicalizationTransform)
		{
			if (InformationLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_BeginCanonicalization"), new object[2]
				{
					canonicalizationTransform.Algorithm,
					canonicalizationTransform.GetType().Name
				});
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.BeginCanonicalization, data);
			}
			if (VerboseLoggingEnabled)
			{
				string data2 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_CanonicalizationSettings"), new object[2]
				{
					canonicalizationTransform.Resolver.GetType(),
					canonicalizationTransform.BaseURI
				});
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.BeginCanonicalization, data2);
			}
		}

		internal static void LogBeginCheckSignatureFormat(SignedXml signedXml, Func<SignedXml, bool> formatValidator)
		{
			if (InformationLoggingEnabled)
			{
				MethodInfo method = formatValidator.Method;
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_CheckSignatureFormat"), new object[3]
				{
					method.Module.Assembly.FullName,
					method.DeclaringType.FullName,
					method.Name
				});
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.BeginCheckSignatureFormat, data);
			}
		}

		internal static void LogBeginCheckSignedInfo(SignedXml signedXml, SignedInfo signedInfo)
		{
			if (InformationLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_CheckSignedInfo"), new object[1] { (signedInfo.Id != null) ? signedInfo.Id : "(null)" });
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.BeginCheckSignedInfo, data);
			}
		}

		internal static void LogBeginSignatureComputation(SignedXml signedXml, XmlElement context)
		{
			if (InformationLoggingEnabled)
			{
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.BeginSignatureComputation, SecurityResources.GetResourceString("Log_BeginSignatureComputation"));
			}
			if (VerboseLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_XmlContext"), new object[1] { (context != null) ? context.OuterXml : "(null)" });
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.BeginSignatureComputation, data);
			}
		}

		internal static void LogBeginSignatureVerification(SignedXml signedXml, XmlElement context)
		{
			if (InformationLoggingEnabled)
			{
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.BeginSignatureVerification, SecurityResources.GetResourceString("Log_BeginSignatureVerification"));
			}
			if (VerboseLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_XmlContext"), new object[1] { (context != null) ? context.OuterXml : "(null)" });
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.BeginSignatureVerification, data);
			}
		}

		internal static void LogCanonicalizedOutput(SignedXml signedXml, Transform canonicalizationTransform)
		{
			if (VerboseLoggingEnabled)
			{
				using (StreamReader streamReader = new StreamReader(canonicalizationTransform.GetOutput(typeof(Stream)) as Stream))
				{
					string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_CanonicalizedOutput"), new object[1] { streamReader.ReadToEnd() });
					WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.CanonicalizedData, data);
				}
			}
		}

		internal static void LogFormatValidationResult(SignedXml signedXml, bool result)
		{
			if (InformationLoggingEnabled)
			{
				string data = (result ? SecurityResources.GetResourceString("Log_FormatValidationSuccessful") : SecurityResources.GetResourceString("Log_FormatValidationNotSuccessful"));
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.FormatValidationResult, data);
			}
		}

		internal static void LogUnsafeCanonicalizationMethod(SignedXml signedXml, string algorithm, IEnumerable<string> validAlgorithms)
		{
			if (!InformationLoggingEnabled)
			{
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			foreach (string validAlgorithm in validAlgorithms)
			{
				if (stringBuilder.Length != 0)
				{
					stringBuilder.Append(", ");
				}
				stringBuilder.AppendFormat("\"{0}\"", validAlgorithm);
			}
			string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_UnsafeCanonicalizationMethod"), new object[2]
			{
				algorithm,
				stringBuilder.ToString()
			});
			WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.UnsafeCanonicalizationMethod, data);
		}

		internal static void LogUnsafeTransformMethod(SignedXml signedXml, string algorithm, IEnumerable<string> validC14nAlgorithms, IEnumerable<string> validTransformAlgorithms)
		{
			if (!InformationLoggingEnabled)
			{
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			foreach (string validC14nAlgorithm in validC14nAlgorithms)
			{
				if (stringBuilder.Length != 0)
				{
					stringBuilder.Append(", ");
				}
				stringBuilder.AppendFormat("\"{0}\"", validC14nAlgorithm);
			}
			foreach (string validTransformAlgorithm in validTransformAlgorithms)
			{
				if (stringBuilder.Length != 0)
				{
					stringBuilder.Append(", ");
				}
				stringBuilder.AppendFormat("\"{0}\"", validTransformAlgorithm);
			}
			string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_UnsafeTransformMethod"), new object[2]
			{
				algorithm,
				stringBuilder.ToString()
			});
			WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.UnsafeTransformMethod, data);
		}

		internal static void LogNamespacePropagation(SignedXml signedXml, XmlNodeList namespaces)
		{
			if (!InformationLoggingEnabled)
			{
				return;
			}
			if (namespaces != null)
			{
				foreach (XmlAttribute @namespace in namespaces)
				{
					string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_PropagatingNamespace"), new object[2] { @namespace.Name, @namespace.Value });
					WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.NamespacePropagation, data);
				}
				return;
			}
			WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.NamespacePropagation, SecurityResources.GetResourceString("Log_NoNamespacesPropagated"));
		}

		internal static Stream LogReferenceData(Reference reference, Stream data)
		{
			if (VerboseLoggingEnabled)
			{
				MemoryStream memoryStream = new MemoryStream();
				byte[] array = new byte[4096];
				int num = 0;
				do
				{
					num = data.Read(array, 0, array.Length);
					memoryStream.Write(array, 0, num);
				}
				while (num == array.Length);
				string data2 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_TransformedReferenceContents"), new object[1] { Encoding.UTF8.GetString(memoryStream.ToArray()) });
				WriteLine(reference, TraceEventType.Verbose, SignedXmlDebugEvent.ReferenceData, data2);
				memoryStream.Seek(0L, SeekOrigin.Begin);
				return memoryStream;
			}
			return data;
		}

		internal static void LogSigning(SignedXml signedXml, object key, SignatureDescription signatureDescription, HashAlgorithm hash, AsymmetricSignatureFormatter asymmetricSignatureFormatter)
		{
			if (InformationLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_SigningAsymmetric"), GetKeyName(key), signatureDescription.GetType().Name, hash.GetType().Name, asymmetricSignatureFormatter.GetType().Name);
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.Signing, data);
			}
		}

		internal static void LogSigning(SignedXml signedXml, KeyedHashAlgorithm key)
		{
			if (InformationLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_SigningHmac"), new object[1] { key.GetType().Name });
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.Signing, data);
			}
		}

		internal static void LogSigningReference(SignedXml signedXml, Reference reference)
		{
			if (VerboseLoggingEnabled)
			{
				HashAlgorithm hashAlgorithm = Utils.CreateFromName<HashAlgorithm>(reference.DigestMethod);
				string text = ((hashAlgorithm == null) ? "null" : hashAlgorithm.GetType().Name);
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_SigningReference"), GetObjectId(reference), reference.Uri, reference.Id, reference.Type, reference.DigestMethod, text);
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.SigningReference, data);
			}
		}

		internal static void LogVerificationFailure(SignedXml signedXml, string failureLocation)
		{
			if (InformationLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_VerificationFailed"), new object[1] { failureLocation });
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.VerificationFailure, data);
			}
		}

		internal static void LogVerificationResult(SignedXml signedXml, object key, bool verified)
		{
			if (InformationLoggingEnabled)
			{
				string format = (verified ? SecurityResources.GetResourceString("Log_VerificationWithKeySuccessful") : SecurityResources.GetResourceString("Log_VerificationWithKeyNotSuccessful"));
				string data = string.Format(CultureInfo.InvariantCulture, format, new object[1] { GetKeyName(key) });
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.SignatureVerificationResult, data);
			}
		}

		internal static void LogVerifyKeyUsage(SignedXml signedXml, X509Certificate certificate, X509KeyUsageExtension keyUsages)
		{
			if (InformationLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_KeyUsages"), new object[3]
				{
					keyUsages.KeyUsages,
					GetOidName(keyUsages.Oid),
					GetKeyName(certificate)
				});
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.X509Verification, data);
			}
		}

		internal static void LogVerifyReference(SignedXml signedXml, Reference reference)
		{
			if (InformationLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_VerifyReference"), GetObjectId(reference), reference.Uri, reference.Id, reference.Type);
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.VerifyReference, data);
			}
		}

		internal static void LogVerifyReferenceHash(SignedXml signedXml, Reference reference, byte[] actualHash, byte[] expectedHash)
		{
			if (VerboseLoggingEnabled)
			{
				HashAlgorithm hashAlgorithm = Utils.CreateFromName<HashAlgorithm>(reference.DigestMethod);
				string text = ((hashAlgorithm == null) ? "null" : hashAlgorithm.GetType().Name);
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_ReferenceHash"), GetObjectId(reference), reference.DigestMethod, text, FormatBytes(actualHash), FormatBytes(expectedHash));
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.VerifyReference, data);
			}
		}

		internal static void LogVerifySignedInfo(SignedXml signedXml, AsymmetricAlgorithm key, SignatureDescription signatureDescription, HashAlgorithm hashAlgorithm, AsymmetricSignatureDeformatter asymmetricSignatureDeformatter, byte[] actualHashValue, byte[] signatureValue)
		{
			if (InformationLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_VerifySignedInfoAsymmetric"), GetKeyName(key), signatureDescription.GetType().Name, hashAlgorithm.GetType().Name, asymmetricSignatureDeformatter.GetType().Name);
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.VerifySignedInfo, data);
			}
			if (VerboseLoggingEnabled)
			{
				string data2 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_ActualHashValue"), new object[1] { FormatBytes(actualHashValue) });
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.VerifySignedInfo, data2);
				string data3 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_RawSignatureValue"), new object[1] { FormatBytes(signatureValue) });
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.VerifySignedInfo, data3);
			}
		}

		internal static void LogVerifySignedInfo(SignedXml signedXml, KeyedHashAlgorithm mac, byte[] actualHashValue, byte[] signatureValue)
		{
			if (InformationLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_VerifySignedInfoHmac"), new object[1] { mac.GetType().Name });
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.VerifySignedInfo, data);
			}
			if (VerboseLoggingEnabled)
			{
				string data2 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_ActualHashValue"), new object[1] { FormatBytes(actualHashValue) });
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.VerifySignedInfo, data2);
				string data3 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_RawSignatureValue"), new object[1] { FormatBytes(signatureValue) });
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.VerifySignedInfo, data3);
			}
		}

		internal static void LogVerifyX509Chain(SignedXml signedXml, X509Chain chain, X509Certificate certificate)
		{
			if (InformationLoggingEnabled)
			{
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_BuildX509Chain"), new object[1] { GetKeyName(certificate) });
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.X509Verification, data);
			}
			if (VerboseLoggingEnabled)
			{
				string data2 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_RevocationMode"), new object[1] { chain.ChainPolicy.RevocationFlag });
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.X509Verification, data2);
				string data3 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_RevocationFlag"), new object[1] { chain.ChainPolicy.RevocationFlag });
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.X509Verification, data3);
				string data4 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_VerificationFlag"), new object[1] { chain.ChainPolicy.VerificationFlags });
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.X509Verification, data4);
				string data5 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_VerificationTime"), new object[1] { chain.ChainPolicy.VerificationTime });
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.X509Verification, data5);
				string data6 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_UrlTimeout"), new object[1] { chain.ChainPolicy.UrlRetrievalTimeout });
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.X509Verification, data6);
			}
			if (InformationLoggingEnabled)
			{
				X509ChainStatus[] chainStatus = chain.ChainStatus;
				for (int i = 0; i < chainStatus.Length; i++)
				{
					X509ChainStatus x509ChainStatus = chainStatus[i];
					if (x509ChainStatus.Status != 0)
					{
						string data7 = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_X509ChainError"), new object[2] { x509ChainStatus.Status, x509ChainStatus.StatusInformation });
						WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.X509Verification, data7);
					}
				}
			}
			if (VerboseLoggingEnabled)
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(SecurityResources.GetResourceString("Log_CertificateChain"));
				X509ChainElementEnumerator enumerator = chain.ChainElements.GetEnumerator();
				while (enumerator.MoveNext())
				{
					X509ChainElement current = enumerator.Current;
					stringBuilder.AppendFormat(CultureInfo.InvariantCulture, " {0}", new object[1] { GetKeyName(current.Certificate) });
				}
				WriteLine(signedXml, TraceEventType.Verbose, SignedXmlDebugEvent.X509Verification, stringBuilder.ToString());
			}
		}

		internal static void LogSignedXmlRecursionLimit(SignedXml signedXml, Reference reference)
		{
			if (InformationLoggingEnabled)
			{
				HashAlgorithm hashAlgorithm = Utils.CreateFromName<HashAlgorithm>(reference.DigestMethod);
				string text = ((hashAlgorithm == null) ? "null" : hashAlgorithm.GetType().Name);
				string data = string.Format(CultureInfo.InvariantCulture, SecurityResources.GetResourceString("Log_SignedXmlRecursionLimit"), new object[3]
				{
					GetObjectId(reference),
					reference.DigestMethod,
					text
				});
				WriteLine(signedXml, TraceEventType.Information, SignedXmlDebugEvent.VerifySignedInfo, data);
			}
		}

		private static void WriteLine(object source, TraceEventType eventType, SignedXmlDebugEvent eventId, string data)
		{
			s_traceSource.TraceEvent(eventType, (int)eventId, "[{0}, {1}] {2}", GetObjectId(source), eventId, data);
		}
	}
	internal static class SymmetricKeyWrap
	{
		private static readonly byte[] s_rgbTripleDES_KW_IV = new byte[8] { 74, 221, 162, 44, 121, 232, 33, 5 };

		private static readonly byte[] s_rgbAES_KW_IV = new byte[8] { 166, 166, 166, 166, 166, 166, 166, 166 };

		internal static byte[] TripleDESKeyWrapEncrypt(byte[] rgbKey, byte[] rgbWrappedKeyData)
		{
			SHA1CryptoServiceProvider sHA1CryptoServiceProvider = new SHA1CryptoServiceProvider();
			byte[] src = sHA1CryptoServiceProvider.ComputeHash(rgbWrappedKeyData);
			RNGCryptoServiceProvider rNGCryptoServiceProvider = new RNGCryptoServiceProvider();
			byte[] array = new byte[8];
			rNGCryptoServiceProvider.GetBytes(array);
			byte[] array2 = new byte[rgbWrappedKeyData.Length + 8];
			TripleDESCryptoServiceProvider tripleDESCryptoServiceProvider = new TripleDESCryptoServiceProvider();
			tripleDESCryptoServiceProvider.Padding = PaddingMode.None;
			ICryptoTransform cryptoTransform = tripleDESCryptoServiceProvider.CreateEncryptor(rgbKey, array);
			Buffer.BlockCopy(rgbWrappedKeyData, 0, array2, 0, rgbWrappedKeyData.Length);
			Buffer.BlockCopy(src, 0, array2, rgbWrappedKeyData.Length, 8);
			byte[] array3 = cryptoTransform.TransformFinalBlock(array2, 0, array2.Length);
			byte[] array4 = new byte[array.Length + array3.Length];
			Buffer.BlockCopy(array, 0, array4, 0, array.Length);
			Buffer.BlockCopy(array3, 0, array4, array.Length, array3.Length);
			Array.Reverse(array4);
			ICryptoTransform cryptoTransform2 = tripleDESCryptoServiceProvider.CreateEncryptor(rgbKey, s_rgbTripleDES_KW_IV);
			return cryptoTransform2.TransformFinalBlock(array4, 0, array4.Length);
		}

		internal static byte[] TripleDESKeyWrapDecrypt(byte[] rgbKey, byte[] rgbEncryptedWrappedKeyData)
		{
			if (rgbEncryptedWrappedKeyData.Length != 32 && rgbEncryptedWrappedKeyData.Length != 40 && rgbEncryptedWrappedKeyData.Length != 48)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_KW_BadKeySize"));
			}
			TripleDESCryptoServiceProvider tripleDESCryptoServiceProvider = new TripleDESCryptoServiceProvider();
			tripleDESCryptoServiceProvider.Padding = PaddingMode.None;
			ICryptoTransform cryptoTransform = tripleDESCryptoServiceProvider.CreateDecryptor(rgbKey, s_rgbTripleDES_KW_IV);
			byte[] array = cryptoTransform.TransformFinalBlock(rgbEncryptedWrappedKeyData, 0, rgbEncryptedWrappedKeyData.Length);
			Array.Reverse(array);
			byte[] array2 = new byte[8];
			Buffer.BlockCopy(array, 0, array2, 0, 8);
			byte[] array3 = new byte[array.Length - array2.Length];
			Buffer.BlockCopy(array, 8, array3, 0, array3.Length);
			ICryptoTransform cryptoTransform2 = tripleDESCryptoServiceProvider.CreateDecryptor(rgbKey, array2);
			byte[] array4 = cryptoTransform2.TransformFinalBlock(array3, 0, array3.Length);
			byte[] array5 = new byte[array4.Length - 8];
			Buffer.BlockCopy(array4, 0, array5, 0, array5.Length);
			SHA1CryptoServiceProvider sHA1CryptoServiceProvider = new SHA1CryptoServiceProvider();
			byte[] array6 = sHA1CryptoServiceProvider.ComputeHash(array5);
			int num = array5.Length;
			int num2 = 0;
			while (num < array4.Length)
			{
				if (array4[num] != array6[num2])
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_BadWrappedKeySize"));
				}
				num++;
				num2++;
			}
			return array5;
		}

		internal static byte[] AESKeyWrapEncrypt(byte[] rgbKey, byte[] rgbWrappedKeyData)
		{
			int num = rgbWrappedKeyData.Length >> 3;
			if (rgbWrappedKeyData.Length % 8 != 0 || num <= 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_KW_BadKeySize"));
			}
			Aes aes = Aes.Create();
			aes.Key = rgbKey;
			aes.Mode = CipherMode.ECB;
			aes.Padding = PaddingMode.None;
			using (aes)
			{
				using ICryptoTransform cryptoTransform = aes.CreateEncryptor();
				if (num == 1)
				{
					byte[] array = new byte[s_rgbAES_KW_IV.Length + rgbWrappedKeyData.Length];
					Buffer.BlockCopy(s_rgbAES_KW_IV, 0, array, 0, s_rgbAES_KW_IV.Length);
					Buffer.BlockCopy(rgbWrappedKeyData, 0, array, s_rgbAES_KW_IV.Length, rgbWrappedKeyData.Length);
					return cryptoTransform.TransformFinalBlock(array, 0, array.Length);
				}
				long num2 = 0L;
				byte[] array2 = new byte[num + 1 << 3];
				Buffer.BlockCopy(rgbWrappedKeyData, 0, array2, 8, rgbWrappedKeyData.Length);
				byte[] array3 = new byte[8];
				byte[] array4 = new byte[16];
				Buffer.BlockCopy(s_rgbAES_KW_IV, 0, array3, 0, 8);
				for (int i = 0; i <= 5; i++)
				{
					for (int j = 1; j <= num; j++)
					{
						num2 = j + i * num;
						Buffer.BlockCopy(array3, 0, array4, 0, 8);
						Buffer.BlockCopy(array2, 8 * j, array4, 8, 8);
						byte[] array5 = cryptoTransform.TransformFinalBlock(array4, 0, 16);
						for (int k = 0; k < 8; k++)
						{
							byte b = (byte)((num2 >> 8 * (7 - k)) & 0xFF);
							array3[k] = (byte)(b ^ array5[k]);
						}
						Buffer.BlockCopy(array5, 8, array2, 8 * j, 8);
					}
				}
				Buffer.BlockCopy(array3, 0, array2, 0, 8);
				return array2;
			}
		}

		internal static byte[] AESKeyWrapDecrypt(byte[] rgbKey, byte[] rgbEncryptedWrappedKeyData)
		{
			int num = (rgbEncryptedWrappedKeyData.Length >> 3) - 1;
			if (rgbEncryptedWrappedKeyData.Length % 8 != 0 || num <= 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_KW_BadKeySize"));
			}
			byte[] array = new byte[num << 3];
			Aes aes = Aes.Create();
			aes.Key = rgbKey;
			aes.Mode = CipherMode.ECB;
			aes.Padding = PaddingMode.None;
			using (aes)
			{
				using ICryptoTransform cryptoTransform = aes.CreateDecryptor();
				if (num == 1)
				{
					byte[] array2 = cryptoTransform.TransformFinalBlock(rgbEncryptedWrappedKeyData, 0, rgbEncryptedWrappedKeyData.Length);
					for (int i = 0; i < 8; i++)
					{
						if (array2[i] != s_rgbAES_KW_IV[i])
						{
							throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_BadWrappedKeySize"));
						}
					}
					Buffer.BlockCopy(array2, 8, array, 0, 8);
					return array;
				}
				long num2 = 0L;
				Buffer.BlockCopy(rgbEncryptedWrappedKeyData, 8, array, 0, array.Length);
				byte[] array3 = new byte[8];
				byte[] array4 = new byte[16];
				Buffer.BlockCopy(rgbEncryptedWrappedKeyData, 0, array3, 0, 8);
				for (int num3 = 5; num3 >= 0; num3--)
				{
					for (int num4 = num; num4 >= 1; num4--)
					{
						num2 = num4 + num3 * num;
						for (int j = 0; j < 8; j++)
						{
							byte b = (byte)((num2 >> 8 * (7 - j)) & 0xFF);
							array3[j] ^= b;
						}
						Buffer.BlockCopy(array3, 0, array4, 0, 8);
						Buffer.BlockCopy(array, 8 * (num4 - 1), array4, 8, 8);
						byte[] src = cryptoTransform.TransformFinalBlock(array4, 0, 16);
						Buffer.BlockCopy(src, 8, array, 8 * (num4 - 1), 8);
						Buffer.BlockCopy(src, 0, array3, 0, 8);
					}
				}
				for (int k = 0; k < 8; k++)
				{
					if (array3[k] != s_rgbAES_KW_IV[k])
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_BadWrappedKeySize"));
					}
				}
				return array;
			}
		}
	}
	/// <summary>Defines an ordered list of <see cref="T:System.Security.Cryptography.Xml.Transform" /> objects that is applied to unsigned content prior to digest calculation.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class TransformChain
	{
		private ArrayList m_transforms;

		/// <summary>Gets the number of transforms in the <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object.</summary>
		/// <returns>The number of transforms in the <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object.</returns>
		public int Count => m_transforms.Count;

		/// <summary>Gets the transform at the specified index in the <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object.</summary>
		/// <param name="index">The index into the <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object that specifies which transform to return.</param>
		/// <returns>The transform at the specified index in the <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="index" /> parameter is greater than the number of transforms.</exception>
		public Transform this[int index]
		{
			get
			{
				if (index >= m_transforms.Count)
				{
					throw new ArgumentException(SecurityResources.GetResourceString("ArgumentOutOfRange_Index"), "index");
				}
				return (Transform)m_transforms[index];
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> class.</summary>
		public TransformChain()
		{
			m_transforms = new ArrayList();
		}

		/// <summary>Adds a transform to the list of transforms to be applied to the unsigned content prior to digest calculation.</summary>
		/// <param name="transform">The transform to add to the list of transforms.</param>
		public void Add(Transform transform)
		{
			if (transform != null)
			{
				m_transforms.Add(transform);
			}
		}

		/// <summary>Returns an enumerator of the transforms in the <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object.</summary>
		/// <returns>An enumerator of the transforms in the <see cref="T:System.Security.Cryptography.Xml.TransformChain" /> object.</returns>
		public IEnumerator GetEnumerator()
		{
			return m_transforms.GetEnumerator();
		}

		internal Stream TransformToOctetStream(object inputObject, Type inputType, XmlResolver resolver, string baseUri)
		{
			object obj = inputObject;
			foreach (Transform transform in m_transforms)
			{
				if (obj == null || transform.AcceptsType(obj.GetType()))
				{
					transform.Resolver = resolver;
					transform.BaseURI = baseUri;
					transform.LoadInput(obj);
					obj = transform.GetOutput();
				}
				else if (obj is Stream)
				{
					if (!transform.AcceptsType(typeof(XmlDocument)))
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"));
					}
					Stream stream = obj as Stream;
					XmlDocument xmlDocument = new XmlDocument();
					xmlDocument.PreserveWhitespace = true;
					XmlReader reader = Utils.PreProcessStreamInput(stream, resolver, baseUri);
					xmlDocument.Load(reader);
					transform.LoadInput(xmlDocument);
					stream.Close();
					obj = transform.GetOutput();
				}
				else if (obj is XmlNodeList)
				{
					if (!transform.AcceptsType(typeof(Stream)))
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"));
					}
					CanonicalXml canonicalXml = new CanonicalXml((XmlNodeList)obj, resolver, includeComments: false);
					MemoryStream memoryStream = new MemoryStream(canonicalXml.GetBytes());
					transform.LoadInput(memoryStream);
					obj = transform.GetOutput();
					memoryStream.Close();
				}
				else
				{
					if (!(obj is XmlDocument))
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"));
					}
					if (!transform.AcceptsType(typeof(Stream)))
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"));
					}
					CanonicalXml canonicalXml2 = new CanonicalXml((XmlDocument)obj, resolver);
					MemoryStream memoryStream2 = new MemoryStream(canonicalXml2.GetBytes());
					transform.LoadInput(memoryStream2);
					obj = transform.GetOutput();
					memoryStream2.Close();
				}
			}
			if (obj is Stream)
			{
				return obj as Stream;
			}
			if (obj is XmlNodeList)
			{
				CanonicalXml canonicalXml3 = new CanonicalXml((XmlNodeList)obj, resolver, includeComments: false);
				return new MemoryStream(canonicalXml3.GetBytes());
			}
			if (obj is XmlDocument)
			{
				CanonicalXml canonicalXml4 = new CanonicalXml((XmlDocument)obj, resolver);
				return new MemoryStream(canonicalXml4.GetBytes());
			}
			throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"));
		}

		internal Stream TransformToOctetStream(Stream input, XmlResolver resolver, string baseUri)
		{
			return TransformToOctetStream(input, typeof(Stream), resolver, baseUri);
		}

		internal Stream TransformToOctetStream(XmlDocument document, XmlResolver resolver, string baseUri)
		{
			return TransformToOctetStream(document, typeof(XmlDocument), resolver, baseUri);
		}

		internal XmlElement GetXml(XmlDocument document, string ns)
		{
			XmlElement xmlElement = document.CreateElement("Transforms", ns);
			foreach (Transform transform in m_transforms)
			{
				if (transform != null)
				{
					XmlElement xml = transform.GetXml(document);
					if (xml != null)
					{
						xmlElement.AppendChild(xml);
					}
				}
			}
			return xmlElement;
		}

		internal void LoadXml(XmlElement value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(value.OwnerDocument.NameTable);
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			XmlNodeList xmlNodeList = value.SelectNodes("ds:Transform", xmlNamespaceManager);
			if (xmlNodeList.Count == 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Transforms");
			}
			m_transforms.Clear();
			for (int i = 0; i < xmlNodeList.Count; i++)
			{
				XmlElement xmlElement = (XmlElement)xmlNodeList.Item(i);
				string attribute = Utils.GetAttribute(xmlElement, "Algorithm", "http://www.w3.org/2000/09/xmldsig#");
				Transform transform = Utils.CreateFromName<Transform>(attribute);
				if (transform == null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
				}
				transform.LoadInnerXml(xmlElement.ChildNodes);
				m_transforms.Add(transform);
			}
		}
	}
	/// <summary>Represents the abstract base class from which all <see langword="&lt;Transform&gt;" /> elements that can be used in an XML digital signature derive.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class Transform
	{
		private string m_algorithm;

		private string m_baseUri;

		internal XmlResolver m_xmlResolver;

		private bool m_bResolverSet;

		private SignedXml m_signedXml;

		private Reference m_reference;

		private Hashtable m_propagatedNamespaces;

		private XmlElement m_context;

		internal string BaseURI
		{
			get
			{
				return m_baseUri;
			}
			set
			{
				m_baseUri = value;
			}
		}

		internal SignedXml SignedXml
		{
			get
			{
				return m_signedXml;
			}
			set
			{
				m_signedXml = value;
			}
		}

		internal Reference Reference
		{
			get
			{
				return m_reference;
			}
			set
			{
				m_reference = value;
			}
		}

		/// <summary>Gets or sets the Uniform Resource Identifier (URI) that identifies the algorithm performed by the current transform.</summary>
		/// <returns>The URI that identifies the algorithm performed by the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</returns>
		public string Algorithm
		{
			get
			{
				return m_algorithm;
			}
			set
			{
				m_algorithm = value;
			}
		}

		/// <summary>Sets the current <see cref="T:System.Xml.XmlResolver" /> object.</summary>
		/// <returns>The current <see cref="T:System.Xml.XmlResolver" /> object. This property defaults to an <see cref="T:System.Xml.XmlSecureResolver" /> object.</returns>
		[ComVisible(false)]
		public XmlResolver Resolver
		{
			internal get
			{
				return m_xmlResolver;
			}
			set
			{
				m_xmlResolver = value;
				m_bResolverSet = true;
			}
		}

		internal bool ResolverSet => m_bResolverSet;

		/// <summary>When overridden in a derived class, gets an array of types that are valid inputs to the <see cref="M:System.Security.Cryptography.Xml.Transform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</summary>
		/// <returns>An array of valid input types for the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object; you can pass only objects of one of these types to the <see cref="M:System.Security.Cryptography.Xml.Transform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</returns>
		public abstract Type[] InputTypes { get; }

		/// <summary>When overridden in a derived class, gets an array of types that are possible outputs from the <see cref="M:System.Security.Cryptography.Xml.Transform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</summary>
		/// <returns>An array of valid output types for the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object; only objects of one of these types are returned from the <see cref="M:System.Security.Cryptography.Xml.Transform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</returns>
		public abstract Type[] OutputTypes { get; }

		/// <summary>Gets or sets an <see cref="T:System.Xml.XmlElement" /> object that represents the document context under which the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object is running.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlElement" /> object that represents the document context under which the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object is running.</returns>
		[ComVisible(false)]
		public XmlElement Context
		{
			get
			{
				if (m_context != null)
				{
					return m_context;
				}
				Reference reference = Reference;
				return ((reference == null) ? SignedXml : reference.SignedXml)?.m_context;
			}
			set
			{
				m_context = value;
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Collections.Hashtable" /> object that contains the namespaces that are propagated into the signature.</summary>
		/// <returns>A <see cref="T:System.Collections.Hashtable" /> object that contains the namespaces that are propagated into the signature.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Security.Cryptography.Xml.Transform.PropagatedNamespaces" /> property was set to <see langword="null" />.</exception>
		[ComVisible(false)]
		public Hashtable PropagatedNamespaces
		{
			get
			{
				if (m_propagatedNamespaces != null)
				{
					return m_propagatedNamespaces;
				}
				Reference reference = Reference;
				SignedXml signedXml = ((reference == null) ? SignedXml : reference.SignedXml);
				if (reference != null && (reference.ReferenceTargetType != ReferenceTargetType.UriReference || reference.Uri == null || reference.Uri.Length == 0 || reference.Uri[0] != '#'))
				{
					m_propagatedNamespaces = new Hashtable(0);
					return m_propagatedNamespaces;
				}
				CanonicalXmlNodeList canonicalXmlNodeList = null;
				if (reference != null)
				{
					canonicalXmlNodeList = reference.m_namespaces;
				}
				else if (signedXml.m_context != null)
				{
					canonicalXmlNodeList = Utils.GetPropagatedAttributes(signedXml.m_context);
				}
				if (canonicalXmlNodeList == null)
				{
					m_propagatedNamespaces = new Hashtable(0);
					return m_propagatedNamespaces;
				}
				m_propagatedNamespaces = new Hashtable(canonicalXmlNodeList.Count);
				foreach (XmlNode item in canonicalXmlNodeList)
				{
					string key = ((item.Prefix.Length > 0) ? (item.Prefix + ":" + item.LocalName) : item.LocalName);
					if (!m_propagatedNamespaces.Contains(key))
					{
						m_propagatedNamespaces.Add(key, item.Value);
					}
				}
				return m_propagatedNamespaces;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.Transform" /> class.</summary>
		protected Transform()
		{
		}

		internal bool AcceptsType(Type inputType)
		{
			if (InputTypes != null)
			{
				for (int i = 0; i < InputTypes.Length; i++)
				{
					if (inputType == InputTypes[i] || inputType.IsSubclassOf(InputTypes[i]))
					{
						return true;
					}
				}
			}
			return false;
		}

		/// <summary>Returns the XML representation of the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</summary>
		/// <returns>The XML representation of the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</returns>
		public XmlElement GetXml()
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			return GetXml(xmlDocument);
		}

		internal XmlElement GetXml(XmlDocument document)
		{
			return GetXml(document, "Transform");
		}

		internal XmlElement GetXml(XmlDocument document, string name)
		{
			XmlElement xmlElement = document.CreateElement(name, "http://www.w3.org/2000/09/xmldsig#");
			if (!string.IsNullOrEmpty(Algorithm))
			{
				xmlElement.SetAttribute("Algorithm", Algorithm);
			}
			XmlNodeList innerXml = GetInnerXml();
			if (innerXml != null)
			{
				foreach (XmlNode item in innerXml)
				{
					xmlElement.AppendChild(document.ImportNode(item, deep: true));
				}
				return xmlElement;
			}
			return xmlElement;
		}

		/// <summary>When overridden in a derived class, parses the specified <see cref="T:System.Xml.XmlNodeList" /> object as transform-specific content of a <see langword="&lt;Transform&gt;" /> element and configures the internal state of the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object to match the <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <param name="nodeList">An <see cref="T:System.Xml.XmlNodeList" /> object that specifies transform-specific content for the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</param>
		public abstract void LoadInnerXml(XmlNodeList nodeList);

		/// <summary>When overridden in a derived class, returns an XML representation of the parameters of the <see cref="T:System.Security.Cryptography.Xml.Transform" /> object that are suitable to be included as subelements of an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <returns>A list of the XML nodes that represent the transform-specific content needed to describe the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object in an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</returns>
		protected abstract XmlNodeList GetInnerXml();

		/// <summary>When overridden in a derived class, loads the specified input into the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</summary>
		/// <param name="obj">The input to load into the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</param>
		public abstract void LoadInput(object obj);

		/// <summary>When overridden in a derived class, returns the output of the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</summary>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</returns>
		public abstract object GetOutput();

		/// <summary>When overridden in a derived class, returns the output of the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object of the specified type.</summary>
		/// <param name="type">The type of the output to return. This must be one of the types in the <see cref="P:System.Security.Cryptography.Xml.Transform.OutputTypes" /> property.</param>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.Transform" /> object as an object of the specified type.</returns>
		public abstract object GetOutput(Type type);

		/// <summary>When overridden in a derived class, returns the digest associated with a <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</summary>
		/// <param name="hash">The <see cref="T:System.Security.Cryptography.HashAlgorithm" /> object used to create a digest.</param>
		/// <returns>The digest associated with a <see cref="T:System.Security.Cryptography.Xml.Transform" /> object.</returns>
		[ComVisible(false)]
		public virtual byte[] GetDigestedOutput(HashAlgorithm hash)
		{
			return hash.ComputeHash((Stream)GetOutput(typeof(Stream)));
		}
	}
	/// <summary>Represents the C14N XML canonicalization transform for a digital signature as defined by the World Wide Web Consortium (W3C), without comments.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class XmlDsigC14NTransform : Transform
	{
		private Type[] _inputTypes = new Type[3]
		{
			typeof(Stream),
			typeof(XmlDocument),
			typeof(XmlNodeList)
		};

		private Type[] _outputTypes = new Type[1] { typeof(Stream) };

		private CanonicalXml _cXml;

		private bool _includeComments;

		/// <summary>Gets an array of types that are valid inputs to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigC14NTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object.</summary>
		/// <returns>An array of valid input types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object; you can pass only objects of one of these types to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigC14NTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object.</returns>
		public override Type[] InputTypes => _inputTypes;

		/// <summary>Gets an array of types that are possible outputs from the <see cref="M:System.Security.Cryptography.Xml.XmlDsigC14NTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object.</summary>
		/// <returns>An array of valid output types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object; the <see cref="M:System.Security.Cryptography.Xml.XmlDsigC14NTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object return only objects of one of these types.</returns>
		public override Type[] OutputTypes => _outputTypes;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> class.</summary>
		public XmlDsigC14NTransform()
		{
			base.Algorithm = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> class with comments, if specified.</summary>
		/// <param name="includeComments">
		///   <see langword="true" /> to include comments; otherwise, <see langword="false" />.</param>
		public XmlDsigC14NTransform(bool includeComments)
		{
			_includeComments = includeComments;
			base.Algorithm = (includeComments ? "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments" : "http://www.w3.org/TR/2001/REC-xml-c14n-20010315");
		}

		/// <summary>Parses the specified <see cref="T:System.Xml.XmlNodeList" /> object as transform-specific content of a <see langword="&lt;Transform&gt;" /> element; this method is not supported because this element has no inner XML elements.</summary>
		/// <param name="nodeList">An <see cref="T:System.Xml.XmlNodeList" /> object to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object.</param>
		public override void LoadInnerXml(XmlNodeList nodeList)
		{
			if (!Utils.GetAllowAdditionalSignatureNodes() && nodeList != null && nodeList.Count > 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
			}
		}

		/// <summary>Returns an XML representation of the parameters of an <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object that are suitable to be included as subelements of an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <returns>A list of the XML nodes that represent the transform-specific content needed to describe the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object in an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</returns>
		protected override XmlNodeList GetInnerXml()
		{
			return null;
		}

		/// <summary>Loads the specified input into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object.</summary>
		/// <param name="obj">The input to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="obj" /> parameter is a <see cref="T:System.IO.Stream" /> object and it is <see langword="null" />.</exception>
		public override void LoadInput(object obj)
		{
			XmlResolver resolver = (base.ResolverSet ? m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), base.BaseURI));
			if (obj is Stream)
			{
				_cXml = new CanonicalXml((Stream)obj, _includeComments, resolver, base.BaseURI);
				return;
			}
			if (obj is XmlDocument)
			{
				_cXml = new CanonicalXml((XmlDocument)obj, resolver, _includeComments);
				return;
			}
			if (obj is XmlNodeList)
			{
				_cXml = new CanonicalXml((XmlNodeList)obj, resolver, _includeComments);
				return;
			}
			throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "obj");
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object.</summary>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object.</returns>
		public override object GetOutput()
		{
			return new MemoryStream(_cXml.GetBytes());
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object of type <see cref="T:System.IO.Stream" />.</summary>
		/// <param name="type">The type of the output to return. <see cref="T:System.IO.Stream" /> is the only valid type for this parameter.</param>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object of type <see cref="T:System.IO.Stream" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="type" /> parameter is not a <see cref="T:System.IO.Stream" /> object.</exception>
		public override object GetOutput(Type type)
		{
			if (type != typeof(Stream) && !type.IsSubclassOf(typeof(Stream)))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"), "type");
			}
			return new MemoryStream(_cXml.GetBytes());
		}

		/// <summary>Returns the digest associated with an <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object.</summary>
		/// <param name="hash">The <see cref="T:System.Security.Cryptography.HashAlgorithm" /> object used to create a digest.</param>
		/// <returns>The digest associated with an <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NTransform" /> object.</returns>
		[ComVisible(false)]
		public override byte[] GetDigestedOutput(HashAlgorithm hash)
		{
			return _cXml.GetDigestedBytes(hash);
		}
	}
	/// <summary>Represents the C14N XML canonicalization transform for a digital signature as defined by the World Wide Web Consortium (W3C), with comments.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class XmlDsigC14NWithCommentsTransform : XmlDsigC14NTransform
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigC14NWithCommentsTransform" /> class.</summary>
		public XmlDsigC14NWithCommentsTransform()
			: base(includeComments: true)
		{
			base.Algorithm = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";
		}
	}
	/// <summary>Represents the exclusive C14N XML canonicalization transform for a digital signature as defined by the World Wide Web Consortium (W3C), without comments.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class XmlDsigExcC14NTransform : Transform
	{
		private Type[] _inputTypes = new Type[3]
		{
			typeof(Stream),
			typeof(XmlDocument),
			typeof(XmlNodeList)
		};

		private Type[] _outputTypes = new Type[1] { typeof(Stream) };

		private bool _includeComments;

		private string _inclusiveNamespacesPrefixList;

		private ExcCanonicalXml _excCanonicalXml;

		/// <summary>Gets or sets a string that contains namespace prefixes to canonicalize using the standard canonicalization algorithm.</summary>
		/// <returns>A string that contains namespace prefixes to canonicalize using the standard canonicalization algorithm.</returns>
		public string InclusiveNamespacesPrefixList
		{
			get
			{
				return _inclusiveNamespacesPrefixList;
			}
			set
			{
				_inclusiveNamespacesPrefixList = value;
			}
		}

		/// <summary>Gets an array of types that are valid inputs to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object.</summary>
		/// <returns>An array of valid input types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object; you can pass only objects of one of these types to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object.</returns>
		public override Type[] InputTypes => _inputTypes;

		/// <summary>Gets an array of types that are possible outputs from the <see cref="M:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object.</summary>
		/// <returns>An array of valid output types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object; the <see cref="Overload:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object return only objects of one of these types.</returns>
		public override Type[] OutputTypes => _outputTypes;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> class.</summary>
		public XmlDsigExcC14NTransform()
			: this(includeComments: false, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> class specifying a value that determines whether to include comments.</summary>
		/// <param name="includeComments">
		///   <see langword="true" /> to include comments; otherwise, <see langword="false" />.</param>
		public XmlDsigExcC14NTransform(bool includeComments)
			: this(includeComments, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> class specifying a list of namespace prefixes to canonicalize using the standard canonicalization algorithm.</summary>
		/// <param name="inclusiveNamespacesPrefixList">The namespace prefixes to canonicalize using the standard canonicalization algorithm.</param>
		public XmlDsigExcC14NTransform(string inclusiveNamespacesPrefixList)
			: this(includeComments: false, inclusiveNamespacesPrefixList)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> class specifying whether to include comments, and specifying a list of namespace prefixes.</summary>
		/// <param name="includeComments">
		///   <see langword="true" /> to include comments; otherwise, <see langword="false" />.</param>
		/// <param name="inclusiveNamespacesPrefixList">The namespace prefixes to canonicalize using the standard canonicalization algorithm.</param>
		public XmlDsigExcC14NTransform(bool includeComments, string inclusiveNamespacesPrefixList)
		{
			_includeComments = includeComments;
			_inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList;
			base.Algorithm = (includeComments ? "http://www.w3.org/2001/10/xml-exc-c14n#WithComments" : "http://www.w3.org/2001/10/xml-exc-c14n#");
		}

		/// <summary>Parses the specified <see cref="T:System.Xml.XmlNodeList" /> object as transform-specific content of a <see langword="&lt;Transform&gt;" /> element and configures the internal state of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object to match the <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <param name="nodeList">An <see cref="T:System.Xml.XmlNodeList" /> object that specifies transform-specific content for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object.</param>
		public override void LoadInnerXml(XmlNodeList nodeList)
		{
			if (nodeList == null)
			{
				return;
			}
			foreach (XmlNode node in nodeList)
			{
				if (!(node is XmlElement xmlElement))
				{
					continue;
				}
				if (xmlElement.LocalName.Equals("InclusiveNamespaces") && xmlElement.NamespaceURI.Equals("http://www.w3.org/2001/10/xml-exc-c14n#") && Utils.HasAttribute(xmlElement, "PrefixList", "http://www.w3.org/2000/09/xmldsig#"))
				{
					if (!Utils.VerifyAttributes(xmlElement, "PrefixList"))
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
					}
					InclusiveNamespacesPrefixList = Utils.GetAttribute(xmlElement, "PrefixList", "http://www.w3.org/2000/09/xmldsig#");
					break;
				}
				if (!Utils.GetAllowAdditionalSignatureNodes())
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
				}
			}
		}

		/// <summary>When overridden in a derived class, loads the specified input into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object.</summary>
		/// <param name="obj">The input to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="obj" /> parameter is not a <see cref="T:System.IO.Stream" /> object.  
		///  -or-  
		///  The <paramref name="obj" /> parameter is not an <see cref="T:System.Xml.XmlDocument" /> object.  
		///  -or-  
		///  The <paramref name="obj" /> parameter is not an <see cref="T:System.Xml.XmlNodeList" /> object.</exception>
		public override void LoadInput(object obj)
		{
			XmlResolver resolver = (base.ResolverSet ? m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), base.BaseURI));
			if (obj is Stream)
			{
				_excCanonicalXml = new ExcCanonicalXml((Stream)obj, _includeComments, _inclusiveNamespacesPrefixList, resolver, base.BaseURI);
				return;
			}
			if (obj is XmlDocument)
			{
				_excCanonicalXml = new ExcCanonicalXml((XmlDocument)obj, _includeComments, _inclusiveNamespacesPrefixList, resolver);
				return;
			}
			if (obj is XmlNodeList)
			{
				_excCanonicalXml = new ExcCanonicalXml((XmlNodeList)obj, _includeComments, _inclusiveNamespacesPrefixList, resolver);
				return;
			}
			throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_IncorrectObjectType"), "obj");
		}

		/// <summary>Returns an XML representation of the parameters of a <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object that are suitable to be included as subelements of an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <returns>A list of the XML nodes that represent the transform-specific content needed to describe the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object in an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</returns>
		protected override XmlNodeList GetInnerXml()
		{
			if (InclusiveNamespacesPrefixList == null)
			{
				return null;
			}
			XmlDocument xmlDocument = new XmlDocument();
			XmlElement xmlElement = xmlDocument.CreateElement("Transform", "http://www.w3.org/2000/09/xmldsig#");
			if (!string.IsNullOrEmpty(base.Algorithm))
			{
				xmlElement.SetAttribute("Algorithm", base.Algorithm);
			}
			XmlElement xmlElement2 = xmlDocument.CreateElement("InclusiveNamespaces", "http://www.w3.org/2001/10/xml-exc-c14n#");
			xmlElement2.SetAttribute("PrefixList", InclusiveNamespacesPrefixList);
			xmlElement.AppendChild(xmlElement2);
			return xmlElement.ChildNodes;
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object</summary>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object.</returns>
		public override object GetOutput()
		{
			return new MemoryStream(_excCanonicalXml.GetBytes());
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object as an object of the specified type.</summary>
		/// <param name="type">The type of the output to return. This must be one of the types in the <see cref="P:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform.OutputTypes" /> property.</param>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object as an object of the specified type.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="type" /> parameter is not a <see cref="T:System.IO.Stream" /> object.  
		///  -or-  
		///  The <paramref name="type" /> parameter does not derive from a <see cref="T:System.IO.Stream" /> object.</exception>
		public override object GetOutput(Type type)
		{
			if (type != typeof(Stream) && !type.IsSubclassOf(typeof(Stream)))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"), "type");
			}
			return new MemoryStream(_excCanonicalXml.GetBytes());
		}

		/// <summary>Returns the digest associated with a <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object.</summary>
		/// <param name="hash">The <see cref="T:System.Security.Cryptography.HashAlgorithm" /> object used to create a digest.</param>
		/// <returns>The digest associated with a <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NTransform" /> object.</returns>
		public override byte[] GetDigestedOutput(HashAlgorithm hash)
		{
			return _excCanonicalXml.GetDigestedBytes(hash);
		}
	}
	/// <summary>Represents the exclusive C14N XML canonicalization transform for a digital signature as defined by the World Wide Web Consortium (W3C), with comments.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class XmlDsigExcC14NWithCommentsTransform : XmlDsigExcC14NTransform
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NWithCommentsTransform" /> class.</summary>
		public XmlDsigExcC14NWithCommentsTransform()
			: base(includeComments: true)
		{
			base.Algorithm = "http://www.w3.org/2001/10/xml-exc-c14n#WithComments";
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigExcC14NWithCommentsTransform" /> class specifying a list of namespace prefixes to canonicalize using the standard canonicalization algorithm.</summary>
		/// <param name="inclusiveNamespacesPrefixList">The namespace prefixes to canonicalize using the standard canonicalization algorithm.</param>
		public XmlDsigExcC14NWithCommentsTransform(string inclusiveNamespacesPrefixList)
			: base(includeComments: true, inclusiveNamespacesPrefixList)
		{
			base.Algorithm = "http://www.w3.org/2001/10/xml-exc-c14n#WithComments";
		}
	}
	/// <summary>Represents the <see langword="Base64" /> decoding transform as defined in Section 6.6.2 of the XMLDSIG specification.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class XmlDsigBase64Transform : Transform
	{
		private Type[] _inputTypes = new Type[3]
		{
			typeof(Stream),
			typeof(XmlNodeList),
			typeof(XmlDocument)
		};

		private Type[] _outputTypes = new Type[1] { typeof(Stream) };

		private CryptoStream _cs;

		/// <summary>Gets an array of types that are valid inputs to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigBase64Transform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object.</summary>
		/// <returns>An array of valid input types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object; you can pass only objects of one of these types to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigBase64Transform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object.</returns>
		public override Type[] InputTypes => _inputTypes;

		/// <summary>Gets an array of types that are possible outputs from the <see cref="M:System.Security.Cryptography.Xml.XmlDsigBase64Transform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object.</summary>
		/// <returns>An array of valid output types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object; only objects of one of these types are returned from the <see cref="M:System.Security.Cryptography.Xml.XmlDsigBase64Transform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object.</returns>
		public override Type[] OutputTypes => _outputTypes;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> class.</summary>
		public XmlDsigBase64Transform()
		{
			base.Algorithm = "http://www.w3.org/2000/09/xmldsig#base64";
		}

		/// <summary>Parses the specified <see cref="T:System.Xml.XmlNodeList" /> object as transform-specific content of a <see langword="&lt;Transform&gt;" /> element; this method is not supported because the <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object has no inner XML elements.</summary>
		/// <param name="nodeList">An <see cref="T:System.Xml.XmlNodeList" /> object to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object.</param>
		public override void LoadInnerXml(XmlNodeList nodeList)
		{
			if (!Utils.GetAllowAdditionalSignatureNodes() && nodeList != null && nodeList.Count > 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
			}
		}

		/// <summary>Returns an XML representation of the parameters of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object that are suitable to be included as subelements of an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <returns>A list of the XML nodes that represent the transform-specific content needed to describe the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object in an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</returns>
		protected override XmlNodeList GetInnerXml()
		{
			return null;
		}

		/// <summary>Loads the specified input into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object.</summary>
		/// <param name="obj">The input to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="obj" /> parameter is a <see cref="T:System.IO.Stream" /> and it is <see langword="null" />.</exception>
		public override void LoadInput(object obj)
		{
			if (obj is Stream)
			{
				LoadStreamInput((Stream)obj);
			}
			else if (obj is XmlNodeList)
			{
				LoadXmlNodeListInput((XmlNodeList)obj);
			}
			else if (obj is XmlDocument)
			{
				LoadXmlNodeListInput(((XmlDocument)obj).SelectNodes("//."));
			}
		}

		private void LoadStreamInput(Stream inputStream)
		{
			if (inputStream == null)
			{
				throw new ArgumentException("obj");
			}
			MemoryStream memoryStream = new MemoryStream();
			byte[] array = new byte[1024];
			int num;
			do
			{
				num = inputStream.Read(array, 0, 1024);
				if (num <= 0)
				{
					continue;
				}
				int num2 = 0;
				int i;
				for (i = 0; i < num && !char.IsWhiteSpace((char)array[i]); i++)
				{
				}
				num2 = i;
				for (i++; i < num; i++)
				{
					if (!char.IsWhiteSpace((char)array[i]))
					{
						array[num2] = array[i];
						num2++;
					}
				}
				memoryStream.Write(array, 0, num2);
			}
			while (num > 0);
			memoryStream.Position = 0L;
			_cs = new CryptoStream(memoryStream, new FromBase64Transform(), CryptoStreamMode.Read);
		}

		private void LoadXmlNodeListInput(XmlNodeList nodeList)
		{
			StringBuilder stringBuilder = new StringBuilder();
			foreach (XmlNode node in nodeList)
			{
				XmlNode xmlNode2 = node.SelectSingleNode("self::text()");
				if (xmlNode2 != null)
				{
					stringBuilder.Append(xmlNode2.OuterXml);
				}
			}
			UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
			byte[] bytes = uTF8Encoding.GetBytes(stringBuilder.ToString());
			int num = 0;
			int i;
			for (i = 0; i < bytes.Length && !char.IsWhiteSpace((char)bytes[i]); i++)
			{
			}
			num = i;
			for (i++; i < bytes.Length; i++)
			{
				if (!char.IsWhiteSpace((char)bytes[i]))
				{
					bytes[num] = bytes[i];
					num++;
				}
			}
			MemoryStream stream = new MemoryStream(bytes, 0, num);
			_cs = new CryptoStream(stream, new FromBase64Transform(), CryptoStreamMode.Read);
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object.</summary>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object.</returns>
		public override object GetOutput()
		{
			return _cs;
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object of type <see cref="T:System.IO.Stream" />.</summary>
		/// <param name="type">The type of the output to return. <see cref="T:System.IO.Stream" /> is the only valid type for this parameter.</param>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigBase64Transform" /> object of type <see cref="T:System.IO.Stream" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="type" /> parameter is not a <see cref="T:System.IO.Stream" /> object.</exception>
		public override object GetOutput(Type type)
		{
			if (type != typeof(Stream) && !type.IsSubclassOf(typeof(Stream)))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"), "type");
			}
			return _cs;
		}
	}
	/// <summary>Represents the XPath transform for a digital signature as defined by the W3C.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class XmlDsigXPathTransform : Transform
	{
		private Type[] _inputTypes = new Type[3]
		{
			typeof(Stream),
			typeof(XmlNodeList),
			typeof(XmlDocument)
		};

		private Type[] _outputTypes = new Type[1] { typeof(XmlNodeList) };

		private string _xpathexpr;

		private XmlDocument _document;

		private XmlNamespaceManager _nsm;

		/// <summary>Gets an array of types that are valid inputs to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigXPathTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object.</summary>
		/// <returns>An array of valid input types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object; you can pass only objects of one of these types to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigXPathTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object.</returns>
		public override Type[] InputTypes => _inputTypes;

		/// <summary>Gets an array of types that are possible outputs from the <see cref="M:System.Security.Cryptography.Xml.XmlDsigXPathTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object.</summary>
		/// <returns>An array of valid output types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object; the <see cref="M:System.Security.Cryptography.Xml.XmlDsigXPathTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object return only objects of one of these types.</returns>
		public override Type[] OutputTypes => _outputTypes;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> class.</summary>
		public XmlDsigXPathTransform()
		{
			base.Algorithm = "http://www.w3.org/TR/1999/REC-xpath-19991116";
		}

		/// <summary>Parses the specified <see cref="T:System.Xml.XmlNodeList" /> object as transform-specific content of a <see langword="&lt;Transform&gt;" /> element and configures the internal state of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object to match the <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <param name="nodeList">An <see cref="T:System.Xml.XmlNodeList" /> object to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object.</param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="nodeList" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The <paramref name="nodeList" /> parameter does not contain an <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> element.</exception>
		public override void LoadInnerXml(XmlNodeList nodeList)
		{
			if (nodeList == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
			}
			foreach (XmlNode node in nodeList)
			{
				string text = null;
				string text2 = null;
				if (!(node is XmlElement xmlElement))
				{
					continue;
				}
				if (xmlElement.LocalName == "XPath")
				{
					_xpathexpr = xmlElement.InnerXml.Trim(null);
					XmlNodeReader xmlNodeReader = new XmlNodeReader(xmlElement);
					XmlNameTable nameTable = xmlNodeReader.NameTable;
					_nsm = new XmlNamespaceManager(nameTable);
					if (!Utils.VerifyAttributes(xmlElement, (string)null))
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
					}
					foreach (XmlAttribute attribute in xmlElement.Attributes)
					{
						if (attribute.Prefix == "xmlns")
						{
							text = attribute.LocalName;
							text2 = attribute.Value;
							if (text == null)
							{
								text = xmlElement.Prefix;
								text2 = xmlElement.NamespaceURI;
							}
							_nsm.AddNamespace(text, text2);
						}
					}
					break;
				}
				if (!Utils.GetAllowAdditionalSignatureNodes())
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
				}
			}
			if (_xpathexpr == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
			}
		}

		/// <summary>Returns an XML representation of the parameters of a <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object that are suitable to be included as subelements of an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <returns>A list of the XML nodes that represent the transform-specific content needed to describe the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object in an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</returns>
		protected override XmlNodeList GetInnerXml()
		{
			XmlDocument xmlDocument = new XmlDocument();
			XmlElement xmlElement = xmlDocument.CreateElement(null, "XPath", "http://www.w3.org/2000/09/xmldsig#");
			if (_nsm != null)
			{
				foreach (string item in _nsm)
				{
					switch (item)
					{
					case "xml":
					case "xmlns":
					case null:
						continue;
					}
					if (item.Length > 0)
					{
						xmlElement.SetAttribute("xmlns:" + item, _nsm.LookupNamespace(item));
					}
				}
			}
			xmlElement.InnerXml = _xpathexpr;
			xmlDocument.AppendChild(xmlElement);
			return xmlDocument.ChildNodes;
		}

		/// <summary>Loads the specified input into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object.</summary>
		/// <param name="obj">The input to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object.</param>
		public override void LoadInput(object obj)
		{
			if (obj is Stream)
			{
				LoadStreamInput((Stream)obj);
			}
			else if (obj is XmlNodeList)
			{
				LoadXmlNodeListInput((XmlNodeList)obj);
			}
			else if (obj is XmlDocument)
			{
				LoadXmlDocumentInput((XmlDocument)obj);
			}
		}

		private void LoadStreamInput(Stream stream)
		{
			XmlResolver xmlResolver = (base.ResolverSet ? m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), base.BaseURI));
			XmlReader reader = Utils.PreProcessStreamInput(stream, xmlResolver, base.BaseURI);
			_document = new XmlDocument();
			_document.PreserveWhitespace = true;
			_document.Load(reader);
		}

		private void LoadXmlNodeListInput(XmlNodeList nodeList)
		{
			XmlResolver resolver = (base.ResolverSet ? m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), base.BaseURI));
			CanonicalXml canonicalXml = new CanonicalXml(nodeList, resolver, includeComments: true);
			using MemoryStream stream = new MemoryStream(canonicalXml.GetBytes());
			LoadStreamInput(stream);
		}

		private void LoadXmlDocumentInput(XmlDocument doc)
		{
			_document = doc;
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object.</summary>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object.</returns>
		public override object GetOutput()
		{
			CanonicalXmlNodeList canonicalXmlNodeList = new CanonicalXmlNodeList();
			if (!string.IsNullOrEmpty(_xpathexpr))
			{
				XPathNavigator xPathNavigator = _document.CreateNavigator();
				XPathNodeIterator xPathNodeIterator = xPathNavigator.Select("//. | //@*");
				XPathExpression xPathExpression = xPathNavigator.Compile("boolean(" + _xpathexpr + ")");
				xPathExpression.SetContext(_nsm);
				while (xPathNodeIterator.MoveNext())
				{
					XmlNode node = ((IHasXmlNode)xPathNodeIterator.Current).GetNode();
					if ((bool)xPathNodeIterator.Current.Evaluate(xPathExpression))
					{
						canonicalXmlNodeList.Add(node);
					}
				}
				xPathNodeIterator = xPathNavigator.Select("//namespace::*");
				while (xPathNodeIterator.MoveNext())
				{
					XmlNode node2 = ((IHasXmlNode)xPathNodeIterator.Current).GetNode();
					canonicalXmlNodeList.Add(node2);
				}
			}
			return canonicalXmlNodeList;
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object of type <see cref="T:System.Xml.XmlNodeList" />.</summary>
		/// <param name="type">The type of the output to return. <see cref="T:System.Xml.XmlNodeList" /> is the only valid type for this parameter.</param>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXPathTransform" /> object of type <see cref="T:System.Xml.XmlNodeList" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="type" /> parameter is not an <see cref="T:System.Xml.XmlNodeList" /> object.</exception>
		public override object GetOutput(Type type)
		{
			if (type != typeof(XmlNodeList) && !type.IsSubclassOf(typeof(XmlNodeList)))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"), "type");
			}
			return (XmlNodeList)GetOutput();
		}
	}
	/// <summary>Represents the XSLT transform for a digital signature as defined by the W3C.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class XmlDsigXsltTransform : Transform
	{
		private Type[] _inputTypes = new Type[3]
		{
			typeof(Stream),
			typeof(XmlDocument),
			typeof(XmlNodeList)
		};

		private Type[] _outputTypes = new Type[1] { typeof(Stream) };

		private XmlNodeList _xslNodes;

		private string _xslFragment;

		private Stream _inputStream;

		private bool _includeComments;

		/// <summary>Gets an array of types that are valid inputs to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigXsltTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object.</summary>
		/// <returns>An array of valid input types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object; you can pass only objects of one of these types to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigXsltTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object.</returns>
		public override Type[] InputTypes => _inputTypes;

		/// <summary>Gets an array of types that are possible outputs from the <see cref="M:System.Security.Cryptography.Xml.XmlDsigXsltTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object.</summary>
		/// <returns>An array of valid output types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object; only objects of one of these types are returned from the <see cref="M:System.Security.Cryptography.Xml.XmlDsigXsltTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object.</returns>
		public override Type[] OutputTypes => _outputTypes;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> class.</summary>
		public XmlDsigXsltTransform()
		{
			base.Algorithm = "http://www.w3.org/TR/1999/REC-xslt-19991116";
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> class with comments, if specified.</summary>
		/// <param name="includeComments">
		///   <see langword="true" /> to include comments; otherwise, <see langword="false" />.</param>
		public XmlDsigXsltTransform(bool includeComments)
		{
			_includeComments = includeComments;
			base.Algorithm = "http://www.w3.org/TR/1999/REC-xslt-19991116";
		}

		/// <summary>Parses the specified <see cref="T:System.Xml.XmlNodeList" /> object as transform-specific content of a <see langword="&lt;Transform&gt;" /> element and configures the internal state of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object to match the <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <param name="nodeList">An <see cref="T:System.Xml.XmlNodeList" /> object that encapsulates an XSLT style sheet to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object. This style sheet is applied to the document loaded by the <see cref="M:System.Security.Cryptography.Xml.XmlDsigXsltTransform.LoadInput(System.Object)" /> method.</param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="nodeList" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The <paramref name="nodeList" /> parameter does not contain an <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object.</exception>
		public override void LoadInnerXml(XmlNodeList nodeList)
		{
			if (nodeList == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
			}
			XmlElement xmlElement = null;
			int num = 0;
			foreach (XmlNode node in nodeList)
			{
				if (node is XmlWhitespace)
				{
					continue;
				}
				if (node is XmlElement)
				{
					if (num != 0)
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
					}
					xmlElement = node as XmlElement;
					num++;
				}
				else
				{
					num++;
				}
			}
			if (num != 1 || xmlElement == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
			}
			_xslNodes = nodeList;
			_xslFragment = xmlElement.OuterXml.Trim(null);
		}

		/// <summary>Returns an XML representation of the parameters of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object that are suitable to be included as subelements of an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <returns>A list of the XML nodes that represent the transform-specific content needed to describe the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object in an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</returns>
		protected override XmlNodeList GetInnerXml()
		{
			return _xslNodes;
		}

		/// <summary>Loads the specified input into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object.</summary>
		/// <param name="obj">The input to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object.</param>
		public override void LoadInput(object obj)
		{
			if (_inputStream != null)
			{
				_inputStream.Close();
			}
			_inputStream = new MemoryStream();
			if (obj is Stream)
			{
				_inputStream = (Stream)obj;
			}
			else if (obj is XmlNodeList)
			{
				CanonicalXml canonicalXml = new CanonicalXml((XmlNodeList)obj, null, _includeComments);
				byte[] bytes = canonicalXml.GetBytes();
				if (bytes != null)
				{
					_inputStream.Write(bytes, 0, bytes.Length);
					_inputStream.Flush();
					_inputStream.Position = 0L;
				}
			}
			else if (obj is XmlDocument)
			{
				CanonicalXml canonicalXml2 = new CanonicalXml((XmlDocument)obj, null, _includeComments);
				byte[] bytes2 = canonicalXml2.GetBytes();
				if (bytes2 != null)
				{
					_inputStream.Write(bytes2, 0, bytes2.Length);
					_inputStream.Flush();
					_inputStream.Position = 0L;
				}
			}
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object.</summary>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object.</returns>
		public override object GetOutput()
		{
			XslCompiledTransform xslCompiledTransform = new XslCompiledTransform();
			XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
			xmlReaderSettings.XmlResolver = null;
			xmlReaderSettings.MaxCharactersFromEntities = Utils.GetMaxCharactersFromEntities();
			xmlReaderSettings.MaxCharactersInDocument = Utils.GetMaxCharactersInDocument();
			using StringReader input = new StringReader(_xslFragment);
			XmlReader stylesheet = XmlReader.Create((TextReader)input, xmlReaderSettings, (string)null);
			xslCompiledTransform.Load(stylesheet, XsltSettings.Default, null);
			XmlReader reader = XmlReader.Create(_inputStream, xmlReaderSettings, base.BaseURI);
			XPathDocument input2 = new XPathDocument(reader, XmlSpace.Preserve);
			MemoryStream memoryStream = new MemoryStream();
			XmlWriter results = new XmlTextWriter(memoryStream, null);
			xslCompiledTransform.Transform(input2, null, results);
			memoryStream.Position = 0L;
			return memoryStream;
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object of type <see cref="T:System.IO.Stream" />.</summary>
		/// <param name="type">The type of the output to return. <see cref="T:System.IO.Stream" /> is the only valid type for this parameter.</param>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigXsltTransform" /> object of type <see cref="T:System.IO.Stream" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="type" /> parameter is not a <see cref="T:System.IO.Stream" /> object.</exception>
		public override object GetOutput(Type type)
		{
			if (type != typeof(Stream) && !type.IsSubclassOf(typeof(Stream)))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"), "type");
			}
			return (Stream)GetOutput();
		}
	}
	/// <summary>Represents the enveloped signature transform for an XML digital signature as defined by the W3C.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class XmlDsigEnvelopedSignatureTransform : Transform
	{
		private Type[] _inputTypes = new Type[3]
		{
			typeof(Stream),
			typeof(XmlNodeList),
			typeof(XmlDocument)
		};

		private Type[] _outputTypes = new Type[2]
		{
			typeof(XmlNodeList),
			typeof(XmlDocument)
		};

		private XmlNodeList _inputNodeList;

		private bool _includeComments;

		private XmlNamespaceManager _nsm;

		private XmlDocument _containingDocument;

		private int _signaturePosition;

		internal int SignaturePosition
		{
			set
			{
				_signaturePosition = value;
			}
		}

		/// <summary>Gets an array of types that are valid inputs to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</summary>
		/// <returns>An array of valid input types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object; you can pass only objects of one of these types to the <see cref="M:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</returns>
		public override Type[] InputTypes => _inputTypes;

		/// <summary>Gets an array of types that are possible outputs from the <see cref="M:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</summary>
		/// <returns>An array of valid output types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object; only objects of one of these types are returned from the <see cref="M:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</returns>
		public override Type[] OutputTypes => _outputTypes;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> class.</summary>
		public XmlDsigEnvelopedSignatureTransform()
		{
			base.Algorithm = "http://www.w3.org/2000/09/xmldsig#enveloped-signature";
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> class with comments, if specified.</summary>
		/// <param name="includeComments">
		///   <see langword="true" /> to include comments; otherwise, <see langword="false" />.</param>
		public XmlDsigEnvelopedSignatureTransform(bool includeComments)
		{
			_includeComments = includeComments;
			base.Algorithm = "http://www.w3.org/2000/09/xmldsig#enveloped-signature";
		}

		/// <summary>Parses the specified <see cref="T:System.Xml.XmlNodeList" /> as transform-specific content of a <see langword="&lt;Transform&gt;" /> element and configures the internal state of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object to match the <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <param name="nodeList">An <see cref="T:System.Xml.XmlNodeList" /> to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</param>
		public override void LoadInnerXml(XmlNodeList nodeList)
		{
			if (!Utils.GetAllowAdditionalSignatureNodes() && nodeList != null && nodeList.Count > 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
			}
		}

		/// <summary>Returns an XML representation of the parameters of an <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object that are suitable to be included as subelements of an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <returns>A list of the XML nodes that represent the transform-specific content needed to describe the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object in an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</returns>
		protected override XmlNodeList GetInnerXml()
		{
			return null;
		}

		/// <summary>Loads the specified input into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</summary>
		/// <param name="obj">The input to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="obj" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The containing XML document is <see langword="null" />.</exception>
		public override void LoadInput(object obj)
		{
			if (obj is Stream)
			{
				LoadStreamInput((Stream)obj);
			}
			else if (obj is XmlNodeList)
			{
				LoadXmlNodeListInput((XmlNodeList)obj);
			}
			else if (obj is XmlDocument)
			{
				LoadXmlDocumentInput((XmlDocument)obj);
			}
		}

		private void LoadStreamInput(Stream stream)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			XmlResolver xmlResolver = (base.ResolverSet ? m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), base.BaseURI));
			XmlReader reader = Utils.PreProcessStreamInput(stream, xmlResolver, base.BaseURI);
			xmlDocument.Load(reader);
			_containingDocument = xmlDocument;
			if (_containingDocument == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_EnvelopedSignatureRequiresContext"));
			}
			_nsm = new XmlNamespaceManager(_containingDocument.NameTable);
			_nsm.AddNamespace("dsig", "http://www.w3.org/2000/09/xmldsig#");
		}

		private void LoadXmlNodeListInput(XmlNodeList nodeList)
		{
			if (nodeList == null)
			{
				throw new ArgumentNullException("nodeList");
			}
			_containingDocument = Utils.GetOwnerDocument(nodeList);
			if (_containingDocument == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_EnvelopedSignatureRequiresContext"));
			}
			_nsm = new XmlNamespaceManager(_containingDocument.NameTable);
			_nsm.AddNamespace("dsig", "http://www.w3.org/2000/09/xmldsig#");
			_inputNodeList = nodeList;
		}

		private void LoadXmlDocumentInput(XmlDocument doc)
		{
			if (doc == null)
			{
				throw new ArgumentNullException("doc");
			}
			_containingDocument = doc;
			_nsm = new XmlNamespaceManager(_containingDocument.NameTable);
			_nsm.AddNamespace("dsig", "http://www.w3.org/2000/09/xmldsig#");
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</summary>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The containing XML document is <see langword="null" />.</exception>
		public override object GetOutput()
		{
			if (_containingDocument == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_EnvelopedSignatureRequiresContext"));
			}
			if (_inputNodeList != null)
			{
				if (_signaturePosition == 0)
				{
					return _inputNodeList;
				}
				XmlNodeList xmlNodeList = _containingDocument.SelectNodes("//dsig:Signature", _nsm);
				if (xmlNodeList == null)
				{
					return _inputNodeList;
				}
				CanonicalXmlNodeList canonicalXmlNodeList = new CanonicalXmlNodeList();
				{
					foreach (XmlNode inputNode in _inputNodeList)
					{
						if (inputNode == null)
						{
							continue;
						}
						if (Utils.IsXmlNamespaceNode(inputNode) || Utils.IsNamespaceNode(inputNode))
						{
							canonicalXmlNodeList.Add(inputNode);
							continue;
						}
						try
						{
							XmlNode xmlNode2 = inputNode.SelectSingleNode("ancestor-or-self::dsig:Signature[1]", _nsm);
							int num = 0;
							foreach (XmlNode item in xmlNodeList)
							{
								num++;
								if (item == xmlNode2)
								{
									break;
								}
							}
							if (xmlNode2 == null || (xmlNode2 != null && num != _signaturePosition))
							{
								canonicalXmlNodeList.Add(inputNode);
							}
						}
						catch
						{
						}
					}
					return canonicalXmlNodeList;
				}
			}
			XmlNodeList xmlNodeList2 = _containingDocument.SelectNodes("//dsig:Signature", _nsm);
			if (xmlNodeList2 == null)
			{
				return _containingDocument;
			}
			if (xmlNodeList2.Count < _signaturePosition || _signaturePosition <= 0)
			{
				return _containingDocument;
			}
			xmlNodeList2[_signaturePosition - 1].ParentNode.RemoveChild(xmlNodeList2[_signaturePosition - 1]);
			return _containingDocument;
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object of type <see cref="T:System.Xml.XmlNodeList" />.</summary>
		/// <param name="type">The type of the output to return. <see cref="T:System.Xml.XmlNodeList" /> is the only valid type for this parameter.</param>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object of type <see cref="T:System.Xml.XmlNodeList" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="type" /> parameter is not an <see cref="T:System.Xml.XmlNodeList" /> object.</exception>
		public override object GetOutput(Type type)
		{
			if (type == typeof(XmlNodeList) || type.IsSubclassOf(typeof(XmlNodeList)))
			{
				if (_inputNodeList == null)
				{
					_inputNodeList = Utils.AllDescendantNodes(_containingDocument, includeComments: true);
				}
				return (XmlNodeList)GetOutput();
			}
			if (type == typeof(XmlDocument) || type.IsSubclassOf(typeof(XmlDocument)))
			{
				if (_inputNodeList != null)
				{
					throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"), "type");
				}
				return (XmlDocument)GetOutput();
			}
			throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"), "type");
		}
	}
	[Serializable]
	internal enum TransformInputType
	{
		XmlDocument = 1,
		XmlStream,
		XmlNodeSet
	}
	/// <summary>Specifies the order of XML Digital Signature and XML Encryption operations when both are performed on the same document.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class XmlDecryptionTransform : Transform
	{
		private Type[] m_inputTypes = new Type[2]
		{
			typeof(Stream),
			typeof(XmlDocument)
		};

		private Type[] m_outputTypes = new Type[1] { typeof(XmlDocument) };

		private XmlNodeList m_encryptedDataList;

		private ArrayList m_arrayListUri;

		private EncryptedXml m_exml;

		private XmlDocument m_containingDocument;

		private XmlNamespaceManager m_nsm;

		private const string XmlDecryptionTransformNamespaceUrl = "http://www.w3.org/2002/07/decrypt#";

		private ArrayList ExceptUris
		{
			get
			{
				if (m_arrayListUri == null)
				{
					m_arrayListUri = new ArrayList();
				}
				return m_arrayListUri;
			}
		}

		/// <summary>Gets or sets an <see cref="T:System.Security.Cryptography.Xml.EncryptedXml" /> object that contains information about the keys necessary to decrypt an XML document.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Xml.EncryptedXml" /> object that contains information about the keys necessary to decrypt an XML document.</returns>
		public EncryptedXml EncryptedXml
		{
			get
			{
				if (m_exml != null)
				{
					return m_exml;
				}
				Reference reference = base.Reference;
				SignedXml signedXml = ((reference == null) ? base.SignedXml : reference.SignedXml);
				if (signedXml == null || signedXml.EncryptedXml == null)
				{
					m_exml = new EncryptedXml(m_containingDocument);
				}
				else
				{
					m_exml = signedXml.EncryptedXml;
				}
				return m_exml;
			}
			set
			{
				m_exml = value;
			}
		}

		/// <summary>Gets an array of types that are valid inputs to the <see cref="M:System.Security.Cryptography.Xml.XmlDecryptionTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object.</summary>
		/// <returns>An array of valid input types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object; you can pass only objects of one of these types to the <see cref="M:System.Security.Cryptography.Xml.XmlDecryptionTransform.LoadInput(System.Object)" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object.</returns>
		public override Type[] InputTypes => m_inputTypes;

		/// <summary>Gets an array of types that are possible outputs from the <see cref="M:System.Security.Cryptography.Xml.XmlDecryptionTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object.</summary>
		/// <returns>An array of valid output types for the current <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object; only objects of one of these types are returned from the <see cref="M:System.Security.Cryptography.Xml.XmlDecryptionTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object.</returns>
		public override Type[] OutputTypes => m_outputTypes;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> class.</summary>
		public XmlDecryptionTransform()
		{
			base.Algorithm = "http://www.w3.org/2002/07/decrypt#XML";
		}

		/// <summary>Determines whether the ID attribute of an <see cref="T:System.Xml.XmlElement" /> object matches a specified value.</summary>
		/// <param name="inputElement">An <see cref="T:System.Xml.XmlElement" /> object with an ID attribute to compare with <paramref name="idValue" />.</param>
		/// <param name="idValue">The value to compare with the ID attribute of <paramref name="inputElement" />.</param>
		/// <returns>
		///   <see langword="true" /> if the ID attribute of the <paramref name="inputElement" /> parameter matches the <paramref name="idValue" /> parameter; otherwise, <see langword="false" />.</returns>
		protected virtual bool IsTargetElement(XmlElement inputElement, string idValue)
		{
			if (inputElement == null)
			{
				return false;
			}
			if (inputElement.GetAttribute("Id") == idValue || inputElement.GetAttribute("id") == idValue || inputElement.GetAttribute("ID") == idValue)
			{
				return true;
			}
			return false;
		}

		/// <summary>Adds a Uniform Resource Identifier (URI) to exclude from processing.</summary>
		/// <param name="uri">A Uniform Resource Identifier (URI) to exclude from processing</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="uri" /> parameter is <see langword="null" />.</exception>
		public void AddExceptUri(string uri)
		{
			if (uri == null)
			{
				throw new ArgumentNullException("uri");
			}
			ExceptUris.Add(uri);
		}

		/// <summary>Parses the specified <see cref="T:System.Xml.XmlNodeList" /> object as transform-specific content of a <see langword="&lt;Transform&gt;" /> element and configures the internal state of the current <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object to match the <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <param name="nodeList">An <see cref="T:System.Xml.XmlNodeList" /> object that specifies transform-specific content for the current <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object.</param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="nodeList" /> parameter is <see langword="null" />.  
		///  -or-  
		///  The Uniform Resource Identifier (URI) value of an <see cref="T:System.Xml.XmlNode" /> object in <paramref name="nodeList" /> was not found.  
		///  -or-  
		///  The length of the URI value of an <see cref="T:System.Xml.XmlNode" /> object in <paramref name="nodeList" /> is 0.  
		///  -or-  
		///  The first character of the URI value of an <see cref="T:System.Xml.XmlNode" /> object in <paramref name="nodeList" /> is not '#'.</exception>
		public override void LoadInnerXml(XmlNodeList nodeList)
		{
			if (nodeList == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
			}
			ExceptUris.Clear();
			foreach (XmlNode node in nodeList)
			{
				if (!(node is XmlElement xmlElement))
				{
					continue;
				}
				if (xmlElement.LocalName == "Except" && xmlElement.NamespaceURI == "http://www.w3.org/2002/07/decrypt#")
				{
					string attribute = Utils.GetAttribute(xmlElement, "URI", "http://www.w3.org/2002/07/decrypt#");
					if (attribute == null || attribute.Length == 0 || attribute[0] != '#')
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UriRequired"));
					}
					if (!Utils.VerifyAttributes(xmlElement, "URI"))
					{
						throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
					}
					string value = Utils.ExtractIdFromLocalUri(attribute);
					ExceptUris.Add(value);
				}
				else if (!Utils.GetAllowAdditionalSignatureNodes())
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
				}
			}
		}

		/// <summary>Returns an XML representation of the parameters of an <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object that are suitable to be included as subelements of an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <returns>A list of the XML nodes that represent the transform-specific content needed to describe the current <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object in an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</returns>
		protected override XmlNodeList GetInnerXml()
		{
			if (ExceptUris.Count == 0)
			{
				return null;
			}
			XmlDocument xmlDocument = new XmlDocument();
			XmlElement xmlElement = xmlDocument.CreateElement("Transform", "http://www.w3.org/2000/09/xmldsig#");
			if (!string.IsNullOrEmpty(base.Algorithm))
			{
				xmlElement.SetAttribute("Algorithm", base.Algorithm);
			}
			foreach (string exceptUri in ExceptUris)
			{
				XmlElement xmlElement2 = xmlDocument.CreateElement("Except", "http://www.w3.org/2002/07/decrypt#");
				xmlElement2.SetAttribute("URI", exceptUri);
				xmlElement.AppendChild(xmlElement2);
			}
			return xmlElement.ChildNodes;
		}

		/// <summary>When overridden in a derived class, loads the specified input into the current <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object.</summary>
		/// <param name="obj">The input to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlDecryptionTransform" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="obj" /> parameter is <see langword="null" />.</exception>
		public override void LoadInput(object obj)
		{
			if (obj is Stream)
			{
				LoadStreamInput((Stream)obj);
			}
			else if (obj is XmlDocument)
			{
				LoadXmlDocumentInput((XmlDocument)obj);
			}
		}

		private void LoadStreamInput(Stream stream)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			XmlResolver xmlResolver = (base.ResolverSet ? m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), base.BaseURI));
			XmlReader reader = Utils.PreProcessStreamInput(stream, xmlResolver, base.BaseURI);
			xmlDocument.Load(reader);
			m_containingDocument = xmlDocument;
			m_nsm = new XmlNamespaceManager(m_containingDocument.NameTable);
			m_nsm.AddNamespace("enc", "http://www.w3.org/2001/04/xmlenc#");
			m_encryptedDataList = xmlDocument.SelectNodes("//enc:EncryptedData", m_nsm);
		}

		private void LoadXmlDocumentInput(XmlDocument document)
		{
			if (document == null)
			{
				throw new ArgumentNullException("document");
			}
			m_containingDocument = document;
			m_nsm = new XmlNamespaceManager(document.NameTable);
			m_nsm.AddNamespace("enc", "http://www.w3.org/2001/04/xmlenc#");
			m_encryptedDataList = document.SelectNodes("//enc:EncryptedData", m_nsm);
		}

		private void ReplaceEncryptedData(XmlElement encryptedDataElement, byte[] decrypted)
		{
			XmlNode parentNode = encryptedDataElement.ParentNode;
			if (parentNode.NodeType == XmlNodeType.Document)
			{
				parentNode.InnerXml = EncryptedXml.Encoding.GetString(decrypted);
			}
			else
			{
				EncryptedXml.ReplaceData(encryptedDataElement, decrypted);
			}
		}

		private bool ProcessEncryptedDataItem(XmlElement encryptedDataElement)
		{
			if (ExceptUris.Count > 0)
			{
				for (int i = 0; i < ExceptUris.Count; i++)
				{
					if (IsTargetElement(encryptedDataElement, (string)ExceptUris[i]))
					{
						return false;
					}
				}
			}
			EncryptedData encryptedData = new EncryptedData();
			encryptedData.LoadXml(encryptedDataElement);
			SymmetricAlgorithm decryptionKey = EncryptedXml.GetDecryptionKey(encryptedData, null);
			if (decryptionKey == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_MissingDecryptionKey"));
			}
			byte[] decrypted = EncryptedXml.DecryptData(encryptedData, decryptionKey);
			ReplaceEncryptedData(encryptedDataElement, decrypted);
			return true;
		}

		private void ProcessElementRecursively(XmlNodeList encryptedDatas)
		{
			if (encryptedDatas == null || encryptedDatas.Count == 0)
			{
				return;
			}
			Queue queue = new Queue();
			foreach (XmlNode encryptedData in encryptedDatas)
			{
				queue.Enqueue(encryptedData);
			}
			XmlNode xmlNode = queue.Dequeue() as XmlNode;
			while (xmlNode != null)
			{
				if (xmlNode is XmlElement xmlElement && xmlElement.LocalName == "EncryptedData" && xmlElement.NamespaceURI == "http://www.w3.org/2001/04/xmlenc#")
				{
					XmlNode nextSibling = xmlElement.NextSibling;
					XmlNode parentNode = xmlElement.ParentNode;
					if (ProcessEncryptedDataItem(xmlElement))
					{
						XmlNode xmlNode2 = parentNode.FirstChild;
						while (xmlNode2 != null && xmlNode2.NextSibling != nextSibling)
						{
							xmlNode2 = xmlNode2.NextSibling;
						}
						if (xmlNode2 != null)
						{
							XmlNodeList xmlNodeList = xmlNode2.SelectNodes("//enc:EncryptedData", m_nsm);
							if (xmlNodeList.Count > 0)
							{
								foreach (XmlNode item in xmlNodeList)
								{
									queue.Enqueue(item);
								}
							}
						}
					}
				}
				if (queue.Count != 0)
				{
					xmlNode = queue.Dequeue() as XmlNode;
					continue;
				}
				break;
			}
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</summary>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A decryption key could not be found.</exception>
		public override object GetOutput()
		{
			if (m_encryptedDataList != null)
			{
				ProcessElementRecursively(m_encryptedDataList);
			}
			Utils.AddNamespaces(m_containingDocument.DocumentElement, base.PropagatedNamespaces);
			return m_containingDocument;
		}

		/// <summary>Returns the output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</summary>
		/// <param name="type">The type of the output to return. <see cref="T:System.Xml.XmlNodeList" /> is the only valid type for this parameter.</param>
		/// <returns>The output of the current <see cref="T:System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform" /> object.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="type" /> parameter is not an <see cref="T:System.Xml.XmlNodeList" /> object.</exception>
		public override object GetOutput(Type type)
		{
			if (type == typeof(XmlDocument))
			{
				return (XmlDocument)GetOutput();
			}
			throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"), "type");
		}
	}
	/// <summary>Represents the license transform algorithm used to normalize XrML licenses for signatures.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class XmlLicenseTransform : Transform
	{
		private Type[] inputTypes = new Type[1] { typeof(XmlDocument) };

		private Type[] outputTypes = new Type[1] { typeof(XmlDocument) };

		private XmlNamespaceManager namespaceManager;

		private XmlDocument license;

		private IRelDecryptor relDecryptor;

		private const string ElementIssuer = "issuer";

		private const string NamespaceUriCore = "urn:mpeg:mpeg21:2003:01-REL-R-NS";

		/// <summary>Gets an array of types that are valid inputs to the <see cref="P:System.Security.Cryptography.Xml.XmlLicenseTransform.OutputTypes" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</summary>
		/// <returns>An array of types that are valid inputs to the <see cref="P:System.Security.Cryptography.Xml.XmlLicenseTransform.OutputTypes" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object; you can pass only objects of one of these types to the <see cref="P:System.Security.Cryptography.Xml.XmlLicenseTransform.OutputTypes" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</returns>
		public override Type[] InputTypes => inputTypes;

		/// <summary>Gets an array of types that are valid outputs from the <see cref="P:System.Security.Cryptography.Xml.XmlLicenseTransform.OutputTypes" /> method of the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</summary>
		/// <returns>An array of valid output types for the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object; only objects of one of these types are returned from the <see cref="M:System.Security.Cryptography.Xml.XmlLicenseTransform.GetOutput" /> methods of the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</returns>
		public override Type[] OutputTypes => outputTypes;

		/// <summary>Gets or sets the decryptor of the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</summary>
		/// <returns>The decryptor of the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</returns>
		public IRelDecryptor Decryptor
		{
			get
			{
				return relDecryptor;
			}
			set
			{
				relDecryptor = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> class.</summary>
		public XmlLicenseTransform()
		{
			base.Algorithm = "urn:mpeg:mpeg21:2003:01-REL-R-NS:licenseTransform";
		}

		private void DecryptEncryptedGrants(XmlNodeList encryptedGrantList, IRelDecryptor decryptor)
		{
			XmlElement xmlElement = null;
			XmlElement xmlElement2 = null;
			XmlElement xmlElement3 = null;
			EncryptionMethod encryptionMethod = null;
			KeyInfo keyInfo = null;
			CipherData cipherData = null;
			int i = 0;
			for (int count = encryptedGrantList.Count; i < count; i++)
			{
				xmlElement = encryptedGrantList[i].SelectSingleNode("//r:encryptedGrant/enc:EncryptionMethod", namespaceManager) as XmlElement;
				xmlElement2 = encryptedGrantList[i].SelectSingleNode("//r:encryptedGrant/dsig:KeyInfo", namespaceManager) as XmlElement;
				xmlElement3 = encryptedGrantList[i].SelectSingleNode("//r:encryptedGrant/enc:CipherData", namespaceManager) as XmlElement;
				if (xmlElement != null && xmlElement2 != null && xmlElement3 != null)
				{
					encryptionMethod = new EncryptionMethod();
					keyInfo = new KeyInfo();
					cipherData = new CipherData();
					encryptionMethod.LoadXml(xmlElement);
					keyInfo.LoadXml(xmlElement2);
					cipherData.LoadXml(xmlElement3);
					MemoryStream memoryStream = null;
					Stream stream = null;
					StreamReader streamReader = null;
					try
					{
						memoryStream = new MemoryStream(cipherData.CipherValue);
						stream = relDecryptor.Decrypt(encryptionMethod, keyInfo, memoryStream);
						if (stream == null || stream.Length == 0L)
						{
							throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_XrmlUnableToDecryptGrant"));
						}
						streamReader = new StreamReader(stream);
						string innerXml = streamReader.ReadToEnd();
						encryptedGrantList[i].ParentNode.InnerXml = innerXml;
					}
					finally
					{
						memoryStream?.Close();
						stream?.Close();
						streamReader?.Close();
					}
					encryptionMethod = null;
					keyInfo = null;
					cipherData = null;
				}
				xmlElement = null;
				xmlElement2 = null;
				xmlElement3 = null;
			}
		}

		/// <summary>Returns an XML representation of the parameters of an <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object that are suitable to be included as subelements of an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</summary>
		/// <returns>A list of the XML nodes that represent the transform-specific content needed to describe the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object in an XMLDSIG <see langword="&lt;Transform&gt;" /> element.</returns>
		protected override XmlNodeList GetInnerXml()
		{
			return null;
		}

		/// <summary>Returns the output of an <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</summary>
		/// <returns>The output of the <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</returns>
		public override object GetOutput()
		{
			return license;
		}

		/// <summary>Returns the output of an <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</summary>
		/// <param name="type">The type of the output to return. <see cref="T:System.Xml.XmlDocument" /> is the only valid type for this parameter.</param>
		/// <returns>The output of the <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="type" /> parameter is not an <see cref="T:System.Xml.XmlDocument" /> object.</exception>
		public override object GetOutput(Type type)
		{
			if (type != typeof(XmlDocument) || !type.IsSubclassOf(typeof(XmlDocument)))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"), "type");
			}
			return GetOutput();
		}

		/// <summary>Parses the specified <see cref="T:System.Xml.XmlNodeList" /> object as transform-specific content of a <see langword="&lt;Transform&gt;" /> element; this method is not supported because the <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object has no inner XML elements.</summary>
		/// <param name="nodeList">An <see cref="T:System.Xml.XmlNodeList" /> object that encapsulates the transform to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</param>
		public override void LoadInnerXml(XmlNodeList nodeList)
		{
			if (!Utils.GetAllowAdditionalSignatureNodes() && nodeList != null && nodeList.Count > 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
			}
		}

		/// <summary>Loads the specified input into the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object.</summary>
		/// <param name="obj">The input to load into the current <see cref="T:System.Security.Cryptography.Xml.XmlLicenseTransform" /> object. The type of the input object must be <see cref="T:System.Xml.XmlDocument" />.</param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The context was not set before this transform was invoked.  
		///  -or-  
		///  The <see langword="&lt;issuer&gt;" /> element was not set before this transform was invoked.  
		///  -or-  
		///  The <see langword="&lt;license&gt;" /> element was not set before this transform was invoked.  
		///  -or-  
		///  The <see cref="P:System.Security.Cryptography.Xml.XmlLicenseTransform.Decryptor" /> property was not set before this transform was invoked.</exception>
		public override void LoadInput(object obj)
		{
			if (base.Context == null)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_XrmlMissingContext"));
			}
			license = new XmlDocument();
			license.PreserveWhitespace = true;
			namespaceManager = new XmlNamespaceManager(license.NameTable);
			namespaceManager.AddNamespace("dsig", "http://www.w3.org/2000/09/xmldsig#");
			namespaceManager.AddNamespace("enc", "http://www.w3.org/2001/04/xmlenc#");
			namespaceManager.AddNamespace("r", "urn:mpeg:mpeg21:2003:01-REL-R-NS");
			XmlElement xmlElement = null;
			XmlElement xmlElement2 = null;
			XmlNode xmlNode = null;
			if (!(base.Context.SelectSingleNode("ancestor-or-self::r:issuer[1]", namespaceManager) is XmlElement xmlElement3))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_XrmlMissingIssuer"));
			}
			xmlNode = xmlElement3.SelectSingleNode("descendant-or-self::dsig:Signature[1]", namespaceManager) as XmlElement;
			xmlNode?.ParentNode.RemoveChild(xmlNode);
			if (!(xmlElement3.SelectSingleNode("ancestor-or-self::r:license[1]", namespaceManager) is XmlElement xmlElement4))
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_XrmlMissingLicence"));
			}
			XmlNodeList xmlNodeList = xmlElement4.SelectNodes("descendant-or-self::r:license[1]/r:issuer", namespaceManager);
			int i = 0;
			for (int count = xmlNodeList.Count; i < count; i++)
			{
				if (xmlNodeList[i] != xmlElement3 && xmlNodeList[i].LocalName == "issuer" && xmlNodeList[i].NamespaceURI == "urn:mpeg:mpeg21:2003:01-REL-R-NS")
				{
					xmlNodeList[i].ParentNode.RemoveChild(xmlNodeList[i]);
				}
			}
			XmlNodeList xmlNodeList2 = xmlElement4.SelectNodes("/r:license/r:grant/r:encryptedGrant", namespaceManager);
			if (xmlNodeList2.Count > 0)
			{
				if (relDecryptor == null)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_XrmlMissingIRelDecryptor"));
				}
				DecryptEncryptedGrants(xmlNodeList2, relDecryptor);
			}
			license.InnerXml = xmlElement4.OuterXml;
		}
	}
	/// <summary>Defines methods that decrypt an XrML <see langword="&lt;encryptedGrant&gt;" /> element.</summary>
	public interface IRelDecryptor
	{
		/// <summary>Decrypts an XrML <see langword="&lt;encryptedGrant&gt;" /> element that is contained within a <see cref="T:System.IO.Stream" /> object.</summary>
		/// <param name="encryptionMethod">An <see cref="T:System.Security.Cryptography.Xml.EncryptionMethod" /> object that encapsulates the algorithm used for XML encryption.</param>
		/// <param name="keyInfo">A <see cref="T:System.Security.Cryptography.Xml.KeyInfo" /> object that contains an asymmetric key to use for decryption.</param>
		/// <param name="toDecrypt">A stream object that contains an <see langword="&lt;encryptedGrant&gt;" /> element to decrypt.</param>
		/// <returns>A <see cref="T:System.IO.Stream" /> object that contains a decrypted <see langword="&lt;encryptedGrant&gt;" /> element.</returns>
		Stream Decrypt(EncryptionMethod encryptionMethod, KeyInfo keyInfo, Stream toDecrypt);
	}
	[Serializable]
	internal enum CertUsageType
	{
		Verification,
		Decryption
	}
	internal class MyXmlDocument : XmlDocument
	{
		protected override XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI)
		{
			return CreateAttribute(prefix, localName, namespaceURI);
		}
	}
	internal class Utils
	{
		private static int? xmlDsigSearchDepth = null;

		private static long? maxCharactersFromEntities = null;

		private static bool s_readMaxCharactersInDocument = false;

		private static long s_maxCharactersInDocument = 0L;

		private static bool? s_allowAmbiguousReferenceTarget = null;

		private static bool? s_allowDetachedSignature = null;

		private static bool s_readRequireNCNameIdentifier = false;

		private static bool s_requireNCNameIdentifier = true;

		private static bool s_readMaxTransformsPerReference = false;

		private static long s_maxTransformsPerReference = 10L;

		private static bool s_readMaxReferencesPerSignedInfo = false;

		private static long s_maxReferencesPerSignedInfo = 100L;

		private static bool s_readAllowAdditionalSignatureNodes = false;

		private static bool s_allowAdditionalSignatureNodes = false;

		private static bool s_readSkipSignatureAttributeEnforcement = false;

		private static bool s_skipSignatureAttributeEnforcement = false;

		private static bool s_readAllowBareTypeReference = false;

		private static bool s_allowBareTypeReference = false;

		private static bool s_readLeaveCipherValueUnchecked = false;

		private static bool s_leaveCipherValueUnchecked = false;

		private static readonly char[] s_invalidChars = new char[5] { ',', '`', '[', '*', '&' };

		private Utils()
		{
		}

		private static bool HasNamespace(XmlElement element, string prefix, string value)
		{
			if (IsCommittedNamespace(element, prefix, value))
			{
				return true;
			}
			if (element.Prefix == prefix && element.NamespaceURI == value)
			{
				return true;
			}
			return false;
		}

		internal static bool IsCommittedNamespace(XmlElement element, string prefix, string value)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			string name = ((prefix.Length > 0) ? ("xmlns:" + prefix) : "xmlns");
			if (element.HasAttribute(name) && element.GetAttribute(name) == value)
			{
				return true;
			}
			return false;
		}

		internal static bool IsRedundantNamespace(XmlElement element, string prefix, string value)
		{
			if (element == null)
			{
				throw new ArgumentNullException("element");
			}
			for (XmlNode parentNode = element.ParentNode; parentNode != null; parentNode = parentNode.ParentNode)
			{
				if (parentNode is XmlElement element2 && HasNamespace(element2, prefix, value))
				{
					return true;
				}
			}
			return false;
		}

		internal static string GetAttribute(XmlElement element, string localName, string namespaceURI)
		{
			string text = (element.HasAttribute(localName) ? element.GetAttribute(localName) : null);
			if (text == null && element.HasAttribute(localName, namespaceURI))
			{
				text = element.GetAttribute(localName, namespaceURI);
			}
			return text;
		}

		internal static bool HasAttribute(XmlElement element, string localName, string namespaceURI)
		{
			if (!element.HasAttribute(localName))
			{
				return element.HasAttribute(localName, namespaceURI);
			}
			return true;
		}

		internal static bool IsNamespaceNode(XmlNode n)
		{
			if (n.NodeType == XmlNodeType.Attribute)
			{
				if (!n.Prefix.Equals("xmlns"))
				{
					if (n.Prefix.Length == 0)
					{
						return n.LocalName.Equals("xmlns");
					}
					return false;
				}
				return true;
			}
			return false;
		}

		internal static bool IsXmlNamespaceNode(XmlNode n)
		{
			if (n.NodeType == XmlNodeType.Attribute)
			{
				return n.Prefix.Equals("xml");
			}
			return false;
		}

		internal static bool IsDefaultNamespaceNode(XmlNode n)
		{
			bool flag = n.NodeType == XmlNodeType.Attribute && n.Prefix.Length == 0 && n.LocalName.Equals("xmlns");
			bool flag2 = IsXmlNamespaceNode(n);
			return flag || flag2;
		}

		internal static bool IsEmptyDefaultNamespaceNode(XmlNode n)
		{
			if (IsDefaultNamespaceNode(n))
			{
				return n.Value.Length == 0;
			}
			return false;
		}

		internal static string GetNamespacePrefix(XmlAttribute a)
		{
			if (a.Prefix.Length != 0)
			{
				return a.LocalName;
			}
			return string.Empty;
		}

		internal static bool HasNamespacePrefix(XmlAttribute a, string nsPrefix)
		{
			return GetNamespacePrefix(a).Equals(nsPrefix);
		}

		internal static bool IsNonRedundantNamespaceDecl(XmlAttribute a, XmlAttribute nearestAncestorWithSamePrefix)
		{
			if (nearestAncestorWithSamePrefix == null)
			{
				return !IsEmptyDefaultNamespaceNode(a);
			}
			return !nearestAncestorWithSamePrefix.Value.Equals(a.Value);
		}

		internal static bool IsXmlPrefixDefinitionNode(XmlAttribute a)
		{
			return false;
		}

		internal static string DiscardWhiteSpaces(string inputBuffer)
		{
			return DiscardWhiteSpaces(inputBuffer, 0, inputBuffer.Length);
		}

		internal static string DiscardWhiteSpaces(string inputBuffer, int inputOffset, int inputCount)
		{
			int num = 0;
			for (int i = 0; i < inputCount; i++)
			{
				if (char.IsWhiteSpace(inputBuffer[inputOffset + i]))
				{
					num++;
				}
			}
			char[] array = new char[inputCount - num];
			num = 0;
			for (int i = 0; i < inputCount; i++)
			{
				if (!char.IsWhiteSpace(inputBuffer[inputOffset + i]))
				{
					array[num++] = inputBuffer[inputOffset + i];
				}
			}
			return new string(array);
		}

		internal static void SBReplaceCharWithString(StringBuilder sb, char oldChar, string newString)
		{
			int num = 0;
			int length = newString.Length;
			while (num < sb.Length)
			{
				if (sb[num] == oldChar)
				{
					sb.Remove(num, 1);
					sb.Insert(num, newString);
					num += length;
				}
				else
				{
					num++;
				}
			}
		}

		internal static XmlReader PreProcessStreamInput(Stream inputStream, XmlResolver xmlResolver, string baseUri)
		{
			XmlReaderSettings secureXmlReaderSettings = GetSecureXmlReaderSettings(xmlResolver);
			return XmlReader.Create(inputStream, secureXmlReaderSettings, baseUri);
		}

		internal static XmlReaderSettings GetSecureXmlReaderSettings(XmlResolver xmlResolver)
		{
			XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
			xmlReaderSettings.XmlResolver = xmlResolver;
			xmlReaderSettings.DtdProcessing = DtdProcessing.Parse;
			xmlReaderSettings.MaxCharactersFromEntities = GetMaxCharactersFromEntities();
			xmlReaderSettings.MaxCharactersInDocument = GetMaxCharactersInDocument();
			return xmlReaderSettings;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static int GetXmlDsigSearchDepth()
		{
			if (xmlDsigSearchDepth.HasValue)
			{
				return xmlDsigSearchDepth.Value;
			}
			long netFxSecurityRegistryValue = GetNetFxSecurityRegistryValue("SignedDigitalSignatureXmlMaxDepth", 20L);
			xmlDsigSearchDepth = (int)netFxSecurityRegistryValue;
			return xmlDsigSearchDepth.Value;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static long GetMaxCharactersFromEntities()
		{
			if (maxCharactersFromEntities.HasValue)
			{
				return maxCharactersFromEntities.Value;
			}
			long netFxSecurityRegistryValue = GetNetFxSecurityRegistryValue("SignedXmlMaxCharactersFromEntities", 10000000L);
			maxCharactersFromEntities = netFxSecurityRegistryValue;
			return maxCharactersFromEntities.Value;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static long GetMaxCharactersInDocument()
		{
			if (s_readMaxCharactersInDocument)
			{
				return s_maxCharactersInDocument;
			}
			long num = (s_maxCharactersInDocument = GetNetFxSecurityRegistryValue("SignedXmlMaxCharactersInDocument", 0L));
			Thread.MemoryBarrier();
			s_readMaxCharactersInDocument = true;
			return s_maxCharactersInDocument;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static bool AllowAmbiguousReferenceTargets()
		{
			if (s_allowAmbiguousReferenceTarget.HasValue)
			{
				return s_allowAmbiguousReferenceTarget.Value;
			}
			long netFxSecurityRegistryValue = GetNetFxSecurityRegistryValue("SignedXmlAllowAmbiguousReferenceTargets", 0L);
			bool value = netFxSecurityRegistryValue != 0;
			s_allowAmbiguousReferenceTarget = value;
			return s_allowAmbiguousReferenceTarget.Value;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static bool AllowDetachedSignature()
		{
			if (s_allowDetachedSignature.HasValue)
			{
				return s_allowDetachedSignature.Value;
			}
			long netFxSecurityRegistryValue = GetNetFxSecurityRegistryValue("SignedXmlAllowDetachedSignature", 0L);
			bool value = netFxSecurityRegistryValue != 0;
			s_allowDetachedSignature = value;
			return s_allowDetachedSignature.Value;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static bool RequireNCNameIdentifier()
		{
			if (s_readRequireNCNameIdentifier)
			{
				return s_requireNCNameIdentifier;
			}
			long netFxSecurityRegistryValue = GetNetFxSecurityRegistryValue("SignedXmlRequireNCNameIdentifier", 1L);
			bool flag = (s_requireNCNameIdentifier = netFxSecurityRegistryValue != 0);
			Thread.MemoryBarrier();
			s_readRequireNCNameIdentifier = true;
			return s_requireNCNameIdentifier;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static long GetMaxTransformsPerReference()
		{
			if (s_readMaxTransformsPerReference)
			{
				return s_maxTransformsPerReference;
			}
			long num = (s_maxTransformsPerReference = GetNetFxSecurityRegistryValue("SignedXmlMaxTransformsPerReference", 10L));
			Thread.MemoryBarrier();
			s_readMaxTransformsPerReference = true;
			return s_maxTransformsPerReference;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static long GetMaxReferencesPerSignedInfo()
		{
			if (s_readMaxReferencesPerSignedInfo)
			{
				return s_maxReferencesPerSignedInfo;
			}
			long num = (s_maxReferencesPerSignedInfo = GetNetFxSecurityRegistryValue("SignedXmlMaxReferencesPerSignedInfo", 100L));
			Thread.MemoryBarrier();
			s_readMaxReferencesPerSignedInfo = true;
			return s_maxReferencesPerSignedInfo;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static bool GetAllowAdditionalSignatureNodes()
		{
			if (s_readAllowAdditionalSignatureNodes)
			{
				return s_allowAdditionalSignatureNodes;
			}
			long netFxSecurityRegistryValue = GetNetFxSecurityRegistryValue("SignedXmlAllowAdditionalSignatureNodes", 0L);
			bool flag = (s_allowAdditionalSignatureNodes = netFxSecurityRegistryValue != 0);
			Thread.MemoryBarrier();
			s_readAllowAdditionalSignatureNodes = true;
			return s_allowAdditionalSignatureNodes;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static bool GetSkipSignatureAttributeEnforcement()
		{
			if (s_readSkipSignatureAttributeEnforcement)
			{
				return s_skipSignatureAttributeEnforcement;
			}
			long netFxSecurityRegistryValue = GetNetFxSecurityRegistryValue("SignedXmlSkipSignatureAttributeEnforcement", 0L);
			bool flag = (s_skipSignatureAttributeEnforcement = netFxSecurityRegistryValue != 0);
			Thread.MemoryBarrier();
			s_readSkipSignatureAttributeEnforcement = true;
			return s_skipSignatureAttributeEnforcement;
		}

		internal static bool VerifyAttributes(XmlElement element, string expectedAttrName)
		{
			return VerifyAttributes(element, (expectedAttrName == null) ? null : new string[1] { expectedAttrName });
		}

		internal static bool VerifyAttributes(XmlElement element, string[] expectedAttrNames)
		{
			if (!GetSkipSignatureAttributeEnforcement())
			{
				foreach (XmlAttribute attribute in element.Attributes)
				{
					bool flag = attribute.Name == "xmlns" || attribute.Name.StartsWith("xmlns:") || attribute.Name == "xml:space" || attribute.Name == "xml:lang" || attribute.Name == "xml:base";
					int num = 0;
					while (!flag && expectedAttrNames != null && num < expectedAttrNames.Length)
					{
						flag = attribute.Name == expectedAttrNames[num];
						num++;
					}
					if (!flag)
					{
						return false;
					}
				}
			}
			return true;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static bool GetAllowBareTypeReference()
		{
			if (s_readAllowBareTypeReference)
			{
				return s_allowBareTypeReference;
			}
			long netFxSecurityRegistryValue = GetNetFxSecurityRegistryValue("CryptoXmlAllowBareTypeReference", 0L);
			bool flag = (s_allowBareTypeReference = netFxSecurityRegistryValue != 0);
			Thread.MemoryBarrier();
			s_readAllowBareTypeReference = true;
			return s_allowBareTypeReference;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		internal static bool GetLeaveCipherValueUnchecked()
		{
			if (s_readLeaveCipherValueUnchecked)
			{
				return s_leaveCipherValueUnchecked;
			}
			long netFxSecurityRegistryValue = GetNetFxSecurityRegistryValue("EncryptedXmlLeaveCipherValueUnchecked", 0L);
			bool flag = (s_leaveCipherValueUnchecked = netFxSecurityRegistryValue != 0);
			Thread.MemoryBarrier();
			s_readLeaveCipherValueUnchecked = true;
			return s_leaveCipherValueUnchecked;
		}

		internal static T CreateFromName<T>(string key) where T : class
		{
			if (GetAllowBareTypeReference())
			{
				return CryptoConfig.CreateFromName(key) as T;
			}
			if (key == null || key.IndexOfAny(s_invalidChars) >= 0)
			{
				return null;
			}
			try
			{
				return CryptoConfig.CreateFromName(key) as T;
			}
			catch (Exception)
			{
				return null;
			}
		}

		private static long GetNetFxSecurityRegistryValue(string regValueName, long defaultValue)
		{
			try
			{
				using RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\.NETFramework\\Security", writable: false);
				if (registryKey != null)
				{
					object value = registryKey.GetValue(regValueName);
					if (value != null)
					{
						RegistryValueKind valueKind = registryKey.GetValueKind(regValueName);
						if (valueKind == RegistryValueKind.DWord || valueKind == RegistryValueKind.QWord)
						{
							return Convert.ToInt64(value, CultureInfo.InvariantCulture);
						}
						return defaultValue;
					}
					return defaultValue;
				}
				return defaultValue;
			}
			catch (SecurityException)
			{
				return defaultValue;
			}
		}

		internal static XmlDocument PreProcessDocumentInput(XmlDocument document, XmlResolver xmlResolver, string baseUri)
		{
			if (document == null)
			{
				throw new ArgumentNullException("document");
			}
			MyXmlDocument myXmlDocument = new MyXmlDocument();
			myXmlDocument.PreserveWhitespace = document.PreserveWhitespace;
			using TextReader input = new StringReader(document.OuterXml);
			XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
			xmlReaderSettings.XmlResolver = xmlResolver;
			xmlReaderSettings.DtdProcessing = DtdProcessing.Parse;
			xmlReaderSettings.MaxCharactersFromEntities = GetMaxCharactersFromEntities();
			xmlReaderSettings.MaxCharactersInDocument = GetMaxCharactersInDocument();
			XmlReader reader = XmlReader.Create(input, xmlReaderSettings, baseUri);
			myXmlDocument.Load(reader);
			return myXmlDocument;
		}

		internal static XmlDocument PreProcessElementInput(XmlElement elem, XmlResolver xmlResolver, string baseUri)
		{
			if (elem == null)
			{
				throw new ArgumentNullException("elem");
			}
			MyXmlDocument myXmlDocument = new MyXmlDocument();
			myXmlDocument.PreserveWhitespace = true;
			using TextReader input = new StringReader(elem.OuterXml);
			XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
			xmlReaderSettings.XmlResolver = xmlResolver;
			xmlReaderSettings.DtdProcessing = DtdProcessing.Parse;
			xmlReaderSettings.MaxCharactersFromEntities = GetMaxCharactersFromEntities();
			xmlReaderSettings.MaxCharactersInDocument = GetMaxCharactersInDocument();
			XmlReader reader = XmlReader.Create(input, xmlReaderSettings, baseUri);
			myXmlDocument.Load(reader);
			return myXmlDocument;
		}

		internal static XmlDocument DiscardComments(XmlDocument document)
		{
			XmlNodeList xmlNodeList = document.SelectNodes("//comment()");
			if (xmlNodeList != null)
			{
				foreach (XmlNode item in xmlNodeList)
				{
					item.ParentNode.RemoveChild(item);
				}
				return document;
			}
			return document;
		}

		internal static XmlNodeList AllDescendantNodes(XmlNode node, bool includeComments)
		{
			CanonicalXmlNodeList canonicalXmlNodeList = new CanonicalXmlNodeList();
			CanonicalXmlNodeList canonicalXmlNodeList2 = new CanonicalXmlNodeList();
			CanonicalXmlNodeList canonicalXmlNodeList3 = new CanonicalXmlNodeList();
			CanonicalXmlNodeList canonicalXmlNodeList4 = new CanonicalXmlNodeList();
			int num = 0;
			canonicalXmlNodeList2.Add(node);
			do
			{
				XmlNode xmlNode = canonicalXmlNodeList2[num];
				XmlNodeList childNodes = xmlNode.ChildNodes;
				if (childNodes != null)
				{
					foreach (XmlNode item in childNodes)
					{
						if (includeComments || !(item is XmlComment))
						{
							canonicalXmlNodeList2.Add(item);
						}
					}
				}
				XmlAttributeCollection attributes = xmlNode.Attributes;
				if (attributes != null)
				{
					foreach (XmlNode attribute in xmlNode.Attributes)
					{
						if (attribute.LocalName == "xmlns" || attribute.Prefix == "xmlns")
						{
							canonicalXmlNodeList4.Add(attribute);
						}
						else
						{
							canonicalXmlNodeList3.Add(attribute);
						}
					}
				}
				num++;
			}
			while (num < canonicalXmlNodeList2.Count);
			foreach (XmlNode item2 in canonicalXmlNodeList2)
			{
				canonicalXmlNodeList.Add(item2);
			}
			foreach (XmlNode item3 in canonicalXmlNodeList3)
			{
				canonicalXmlNodeList.Add(item3);
			}
			foreach (XmlNode item4 in canonicalXmlNodeList4)
			{
				canonicalXmlNodeList.Add(item4);
			}
			return canonicalXmlNodeList;
		}

		internal static bool NodeInList(XmlNode node, XmlNodeList nodeList)
		{
			foreach (XmlNode node2 in nodeList)
			{
				if (node2 == node)
				{
					return true;
				}
			}
			return false;
		}

		internal static string GetIdFromLocalUri(string uri, out bool discardComments)
		{
			string text = uri.Substring(1);
			discardComments = true;
			if (text.StartsWith("xpointer(id(", StringComparison.Ordinal))
			{
				int num = text.IndexOf("id(", StringComparison.Ordinal);
				int num2 = text.IndexOf(")", StringComparison.Ordinal);
				if (num2 < 0 || num2 < num + 3)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidReference"));
				}
				text = text.Substring(num + 3, num2 - num - 3);
				text = text.Replace("'", "");
				text = text.Replace("\"", "");
				discardComments = false;
			}
			return text;
		}

		internal static string ExtractIdFromLocalUri(string uri)
		{
			string text = uri.Substring(1);
			if (text.StartsWith("xpointer(id(", StringComparison.Ordinal))
			{
				int num = text.IndexOf("id(", StringComparison.Ordinal);
				int num2 = text.IndexOf(")", StringComparison.Ordinal);
				if (num2 < 0 || num2 < num + 3)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidReference"));
				}
				text = text.Substring(num + 3, num2 - num - 3);
				text = text.Replace("'", "");
				text = text.Replace("\"", "");
			}
			return text;
		}

		internal static void RemoveAllChildren(XmlElement inputElement)
		{
			XmlNode xmlNode = inputElement.FirstChild;
			XmlNode xmlNode2 = null;
			while (xmlNode != null)
			{
				xmlNode2 = xmlNode.NextSibling;
				inputElement.RemoveChild(xmlNode);
				xmlNode = xmlNode2;
			}
		}

		internal static long Pump(Stream input, Stream output)
		{
			if (input is MemoryStream memoryStream && memoryStream.Position == 0L)
			{
				memoryStream.WriteTo(output);
				return memoryStream.Length;
			}
			byte[] buffer = new byte[4096];
			long num = 0L;
			int num2;
			while ((num2 = input.Read(buffer, 0, 4096)) > 0)
			{
				output.Write(buffer, 0, num2);
				num += num2;
			}
			return num;
		}

		internal static Hashtable TokenizePrefixListString(string s)
		{
			Hashtable hashtable = new Hashtable();
			if (s != null)
			{
				string[] array = s.Split(null);
				string[] array2 = array;
				foreach (string text in array2)
				{
					if (text.Equals("#default"))
					{
						hashtable.Add(string.Empty, true);
					}
					else if (text.Length > 0)
					{
						hashtable.Add(text, true);
					}
				}
			}
			return hashtable;
		}

		internal static string EscapeWhitespaceData(string data)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(data);
			SBReplaceCharWithString(stringBuilder, '\r', "&#xD;");
			return stringBuilder.ToString();
		}

		internal static string EscapeTextData(string data)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(data);
			stringBuilder.Replace("&", "&amp;");
			stringBuilder.Replace("<", "&lt;");
			stringBuilder.Replace(">", "&gt;");
			SBReplaceCharWithString(stringBuilder, '\r', "&#xD;");
			return stringBuilder.ToString();
		}

		internal static string EscapeCData(string data)
		{
			return EscapeTextData(data);
		}

		internal static string EscapeAttributeValue(string value)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(value);
			stringBuilder.Replace("&", "&amp;");
			stringBuilder.Replace("<", "&lt;");
			stringBuilder.Replace("\"", "&quot;");
			SBReplaceCharWithString(stringBuilder, '\t', "&#x9;");
			SBReplaceCharWithString(stringBuilder, '\n', "&#xA;");
			SBReplaceCharWithString(stringBuilder, '\r', "&#xD;");
			return stringBuilder.ToString();
		}

		internal static XmlDocument GetOwnerDocument(XmlNodeList nodeList)
		{
			foreach (XmlNode node in nodeList)
			{
				if (node.OwnerDocument != null)
				{
					return node.OwnerDocument;
				}
			}
			return null;
		}

		internal static void AddNamespaces(XmlElement elem, CanonicalXmlNodeList namespaces)
		{
			if (namespaces == null)
			{
				return;
			}
			foreach (XmlNode @namespace in namespaces)
			{
				string text = ((@namespace.Prefix.Length > 0) ? (@namespace.Prefix + ":" + @namespace.LocalName) : @namespace.LocalName);
				if (!elem.HasAttribute(text) && (!text.Equals("xmlns") || elem.Prefix.Length != 0))
				{
					XmlAttribute xmlAttribute = elem.OwnerDocument.CreateAttribute(text);
					xmlAttribute.Value = @namespace.Value;
					elem.SetAttributeNode(xmlAttribute);
				}
			}
		}

		internal static void AddNamespaces(XmlElement elem, Hashtable namespaces)
		{
			if (namespaces == null)
			{
				return;
			}
			foreach (string key in namespaces.Keys)
			{
				if (!elem.HasAttribute(key))
				{
					XmlAttribute xmlAttribute = elem.OwnerDocument.CreateAttribute(key);
					xmlAttribute.Value = namespaces[key] as string;
					elem.SetAttributeNode(xmlAttribute);
				}
			}
		}

		internal static CanonicalXmlNodeList GetPropagatedAttributes(XmlElement elem)
		{
			if (elem == null)
			{
				return null;
			}
			CanonicalXmlNodeList canonicalXmlNodeList = new CanonicalXmlNodeList();
			XmlNode xmlNode = elem;
			if (xmlNode == null)
			{
				return null;
			}
			bool flag = true;
			while (xmlNode != null)
			{
				if (!(xmlNode is XmlElement xmlElement))
				{
					xmlNode = xmlNode.ParentNode;
					continue;
				}
				if (!IsCommittedNamespace(xmlElement, xmlElement.Prefix, xmlElement.NamespaceURI) && !IsRedundantNamespace(xmlElement, xmlElement.Prefix, xmlElement.NamespaceURI))
				{
					string name = ((xmlElement.Prefix.Length > 0) ? ("xmlns:" + xmlElement.Prefix) : "xmlns");
					XmlAttribute xmlAttribute = elem.OwnerDocument.CreateAttribute(name);
					xmlAttribute.Value = xmlElement.NamespaceURI;
					canonicalXmlNodeList.Add(xmlAttribute);
				}
				if (xmlElement.HasAttributes)
				{
					XmlAttributeCollection attributes = xmlElement.Attributes;
					foreach (XmlAttribute item in attributes)
					{
						if (flag && item.LocalName == "xmlns")
						{
							XmlAttribute xmlAttribute3 = elem.OwnerDocument.CreateAttribute("xmlns");
							xmlAttribute3.Value = item.Value;
							canonicalXmlNodeList.Add(xmlAttribute3);
							flag = false;
						}
						else if (item.Prefix == "xmlns" || item.Prefix == "xml")
						{
							canonicalXmlNodeList.Add(item);
						}
						else if (item.NamespaceURI.Length > 0 && !IsCommittedNamespace(xmlElement, item.Prefix, item.NamespaceURI) && !IsRedundantNamespace(xmlElement, item.Prefix, item.NamespaceURI))
						{
							string name2 = ((item.Prefix.Length > 0) ? ("xmlns:" + item.Prefix) : "xmlns");
							XmlAttribute xmlAttribute4 = elem.OwnerDocument.CreateAttribute(name2);
							xmlAttribute4.Value = item.NamespaceURI;
							canonicalXmlNodeList.Add(xmlAttribute4);
						}
					}
				}
				xmlNode = xmlNode.ParentNode;
			}
			return canonicalXmlNodeList;
		}

		internal static byte[] ConvertIntToByteArray(int dwInput)
		{
			byte[] array = new byte[8];
			int num = 0;
			if (dwInput == 0)
			{
				return new byte[1];
			}
			int num2 = dwInput;
			while (num2 > 0)
			{
				int num3 = num2 % 256;
				array[num] = (byte)num3;
				num2 = (num2 - num3) / 256;
				num++;
			}
			byte[] array2 = new byte[num];
			for (int i = 0; i < num; i++)
			{
				array2[i] = array[num - i - 1];
			}
			return array2;
		}

		internal static int GetHexArraySize(byte[] hex)
		{
			int num = hex.Length;
			while (num-- > 0 && hex[num] == 0)
			{
			}
			return num + 1;
		}

		[SecuritySafeCritical]
		internal static X509Certificate2Collection BuildBagOfCerts(KeyInfoX509Data keyInfoX509Data, CertUsageType certUsageType)
		{
			X509Certificate2Collection x509Certificate2Collection = new X509Certificate2Collection();
			ArrayList arrayList = ((certUsageType == CertUsageType.Decryption) ? new ArrayList() : null);
			if (keyInfoX509Data.Certificates != null)
			{
				foreach (X509Certificate2 certificate in keyInfoX509Data.Certificates)
				{
					switch (certUsageType)
					{
					case CertUsageType.Verification:
						x509Certificate2Collection.Add(certificate);
						break;
					case CertUsageType.Decryption:
						arrayList.Add(new X509IssuerSerial(certificate.IssuerName.Name, certificate.SerialNumber));
						break;
					}
				}
			}
			if (keyInfoX509Data.SubjectNames == null && keyInfoX509Data.IssuerSerials == null && keyInfoX509Data.SubjectKeyIds == null && arrayList == null)
			{
				return x509Certificate2Collection;
			}
			StorePermission storePermission = new StorePermission(StorePermissionFlags.OpenStore);
			storePermission.Assert();
			X509Store[] array = new X509Store[2];
			string storeName = ((certUsageType == CertUsageType.Verification) ? "AddressBook" : "My");
			array[0] = new X509Store(storeName, StoreLocation.CurrentUser);
			array[1] = new X509Store(storeName, StoreLocation.LocalMachine);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == null)
				{
					continue;
				}
				X509Certificate2Collection x509Certificate2Collection2 = null;
				try
				{
					array[i].Open(OpenFlags.OpenExistingOnly);
					x509Certificate2Collection2 = array[i].Certificates;
					array[i].Close();
					if (keyInfoX509Data.SubjectNames != null)
					{
						foreach (string subjectName in keyInfoX509Data.SubjectNames)
						{
							x509Certificate2Collection2 = x509Certificate2Collection2.Find(X509FindType.FindBySubjectDistinguishedName, subjectName, validOnly: false);
						}
					}
					if (keyInfoX509Data.IssuerSerials != null)
					{
						foreach (X509IssuerSerial issuerSerial in keyInfoX509Data.IssuerSerials)
						{
							x509Certificate2Collection2 = x509Certificate2Collection2.Find(X509FindType.FindByIssuerDistinguishedName, issuerSerial.IssuerName, validOnly: false);
							x509Certificate2Collection2 = x509Certificate2Collection2.Find(X509FindType.FindBySerialNumber, issuerSerial.SerialNumber, validOnly: false);
						}
					}
					if (keyInfoX509Data.SubjectKeyIds != null)
					{
						foreach (byte[] subjectKeyId in keyInfoX509Data.SubjectKeyIds)
						{
							string findValue2 = System.Security.Cryptography.X509Certificates.X509Utils.EncodeHexString(subjectKeyId);
							x509Certificate2Collection2 = x509Certificate2Collection2.Find(X509FindType.FindBySubjectKeyIdentifier, findValue2, validOnly: false);
						}
					}
					if (arrayList != null)
					{
						foreach (X509IssuerSerial item in arrayList)
						{
							x509Certificate2Collection2 = x509Certificate2Collection2.Find(X509FindType.FindByIssuerDistinguishedName, item.IssuerName, validOnly: false);
							x509Certificate2Collection2 = x509Certificate2Collection2.Find(X509FindType.FindBySerialNumber, item.SerialNumber, validOnly: false);
						}
					}
				}
				catch (CryptographicException)
				{
				}
				if (x509Certificate2Collection2 != null)
				{
					x509Certificate2Collection.AddRange(x509Certificate2Collection2);
				}
			}
			return x509Certificate2Collection;
		}
	}
}
namespace System.Security.Cryptography.X509Certificates
{
	internal class X509Utils
	{
		private static readonly char[] hexValues = new char[16]
		{
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
			'A', 'B', 'C', 'D', 'E', 'F'
		};

		private X509Utils()
		{
		}

		internal static uint MapRevocationFlags(X509RevocationMode revocationMode, X509RevocationFlag revocationFlag)
		{
			uint num = 0u;
			switch (revocationMode)
			{
			case X509RevocationMode.NoCheck:
				return num;
			case X509RevocationMode.Offline:
				num |= 0x80000000u;
				break;
			}
			return revocationFlag switch
			{
				X509RevocationFlag.EndCertificateOnly => num | 0x10000000u, 
				X509RevocationFlag.EntireChain => num | 0x20000000u, 
				_ => num | 0x40000000u, 
			};
		}

		internal static string EncodeHexString(byte[] sArray)
		{
			return EncodeHexString(sArray, 0u, (uint)sArray.Length);
		}

		internal static string EncodeHexString(byte[] sArray, uint start, uint end)
		{
			string result = null;
			if (sArray != null)
			{
				char[] array = new char[(end - start) * 2];
				uint num = start;
				uint num2 = 0u;
				for (; num < end; num++)
				{
					uint num3 = (uint)((sArray[num] & 0xF0) >> 4);
					array[num2++] = hexValues[num3];
					num3 = sArray[num] & 0xFu;
					array[num2++] = hexValues[num3];
				}
				result = new string(array);
			}
			return result;
		}

		internal static string EncodeHexStringFromInt(byte[] sArray)
		{
			return EncodeHexStringFromInt(sArray, 0u, (uint)sArray.Length);
		}

		internal static string EncodeHexStringFromInt(byte[] sArray, uint start, uint end)
		{
			string result = null;
			if (sArray != null)
			{
				char[] array = new char[(end - start) * 2];
				uint num = end;
				uint num2 = 0u;
				while (num-- > start)
				{
					uint num3 = (uint)(sArray[num] & 0xF0) >> 4;
					array[num2++] = hexValues[num3];
					num3 = sArray[num] & 0xFu;
					array[num2++] = hexValues[num3];
				}
				result = new string(array);
			}
			return result;
		}

		internal static byte HexToByte(char val)
		{
			if (val <= '9' && val >= '0')
			{
				return (byte)(val - 48);
			}
			if (val >= 'a' && val <= 'f')
			{
				return (byte)(val - 97 + 10);
			}
			if (val >= 'A' && val <= 'F')
			{
				return (byte)(val - 65 + 10);
			}
			return byte.MaxValue;
		}

		internal static byte[] DecodeHexString(string s)
		{
			string text = System.Security.Cryptography.Xml.Utils.DiscardWhiteSpaces(s);
			uint num = (uint)text.Length / 2u;
			byte[] array = new byte[num];
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				array[i] = (byte)((HexToByte(text[num2]) << 4) | HexToByte(text[num2 + 1]));
				num2 += 2;
			}
			return array;
		}

		[SecurityCritical]
		internal unsafe static bool MemEqual(byte* pbBuf1, uint cbBuf1, byte* pbBuf2, uint cbBuf2)
		{
			if (cbBuf1 != cbBuf2)
			{
				return false;
			}
			while (cbBuf1-- != 0)
			{
				if (*(pbBuf1++) != *(pbBuf2++))
				{
					return false;
				}
			}
			return true;
		}

		[SecurityCritical]
		internal static SafeLocalAllocHandle StringToAnsiPtr(string s)
		{
			byte[] array = new byte[s.Length + 1];
			Encoding.ASCII.GetBytes(s, 0, s.Length, array, 0);
			SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(0u, new IntPtr(array.Length));
			Marshal.Copy(array, 0, safeLocalAllocHandle.DangerousGetHandle(), array.Length);
			return safeLocalAllocHandle;
		}

		[SecurityCritical]
		internal static System.Security.Cryptography.SafeCertContextHandle GetCertContext(X509Certificate2 certificate)
		{
			System.Security.Cryptography.SafeCertContextHandle result = CAPI.CertDuplicateCertificateContext(certificate.Handle);
			GC.KeepAlive(certificate);
			return result;
		}

		[SecurityCritical]
		internal static bool GetPrivateKeyInfo(System.Security.Cryptography.SafeCertContextHandle safeCertContext, ref CspParameters parameters)
		{
			SafeLocalAllocHandle invalidHandle = SafeLocalAllocHandle.InvalidHandle;
			uint pcbData = 0u;
			if (!CAPI.CAPISafe.CertGetCertificateContextProperty(safeCertContext, 2u, invalidHandle, ref pcbData))
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error == -2146885628)
				{
					return false;
				}
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			invalidHandle = CAPI.LocalAlloc(0u, new IntPtr(pcbData));
			if (!CAPI.CAPISafe.CertGetCertificateContextProperty(safeCertContext, 2u, invalidHandle, ref pcbData))
			{
				int lastWin32Error2 = Marshal.GetLastWin32Error();
				if (lastWin32Error2 == -2146885628)
				{
					return false;
				}
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			CAPI.CRYPT_KEY_PROV_INFO cRYPT_KEY_PROV_INFO = (CAPI.CRYPT_KEY_PROV_INFO)Marshal.PtrToStructure(invalidHandle.DangerousGetHandle(), typeof(CAPI.CRYPT_KEY_PROV_INFO));
			parameters.ProviderName = cRYPT_KEY_PROV_INFO.pwszProvName;
			parameters.KeyContainerName = cRYPT_KEY_PROV_INFO.pwszContainerName;
			parameters.ProviderType = (int)cRYPT_KEY_PROV_INFO.dwProvType;
			parameters.KeyNumber = (int)cRYPT_KEY_PROV_INFO.dwKeySpec;
			parameters.Flags = (((cRYPT_KEY_PROV_INFO.dwFlags & 0x20) == 32) ? CspProviderFlags.UseMachineKeyStore : CspProviderFlags.NoFlags);
			invalidHandle.Dispose();
			return true;
		}

		[SecurityCritical]
		internal static System.Security.Cryptography.SafeCertStoreHandle ExportToMemoryStore(X509Certificate2Collection collection, X509Certificate2Collection collection2 = null)
		{
			StorePermission storePermission = new StorePermission(StorePermissionFlags.AllFlags);
			storePermission.Assert();
			System.Security.Cryptography.SafeCertStoreHandle safeCertStoreHandle = CAPI.CertOpenStore(new IntPtr(2L), 65537u, IntPtr.Zero, 8704u, null);
			if (safeCertStoreHandle == null || safeCertStoreHandle.IsInvalid)
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			AddToStore(safeCertStoreHandle, collection);
			if (collection2 != null)
			{
				AddToStore(safeCertStoreHandle, collection2);
			}
			return safeCertStoreHandle;
		}

		[SecurityCritical]
		private static void AddToStore(System.Security.Cryptography.SafeCertStoreHandle safeCertStoreHandle, X509Certificate2Collection collection)
		{
			X509Certificate2Enumerator enumerator = collection.GetEnumerator();
			while (enumerator.MoveNext())
			{
				X509Certificate2 current = enumerator.Current;
				using System.Security.Cryptography.SafeCertContextHandle pCertContext = GetCertContext(current);
				if (!CAPI.CertAddCertificateLinkToStore(safeCertStoreHandle, pCertContext, 4u, System.Security.Cryptography.SafeCertContextHandle.InvalidHandle))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
			}
		}

		[SecuritySafeCritical]
		internal static uint OidToAlgId(string value)
		{
			SafeLocalAllocHandle pvKey = StringToAnsiPtr(value);
			return CAPI.CryptFindOIDInfo(1u, pvKey, 0u).Algid;
		}

		internal static bool IsSelfSigned(X509Chain chain)
		{
			X509ChainElementCollection chainElements = chain.ChainElements;
			if (chainElements.Count != 1)
			{
				return false;
			}
			X509Certificate2 certificate = chainElements[0].Certificate;
			if (string.Compare(certificate.SubjectName.Name, certificate.IssuerName.Name, StringComparison.OrdinalIgnoreCase) == 0)
			{
				return true;
			}
			return false;
		}

		[SecurityCritical]
		internal static SafeLocalAllocHandle CopyOidsToUnmanagedMemory(OidCollection oids)
		{
			SafeLocalAllocHandle invalidHandle = SafeLocalAllocHandle.InvalidHandle;
			if (oids == null || oids.Count == 0)
			{
				return invalidHandle;
			}
			int num = oids.Count * Marshal.SizeOf(typeof(IntPtr));
			int num2 = 0;
			OidEnumerator enumerator = oids.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Oid current = enumerator.Current;
				num2 += current.Value.Length + 1;
			}
			invalidHandle = CAPI.LocalAlloc(64u, new IntPtr((uint)(num + num2)));
			IntPtr intPtr = new IntPtr((long)invalidHandle.DangerousGetHandle() + num);
			for (int i = 0; i < oids.Count; i++)
			{
				Marshal.WriteIntPtr(new IntPtr((long)invalidHandle.DangerousGetHandle() + i * Marshal.SizeOf(typeof(IntPtr))), intPtr);
				byte[] bytes = Encoding.ASCII.GetBytes(oids[i].Value);
				Marshal.Copy(bytes, 0, intPtr, bytes.Length);
				intPtr = new IntPtr((long)intPtr + oids[i].Value.Length + 1);
			}
			return invalidHandle;
		}

		[SecurityCritical]
		internal static X509Certificate2Collection GetCertificates(System.Security.Cryptography.SafeCertStoreHandle safeCertStoreHandle)
		{
			X509Certificate2Collection x509Certificate2Collection = new X509Certificate2Collection();
			IntPtr intPtr = CAPI.CertEnumCertificatesInStore(safeCertStoreHandle, IntPtr.Zero);
			while (intPtr != IntPtr.Zero)
			{
				X509Certificate2 certificate = new X509Certificate2(intPtr);
				x509Certificate2Collection.Add(certificate);
				intPtr = CAPI.CertEnumCertificatesInStore(safeCertStoreHandle, intPtr);
			}
			return x509Certificate2Collection;
		}

		[SecurityCritical]
		internal unsafe static int BuildChain(IntPtr hChainEngine, System.Security.Cryptography.SafeCertContextHandle pCertContext, X509Certificate2Collection extraStore, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, DateTime verificationTime, TimeSpan timeout, ref SafeCertChainHandle ppChainContext)
		{
			if (pCertContext == null || pCertContext.IsInvalid)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_InvalidContextHandle"), "pCertContext");
			}
			System.Security.Cryptography.SafeCertStoreHandle hAdditionalStore = System.Security.Cryptography.SafeCertStoreHandle.InvalidHandle;
			if (extraStore != null && extraStore.Count > 0)
			{
				hAdditionalStore = ExportToMemoryStore(extraStore);
			}
			CAPI.CERT_CHAIN_PARA pChainPara = default(CAPI.CERT_CHAIN_PARA);
			pChainPara.cbSize = (uint)Marshal.SizeOf((object)pChainPara);
			SafeLocalAllocHandle safeLocalAllocHandle = SafeLocalAllocHandle.InvalidHandle;
			if (applicationPolicy != null && applicationPolicy.Count > 0)
			{
				pChainPara.RequestedUsage.dwType = 0u;
				pChainPara.RequestedUsage.Usage.cUsageIdentifier = (uint)applicationPolicy.Count;
				safeLocalAllocHandle = CopyOidsToUnmanagedMemory(applicationPolicy);
				pChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = safeLocalAllocHandle.DangerousGetHandle();
			}
			SafeLocalAllocHandle safeLocalAllocHandle2 = SafeLocalAllocHandle.InvalidHandle;
			if (certificatePolicy != null && certificatePolicy.Count > 0)
			{
				pChainPara.RequestedIssuancePolicy.dwType = 0u;
				pChainPara.RequestedIssuancePolicy.Usage.cUsageIdentifier = (uint)certificatePolicy.Count;
				safeLocalAllocHandle2 = CopyOidsToUnmanagedMemory(certificatePolicy);
				pChainPara.RequestedIssuancePolicy.Usage.rgpszUsageIdentifier = safeLocalAllocHandle2.DangerousGetHandle();
			}
			pChainPara.dwUrlRetrievalTimeout = (uint)timeout.Milliseconds;
			System.Runtime.InteropServices.ComTypes.FILETIME pTime = default(System.Runtime.InteropServices.ComTypes.FILETIME);
			*(long*)(&pTime) = verificationTime.ToFileTime();
			uint dwFlags = MapRevocationFlags(revocationMode, revocationFlag);
			if (!CAPI.CAPISafe.CertGetCertificateChain(hChainEngine, pCertContext, ref pTime, hAdditionalStore, ref pChainPara, dwFlags, IntPtr.Zero, ref ppChainContext))
			{
				return Marshal.GetHRForLastWin32Error();
			}
			safeLocalAllocHandle.Dispose();
			safeLocalAllocHandle2.Dispose();
			return 0;
		}

		[SecurityCritical]
		internal unsafe static int VerifyCertificate(System.Security.Cryptography.SafeCertContextHandle pCertContext, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, DateTime verificationTime, TimeSpan timeout, X509Certificate2Collection extraStore, IntPtr pszPolicy, IntPtr pdwErrorStatus)
		{
			if (pCertContext == null || pCertContext.IsInvalid)
			{
				throw new ArgumentException("pCertContext");
			}
			CAPI.CERT_CHAIN_POLICY_PARA pPolicyPara = new CAPI.CERT_CHAIN_POLICY_PARA(Marshal.SizeOf(typeof(CAPI.CERT_CHAIN_POLICY_PARA)));
			CAPI.CERT_CHAIN_POLICY_STATUS pPolicyStatus = new CAPI.CERT_CHAIN_POLICY_STATUS(Marshal.SizeOf(typeof(CAPI.CERT_CHAIN_POLICY_STATUS)));
			SafeCertChainHandle ppChainContext = SafeCertChainHandle.InvalidHandle;
			int num = BuildChain(new IntPtr(0L), pCertContext, extraStore, applicationPolicy, certificatePolicy, revocationMode, revocationFlag, verificationTime, timeout, ref ppChainContext);
			if (num != 0)
			{
				return num;
			}
			if (CAPI.CAPISafe.CertVerifyCertificateChainPolicy(pszPolicy, ppChainContext, ref pPolicyPara, ref pPolicyStatus))
			{
				if (pdwErrorStatus != IntPtr.Zero)
				{
					*(uint*)(void*)pdwErrorStatus = pPolicyStatus.dwError;
				}
				if (pPolicyStatus.dwError != 0)
				{
					return 1;
				}
				return 0;
			}
			return Marshal.GetHRForLastWin32Error();
		}
	}
	/// <summary>Specifies the type of selection requested using the <see cref="Overload:System.Security.Cryptography.X509Certificates.X509Certificate2UI.SelectFromCollection" /> method.</summary>
	public enum X509SelectionFlag
	{
		/// <summary>A single selection. The UI allows the user to select one X.509 certificate.</summary>
		SingleSelection,
		/// <summary>A multiple selection. The user can use the SHIFT or CRTL keys to select more than one X.509 certificate.</summary>
		MultiSelection
	}
	/// <summary>Displays user interface dialogs that allow you to select and view X.509 certificates. This class cannot be inherited.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public static class X509Certificate2UI
	{
		/// <summary>Displays a dialog box that contains the properties of an X.509 certificate and its associated certificate chain.</summary>
		/// <param name="certificate">The X.509 certificate to display.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="certificate" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="certificate" /> parameter is invalid.</exception>
		[SecuritySafeCritical]
		public static void DisplayCertificate(X509Certificate2 certificate)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			DisplayX509Certificate(X509Utils.GetCertContext(certificate), IntPtr.Zero);
		}

		/// <summary>Displays a dialog box that contains the properties of an X.509 certificate and its associated certificate chain using a handle to a parent window.</summary>
		/// <param name="certificate">The X.509 certificate to display.</param>
		/// <param name="hwndParent">A handle to the parent window to use for the display dialog.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="certificate" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="certificate" /> parameter is invalid.</exception>
		[SecurityCritical]
		public static void DisplayCertificate(X509Certificate2 certificate, IntPtr hwndParent)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			DisplayX509Certificate(X509Utils.GetCertContext(certificate), hwndParent);
		}

		/// <summary>Displays a dialog box for selecting an X.509 certificate from a certificate collection.</summary>
		/// <param name="certificates">A collection of X.509 certificates to select from.</param>
		/// <param name="title">The title of the dialog box.</param>
		/// <param name="message">A descriptive message to guide the user.  The message is displayed in the dialog box.</param>
		/// <param name="selectionFlag">One of the <see cref="T:System.Security.Cryptography.X509Certificates.X509SelectionFlag" /> values that specifies whether single or multiple selections are allowed.</param>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> object that contains the selected certificate or certificates.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="selectionFlag" /> parameter is not a valid flag.</exception>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="certificates" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="certificates" /> parameter is invalid.</exception>
		public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag)
		{
			return SelectFromCollectionHelper(certificates, title, message, selectionFlag, IntPtr.Zero);
		}

		/// <summary>Displays a dialog box for selecting an X.509 certificate from a certificate collection using a handle to a parent window.</summary>
		/// <param name="certificates">A collection of X.509 certificates to select from.</param>
		/// <param name="title">The title of the dialog box.</param>
		/// <param name="message">A descriptive message to guide the user.  The message is displayed in the dialog box.</param>
		/// <param name="selectionFlag">One of the <see cref="T:System.Security.Cryptography.X509Certificates.X509SelectionFlag" /> values that specifies whether single or multiple selections are allowed.</param>
		/// <param name="hwndParent">A handle to the parent window to use for the display dialog box.</param>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> object that contains the selected certificate or certificates.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="selectionFlag" /> parameter is not a valid flag.</exception>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="certificates" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="certificates" /> parameter is invalid.</exception>
		[SecurityCritical]
		public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag, IntPtr hwndParent)
		{
			return SelectFromCollectionHelper(certificates, title, message, selectionFlag, hwndParent);
		}

		[SecurityCritical]
		private static void DisplayX509Certificate(System.Security.Cryptography.SafeCertContextHandle safeCertContext, IntPtr hwndParent)
		{
			if (safeCertContext.IsInvalid)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_InvalidHandle"), "safeCertContext");
			}
			int num = 0;
			CAPI.CRYPTUI_VIEWCERTIFICATE_STRUCTW cRYPTUI_VIEWCERTIFICATE_STRUCTW = new CAPI.CRYPTUI_VIEWCERTIFICATE_STRUCTW();
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.dwSize = (uint)Marshal.SizeOf((object)cRYPTUI_VIEWCERTIFICATE_STRUCTW);
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.hwndParent = hwndParent;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.dwFlags = 0u;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.szTitle = null;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.pCertContext = safeCertContext.DangerousGetHandle();
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.rgszPurposes = IntPtr.Zero;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.cPurposes = 0u;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.pCryptProviderData = IntPtr.Zero;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.fpCryptProviderDataTrustedUsage = false;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.idxSigner = 0u;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.idxCert = 0u;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.fCounterSigner = false;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.idxCounterSigner = 0u;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.cStores = 0u;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.rghStores = IntPtr.Zero;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.cPropSheetPages = 0u;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.rgPropSheetPages = IntPtr.Zero;
			cRYPTUI_VIEWCERTIFICATE_STRUCTW.nStartPage = 0u;
			if (!CAPI.CryptUIDlgViewCertificateW(cRYPTUI_VIEWCERTIFICATE_STRUCTW, IntPtr.Zero))
			{
				num = Marshal.GetLastWin32Error();
			}
			if (num != 0 && num != 1223)
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
		}

		[SecuritySafeCritical]
		private static X509Certificate2Collection SelectFromCollectionHelper(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag, IntPtr hwndParent)
		{
			if (certificates == null)
			{
				throw new ArgumentNullException("certificates");
			}
			if (selectionFlag < X509SelectionFlag.SingleSelection || selectionFlag > X509SelectionFlag.MultiSelection)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Arg_EnumIllegalVal"), new object[1] { "selectionFlag" }));
			}
			StorePermission storePermission = new StorePermission(StorePermissionFlags.AllFlags);
			storePermission.Assert();
			using System.Security.Cryptography.SafeCertStoreHandle safeSourceStoreHandle = X509Utils.ExportToMemoryStore(certificates);
			using System.Security.Cryptography.SafeCertStoreHandle safeCertStoreHandle = SelectFromStore(safeSourceStoreHandle, title, message, selectionFlag, hwndParent);
			return X509Utils.GetCertificates(safeCertStoreHandle);
		}

		[SecurityCritical]
		private unsafe static System.Security.Cryptography.SafeCertStoreHandle SelectFromStore(System.Security.Cryptography.SafeCertStoreHandle safeSourceStoreHandle, string title, string message, X509SelectionFlag selectionFlags, IntPtr hwndParent)
		{
			int num = 0;
			System.Security.Cryptography.SafeCertStoreHandle safeCertStoreHandle = CAPI.CertOpenStore((IntPtr)2L, 65537u, IntPtr.Zero, 0u, null);
			if (safeCertStoreHandle == null || safeCertStoreHandle.IsInvalid)
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			CAPI.CRYPTUI_SELECTCERTIFICATE_STRUCTW cRYPTUI_SELECTCERTIFICATE_STRUCTW = new CAPI.CRYPTUI_SELECTCERTIFICATE_STRUCTW();
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.dwSize = (uint)(int)Marshal.OffsetOf(typeof(CAPI.CRYPTUI_SELECTCERTIFICATE_STRUCTW), "hSelectedCertStore");
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.hwndParent = hwndParent;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.dwFlags = (uint)selectionFlags;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.szTitle = title;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.dwDontUseColumn = 0u;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.szDisplayString = message;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.pFilterCallback = IntPtr.Zero;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.pDisplayCallback = IntPtr.Zero;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.pvCallbackData = IntPtr.Zero;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.cDisplayStores = 1u;
			IntPtr intPtr = safeSourceStoreHandle.DangerousGetHandle();
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.rghDisplayStores = new IntPtr(&intPtr);
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.cStores = 0u;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.rghStores = IntPtr.Zero;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.cPropSheetPages = 0u;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.rgPropSheetPages = IntPtr.Zero;
			cRYPTUI_SELECTCERTIFICATE_STRUCTW.hSelectedCertStore = safeCertStoreHandle.DangerousGetHandle();
			System.Security.Cryptography.SafeCertContextHandle safeCertContextHandle = CAPI.CryptUIDlgSelectCertificateW(cRYPTUI_SELECTCERTIFICATE_STRUCTW);
			if (safeCertContextHandle != null && !safeCertContextHandle.IsInvalid)
			{
				System.Security.Cryptography.SafeCertContextHandle invalidHandle = System.Security.Cryptography.SafeCertContextHandle.InvalidHandle;
				if (!CAPI.CertAddCertificateLinkToStore(safeCertStoreHandle, safeCertContextHandle, 4u, invalidHandle))
				{
					num = Marshal.GetLastWin32Error();
				}
			}
			if (num != 0)
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			return safeCertStoreHandle;
		}
	}
	internal static class X509CertificateExtensions
	{
		private static Lazy<Func<X509Certificate2, AsymmetricAlgorithm>> s_getEcdsaPublicKey = CreateLazyInvoker<AsymmetricAlgorithm>("ECDsa", isPublic: true);

		private static Lazy<Func<X509Certificate2, AsymmetricAlgorithm>> s_getEcdsaPrivateKey = CreateLazyInvoker<AsymmetricAlgorithm>("ECDsa", isPublic: false);

		public static RSA GetRSAPublicKey(this X509Certificate2 certificate)
		{
			return CngLightup.GetRSAPublicKey(certificate);
		}

		public static RSA GetRSAPrivateKey(this X509Certificate2 certificate)
		{
			return CngLightup.GetRSAPrivateKey(certificate);
		}

		public static DSA GetDSAPublicKey(this X509Certificate2 certificate)
		{
			return CngLightup.GetDSAPublicKey(certificate);
		}

		public static DSA GetDSAPrivateKey(this X509Certificate2 certificate)
		{
			return CngLightup.GetDSAPrivateKey(certificate);
		}

		public static AsymmetricAlgorithm GetECDsaPublicKey(this X509Certificate2 certificate)
		{
			return s_getEcdsaPublicKey.Value(certificate);
		}

		public static AsymmetricAlgorithm GetECDsaPrivateKey(this X509Certificate2 certificate)
		{
			return s_getEcdsaPrivateKey.Value(certificate);
		}

		public static AsymmetricAlgorithm GetAnyPublicKey(this X509Certificate2 c)
		{
			AsymmetricAlgorithm rSAPublicKey = c.GetRSAPublicKey();
			if (rSAPublicKey != null)
			{
				return rSAPublicKey;
			}
			rSAPublicKey = c.GetDSAPublicKey();
			if (rSAPublicKey != null)
			{
				return rSAPublicKey;
			}
			rSAPublicKey = c.GetECDsaPublicKey();
			if (rSAPublicKey != null)
			{
				return rSAPublicKey;
			}
			throw new NotSupportedException(SecurityResources.GetResourceString("NotSupported_KeyAlgorithm"));
		}

		private static Lazy<Func<X509Certificate2, T>> CreateLazyInvoker<T>(string algorithmName, bool isPublic) where T : AsymmetricAlgorithm
		{
			Func<Func<X509Certificate2, T>> valueFactory = delegate
			{
				string typeName = "System.Security.Cryptography.X509Certificates." + algorithmName + "CertificateExtensions, System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
				Type type = Type.GetType(typeName, throwOnError: false, ignoreCase: false);
				if (type == null)
				{
					return (X509Certificate2 x509) => null;
				}
				string name = "Get" + algorithmName + (isPublic ? "Public" : "Private") + "Key";
				MethodInfo method = type.GetMethod(name, BindingFlags.Static | BindingFlags.Public, null, new Type[1] { typeof(X509Certificate2) }, null);
				return (Func<X509Certificate2, T>)method.CreateDelegate(typeof(Func<X509Certificate2, T>));
			};
			return new Lazy<Func<X509Certificate2, T>>(valueFactory, LazyThreadSafetyMode.PublicationOnly);
		}
	}
}
namespace System.Security.Cryptography.Pkcs
{
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.EnvelopedCms" /> class represents a CMS/PKCS #7 structure for enveloped data.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EnvelopedCms
	{
		[SecurityCritical]
		private struct CMSG_DECRYPT_PARAM
		{
			internal SafeCertContextHandle safeCertContextHandle;

			internal SafeCryptProvHandle safeCryptProvHandle;

			internal uint keySpec;
		}

		[SecurityCritical]
		private struct CMSG_ENCRYPT_PARAM
		{
			internal bool useCms;

			internal SafeCryptProvHandle safeCryptProvHandle;

			internal SafeLocalAllocHandle pvEncryptionAuxInfo;

			internal SafeLocalAllocHandle rgpRecipients;

			internal SafeLocalAllocHandle rgCertEncoded;

			internal SafeLocalAllocHandle rgUnprotectedAttr;

			internal SafeLocalAllocHandle[] rgSubjectKeyIdentifier;

			internal SafeLocalAllocHandle[] rgszObjId;

			internal SafeLocalAllocHandle[] rgszKeyWrapObjId;

			internal SafeLocalAllocHandle[] rgKeyWrapAuxInfo;

			internal SafeLocalAllocHandle[] rgEphemeralIdentifier;

			internal SafeLocalAllocHandle[] rgszEphemeralObjId;

			internal SafeLocalAllocHandle[] rgUserKeyingMaterial;

			internal SafeLocalAllocHandle[] prgpEncryptedKey;

			internal SafeLocalAllocHandle[] rgpEncryptedKey;
		}

		[SecurityCritical]
		private SafeCryptMsgHandle m_safeCryptMsgHandle;

		private int m_version;

		private SubjectIdentifierType m_recipientIdentifierType;

		private ContentInfo m_contentInfo;

		private AlgorithmIdentifier m_encryptionAlgorithm;

		private X509Certificate2Collection m_certificates;

		private CryptographicAttributeObjectCollection m_unprotectedAttributes;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.EnvelopedCms.Version" /> property retrieves the version of the enveloped CMS/PKCS #7 message.</summary>
		/// <returns>An int value that represents the version of the enveloped CMS/PKCS #7 message.</returns>
		public int Version => m_version;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.EnvelopedCms.ContentInfo" /> property retrieves the inner content information for the enveloped CMS/PKCS #7 message.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> object that represents the inner content information from the enveloped CMS/PKCS #7 message.</returns>
		public ContentInfo ContentInfo => m_contentInfo;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.EnvelopedCms.ContentEncryptionAlgorithm" /> property retrieves the identifier of the algorithm used to encrypt the content.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Pkcs.AlgorithmIdentifier" /> object that represents the algorithm identifier.</returns>
		public AlgorithmIdentifier ContentEncryptionAlgorithm => m_encryptionAlgorithm;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.EnvelopedCms.Certificates" /> property retrieves the set of certificates associated with the enveloped CMS/PKCS #7 message.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> collection that represents the X.509 certificates used with the enveloped CMS/PKCS #7 message. If no certificates exist, the property value is an empty collection.</returns>
		public X509Certificate2Collection Certificates => m_certificates;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.EnvelopedCms.UnprotectedAttributes" /> property retrieves the unprotected (unencrypted) attributes associated with the enveloped CMS/PKCS #7 message. Unprotected attributes are not encrypted, and so do not have data confidentiality within an <see cref="T:System.Security.Cryptography.Pkcs.EnvelopedCms" /> object.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection that represents the unprotected attributes. If no unprotected attributes exist, the property value is an empty collection.</returns>
		public CryptographicAttributeObjectCollection UnprotectedAttributes => m_unprotectedAttributes;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.EnvelopedCms.RecipientInfos" /> property retrieves the recipient information associated with the enveloped CMS/PKCS #7 message.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection that represents the recipient information. If no recipients exist, the property value is an empty collection.</returns>
		public RecipientInfoCollection RecipientInfos
		{
			[SecuritySafeCritical]
			get
			{
				if (m_safeCryptMsgHandle == null || m_safeCryptMsgHandle.IsInvalid)
				{
					return new RecipientInfoCollection();
				}
				return new RecipientInfoCollection(m_safeCryptMsgHandle);
			}
		}

		private static AlgorithmIdentifier GetDefaultEncryptionAlgorithm()
		{
			string oidValue = (LocalAppContextSwitches.EnvelopedCmsUseLegacyDefaultAlgorithm ? "1.2.840.113549.3.7" : "2.16.840.1.101.3.4.1.42");
			return new AlgorithmIdentifier(Oid.FromOidValue(oidValue, OidGroup.EncryptionAlgorithm));
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.#ctor" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.EnvelopedCms" /> class.</summary>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		public EnvelopedCms()
			: this(SubjectIdentifierType.IssuerAndSerialNumber, new ContentInfo(Oid.FromOidValue("1.2.840.113549.1.7.1", OidGroup.ExtensionOrAttribute), new byte[0]), GetDefaultEncryptionAlgorithm())
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.#ctor(System.Security.Cryptography.Pkcs.ContentInfo)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.EnvelopedCms" /> class by using the specified content information as the inner content type.</summary>
		/// <param name="contentInfo">An instance of the <see cref="P:System.Security.Cryptography.Pkcs.EnvelopedCms.ContentInfo" /> class that represents the content and its type.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		public EnvelopedCms(ContentInfo contentInfo)
			: this(SubjectIdentifierType.IssuerAndSerialNumber, contentInfo, GetDefaultEncryptionAlgorithm())
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.#ctor(System.Security.Cryptography.Pkcs.SubjectIdentifierType,System.Security.Cryptography.Pkcs.ContentInfo)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.EnvelopedCms" /> class by using the specified subject identifier type and content information. The specified content information is to be used as the inner content type.</summary>
		/// <param name="recipientIdentifierType">A member of the <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> enumeration that specifies the means of identifying the recipient.</param>
		/// <param name="contentInfo">A <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> object that represents the content and its type.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		public EnvelopedCms(SubjectIdentifierType recipientIdentifierType, ContentInfo contentInfo)
			: this(recipientIdentifierType, contentInfo, GetDefaultEncryptionAlgorithm())
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.#ctor(System.Security.Cryptography.Pkcs.ContentInfo,System.Security.Cryptography.Pkcs.AlgorithmIdentifier)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.EnvelopedCms" /> class by using the specified content information and encryption algorithm. The specified content information is to be used as the inner content type.</summary>
		/// <param name="contentInfo">A  <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> object that represents the content and its type.</param>
		/// <param name="encryptionAlgorithm">An <see cref="T:System.Security.Cryptography.Pkcs.AlgorithmIdentifier" /> object that specifies the encryption algorithm.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		public EnvelopedCms(ContentInfo contentInfo, AlgorithmIdentifier encryptionAlgorithm)
			: this(SubjectIdentifierType.IssuerAndSerialNumber, contentInfo, encryptionAlgorithm)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.#ctor(System.Security.Cryptography.Pkcs.SubjectIdentifierType,System.Security.Cryptography.Pkcs.ContentInfo,System.Security.Cryptography.Pkcs.AlgorithmIdentifier)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.EnvelopedCms" /> class by using the specified subject identifier type, content information, and encryption algorithm. The specified content information is to be used as the inner content type.</summary>
		/// <param name="recipientIdentifierType">A member of the <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> enumeration that specifies the means of identifying the recipient.</param>
		/// <param name="contentInfo">A <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> object that represents the content and its type.</param>
		/// <param name="encryptionAlgorithm">An <see cref="T:System.Security.Cryptography.Pkcs.AlgorithmIdentifier" /> object that specifies the encryption algorithm.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		[SecuritySafeCritical]
		public EnvelopedCms(SubjectIdentifierType recipientIdentifierType, ContentInfo contentInfo, AlgorithmIdentifier encryptionAlgorithm)
		{
			if (contentInfo == null)
			{
				throw new ArgumentNullException("contentInfo");
			}
			if (contentInfo.Content == null)
			{
				throw new ArgumentNullException("contentInfo.Content");
			}
			if (encryptionAlgorithm == null)
			{
				throw new ArgumentNullException("encryptionAlgorithm");
			}
			m_safeCryptMsgHandle = SafeCryptMsgHandle.InvalidHandle;
			m_version = ((recipientIdentifierType == SubjectIdentifierType.SubjectKeyIdentifier) ? 2 : 0);
			m_recipientIdentifierType = recipientIdentifierType;
			m_contentInfo = contentInfo;
			m_encryptionAlgorithm = encryptionAlgorithm;
			m_encryptionAlgorithm.Parameters = new byte[0];
			m_certificates = new X509Certificate2Collection();
			m_unprotectedAttributes = new CryptographicAttributeObjectCollection();
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Encode" /> method encodes the contents of the enveloped CMS/PKCS #7 message and returns it as an array of byte values. Encryption must be done before encoding.</summary>
		/// <returns>If the method succeeds, the method returns an array of byte values that represent the encoded information.  
		///  If the method fails, it throws an exception.</returns>
		/// <exception cref="T:System.InvalidOperationException">A method call was invalid for the object's current state.</exception>
		[SecuritySafeCritical]
		public byte[] Encode()
		{
			if (m_safeCryptMsgHandle == null || m_safeCryptMsgHandle.IsInvalid)
			{
				throw new InvalidOperationException(SecurityResources.GetResourceString("Cryptography_Cms_MessageNotEncrypted"));
			}
			return PkcsUtils.GetContent(m_safeCryptMsgHandle);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Decode(System.Byte[])" /> method decodes the specified enveloped CMS/PKCS #7 message and resets all member variables in the <see cref="T:System.Security.Cryptography.Pkcs.EnvelopedCms" /> object.</summary>
		/// <param name="encodedMessage">An array of byte values that represent the information to be decoded.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		[SecuritySafeCritical]
		public void Decode(byte[] encodedMessage)
		{
			if (encodedMessage == null)
			{
				throw new ArgumentNullException("encodedMessage");
			}
			if (m_safeCryptMsgHandle != null && !m_safeCryptMsgHandle.IsInvalid)
			{
				m_safeCryptMsgHandle.Dispose();
			}
			m_safeCryptMsgHandle = OpenToDecode(encodedMessage);
			m_version = (int)PkcsUtils.GetVersion(m_safeCryptMsgHandle);
			Oid contentType = PkcsUtils.GetContentType(m_safeCryptMsgHandle);
			byte[] content = PkcsUtils.GetContent(m_safeCryptMsgHandle);
			m_contentInfo = new ContentInfo(contentType, content);
			m_encryptionAlgorithm = PkcsUtils.GetAlgorithmIdentifier(m_safeCryptMsgHandle);
			m_certificates = PkcsUtils.GetCertificates(m_safeCryptMsgHandle);
			m_unprotectedAttributes = PkcsUtils.GetUnprotectedAttributes(m_safeCryptMsgHandle);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Encrypt" /> method encrypts the contents of the CMS/PKCS #7 message.</summary>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public void Encrypt()
		{
			Encrypt(new CmsRecipientCollection());
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Encrypt(System.Security.Cryptography.Pkcs.CmsRecipient)" /> method encrypts the contents of the CMS/PKCS #7 message by using the specified recipient information.</summary>
		/// <param name="recipient">A <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object that represents the recipient information.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public void Encrypt(CmsRecipient recipient)
		{
			if (recipient == null)
			{
				throw new ArgumentNullException("recipient");
			}
			Encrypt(new CmsRecipientCollection(recipient));
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Encrypt(System.Security.Cryptography.Pkcs.CmsRecipientCollection)" /> method encrypts the contents of the CMS/PKCS #7 message by using the information for the specified list of recipients. The message is encrypted by using a message encryption key with a symmetric encryption algorithm such as triple DES. The message encryption key is then encrypted with the public key of each recipient.</summary>
		/// <param name="recipients">A <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection that represents the information for the list of recipients.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public void Encrypt(CmsRecipientCollection recipients)
		{
			if (recipients == null)
			{
				throw new ArgumentNullException("recipients");
			}
			if (ContentInfo.Content.Length == 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Envelope_Empty_Content"));
			}
			if (recipients.Count == 0)
			{
				recipients = PkcsUtils.SelectRecipients(m_recipientIdentifierType);
			}
			EncryptContent(recipients);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Decrypt" /> method decrypts the contents of the decoded enveloped CMS/PKCS #7 message. The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Decrypt" /> method searches the current user and computer My stores for the appropriate certificate and private key.</summary>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		/// <exception cref="T:System.InvalidOperationException">A method call was invalid for the object's current state.</exception>
		public void Decrypt()
		{
			DecryptContent(RecipientInfos, null);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Decrypt(System.Security.Cryptography.Pkcs.RecipientInfo)" /> method decrypts the contents of the decoded enveloped CMS/PKCS #7 message by using the private key associated with the certificate identified by the specified recipient information.</summary>
		/// <param name="recipientInfo">A <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object that represents the recipient information that identifies the certificate associated with the private key to use for the decryption.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		/// <exception cref="T:System.InvalidOperationException">A method call was invalid for the object's current state.</exception>
		public void Decrypt(RecipientInfo recipientInfo)
		{
			if (recipientInfo == null)
			{
				throw new ArgumentNullException("recipientInfo");
			}
			DecryptContent(new RecipientInfoCollection(recipientInfo), null);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Decrypt(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" /> method decrypts the contents of the decoded enveloped CMS/PKCS #7 message by using the specified certificate collection. The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Decrypt(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" /> method searches the specified certificate collection and the My certificate store for the proper certificate to use for the decryption.</summary>
		/// <param name="extraStore">An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> collection that represents additional certificates to use for the decryption. The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Decrypt(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" /> method searches this certificate collection and the My certificate store for the proper certificate to use for the decryption.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		/// <exception cref="T:System.InvalidOperationException">A method call was invalid for the object's current state.</exception>
		public void Decrypt(X509Certificate2Collection extraStore)
		{
			if (extraStore == null)
			{
				throw new ArgumentNullException("extraStore");
			}
			DecryptContent(RecipientInfos, extraStore);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Decrypt(System.Security.Cryptography.Pkcs.RecipientInfo,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" /> method decrypts the contents of the decoded enveloped CMS/PKCS #7 message by using the private key associated with the certificate identified by the specified recipient information and by using the specified certificate collection.  The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Decrypt(System.Security.Cryptography.Pkcs.RecipientInfo,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" /> method searches the specified certificate collection and the My certificate store for the proper certificate to use for the decryption.</summary>
		/// <param name="recipientInfo">A <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object that represents the recipient information to use for the decryption.</param>
		/// <param name="extraStore">An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> collection that represents additional certificates to use for the decryption. The <see cref="M:System.Security.Cryptography.Pkcs.EnvelopedCms.Decrypt(System.Security.Cryptography.Pkcs.RecipientInfo,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" /> method searches this certificate collection and the My certificate store for the proper certificate to use for the decryption.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		/// <exception cref="T:System.InvalidOperationException">A method call was invalid for the object's current state.</exception>
		public void Decrypt(RecipientInfo recipientInfo, X509Certificate2Collection extraStore)
		{
			if (recipientInfo == null)
			{
				throw new ArgumentNullException("recipientInfo");
			}
			if (extraStore == null)
			{
				throw new ArgumentNullException("extraStore");
			}
			DecryptContent(new RecipientInfoCollection(recipientInfo), extraStore);
		}

		[SecuritySafeCritical]
		private unsafe void DecryptContent(RecipientInfoCollection recipientInfos, X509Certificate2Collection extraStore)
		{
			int num = -2146889717;
			if (m_safeCryptMsgHandle == null || m_safeCryptMsgHandle.IsInvalid)
			{
				throw new InvalidOperationException(SecurityResources.GetResourceString("Cryptography_Cms_NoEncryptedMessageToEncode"));
			}
			for (int i = 0; i < recipientInfos.Count; i++)
			{
				RecipientInfo recipientInfo = recipientInfos[i];
				CMSG_DECRYPT_PARAM cmsgDecryptParam = default(CMSG_DECRYPT_PARAM);
				int num2 = GetCspParams(recipientInfo, extraStore, ref cmsgDecryptParam);
				if (num2 == 0)
				{
					CspParameters parameters = new CspParameters();
					if (System.Security.Cryptography.X509Certificates.X509Utils.GetPrivateKeyInfo(cmsgDecryptParam.safeCertContextHandle, ref parameters))
					{
						KeyContainerPermission keyContainerPermission = new KeyContainerPermission(KeyContainerPermissionFlags.NoFlags);
						KeyContainerPermissionAccessEntry accessEntry = new KeyContainerPermissionAccessEntry(parameters, KeyContainerPermissionFlags.Open | KeyContainerPermissionFlags.Decrypt);
						keyContainerPermission.AccessEntries.Add(accessEntry);
						keyContainerPermission.Demand();
					}
					switch (recipientInfo.Type)
					{
					case RecipientInfoType.KeyTransport:
					{
						CAPI.CMSG_CTRL_DECRYPT_PARA cMSG_CTRL_DECRYPT_PARA = new CAPI.CMSG_CTRL_DECRYPT_PARA(Marshal.SizeOf(typeof(CAPI.CMSG_CTRL_DECRYPT_PARA)));
						cMSG_CTRL_DECRYPT_PARA.hCryptProv = cmsgDecryptParam.safeCryptProvHandle.DangerousGetHandle();
						cMSG_CTRL_DECRYPT_PARA.dwKeySpec = cmsgDecryptParam.keySpec;
						cMSG_CTRL_DECRYPT_PARA.dwRecipientIndex = recipientInfo.Index;
						if (!CAPI.CryptMsgControl(m_safeCryptMsgHandle, 0u, 2u, new IntPtr(&cMSG_CTRL_DECRYPT_PARA)))
						{
							num2 = Marshal.GetHRForLastWin32Error();
						}
						GC.KeepAlive(cMSG_CTRL_DECRYPT_PARA);
						break;
					}
					case RecipientInfoType.KeyAgreement:
					{
						SafeCertContextHandle safeCertContextHandle = SafeCertContextHandle.InvalidHandle;
						KeyAgreeRecipientInfo keyAgreeRecipientInfo = (KeyAgreeRecipientInfo)recipientInfo;
						CAPI.CMSG_CMS_RECIPIENT_INFO cMSG_CMS_RECIPIENT_INFO = (CAPI.CMSG_CMS_RECIPIENT_INFO)Marshal.PtrToStructure(keyAgreeRecipientInfo.pCmsgRecipientInfo.DangerousGetHandle(), typeof(CAPI.CMSG_CMS_RECIPIENT_INFO));
						CAPI.CMSG_CTRL_KEY_AGREE_DECRYPT_PARA cMSG_CTRL_KEY_AGREE_DECRYPT_PARA = new CAPI.CMSG_CTRL_KEY_AGREE_DECRYPT_PARA(Marshal.SizeOf(typeof(CAPI.CMSG_CTRL_KEY_AGREE_DECRYPT_PARA)));
						cMSG_CTRL_KEY_AGREE_DECRYPT_PARA.hCryptProv = cmsgDecryptParam.safeCryptProvHandle.DangerousGetHandle();
						cMSG_CTRL_KEY_AGREE_DECRYPT_PARA.dwKeySpec = cmsgDecryptParam.keySpec;
						cMSG_CTRL_KEY_AGREE_DECRYPT_PARA.pKeyAgree = cMSG_CMS_RECIPIENT_INFO.pRecipientInfo;
						cMSG_CTRL_KEY_AGREE_DECRYPT_PARA.dwRecipientIndex = keyAgreeRecipientInfo.Index;
						cMSG_CTRL_KEY_AGREE_DECRYPT_PARA.dwRecipientEncryptedKeyIndex = keyAgreeRecipientInfo.SubIndex;
						if (keyAgreeRecipientInfo.SubType == RecipientSubType.CertIdKeyAgreement)
						{
							CAPI.CMSG_KEY_AGREE_CERT_ID_RECIPIENT_INFO cMSG_KEY_AGREE_CERT_ID_RECIPIENT_INFO = (CAPI.CMSG_KEY_AGREE_CERT_ID_RECIPIENT_INFO)keyAgreeRecipientInfo.CmsgRecipientInfo;
							SafeCertStoreHandle hCertStore = BuildOriginatorStore(Certificates, extraStore);
							safeCertContextHandle = CAPI.CertFindCertificateInStore(hCertStore, 65537u, 0u, 1048576u, new IntPtr(&cMSG_KEY_AGREE_CERT_ID_RECIPIENT_INFO.OriginatorCertId), SafeCertContextHandle.InvalidHandle);
							if (safeCertContextHandle == null || safeCertContextHandle.IsInvalid)
							{
								num2 = -2146885628;
								break;
							}
							cMSG_CTRL_KEY_AGREE_DECRYPT_PARA.OriginatorPublicKey = ((CAPI.CERT_INFO)Marshal.PtrToStructure(((CAPI.CERT_CONTEXT)Marshal.PtrToStructure(safeCertContextHandle.DangerousGetHandle(), typeof(CAPI.CERT_CONTEXT))).pCertInfo, typeof(CAPI.CERT_INFO))).SubjectPublicKeyInfo.PublicKey;
						}
						else
						{
							cMSG_CTRL_KEY_AGREE_DECRYPT_PARA.OriginatorPublicKey = ((CAPI.CMSG_KEY_AGREE_PUBLIC_KEY_RECIPIENT_INFO)keyAgreeRecipientInfo.CmsgRecipientInfo).OriginatorPublicKeyInfo.PublicKey;
						}
						if (!CAPI.CryptMsgControl(m_safeCryptMsgHandle, 0u, 17u, new IntPtr(&cMSG_CTRL_KEY_AGREE_DECRYPT_PARA)))
						{
							num2 = Marshal.GetHRForLastWin32Error();
						}
						GC.KeepAlive(cMSG_CTRL_KEY_AGREE_DECRYPT_PARA);
						GC.KeepAlive(safeCertContextHandle);
						break;
					}
					default:
						throw new CryptographicException(-2147483647);
					}
					GC.KeepAlive(cmsgDecryptParam);
				}
				if (num2 == 0)
				{
					uint cbData = 0u;
					SafeLocalAllocHandle pvData = SafeLocalAllocHandle.InvalidHandle;
					PkcsUtils.GetParam(m_safeCryptMsgHandle, 2u, 0u, out pvData, out cbData);
					if (cbData != 0)
					{
						Oid contentType = PkcsUtils.GetContentType(m_safeCryptMsgHandle);
						byte[] array = new byte[cbData];
						Marshal.Copy(pvData.DangerousGetHandle(), array, 0, (int)cbData);
						m_contentInfo = new ContentInfo(contentType, array);
					}
					pvData.Dispose();
					num = 0;
					break;
				}
				num = num2;
			}
			if (num != 0)
			{
				throw new CryptographicException(num);
			}
		}

		[SecuritySafeCritical]
		private unsafe void EncryptContent(CmsRecipientCollection recipients)
		{
			CMSG_ENCRYPT_PARAM encryptParam = default(CMSG_ENCRYPT_PARAM);
			if (recipients.Count < 1)
			{
				throw new CryptographicException(-2146889717);
			}
			CmsRecipientEnumerator enumerator = recipients.GetEnumerator();
			while (enumerator.MoveNext())
			{
				CmsRecipient current = enumerator.Current;
				if (current.Certificate == null)
				{
					throw new ArgumentNullException(SecurityResources.GetResourceString("Cryptography_Cms_RecipientCertificateNotFound"));
				}
				if (PkcsUtils.GetRecipientInfoType(current.Certificate) == RecipientInfoType.KeyAgreement || current.RecipientIdentifierType == SubjectIdentifierType.SubjectKeyIdentifier)
				{
					encryptParam.useCms = true;
				}
			}
			if (!encryptParam.useCms && (Certificates.Count > 0 || UnprotectedAttributes.Count > 0))
			{
				encryptParam.useCms = true;
			}
			if (encryptParam.useCms && !PkcsUtils.CmsSupported())
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Not_Supported"));
			}
			CAPI.CMSG_ENVELOPED_ENCODE_INFO cMSG_ENVELOPED_ENCODE_INFO = new CAPI.CMSG_ENVELOPED_ENCODE_INFO(Marshal.SizeOf(typeof(CAPI.CMSG_ENVELOPED_ENCODE_INFO)));
			SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(CAPI.CMSG_ENVELOPED_ENCODE_INFO))));
			SetCspParams(ContentEncryptionAlgorithm, ref encryptParam);
			cMSG_ENVELOPED_ENCODE_INFO.ContentEncryptionAlgorithm.pszObjId = ContentEncryptionAlgorithm.Oid.Value;
			if (encryptParam.pvEncryptionAuxInfo != null && !encryptParam.pvEncryptionAuxInfo.IsInvalid)
			{
				cMSG_ENVELOPED_ENCODE_INFO.pvEncryptionAuxInfo = encryptParam.pvEncryptionAuxInfo.DangerousGetHandle();
			}
			cMSG_ENVELOPED_ENCODE_INFO.cRecipients = (uint)recipients.Count;
			List<SafeCertContextHandle> certContexts = null;
			if (encryptParam.useCms)
			{
				SetCmsRecipientParams(recipients, Certificates, UnprotectedAttributes, ContentEncryptionAlgorithm, ref encryptParam);
				cMSG_ENVELOPED_ENCODE_INFO.rgCmsRecipients = encryptParam.rgpRecipients.DangerousGetHandle();
				if (encryptParam.rgCertEncoded != null && !encryptParam.rgCertEncoded.IsInvalid)
				{
					cMSG_ENVELOPED_ENCODE_INFO.cCertEncoded = (uint)Certificates.Count;
					cMSG_ENVELOPED_ENCODE_INFO.rgCertEncoded = encryptParam.rgCertEncoded.DangerousGetHandle();
				}
				if (encryptParam.rgUnprotectedAttr != null && !encryptParam.rgUnprotectedAttr.IsInvalid)
				{
					cMSG_ENVELOPED_ENCODE_INFO.cUnprotectedAttr = (uint)UnprotectedAttributes.Count;
					cMSG_ENVELOPED_ENCODE_INFO.rgUnprotectedAttr = encryptParam.rgUnprotectedAttr.DangerousGetHandle();
				}
			}
			else
			{
				SetPkcs7RecipientParams(recipients, ref encryptParam, out certContexts);
				cMSG_ENVELOPED_ENCODE_INFO.rgpRecipients = encryptParam.rgpRecipients.DangerousGetHandle();
			}
			Marshal.StructureToPtr((object)cMSG_ENVELOPED_ENCODE_INFO, safeLocalAllocHandle.DangerousGetHandle(), fDeleteOld: false);
			try
			{
				SafeCryptMsgHandle safeCryptMsgHandle = CAPI.CryptMsgOpenToEncode(65537u, 0u, 3u, safeLocalAllocHandle.DangerousGetHandle(), ContentInfo.ContentType.Value, IntPtr.Zero);
				if (safeCryptMsgHandle == null || safeCryptMsgHandle.IsInvalid)
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
				if (m_safeCryptMsgHandle != null && !m_safeCryptMsgHandle.IsInvalid)
				{
					m_safeCryptMsgHandle.Dispose();
				}
				m_safeCryptMsgHandle = safeCryptMsgHandle;
			}
			finally
			{
				Marshal.DestroyStructure(safeLocalAllocHandle.DangerousGetHandle(), typeof(CAPI.CMSG_ENVELOPED_ENCODE_INFO));
				safeLocalAllocHandle.Dispose();
			}
			byte[] encodedData = new byte[0];
			if (string.Compare(ContentInfo.ContentType.Value, "1.2.840.113549.1.7.1", StringComparison.OrdinalIgnoreCase) == 0)
			{
				byte[] content = ContentInfo.Content;
				fixed (byte* value = content)
				{
					CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB = default(CAPI.CRYPTOAPI_BLOB);
					cRYPTOAPI_BLOB.cbData = (uint)content.Length;
					cRYPTOAPI_BLOB.pbData = new IntPtr(value);
					if (!CAPI.EncodeObject(new IntPtr(25L), new IntPtr(&cRYPTOAPI_BLOB), out encodedData))
					{
						throw new CryptographicException(Marshal.GetLastWin32Error());
					}
				}
			}
			else
			{
				encodedData = ContentInfo.Content;
			}
			if (encodedData.Length != 0 && !CAPI.CAPISafe.CryptMsgUpdate(m_safeCryptMsgHandle, encodedData, (uint)encodedData.Length, fFinal: true))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			GC.KeepAlive(encryptParam);
			GC.KeepAlive(recipients);
			GC.KeepAlive(certContexts);
		}

		[SecuritySafeCritical]
		private static SafeCryptMsgHandle OpenToDecode(byte[] encodedMessage)
		{
			SafeCryptMsgHandle safeCryptMsgHandle = null;
			safeCryptMsgHandle = CAPI.CAPISafe.CryptMsgOpenToDecode(65537u, 0u, 0u, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);
			if (safeCryptMsgHandle == null || safeCryptMsgHandle.IsInvalid)
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			if (!CAPI.CAPISafe.CryptMsgUpdate(safeCryptMsgHandle, encodedMessage, (uint)encodedMessage.Length, fFinal: true))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			if (3 != PkcsUtils.GetMessageType(safeCryptMsgHandle))
			{
				throw new CryptographicException(-2146889724);
			}
			return safeCryptMsgHandle;
		}

		[SecurityCritical]
		private unsafe static int GetCspParams(RecipientInfo recipientInfo, X509Certificate2Collection extraStore, ref CMSG_DECRYPT_PARAM cmsgDecryptParam)
		{
			int result = -2146889717;
			SafeCertContextHandle safeCertContextHandle = SafeCertContextHandle.InvalidHandle;
			SafeCertStoreHandle safeCertStoreHandle = BuildDecryptorStore(extraStore);
			switch (recipientInfo.Type)
			{
			case RecipientInfoType.KeyTransport:
			{
				if (recipientInfo.SubType == RecipientSubType.Pkcs7KeyTransport)
				{
					safeCertContextHandle = CAPI.CertFindCertificateInStore(safeCertStoreHandle, 65537u, 0u, 720896u, recipientInfo.pCmsgRecipientInfo.DangerousGetHandle(), SafeCertContextHandle.InvalidHandle);
					break;
				}
				CAPI.CMSG_KEY_TRANS_RECIPIENT_INFO cMSG_KEY_TRANS_RECIPIENT_INFO = (CAPI.CMSG_KEY_TRANS_RECIPIENT_INFO)recipientInfo.CmsgRecipientInfo;
				safeCertContextHandle = CAPI.CertFindCertificateInStore(safeCertStoreHandle, 65537u, 0u, 1048576u, new IntPtr(&cMSG_KEY_TRANS_RECIPIENT_INFO.RecipientId), SafeCertContextHandle.InvalidHandle);
				break;
			}
			case RecipientInfoType.KeyAgreement:
			{
				KeyAgreeRecipientInfo keyAgreeRecipientInfo = (KeyAgreeRecipientInfo)recipientInfo;
				CAPI.CERT_ID recipientId = keyAgreeRecipientInfo.RecipientId;
				safeCertContextHandle = CAPI.CertFindCertificateInStore(safeCertStoreHandle, 65537u, 0u, 1048576u, new IntPtr(&recipientId), SafeCertContextHandle.InvalidHandle);
				break;
			}
			default:
				result = -2147483647;
				break;
			}
			safeCertStoreHandle.Dispose();
			if (safeCertContextHandle != null && !safeCertContextHandle.IsInvalid)
			{
				result = PkcsUtils.GetCertPrivateKey(safeCertContextHandle, out var safeCryptProvHandle, out var keySpec);
				if (safeCryptProvHandle != null && !safeCryptProvHandle.IsInvalid)
				{
					cmsgDecryptParam.safeCryptProvHandle = safeCryptProvHandle;
				}
				else
				{
					cmsgDecryptParam.safeCryptProvHandle = null;
				}
				cmsgDecryptParam.safeCertContextHandle = safeCertContextHandle;
				cmsgDecryptParam.keySpec = keySpec;
			}
			return result;
		}

		[SecurityCritical]
		private static void SetCspParams(AlgorithmIdentifier contentEncryptionAlgorithm, ref CMSG_ENCRYPT_PARAM encryptParam)
		{
			encryptParam.safeCryptProvHandle = SafeCryptProvHandle.InvalidHandle;
			encryptParam.pvEncryptionAuxInfo = SafeLocalAllocHandle.InvalidHandle;
			SafeCryptProvHandle hCryptProv = SafeCryptProvHandle.InvalidHandle;
			if (!CAPI.CryptAcquireContext(ref hCryptProv, IntPtr.Zero, IntPtr.Zero, 1u, 4026531840u))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			uint num = System.Security.Cryptography.X509Certificates.X509Utils.OidToAlgId(contentEncryptionAlgorithm.Oid.Value);
			if (num == 26114 || num == 26625)
			{
				CAPI.CMSG_RC2_AUX_INFO cMSG_RC2_AUX_INFO = new CAPI.CMSG_RC2_AUX_INFO(Marshal.SizeOf(typeof(CAPI.CMSG_RC2_AUX_INFO)));
				uint num2 = (uint)contentEncryptionAlgorithm.KeyLength;
				if (num2 == 0)
				{
					num2 = (uint)PkcsUtils.GetMaxKeyLength(hCryptProv, num);
				}
				cMSG_RC2_AUX_INFO.dwBitLen = num2;
				SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(CAPI.CMSG_RC2_AUX_INFO))));
				Marshal.StructureToPtr((object)cMSG_RC2_AUX_INFO, safeLocalAllocHandle.DangerousGetHandle(), fDeleteOld: false);
				encryptParam.pvEncryptionAuxInfo = safeLocalAllocHandle;
			}
			encryptParam.safeCryptProvHandle = hCryptProv;
		}

		[SecurityCritical]
		private unsafe static void SetCmsRecipientParams(CmsRecipientCollection recipients, X509Certificate2Collection certificates, CryptographicAttributeObjectCollection unprotectedAttributes, AlgorithmIdentifier contentEncryptionAlgorithm, ref CMSG_ENCRYPT_PARAM encryptParam)
		{
			recipients = recipients.DeepCopy();
			certificates = new X509Certificate2Collection(certificates);
			int num = 0;
			uint[] array = new uint[recipients.Count];
			int num2 = 0;
			checked
			{
				int num3 = recipients.Count * Marshal.SizeOf(typeof(CAPI.CMSG_RECIPIENT_ENCODE_INFO));
				int num4 = num3;
				for (num = 0; num < recipients.Count; num++)
				{
					array[num] = (uint)PkcsUtils.GetRecipientInfoType(recipients[num].Certificate);
					if (array[num] == 1)
					{
						num4 += Marshal.SizeOf(typeof(CAPI.CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO));
						continue;
					}
					if (array[num] == 2)
					{
						num2++;
						num4 += Marshal.SizeOf(typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO));
						continue;
					}
					throw new CryptographicException(-2146889726);
				}
				encryptParam.rgpRecipients = CAPI.LocalAlloc(64u, new IntPtr(num4));
				encryptParam.rgCertEncoded = SafeLocalAllocHandle.InvalidHandle;
				encryptParam.rgUnprotectedAttr = SafeLocalAllocHandle.InvalidHandle;
				encryptParam.rgSubjectKeyIdentifier = new SafeLocalAllocHandle[recipients.Count];
				encryptParam.rgszObjId = new SafeLocalAllocHandle[recipients.Count];
				if (num2 > 0)
				{
					encryptParam.rgszKeyWrapObjId = new SafeLocalAllocHandle[num2];
					encryptParam.rgKeyWrapAuxInfo = new SafeLocalAllocHandle[num2];
					encryptParam.rgEphemeralIdentifier = new SafeLocalAllocHandle[num2];
					encryptParam.rgszEphemeralObjId = new SafeLocalAllocHandle[num2];
					encryptParam.rgUserKeyingMaterial = new SafeLocalAllocHandle[num2];
					encryptParam.prgpEncryptedKey = new SafeLocalAllocHandle[num2];
					encryptParam.rgpEncryptedKey = new SafeLocalAllocHandle[num2];
				}
				if (certificates.Count > 0)
				{
					encryptParam.rgCertEncoded = CAPI.LocalAlloc(64u, new IntPtr(certificates.Count * Marshal.SizeOf(typeof(CAPI.CRYPTOAPI_BLOB))));
					for (num = 0; num < certificates.Count; num++)
					{
						CAPI.CERT_CONTEXT cERT_CONTEXT = (CAPI.CERT_CONTEXT)Marshal.PtrToStructure(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificates[num]).DangerousGetHandle(), typeof(CAPI.CERT_CONTEXT));
						unchecked
						{
							CAPI.CRYPTOAPI_BLOB* ptr = (CAPI.CRYPTOAPI_BLOB*)(void*)new IntPtr(checked((long)encryptParam.rgCertEncoded.DangerousGetHandle() + num * Marshal.SizeOf(typeof(CAPI.CRYPTOAPI_BLOB))));
							ptr->cbData = cERT_CONTEXT.cbCertEncoded;
							ptr->pbData = cERT_CONTEXT.pbCertEncoded;
						}
					}
				}
				if (unprotectedAttributes.Count > 0)
				{
					encryptParam.rgUnprotectedAttr = new SafeLocalAllocHandle(PkcsUtils.CreateCryptAttributes(unprotectedAttributes));
				}
				num2 = 0;
				IntPtr intPtr = new IntPtr((long)encryptParam.rgpRecipients.DangerousGetHandle() + num3);
				for (num = 0; num < recipients.Count; num++)
				{
					CmsRecipient cmsRecipient = recipients[num];
					X509Certificate2 certificate = cmsRecipient.Certificate;
					CAPI.CERT_INFO cERT_INFO = (CAPI.CERT_INFO)Marshal.PtrToStructure(((CAPI.CERT_CONTEXT)Marshal.PtrToStructure(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificate).DangerousGetHandle(), typeof(CAPI.CERT_CONTEXT))).pCertInfo, typeof(CAPI.CERT_INFO));
					unchecked
					{
						CAPI.CMSG_RECIPIENT_ENCODE_INFO* ptr2 = (CAPI.CMSG_RECIPIENT_ENCODE_INFO*)(void*)new IntPtr(checked((long)encryptParam.rgpRecipients.DangerousGetHandle() + num * Marshal.SizeOf(typeof(CAPI.CMSG_RECIPIENT_ENCODE_INFO))));
						ptr2->dwRecipientChoice = array[num];
						ptr2->pRecipientInfo = intPtr;
					}
					if (array[num] == 1)
					{
						IntPtr ptr3 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO), "cbSize"));
						Marshal.WriteInt32(ptr3, Marshal.SizeOf(typeof(CAPI.CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO)));
						IntPtr intPtr2 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO), "KeyEncryptionAlgorithm"));
						byte[] bytes = Encoding.ASCII.GetBytes(cERT_INFO.SubjectPublicKeyInfo.Algorithm.pszObjId);
						encryptParam.rgszObjId[num] = CAPI.LocalAlloc(64u, new IntPtr(bytes.Length + 1));
						Marshal.Copy(bytes, 0, encryptParam.rgszObjId[num].DangerousGetHandle(), bytes.Length);
						IntPtr ptr4 = new IntPtr((long)intPtr2 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_ALGORITHM_IDENTIFIER), "pszObjId"));
						Marshal.WriteIntPtr(ptr4, encryptParam.rgszObjId[num].DangerousGetHandle());
						IntPtr intPtr3 = new IntPtr((long)intPtr2 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_ALGORITHM_IDENTIFIER), "Parameters"));
						IntPtr ptr5 = new IntPtr((long)intPtr3 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "cbData"));
						Marshal.WriteInt32(ptr5, (int)cERT_INFO.SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
						IntPtr ptr6 = new IntPtr((long)intPtr3 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "pbData"));
						Marshal.WriteIntPtr(ptr6, cERT_INFO.SubjectPublicKeyInfo.Algorithm.Parameters.pbData);
						IntPtr intPtr4 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO), "RecipientPublicKey"));
						ptr5 = new IntPtr((long)intPtr4 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_BIT_BLOB), "cbData"));
						Marshal.WriteInt32(ptr5, (int)cERT_INFO.SubjectPublicKeyInfo.PublicKey.cbData);
						ptr6 = new IntPtr((long)intPtr4 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_BIT_BLOB), "pbData"));
						Marshal.WriteIntPtr(ptr6, cERT_INFO.SubjectPublicKeyInfo.PublicKey.pbData);
						IntPtr ptr7 = new IntPtr((long)intPtr4 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_BIT_BLOB), "cUnusedBits"));
						Marshal.WriteInt32(ptr7, (int)cERT_INFO.SubjectPublicKeyInfo.PublicKey.cUnusedBits);
						IntPtr intPtr5 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO), "RecipientId"));
						if (cmsRecipient.RecipientIdentifierType == SubjectIdentifierType.SubjectKeyIdentifier)
						{
							uint pcbData = 0u;
							SafeLocalAllocHandle invalidHandle = SafeLocalAllocHandle.InvalidHandle;
							if (!CAPI.CAPISafe.CertGetCertificateContextProperty(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificate), 20u, invalidHandle, ref pcbData))
							{
								throw new CryptographicException(Marshal.GetLastWin32Error());
							}
							invalidHandle = CAPI.LocalAlloc(64u, new IntPtr(pcbData));
							if (!CAPI.CAPISafe.CertGetCertificateContextProperty(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificate), 20u, invalidHandle, ref pcbData))
							{
								throw new CryptographicException(Marshal.GetLastWin32Error());
							}
							encryptParam.rgSubjectKeyIdentifier[num] = invalidHandle;
							IntPtr ptr8 = new IntPtr((long)intPtr5 + (long)Marshal.OffsetOf(typeof(CAPI.CERT_ID), "dwIdChoice"));
							Marshal.WriteInt32(ptr8, 2);
							IntPtr intPtr6 = new IntPtr((long)intPtr5 + (long)Marshal.OffsetOf(typeof(CAPI.CERT_ID), "Value"));
							ptr5 = new IntPtr((long)intPtr6 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "cbData"));
							Marshal.WriteInt32(ptr5, (int)pcbData);
							ptr6 = new IntPtr((long)intPtr6 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "pbData"));
							Marshal.WriteIntPtr(ptr6, invalidHandle.DangerousGetHandle());
						}
						else
						{
							IntPtr ptr9 = new IntPtr((long)intPtr5 + (long)Marshal.OffsetOf(typeof(CAPI.CERT_ID), "dwIdChoice"));
							Marshal.WriteInt32(ptr9, 1);
							IntPtr intPtr7 = new IntPtr((long)intPtr5 + (long)Marshal.OffsetOf(typeof(CAPI.CERT_ID), "Value"));
							IntPtr intPtr8 = new IntPtr((long)intPtr7 + (long)Marshal.OffsetOf(typeof(CAPI.CERT_ISSUER_SERIAL_NUMBER), "Issuer"));
							ptr5 = new IntPtr((long)intPtr8 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "cbData"));
							Marshal.WriteInt32(ptr5, (int)cERT_INFO.Issuer.cbData);
							ptr6 = new IntPtr((long)intPtr8 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "pbData"));
							Marshal.WriteIntPtr(ptr6, cERT_INFO.Issuer.pbData);
							IntPtr intPtr9 = new IntPtr((long)intPtr7 + (long)Marshal.OffsetOf(typeof(CAPI.CERT_ISSUER_SERIAL_NUMBER), "SerialNumber"));
							ptr5 = new IntPtr((long)intPtr9 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "cbData"));
							Marshal.WriteInt32(ptr5, (int)cERT_INFO.SerialNumber.cbData);
							ptr6 = new IntPtr((long)intPtr9 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "pbData"));
							Marshal.WriteIntPtr(ptr6, cERT_INFO.SerialNumber.pbData);
						}
						intPtr = new IntPtr((long)intPtr + Marshal.SizeOf(typeof(CAPI.CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO)));
					}
					else
					{
						if (array[num] != 2)
						{
							continue;
						}
						IntPtr ptr10 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO), "cbSize"));
						Marshal.WriteInt32(ptr10, Marshal.SizeOf(typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO)));
						IntPtr intPtr10 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO), "KeyEncryptionAlgorithm"));
						byte[] bytes2 = Encoding.ASCII.GetBytes("1.2.840.113549.1.9.16.3.5");
						encryptParam.rgszObjId[num] = CAPI.LocalAlloc(64u, new IntPtr(bytes2.Length + 1));
						Marshal.Copy(bytes2, 0, encryptParam.rgszObjId[num].DangerousGetHandle(), bytes2.Length);
						IntPtr ptr11 = new IntPtr((long)intPtr10 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_ALGORITHM_IDENTIFIER), "pszObjId"));
						Marshal.WriteIntPtr(ptr11, encryptParam.rgszObjId[num].DangerousGetHandle());
						IntPtr intPtr11 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO), "KeyWrapAlgorithm"));
						uint num5 = System.Security.Cryptography.X509Certificates.X509Utils.OidToAlgId(contentEncryptionAlgorithm.Oid.Value);
						bytes2 = ((num5 != 26114) ? Encoding.ASCII.GetBytes("1.2.840.113549.1.9.16.3.6") : Encoding.ASCII.GetBytes("1.2.840.113549.1.9.16.3.7"));
						encryptParam.rgszKeyWrapObjId[num2] = CAPI.LocalAlloc(64u, new IntPtr(bytes2.Length + 1));
						Marshal.Copy(bytes2, 0, encryptParam.rgszKeyWrapObjId[num2].DangerousGetHandle(), bytes2.Length);
						ptr11 = new IntPtr((long)intPtr11 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_ALGORITHM_IDENTIFIER), "pszObjId"));
						Marshal.WriteIntPtr(ptr11, encryptParam.rgszKeyWrapObjId[num2].DangerousGetHandle());
						if (num5 == 26114)
						{
							IntPtr ptr12 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO), "pvKeyWrapAuxInfo"));
							Marshal.WriteIntPtr(ptr12, encryptParam.pvEncryptionAuxInfo.DangerousGetHandle());
						}
						IntPtr ptr13 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO), "dwKeyChoice"));
						Marshal.WriteInt32(ptr13, 1);
						IntPtr ptr14 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO), "pEphemeralAlgorithmOrSenderId"));
						encryptParam.rgEphemeralIdentifier[num2] = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(CAPI.CRYPT_ALGORITHM_IDENTIFIER))));
						Marshal.WriteIntPtr(ptr14, encryptParam.rgEphemeralIdentifier[num2].DangerousGetHandle());
						bytes2 = Encoding.ASCII.GetBytes(cERT_INFO.SubjectPublicKeyInfo.Algorithm.pszObjId);
						encryptParam.rgszEphemeralObjId[num2] = CAPI.LocalAlloc(64u, new IntPtr(bytes2.Length + 1));
						Marshal.Copy(bytes2, 0, encryptParam.rgszEphemeralObjId[num2].DangerousGetHandle(), bytes2.Length);
						ptr11 = new IntPtr((long)encryptParam.rgEphemeralIdentifier[num2].DangerousGetHandle() + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_ALGORITHM_IDENTIFIER), "pszObjId"));
						Marshal.WriteIntPtr(ptr11, encryptParam.rgszEphemeralObjId[num2].DangerousGetHandle());
						IntPtr intPtr12 = new IntPtr((long)encryptParam.rgEphemeralIdentifier[num2].DangerousGetHandle() + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_ALGORITHM_IDENTIFIER), "Parameters"));
						IntPtr ptr15 = new IntPtr((long)intPtr12 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "cbData"));
						Marshal.WriteInt32(ptr15, (int)cERT_INFO.SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
						IntPtr ptr16 = new IntPtr((long)intPtr12 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "pbData"));
						Marshal.WriteIntPtr(ptr16, cERT_INFO.SubjectPublicKeyInfo.Algorithm.Parameters.pbData);
						IntPtr ptr17 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO), "cRecipientEncryptedKeys"));
						Marshal.WriteInt32(ptr17, 1);
						encryptParam.prgpEncryptedKey[num2] = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(IntPtr))));
						IntPtr ptr18 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO), "rgpRecipientEncryptedKeys"));
						Marshal.WriteIntPtr(ptr18, encryptParam.prgpEncryptedKey[num2].DangerousGetHandle());
						encryptParam.rgpEncryptedKey[num2] = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO))));
						Marshal.WriteIntPtr(encryptParam.prgpEncryptedKey[num2].DangerousGetHandle(), encryptParam.rgpEncryptedKey[num2].DangerousGetHandle());
						ptr10 = new IntPtr((long)encryptParam.rgpEncryptedKey[num2].DangerousGetHandle() + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO), "cbSize"));
						Marshal.WriteInt32(ptr10, Marshal.SizeOf(typeof(CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO)));
						IntPtr intPtr13 = new IntPtr((long)encryptParam.rgpEncryptedKey[num2].DangerousGetHandle() + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO), "RecipientPublicKey"));
						ptr15 = new IntPtr((long)intPtr13 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_BIT_BLOB), "cbData"));
						Marshal.WriteInt32(ptr15, (int)cERT_INFO.SubjectPublicKeyInfo.PublicKey.cbData);
						ptr16 = new IntPtr((long)intPtr13 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_BIT_BLOB), "pbData"));
						Marshal.WriteIntPtr(ptr16, cERT_INFO.SubjectPublicKeyInfo.PublicKey.pbData);
						IntPtr ptr19 = new IntPtr((long)intPtr13 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_BIT_BLOB), "cUnusedBits"));
						Marshal.WriteInt32(ptr19, (int)cERT_INFO.SubjectPublicKeyInfo.PublicKey.cUnusedBits);
						IntPtr intPtr14 = new IntPtr((long)encryptParam.rgpEncryptedKey[num2].DangerousGetHandle() + (long)Marshal.OffsetOf(typeof(CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO), "RecipientId"));
						IntPtr ptr20 = new IntPtr((long)intPtr14 + (long)Marshal.OffsetOf(typeof(CAPI.CERT_ID), "dwIdChoice"));
						if (cmsRecipient.RecipientIdentifierType == SubjectIdentifierType.SubjectKeyIdentifier)
						{
							Marshal.WriteInt32(ptr20, 2);
							IntPtr intPtr15 = new IntPtr((long)intPtr14 + (long)Marshal.OffsetOf(typeof(CAPI.CERT_ID), "Value"));
							uint pcbData2 = 0u;
							SafeLocalAllocHandle invalidHandle2 = SafeLocalAllocHandle.InvalidHandle;
							if (!CAPI.CAPISafe.CertGetCertificateContextProperty(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificate), 20u, invalidHandle2, ref pcbData2))
							{
								throw new CryptographicException(Marshal.GetLastWin32Error());
							}
							invalidHandle2 = CAPI.LocalAlloc(64u, new IntPtr(pcbData2));
							if (!CAPI.CAPISafe.CertGetCertificateContextProperty(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificate), 20u, invalidHandle2, ref pcbData2))
							{
								throw new CryptographicException(Marshal.GetLastWin32Error());
							}
							encryptParam.rgSubjectKeyIdentifier[num2] = invalidHandle2;
							ptr15 = new IntPtr((long)intPtr15 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "cbData"));
							Marshal.WriteInt32(ptr15, (int)pcbData2);
							ptr16 = new IntPtr((long)intPtr15 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "pbData"));
							Marshal.WriteIntPtr(ptr16, invalidHandle2.DangerousGetHandle());
						}
						else
						{
							Marshal.WriteInt32(ptr20, 1);
							IntPtr intPtr16 = new IntPtr((long)intPtr14 + (long)Marshal.OffsetOf(typeof(CAPI.CERT_ID), "Value"));
							IntPtr intPtr17 = new IntPtr((long)intPtr16 + (long)Marshal.OffsetOf(typeof(CAPI.CERT_ISSUER_SERIAL_NUMBER), "Issuer"));
							ptr15 = new IntPtr((long)intPtr17 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "cbData"));
							Marshal.WriteInt32(ptr15, (int)cERT_INFO.Issuer.cbData);
							ptr16 = new IntPtr((long)intPtr17 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "pbData"));
							Marshal.WriteIntPtr(ptr16, cERT_INFO.Issuer.pbData);
							IntPtr intPtr18 = new IntPtr((long)intPtr16 + (long)Marshal.OffsetOf(typeof(CAPI.CERT_ISSUER_SERIAL_NUMBER), "SerialNumber"));
							ptr15 = new IntPtr((long)intPtr18 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "cbData"));
							Marshal.WriteInt32(ptr15, (int)cERT_INFO.SerialNumber.cbData);
							ptr16 = new IntPtr((long)intPtr18 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "pbData"));
							Marshal.WriteIntPtr(ptr16, cERT_INFO.SerialNumber.pbData);
						}
						num2++;
						intPtr = new IntPtr((long)intPtr + Marshal.SizeOf(typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO)));
					}
				}
			}
		}

		[SecurityCritical]
		private static void SetPkcs7RecipientParams(CmsRecipientCollection recipients, ref CMSG_ENCRYPT_PARAM encryptParam, out List<SafeCertContextHandle> certContexts)
		{
			int num = 0;
			int count = recipients.Count;
			certContexts = new List<SafeCertContextHandle>();
			checked
			{
				uint num2 = (uint)count * (uint)Marshal.SizeOf(typeof(IntPtr));
				encryptParam.rgpRecipients = CAPI.LocalAlloc(64u, new IntPtr(num2));
				IntPtr intPtr = encryptParam.rgpRecipients.DangerousGetHandle();
				for (num = 0; num < count; num++)
				{
					SafeCertContextHandle certContext = System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(recipients[num].Certificate);
					certContexts.Add(certContext);
					IntPtr ptr = certContext.DangerousGetHandle();
					Marshal.WriteIntPtr(intPtr, ((CAPI.CERT_CONTEXT)Marshal.PtrToStructure(ptr, typeof(CAPI.CERT_CONTEXT))).pCertInfo);
					intPtr = new IntPtr((long)intPtr + Marshal.SizeOf(typeof(IntPtr)));
				}
			}
		}

		[SecurityCritical]
		private static SafeCertStoreHandle BuildDecryptorStore(X509Certificate2Collection extraStore)
		{
			X509Certificate2Collection x509Certificate2Collection = new X509Certificate2Collection();
			try
			{
				X509Store x509Store = new X509Store("MY", StoreLocation.CurrentUser);
				x509Store.Open(OpenFlags.OpenExistingOnly | OpenFlags.IncludeArchived);
				x509Certificate2Collection.AddRange(x509Store.Certificates);
				x509Store.Close();
			}
			catch (SecurityException)
			{
			}
			try
			{
				X509Store x509Store2 = new X509Store("MY", StoreLocation.LocalMachine);
				x509Store2.Open(OpenFlags.OpenExistingOnly | OpenFlags.IncludeArchived);
				x509Certificate2Collection.AddRange(x509Store2.Certificates);
				x509Store2.Close();
			}
			catch (SecurityException)
			{
			}
			if (x509Certificate2Collection.Count == 0 && extraStore.Count == 0)
			{
				throw new CryptographicException(-2146889717);
			}
			try
			{
				return System.Security.Cryptography.X509Certificates.X509Utils.ExportToMemoryStore(x509Certificate2Collection, extraStore);
			}
			finally
			{
				X509Certificate2Enumerator enumerator = x509Certificate2Collection.GetEnumerator();
				while (enumerator.MoveNext())
				{
					X509Certificate2 current = enumerator.Current;
					current.Reset();
				}
			}
		}

		[SecurityCritical]
		private static SafeCertStoreHandle BuildOriginatorStore(X509Certificate2Collection bagOfCerts, X509Certificate2Collection extraStore)
		{
			X509Certificate2Collection x509Certificate2Collection = new X509Certificate2Collection();
			try
			{
				X509Store x509Store = new X509Store("AddressBook", StoreLocation.CurrentUser);
				x509Store.Open(OpenFlags.OpenExistingOnly | OpenFlags.IncludeArchived);
				x509Certificate2Collection.AddRange(x509Store.Certificates);
				x509Store.Close();
			}
			catch (SecurityException)
			{
			}
			try
			{
				X509Store x509Store2 = new X509Store("AddressBook", StoreLocation.LocalMachine);
				x509Store2.Open(OpenFlags.OpenExistingOnly | OpenFlags.IncludeArchived);
				x509Certificate2Collection.AddRange(x509Store2.Certificates);
				x509Store2.Close();
			}
			catch (SecurityException)
			{
			}
			X509Certificate2Collection x509Certificate2Collection2;
			if (bagOfCerts == null || extraStore == null)
			{
				x509Certificate2Collection2 = ((bagOfCerts != null) ? bagOfCerts : ((extraStore == null) ? null : extraStore));
			}
			else
			{
				x509Certificate2Collection2 = new X509Certificate2Collection();
				x509Certificate2Collection2.AddRange(bagOfCerts);
				x509Certificate2Collection2.AddRange(extraStore);
			}
			if (x509Certificate2Collection.Count == 0 && x509Certificate2Collection2.Count == 0)
			{
				throw new CryptographicException(-2146885628);
			}
			try
			{
				return System.Security.Cryptography.X509Certificates.X509Utils.ExportToMemoryStore(x509Certificate2Collection, x509Certificate2Collection2);
			}
			finally
			{
				X509Certificate2Enumerator enumerator = x509Certificate2Collection.GetEnumerator();
				while (enumerator.MoveNext())
				{
					X509Certificate2 current = enumerator.Current;
					current.Reset();
				}
			}
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> class defines the recipient of a CMS/PKCS #7 message.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CmsRecipient
	{
		private SubjectIdentifierType m_recipientIdentifierType;

		private X509Certificate2 m_certificate;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsRecipient.RecipientIdentifierType" /> property retrieves the type of the identifier of the recipient.</summary>
		/// <returns>A member of the <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> enumeration that specifies the type of the identifier of the recipient.</returns>
		public SubjectIdentifierType RecipientIdentifierType => m_recipientIdentifierType;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsRecipient.Certificate" /> property retrieves the certificate associated with the recipient.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object that holds the certificate associated with the recipient.</returns>
		public X509Certificate2 Certificate => m_certificate;

		private CmsRecipient()
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipient.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2)" /> constructor constructs an instance of the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> class by using the specified recipient certificate.</summary>
		/// <param name="certificate">An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object that represents the recipient certificate.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public CmsRecipient(X509Certificate2 certificate)
			: this(SubjectIdentifierType.IssuerAndSerialNumber, certificate)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipient.#ctor(System.Security.Cryptography.Pkcs.SubjectIdentifierType,System.Security.Cryptography.X509Certificates.X509Certificate2)" /> constructor constructs an instance of the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> class by using the specified recipient identifier type and recipient certificate.</summary>
		/// <param name="recipientIdentifierType">A member of the <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> enumeration that specifies the type of the identifier of the recipient.</param>
		/// <param name="certificate">An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object that represents the recipient certificate.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public CmsRecipient(SubjectIdentifierType recipientIdentifierType, X509Certificate2 certificate)
		{
			Reset(recipientIdentifierType, certificate);
		}

		private void Reset(SubjectIdentifierType recipientIdentifierType, X509Certificate2 certificate)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			switch (recipientIdentifierType)
			{
			case SubjectIdentifierType.Unknown:
				recipientIdentifierType = SubjectIdentifierType.IssuerAndSerialNumber;
				break;
			case SubjectIdentifierType.SubjectKeyIdentifier:
				if (!PkcsUtils.CmsSupported())
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Not_Supported"));
				}
				break;
			default:
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Invalid_Subject_Identifier_Type"), recipientIdentifierType.ToString());
			case SubjectIdentifierType.IssuerAndSerialNumber:
				break;
			}
			m_recipientIdentifierType = recipientIdentifierType;
			m_certificate = certificate;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> class represents a set of <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> objects. <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> implements the <see cref="T:System.Collections.ICollection" /> interface.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CmsRecipientCollection : ICollection, IEnumerable
	{
		private ArrayList m_recipients;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsRecipientCollection.Item(System.Int32)" /> property retrieves the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object at the specified index in the collection.</summary>
		/// <param name="index">An <see cref="T:System.Int32" /> value that represents the index in the collection. The index is zero based.</param>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object at the specified index.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of an argument was outside the allowable range of values as defined by the called method.</exception>
		public CmsRecipient this[int index]
		{
			get
			{
				if (index < 0 || index >= m_recipients.Count)
				{
					throw new ArgumentOutOfRangeException("index", SecurityResources.GetResourceString("ArgumentOutOfRange_Index"));
				}
				return (CmsRecipient)m_recipients[index];
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsRecipientCollection.Count" /> property retrieves the number of items in the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</summary>
		/// <returns>An <see cref="T:System.Int32" /> value that represents the number of items in the collection.</returns>
		public int Count => m_recipients.Count;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsRecipientCollection.IsSynchronized" /> property retrieves whether access to the collection is synchronized, or thread safe. This property always returns <see langword="false" />, which means that the collection is not thread safe.</summary>
		/// <returns>A <see cref="T:System.Boolean" /> value of <see langword="false" />, which means that the collection is not thread safe.</returns>
		public bool IsSynchronized => false;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsRecipientCollection.SyncRoot" /> property retrieves an <see cref="T:System.Object" /> object used to synchronize access to the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</summary>
		/// <returns>An <see cref="T:System.Object" /> object that is used to synchronize access to the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</returns>
		public object SyncRoot => this;

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipientCollection.#ctor" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> class.</summary>
		public CmsRecipientCollection()
		{
			m_recipients = new ArrayList();
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipientCollection.#ctor(System.Security.Cryptography.Pkcs.CmsRecipient)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> class and adds the specified recipient.</summary>
		/// <param name="recipient">An instance of the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> class that represents the specified CMS/PKCS #7 recipient.</param>
		public CmsRecipientCollection(CmsRecipient recipient)
		{
			m_recipients = new ArrayList(1);
			m_recipients.Add(recipient);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipientCollection.#ctor(System.Security.Cryptography.Pkcs.SubjectIdentifierType,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> class and adds recipients based on the specified subject identifier and set of certificates that identify the recipients.</summary>
		/// <param name="recipientIdentifierType">A member of the <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> enumeration that specifies the type of subject identifier.</param>
		/// <param name="certificates">An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> collection that contains the certificates that identify the recipients.</param>
		public CmsRecipientCollection(SubjectIdentifierType recipientIdentifierType, X509Certificate2Collection certificates)
		{
			m_recipients = new ArrayList(certificates.Count);
			for (int i = 0; i < certificates.Count; i++)
			{
				m_recipients.Add(new CmsRecipient(recipientIdentifierType, certificates[i]));
			}
		}

		private CmsRecipientCollection(CmsRecipientCollection other)
		{
			m_recipients = new ArrayList(other.m_recipients.Count);
			foreach (CmsRecipient recipient in other.m_recipients)
			{
				m_recipients.Add(new CmsRecipient(recipient.RecipientIdentifierType, new X509Certificate2(recipient.Certificate)));
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipientCollection.Add(System.Security.Cryptography.Pkcs.CmsRecipient)" /> method adds a recipient to the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</summary>
		/// <param name="recipient">A <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object that represents the recipient to add to the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</param>
		/// <returns>If the method succeeds, the method returns an <see cref="T:System.Int32" /> value that represents the zero-based position where the recipient is to be inserted.  
		///  If the method fails, it throws an exception.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="recipient" /> is <see langword="null" />.</exception>
		public int Add(CmsRecipient recipient)
		{
			if (recipient == null)
			{
				throw new ArgumentNullException("recipient");
			}
			return m_recipients.Add(recipient);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipientCollection.Remove(System.Security.Cryptography.Pkcs.CmsRecipient)" /> method removes a recipient from the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</summary>
		/// <param name="recipient">A <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object that represents the recipient to remove from the collection.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="recipient" /> is <see langword="null" />.</exception>
		public void Remove(CmsRecipient recipient)
		{
			if (recipient == null)
			{
				throw new ArgumentNullException("recipient");
			}
			m_recipients.Remove(recipient);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipientCollection.GetEnumerator" /> method returns a <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientEnumerator" /> object for the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientEnumerator" /> object that can be used to enumerate the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</returns>
		public CmsRecipientEnumerator GetEnumerator()
		{
			return new CmsRecipientEnumerator(this);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipientCollection.System#Collections#IEnumerable#GetEnumerator" /> method returns a <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientEnumerator" /> object for the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientEnumerator" /> object that can be used to enumerate the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return new CmsRecipientEnumerator(this);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipientCollection.CopyTo(System.Array,System.Int32)" /> method copies the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection to an array.</summary>
		/// <param name="array">An <see cref="T:System.Array" /> object to which the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection is to be copied.</param>
		/// <param name="index">The zero-based index in <paramref name="array" /> where the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection is copied.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="array" /> is not large enough to hold the specified elements.  
		///
		/// -or-  
		///
		/// <paramref name="array" /> does not contain the proper number of dimensions.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="array" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="index" /> is outside the range of elements in <paramref name="array" />.</exception>
		public void CopyTo(Array array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (array.Rank != 1)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Arg_RankMultiDimNotSupported"));
			}
			if (index < 0 || index >= array.Length)
			{
				throw new ArgumentOutOfRangeException("index", SecurityResources.GetResourceString("ArgumentOutOfRange_Index"));
			}
			if (index + Count > array.Length)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Argument_InvalidOffLen"));
			}
			for (int i = 0; i < Count; i++)
			{
				array.SetValue(this[i], index);
				index++;
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipientCollection.CopyTo(System.Security.Cryptography.Pkcs.CmsRecipient[],System.Int32)" /> method copies the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection to a <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> array.</summary>
		/// <param name="array">An array of <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> objects where the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection is to be copied.</param>
		/// <param name="index">The zero-based index for the array of <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> objects in <paramref name="array" /> to which the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection is copied.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="array" /> is not large enough to hold the specified elements.  
		///
		/// -or-  
		///
		/// <paramref name="array" /> does not contain the proper number of dimensions.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="array" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="index" /> is outside the range of elements in <paramref name="array" />.</exception>
		public void CopyTo(CmsRecipient[] array, int index)
		{
			((ICollection)this).CopyTo((Array)array, index);
		}

		internal CmsRecipientCollection DeepCopy()
		{
			return new CmsRecipientCollection(this);
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientEnumerator" /> class provides enumeration functionality for the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection. <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientEnumerator" /> implements the <see cref="T:System.Collections.IEnumerator" /> interface.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CmsRecipientEnumerator : IEnumerator
	{
		private CmsRecipientCollection m_recipients;

		private int m_current;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsRecipientEnumerator.Current" /> property retrieves the current <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object from the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object that represents the current recipient in the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</returns>
		public CmsRecipient Current => m_recipients[m_current];

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsRecipientEnumerator.System#Collections#IEnumerator#Current" /> property retrieves the current <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object from the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object that represents the current recipient in the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</returns>
		object IEnumerator.Current => m_recipients[m_current];

		private CmsRecipientEnumerator()
		{
		}

		internal CmsRecipientEnumerator(CmsRecipientCollection recipients)
		{
			m_recipients = recipients;
			m_current = -1;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipientEnumerator.MoveNext" /> method advances the enumeration to the next <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object in the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</summary>
		/// <returns>
		///   <see langword="true" /> if the enumeration successfully moved to the next <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object; <see langword="false" /> if the enumeration moved past the last item in the enumeration.</returns>
		public bool MoveNext()
		{
			if (m_current == m_recipients.Count - 1)
			{
				return false;
			}
			m_current++;
			return true;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsRecipientEnumerator.Reset" /> method resets the enumeration to the first <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" /> object in the <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipientCollection" /> collection.</summary>
		public void Reset()
		{
			m_current = -1;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> class provides signing functionality.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CmsSigner
	{
		private SubjectIdentifierType m_signerIdentifierType;

		private X509Certificate2 m_certificate;

		private Oid m_digestAlgorithm;

		private CryptographicAttributeObjectCollection m_signedAttributes;

		private CryptographicAttributeObjectCollection m_unsignedAttributes;

		private X509Certificate2Collection m_certificates;

		private X509IncludeOption m_includeOption;

		private bool m_dummyCert;

		private const string Sha256Oid = "2.16.840.1.101.3.4.2.1";

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsSigner.SignerIdentifierType" /> property sets or retrieves the type of the identifier of the signer.</summary>
		/// <returns>A member of the <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> enumeration that specifies the type of the identifier of the signer.</returns>
		/// <exception cref="T:System.ArgumentException">One of the arguments provided to a method was not valid.</exception>
		public SubjectIdentifierType SignerIdentifierType
		{
			get
			{
				return m_signerIdentifierType;
			}
			set
			{
				if (value != SubjectIdentifierType.IssuerAndSerialNumber && value != SubjectIdentifierType.SubjectKeyIdentifier && value != SubjectIdentifierType.NoSignature)
				{
					throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Arg_EnumIllegalVal"), new object[1] { "value" }));
				}
				if (m_dummyCert && value != SubjectIdentifierType.SubjectKeyIdentifier)
				{
					throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Arg_EnumIllegalVal"), new object[1] { "value" }));
				}
				m_signerIdentifierType = value;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsSigner.Certificate" /> property sets or retrieves the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object that represents the signing certificate.</summary>
		/// <returns>An  <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object that represents the signing certificate.</returns>
		public X509Certificate2 Certificate
		{
			get
			{
				return m_certificate;
			}
			set
			{
				m_certificate = value;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsSigner.DigestAlgorithm" /> property sets or retrieves the <see cref="T:System.Security.Cryptography.Oid" /> that represents the hash algorithm used with the signature.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Oid" /> object that represents the hash algorithm used with the signature.</returns>
		public Oid DigestAlgorithm
		{
			get
			{
				return m_digestAlgorithm;
			}
			set
			{
				m_digestAlgorithm = value;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsSigner.SignedAttributes" /> property retrieves the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection of signed attributes to be associated with the resulting <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> content. Signed attributes are signed along with the specified content.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection that represents the signed attributes. If there are no signed attributes, the property is an empty collection.</returns>
		public CryptographicAttributeObjectCollection SignedAttributes => m_signedAttributes;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsSigner.UnsignedAttributes" /> property retrieves the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection of unsigned PKCS #9 attributes to be associated with the resulting <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> content. Unsigned attributes can be modified without invalidating the signature.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection that represents the unsigned attributes. If there are no unsigned attributes, the property is an empty collection.</returns>
		public CryptographicAttributeObjectCollection UnsignedAttributes => m_unsignedAttributes;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsSigner.Certificates" /> property retrieves the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> collection that contains certificates associated with the message to be signed.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> collection that represents the collection of  certificates associated with the message to be signed.</returns>
		public X509Certificate2Collection Certificates => m_certificates;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.CmsSigner.IncludeOption" /> property sets or retrieves the option that controls whether the root and entire chain associated with the signing certificate are included with the created CMS/PKCS #7 message.</summary>
		/// <returns>A member of the <see cref="T:System.Security.Cryptography.X509Certificates.X509IncludeOption" /> enumeration that specifies how much of the X509 certificate chain should be included in the <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> object. The <see cref="P:System.Security.Cryptography.Pkcs.CmsSigner.IncludeOption" /> property can be one of the following <see cref="T:System.Security.Cryptography.X509Certificates.X509IncludeOption" /> members.  
		///   Name  
		///
		///   Value  
		///
		///   Meaning  
		///
		///  <see cref="F:System.Security.Cryptography.X509Certificates.X509IncludeOption.None" /> 0  
		///
		///   The certificate chain is not included.  
		///
		///  <see cref="F:System.Security.Cryptography.X509Certificates.X509IncludeOption.ExcludeRoot" /> 1  
		///
		///   The certificate chain, except for the root certificate, is included.  
		///
		///  <see cref="F:System.Security.Cryptography.X509Certificates.X509IncludeOption.EndCertOnly" /> 2  
		///
		///   Only the end certificate is included.  
		///
		///  <see cref="F:System.Security.Cryptography.X509Certificates.X509IncludeOption.WholeChain" /> 3  
		///
		///   The certificate chain, including the root certificate, is included.</returns>
		/// <exception cref="T:System.ArgumentException">One of the arguments provided to a method was not valid.</exception>
		public X509IncludeOption IncludeOption
		{
			get
			{
				return m_includeOption;
			}
			set
			{
				if (value < X509IncludeOption.None || value > X509IncludeOption.WholeChain)
				{
					throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, SecurityResources.GetResourceString("Arg_EnumIllegalVal"), new object[1] { "value" }));
				}
				m_includeOption = value;
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsSigner.#ctor" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> class by using a default subject identifier type.</summary>
		public CmsSigner()
			: this(SubjectIdentifierType.IssuerAndSerialNumber, null)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsSigner.#ctor(System.Security.Cryptography.Pkcs.SubjectIdentifierType)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> class with the specified subject identifier type.</summary>
		/// <param name="signerIdentifierType">A member of the <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> enumeration that specifies the signer identifier type.</param>
		public CmsSigner(SubjectIdentifierType signerIdentifierType)
			: this(signerIdentifierType, null)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsSigner.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> class with the specified signing certificate.</summary>
		/// <param name="certificate">An    <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object that represents the signing certificate.</param>
		public CmsSigner(X509Certificate2 certificate)
			: this(SubjectIdentifierType.IssuerAndSerialNumber, certificate)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsSigner.#ctor(System.Security.Cryptography.CspParameters)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> class with the specified cryptographic service provider (CSP) parameters. <see cref="M:System.Security.Cryptography.Pkcs.CmsSigner.#ctor(System.Security.Cryptography.CspParameters)" /> is useful when you know the specific CSP and private key to use for signing.</summary>
		/// <param name="parameters">A <see cref="T:System.Security.Cryptography.CspParameters" /> object that represents the set of CSP parameters to use.</param>
		[SecuritySafeCritical]
		public CmsSigner(CspParameters parameters)
			: this(SubjectIdentifierType.SubjectKeyIdentifier, PkcsUtils.CreateDummyCertificate(parameters))
		{
			m_dummyCert = true;
			IncludeOption = X509IncludeOption.None;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.CmsSigner.#ctor(System.Security.Cryptography.Pkcs.SubjectIdentifierType,System.Security.Cryptography.X509Certificates.X509Certificate2)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> class with the specified signer identifier type and signing certificate.</summary>
		/// <param name="signerIdentifierType">A member of the <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> enumeration that specifies the signer identifier type.</param>
		/// <param name="certificate">An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object that represents the signing certificate.</param>
		public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate)
		{
			switch (signerIdentifierType)
			{
			case SubjectIdentifierType.Unknown:
				SignerIdentifierType = SubjectIdentifierType.IssuerAndSerialNumber;
				IncludeOption = X509IncludeOption.ExcludeRoot;
				break;
			case SubjectIdentifierType.IssuerAndSerialNumber:
				SignerIdentifierType = signerIdentifierType;
				IncludeOption = X509IncludeOption.ExcludeRoot;
				break;
			case SubjectIdentifierType.SubjectKeyIdentifier:
				SignerIdentifierType = signerIdentifierType;
				IncludeOption = X509IncludeOption.ExcludeRoot;
				break;
			case SubjectIdentifierType.NoSignature:
				SignerIdentifierType = signerIdentifierType;
				IncludeOption = X509IncludeOption.None;
				break;
			default:
				SignerIdentifierType = SubjectIdentifierType.IssuerAndSerialNumber;
				IncludeOption = X509IncludeOption.ExcludeRoot;
				break;
			}
			Certificate = certificate;
			string oidValue = (LocalAppContextSwitches.CmsUseInsecureHashAlgorithms ? "1.3.14.3.2.26" : "2.16.840.1.101.3.4.2.1");
			DigestAlgorithm = Oid.FromOidValue(oidValue, OidGroup.HashAlgorithm);
			m_signedAttributes = new CryptographicAttributeObjectCollection();
			m_unsignedAttributes = new CryptographicAttributeObjectCollection();
			m_certificates = new X509Certificate2Collection();
		}
	}
	/// <summary>Represents an attribute used for CMS/PKCS #7 and PKCS #9 operations.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class Pkcs9AttributeObject : AsnEncodedData
	{
		/// <summary>Gets an <see cref="T:System.Security.Cryptography.Oid" /> object that represents the type of attribute associated with this <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9AttributeObject" /> object.</summary>
		/// <returns>An object that represents the type of attribute associated with this <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9AttributeObject" /> object.</returns>
		public new Oid Oid => base.Oid;

		internal Pkcs9AttributeObject(Oid oid)
		{
			base.Oid = oid;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9AttributeObject" /> class.</summary>
		public Pkcs9AttributeObject()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9AttributeObject" /> class using a specified string representation of an object identifier (OID) as the attribute type and a specified ASN.1 encoded data as the attribute value.</summary>
		/// <param name="oid">The string representation of an OID that represents the PKCS #9 attribute type.</param>
		/// <param name="encodedData">An array of byte values that contains the PKCS #9 attribute value.</param>
		public Pkcs9AttributeObject(string oid, byte[] encodedData)
			: this(new AsnEncodedData(oid, encodedData))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9AttributeObject" /> class using a specified <see cref="T:System.Security.Cryptography.Oid" /> object as the attribute type and a specified ASN.1 encoded data as the attribute value.</summary>
		/// <param name="oid">An object that represents the PKCS #9 attribute type.</param>
		/// <param name="encodedData">An array of byte values that represents the PKCS #9 attribute value.</param>
		public Pkcs9AttributeObject(Oid oid, byte[] encodedData)
			: this(new AsnEncodedData(oid, encodedData))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9AttributeObject" /> class using a specified <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object as its attribute type and value.</summary>
		/// <param name="asnEncodedData">An object that contains the PKCS #9 attribute type and value to use.</param>
		/// <exception cref="T:System.ArgumentException">The length of the <paramref name="Value" /> member of the <paramref name="Oid" /> member of <paramref name="asnEncodedData" /> is zero.</exception>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="Oid" /> member of <paramref name="asnEncodedData" /> is <see langword="null" />.  
		///  -or-  
		///  The <paramref name="Value" /> member of the <paramref name="Oid" /> member of <paramref name="asnEncodedData" /> is <see langword="null" />.</exception>
		public Pkcs9AttributeObject(AsnEncodedData asnEncodedData)
			: base(asnEncodedData)
		{
			if (asnEncodedData.Oid == null)
			{
				throw new ArgumentNullException("asnEncodedData.Oid");
			}
			string value = base.Oid.Value;
			if (value == null)
			{
				throw new ArgumentNullException("oid.Value");
			}
			if (value.Length == 0)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Arg_EmptyOrNullString"), "oid.Value");
			}
		}

		/// <summary>Copies a PKCS #9 attribute type and value for this <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9AttributeObject" /> from the specified <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object.</summary>
		/// <param name="asnEncodedData">An object that contains the PKCS #9 attribute type and value to use.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="asnEncodeData" /> does not represent a compatible attribute type.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="asnEncodedData" /> is <see langword="null" />.</exception>
		public override void CopyFrom(AsnEncodedData asnEncodedData)
		{
			if (asnEncodedData == null)
			{
				throw new ArgumentNullException("asnEncodedData");
			}
			if (!(asnEncodedData is Pkcs9AttributeObject))
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Cryptography_Pkcs9_AttributeMismatch"));
			}
			base.CopyFrom(asnEncodedData);
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9SigningTime" /> class defines the signing date and time of a signature. A <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9SigningTime" /> object can  be used as an authenticated attribute of a <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> object when an authenticated date and time are to accompany a digital signature.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class Pkcs9SigningTime : Pkcs9AttributeObject
	{
		private DateTime m_signingTime;

		private bool m_decoded;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.Pkcs9SigningTime.SigningTime" /> property retrieves a <see cref="T:System.DateTime" /> structure that represents the date and time that the message was signed.</summary>
		/// <returns>A <see cref="T:System.DateTime" /> structure that contains the date and time the document was signed.</returns>
		public DateTime SigningTime
		{
			get
			{
				if (!m_decoded && base.RawData != null)
				{
					Decode();
				}
				return m_signingTime;
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.Pkcs9SigningTime.#ctor" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9SigningTime" /> class.</summary>
		public Pkcs9SigningTime()
			: this(DateTime.Now)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.Pkcs9SigningTime.#ctor(System.DateTime)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9SigningTime" /> class by using the specified signing date and time.</summary>
		/// <param name="signingTime">A <see cref="T:System.DateTime" /> structure that represents the signing date and time of the signature.</param>
		public Pkcs9SigningTime(DateTime signingTime)
			: base("1.2.840.113549.1.9.5", Encode(signingTime))
		{
			m_signingTime = signingTime;
			m_decoded = true;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.Pkcs9SigningTime.#ctor(System.Byte[])" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9SigningTime" /> class by using the specified array of byte values as the encoded signing date and time of the content of a CMS/PKCS #7 message.</summary>
		/// <param name="encodedSigningTime">An array of byte values that specifies the encoded signing date and time of the CMS/PKCS #7 message.</param>
		public Pkcs9SigningTime(byte[] encodedSigningTime)
			: base("1.2.840.113549.1.9.5", encodedSigningTime)
		{
		}

		/// <summary>Copies information from a <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object.</summary>
		/// <param name="asnEncodedData">The <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object from which to copy information.</param>
		public override void CopyFrom(AsnEncodedData asnEncodedData)
		{
			base.CopyFrom(asnEncodedData);
			m_decoded = false;
		}

		[SecuritySafeCritical]
		private void Decode()
		{
			uint cbDecodedValue = 0u;
			SafeLocalAllocHandle decodedValue = null;
			if (!CAPI.DecodeObject(new IntPtr(17L), base.RawData, out decodedValue, out cbDecodedValue))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			long fileTime = Marshal.ReadInt64(decodedValue.DangerousGetHandle());
			decodedValue.Dispose();
			m_signingTime = DateTime.FromFileTimeUtc(fileTime);
			m_decoded = true;
		}

		[SecuritySafeCritical]
		private static byte[] Encode(DateTime signingTime)
		{
			long val = signingTime.ToFileTimeUtc();
			SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(long))));
			Marshal.WriteInt64(safeLocalAllocHandle.DangerousGetHandle(), val);
			byte[] encodedData = new byte[0];
			if (!CAPI.EncodeObject("1.2.840.113549.1.9.5", safeLocalAllocHandle.DangerousGetHandle(), out encodedData))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			safeLocalAllocHandle.Dispose();
			return encodedData;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9DocumentName" /> class defines the name of a CMS/PKCS #7 message.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class Pkcs9DocumentName : Pkcs9AttributeObject
	{
		private string m_documentName;

		private bool m_decoded;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.Pkcs9DocumentName.DocumentName" /> property retrieves the document name.</summary>
		/// <returns>A <see cref="T:System.String" /> object that contains the document name.</returns>
		public string DocumentName
		{
			get
			{
				if (!m_decoded && base.RawData != null)
				{
					Decode();
				}
				return m_documentName;
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.Pkcs9DocumentName.#ctor" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9DocumentName" /> class.</summary>
		public Pkcs9DocumentName()
			: base(new Oid("1.3.6.1.4.1.311.88.2.1"))
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.Pkcs9DocumentName.#ctor(System.String)" /> constructor creates an instance of the  <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9DocumentName" /> class by using the specified name for the CMS/PKCS #7 message.</summary>
		/// <param name="documentName">A  <see cref="T:System.String" /> object that specifies the name for the CMS/PKCS #7 message.</param>
		public Pkcs9DocumentName(string documentName)
			: base("1.3.6.1.4.1.311.88.2.1", Encode(documentName))
		{
			m_documentName = documentName;
			m_decoded = true;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.Pkcs9DocumentName.#ctor(System.Byte[])" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9DocumentName" /> class by using the specified array of byte values as the encoded name of the content of a CMS/PKCS #7 message.</summary>
		/// <param name="encodedDocumentName">An array of byte values that specifies the encoded name of the CMS/PKCS #7 message.</param>
		public Pkcs9DocumentName(byte[] encodedDocumentName)
			: base("1.3.6.1.4.1.311.88.2.1", encodedDocumentName)
		{
		}

		/// <summary>Copies information from an <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object.</summary>
		/// <param name="asnEncodedData">The <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object from which to copy information.</param>
		public override void CopyFrom(AsnEncodedData asnEncodedData)
		{
			base.CopyFrom(asnEncodedData);
			m_decoded = false;
		}

		private void Decode()
		{
			m_documentName = PkcsUtils.DecodeOctetString(base.RawData);
			m_decoded = true;
		}

		private static byte[] Encode(string documentName)
		{
			if (string.IsNullOrEmpty(documentName))
			{
				throw new ArgumentNullException("documentName");
			}
			return PkcsUtils.EncodeOctetString(documentName);
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription" /> class defines the description of the content of a CMS/PKCS #7 message.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class Pkcs9DocumentDescription : Pkcs9AttributeObject
	{
		private string m_documentDescription;

		private bool m_decoded;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription.DocumentDescription" /> property retrieves the document description.</summary>
		/// <returns>A <see cref="T:System.String" /> object that contains the document description.</returns>
		public string DocumentDescription
		{
			get
			{
				if (!m_decoded && base.RawData != null)
				{
					Decode();
				}
				return m_documentDescription;
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription.#ctor" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription" /> class.</summary>
		public Pkcs9DocumentDescription()
			: base(new Oid("1.3.6.1.4.1.311.88.2.2"))
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription.#ctor(System.String)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription" /> class by using the specified description of the content of a CMS/PKCS #7 message.</summary>
		/// <param name="documentDescription">An instance of the <see cref="T:System.String" /> class that specifies the description for the CMS/PKCS #7 message.</param>
		public Pkcs9DocumentDescription(string documentDescription)
			: base("1.3.6.1.4.1.311.88.2.2", Encode(documentDescription))
		{
			m_documentDescription = documentDescription;
			m_decoded = true;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription.#ctor(System.Byte[])" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription" /> class by using the specified array of byte values as the encoded description of the content of a CMS/PKCS #7 message.</summary>
		/// <param name="encodedDocumentDescription">An array of byte values that specifies the encoded description of the CMS/PKCS #7 message.</param>
		public Pkcs9DocumentDescription(byte[] encodedDocumentDescription)
			: base("1.3.6.1.4.1.311.88.2.2", encodedDocumentDescription)
		{
		}

		/// <summary>Copies information from an <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object.</summary>
		/// <param name="asnEncodedData">The <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object from which to copy information.</param>
		public override void CopyFrom(AsnEncodedData asnEncodedData)
		{
			base.CopyFrom(asnEncodedData);
			m_decoded = false;
		}

		private void Decode()
		{
			m_documentDescription = PkcsUtils.DecodeOctetString(base.RawData);
			m_decoded = true;
		}

		private static byte[] Encode(string documentDescription)
		{
			if (string.IsNullOrEmpty(documentDescription))
			{
				throw new ArgumentNullException("documentDescription");
			}
			return PkcsUtils.EncodeOctetString(documentDescription);
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9ContentType" /> class defines the type of the content of a CMS/PKCS #7 message.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class Pkcs9ContentType : Pkcs9AttributeObject
	{
		private Oid m_contentType;

		private bool m_decoded;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.Pkcs9ContentType.ContentType" /> property gets an <see cref="T:System.Security.Cryptography.Oid" /> object that contains the content type.</summary>
		/// <returns>An  <see cref="T:System.Security.Cryptography.Oid" /> object that contains the content type.</returns>
		public Oid ContentType
		{
			get
			{
				if (!m_decoded && base.RawData != null)
				{
					Decode();
				}
				return m_contentType;
			}
		}

		internal Pkcs9ContentType(byte[] encodedContentType)
			: base(Oid.FromOidValue("1.2.840.113549.1.9.3", OidGroup.ExtensionOrAttribute), encodedContentType)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.Pkcs9ContentType.#ctor" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9ContentType" /> class.</summary>
		public Pkcs9ContentType()
			: base(Oid.FromOidValue("1.2.840.113549.1.9.3", OidGroup.ExtensionOrAttribute))
		{
		}

		/// <summary>Copies information from an <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object.</summary>
		/// <param name="asnEncodedData">The <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object from which to copy information.</param>
		public override void CopyFrom(AsnEncodedData asnEncodedData)
		{
			base.CopyFrom(asnEncodedData);
			m_decoded = false;
		}

		private void Decode()
		{
			if (base.RawData.Length < 2 || base.RawData[1] != base.RawData.Length - 2)
			{
				throw new CryptographicException(-2146885630);
			}
			if (base.RawData[0] != 6)
			{
				throw new CryptographicException(-2146881269);
			}
			m_contentType = new Oid(PkcsUtils.DecodeObjectIdentifier(base.RawData, 2));
			m_decoded = true;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9MessageDigest" /> class defines the message digest of a CMS/PKCS #7 message.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class Pkcs9MessageDigest : Pkcs9AttributeObject
	{
		private byte[] m_messageDigest;

		private bool m_decoded;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.Pkcs9MessageDigest.MessageDigest" /> property retrieves the message digest.</summary>
		/// <returns>An array of byte values that contains the message digest.</returns>
		public byte[] MessageDigest
		{
			get
			{
				if (!m_decoded && base.RawData != null)
				{
					Decode();
				}
				return m_messageDigest;
			}
		}

		internal Pkcs9MessageDigest(byte[] encodedMessageDigest)
			: base(Oid.FromOidValue("1.2.840.113549.1.9.4", OidGroup.ExtensionOrAttribute), encodedMessageDigest)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.Pkcs9MessageDigest.#ctor" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.Pkcs9MessageDigest" /> class.</summary>
		public Pkcs9MessageDigest()
			: base(Oid.FromOidValue("1.2.840.113549.1.9.4", OidGroup.ExtensionOrAttribute))
		{
		}

		/// <summary>Copies information from an <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object.</summary>
		/// <param name="asnEncodedData">The <see cref="T:System.Security.Cryptography.AsnEncodedData" /> object from which to copy information.</param>
		public override void CopyFrom(AsnEncodedData asnEncodedData)
		{
			base.CopyFrom(asnEncodedData);
			m_decoded = false;
		}

		private void Decode()
		{
			m_messageDigest = PkcsUtils.DecodeOctetBytes(base.RawData);
			m_decoded = true;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoType" /> enumeration defines the types of recipient information.</summary>
	public enum RecipientInfoType
	{
		/// <summary>The recipient information type is unknown.</summary>
		Unknown,
		/// <summary>Key transport recipient information.</summary>
		KeyTransport,
		/// <summary>Key agreement recipient information.</summary>
		KeyAgreement
	}
	internal enum RecipientSubType
	{
		Unknown,
		Pkcs7KeyTransport,
		CmsKeyTransport,
		CertIdKeyAgreement,
		PublicKeyAgreement
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> class represents information about a CMS/PKCS #7 message recipient. The <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> class is an abstract class inherited by the <see cref="T:System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo" /> and <see cref="T:System.Security.Cryptography.Pkcs.KeyTransRecipientInfo" /> classes.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class RecipientInfo
	{
		private RecipientInfoType m_recipentInfoType;

		private RecipientSubType m_recipientSubType;

		[SecurityCritical]
		private SafeLocalAllocHandle m_pCmsgRecipientInfo;

		private object m_cmsgRecipientInfo;

		private uint m_index;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.RecipientInfo.Type" /> property retrieves the type of the recipient. The type of the recipient determines which of two major protocols is used to establish a key between the originator and the recipient of a CMS/PKCS #7 message.</summary>
		/// <returns>A value of the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoType" /> enumeration that defines the type of the recipient.</returns>
		public RecipientInfoType Type => m_recipentInfoType;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.RecipientInfo.Version" /> abstract property retrieves the version of the recipient information. Derived classes automatically set this property for their objects, and the value indicates whether it is using PKCS #7 or Cryptographic Message Syntax (CMS) to protect messages. The version also implies whether the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object establishes a cryptographic key by a key agreement algorithm or a key transport algorithm.</summary>
		/// <returns>An <see cref="T:System.Int32" /> value that represents the version of the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object.</returns>
		public abstract int Version { get; }

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.RecipientInfo.RecipientIdentifier" /> abstract property retrieves the identifier of the recipient.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifier" /> object that contains the identifier of the recipient.</returns>
		public abstract SubjectIdentifier RecipientIdentifier { get; }

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.RecipientInfo.KeyEncryptionAlgorithm" /> abstract property retrieves the algorithm used to perform the key establishment.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Pkcs.AlgorithmIdentifier" /> object that contains the value of the algorithm used to establish the key between the originator and recipient of the CMS/PKCS #7 message.</returns>
		public abstract AlgorithmIdentifier KeyEncryptionAlgorithm { get; }

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.RecipientInfo.EncryptedKey" /> abstract property retrieves the encrypted recipient keying material.</summary>
		/// <returns>An array of byte values that contain the encrypted recipient keying material.</returns>
		public abstract byte[] EncryptedKey { get; }

		internal RecipientSubType SubType => m_recipientSubType;

		internal SafeLocalAllocHandle pCmsgRecipientInfo
		{
			[SecurityCritical]
			get
			{
				return m_pCmsgRecipientInfo;
			}
		}

		internal object CmsgRecipientInfo => m_cmsgRecipientInfo;

		internal uint Index => m_index;

		internal RecipientInfo()
		{
		}

		[SecurityCritical]
		internal RecipientInfo(RecipientInfoType recipientInfoType, RecipientSubType recipientSubType, SafeLocalAllocHandle pCmsgRecipientInfo, object cmsgRecipientInfo, uint index)
		{
			if (recipientInfoType < RecipientInfoType.Unknown || recipientInfoType > RecipientInfoType.KeyAgreement)
			{
				recipientInfoType = RecipientInfoType.Unknown;
			}
			if (recipientSubType < RecipientSubType.Unknown || recipientSubType > RecipientSubType.PublicKeyAgreement)
			{
				recipientSubType = RecipientSubType.Unknown;
			}
			m_recipentInfoType = recipientInfoType;
			m_recipientSubType = recipientSubType;
			m_pCmsgRecipientInfo = pCmsgRecipientInfo;
			m_cmsgRecipientInfo = cmsgRecipientInfo;
			m_index = index;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.KeyTransRecipientInfo" /> class defines key transport recipient information.        Key transport algorithms typically use the RSA algorithm, in which  an originator establishes a shared cryptographic key with a recipient by generating that key and  then transporting it to the recipient. This is in contrast to key agreement algorithms, in which the two parties that will be using a cryptographic key both take part in its generation, thereby mutually agreeing to that key.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class KeyTransRecipientInfo : RecipientInfo
	{
		private int m_version;

		private SubjectIdentifier m_recipientIdentifier;

		private AlgorithmIdentifier m_encryptionAlgorithm;

		private byte[] m_encryptedKey;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.KeyTransRecipientInfo.Version" /> property retrieves the version of the key transport recipient. The version of the key transport recipient is automatically set for  objects in this class, and the value  implies that the recipient is taking part in a key transport algorithm.</summary>
		/// <returns>An int value that represents the version of the key transport <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object.</returns>
		public override int Version => m_version;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.KeyTransRecipientInfo.RecipientIdentifier" /> property retrieves the subject identifier associated with the encrypted content.</summary>
		/// <returns>A   <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifier" /> object that  stores the identifier of the recipient taking part in the key transport.</returns>
		public override SubjectIdentifier RecipientIdentifier
		{
			[SecuritySafeCritical]
			get
			{
				if (m_recipientIdentifier == null)
				{
					if (base.SubType == RecipientSubType.CmsKeyTransport)
					{
						m_recipientIdentifier = new SubjectIdentifier(((CAPI.CMSG_KEY_TRANS_RECIPIENT_INFO)base.CmsgRecipientInfo).RecipientId);
					}
					else
					{
						CAPI.CERT_INFO certInfo = (CAPI.CERT_INFO)base.CmsgRecipientInfo;
						m_recipientIdentifier = new SubjectIdentifier(certInfo);
					}
				}
				return m_recipientIdentifier;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.KeyTransRecipientInfo.KeyEncryptionAlgorithm" /> property retrieves the key encryption algorithm used to encrypt the content encryption key.</summary>
		/// <returns>An  <see cref="T:System.Security.Cryptography.Pkcs.AlgorithmIdentifier" /> object that stores the key encryption algorithm identifier.</returns>
		public override AlgorithmIdentifier KeyEncryptionAlgorithm
		{
			[SecuritySafeCritical]
			get
			{
				if (m_encryptionAlgorithm == null)
				{
					if (base.SubType == RecipientSubType.CmsKeyTransport)
					{
						m_encryptionAlgorithm = new AlgorithmIdentifier(((CAPI.CMSG_KEY_TRANS_RECIPIENT_INFO)base.CmsgRecipientInfo).KeyEncryptionAlgorithm);
					}
					else
					{
						m_encryptionAlgorithm = new AlgorithmIdentifier(((CAPI.CERT_INFO)base.CmsgRecipientInfo).SignatureAlgorithm);
					}
				}
				return m_encryptionAlgorithm;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.KeyTransRecipientInfo.EncryptedKey" /> property retrieves the encrypted key for this key transport recipient.</summary>
		/// <returns>An array of byte values that represents the encrypted key.</returns>
		public override byte[] EncryptedKey
		{
			[SecuritySafeCritical]
			get
			{
				if (m_encryptedKey.Length == 0 && base.SubType == RecipientSubType.CmsKeyTransport)
				{
					CAPI.CMSG_KEY_TRANS_RECIPIENT_INFO cMSG_KEY_TRANS_RECIPIENT_INFO = (CAPI.CMSG_KEY_TRANS_RECIPIENT_INFO)base.CmsgRecipientInfo;
					if (cMSG_KEY_TRANS_RECIPIENT_INFO.EncryptedKey.cbData != 0)
					{
						m_encryptedKey = new byte[cMSG_KEY_TRANS_RECIPIENT_INFO.EncryptedKey.cbData];
						Marshal.Copy(cMSG_KEY_TRANS_RECIPIENT_INFO.EncryptedKey.pbData, m_encryptedKey, 0, m_encryptedKey.Length);
					}
				}
				return m_encryptedKey;
			}
		}

		[SecurityCritical]
		internal unsafe KeyTransRecipientInfo(SafeLocalAllocHandle pRecipientInfo, CAPI.CERT_INFO certInfo, uint index)
			: base(RecipientInfoType.KeyTransport, RecipientSubType.Pkcs7KeyTransport, pRecipientInfo, certInfo, index)
		{
			int version = 2;
			byte* ptr = (byte*)(void*)certInfo.SerialNumber.pbData;
			for (int i = 0; i < certInfo.SerialNumber.cbData; i++)
			{
				if (*(ptr++) != 0)
				{
					version = 0;
					break;
				}
			}
			Reset(version);
		}

		[SecurityCritical]
		internal KeyTransRecipientInfo(SafeLocalAllocHandle pRecipientInfo, CAPI.CMSG_KEY_TRANS_RECIPIENT_INFO keyTrans, uint index)
			: base(RecipientInfoType.KeyTransport, RecipientSubType.CmsKeyTransport, pRecipientInfo, keyTrans, index)
		{
			Reset((int)keyTrans.dwVersion);
		}

		private void Reset(int version)
		{
			m_version = version;
			m_recipientIdentifier = null;
			m_encryptionAlgorithm = null;
			m_encryptedKey = new byte[0];
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo" /> class defines key agreement recipient information. Key agreement algorithms typically use the Diffie-Hellman key agreement algorithm, in which the two parties that establish a shared cryptographic key both take part in its generation and, by definition, agree on that key. This is in contrast to key transport algorithms, in which one party generates the key unilaterally and sends, or transports it, to the other party.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class KeyAgreeRecipientInfo : RecipientInfo
	{
		private CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_INFO m_encryptedKeyInfo;

		private uint m_originatorChoice;

		private int m_version;

		private SubjectIdentifierOrKey m_originatorIdentifier;

		private byte[] m_userKeyMaterial;

		private AlgorithmIdentifier m_encryptionAlgorithm;

		private SubjectIdentifier m_recipientIdentifier;

		private byte[] m_encryptedKey;

		private DateTime m_date;

		private CryptographicAttributeObject m_otherKeyAttribute;

		private uint m_subIndex;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo.Version" /> property retrieves the version of the key agreement recipient. This is automatically set for  objects in this class, and the value  implies that the recipient is taking part in a key agreement algorithm.</summary>
		/// <returns>The version of the <see cref="T:System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo" /> object.</returns>
		public override int Version => m_version;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo.OriginatorIdentifierOrKey" /> property retrieves information about the originator of the key agreement for key agreement algorithms that warrant it.</summary>
		/// <returns>An object that contains information about the originator of the key agreement.</returns>
		public SubjectIdentifierOrKey OriginatorIdentifierOrKey
		{
			[SecuritySafeCritical]
			get
			{
				if (m_originatorIdentifier == null)
				{
					if (m_originatorChoice == 1)
					{
						m_originatorIdentifier = new SubjectIdentifierOrKey(((CAPI.CMSG_KEY_AGREE_CERT_ID_RECIPIENT_INFO)base.CmsgRecipientInfo).OriginatorCertId);
					}
					else
					{
						m_originatorIdentifier = new SubjectIdentifierOrKey(((CAPI.CMSG_KEY_AGREE_PUBLIC_KEY_RECIPIENT_INFO)base.CmsgRecipientInfo).OriginatorPublicKeyInfo);
					}
				}
				return m_originatorIdentifier;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo.RecipientIdentifier" /> property retrieves the identifier of the recipient.</summary>
		/// <returns>The identifier of the recipient.</returns>
		public override SubjectIdentifier RecipientIdentifier
		{
			[SecuritySafeCritical]
			get
			{
				if (m_recipientIdentifier == null)
				{
					m_recipientIdentifier = new SubjectIdentifier(m_encryptedKeyInfo.RecipientId);
				}
				return m_recipientIdentifier;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo.Date" /> property retrieves the date and time of the start of the key agreement protocol by the originator.</summary>
		/// <returns>The date and time of the start of the key agreement protocol by the originator.</returns>
		/// <exception cref="T:System.InvalidOperationException">The recipient identifier type is not a subject key identifier.</exception>
		public DateTime Date
		{
			get
			{
				if (m_date == DateTime.MinValue)
				{
					if (RecipientIdentifier.Type != SubjectIdentifierType.SubjectKeyIdentifier)
					{
						throw new InvalidOperationException(SecurityResources.GetResourceString("Cryptography_Cms_Key_Agree_Date_Not_Available"));
					}
					long fileTime = (long)(((ulong)(uint)m_encryptedKeyInfo.Date.dwHighDateTime << 32) | (uint)m_encryptedKeyInfo.Date.dwLowDateTime);
					m_date = DateTime.FromFileTimeUtc(fileTime);
				}
				return m_date;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo.OtherKeyAttribute" /> property retrieves attributes of the keying material.</summary>
		/// <returns>The attributes of the keying material.</returns>
		/// <exception cref="T:System.InvalidOperationException">The recipient identifier type is not a subject key identifier.</exception>
		public CryptographicAttributeObject OtherKeyAttribute
		{
			[SecuritySafeCritical]
			get
			{
				if (m_otherKeyAttribute == null)
				{
					if (RecipientIdentifier.Type != SubjectIdentifierType.SubjectKeyIdentifier)
					{
						throw new InvalidOperationException(SecurityResources.GetResourceString("Cryptography_Cms_Key_Agree_Other_Key_Attribute_Not_Available"));
					}
					if (m_encryptedKeyInfo.pOtherAttr != IntPtr.Zero)
					{
						CAPI.CRYPT_ATTRIBUTE_TYPE_VALUE cryptAttribute = (CAPI.CRYPT_ATTRIBUTE_TYPE_VALUE)Marshal.PtrToStructure(m_encryptedKeyInfo.pOtherAttr, typeof(CAPI.CRYPT_ATTRIBUTE_TYPE_VALUE));
						m_otherKeyAttribute = new CryptographicAttributeObject(cryptAttribute);
					}
				}
				return m_otherKeyAttribute;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo.KeyEncryptionAlgorithm" /> property retrieves the algorithm used to perform the key agreement.</summary>
		/// <returns>The value of the algorithm used to perform the key agreement.</returns>
		public override AlgorithmIdentifier KeyEncryptionAlgorithm
		{
			[SecuritySafeCritical]
			get
			{
				if (m_encryptionAlgorithm == null)
				{
					if (m_originatorChoice == 1)
					{
						m_encryptionAlgorithm = new AlgorithmIdentifier(((CAPI.CMSG_KEY_AGREE_CERT_ID_RECIPIENT_INFO)base.CmsgRecipientInfo).KeyEncryptionAlgorithm);
					}
					else
					{
						m_encryptionAlgorithm = new AlgorithmIdentifier(((CAPI.CMSG_KEY_AGREE_PUBLIC_KEY_RECIPIENT_INFO)base.CmsgRecipientInfo).KeyEncryptionAlgorithm);
					}
				}
				return m_encryptionAlgorithm;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo.EncryptedKey" /> property retrieves the encrypted recipient keying material.</summary>
		/// <returns>An array of byte values that contain the encrypted recipient keying material.</returns>
		public override byte[] EncryptedKey
		{
			[SecuritySafeCritical]
			get
			{
				if (m_encryptedKey.Length == 0 && m_encryptedKeyInfo.EncryptedKey.cbData != 0)
				{
					m_encryptedKey = new byte[m_encryptedKeyInfo.EncryptedKey.cbData];
					Marshal.Copy(m_encryptedKeyInfo.EncryptedKey.pbData, m_encryptedKey, 0, m_encryptedKey.Length);
				}
				return m_encryptedKey;
			}
		}

		internal CAPI.CERT_ID RecipientId => m_encryptedKeyInfo.RecipientId;

		internal uint SubIndex => m_subIndex;

		private KeyAgreeRecipientInfo()
		{
		}

		[SecurityCritical]
		internal KeyAgreeRecipientInfo(SafeLocalAllocHandle pRecipientInfo, CAPI.CMSG_KEY_AGREE_CERT_ID_RECIPIENT_INFO certIdRecipient, uint index, uint subIndex)
			: base(RecipientInfoType.KeyAgreement, RecipientSubType.CertIdKeyAgreement, pRecipientInfo, certIdRecipient, index)
		{
			checked
			{
				IntPtr ptr = Marshal.ReadIntPtr(new IntPtr((long)certIdRecipient.rgpRecipientEncryptedKeys + unchecked((long)subIndex) * unchecked((long)Marshal.SizeOf(typeof(IntPtr)))));
				CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_INFO encryptedKeyInfo = (CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_INFO)Marshal.PtrToStructure(ptr, typeof(CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_INFO));
				Reset(1u, certIdRecipient.dwVersion, encryptedKeyInfo, subIndex);
			}
		}

		[SecurityCritical]
		internal KeyAgreeRecipientInfo(SafeLocalAllocHandle pRecipientInfo, CAPI.CMSG_KEY_AGREE_PUBLIC_KEY_RECIPIENT_INFO publicKeyRecipient, uint index, uint subIndex)
			: base(RecipientInfoType.KeyAgreement, RecipientSubType.PublicKeyAgreement, pRecipientInfo, publicKeyRecipient, index)
		{
			checked
			{
				IntPtr ptr = Marshal.ReadIntPtr(new IntPtr((long)publicKeyRecipient.rgpRecipientEncryptedKeys + unchecked((long)subIndex) * unchecked((long)Marshal.SizeOf(typeof(IntPtr)))));
				CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_INFO encryptedKeyInfo = (CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_INFO)Marshal.PtrToStructure(ptr, typeof(CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_INFO));
				Reset(2u, publicKeyRecipient.dwVersion, encryptedKeyInfo, subIndex);
			}
		}

		private void Reset(uint originatorChoice, uint version, CAPI.CMSG_RECIPIENT_ENCRYPTED_KEY_INFO encryptedKeyInfo, uint subIndex)
		{
			m_encryptedKeyInfo = encryptedKeyInfo;
			m_originatorChoice = originatorChoice;
			m_version = (int)version;
			m_originatorIdentifier = null;
			m_userKeyMaterial = new byte[0];
			m_encryptionAlgorithm = null;
			m_recipientIdentifier = null;
			m_encryptedKey = new byte[0];
			m_date = DateTime.MinValue;
			m_otherKeyAttribute = null;
			m_subIndex = subIndex;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> class represents a collection of <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> objects. <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> implements the <see cref="T:System.Collections.ICollection" /> interface.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class RecipientInfoCollection : ICollection, IEnumerable
	{
		[SecurityCritical]
		private SafeCryptMsgHandle m_safeCryptMsgHandle;

		private ArrayList m_recipientInfos;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.RecipientInfoCollection.Item(System.Int32)" /> property retrieves the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object at the specified index in the collection.</summary>
		/// <param name="index">An int value that represents the index in the collection. The index is zero based.</param>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object at the specified index.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of an argument was outside the allowable range of values as defined by the called method.</exception>
		public RecipientInfo this[int index]
		{
			get
			{
				if (index < 0 || index >= m_recipientInfos.Count)
				{
					throw new ArgumentOutOfRangeException("index", SecurityResources.GetResourceString("ArgumentOutOfRange_Index"));
				}
				return (RecipientInfo)m_recipientInfos[index];
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.RecipientInfoCollection.Count" /> property retrieves the number of items in the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</summary>
		/// <returns>An int value that represents the number of items in the collection.</returns>
		public int Count => m_recipientInfos.Count;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.RecipientInfoCollection.IsSynchronized" /> property retrieves whether access to the collection is synchronized, or thread safe. This property always returns <see langword="false" />, which means the collection is not thread safe.</summary>
		/// <returns>A <see cref="T:System.Boolean" /> value of <see langword="false" />, which means the collection is not thread safe.</returns>
		public bool IsSynchronized => false;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.RecipientInfoCollection.SyncRoot" /> property retrieves an <see cref="T:System.Object" /> object used to synchronize access to the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</summary>
		/// <returns>An <see cref="T:System.Object" /> object used to synchronize access to the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</returns>
		public object SyncRoot => this;

		[SecuritySafeCritical]
		internal RecipientInfoCollection()
		{
			m_safeCryptMsgHandle = SafeCryptMsgHandle.InvalidHandle;
			m_recipientInfos = new ArrayList();
		}

		[SecuritySafeCritical]
		internal RecipientInfoCollection(RecipientInfo recipientInfo)
		{
			m_safeCryptMsgHandle = SafeCryptMsgHandle.InvalidHandle;
			m_recipientInfos = new ArrayList(1);
			m_recipientInfos.Add(recipientInfo);
		}

		[SecurityCritical]
		internal unsafe RecipientInfoCollection(SafeCryptMsgHandle safeCryptMsgHandle)
		{
			bool flag = PkcsUtils.CmsSupported();
			uint num = 0u;
			uint num2 = (uint)Marshal.SizeOf(typeof(uint));
			if (flag)
			{
				if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, 33u, 0u, new IntPtr(&num), new IntPtr(&num2)))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
			}
			else if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, 17u, 0u, new IntPtr(&num), new IntPtr(&num2)))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			m_recipientInfos = new ArrayList();
			for (uint num3 = 0u; num3 < num; num3++)
			{
				if (flag)
				{
					PkcsUtils.GetParam(safeCryptMsgHandle, 36u, num3, out SafeLocalAllocHandle pvData, out uint _);
					CAPI.CMSG_CMS_RECIPIENT_INFO cMSG_CMS_RECIPIENT_INFO = (CAPI.CMSG_CMS_RECIPIENT_INFO)Marshal.PtrToStructure(pvData.DangerousGetHandle(), typeof(CAPI.CMSG_CMS_RECIPIENT_INFO));
					switch (cMSG_CMS_RECIPIENT_INFO.dwRecipientChoice)
					{
					case 1u:
					{
						CAPI.CMSG_KEY_TRANS_RECIPIENT_INFO keyTrans = (CAPI.CMSG_KEY_TRANS_RECIPIENT_INFO)Marshal.PtrToStructure(cMSG_CMS_RECIPIENT_INFO.pRecipientInfo, typeof(CAPI.CMSG_KEY_TRANS_RECIPIENT_INFO));
						m_recipientInfos.Add(new KeyTransRecipientInfo(pvData, keyTrans, num3));
						break;
					}
					case 2u:
					{
						CAPI.CMSG_KEY_AGREE_RECIPIENT_INFO cMSG_KEY_AGREE_RECIPIENT_INFO = (CAPI.CMSG_KEY_AGREE_RECIPIENT_INFO)Marshal.PtrToStructure(cMSG_CMS_RECIPIENT_INFO.pRecipientInfo, typeof(CAPI.CMSG_KEY_AGREE_RECIPIENT_INFO));
						switch (cMSG_KEY_AGREE_RECIPIENT_INFO.dwOriginatorChoice)
						{
						case 1u:
						{
							CAPI.CMSG_KEY_AGREE_CERT_ID_RECIPIENT_INFO certIdRecipient = (CAPI.CMSG_KEY_AGREE_CERT_ID_RECIPIENT_INFO)Marshal.PtrToStructure(cMSG_CMS_RECIPIENT_INFO.pRecipientInfo, typeof(CAPI.CMSG_KEY_AGREE_CERT_ID_RECIPIENT_INFO));
							for (uint num5 = 0u; num5 < certIdRecipient.cRecipientEncryptedKeys; num5++)
							{
								m_recipientInfos.Add(new KeyAgreeRecipientInfo(pvData, certIdRecipient, num3, num5));
							}
							break;
						}
						case 2u:
						{
							CAPI.CMSG_KEY_AGREE_PUBLIC_KEY_RECIPIENT_INFO publicKeyRecipient = (CAPI.CMSG_KEY_AGREE_PUBLIC_KEY_RECIPIENT_INFO)Marshal.PtrToStructure(cMSG_CMS_RECIPIENT_INFO.pRecipientInfo, typeof(CAPI.CMSG_KEY_AGREE_PUBLIC_KEY_RECIPIENT_INFO));
							for (uint num4 = 0u; num4 < publicKeyRecipient.cRecipientEncryptedKeys; num4++)
							{
								m_recipientInfos.Add(new KeyAgreeRecipientInfo(pvData, publicKeyRecipient, num3, num4));
							}
							break;
						}
						default:
							throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Invalid_Originator_Identifier_Choice"), cMSG_KEY_AGREE_RECIPIENT_INFO.dwOriginatorChoice.ToString(CultureInfo.CurrentCulture));
						}
						break;
					}
					default:
						throw new CryptographicException(-2147483647);
					}
				}
				else
				{
					PkcsUtils.GetParam(safeCryptMsgHandle, 19u, num3, out SafeLocalAllocHandle pvData2, out uint _);
					CAPI.CERT_INFO certInfo = (CAPI.CERT_INFO)Marshal.PtrToStructure(pvData2.DangerousGetHandle(), typeof(CAPI.CERT_INFO));
					m_recipientInfos.Add(new KeyTransRecipientInfo(pvData2, certInfo, num3));
				}
			}
			m_safeCryptMsgHandle = safeCryptMsgHandle;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.RecipientInfoCollection.GetEnumerator" /> method returns a <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoEnumerator" /> object for the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoEnumerator" /> object that can be used to enumerate the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</returns>
		public RecipientInfoEnumerator GetEnumerator()
		{
			return new RecipientInfoEnumerator(this);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.RecipientInfoCollection.System#Collections#IEnumerable#GetEnumerator" /> method returns a <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoEnumerator" /> object for the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoEnumerator" /> object that can be used to enumerate the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return new RecipientInfoEnumerator(this);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.RecipientInfoCollection.CopyTo(System.Array,System.Int32)" /> method copies the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection to an array.</summary>
		/// <param name="array">An <see cref="T:System.Array" /> object to which  the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection is to be copied.</param>
		/// <param name="index">The zero-based index in <paramref name="array" /> where the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection is copied.</param>
		/// <exception cref="T:System.ArgumentException">One of the arguments provided to a method was not valid.</exception>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of an argument was outside the allowable range of values as defined by the called method.</exception>
		public void CopyTo(Array array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (array.Rank != 1)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Arg_RankMultiDimNotSupported"));
			}
			if (index < 0 || index >= array.Length)
			{
				throw new ArgumentOutOfRangeException("index", SecurityResources.GetResourceString("ArgumentOutOfRange_Index"));
			}
			if (index + Count > array.Length)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Argument_InvalidOffLen"));
			}
			for (int i = 0; i < Count; i++)
			{
				array.SetValue(this[i], index);
				index++;
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.RecipientInfoCollection.CopyTo(System.Security.Cryptography.Pkcs.RecipientInfo[],System.Int32)" /> method copies the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection to a <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> array.</summary>
		/// <param name="array">An array of <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> objects where the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection is to be copied.</param>
		/// <param name="index">The zero-based index in <paramref name="array" /> where the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection is copied.</param>
		/// <exception cref="T:System.ArgumentException">One of the arguments provided to a method was not valid.</exception>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of an argument was outside the allowable range of values as defined by the called method.</exception>
		public void CopyTo(RecipientInfo[] array, int index)
		{
			((ICollection)this).CopyTo((Array)array, index);
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoEnumerator" /> class provides enumeration functionality for the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection. <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoEnumerator" /> implements the <see cref="T:System.Collections.IEnumerator" /> interface.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class RecipientInfoEnumerator : IEnumerator
	{
		private RecipientInfoCollection m_recipientInfos;

		private int m_current;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.RecipientInfoEnumerator.Current" /> property retrieves the current <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object from the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object that represents the current recipient information structure in the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</returns>
		public RecipientInfo Current => m_recipientInfos[m_current];

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.RecipientInfoEnumerator.System#Collections#IEnumerator#Current" /> property retrieves the current <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object from the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object that represents the current recipient information structure in the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</returns>
		object IEnumerator.Current => m_recipientInfos[m_current];

		private RecipientInfoEnumerator()
		{
		}

		internal RecipientInfoEnumerator(RecipientInfoCollection RecipientInfos)
		{
			m_recipientInfos = RecipientInfos;
			m_current = -1;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.RecipientInfoEnumerator.MoveNext" /> method advances the enumeration to the next <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object in the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</summary>
		/// <returns>This method returns a bool that specifies whether the enumeration successfully advanced. If the enumeration successfully moved to the next <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object, the method returns <see langword="true" />. If the enumeration moved past the last item in the enumeration, it returns <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (m_current == m_recipientInfos.Count - 1)
			{
				return false;
			}
			m_current++;
			return true;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.RecipientInfoEnumerator.Reset" /> method resets the enumeration to the first <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfo" /> object in the <see cref="T:System.Security.Cryptography.Pkcs.RecipientInfoCollection" /> collection.</summary>
		public void Reset()
		{
			m_current = -1;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.KeyAgreeKeyChoice" /> enumeration defines the type of key used in a key agreement protocol.</summary>
	public enum KeyAgreeKeyChoice
	{
		/// <summary>The key agreement key type is unknown.</summary>
		Unknown,
		/// <summary>The key agreement key is ephemeral, existing only for the duration of the key agreement protocol.</summary>
		EphemeralKey,
		/// <summary>The key agreement key is static, existing for an extended period of time.</summary>
		StaticKey
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> enumeration defines the type of subject identifier.</summary>
	public enum SubjectIdentifierType
	{
		/// <summary>The type of subject identifier is unknown.</summary>
		Unknown,
		/// <summary>The subject is identified by the certificate issuer and serial number.</summary>
		IssuerAndSerialNumber,
		/// <summary>The subject is identified by the hash of the subject's public key. The hash algorithm used is determined by the signature algorithm suite in the subject's certificate.</summary>
		SubjectKeyIdentifier,
		/// <summary>The subject is identified as taking part in an integrity check operation that uses only a hashing algorithm.</summary>
		NoSignature
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifier" /> class defines the type of the identifier of a subject, such as a <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> or a <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" />.  The subject can be identified by the certificate issuer and serial number or the subject key.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SubjectIdentifier
	{
		private SubjectIdentifierType m_type;

		private object m_value;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifier.Type" /> property retrieves the type of subject identifier. The subject can be identified by the certificate issuer and serial number or the subject key.</summary>
		/// <returns>A member of the <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> enumeration that identifies the type of subject.</returns>
		public SubjectIdentifierType Type => m_type;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifier.Value" /> property retrieves the value of the subject identifier. Use the <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifier.Type" /> property to determine the type of subject identifier, and use the <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifier.Value" /> property to retrieve the corresponding value.</summary>
		/// <returns>An <see cref="T:System.Object" /> object that represents the value of the subject identifier. This <see cref="T:System.Object" /> can be one of the following objects as determined by the <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifier.Type" /> property.  
		///  <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifier.Type" /> property  
		///
		///   Object  
		///
		///   IssuerAndSerialNumber  
		///
		///  <see cref="T:System.Security.Cryptography.Xml.X509IssuerSerial" /> SubjectKeyIdentifier  
		///
		///  <see cref="T:System.String" /></returns>
		public object Value => m_value;

		private SubjectIdentifier()
		{
		}

		[SecurityCritical]
		internal SubjectIdentifier(CAPI.CERT_INFO certInfo)
			: this(certInfo.Issuer, certInfo.SerialNumber)
		{
		}

		[SecurityCritical]
		internal SubjectIdentifier(CAPI.CMSG_SIGNER_INFO signerInfo)
			: this(signerInfo.Issuer, signerInfo.SerialNumber)
		{
		}

		internal SubjectIdentifier(SubjectIdentifierType type, object value)
		{
			Reset(type, value);
		}

		[SecurityCritical]
		internal unsafe SubjectIdentifier(CAPI.CRYPTOAPI_BLOB issuer, CAPI.CRYPTOAPI_BLOB serialNumber)
		{
			bool flag = true;
			byte* ptr = (byte*)(void*)serialNumber.pbData;
			for (uint num = 0u; num < serialNumber.cbData; num++)
			{
				if (*(ptr++) != 0)
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				byte[] array = new byte[issuer.cbData];
				Marshal.Copy(issuer.pbData, array, 0, array.Length);
				X500DistinguishedName x500DistinguishedName = new X500DistinguishedName(array);
				if (string.Compare("CN=Dummy Signer", x500DistinguishedName.Name, StringComparison.OrdinalIgnoreCase) == 0)
				{
					Reset(SubjectIdentifierType.NoSignature, null);
					return;
				}
			}
			checked
			{
				if (flag)
				{
					m_type = SubjectIdentifierType.SubjectKeyIdentifier;
					m_value = string.Empty;
					uint cbDecodedValue = 0u;
					SafeLocalAllocHandle decodedValue = SafeLocalAllocHandle.InvalidHandle;
					if (CAPI.DecodeObject(new IntPtr(7L), issuer.pbData, issuer.cbData, out decodedValue, out cbDecodedValue))
					{
						using (decodedValue)
						{
							CAPI.CERT_NAME_INFO cERT_NAME_INFO = (CAPI.CERT_NAME_INFO)Marshal.PtrToStructure(decodedValue.DangerousGetHandle(), typeof(CAPI.CERT_NAME_INFO));
							for (uint num2 = 0u; num2 < cERT_NAME_INFO.cRDN; num2++)
							{
								CAPI.CERT_RDN cERT_RDN = (CAPI.CERT_RDN)Marshal.PtrToStructure(new IntPtr((long)cERT_NAME_INFO.rgRDN + unchecked((long)num2) * unchecked((long)Marshal.SizeOf(typeof(CAPI.CERT_RDN)))), typeof(CAPI.CERT_RDN));
								for (uint num3 = 0u; num3 < cERT_RDN.cRDNAttr; num3++)
								{
									CAPI.CERT_RDN_ATTR cERT_RDN_ATTR = (CAPI.CERT_RDN_ATTR)Marshal.PtrToStructure(new IntPtr((long)cERT_RDN.rgRDNAttr + unchecked((long)num3) * unchecked((long)Marshal.SizeOf(typeof(CAPI.CERT_RDN_ATTR)))), typeof(CAPI.CERT_RDN_ATTR));
									if (string.Compare("1.3.6.1.4.1.311.10.7.1", cERT_RDN_ATTR.pszObjId, StringComparison.OrdinalIgnoreCase) == 0 && cERT_RDN_ATTR.dwValueType == 2)
									{
										byte[] array2 = new byte[cERT_RDN_ATTR.Value.cbData];
										Marshal.Copy(cERT_RDN_ATTR.Value.pbData, array2, 0, array2.Length);
										Reset(SubjectIdentifierType.SubjectKeyIdentifier, System.Security.Cryptography.X509Certificates.X509Utils.EncodeHexString(array2));
										return;
									}
								}
							}
						}
					}
				}
				CAPI.CERT_ISSUER_SERIAL_NUMBER pIssuerAndSerial = default(CAPI.CERT_ISSUER_SERIAL_NUMBER);
				pIssuerAndSerial.Issuer = issuer;
				pIssuerAndSerial.SerialNumber = serialNumber;
				X509IssuerSerial x509IssuerSerial = PkcsUtils.DecodeIssuerSerial(pIssuerAndSerial);
				Reset(SubjectIdentifierType.IssuerAndSerialNumber, x509IssuerSerial);
			}
		}

		[SecurityCritical]
		internal SubjectIdentifier(CAPI.CERT_ID certId)
		{
			switch (certId.dwIdChoice)
			{
			case 1u:
			{
				X509IssuerSerial x509IssuerSerial = PkcsUtils.DecodeIssuerSerial(certId.Value.IssuerSerialNumber);
				Reset(SubjectIdentifierType.IssuerAndSerialNumber, x509IssuerSerial);
				break;
			}
			case 2u:
			{
				byte[] array = new byte[certId.Value.KeyId.cbData];
				Marshal.Copy(certId.Value.KeyId.pbData, array, 0, array.Length);
				Reset(SubjectIdentifierType.SubjectKeyIdentifier, System.Security.Cryptography.X509Certificates.X509Utils.EncodeHexString(array));
				break;
			}
			default:
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Invalid_Subject_Identifier_Type"), certId.dwIdChoice.ToString(CultureInfo.InvariantCulture));
			}
		}

		internal void Reset(SubjectIdentifierType type, object value)
		{
			switch (type)
			{
			case SubjectIdentifierType.IssuerAndSerialNumber:
				if (value.GetType() != typeof(X509IssuerSerial))
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Invalid_Subject_Identifier_Type_Value_Mismatch"), value.GetType().ToString());
				}
				break;
			case SubjectIdentifierType.SubjectKeyIdentifier:
				if (!PkcsUtils.CmsSupported())
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Not_Supported"));
				}
				if (value.GetType() != typeof(string))
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Invalid_Subject_Identifier_Type_Value_Mismatch"), value.GetType().ToString());
				}
				break;
			default:
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Invalid_Subject_Identifier_Type"), type.ToString());
			case SubjectIdentifierType.Unknown:
			case SubjectIdentifierType.NoSignature:
				break;
			}
			m_type = type;
			m_value = value;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierOrKeyType" /> enumeration defines how a subject is identified.</summary>
	public enum SubjectIdentifierOrKeyType
	{
		/// <summary>The type is unknown.</summary>
		Unknown,
		/// <summary>The subject is identified by the certificate issuer and serial number.</summary>
		IssuerAndSerialNumber,
		/// <summary>The subject is identified by the hash of the subject key.</summary>
		SubjectKeyIdentifier,
		/// <summary>The subject is identified by the public key.</summary>
		PublicKeyInfo
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.PublicKeyInfo" /> class represents information associated with a public key.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class PublicKeyInfo
	{
		private AlgorithmIdentifier m_algorithm;

		private byte[] m_keyValue;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.PublicKeyInfo.Algorithm" /> property retrieves the algorithm identifier associated with the public key.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Pkcs.AlgorithmIdentifier" /> object that represents the algorithm.</returns>
		public AlgorithmIdentifier Algorithm => m_algorithm;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.PublicKeyInfo.KeyValue" /> property retrieves the value of the encoded public component of the public key pair.</summary>
		/// <returns>An array of byte values  that represents the encoded public component of the public key pair.</returns>
		public byte[] KeyValue => m_keyValue;

		private PublicKeyInfo()
		{
		}

		[SecurityCritical]
		internal PublicKeyInfo(CAPI.CERT_PUBLIC_KEY_INFO keyInfo)
		{
			m_algorithm = new AlgorithmIdentifier(keyInfo);
			m_keyValue = new byte[keyInfo.PublicKey.cbData];
			if (m_keyValue.Length != 0)
			{
				Marshal.Copy(keyInfo.PublicKey.pbData, m_keyValue, 0, m_keyValue.Length);
			}
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey" /> class defines the type of the identifier of a subject, such as a <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> or a <see cref="T:System.Security.Cryptography.Pkcs.CmsRecipient" />.  The subject can be identified by the certificate issuer and serial number, the hash of the subject key, or the subject key.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SubjectIdentifierOrKey
	{
		private SubjectIdentifierOrKeyType m_type;

		private object m_value;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey.Type" /> property retrieves the type of subject identifier or key. The subject can be identified by the certificate issuer and serial number, the hash of the subject key, or the subject key.</summary>
		/// <returns>A member of the <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierOrKeyType" /> enumeration that specifies the type of subject identifier.</returns>
		public SubjectIdentifierOrKeyType Type => m_type;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey.Value" /> property retrieves the value of the subject identifier or  key. Use the <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey.Type" /> property to determine the type of subject identifier or key, and use the <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey.Value" /> property to retrieve the corresponding value.</summary>
		/// <returns>An <see cref="T:System.Object" /> object that represents the value of the subject identifier or key. This <see cref="T:System.Object" /> can be one of the following objects as determined by the <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey.Type" /> property.  
		///  <see cref="P:System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey.Type" /> property  
		///
		///   Object  
		///
		///   IssuerAndSerialNumber  
		///
		///  <see cref="T:System.Security.Cryptography.Xml.X509IssuerSerial" /> SubjectKeyIdentifier  
		///
		///  <see cref="T:System.String" /> PublicKeyInfo  
		///
		///  <see cref="T:System.Security.Cryptography.Pkcs.PublicKeyInfo" /></returns>
		public object Value => m_value;

		private SubjectIdentifierOrKey()
		{
		}

		internal SubjectIdentifierOrKey(SubjectIdentifierOrKeyType type, object value)
		{
			Reset(type, value);
		}

		[SecurityCritical]
		internal SubjectIdentifierOrKey(CAPI.CERT_ID certId)
		{
			switch (certId.dwIdChoice)
			{
			case 1u:
			{
				X509IssuerSerial x509IssuerSerial = PkcsUtils.DecodeIssuerSerial(certId.Value.IssuerSerialNumber);
				Reset(SubjectIdentifierOrKeyType.IssuerAndSerialNumber, x509IssuerSerial);
				break;
			}
			case 2u:
			{
				byte[] array = new byte[certId.Value.KeyId.cbData];
				Marshal.Copy(certId.Value.KeyId.pbData, array, 0, array.Length);
				Reset(SubjectIdentifierOrKeyType.SubjectKeyIdentifier, System.Security.Cryptography.X509Certificates.X509Utils.EncodeHexString(array));
				break;
			}
			default:
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Invalid_Subject_Identifier_Type"), certId.dwIdChoice.ToString(CultureInfo.InvariantCulture));
			}
		}

		[SecurityCritical]
		internal SubjectIdentifierOrKey(CAPI.CERT_PUBLIC_KEY_INFO publicKeyInfo)
		{
			Reset(SubjectIdentifierOrKeyType.PublicKeyInfo, new PublicKeyInfo(publicKeyInfo));
		}

		internal void Reset(SubjectIdentifierOrKeyType type, object value)
		{
			switch (type)
			{
			case SubjectIdentifierOrKeyType.IssuerAndSerialNumber:
				if (value.GetType() != typeof(X509IssuerSerial))
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Invalid_Subject_Identifier_Type_Value_Mismatch"), value.GetType().ToString());
				}
				break;
			case SubjectIdentifierOrKeyType.SubjectKeyIdentifier:
				if (!PkcsUtils.CmsSupported())
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Not_Supported"));
				}
				if (value.GetType() != typeof(string))
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Invalid_Subject_Identifier_Type_Value_Mismatch"), value.GetType().ToString());
				}
				break;
			case SubjectIdentifierOrKeyType.PublicKeyInfo:
				if (!PkcsUtils.CmsSupported())
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Not_Supported"));
				}
				if (value.GetType() != typeof(PublicKeyInfo))
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Invalid_Subject_Identifier_Type_Value_Mismatch"), value.GetType().ToString());
				}
				break;
			default:
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Invalid_Subject_Identifier_Type"), type.ToString());
			case SubjectIdentifierOrKeyType.Unknown:
				break;
			}
			m_type = type;
			m_value = value;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.AlgorithmIdentifier" /> class defines the algorithm used for a cryptographic operation.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class AlgorithmIdentifier
	{
		private Oid m_oid;

		private int m_keyLength;

		private byte[] m_parameters;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.AlgorithmIdentifier.Oid" /> property sets or retrieves the <see cref="T:System.Security.Cryptography.Oid" /> object that specifies the object identifier for the algorithm.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Oid" /> object that represents the algorithm.</returns>
		public Oid Oid
		{
			get
			{
				return m_oid;
			}
			set
			{
				m_oid = value;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.AlgorithmIdentifier.KeyLength" /> property sets or retrieves the key length, in bits. This property is not used for algorithms that use a fixed key length.</summary>
		/// <returns>An int value that represents the key length, in bits.</returns>
		public int KeyLength
		{
			get
			{
				return m_keyLength;
			}
			set
			{
				m_keyLength = value;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.AlgorithmIdentifier.Parameters" /> property sets or retrieves any parameters required by the algorithm.</summary>
		/// <returns>An array of byte values that specifies any parameters required by the algorithm.</returns>
		public byte[] Parameters
		{
			get
			{
				return m_parameters;
			}
			set
			{
				m_parameters = value;
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.AlgorithmIdentifier.#ctor" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.AlgorithmIdentifier" /> class by using a set of default parameters.</summary>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public AlgorithmIdentifier()
		{
			Reset(Oid.FromOidValue("1.2.840.113549.3.7", OidGroup.EncryptionAlgorithm), 0, new byte[0]);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.AlgorithmIdentifier.#ctor(System.Security.Cryptography.Oid)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.AlgorithmIdentifier" /> class with the specified algorithm identifier.</summary>
		/// <param name="oid">An object identifier for the algorithm.</param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public AlgorithmIdentifier(Oid oid)
		{
			Reset(oid, 0, new byte[0]);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.AlgorithmIdentifier.#ctor(System.Security.Cryptography.Oid,System.Int32)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.AlgorithmIdentifier" /> class with the specified algorithm identifier and key length.</summary>
		/// <param name="oid">An object identifier for the algorithm.</param>
		/// <param name="keyLength">The length, in bits, of the key.</param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public AlgorithmIdentifier(Oid oid, int keyLength)
		{
			Reset(oid, keyLength, new byte[0]);
		}

		[SecurityCritical]
		internal AlgorithmIdentifier(CAPI.CERT_PUBLIC_KEY_INFO keyInfo)
		{
			SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(CAPI.CERT_PUBLIC_KEY_INFO))));
			Marshal.StructureToPtr((object)keyInfo, safeLocalAllocHandle.DangerousGetHandle(), fDeleteOld: false);
			int keyLength = (int)CAPI.CAPISafe.CertGetPublicKeyLength(65537u, safeLocalAllocHandle.DangerousGetHandle());
			byte[] array = new byte[keyInfo.Algorithm.Parameters.cbData];
			if (array.Length != 0)
			{
				Marshal.Copy(keyInfo.Algorithm.Parameters.pbData, array, 0, array.Length);
			}
			Marshal.DestroyStructure(safeLocalAllocHandle.DangerousGetHandle(), typeof(CAPI.CERT_PUBLIC_KEY_INFO));
			safeLocalAllocHandle.Dispose();
			Reset(Oid.FromOidValue(keyInfo.Algorithm.pszObjId, OidGroup.PublicKeyAlgorithm), keyLength, array);
		}

		[SecurityCritical]
		internal AlgorithmIdentifier(CAPI.CRYPT_ALGORITHM_IDENTIFIER algorithmIdentifier)
		{
			int keyLength = 0;
			uint cbDecodedValue = 0u;
			SafeLocalAllocHandle decodedValue = SafeLocalAllocHandle.InvalidHandle;
			byte[] array = new byte[0];
			uint num = System.Security.Cryptography.X509Certificates.X509Utils.OidToAlgId(algorithmIdentifier.pszObjId);
			switch (num)
			{
			case 26114u:
				if (algorithmIdentifier.Parameters.cbData != 0)
				{
					if (!CAPI.DecodeObject(new IntPtr(41L), algorithmIdentifier.Parameters.pbData, algorithmIdentifier.Parameters.cbData, out decodedValue, out cbDecodedValue))
					{
						throw new CryptographicException(Marshal.GetLastWin32Error());
					}
					CAPI.CRYPT_RC2_CBC_PARAMETERS cRYPT_RC2_CBC_PARAMETERS = (CAPI.CRYPT_RC2_CBC_PARAMETERS)Marshal.PtrToStructure(decodedValue.DangerousGetHandle(), typeof(CAPI.CRYPT_RC2_CBC_PARAMETERS));
					switch (cRYPT_RC2_CBC_PARAMETERS.dwVersion)
					{
					case 160u:
						keyLength = 40;
						break;
					case 52u:
						keyLength = 56;
						break;
					case 58u:
						keyLength = 128;
						break;
					}
					if (cRYPT_RC2_CBC_PARAMETERS.fIV)
					{
						array = (byte[])cRYPT_RC2_CBC_PARAMETERS.rgbIV.Clone();
					}
				}
				break;
			case 26113u:
			case 26115u:
			case 26625u:
				if (algorithmIdentifier.Parameters.cbData != 0)
				{
					if (!CAPI.DecodeObject(new IntPtr(25L), algorithmIdentifier.Parameters.pbData, algorithmIdentifier.Parameters.cbData, out decodedValue, out cbDecodedValue))
					{
						throw new CryptographicException(Marshal.GetLastWin32Error());
					}
					if (cbDecodedValue > Marshal.SizeOf(typeof(CAPI.CRYPTOAPI_BLOB)))
					{
						CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB = (CAPI.CRYPTOAPI_BLOB)Marshal.PtrToStructure(decodedValue.DangerousGetHandle(), typeof(CAPI.CRYPTOAPI_BLOB));
						if (num == 26625)
						{
							if (cRYPTOAPI_BLOB.cbData != 0)
							{
								array = new byte[cRYPTOAPI_BLOB.cbData];
								Marshal.Copy(cRYPTOAPI_BLOB.pbData, array, 0, array.Length);
							}
						}
						else
						{
							array = new byte[cbDecodedValue];
							Marshal.Copy(decodedValue.DangerousGetHandle(), array, 0, array.Length);
							Array.Clear(array, 4, (int)(array.Length - cRYPTOAPI_BLOB.cbData - 4));
						}
					}
				}
				keyLength = num switch
				{
					26625u => 128 - array.Length * 8, 
					26113u => 64, 
					_ => 192, 
				};
				break;
			default:
				if (algorithmIdentifier.Parameters.cbData != 0)
				{
					array = new byte[algorithmIdentifier.Parameters.cbData];
					Marshal.Copy(algorithmIdentifier.Parameters.pbData, array, 0, array.Length);
				}
				break;
			}
			Reset(Oid.FromOidValue(algorithmIdentifier.pszObjId, OidGroup.All), keyLength, array);
			decodedValue.Dispose();
		}

		private void Reset(Oid oid, int keyLength, byte[] parameters)
		{
			m_oid = oid;
			m_keyLength = keyLength;
			m_parameters = parameters;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> class represents the CMS/PKCS #7 ContentInfo data structure as defined in the CMS/PKCS #7 standards document. This data structure is the basis for all CMS/PKCS #7 messages.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ContentInfo
	{
		private Oid m_contentType;

		private byte[] m_content;

		private IntPtr m_pContent = IntPtr.Zero;

		private GCHandle m_gcHandle;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.ContentInfo.ContentType" /> property  retrieves the <see cref="T:System.Security.Cryptography.Oid" /> object that contains the <paramref name="object identifier" /> (OID)  of the content type of the inner content of the CMS/PKCS #7 message.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Oid" /> object that contains the OID value that represents the content type.</returns>
		public Oid ContentType => m_contentType;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.ContentInfo.Content" /> property  retrieves the content of the CMS/PKCS #7 message.</summary>
		/// <returns>An array of byte values that represents the content data.</returns>
		public byte[] Content => m_content;

		internal IntPtr pContent
		{
			[SecurityCritical]
			get
			{
				if (IntPtr.Zero == m_pContent && m_content != null && m_content.Length != 0)
				{
					m_gcHandle = GCHandle.Alloc(m_content, GCHandleType.Pinned);
					m_pContent = Marshal.UnsafeAddrOfPinnedArrayElement((Array)m_content, 0);
				}
				return m_pContent;
			}
		}

		private ContentInfo()
			: this(Oid.FromOidValue("1.2.840.113549.1.7.1", OidGroup.ExtensionOrAttribute), new byte[0])
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.ContentInfo.#ctor(System.Byte[])" /> constructor  creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> class by using an array of byte values as the data and a default <paramref name="object identifier" /> (OID) that represents the content type.</summary>
		/// <param name="content">An array of byte values that represents the data from which to create the <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference  was passed to a method that does not accept it as a valid argument.</exception>
		public ContentInfo(byte[] content)
			: this(Oid.FromOidValue("1.2.840.113549.1.7.1", OidGroup.ExtensionOrAttribute), content)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.ContentInfo.#ctor(System.Security.Cryptography.Oid,System.Byte[])" /> constructor  creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> class by using the specified content type and an array of byte values as the data.</summary>
		/// <param name="contentType">An <see cref="T:System.Security.Cryptography.Oid" /> object that contains an object identifier (OID) that specifies the content type of the content. This can be data, digestedData, encryptedData, envelopedData, hashedData, signedAndEnvelopedData, or signedData.  For more information, see  Remarks.</param>
		/// <param name="content">An array of byte values that represents the data from which to create the <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference  was passed to a method that does not accept it as a valid argument.</exception>
		public ContentInfo(Oid contentType, byte[] content)
		{
			if (contentType == null)
			{
				throw new ArgumentNullException("contentType");
			}
			if (content == null)
			{
				throw new ArgumentNullException("content");
			}
			m_contentType = contentType;
			m_content = content;
		}

		/// <summary>Releases unmanaged resources and performs other cleanup operations before the <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> instance is reclaimed by garbage collection.</summary>
		[SecuritySafeCritical]
		~ContentInfo()
		{
			if (m_gcHandle.IsAllocated)
			{
				m_gcHandle.Free();
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.ContentInfo.GetContentType(System.Byte[])" /> static method  retrieves the outer content type of the encoded <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> message represented by an array of byte values.</summary>
		/// <param name="encodedMessage">An array of byte values that represents the encoded <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> message from which to retrieve the outer content type.</param>
		/// <returns>If the method succeeds, the method returns an <see cref="T:System.Security.Cryptography.Oid" /> object that contains the outer content type of the specified encoded <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> message.  
		///  If the method fails, it throws an exception.</returns>
		/// <exception cref="T:System.ArgumentNullException">A null reference  was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">An error occurred during a cryptographic operation.</exception>
		[SecuritySafeCritical]
		public static Oid GetContentType(byte[] encodedMessage)
		{
			if (encodedMessage == null)
			{
				throw new ArgumentNullException("encodedMessage");
			}
			SafeCryptMsgHandle safeCryptMsgHandle = CAPI.CAPISafe.CryptMsgOpenToDecode(65537u, 0u, 0u, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);
			if (safeCryptMsgHandle == null || safeCryptMsgHandle.IsInvalid)
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			if (!CAPI.CAPISafe.CryptMsgUpdate(safeCryptMsgHandle, encodedMessage, (uint)encodedMessage.Length, fFinal: true))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			Oid result = PkcsUtils.GetMessageType(safeCryptMsgHandle) switch
			{
				1u => Oid.FromOidValue("1.2.840.113549.1.7.1", OidGroup.ExtensionOrAttribute), 
				2u => Oid.FromOidValue("1.2.840.113549.1.7.2", OidGroup.ExtensionOrAttribute), 
				3u => Oid.FromOidValue("1.2.840.113549.1.7.3", OidGroup.ExtensionOrAttribute), 
				4u => Oid.FromOidValue("1.2.840.113549.1.7.4", OidGroup.ExtensionOrAttribute), 
				5u => Oid.FromOidValue("1.2.840.113549.1.7.5", OidGroup.ExtensionOrAttribute), 
				6u => Oid.FromOidValue("1.2.840.113549.1.7.6", OidGroup.ExtensionOrAttribute), 
				_ => throw new CryptographicException(-2146889724), 
			};
			safeCryptMsgHandle.Dispose();
			return result;
		}
	}
	internal static class PkcsUtils
	{
		private struct I_CRYPT_ATTRIBUTE
		{
			internal IntPtr pszObjId;

			internal uint cValue;

			internal IntPtr rgValue;
		}

		private static volatile int m_cmsSupported = -1;

		internal static uint AlignedLength(uint length)
		{
			return (length + 7) & 0xFFFFFFF8u;
		}

		[SecuritySafeCritical]
		internal static bool CmsSupported()
		{
			if (m_cmsSupported == -1)
			{
				using SafeLibraryHandle safeLibraryHandle = CAPI.CAPISafe.LoadLibrary("Crypt32.dll");
				if (!safeLibraryHandle.IsInvalid)
				{
					IntPtr procAddress = CAPI.CAPISafe.GetProcAddress(safeLibraryHandle, "CryptMsgVerifyCountersignatureEncodedEx");
					m_cmsSupported = ((!(procAddress == IntPtr.Zero)) ? 1 : 0);
				}
			}
			if (m_cmsSupported != 0)
			{
				return true;
			}
			return false;
		}

		[SecuritySafeCritical]
		internal static RecipientInfoType GetRecipientInfoType(X509Certificate2 certificate)
		{
			RecipientInfoType result = RecipientInfoType.Unknown;
			if (certificate != null)
			{
				switch (System.Security.Cryptography.X509Certificates.X509Utils.OidToAlgId(((CAPI.CERT_INFO)Marshal.PtrToStructure(((CAPI.CERT_CONTEXT)Marshal.PtrToStructure(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificate).DangerousGetHandle(), typeof(CAPI.CERT_CONTEXT))).pCertInfo, typeof(CAPI.CERT_INFO))).SubjectPublicKeyInfo.Algorithm.pszObjId))
				{
				case 41984u:
					result = RecipientInfoType.KeyTransport;
					break;
				case 43521u:
				case 43522u:
					result = RecipientInfoType.KeyAgreement;
					break;
				default:
					result = RecipientInfoType.Unknown;
					break;
				}
			}
			return result;
		}

		[SecurityCritical]
		internal unsafe static int GetMaxKeyLength(SafeCryptProvHandle safeCryptProvHandle, uint algId)
		{
			uint dwFlags = 1u;
			uint num = (uint)Marshal.SizeOf(typeof(CAPI.PROV_ENUMALGS_EX));
			SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(CAPI.PROV_ENUMALGS_EX))));
			using (safeLocalAllocHandle)
			{
				while (CAPI.CAPISafe.CryptGetProvParam(safeCryptProvHandle, 22u, safeLocalAllocHandle.DangerousGetHandle(), new IntPtr(&num), dwFlags))
				{
					CAPI.PROV_ENUMALGS_EX pROV_ENUMALGS_EX = (CAPI.PROV_ENUMALGS_EX)Marshal.PtrToStructure(safeLocalAllocHandle.DangerousGetHandle(), typeof(CAPI.PROV_ENUMALGS_EX));
					if (pROV_ENUMALGS_EX.aiAlgid == algId)
					{
						return (int)pROV_ENUMALGS_EX.dwMaxLen;
					}
					dwFlags = 0u;
				}
			}
			throw new CryptographicException(-2146889726);
		}

		[SecurityCritical]
		internal unsafe static uint GetVersion(SafeCryptMsgHandle safeCryptMsgHandle)
		{
			uint result = 0u;
			uint num = (uint)Marshal.SizeOf(typeof(uint));
			if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, 30u, 0u, new IntPtr(&result), new IntPtr(&num)))
			{
				checkErr(Marshal.GetLastWin32Error());
			}
			return result;
		}

		[SecurityCritical]
		internal unsafe static uint GetMessageType(SafeCryptMsgHandle safeCryptMsgHandle)
		{
			uint result = 0u;
			uint num = (uint)Marshal.SizeOf(typeof(uint));
			if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, 1u, 0u, new IntPtr(&result), new IntPtr(&num)))
			{
				checkErr(Marshal.GetLastWin32Error());
			}
			return result;
		}

		[SecurityCritical]
		internal unsafe static AlgorithmIdentifier GetAlgorithmIdentifier(SafeCryptMsgHandle safeCryptMsgHandle)
		{
			AlgorithmIdentifier result = new AlgorithmIdentifier();
			uint num = 0u;
			if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, 15u, 0u, IntPtr.Zero, new IntPtr(&num)))
			{
				checkErr(Marshal.GetLastWin32Error());
			}
			if (num != 0)
			{
				SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(0u, new IntPtr(num));
				if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, 15u, 0u, safeLocalAllocHandle, new IntPtr(&num)))
				{
					checkErr(Marshal.GetLastWin32Error());
				}
				CAPI.CRYPT_ALGORITHM_IDENTIFIER algorithmIdentifier = (CAPI.CRYPT_ALGORITHM_IDENTIFIER)Marshal.PtrToStructure(safeLocalAllocHandle.DangerousGetHandle(), typeof(CAPI.CRYPT_ALGORITHM_IDENTIFIER));
				result = new AlgorithmIdentifier(algorithmIdentifier);
				safeLocalAllocHandle.Dispose();
			}
			return result;
		}

		[SecurityCritical]
		internal unsafe static void GetParam(SafeCryptMsgHandle safeCryptMsgHandle, uint paramType, uint index, out SafeLocalAllocHandle pvData, out uint cbData)
		{
			cbData = 0u;
			pvData = SafeLocalAllocHandle.InvalidHandle;
			fixed (uint* value = &cbData)
			{
				if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, paramType, index, pvData, new IntPtr(value)))
				{
					checkErr(Marshal.GetLastWin32Error());
				}
				if (cbData != 0)
				{
					pvData = CAPI.LocalAlloc(64u, new IntPtr(cbData));
					if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, paramType, index, pvData, new IntPtr(value)))
					{
						checkErr(Marshal.GetLastWin32Error());
					}
				}
			}
		}

		[SecurityCritical]
		internal unsafe static void GetParam(SafeCryptMsgHandle safeCryptMsgHandle, uint paramType, uint index, out byte[] pvData, out uint cbData)
		{
			cbData = 0u;
			pvData = new byte[0];
			fixed (uint* value = &cbData)
			{
				if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, paramType, index, IntPtr.Zero, new IntPtr(value)))
				{
					checkErr(Marshal.GetLastWin32Error());
				}
				if (cbData == 0)
				{
					return;
				}
				pvData = new byte[cbData];
				fixed (byte* value2 = &pvData[0])
				{
					if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, paramType, index, new IntPtr(value2), new IntPtr(value)))
					{
						checkErr(Marshal.GetLastWin32Error());
					}
				}
			}
		}

		[SecurityCritical]
		internal unsafe static X509Certificate2Collection GetCertificates(SafeCryptMsgHandle safeCryptMsgHandle)
		{
			uint num = 0u;
			uint num2 = (uint)Marshal.SizeOf(typeof(uint));
			X509Certificate2Collection x509Certificate2Collection = new X509Certificate2Collection();
			if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, 11u, 0u, new IntPtr(&num), new IntPtr(&num2)))
			{
				checkErr(Marshal.GetLastWin32Error());
			}
			for (uint num3 = 0u; num3 < num; num3++)
			{
				uint cbData = 0u;
				SafeLocalAllocHandle pvData = SafeLocalAllocHandle.InvalidHandle;
				GetParam(safeCryptMsgHandle, 12u, num3, out pvData, out cbData);
				if (cbData != 0)
				{
					SafeCertContextHandle safeCertContextHandle = CAPI.CAPISafe.CertCreateCertificateContext(65537u, pvData, cbData);
					if (safeCertContextHandle == null || safeCertContextHandle.IsInvalid)
					{
						throw new CryptographicException(Marshal.GetLastWin32Error());
					}
					x509Certificate2Collection.Add(new X509Certificate2(safeCertContextHandle.DangerousGetHandle()));
					safeCertContextHandle.Dispose();
				}
			}
			return x509Certificate2Collection;
		}

		[SecurityCritical]
		internal static byte[] GetContent(SafeCryptMsgHandle safeCryptMsgHandle)
		{
			uint cbData = 0u;
			byte[] pvData = new byte[0];
			GetParam(safeCryptMsgHandle, 2u, 0u, out pvData, out cbData);
			return pvData;
		}

		[SecurityCritical]
		internal static Oid GetContentType(SafeCryptMsgHandle safeCryptMsgHandle)
		{
			uint cbData = 0u;
			byte[] pvData = new byte[0];
			GetParam(safeCryptMsgHandle, 4u, 0u, out pvData, out cbData);
			if (pvData.Length != 0 && pvData[pvData.Length - 1] == 0)
			{
				byte[] array = new byte[pvData.Length - 1];
				Array.Copy(pvData, 0, array, 0, array.Length);
				pvData = array;
			}
			return new Oid(Encoding.ASCII.GetString(pvData));
		}

		[SecurityCritical]
		internal static byte[] GetMessage(SafeCryptMsgHandle safeCryptMsgHandle)
		{
			uint cbData = 0u;
			byte[] pvData = new byte[0];
			GetParam(safeCryptMsgHandle, 29u, 0u, out pvData, out cbData);
			return pvData;
		}

		[SecurityCritical]
		internal unsafe static int GetSignerIndex(SafeCryptMsgHandle safeCrytpMsgHandle, SignerInfo signerInfo, int startIndex)
		{
			uint num = 0u;
			uint num2 = (uint)Marshal.SizeOf(typeof(uint));
			if (!CAPI.CAPISafe.CryptMsgGetParam(safeCrytpMsgHandle, 5u, 0u, new IntPtr(&num), new IntPtr(&num2)))
			{
				checkErr(Marshal.GetLastWin32Error());
			}
			for (int i = startIndex; i < (int)num; i++)
			{
				uint num3 = 0u;
				if (!CAPI.CAPISafe.CryptMsgGetParam(safeCrytpMsgHandle, 6u, (uint)i, IntPtr.Zero, new IntPtr(&num3)))
				{
					checkErr(Marshal.GetLastWin32Error());
				}
				if (num3 != 0)
				{
					SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(0u, new IntPtr(num3));
					if (!CAPI.CAPISafe.CryptMsgGetParam(safeCrytpMsgHandle, 6u, (uint)i, safeLocalAllocHandle, new IntPtr(&num3)))
					{
						checkErr(Marshal.GetLastWin32Error());
					}
					CAPI.CMSG_SIGNER_INFO cmsgSignerInfo = signerInfo.GetCmsgSignerInfo();
					CAPI.CMSG_SIGNER_INFO cMSG_SIGNER_INFO = (CAPI.CMSG_SIGNER_INFO)Marshal.PtrToStructure(safeLocalAllocHandle.DangerousGetHandle(), typeof(CAPI.CMSG_SIGNER_INFO));
					if (System.Security.Cryptography.X509Certificates.X509Utils.MemEqual((byte*)(void*)cmsgSignerInfo.Issuer.pbData, cmsgSignerInfo.Issuer.cbData, (byte*)(void*)cMSG_SIGNER_INFO.Issuer.pbData, cMSG_SIGNER_INFO.Issuer.cbData) && System.Security.Cryptography.X509Certificates.X509Utils.MemEqual((byte*)(void*)cmsgSignerInfo.SerialNumber.pbData, cmsgSignerInfo.SerialNumber.cbData, (byte*)(void*)cMSG_SIGNER_INFO.SerialNumber.pbData, cMSG_SIGNER_INFO.SerialNumber.cbData))
					{
						return i;
					}
					safeLocalAllocHandle.Dispose();
				}
			}
			throw new CryptographicException(-2146889714);
		}

		[SecurityCritical]
		internal unsafe static CryptographicAttributeObjectCollection GetUnprotectedAttributes(SafeCryptMsgHandle safeCryptMsgHandle)
		{
			uint num = 0u;
			CryptographicAttributeObjectCollection result = new CryptographicAttributeObjectCollection();
			SafeLocalAllocHandle invalidHandle = SafeLocalAllocHandle.InvalidHandle;
			if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, 37u, 0u, invalidHandle, new IntPtr(&num)))
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error != -2146889713)
				{
					checkErr(Marshal.GetLastWin32Error());
				}
			}
			if (num != 0)
			{
				using (invalidHandle = CAPI.LocalAlloc(64u, new IntPtr(num)))
				{
					if (!CAPI.CAPISafe.CryptMsgGetParam(safeCryptMsgHandle, 37u, 0u, invalidHandle, new IntPtr(&num)))
					{
						checkErr(Marshal.GetLastWin32Error());
					}
					return new CryptographicAttributeObjectCollection(invalidHandle);
				}
			}
			return result;
		}

		[SecurityCritical]
		internal unsafe static X509IssuerSerial DecodeIssuerSerial(CAPI.CERT_ISSUER_SERIAL_NUMBER pIssuerAndSerial)
		{
			SafeLocalAllocHandle invalidHandle = SafeLocalAllocHandle.InvalidHandle;
			uint num = CAPI.CAPISafe.CertNameToStrW(65537u, new IntPtr(&pIssuerAndSerial.Issuer), 33554435u, invalidHandle, 0u);
			if (num <= 1)
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			invalidHandle = CAPI.LocalAlloc(0u, new IntPtr(checked(2u * num)));
			num = CAPI.CAPISafe.CertNameToStrW(65537u, new IntPtr(&pIssuerAndSerial.Issuer), 33554435u, invalidHandle, num);
			if (num <= 1)
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			X509IssuerSerial result = default(X509IssuerSerial);
			result.IssuerName = Marshal.PtrToStringUni(invalidHandle.DangerousGetHandle());
			byte[] array = new byte[pIssuerAndSerial.SerialNumber.cbData];
			Marshal.Copy(pIssuerAndSerial.SerialNumber.pbData, array, 0, array.Length);
			result.SerialNumber = System.Security.Cryptography.X509Certificates.X509Utils.EncodeHexStringFromInt(array);
			invalidHandle.Dispose();
			return result;
		}

		[SecuritySafeCritical]
		internal static string DecodeOctetString(byte[] encodedOctetString)
		{
			uint cbDecodedValue = 0u;
			SafeLocalAllocHandle decodedValue = null;
			if (!CAPI.DecodeObject(new IntPtr(25L), encodedOctetString, out decodedValue, out cbDecodedValue))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			if (cbDecodedValue == 0)
			{
				return string.Empty;
			}
			CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB = (CAPI.CRYPTOAPI_BLOB)Marshal.PtrToStructure(decodedValue.DangerousGetHandle(), typeof(CAPI.CRYPTOAPI_BLOB));
			if (cRYPTOAPI_BLOB.cbData == 0)
			{
				return string.Empty;
			}
			int num = (int)(cRYPTOAPI_BLOB.cbData / 2u);
			for (int i = 0; i < num; i++)
			{
				if (Marshal.ReadInt16(cRYPTOAPI_BLOB.pbData, i * 2) == 0)
				{
					num = i;
					break;
				}
			}
			string result = Marshal.PtrToStringUni(cRYPTOAPI_BLOB.pbData, num);
			decodedValue.Dispose();
			return result;
		}

		[SecuritySafeCritical]
		internal static byte[] DecodeOctetBytes(byte[] encodedOctetString)
		{
			uint cbDecodedValue = 0u;
			SafeLocalAllocHandle decodedValue = null;
			if (!CAPI.DecodeObject(new IntPtr(25L), encodedOctetString, out decodedValue, out cbDecodedValue))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			if (cbDecodedValue == 0)
			{
				return new byte[0];
			}
			using (decodedValue)
			{
				return CAPI.BlobToByteArray(decodedValue.DangerousGetHandle());
			}
		}

		internal static byte[] EncodeOctetString(string octetString)
		{
			byte[] array = new byte[2 * (octetString.Length + 1)];
			Encoding.Unicode.GetBytes(octetString, 0, octetString.Length, array, 0);
			return EncodeOctetString(array);
		}

		[SecuritySafeCritical]
		internal unsafe static byte[] EncodeOctetString(byte[] octets)
		{
			fixed (byte* value = octets)
			{
				CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB = default(CAPI.CRYPTOAPI_BLOB);
				cRYPTOAPI_BLOB.cbData = (uint)octets.Length;
				cRYPTOAPI_BLOB.pbData = new IntPtr(value);
				byte[] encodedData = new byte[0];
				if (!CAPI.EncodeObject(new IntPtr(25L), new IntPtr((long)(&cRYPTOAPI_BLOB)), out encodedData))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
				return encodedData;
			}
		}

		internal static string DecodeObjectIdentifier(byte[] encodedObjId, int offset)
		{
			StringBuilder stringBuilder = new StringBuilder("");
			if (0 < encodedObjId.Length - offset)
			{
				byte b = encodedObjId[offset];
				stringBuilder.Append(((byte)((uint)b / 40u)).ToString(null, null));
				stringBuilder.Append(".");
				stringBuilder.Append(((byte)((uint)b % 40u)).ToString(null, null));
				ulong num = 0uL;
				for (int i = offset + 1; i < encodedObjId.Length; i++)
				{
					byte b2 = encodedObjId[i];
					num = (num << 7) + (ulong)(b2 & 0x7F);
					if ((b2 & 0x80) == 0)
					{
						stringBuilder.Append(".");
						stringBuilder.Append(num.ToString(null, null));
						num = 0uL;
					}
				}
				if (num != 0L)
				{
					throw new CryptographicException(-2146885630);
				}
			}
			return stringBuilder.ToString();
		}

		internal static CmsRecipientCollection SelectRecipients(SubjectIdentifierType recipientIdentifierType)
		{
			X509Store x509Store = new X509Store("AddressBook");
			x509Store.Open(OpenFlags.OpenExistingOnly);
			X509Certificate2Collection x509Certificate2Collection = new X509Certificate2Collection(x509Store.Certificates);
			X509Certificate2Enumerator enumerator = x509Store.Certificates.GetEnumerator();
			while (enumerator.MoveNext())
			{
				X509Certificate2 current = enumerator.Current;
				if (!(current.NotBefore <= DateTime.Now) || !(current.NotAfter >= DateTime.Now))
				{
					continue;
				}
				bool flag = true;
				X509ExtensionEnumerator enumerator2 = current.Extensions.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					X509Extension current2 = enumerator2.Current;
					if (string.Compare(current2.Oid.Value, "2.5.29.15", StringComparison.OrdinalIgnoreCase) == 0)
					{
						X509KeyUsageExtension x509KeyUsageExtension = new X509KeyUsageExtension();
						x509KeyUsageExtension.CopyFrom(current2);
						if ((x509KeyUsageExtension.KeyUsages & X509KeyUsageFlags.KeyEncipherment) == 0 && (x509KeyUsageExtension.KeyUsages & X509KeyUsageFlags.KeyAgreement) == 0)
						{
							flag = false;
						}
						break;
					}
				}
				if (flag)
				{
					x509Certificate2Collection.Add(current);
				}
			}
			if (x509Certificate2Collection.Count < 1)
			{
				throw new CryptographicException(-2146889717);
			}
			X509Certificate2Collection x509Certificate2Collection2 = X509Certificate2UI.SelectFromCollection(x509Certificate2Collection, null, null, X509SelectionFlag.MultiSelection);
			if (x509Certificate2Collection2.Count < 1)
			{
				throw new CryptographicException(1223);
			}
			return new CmsRecipientCollection(recipientIdentifierType, x509Certificate2Collection2);
		}

		internal static X509Certificate2 SelectSignerCertificate()
		{
			X509Store x509Store = new X509Store();
			x509Store.Open(OpenFlags.OpenExistingOnly | OpenFlags.IncludeArchived);
			X509Certificate2Collection x509Certificate2Collection = new X509Certificate2Collection();
			X509Certificate2Enumerator enumerator = x509Store.Certificates.GetEnumerator();
			while (enumerator.MoveNext())
			{
				X509Certificate2 current = enumerator.Current;
				if (!current.HasPrivateKey || !(current.NotBefore <= DateTime.Now) || !(current.NotAfter >= DateTime.Now))
				{
					continue;
				}
				bool flag = true;
				X509ExtensionEnumerator enumerator2 = current.Extensions.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					X509Extension current2 = enumerator2.Current;
					if (string.Compare(current2.Oid.Value, "2.5.29.15", StringComparison.OrdinalIgnoreCase) == 0)
					{
						X509KeyUsageExtension x509KeyUsageExtension = new X509KeyUsageExtension();
						x509KeyUsageExtension.CopyFrom(current2);
						if ((x509KeyUsageExtension.KeyUsages & X509KeyUsageFlags.DigitalSignature) == 0 && (x509KeyUsageExtension.KeyUsages & X509KeyUsageFlags.NonRepudiation) == 0)
						{
							flag = false;
						}
						break;
					}
				}
				if (flag)
				{
					x509Certificate2Collection.Add(current);
				}
			}
			if (x509Certificate2Collection.Count < 1)
			{
				throw new CryptographicException(-2146889714);
			}
			x509Certificate2Collection = X509Certificate2UI.SelectFromCollection(x509Certificate2Collection, null, null, X509SelectionFlag.SingleSelection);
			if (x509Certificate2Collection.Count < 1)
			{
				throw new CryptographicException(1223);
			}
			return x509Certificate2Collection[0];
		}

		[SecuritySafeCritical]
		internal static AsnEncodedDataCollection GetAsnEncodedDataCollection(CAPI.CRYPT_ATTRIBUTE cryptAttribute)
		{
			AsnEncodedDataCollection asnEncodedDataCollection = new AsnEncodedDataCollection();
			Oid oid = new Oid(cryptAttribute.pszObjId);
			string value = oid.Value;
			for (uint num = 0u; num < cryptAttribute.cValue; num++)
			{
				checked
				{
					IntPtr pBlob = new IntPtr((long)cryptAttribute.rgValue + unchecked((long)num) * unchecked((long)Marshal.SizeOf(typeof(CAPI.CRYPTOAPI_BLOB))));
					Pkcs9AttributeObject asnEncodedData = new Pkcs9AttributeObject(oid, CAPI.BlobToByteArray(pBlob));
					if (CryptoConfig.CreateFromName(value) is Pkcs9AttributeObject pkcs9AttributeObject)
					{
						pkcs9AttributeObject.CopyFrom(asnEncodedData);
						asnEncodedData = pkcs9AttributeObject;
					}
					asnEncodedDataCollection.Add(asnEncodedData);
				}
			}
			return asnEncodedDataCollection;
		}

		[SecurityCritical]
		internal static AsnEncodedDataCollection GetAsnEncodedDataCollection(CAPI.CRYPT_ATTRIBUTE_TYPE_VALUE cryptAttribute)
		{
			AsnEncodedDataCollection asnEncodedDataCollection = new AsnEncodedDataCollection();
			asnEncodedDataCollection.Add(new Pkcs9AttributeObject(new Oid(cryptAttribute.pszObjId), CAPI.BlobToByteArray(cryptAttribute.Value)));
			return asnEncodedDataCollection;
		}

		[SecurityCritical]
		internal unsafe static IntPtr CreateCryptAttributes(CryptographicAttributeObjectCollection attributes)
		{
			attributes = attributes.DeepCopy();
			if (attributes.Count == 0)
			{
				return IntPtr.Zero;
			}
			uint num = 0u;
			uint num3;
			SafeLocalAllocHandle safeLocalAllocHandle;
			I_CRYPT_ATTRIBUTE* ptr;
			IntPtr intPtr;
			CryptographicAttributeObjectEnumerator enumerator3;
			checked
			{
				uint num2 = AlignedLength((uint)Marshal.SizeOf(typeof(I_CRYPT_ATTRIBUTE)));
				num3 = AlignedLength((uint)Marshal.SizeOf(typeof(CAPI.CRYPTOAPI_BLOB)));
				CryptographicAttributeObjectEnumerator enumerator = attributes.GetEnumerator();
				while (enumerator.MoveNext())
				{
					CryptographicAttributeObject current = enumerator.Current;
					num += num2;
					num += AlignedLength((uint)(current.Oid.Value.Length + 1));
					AsnEncodedDataEnumerator enumerator2 = current.Values.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						AsnEncodedData current2 = enumerator2.Current;
						num += num3;
						num += AlignedLength((uint)current2.RawData.Length);
					}
				}
				safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(num));
				ptr = unchecked((I_CRYPT_ATTRIBUTE*)(void*)safeLocalAllocHandle.DangerousGetHandle());
				intPtr = new IntPtr((long)safeLocalAllocHandle.DangerousGetHandle() + unchecked((long)num2) * unchecked((long)attributes.Count));
				enumerator3 = attributes.GetEnumerator();
			}
			while (enumerator3.MoveNext())
			{
				CryptographicAttributeObject current3 = enumerator3.Current;
				byte* ptr2 = (byte*)(void*)intPtr;
				byte[] array = new byte[checked(current3.Oid.Value.Length + 1)];
				CAPI.CRYPTOAPI_BLOB* ptr3 = (CAPI.CRYPTOAPI_BLOB*)checked(unchecked((ulong)ptr2) + unchecked((ulong)AlignedLength(checked((uint)array.Length))));
				ptr->pszObjId = (IntPtr)ptr2;
				IntPtr intPtr2;
				checked
				{
					ptr->cValue = (uint)current3.Values.Count;
					ptr->rgValue = (IntPtr)ptr3;
					Encoding.ASCII.GetBytes(current3.Oid.Value, 0, current3.Oid.Value.Length, array, 0);
					Marshal.Copy(array, 0, ptr->pszObjId, array.Length);
					intPtr2 = new IntPtr((long)ptr3 + unchecked((long)current3.Values.Count) * unchecked((long)num3));
					AsnEncodedDataEnumerator enumerator4 = current3.Values.GetEnumerator();
					while (enumerator4.MoveNext())
					{
						AsnEncodedData current4 = enumerator4.Current;
						byte[] rawData = current4.RawData;
						if (rawData.Length != 0)
						{
							ptr3->cbData = (uint)rawData.Length;
							ptr3->pbData = intPtr2;
							Marshal.Copy(rawData, 0, intPtr2, rawData.Length);
							intPtr2 = new IntPtr((long)intPtr2 + unchecked((long)AlignedLength(checked((uint)rawData.Length))));
						}
						unchecked
						{
							ptr3 = (CAPI.CRYPTOAPI_BLOB*)checked(unchecked((ulong)ptr3) + unchecked((ulong)sizeof(CAPI.CRYPTOAPI_BLOB)));
						}
					}
				}
				ptr = (I_CRYPT_ATTRIBUTE*)checked(unchecked((ulong)ptr) + unchecked((ulong)sizeof(I_CRYPT_ATTRIBUTE)));
				intPtr = intPtr2;
			}
			GC.SuppressFinalize(safeLocalAllocHandle);
			return safeLocalAllocHandle.DangerousGetHandle();
		}

		[SecuritySafeCritical]
		internal static CAPI.CMSG_SIGNER_ENCODE_INFO CreateSignerEncodeInfo(CmsSigner signer, out SafeCryptProvHandle hProv)
		{
			return CreateSignerEncodeInfo(signer, silent: false, out hProv);
		}

		[SecuritySafeCritical]
		internal unsafe static CAPI.CMSG_SIGNER_ENCODE_INFO CreateSignerEncodeInfo(CmsSigner signer, bool silent, out SafeCryptProvHandle hProv)
		{
			CAPI.CMSG_SIGNER_ENCODE_INFO result = new CAPI.CMSG_SIGNER_ENCODE_INFO(Marshal.SizeOf(typeof(CAPI.CMSG_SIGNER_ENCODE_INFO)));
			SafeCryptProvHandle hCryptProv = SafeCryptProvHandle.InvalidHandle;
			uint keySpec = 0u;
			result.HashAlgorithm.pszObjId = signer.DigestAlgorithm.Value;
			if (string.Compare(signer.Certificate.PublicKey.Oid.Value, "1.2.840.10040.4.1", StringComparison.Ordinal) == 0)
			{
				result.HashEncryptionAlgorithm.pszObjId = "1.2.840.10040.4.3";
			}
			result.cAuthAttr = (uint)signer.SignedAttributes.Count;
			result.rgAuthAttr = CreateCryptAttributes(signer.SignedAttributes);
			result.cUnauthAttr = (uint)signer.UnsignedAttributes.Count;
			result.rgUnauthAttr = CreateCryptAttributes(signer.UnsignedAttributes);
			if (signer.SignerIdentifierType == SubjectIdentifierType.NoSignature)
			{
				result.HashEncryptionAlgorithm.pszObjId = "1.3.6.1.5.5.7.6.2";
				result.pCertInfo = IntPtr.Zero;
				result.dwKeySpec = keySpec;
				if (!CAPI.CryptAcquireContext(ref hCryptProv, null, null, 1u, 4026531840u))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
				result.hCryptProv = hCryptProv.DangerousGetHandle();
				hProv = hCryptProv;
				result.SignerId.dwIdChoice = 1u;
				X500DistinguishedName x500DistinguishedName = new X500DistinguishedName("CN=Dummy Signer");
				x500DistinguishedName.Oid = Oid.FromOidValue("1.3.6.1.4.1.311.21.9", OidGroup.ExtensionOrAttribute);
				result.SignerId.Value.IssuerSerialNumber.Issuer.cbData = (uint)x500DistinguishedName.RawData.Length;
				SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(result.SignerId.Value.IssuerSerialNumber.Issuer.cbData));
				Marshal.Copy(x500DistinguishedName.RawData, 0, safeLocalAllocHandle.DangerousGetHandle(), x500DistinguishedName.RawData.Length);
				result.SignerId.Value.IssuerSerialNumber.Issuer.pbData = safeLocalAllocHandle.DangerousGetHandle();
				GC.SuppressFinalize(safeLocalAllocHandle);
				result.SignerId.Value.IssuerSerialNumber.SerialNumber.cbData = 1u;
				SafeLocalAllocHandle safeLocalAllocHandle2 = CAPI.LocalAlloc(64u, new IntPtr(result.SignerId.Value.IssuerSerialNumber.SerialNumber.cbData));
				byte* ptr = (byte*)(void*)safeLocalAllocHandle2.DangerousGetHandle();
				*ptr = 0;
				result.SignerId.Value.IssuerSerialNumber.SerialNumber.pbData = safeLocalAllocHandle2.DangerousGetHandle();
				GC.SuppressFinalize(safeLocalAllocHandle2);
				return result;
			}
			SafeCertContextHandle certContext = System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(signer.Certificate);
			int certPrivateKey = GetCertPrivateKey(certContext, out hCryptProv, out keySpec);
			if (certPrivateKey != 0)
			{
				throw new CryptographicException(certPrivateKey);
			}
			result.dwKeySpec = keySpec;
			result.hCryptProv = hCryptProv.DangerousGetHandle();
			hProv = hCryptProv;
			CAPI.CERT_CONTEXT cERT_CONTEXT = *(CAPI.CERT_CONTEXT*)(void*)certContext.DangerousGetHandle();
			result.pCertInfo = cERT_CONTEXT.pCertInfo;
			if (signer.SignerIdentifierType == SubjectIdentifierType.SubjectKeyIdentifier)
			{
				uint pcbData = 0u;
				SafeLocalAllocHandle invalidHandle = SafeLocalAllocHandle.InvalidHandle;
				if (!CAPI.CAPISafe.CertGetCertificateContextProperty(certContext, 20u, invalidHandle, ref pcbData))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
				if (pcbData != 0)
				{
					invalidHandle = CAPI.LocalAlloc(64u, new IntPtr(pcbData));
					if (!CAPI.CAPISafe.CertGetCertificateContextProperty(certContext, 20u, invalidHandle, ref pcbData))
					{
						throw new CryptographicException(Marshal.GetLastWin32Error());
					}
					result.SignerId.dwIdChoice = 2u;
					result.SignerId.Value.KeyId.cbData = pcbData;
					result.SignerId.Value.KeyId.pbData = invalidHandle.DangerousGetHandle();
					GC.SuppressFinalize(invalidHandle);
				}
			}
			return result;
		}

		[SecurityCritical]
		internal static int GetCertPrivateKey(SafeCertContextHandle safeCertContextHandle, out SafeCryptProvHandle safeCryptProvHandle, out uint keySpec)
		{
			bool pfCallerFreeProv = false;
			uint pcbData = (uint)IntPtr.Size;
			safeCryptProvHandle = null;
			if (CAPI.CAPISafe.CertGetCertificateContextProperty(safeCertContextHandle, 78u, out var data, ref pcbData))
			{
				keySpec = 0u;
				safeCryptProvHandle = new SafeCryptProvHandle(data, safeCertContextHandle);
				return 0;
			}
			CspParameters parameters = new CspParameters();
			if (!System.Security.Cryptography.X509Certificates.X509Utils.GetPrivateKeyInfo(safeCertContextHandle, ref parameters))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			if (string.Compare(parameters.ProviderName, "Microsoft Base Cryptographic Provider v1.0", StringComparison.OrdinalIgnoreCase) == 0)
			{
				SafeCryptProvHandle hCryptProv = SafeCryptProvHandle.InvalidHandle;
				if (CAPI.CryptAcquireContext(ref hCryptProv, parameters.KeyContainerName, "Microsoft Enhanced Cryptographic Provider v1.0", 1u, 0u) || CAPI.CryptAcquireContext(ref hCryptProv, parameters.KeyContainerName, "Microsoft Strong Cryptographic Provider", 1u, 0u))
				{
					safeCryptProvHandle = hCryptProv;
				}
			}
			keySpec = (uint)parameters.KeyNumber;
			int result = 0;
			uint num = 6u;
			if (parameters.ProviderType == 0)
			{
				num |= 0x20000u;
			}
			if (safeCryptProvHandle == null || safeCryptProvHandle.IsInvalid)
			{
				data = IntPtr.Zero;
				if (CAPI.CAPISafe.CryptAcquireCertificatePrivateKey(safeCertContextHandle, num, IntPtr.Zero, ref data, ref keySpec, ref pfCallerFreeProv))
				{
					safeCryptProvHandle = new SafeCryptProvHandle(data, pfCallerFreeProv);
				}
				else
				{
					result = Marshal.GetHRForLastWin32Error();
				}
			}
			return result;
		}

		[SecuritySafeCritical]
		internal static X509Certificate2Collection CreateBagOfCertificates(CmsSigner signer)
		{
			X509Certificate2Collection x509Certificate2Collection = new X509Certificate2Collection();
			x509Certificate2Collection.AddRange(signer.Certificates);
			if (signer.IncludeOption != 0)
			{
				if (signer.IncludeOption == X509IncludeOption.EndCertOnly)
				{
					x509Certificate2Collection.Add(signer.Certificate);
				}
				else
				{
					int num = 1;
					X509Chain x509Chain = new X509Chain();
					x509Chain.Build(signer.Certificate);
					if (x509Chain.ChainStatus.Length != 0 && (x509Chain.ChainStatus[0].Status & X509ChainStatusFlags.PartialChain) == X509ChainStatusFlags.PartialChain)
					{
						throw new CryptographicException(-2146762486);
					}
					if (signer.IncludeOption == X509IncludeOption.WholeChain)
					{
						num = x509Chain.ChainElements.Count;
					}
					else if (x509Chain.ChainElements.Count > 1)
					{
						num = x509Chain.ChainElements.Count - 1;
					}
					for (int i = 0; i < num; i++)
					{
						x509Certificate2Collection.Add(x509Chain.ChainElements[i].Certificate);
					}
				}
			}
			return x509Certificate2Collection;
		}

		[SecurityCritical]
		internal unsafe static SafeLocalAllocHandle CreateEncodedCertBlob(X509Certificate2Collection certificates)
		{
			SafeLocalAllocHandle safeLocalAllocHandle = SafeLocalAllocHandle.InvalidHandle;
			certificates = new X509Certificate2Collection(certificates);
			if (certificates.Count > 0)
			{
				safeLocalAllocHandle = CAPI.LocalAlloc(0u, new IntPtr(checked(certificates.Count * Marshal.SizeOf(typeof(CAPI.CRYPTOAPI_BLOB)))));
				CAPI.CRYPTOAPI_BLOB* ptr = (CAPI.CRYPTOAPI_BLOB*)(void*)safeLocalAllocHandle.DangerousGetHandle();
				X509Certificate2Enumerator enumerator = certificates.GetEnumerator();
				while (enumerator.MoveNext())
				{
					X509Certificate2 current = enumerator.Current;
					SafeCertContextHandle certContext = System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(current);
					CAPI.CERT_CONTEXT cERT_CONTEXT = *(CAPI.CERT_CONTEXT*)(void*)certContext.DangerousGetHandle();
					ptr->cbData = cERT_CONTEXT.cbCertEncoded;
					ptr->pbData = cERT_CONTEXT.pbCertEncoded;
					ptr = (CAPI.CRYPTOAPI_BLOB*)checked(unchecked((ulong)ptr) + unchecked((ulong)sizeof(CAPI.CRYPTOAPI_BLOB)));
				}
			}
			return safeLocalAllocHandle;
		}

		[SecuritySafeCritical]
		internal unsafe static uint AddCertsToMessage(SafeCryptMsgHandle safeCryptMsgHandle, X509Certificate2Collection bagOfCerts, X509Certificate2Collection chainOfCerts)
		{
			uint num = 0u;
			X509Certificate2Enumerator enumerator = chainOfCerts.GetEnumerator();
			while (enumerator.MoveNext())
			{
				X509Certificate2 current = enumerator.Current;
				X509Certificate2Collection x509Certificate2Collection = bagOfCerts.Find(X509FindType.FindByThumbprint, current.Thumbprint, validOnly: false);
				if (x509Certificate2Collection.Count == 0)
				{
					SafeCertContextHandle certContext = System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(current);
					CAPI.CERT_CONTEXT cERT_CONTEXT = *(CAPI.CERT_CONTEXT*)(void*)certContext.DangerousGetHandle();
					CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB = default(CAPI.CRYPTOAPI_BLOB);
					cRYPTOAPI_BLOB.cbData = cERT_CONTEXT.cbCertEncoded;
					cRYPTOAPI_BLOB.pbData = cERT_CONTEXT.pbCertEncoded;
					if (!CAPI.CryptMsgControl(safeCryptMsgHandle, 0u, 10u, new IntPtr((long)(&cRYPTOAPI_BLOB))))
					{
						throw new CryptographicException(Marshal.GetLastWin32Error());
					}
					num++;
				}
			}
			return num;
		}

		internal static X509Certificate2 FindCertificate(SubjectIdentifier identifier, X509Certificate2Collection certificates)
		{
			X509Certificate2 result = null;
			if (certificates != null && certificates.Count > 0)
			{
				switch (identifier.Type)
				{
				case SubjectIdentifierType.IssuerAndSerialNumber:
				{
					X509Certificate2Collection x509Certificate2Collection = certificates.Find(X509FindType.FindByIssuerDistinguishedName, ((X509IssuerSerial)identifier.Value).IssuerName, validOnly: false);
					if (x509Certificate2Collection.Count > 0)
					{
						x509Certificate2Collection = x509Certificate2Collection.Find(X509FindType.FindBySerialNumber, ((X509IssuerSerial)identifier.Value).SerialNumber, validOnly: false);
						if (x509Certificate2Collection.Count > 0)
						{
							result = x509Certificate2Collection[0];
						}
					}
					break;
				}
				case SubjectIdentifierType.SubjectKeyIdentifier:
				{
					X509Certificate2Collection x509Certificate2Collection = certificates.Find(X509FindType.FindBySubjectKeyIdentifier, identifier.Value, validOnly: false);
					if (x509Certificate2Collection.Count > 0)
					{
						result = x509Certificate2Collection[0];
					}
					break;
				}
				}
			}
			return result;
		}

		private static void checkErr(int err)
		{
			if (-2146889724 != err)
			{
				throw new CryptographicException(err);
			}
		}

		[SecuritySafeCritical]
		internal unsafe static X509Certificate2 CreateDummyCertificate(CspParameters parameters)
		{
			SafeCertContextHandle invalidHandle = SafeCertContextHandle.InvalidHandle;
			SafeCryptProvHandle hCryptProv = SafeCryptProvHandle.InvalidHandle;
			uint num = 0u;
			if ((parameters.Flags & CspProviderFlags.UseMachineKeyStore) != 0)
			{
				num |= 0x20u;
			}
			if ((parameters.Flags & CspProviderFlags.UseDefaultKeyContainer) != 0)
			{
				num |= 0xF0000000u;
			}
			if ((parameters.Flags & CspProviderFlags.NoPrompt) != 0)
			{
				num |= 0x40u;
			}
			if (!CAPI.CryptAcquireContext(ref hCryptProv, parameters.KeyContainerName, parameters.ProviderName, (uint)parameters.ProviderType, num))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			CAPI.CRYPT_KEY_PROV_INFO cRYPT_KEY_PROV_INFO = default(CAPI.CRYPT_KEY_PROV_INFO);
			cRYPT_KEY_PROV_INFO.pwszProvName = parameters.ProviderName;
			cRYPT_KEY_PROV_INFO.pwszContainerName = parameters.KeyContainerName;
			cRYPT_KEY_PROV_INFO.dwProvType = (uint)parameters.ProviderType;
			cRYPT_KEY_PROV_INFO.dwKeySpec = (uint)parameters.KeyNumber;
			cRYPT_KEY_PROV_INFO.dwFlags = (((parameters.Flags & CspProviderFlags.UseMachineKeyStore) == CspProviderFlags.UseMachineKeyStore) ? 32u : 0u);
			SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(CAPI.CRYPT_KEY_PROV_INFO))));
			Marshal.StructureToPtr((object)cRYPT_KEY_PROV_INFO, safeLocalAllocHandle.DangerousGetHandle(), fDeleteOld: false);
			CAPI.CRYPT_ALGORITHM_IDENTIFIER cRYPT_ALGORITHM_IDENTIFIER = default(CAPI.CRYPT_ALGORITHM_IDENTIFIER);
			cRYPT_ALGORITHM_IDENTIFIER.pszObjId = "1.3.14.3.2.29";
			SafeLocalAllocHandle safeLocalAllocHandle2 = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(CAPI.CRYPT_ALGORITHM_IDENTIFIER))));
			Marshal.StructureToPtr((object)cRYPT_ALGORITHM_IDENTIFIER, safeLocalAllocHandle2.DangerousGetHandle(), fDeleteOld: false);
			X500DistinguishedName x500DistinguishedName = new X500DistinguishedName("cn=CMS Signer Dummy Certificate");
			fixed (byte* value = x500DistinguishedName.RawData)
			{
				CAPI.CRYPTOAPI_BLOB cRYPTOAPI_BLOB = default(CAPI.CRYPTOAPI_BLOB);
				cRYPTOAPI_BLOB.cbData = (uint)x500DistinguishedName.RawData.Length;
				cRYPTOAPI_BLOB.pbData = new IntPtr(value);
				invalidHandle = CAPI.CAPIUnsafe.CertCreateSelfSignCertificate(hCryptProv, new IntPtr(&cRYPTOAPI_BLOB), 1u, safeLocalAllocHandle.DangerousGetHandle(), safeLocalAllocHandle2.DangerousGetHandle(), IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);
			}
			Marshal.DestroyStructure(safeLocalAllocHandle.DangerousGetHandle(), typeof(CAPI.CRYPT_KEY_PROV_INFO));
			safeLocalAllocHandle.Dispose();
			Marshal.DestroyStructure(safeLocalAllocHandle2.DangerousGetHandle(), typeof(CAPI.CRYPT_ALGORITHM_IDENTIFIER));
			safeLocalAllocHandle2.Dispose();
			if (invalidHandle == null || invalidHandle.IsInvalid)
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			X509Certificate2 result = new X509Certificate2(invalidHandle.DangerousGetHandle());
			invalidHandle.Dispose();
			return result;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> class enables signing and verifying of CMS/PKCS #7 messages.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SignedCms
	{
		[SecurityCritical]
		private SafeCryptMsgHandle m_safeCryptMsgHandle;

		private int m_version;

		private SubjectIdentifierType m_signerIdentifierType;

		private ContentInfo m_contentInfo;

		private bool m_detached;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignedCms.Version" /> property retrieves the version of the CMS/PKCS #7 message.</summary>
		/// <returns>An int value that represents the CMS/PKCS #7 message version.</returns>
		public int Version
		{
			[SecuritySafeCritical]
			get
			{
				if (m_safeCryptMsgHandle == null || m_safeCryptMsgHandle.IsInvalid)
				{
					return m_version;
				}
				return (int)PkcsUtils.GetVersion(m_safeCryptMsgHandle);
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignedCms.ContentInfo" /> property retrieves the inner contents of the encoded CMS/PKCS #7 message.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> object that represents the contents of the encoded CMS/PKCS #7 message.</returns>
		public ContentInfo ContentInfo => m_contentInfo;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignedCms.Detached" /> property retrieves whether the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> object is for a detached signature.</summary>
		/// <returns>A <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> object is for a detached signature. If this property is <see langword="true" />, the signature is detached. If this property is <see langword="false" />, the signature is not detached.</returns>
		public bool Detached => m_detached;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignedCms.Certificates" /> property retrieves the certificates associated with the encoded CMS/PKCS #7 message.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> collection that represents the set of certificates for the encoded CMS/PKCS #7 message.</returns>
		public X509Certificate2Collection Certificates
		{
			[SecuritySafeCritical]
			get
			{
				if (m_safeCryptMsgHandle == null || m_safeCryptMsgHandle.IsInvalid)
				{
					return new X509Certificate2Collection();
				}
				return PkcsUtils.GetCertificates(m_safeCryptMsgHandle);
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignedCms.SignerInfos" /> property retrieves the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection associated with the CMS/PKCS #7 message.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> object that represents the signer information for the CMS/PKCS #7 message.</returns>
		public SignerInfoCollection SignerInfos
		{
			[SecuritySafeCritical]
			get
			{
				if (m_safeCryptMsgHandle == null || m_safeCryptMsgHandle.IsInvalid)
				{
					return new SignerInfoCollection();
				}
				return new SignerInfoCollection(this);
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.#ctor" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> class.</summary>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		public SignedCms()
			: this(SubjectIdentifierType.IssuerAndSerialNumber, new ContentInfo(Oid.FromOidValue("1.2.840.113549.1.7.1", OidGroup.ExtensionOrAttribute), new byte[0]), detached: false)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.#ctor(System.Security.Cryptography.Pkcs.SubjectIdentifierType)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> class by using the specified subject identifier type as the default subject identifier type for signers.</summary>
		/// <param name="signerIdentifierType">A <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> member that specifies the default subject identifier type for signers.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		public SignedCms(SubjectIdentifierType signerIdentifierType)
			: this(signerIdentifierType, new ContentInfo(Oid.FromOidValue("1.2.840.113549.1.7.1", OidGroup.ExtensionOrAttribute), new byte[0]), detached: false)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.#ctor(System.Security.Cryptography.Pkcs.ContentInfo)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> class by using the specified content information as the inner content.</summary>
		/// <param name="contentInfo">A <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> object that specifies the content information as the inner content of the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> message.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		public SignedCms(ContentInfo contentInfo)
			: this(SubjectIdentifierType.IssuerAndSerialNumber, contentInfo, detached: false)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.#ctor(System.Security.Cryptography.Pkcs.SubjectIdentifierType,System.Security.Cryptography.Pkcs.ContentInfo)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> class by using the specified subject identifier type as the default subject identifier type for signers and content information as the inner content.</summary>
		/// <param name="signerIdentifierType">A <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> member that specifies the default subject identifier type for signers.</param>
		/// <param name="contentInfo">A <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> object that specifies the content information as the inner content of the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> message.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		public SignedCms(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo)
			: this(signerIdentifierType, contentInfo, detached: false)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.#ctor(System.Security.Cryptography.Pkcs.ContentInfo,System.Boolean)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> class by using the specified content information as the inner content and by using the detached state.</summary>
		/// <param name="contentInfo">A <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> object that specifies the content information as the inner content of the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> message.</param>
		/// <param name="detached">A <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> object is for a detached signature. If <paramref name="detached" /> is <see langword="true" />, the signature is detached. If <paramref name="detached" /> is <see langword="false" />, the signature is not detached.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		public SignedCms(ContentInfo contentInfo, bool detached)
			: this(SubjectIdentifierType.IssuerAndSerialNumber, contentInfo, detached)
		{
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.#ctor(System.Security.Cryptography.Pkcs.SubjectIdentifierType,System.Security.Cryptography.Pkcs.ContentInfo,System.Boolean)" /> constructor creates an instance of the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> class by using the specified subject identifier type as the default subject identifier type for signers, the content information as the inner content, and by using the detached state.</summary>
		/// <param name="signerIdentifierType">A <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> member that specifies the default subject identifier type for signers.</param>
		/// <param name="contentInfo">A <see cref="T:System.Security.Cryptography.Pkcs.ContentInfo" /> object that specifies the content information as the inner content of the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> message.</param>
		/// <param name="detached">A <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> object is for a detached signature. If <paramref name="detached" /> is <see langword="true" />, the signature is detached. If detached is <see langword="false" />, the signature is not detached.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		[SecuritySafeCritical]
		public SignedCms(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo, bool detached)
		{
			if (contentInfo == null)
			{
				throw new ArgumentNullException("contentInfo");
			}
			if (contentInfo.Content == null)
			{
				throw new ArgumentNullException("contentInfo.Content");
			}
			if (signerIdentifierType != SubjectIdentifierType.SubjectKeyIdentifier && signerIdentifierType != SubjectIdentifierType.IssuerAndSerialNumber && signerIdentifierType != SubjectIdentifierType.NoSignature)
			{
				signerIdentifierType = SubjectIdentifierType.IssuerAndSerialNumber;
			}
			m_safeCryptMsgHandle = SafeCryptMsgHandle.InvalidHandle;
			m_signerIdentifierType = signerIdentifierType;
			m_version = 0;
			m_contentInfo = contentInfo;
			m_detached = detached;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.Encode" /> method encodes the information in the object into a CMS/PKCS #7 message.</summary>
		/// <returns>An array of byte values that represents the encoded message. The encoded message can be decoded by the <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.Decode(System.Byte[])" /> method.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		/// <exception cref="T:System.InvalidOperationException">A method call was invalid for the object's current state.</exception>
		[SecuritySafeCritical]
		public byte[] Encode()
		{
			if (m_safeCryptMsgHandle == null || m_safeCryptMsgHandle.IsInvalid)
			{
				throw new InvalidOperationException(SecurityResources.GetResourceString("Cryptography_Cms_MessageNotSigned"));
			}
			return PkcsUtils.GetMessage(m_safeCryptMsgHandle);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.Decode(System.Byte[])" /> method decodes an encoded <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> message. Upon successful decoding, the decoded information can be retrieved from the properties of the <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> object.</summary>
		/// <param name="encodedMessage">Array of byte values that represents the encoded CMS/PKCS #7 message to be decoded.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		[SecuritySafeCritical]
		public void Decode(byte[] encodedMessage)
		{
			if (encodedMessage == null)
			{
				throw new ArgumentNullException("encodedMessage");
			}
			if (m_safeCryptMsgHandle != null && !m_safeCryptMsgHandle.IsInvalid)
			{
				m_safeCryptMsgHandle.Dispose();
			}
			m_safeCryptMsgHandle = OpenToDecode(encodedMessage, ContentInfo, Detached);
			if (!Detached)
			{
				Oid contentType = PkcsUtils.GetContentType(m_safeCryptMsgHandle);
				byte[] content = PkcsUtils.GetContent(m_safeCryptMsgHandle);
				m_contentInfo = new ContentInfo(contentType, content);
			}
		}

		/// <summary>Creates a signature and adds the signature to the CMS/PKCS #7 message.</summary>
		/// <exception cref="T:System.InvalidOperationException">.NET Framework (all versions) and .NET Core 3.0 and later: The recipient certificate is not specified.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">.NET Core version 2.2 and earlier: No signer certificate was provided.</exception>
		public void ComputeSignature()
		{
			ComputeSignature(new CmsSigner(m_signerIdentifierType), silent: true);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.ComputeSignature(System.Security.Cryptography.Pkcs.CmsSigner)" /> method creates a signature using the specified signer and adds the signature to the CMS/PKCS #7 message.</summary>
		/// <param name="signer">A <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> object that represents the signer.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public void ComputeSignature(CmsSigner signer)
		{
			ComputeSignature(signer, silent: true);
		}

		[SecuritySafeCritical]
		private static int SafeGetLastWin32Error()
		{
			return Marshal.GetLastWin32Error();
		}

		/// <summary>Creates a signature using the specified signer and adds the signature to the CMS/PKCS #7 message.</summary>
		/// <param name="signer">A <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> object that represents the signer.</param>
		/// <param name="silent">This parameter is not used.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="signer" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		/// <exception cref="T:System.InvalidOperationException">.NET Framework only: A signing certificate is not specified.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">.NET Core only: A signing certificate is not specified.</exception>
		[SecuritySafeCritical]
		public void ComputeSignature(CmsSigner signer, bool silent)
		{
			if (signer == null)
			{
				throw new ArgumentNullException("signer");
			}
			if (ContentInfo.Content.Length == 0)
			{
				throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Sign_Empty_Content"));
			}
			if (SubjectIdentifierType.NoSignature == signer.SignerIdentifierType)
			{
				if (m_safeCryptMsgHandle != null && !m_safeCryptMsgHandle.IsInvalid)
				{
					throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Cms_Sign_No_Signature_First_Signer"));
				}
				Sign(signer, silent);
				return;
			}
			if (signer.Certificate == null)
			{
				if (silent)
				{
					throw new InvalidOperationException(SecurityResources.GetResourceString("Cryptography_Cms_RecipientCertificateNotFound"));
				}
				signer.Certificate = PkcsUtils.SelectSignerCertificate();
			}
			if (!signer.Certificate.HasPrivateKey)
			{
				throw new CryptographicException(-2146893811);
			}
			CspParameters parameters = new CspParameters();
			if (System.Security.Cryptography.X509Certificates.X509Utils.GetPrivateKeyInfo(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(signer.Certificate), ref parameters))
			{
				KeyContainerPermission keyContainerPermission = new KeyContainerPermission(KeyContainerPermissionFlags.NoFlags);
				KeyContainerPermissionAccessEntry accessEntry = new KeyContainerPermissionAccessEntry(parameters, KeyContainerPermissionFlags.Open | KeyContainerPermissionFlags.Sign);
				keyContainerPermission.AccessEntries.Add(accessEntry);
				keyContainerPermission.Demand();
			}
			if (m_safeCryptMsgHandle == null || m_safeCryptMsgHandle.IsInvalid)
			{
				Sign(signer, silent);
			}
			else
			{
				CoSign(signer, silent);
			}
		}

		/// <summary>Removes the signature at the specified index of the <see cref="P:System.Security.Cryptography.Pkcs.SignedCms.SignerInfos" /> collection.</summary>
		/// <param name="index">The zero-based index of the signature to remove.</param>
		/// <exception cref="T:System.InvalidOperationException">A CMS/PKCS #7 message is not signed, and <paramref name="index" /> is invalid.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="index" /> is less than zero.  
		/// -or-  
		/// <paramref name="index" /> is greater than the signature count minus 1.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The signature could not be removed.  
		///  -or-  
		///  An internal cryptographic error occurred.</exception>
		[SecuritySafeCritical]
		public unsafe void RemoveSignature(int index)
		{
			if (m_safeCryptMsgHandle == null || m_safeCryptMsgHandle.IsInvalid)
			{
				throw new InvalidOperationException(SecurityResources.GetResourceString("Cryptography_Cms_MessageNotSigned"));
			}
			uint num = 0u;
			uint num2 = (uint)Marshal.SizeOf(typeof(uint));
			if (!CAPI.CAPISafe.CryptMsgGetParam(m_safeCryptMsgHandle, 5u, 0u, new IntPtr(&num), new IntPtr(&num2)))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			if (index < 0 || index >= (int)num)
			{
				throw new ArgumentOutOfRangeException("index", SecurityResources.GetResourceString("ArgumentOutOfRange_Index"));
			}
			if (!CAPI.CryptMsgControl(m_safeCryptMsgHandle, 0u, 7u, new IntPtr(&index)))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.RemoveSignature(System.Security.Cryptography.Pkcs.SignerInfo)" /> method removes the signature for the specified <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object.</summary>
		/// <param name="signerInfo">A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object that represents the countersignature being removed.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of an argument was outside the allowable range of values as defined by the called method.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		[SecuritySafeCritical]
		public void RemoveSignature(SignerInfo signerInfo)
		{
			if (signerInfo == null)
			{
				throw new ArgumentNullException("signerInfo");
			}
			RemoveSignature(PkcsUtils.GetSignerIndex(m_safeCryptMsgHandle, signerInfo, 0));
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.CheckSignature(System.Boolean)" /> method verifies the digital signatures on the signed CMS/PKCS #7 message and, optionally, validates the signers' certificates.</summary>
		/// <param name="verifySignatureOnly">A <see cref="T:System.Boolean" /> value that specifies whether only the digital signatures are verified without the signers' certificates being validated.  
		///  If <paramref name="verifySignatureOnly" /> is <see langword="true" />, only the digital signatures are verified. If it is <see langword="false" />, the digital signatures are verified, the signers' certificates are validated, and the purposes of the certificates are validated. The purposes of a certificate are considered valid if the certificate has no key usage or if the key usage supports digital signatures or nonrepudiation.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		/// <exception cref="T:System.InvalidOperationException">A method call was invalid for the object's current state.</exception>
		public void CheckSignature(bool verifySignatureOnly)
		{
			CheckSignature(new X509Certificate2Collection(), verifySignatureOnly);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" /> method verifies the digital signatures on the signed CMS/PKCS #7 message by using the specified collection of certificates and, optionally, validates the signers' certificates.</summary>
		/// <param name="extraStore">An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> object that can be used to validate the certificate chain. If no additional certificates are to be used to validate the certificate chain, use <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.CheckSignature(System.Boolean)" /> instead of <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" />.</param>
		/// <param name="verifySignatureOnly">A <see cref="T:System.Boolean" /> value that specifies whether only the digital signatures are verified without the signers' certificates being validated.  
		///  If <paramref name="verifySignatureOnly" /> is <see langword="true" />, only the digital signatures are verified. If it is <see langword="false" />, the digital signatures are verified, the signers' certificates are validated, and the purposes of the certificates are validated. The purposes of a certificate are considered valid if the certificate has no key usage or if the key usage supports digital signatures or nonrepudiation.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		/// <exception cref="T:System.InvalidOperationException">A method call was invalid for the object's current state.</exception>
		[SecuritySafeCritical]
		public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly)
		{
			if (m_safeCryptMsgHandle == null || m_safeCryptMsgHandle.IsInvalid)
			{
				throw new InvalidOperationException(SecurityResources.GetResourceString("Cryptography_Cms_MessageNotSigned"));
			}
			if (extraStore == null)
			{
				throw new ArgumentNullException("extraStore");
			}
			CheckSignatures(SignerInfos, extraStore, verifySignatureOnly);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.CheckHash" /> method verifies the data integrity of the CMS/PKCS #7 message. <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.CheckHash" /> is a specialized method used in specific security infrastructure applications that only wish to check the hash of the CMS message, rather than perform a full digital signature verification. <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.CheckHash" /> does not authenticate the author nor sender of the message because this method does not involve verifying a digital signature. For general-purpose checking of the integrity and authenticity of a CMS/PKCS #7 message, use the <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.CheckSignature(System.Boolean)" /> or <see cref="M:System.Security.Cryptography.Pkcs.SignedCms.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" /> methods.</summary>
		/// <exception cref="T:System.InvalidOperationException">A method call was invalid for the object's current state.</exception>
		[SecuritySafeCritical]
		public void CheckHash()
		{
			if (m_safeCryptMsgHandle == null || m_safeCryptMsgHandle.IsInvalid)
			{
				throw new InvalidOperationException(SecurityResources.GetResourceString("Cryptography_Cms_MessageNotSigned"));
			}
			CheckHashes(SignerInfos);
		}

		[SecurityCritical]
		internal SafeCryptMsgHandle GetCryptMsgHandle()
		{
			return m_safeCryptMsgHandle;
		}

		[SecuritySafeCritical]
		internal void ReopenToDecode()
		{
			byte[] message = PkcsUtils.GetMessage(m_safeCryptMsgHandle);
			if (m_safeCryptMsgHandle != null && !m_safeCryptMsgHandle.IsInvalid)
			{
				m_safeCryptMsgHandle.Dispose();
			}
			m_safeCryptMsgHandle = OpenToDecode(message, ContentInfo, Detached);
		}

		[SecuritySafeCritical]
		private unsafe void Sign(CmsSigner signer, bool silent)
		{
			SafeCryptMsgHandle safeCryptMsgHandle = null;
			CAPI.CMSG_SIGNED_ENCODE_INFO cMSG_SIGNED_ENCODE_INFO = new CAPI.CMSG_SIGNED_ENCODE_INFO(Marshal.SizeOf(typeof(CAPI.CMSG_SIGNED_ENCODE_INFO)));
			SafeCryptProvHandle hProv;
			CAPI.CMSG_SIGNER_ENCODE_INFO cMSG_SIGNER_ENCODE_INFO = PkcsUtils.CreateSignerEncodeInfo(signer, silent, out hProv);
			byte[] encodedMessage = null;
			try
			{
				SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(0u, new IntPtr(Marshal.SizeOf(typeof(CAPI.CMSG_SIGNER_ENCODE_INFO))));
				try
				{
					Marshal.StructureToPtr((object)cMSG_SIGNER_ENCODE_INFO, safeLocalAllocHandle.DangerousGetHandle(), fDeleteOld: false);
					X509Certificate2Collection x509Certificate2Collection = PkcsUtils.CreateBagOfCertificates(signer);
					SafeLocalAllocHandle safeLocalAllocHandle2 = PkcsUtils.CreateEncodedCertBlob(x509Certificate2Collection);
					cMSG_SIGNED_ENCODE_INFO.cSigners = 1u;
					cMSG_SIGNED_ENCODE_INFO.rgSigners = safeLocalAllocHandle.DangerousGetHandle();
					cMSG_SIGNED_ENCODE_INFO.cCertEncoded = (uint)x509Certificate2Collection.Count;
					if (x509Certificate2Collection.Count > 0)
					{
						cMSG_SIGNED_ENCODE_INFO.rgCertEncoded = safeLocalAllocHandle2.DangerousGetHandle();
					}
					safeCryptMsgHandle = ((string.Compare(ContentInfo.ContentType.Value, "1.2.840.113549.1.7.1", StringComparison.OrdinalIgnoreCase) != 0) ? CAPI.CryptMsgOpenToEncode(65537u, Detached ? 4u : 0u, 2u, new IntPtr(&cMSG_SIGNED_ENCODE_INFO), ContentInfo.ContentType.Value, IntPtr.Zero) : CAPI.CryptMsgOpenToEncode(65537u, Detached ? 4u : 0u, 2u, new IntPtr(&cMSG_SIGNED_ENCODE_INFO), IntPtr.Zero, IntPtr.Zero));
					if (safeCryptMsgHandle == null || safeCryptMsgHandle.IsInvalid)
					{
						throw new CryptographicException(Marshal.GetLastWin32Error());
					}
					if (ContentInfo.Content.Length != 0 && !CAPI.CAPISafe.CryptMsgUpdate(safeCryptMsgHandle, ContentInfo.pContent, (uint)ContentInfo.Content.Length, fFinal: true))
					{
						throw new CryptographicException(Marshal.GetLastWin32Error());
					}
					encodedMessage = PkcsUtils.GetContent(safeCryptMsgHandle);
					safeCryptMsgHandle.Dispose();
					safeLocalAllocHandle2.Dispose();
				}
				finally
				{
					Marshal.DestroyStructure(safeLocalAllocHandle.DangerousGetHandle(), typeof(CAPI.CMSG_SIGNER_ENCODE_INFO));
					safeLocalAllocHandle.Dispose();
				}
			}
			finally
			{
				cMSG_SIGNER_ENCODE_INFO.Dispose();
				hProv.Dispose();
			}
			safeCryptMsgHandle = OpenToDecode(encodedMessage, ContentInfo, Detached);
			if (m_safeCryptMsgHandle != null && !m_safeCryptMsgHandle.IsInvalid)
			{
				m_safeCryptMsgHandle.Dispose();
			}
			m_safeCryptMsgHandle = safeCryptMsgHandle;
			GC.KeepAlive(signer);
		}

		[SecuritySafeCritical]
		private void CoSign(CmsSigner signer, bool silent)
		{
			SafeCryptProvHandle hProv;
			CAPI.CMSG_SIGNER_ENCODE_INFO cMSG_SIGNER_ENCODE_INFO = PkcsUtils.CreateSignerEncodeInfo(signer, silent, out hProv);
			try
			{
				SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(CAPI.CMSG_SIGNER_ENCODE_INFO))));
				try
				{
					Marshal.StructureToPtr((object)cMSG_SIGNER_ENCODE_INFO, safeLocalAllocHandle.DangerousGetHandle(), fDeleteOld: false);
					if (!CAPI.CryptMsgControl(m_safeCryptMsgHandle, 0u, 6u, safeLocalAllocHandle.DangerousGetHandle()))
					{
						throw new CryptographicException(Marshal.GetLastWin32Error());
					}
				}
				finally
				{
					Marshal.DestroyStructure(safeLocalAllocHandle.DangerousGetHandle(), typeof(CAPI.CMSG_SIGNER_ENCODE_INFO));
					safeLocalAllocHandle.Dispose();
				}
			}
			finally
			{
				cMSG_SIGNER_ENCODE_INFO.Dispose();
				hProv.Dispose();
			}
			PkcsUtils.AddCertsToMessage(m_safeCryptMsgHandle, Certificates, PkcsUtils.CreateBagOfCertificates(signer));
		}

		[SecuritySafeCritical]
		private static SafeCryptMsgHandle OpenToDecode(byte[] encodedMessage, ContentInfo contentInfo, bool detached)
		{
			SafeCryptMsgHandle safeCryptMsgHandle = CAPI.CAPISafe.CryptMsgOpenToDecode(65537u, detached ? 4u : 0u, 0u, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);
			if (safeCryptMsgHandle == null || safeCryptMsgHandle.IsInvalid)
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			if (!CAPI.CAPISafe.CryptMsgUpdate(safeCryptMsgHandle, encodedMessage, (uint)encodedMessage.Length, fFinal: true))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			if (2 != PkcsUtils.GetMessageType(safeCryptMsgHandle))
			{
				throw new CryptographicException(-2146889724);
			}
			if (detached)
			{
				byte[] content = contentInfo.Content;
				if (content != null && content.Length != 0 && !CAPI.CAPISafe.CryptMsgUpdate(safeCryptMsgHandle, content, (uint)content.Length, fFinal: true))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
			}
			return safeCryptMsgHandle;
		}

		private static void CheckSignatures(SignerInfoCollection signers, X509Certificate2Collection extraStore, bool verifySignatureOnly)
		{
			if (signers == null || signers.Count < 1)
			{
				throw new CryptographicException(-2146885618);
			}
			SignerInfoEnumerator enumerator = signers.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SignerInfo current = enumerator.Current;
				current.CheckSignature(extraStore, verifySignatureOnly);
				if (current.CounterSignerInfos.Count > 0)
				{
					CheckSignatures(current.CounterSignerInfos, extraStore, verifySignatureOnly);
				}
			}
		}

		private static void CheckHashes(SignerInfoCollection signers)
		{
			if (signers == null || signers.Count < 1)
			{
				throw new CryptographicException(-2146885618);
			}
			SignerInfoEnumerator enumerator = signers.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SignerInfo current = enumerator.Current;
				if (current.SignerIdentifier.Type == SubjectIdentifierType.NoSignature)
				{
					current.CheckHash();
				}
			}
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> class represents a signer associated with a <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> object that represents a CMS/PKCS #7 message.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SignerInfo
	{
		private X509Certificate2 m_certificate;

		private SubjectIdentifier m_signerIdentifier;

		private CryptographicAttributeObjectCollection m_signedAttributes;

		private CryptographicAttributeObjectCollection m_unsignedAttributes;

		private SignedCms m_signedCms;

		private SignerInfo m_parentSignerInfo;

		private byte[] m_encodedSignerInfo;

		[SecurityCritical]
		private SafeLocalAllocHandle m_pbCmsgSignerInfo;

		private CAPI.CMSG_SIGNER_INFO m_cmsgSignerInfo;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" /> property retrieves the signer information version.</summary>
		/// <returns>An int value that specifies the signer information version.</returns>
		public int Version => (int)m_cmsgSignerInfo.dwVersion;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" /> property retrieves the signing certificate associated with the signer information.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object that represents the signing certificate.</returns>
		public X509Certificate2 Certificate
		{
			get
			{
				if (m_certificate == null)
				{
					m_certificate = PkcsUtils.FindCertificate(SignerIdentifier, m_signedCms.Certificates);
				}
				return m_certificate;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" /> property retrieves the certificate identifier of the signer associated with the signer information.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifier" /> object that uniquely identifies the certificate associated with the signer information.</returns>
		public SubjectIdentifier SignerIdentifier
		{
			[SecuritySafeCritical]
			get
			{
				if (m_signerIdentifier == null)
				{
					m_signerIdentifier = new SubjectIdentifier(m_cmsgSignerInfo);
				}
				return m_signerIdentifier;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" /> property retrieves the <see cref="T:System.Security.Cryptography.Oid" /> object that represents the hash algorithm used in the computation of the signatures.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.Oid" /> object that represents the hash algorithm used with the signature.</returns>
		public Oid DigestAlgorithm => new Oid(m_cmsgSignerInfo.HashAlgorithm.pszObjId);

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" /> property retrieves the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection of signed attributes that is associated with the signer information. Signed attributes are signed along with the rest of the message content.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection that represents the signed attributes. If there are no signed attributes, the property is an empty collection.</returns>
		public CryptographicAttributeObjectCollection SignedAttributes
		{
			[SecuritySafeCritical]
			get
			{
				if (m_signedAttributes == null)
				{
					m_signedAttributes = new CryptographicAttributeObjectCollection(m_cmsgSignerInfo.AuthAttrs);
				}
				return m_signedAttributes;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" /> property retrieves the <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection of unsigned attributes that is associated with the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> content. Unsigned attributes can be modified without invalidating the signature.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> collection that represents the unsigned attributes. If there are no unsigned attributes, the property is an empty collection.</returns>
		public CryptographicAttributeObjectCollection UnsignedAttributes
		{
			[SecuritySafeCritical]
			get
			{
				if (m_unsignedAttributes == null)
				{
					m_unsignedAttributes = new CryptographicAttributeObjectCollection(m_cmsgSignerInfo.UnauthAttrs);
				}
				return m_unsignedAttributes;
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" /> property retrieves the set of counter signers associated with the signer information.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection that represents the counter signers for the signer information. If there are no counter signers, the property is an empty collection.</returns>
		public SignerInfoCollection CounterSignerInfos
		{
			get
			{
				if (m_parentSignerInfo != null)
				{
					return new SignerInfoCollection();
				}
				return new SignerInfoCollection(m_signedCms, this);
			}
		}

		/// <summary>Gets the identifier for the signature algorithm used by the current <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object.</summary>
		/// <returns>The identifier for the signature algorithm used by the current <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object.</returns>
		public Oid SignatureAlgorithm => new Oid(m_cmsgSignerInfo.HashEncryptionAlgorithm.pszObjId);

		private SignerInfo()
		{
		}

		[SecurityCritical]
		internal SignerInfo(SignedCms signedCms, SafeLocalAllocHandle pbCmsgSignerInfo)
		{
			m_signedCms = signedCms;
			m_parentSignerInfo = null;
			m_encodedSignerInfo = null;
			m_pbCmsgSignerInfo = pbCmsgSignerInfo;
			m_cmsgSignerInfo = (CAPI.CMSG_SIGNER_INFO)Marshal.PtrToStructure(pbCmsgSignerInfo.DangerousGetHandle(), typeof(CAPI.CMSG_SIGNER_INFO));
		}

		[SecuritySafeCritical]
		internal unsafe SignerInfo(SignedCms signedCms, SignerInfo parentSignerInfo, byte[] encodedSignerInfo)
		{
			uint cbDecodedValue = 0u;
			SafeLocalAllocHandle decodedValue = SafeLocalAllocHandle.InvalidHandle;
			fixed (byte* value = &encodedSignerInfo[0])
			{
				if (!CAPI.DecodeObject(new IntPtr(500L), new IntPtr(value), (uint)encodedSignerInfo.Length, out decodedValue, out cbDecodedValue))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
			}
			m_signedCms = signedCms;
			m_parentSignerInfo = parentSignerInfo;
			m_encodedSignerInfo = (byte[])encodedSignerInfo.Clone();
			m_pbCmsgSignerInfo = decodedValue;
			m_cmsgSignerInfo = (CAPI.CMSG_SIGNER_INFO)Marshal.PtrToStructure(decodedValue.DangerousGetHandle(), typeof(CAPI.CMSG_SIGNER_INFO));
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.ComputeCounterSignature" /> method prompts the user to select a signing certificate, creates a countersignature, and adds the signature to the CMS/PKCS #7 message. Countersignatures are restricted to one level.</summary>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public void ComputeCounterSignature()
		{
			ComputeCounterSignature(new CmsSigner((m_signedCms.Version != 2) ? SubjectIdentifierType.IssuerAndSerialNumber : SubjectIdentifierType.SubjectKeyIdentifier));
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.ComputeCounterSignature(System.Security.Cryptography.Pkcs.CmsSigner)" /> method creates a countersignature by using the specified signer and adds the signature to the CMS/PKCS #7 message. Countersignatures are restricted to one level.</summary>
		/// <param name="signer">A <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> object that represents the counter signer.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		public void ComputeCounterSignature(CmsSigner signer)
		{
			if (m_parentSignerInfo != null)
			{
				throw new CryptographicException(-2147483647);
			}
			if (signer == null)
			{
				throw new ArgumentNullException("signer");
			}
			if (signer.Certificate == null)
			{
				signer.Certificate = PkcsUtils.SelectSignerCertificate();
			}
			if (!signer.Certificate.HasPrivateKey)
			{
				throw new CryptographicException(-2146893811);
			}
			CounterSign(signer);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.RemoveCounterSignature(System.Int32)" /> method removes the countersignature at the specified index of the <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" /> collection.</summary>
		/// <param name="index">The zero-based index of the countersignature to remove.</param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		[SecuritySafeCritical]
		public void RemoveCounterSignature(int index)
		{
			if (m_parentSignerInfo != null)
			{
				throw new CryptographicException(-2147483647);
			}
			RemoveCounterSignature(PkcsUtils.GetSignerIndex(m_signedCms.GetCryptMsgHandle(), this, 0), index);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.RemoveCounterSignature(System.Security.Cryptography.Pkcs.SignerInfo)" /> method removes the countersignature for the specified <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object.</summary>
		/// <param name="counterSignerInfo">A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object that represents the countersignature being removed.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of an argument was outside the allowable range of values as defined by the called method.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		[SecuritySafeCritical]
		public void RemoveCounterSignature(SignerInfo counterSignerInfo)
		{
			if (m_parentSignerInfo != null)
			{
				throw new CryptographicException(-2147483647);
			}
			if (counterSignerInfo == null)
			{
				throw new ArgumentNullException("counterSignerInfo");
			}
			CryptographicAttributeObjectEnumerator enumerator = UnsignedAttributes.GetEnumerator();
			while (enumerator.MoveNext())
			{
				CryptographicAttributeObject current = enumerator.Current;
				if (string.Compare(current.Oid.Value, "1.2.840.113549.1.9.6", StringComparison.OrdinalIgnoreCase) != 0)
				{
					continue;
				}
				for (int i = 0; i < current.Values.Count; i++)
				{
					AsnEncodedData asnEncodedData = current.Values[i];
					SignerInfo signerInfo = new SignerInfo(m_signedCms, m_parentSignerInfo, asnEncodedData.RawData);
					if (counterSignerInfo.SignerIdentifier.Type == SubjectIdentifierType.IssuerAndSerialNumber && signerInfo.SignerIdentifier.Type == SubjectIdentifierType.IssuerAndSerialNumber)
					{
						X509IssuerSerial x509IssuerSerial = (X509IssuerSerial)counterSignerInfo.SignerIdentifier.Value;
						X509IssuerSerial x509IssuerSerial2 = (X509IssuerSerial)signerInfo.SignerIdentifier.Value;
						if (string.Compare(x509IssuerSerial.IssuerName, x509IssuerSerial2.IssuerName, StringComparison.OrdinalIgnoreCase) == 0 && string.Compare(x509IssuerSerial.SerialNumber, x509IssuerSerial2.SerialNumber, StringComparison.OrdinalIgnoreCase) == 0)
						{
							RemoveCounterSignature(PkcsUtils.GetSignerIndex(m_signedCms.GetCryptMsgHandle(), this, 0), i);
							return;
						}
					}
					else if (counterSignerInfo.SignerIdentifier.Type == SubjectIdentifierType.SubjectKeyIdentifier && signerInfo.SignerIdentifier.Type == SubjectIdentifierType.SubjectKeyIdentifier)
					{
						string strA = counterSignerInfo.SignerIdentifier.Value as string;
						string strB = signerInfo.SignerIdentifier.Value as string;
						if (string.Compare(strA, strB, StringComparison.OrdinalIgnoreCase) == 0)
						{
							RemoveCounterSignature(PkcsUtils.GetSignerIndex(m_signedCms.GetCryptMsgHandle(), this, 0), i);
							return;
						}
					}
				}
			}
			throw new CryptographicException(-2146889714);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Boolean)" /> method verifies the digital signature of the message and, optionally, validates the certificate.</summary>
		/// <param name="verifySignatureOnly">A bool value that specifies whether only the digital signature is verified. If <paramref name="verifySignatureOnly" /> is <see langword="true" />, only the signature is verified. If <paramref name="verifySignatureOnly" /> is <see langword="false" />, the digital signature is verified, the certificate chain is validated, and the purposes of the certificates are validated. The purposes of the certificate are considered valid if the certificate has no key usage or if the key usage supports digital signature or nonrepudiation.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		/// <exception cref="T:System.InvalidOperationException">A method call was invalid for the object's current state.</exception>
		public void CheckSignature(bool verifySignatureOnly)
		{
			CheckSignature(new X509Certificate2Collection(), verifySignatureOnly);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" /> method verifies the digital signature of the message by using the specified collection of certificates and, optionally, validates the certificate.</summary>
		/// <param name="extraStore">An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> object that can be used to validate the chain. If no additional certificates are to be used to validate the chain, use <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Boolean)" /> instead of <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" />.</param>
		/// <param name="verifySignatureOnly">A bool value that specifies whether only the digital signature is verified. If <paramref name="verifySignatureOnly" /> is <see langword="true" />, only the signature is verified. If <paramref name="verifySignatureOnly" /> is <see langword="false" />, the digital signature is verified, the certificate chain is validated, and the purposes of the certificates are validated. The purposes of the certificate are considered valid if the certificate has no key usage or if the key usage supports digital signature or nonrepudiation.</param>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		/// <exception cref="T:System.InvalidOperationException">A method call was invalid for the object's current state.</exception>
		public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly)
		{
			if (extraStore == null)
			{
				throw new ArgumentNullException("extraStore");
			}
			X509Certificate2 x509Certificate = Certificate;
			if (x509Certificate == null)
			{
				x509Certificate = PkcsUtils.FindCertificate(SignerIdentifier, extraStore);
				if (x509Certificate == null)
				{
					throw new CryptographicException(-2146889714);
				}
			}
			Verify(extraStore, x509Certificate, verifySignatureOnly);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckHash" /> method verifies the data integrity of the CMS/PKCS #7 message signer information. <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckHash" /> is a specialized method used in specific security infrastructure applications in which the subject uses the HashOnly member of the <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> enumeration when setting up a <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> object. <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckHash" /> does not authenticate the signer information because this method does not involve verifying a digital signature. For general-purpose checking of the integrity and authenticity of CMS/PKCS #7 message signer information and countersignatures, use the <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Boolean)" /> or <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" /> methods.</summary>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">A cryptographic operation could not be completed.</exception>
		[SecuritySafeCritical]
		public unsafe void CheckHash()
		{
			int size = Marshal.SizeOf(typeof(CAPI.CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA));
			CAPI.CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA cMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = new CAPI.CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA(size);
			cMSG_CTRL_VERIFY_SIGNATURE_EX_PARA.dwSignerType = 4u;
			cMSG_CTRL_VERIFY_SIGNATURE_EX_PARA.dwSignerIndex = (uint)PkcsUtils.GetSignerIndex(m_signedCms.GetCryptMsgHandle(), this, 0);
			if (!CAPI.CryptMsgControl(m_signedCms.GetCryptMsgHandle(), 0u, 19u, new IntPtr(&cMSG_CTRL_VERIFY_SIGNATURE_EX_PARA)))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
		}

		/// <summary>Retrieves the signature for the current <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object.</summary>
		/// <returns>The signature for the current <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object.</returns>
		[SecuritySafeCritical]
		public byte[] GetSignature()
		{
			byte[] array = new byte[m_cmsgSignerInfo.EncryptedHash.cbData];
			Marshal.Copy(m_cmsgSignerInfo.EncryptedHash.pbData, array, 0, array.Length);
			return array;
		}

		internal CAPI.CMSG_SIGNER_INFO GetCmsgSignerInfo()
		{
			return m_cmsgSignerInfo;
		}

		[SecuritySafeCritical]
		private void CounterSign(CmsSigner signer)
		{
			CspParameters parameters = new CspParameters();
			if (!System.Security.Cryptography.X509Certificates.X509Utils.GetPrivateKeyInfo(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(signer.Certificate), ref parameters))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			KeyContainerPermission keyContainerPermission = new KeyContainerPermission(KeyContainerPermissionFlags.NoFlags);
			KeyContainerPermissionAccessEntry accessEntry = new KeyContainerPermissionAccessEntry(parameters, KeyContainerPermissionFlags.Open | KeyContainerPermissionFlags.Sign);
			keyContainerPermission.AccessEntries.Add(accessEntry);
			keyContainerPermission.Demand();
			uint signerIndex = (uint)PkcsUtils.GetSignerIndex(m_signedCms.GetCryptMsgHandle(), this, 0);
			SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(CAPI.CMSG_SIGNER_ENCODE_INFO))));
			SafeCryptProvHandle hProv;
			CAPI.CMSG_SIGNER_ENCODE_INFO cMSG_SIGNER_ENCODE_INFO = PkcsUtils.CreateSignerEncodeInfo(signer, out hProv);
			try
			{
				Marshal.StructureToPtr((object)cMSG_SIGNER_ENCODE_INFO, safeLocalAllocHandle.DangerousGetHandle(), fDeleteOld: false);
				if (!CAPI.CryptMsgCountersign(m_signedCms.GetCryptMsgHandle(), signerIndex, 1u, safeLocalAllocHandle.DangerousGetHandle()))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
				m_signedCms.ReopenToDecode();
			}
			finally
			{
				Marshal.DestroyStructure(safeLocalAllocHandle.DangerousGetHandle(), typeof(CAPI.CMSG_SIGNER_ENCODE_INFO));
				safeLocalAllocHandle.Dispose();
				cMSG_SIGNER_ENCODE_INFO.Dispose();
				hProv.Dispose();
			}
			PkcsUtils.AddCertsToMessage(m_signedCms.GetCryptMsgHandle(), m_signedCms.Certificates, PkcsUtils.CreateBagOfCertificates(signer));
		}

		[SecuritySafeCritical]
		private unsafe void Verify(X509Certificate2Collection extraStore, X509Certificate2 certificate, bool verifySignatureOnly)
		{
			SafeLocalAllocHandle safeLocalAllocHandle = SafeLocalAllocHandle.InvalidHandle;
			CAPI.CERT_CONTEXT cERT_CONTEXT = (CAPI.CERT_CONTEXT)Marshal.PtrToStructure(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificate).DangerousGetHandle(), typeof(CAPI.CERT_CONTEXT));
			checked
			{
				IntPtr intPtr = new IntPtr((long)cERT_CONTEXT.pCertInfo + (long)Marshal.OffsetOf(typeof(CAPI.CERT_INFO), "SubjectPublicKeyInfo"));
				IntPtr intPtr2 = new IntPtr((long)intPtr + (long)Marshal.OffsetOf(typeof(CAPI.CERT_PUBLIC_KEY_INFO), "Algorithm"));
				IntPtr intPtr3 = new IntPtr((long)intPtr2 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPT_ALGORITHM_IDENTIFIER), "Parameters"));
				IntPtr pvKey = Marshal.ReadIntPtr(intPtr2);
				if (CAPI.CryptFindOIDInfo(1u, pvKey, 3u).Algid == 8704)
				{
					bool flag = false;
					IntPtr ptr = new IntPtr((long)intPtr3 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "cbData"));
					IntPtr ptr2 = new IntPtr((long)intPtr3 + (long)Marshal.OffsetOf(typeof(CAPI.CRYPTOAPI_BLOB), "pbData"));
					if (Marshal.ReadInt32(ptr) == 0)
					{
						flag = true;
					}
					else if (Marshal.ReadIntPtr(ptr2) == IntPtr.Zero)
					{
						flag = true;
					}
					else
					{
						IntPtr ptr3 = Marshal.ReadIntPtr(ptr2);
						if ((uint)Marshal.ReadInt32(ptr3) == 5)
						{
							flag = true;
						}
					}
					if (flag)
					{
						SafeCertChainHandle ppChainContext = SafeCertChainHandle.InvalidHandle;
						System.Security.Cryptography.X509Certificates.X509Utils.BuildChain(new IntPtr(0L), System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificate), null, null, null, X509RevocationMode.NoCheck, X509RevocationFlag.ExcludeRoot, DateTime.Now, new TimeSpan(0, 0, 0), ref ppChainContext);
						ppChainContext.Dispose();
						uint pcbData = 0u;
						if (!CAPI.CAPISafe.CertGetCertificateContextProperty(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificate), 22u, safeLocalAllocHandle, ref pcbData))
						{
							throw new CryptographicException(Marshal.GetLastWin32Error());
						}
						if (pcbData != 0)
						{
							safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(pcbData));
							if (!CAPI.CAPISafe.CertGetCertificateContextProperty(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificate), 22u, safeLocalAllocHandle, ref pcbData))
							{
								throw new CryptographicException(Marshal.GetLastWin32Error());
							}
							Marshal.WriteInt32(ptr, (int)pcbData);
							Marshal.WriteIntPtr(ptr2, safeLocalAllocHandle.DangerousGetHandle());
						}
					}
				}
				if (m_parentSignerInfo == null)
				{
					if (!CAPI.CryptMsgControl(m_signedCms.GetCryptMsgHandle(), 0u, 1u, cERT_CONTEXT.pCertInfo))
					{
						throw new CryptographicException(Marshal.GetLastWin32Error());
					}
				}
				else
				{
					int num = -1;
					int num2 = 0;
					SafeLocalAllocHandle pvData;
					while (true)
					{
						try
						{
							num = PkcsUtils.GetSignerIndex(m_signedCms.GetCryptMsgHandle(), m_parentSignerInfo, num + 1);
						}
						catch (CryptographicException)
						{
							if (num2 == 0)
							{
								throw;
							}
							throw new CryptographicException(num2);
						}
						uint cbData = 0u;
						pvData = SafeLocalAllocHandle.InvalidHandle;
						PkcsUtils.GetParam(m_signedCms.GetCryptMsgHandle(), 28u, (uint)num, out pvData, out cbData);
						if (cbData == 0)
						{
							num2 = -2146885618;
							continue;
						}
						try
						{
							fixed (byte* value = m_encodedSignerInfo)
							{
								if (!CAPI.CAPISafe.CryptMsgVerifyCountersignatureEncoded(IntPtr.Zero, 65537u, pvData.DangerousGetHandle(), cbData, new IntPtr(value), (uint)m_encodedSignerInfo.Length, cERT_CONTEXT.pCertInfo))
								{
									num2 = Marshal.GetLastWin32Error();
									continue;
								}
							}
						}
						finally
						{
						}
						break;
					}
					pvData.Dispose();
				}
				if (!verifySignatureOnly)
				{
					int num3 = VerifyCertificate(certificate, extraStore);
					if (num3 != 0)
					{
						throw new CryptographicException(num3);
					}
				}
				safeLocalAllocHandle.Dispose();
			}
		}

		[SecuritySafeCritical]
		private unsafe void RemoveCounterSignature(int parentIndex, int childIndex)
		{
			if (parentIndex < 0)
			{
				throw new ArgumentOutOfRangeException("parentIndex");
			}
			if (childIndex < 0)
			{
				throw new ArgumentOutOfRangeException("childIndex");
			}
			uint cbData = 0u;
			SafeLocalAllocHandle pvData = SafeLocalAllocHandle.InvalidHandle;
			uint cbData2 = 0u;
			SafeLocalAllocHandle pvData2 = SafeLocalAllocHandle.InvalidHandle;
			uint num = 0u;
			uint num2 = 0u;
			IntPtr zero = IntPtr.Zero;
			SafeCryptMsgHandle cryptMsgHandle = m_signedCms.GetCryptMsgHandle();
			if (PkcsUtils.CmsSupported())
			{
				PkcsUtils.GetParam(cryptMsgHandle, 39u, (uint)parentIndex, out pvData, out cbData);
				CAPI.CMSG_CMS_SIGNER_INFO cMSG_CMS_SIGNER_INFO = (CAPI.CMSG_CMS_SIGNER_INFO)Marshal.PtrToStructure(pvData.DangerousGetHandle(), typeof(CAPI.CMSG_CMS_SIGNER_INFO));
				num2 = cMSG_CMS_SIGNER_INFO.UnauthAttrs.cAttr;
				zero = new IntPtr((long)cMSG_CMS_SIGNER_INFO.UnauthAttrs.rgAttr);
			}
			else
			{
				PkcsUtils.GetParam(cryptMsgHandle, 6u, (uint)parentIndex, out pvData2, out cbData2);
				CAPI.CMSG_SIGNER_INFO cMSG_SIGNER_INFO = (CAPI.CMSG_SIGNER_INFO)Marshal.PtrToStructure(pvData2.DangerousGetHandle(), typeof(CAPI.CMSG_SIGNER_INFO));
				num2 = cMSG_SIGNER_INFO.UnauthAttrs.cAttr;
				zero = new IntPtr((long)cMSG_SIGNER_INFO.UnauthAttrs.rgAttr);
			}
			for (num = 0u; num < num2; num++)
			{
				CAPI.CRYPT_ATTRIBUTE cRYPT_ATTRIBUTE = (CAPI.CRYPT_ATTRIBUTE)Marshal.PtrToStructure(zero, typeof(CAPI.CRYPT_ATTRIBUTE));
				checked
				{
					if (string.Compare(cRYPT_ATTRIBUTE.pszObjId, "1.2.840.113549.1.9.6", StringComparison.OrdinalIgnoreCase) == 0 && cRYPT_ATTRIBUTE.cValue != 0)
					{
						if (childIndex < (int)cRYPT_ATTRIBUTE.cValue)
						{
							CAPI.CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA cMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = new CAPI.CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA(Marshal.SizeOf(typeof(CAPI.CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA)));
							cMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA.dwSignerIndex = (uint)parentIndex;
							cMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA.dwUnauthAttrIndex = num;
							if (!CAPI.CryptMsgControl(cryptMsgHandle, 0u, 9u, new IntPtr(&cMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA)))
							{
								throw new CryptographicException(Marshal.GetLastWin32Error());
							}
							if (cRYPT_ATTRIBUTE.cValue <= 1)
							{
								return;
							}
							try
							{
								uint num3 = (uint)(unchecked((long)checked(cRYPT_ATTRIBUTE.cValue - 1u)) * unchecked((long)Marshal.SizeOf(typeof(CAPI.CRYPTOAPI_BLOB))));
								SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(64u, new IntPtr(num3));
								CAPI.CRYPTOAPI_BLOB* ptr;
								CAPI.CRYPTOAPI_BLOB* ptr2;
								int num4;
								unchecked
								{
									ptr = (CAPI.CRYPTOAPI_BLOB*)(void*)cRYPT_ATTRIBUTE.rgValue;
									ptr2 = (CAPI.CRYPTOAPI_BLOB*)(void*)safeLocalAllocHandle.DangerousGetHandle();
									num4 = 0;
								}
								while (num4 < (int)cRYPT_ATTRIBUTE.cValue)
								{
									if (num4 != childIndex)
									{
										*ptr2 = *ptr;
									}
									num4++;
									unchecked
									{
										ptr = (CAPI.CRYPTOAPI_BLOB*)checked(unchecked((ulong)ptr) + unchecked((ulong)sizeof(CAPI.CRYPTOAPI_BLOB)));
										ptr2 = (CAPI.CRYPTOAPI_BLOB*)checked(unchecked((ulong)ptr2) + unchecked((ulong)sizeof(CAPI.CRYPTOAPI_BLOB)));
									}
								}
								CAPI.CRYPT_ATTRIBUTE cRYPT_ATTRIBUTE2 = default(CAPI.CRYPT_ATTRIBUTE);
								cRYPT_ATTRIBUTE2.pszObjId = cRYPT_ATTRIBUTE.pszObjId;
								cRYPT_ATTRIBUTE2.cValue = cRYPT_ATTRIBUTE.cValue - 1u;
								cRYPT_ATTRIBUTE2.rgValue = safeLocalAllocHandle.DangerousGetHandle();
								SafeLocalAllocHandle safeLocalAllocHandle2 = CAPI.LocalAlloc(64u, new IntPtr(Marshal.SizeOf(typeof(CAPI.CRYPT_ATTRIBUTE))));
								Marshal.StructureToPtr((object)cRYPT_ATTRIBUTE2, safeLocalAllocHandle2.DangerousGetHandle(), fDeleteOld: false);
								byte[] encodedData;
								try
								{
									if (!CAPI.EncodeObject(new IntPtr(22L), safeLocalAllocHandle2.DangerousGetHandle(), out encodedData))
									{
										throw new CryptographicException(Marshal.GetLastWin32Error());
									}
								}
								finally
								{
									Marshal.DestroyStructure(safeLocalAllocHandle2.DangerousGetHandle(), typeof(CAPI.CRYPT_ATTRIBUTE));
									safeLocalAllocHandle2.Dispose();
								}
								try
								{
									fixed (byte* value = &encodedData[0])
									{
										CAPI.CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA cMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = new CAPI.CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA(Marshal.SizeOf(typeof(CAPI.CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA)));
										cMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA.dwSignerIndex = (uint)parentIndex;
										cMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA.blob.cbData = (uint)encodedData.Length;
										cMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA.blob.pbData = new IntPtr(value);
										if (!CAPI.CryptMsgControl(cryptMsgHandle, 0u, 8u, new IntPtr(&cMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA)))
										{
											throw new CryptographicException(Marshal.GetLastWin32Error());
										}
									}
								}
								finally
								{
								}
								safeLocalAllocHandle.Dispose();
								return;
							}
							catch (CryptographicException)
							{
								if (CAPI.EncodeObject(new IntPtr(22L), zero, out var encodedData2))
								{
									fixed (byte* value2 = &encodedData2[0])
									{
										CAPI.CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA cMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA2 = new CAPI.CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA(Marshal.SizeOf(typeof(CAPI.CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA)));
										cMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA2.dwSignerIndex = (uint)parentIndex;
										cMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA2.blob.cbData = (uint)encodedData2.Length;
										cMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA2.blob.pbData = new IntPtr(value2);
										CAPI.CryptMsgControl(cryptMsgHandle, 0u, 8u, new IntPtr(&cMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA2));
									}
								}
								throw;
							}
						}
						childIndex -= (int)cRYPT_ATTRIBUTE.cValue;
					}
					zero = new IntPtr((long)zero + Marshal.SizeOf(typeof(CAPI.CRYPT_ATTRIBUTE)));
				}
			}
			if (pvData != null && !pvData.IsInvalid)
			{
				pvData.Dispose();
			}
			if (pvData2 != null && !pvData2.IsInvalid)
			{
				pvData2.Dispose();
			}
			throw new CryptographicException(-2146885618);
		}

		[SecuritySafeCritical]
		private unsafe static int VerifyCertificate(X509Certificate2 certificate, X509Certificate2Collection extraStore)
		{
			int result = default(int);
			int num = System.Security.Cryptography.X509Certificates.X509Utils.VerifyCertificate(System.Security.Cryptography.X509Certificates.X509Utils.GetCertContext(certificate), null, null, X509RevocationMode.Online, X509RevocationFlag.ExcludeRoot, DateTime.Now, new TimeSpan(0, 0, 0), extraStore, new IntPtr(1L), new IntPtr(&result));
			if (num != 0)
			{
				return result;
			}
			X509ExtensionEnumerator enumerator = certificate.Extensions.GetEnumerator();
			while (enumerator.MoveNext())
			{
				X509Extension current = enumerator.Current;
				if (string.Compare(current.Oid.Value, "2.5.29.15", StringComparison.OrdinalIgnoreCase) == 0)
				{
					X509KeyUsageExtension x509KeyUsageExtension = new X509KeyUsageExtension();
					x509KeyUsageExtension.CopyFrom(current);
					if ((x509KeyUsageExtension.KeyUsages & X509KeyUsageFlags.DigitalSignature) == 0 && (x509KeyUsageExtension.KeyUsages & X509KeyUsageFlags.NonRepudiation) == 0)
					{
						num = -2146762480;
						break;
					}
				}
			}
			return num;
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> class represents a collection of <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> objects. <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> implements the <see cref="T:System.Collections.ICollection" /> interface.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SignerInfoCollection : ICollection, IEnumerable
	{
		private SignerInfo[] m_signerInfos;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfoCollection.Item(System.Int32)" /> property retrieves the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object at the specified index in the collection.</summary>
		/// <param name="index">An int value that represents the index in the collection. The index is zero based.</param>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object  at the specified index.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of an argument was outside the allowable range of values as defined by the called method.</exception>
		public SignerInfo this[int index]
		{
			get
			{
				if (index < 0 || index >= m_signerInfos.Length)
				{
					throw new ArgumentOutOfRangeException("index", SecurityResources.GetResourceString("ArgumentOutOfRange_Index"));
				}
				return m_signerInfos[index];
			}
		}

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfoCollection.Count" /> property retrieves the number of items in the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</summary>
		/// <returns>An int value that represents the number of items in the collection.</returns>
		public int Count => m_signerInfos.Length;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfoCollection.IsSynchronized" /> property retrieves whether access to the collection is synchronized, or thread safe. This property always returns <see langword="false" />, which means the collection is not thread safe.</summary>
		/// <returns>A <see cref="T:System.Boolean" /> value of <see langword="false" />, which means the collection is not thread safe.</returns>
		public bool IsSynchronized => false;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfoCollection.SyncRoot" /> property retrieves an <see cref="T:System.Object" /> object is used to synchronize access to the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</summary>
		/// <returns>An <see cref="T:System.Object" /> object is used to synchronize access to the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</returns>
		public object SyncRoot => this;

		internal SignerInfoCollection()
		{
			m_signerInfos = new SignerInfo[0];
		}

		[SecuritySafeCritical]
		internal unsafe SignerInfoCollection(SignedCms signedCms)
		{
			uint num = 0u;
			uint num2 = (uint)Marshal.SizeOf(typeof(uint));
			SafeCryptMsgHandle cryptMsgHandle = signedCms.GetCryptMsgHandle();
			if (!CAPI.CAPISafe.CryptMsgGetParam(cryptMsgHandle, 5u, 0u, new IntPtr(&num), new IntPtr(&num2)))
			{
				throw new CryptographicException(Marshal.GetLastWin32Error());
			}
			SignerInfo[] array = new SignerInfo[num];
			for (int i = 0; i < num; i++)
			{
				uint num3 = 0u;
				if (!CAPI.CAPISafe.CryptMsgGetParam(cryptMsgHandle, 6u, (uint)i, IntPtr.Zero, new IntPtr(&num3)))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
				SafeLocalAllocHandle safeLocalAllocHandle = CAPI.LocalAlloc(0u, new IntPtr(num3));
				if (!CAPI.CAPISafe.CryptMsgGetParam(cryptMsgHandle, 6u, (uint)i, safeLocalAllocHandle, new IntPtr(&num3)))
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
				array[i] = new SignerInfo(signedCms, safeLocalAllocHandle);
			}
			m_signerInfos = array;
		}

		[SecuritySafeCritical]
		internal SignerInfoCollection(SignedCms signedCms, SignerInfo signerInfo)
		{
			SignerInfo[] array = new SignerInfo[0];
			int num = 0;
			int num2 = 0;
			CryptographicAttributeObjectEnumerator enumerator = signerInfo.UnsignedAttributes.GetEnumerator();
			while (enumerator.MoveNext())
			{
				CryptographicAttributeObject current = enumerator.Current;
				if (current.Oid.Value == "1.2.840.113549.1.9.6")
				{
					num += current.Values.Count;
				}
			}
			array = new SignerInfo[num];
			CryptographicAttributeObjectEnumerator enumerator2 = signerInfo.UnsignedAttributes.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				CryptographicAttributeObject current2 = enumerator2.Current;
				if (current2.Oid.Value == "1.2.840.113549.1.9.6")
				{
					for (int i = 0; i < current2.Values.Count; i++)
					{
						AsnEncodedData asnEncodedData = current2.Values[i];
						array[num2++] = new SignerInfo(signedCms, signerInfo, asnEncodedData.RawData);
					}
				}
			}
			m_signerInfos = array;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfoCollection.GetEnumerator" /> method returns a <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoEnumerator" /> object for the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoEnumerator" /> object that can be used to enumerate the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</returns>
		public SignerInfoEnumerator GetEnumerator()
		{
			return new SignerInfoEnumerator(this);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfoCollection.System#Collections#IEnumerable#GetEnumerator" /> method returns a <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoEnumerator" /> object for the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoEnumerator" /> object that can be used to enumerate the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return new SignerInfoEnumerator(this);
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfoCollection.CopyTo(System.Array,System.Int32)" /> method copies the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection to an array.</summary>
		/// <param name="array">An <see cref="T:System.Array" /> object to which the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection is to be copied.</param>
		/// <param name="index">The zero-based index in <paramref name="array" /> where the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection is copied.</param>
		/// <exception cref="T:System.ArgumentException">One of the arguments provided to a method was not valid.</exception>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of an argument was outside the allowable range of values as defined by the called method.</exception>
		public void CopyTo(Array array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (array.Rank != 1)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Arg_RankMultiDimNotSupported"));
			}
			if (index < 0 || index >= array.Length)
			{
				throw new ArgumentOutOfRangeException("index", SecurityResources.GetResourceString("ArgumentOutOfRange_Index"));
			}
			if (index + Count > array.Length)
			{
				throw new ArgumentException(SecurityResources.GetResourceString("Argument_InvalidOffLen"));
			}
			for (int i = 0; i < Count; i++)
			{
				array.SetValue(this[i], index);
				index++;
			}
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfoCollection.CopyTo(System.Security.Cryptography.Pkcs.SignerInfo[],System.Int32)" /> method copies the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection to a <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> array.</summary>
		/// <param name="array">An array of <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> objects where the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection is to be copied.</param>
		/// <param name="index">The zero-based index in <paramref name="array" /> where the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection is copied.</param>
		/// <exception cref="T:System.ArgumentException">One of the arguments provided to a method was not valid.</exception>
		/// <exception cref="T:System.ArgumentNullException">A null reference was passed to a method that does not accept it as a valid argument.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of an argument was outside the allowable range of values as defined by the called method.</exception>
		public void CopyTo(SignerInfo[] array, int index)
		{
			((ICollection)this).CopyTo((Array)array, index);
		}
	}
	/// <summary>The <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoEnumerator" /> class provides enumeration functionality for the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection. <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoEnumerator" /> implements the <see cref="T:System.Collections.IEnumerator" /> interface.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class SignerInfoEnumerator : IEnumerator
	{
		private SignerInfoCollection m_signerInfos;

		private int m_current;

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfoEnumerator.Current" /> property retrieves the current <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object from the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object that represents the current signer information structure in the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</returns>
		public SignerInfo Current => m_signerInfos[m_current];

		/// <summary>The <see cref="P:System.Security.Cryptography.Pkcs.SignerInfoEnumerator.System#Collections#IEnumerator#Current" /> property retrieves the current <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object from the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object that represents the current signer information structure in the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</returns>
		object IEnumerator.Current => m_signerInfos[m_current];

		private SignerInfoEnumerator()
		{
		}

		internal SignerInfoEnumerator(SignerInfoCollection signerInfos)
		{
			m_signerInfos = signerInfos;
			m_current = -1;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfoEnumerator.MoveNext" /> method advances the enumeration to the next   <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object in the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</summary>
		/// <returns>This method returns a bool value that specifies whether the enumeration successfully advanced. If the enumeration successfully moved to the next <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object, the method returns <see langword="true" />. If the enumeration moved past the last item in the enumeration, it returns <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (m_current == m_signerInfos.Count - 1)
			{
				return false;
			}
			m_current++;
			return true;
		}

		/// <summary>The <see cref="M:System.Security.Cryptography.Pkcs.SignerInfoEnumerator.Reset" /> method resets the enumeration to the first <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> object in the <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> collection.</summary>
		public void Reset()
		{
			m_current = -1;
		}
	}
}
