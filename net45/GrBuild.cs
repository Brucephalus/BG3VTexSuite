
// E:\Graphine Granite Toolset 5.0.7\GrBuild.exe
// GrBuild, Version=1.5.0.0, Culture=neutral, PublicKeyToken=null
// Global type: <Module>
// Entry point: GrBuild.Program.Main
// Architecture: x64
// Runtime: v4.0.30319
// Hash algorithm: SHA1

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using System.Text.RegularExpressions;
using Graphine.Core;
using GrBuildLib;
using GrBuildLib.Tools;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyCompany("Graphine NV")]
[assembly: AssemblyProduct("Tile Set Builder")]
[assembly: AssemblyCopyright("Copyright Graphine NV Â© 2013-2017")]
[assembly: AssemblyInformationalVersion("5.0.7.34144")]
[assembly: AssemblyDescription("Generated by cholleme@ZELDA from master/9a8e2032016ca90aea9bc098289abc7dc1f56d8c")]
[assembly: AssemblyTitle("GrBuild")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: Guid("74fb1abe-bba0-4e42-b67a-903def907785")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: TargetFramework(".NETFramework,Version=v4.5", FrameworkDisplayName = ".NET Framework 4.5")]
[assembly: AssemblyVersion("1.5.0.0")]
namespace GrBuild
{
	public class AssemblyHelper
	{
		public static string AssemblyTitle
		{
			get
			{
				object[] customAttributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyTitleAttribute), inherit: false);
				if (customAttributes.Length != 0)
				{
					AssemblyTitleAttribute assemblyTitleAttribute = (AssemblyTitleAttribute)customAttributes[0];
					if (assemblyTitleAttribute.Title != "")
					{
						return assemblyTitleAttribute.Title;
					}
				}
				return Path.GetFileNameWithoutExtension(Assembly.GetExecutingAssembly().CodeBase);
			}
		}

		public static string AssemblyInformationalVersion
		{
			get
			{
				object[] customAttributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyInformationalVersionAttribute), inherit: false);
				if (customAttributes.Length == 0)
				{
					return "";
				}
				return ((AssemblyInformationalVersionAttribute)customAttributes[0]).InformationalVersion;
			}
		}

		public static string AssemblyDescription
		{
			get
			{
				object[] customAttributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyDescriptionAttribute), inherit: false);
				if (customAttributes.Length == 0)
				{
					return "";
				}
				return ((AssemblyDescriptionAttribute)customAttributes[0]).Description;
			}
		}

		public static string AssemblyProduct
		{
			get
			{
				object[] customAttributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyProductAttribute), inherit: false);
				if (customAttributes.Length == 0)
				{
					return "";
				}
				return ((AssemblyProductAttribute)customAttributes[0]).Product;
			}
		}

		public static string AssemblyCopyright
		{
			get
			{
				object[] customAttributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyCopyrightAttribute), inherit: false);
				if (customAttributes.Length == 0)
				{
					return "";
				}
				return ((AssemblyCopyrightAttribute)customAttributes[0]).Copyright;
			}
		}

		public static string AssemblyCompany
		{
			get
			{
				object[] customAttributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyCompanyAttribute), inherit: false);
				if (customAttributes.Length == 0)
				{
					return "";
				}
				return ((AssemblyCompanyAttribute)customAttributes[0]).Company;
			}
		}
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	internal class CommandLineOptions
	{
		[CommandLineParameter(Name = "project", RequiredSequential = true)]
		public string projectPath;

		[CommandLineParameter(Name = "new", ShortName = "n", Description = "(-n) Specify if a new project file should be created \n\n\tExample: GrBuild.exe MyProject.gproj -n")]
		public bool newProject;

		[CommandLineParameter(Name = "verbosity", ShortName = "v", ValueName = "<level>", Description = "(-v) Display this amount of information in the event log.\n\tThe available verbosity levels are:\n\tq[uiet], n[ormal], d[etailed]\n\n\tExample: --verbosity q or -v q")]
		public string verbosity;

		[CommandLineParameter(Name = "nofilelogger", ShortName = "nolog", Description = "(-nolog) Disable logging build output to a file.\n\tBy default the build output is logged to the file ProjectName.log.")]
		public bool noLog;

		public bool validate;

		[CommandLineParameter(Name = "delete", ShortName = "del", ValueName = "<assset name>", Description = "(-del) Delete an asset given the asset name.\n\tUse \"all\" to delete all assets (-del all)\n\tExample: --delete MyAsset or -del MyAsset")]
		public string assetToDelete;

		[CommandLineParameter(Name = "task", ShortName = "t", ValueName = "<task name>", Description = "(-task) Execute a build task. The available tasks are:\n\tbuild(default - build gts)\n\trebuild (clean intermediate files first then build)\n\tclean (only clean intermediate files if any found).\n\tnobuild (don't build, only run necessary processes for import/delete)\n\n\tExample: --task rebuild or -t rebuild")]
		public string task;

		[CommandLineParameter(Name = "importassets", ShortName = "i", ValueName = "<path>", Description = "(-i) Import all assets described in <file>.\n\n\tExample: --importassets myassets.xml or -i myassets.xml")]
		public string importAssetsPath;

		[CommandLineParameter(Name = "exclusive", ShortName = "e", Description = "(-e) Specifiy that the import is exclusive.\n\tExisting assets in the project that are not part of the xml file will be removed.\n\tThis option only works in combination with the importassets option\n\n\tExample: --importassets assets.xml --exclusive or -i assets.xml -e")]
		public bool exclusiveImport;

		[CommandLineParameter(Name = "config", ShortName = "c", ValueName = "<config name>", Description = "(-c) Set the configuration to use. Configurations are:\n\tfast (default), optimized.\n\tNote that intermediary files in the build process are written to\n\tthe config subfolder in the intermediary directory, e.g., './tmp/fast/pages.dat'\n\n\tExample: --config fast or -c fast", Hidden = true)]
		public string config;

		[CommandLineParameter(Name = "options", ShortName = "opt", ValueName = "name:value,name:value", Atomic = false, Description = "(-opt) Set extra options. See manual for extra options. \n\n\tExample: -opt \"Tilingmode:Hardware,MaximumAnisotropy:8,Pagesize:65536\"")]
		public string options;

		[CommandLineParameter(Name = "output", ShortName = "o", ValueName = "<path>", Atomic = false, Description = "(-o) Set output file path\n\n\tExample: -o \"OutputFile.gts\"")]
		public string outputPath;

		[CommandLineParameter(Name = "pagesdir", ShortName = "p", ValueName = "<relative path>", Atomic = false, Description = "(-p) Set relative directory for storing the page files, start path with directory name. \n\tExample: -p \"pages\" or --pagesdir \"somedir/otherdir\"")]
		public string pagesDirectory;

		[CommandLineParameter(Name = "gtexdir", ShortName = "g", ValueName = "<relative path>", Atomic = false, Description = "(-g) Set relative directory for storing the gtex files, start path with directory name. \n\tExample: -g \"GTEXFiles\" or --gtexdir \"somedir/otherdir\"")]
		public string soupDirectory;

		[CommandLineParameter(Name = "buildprofile", ShortName = "pr", ValueName = "<profile name>", Atomic = false, Description = "(-pr) Set Build Profile to one of the available built-in profiles, set by name. \n\tExample: -pr \"Default\" or --profile \"Default\"")]
		public string profile;

		[CommandLineParameter(Name = "version", ShortName = "version", Atomic = true, Description = "(-version) Display version information only.")]
		public bool showVersion;

		[CommandLineParameter(Name = "help", ShortName = "h", Atomic = true, Description = "(-h) Display this use message.")]
		public bool showHelp;

		[CommandLineParameter(Name = "warninglevel", ShortName = "w", Atomic = false, Description = "(-w) Set Warning Level between 1 and 3. See manual for summary of warning level conditions\n\nExample: -w 2")]
		public string warningLevel;

		[CommandLineParameter(Name = "nopatching", ShortName = "np", Atomic = false, Description = "(-np) Prevent GTex and GTS patching, never builds the GTS and GTex incrementally.")]
		public bool nopatching;

		[CommandLineParameter(Name = "nouniformcoding", ShortName = "nuu", Atomic = false, Description = "(-nuu) Disable the use of special coding of uniform areas in a GTS (set to enable compatibility with older runtimes not supporing uniform coding).")]
		public bool disableUniformCoding;

		[CommandLineParameter(Name = "profiling", ShortName = "pro", Atomic = false, Description = "(-pro) Enable profiling.", Hidden = true)]
		public bool profiling;

		[CommandLineParameter(Name = "strict", ShortName = "str", Atomic = false, Description = "(-str) Enable strict mode. Strict mode prevents certain features which can have unexpected side effects, such as automatic resizing of assets with changing aspect ratio, bit depth conversion, etc.")]
		public bool enableStrictMode;

		[CommandLineParameter(Name = "lightmapmode", ShortName = "lightmapmode", Atomic = false, Description = "Undocumented", Hidden = false)]
		public bool lightmapmode;

		[CommandLineParameter(Name = "cleanincludegtex", ShortName = "cleanincludegtex", Atomic = false, Description = "When cleaning (-t clean) also cleans the GTEX files.", Hidden = false)]
		public bool cleanIncludeGTex;

		[CommandLineParameter(Name = "cleanincludetileset", ShortName = "cleanincludetileset", Atomic = false, Description = "When cleaning (-t clean) also cleans the tile set files (.gts and .gtp files).", Hidden = false)]
		public bool cleanIncludeTileset;

		[CommandLineParameter(Name = "forceusegtex", ShortName = "forceusegtex", Atomic = false, Description = "Force using existing GTex files, even if the GTex files are out dated.", Hidden = false)]
		public bool forceUseGTex;

		[CommandLineParameter(Name = "allowforeigngtex", ShortName = "allowforeigngtex", Atomic = false, Description = "Allow the use of GTex files built by another project (use together with the 'forceusegtex' flag).", Hidden = false)]
		public bool allowForeignGTex;

		[CommandLineParameter(Name = "buildnotileset", ShortName = "buildnotileset", Atomic = false, Description = "No GTS file is written by the tools. The build process ends after GTex files are created.", Hidden = false)]
		public bool omitGTS;

		[CommandLineParameter(Name = "noredirection", ShortName = "noredirection", Atomic = false, Description = "Disable redirection of tiles in the GTS.", Hidden = false)]
		public bool noRedirection;

		[CommandLineParameter(Name = "nosharedmiptiles", ShortName = "nosharedmiptiles", Atomic = false, Description = "Disable shared mip tile generation when building the GTS.", Hidden = false)]
		public bool noSharedMipTiles;

		[CommandLineParameter(Name = "nomipstripping", ShortName = "nomipstripping", Atomic = false, Description = "Disable embedded mip stripping where a tile's mip if it resides in the same page as the tile, is only coded once", Hidden = false)]
		public bool noMipStripping;

		[CommandLineParameter(Name = "setguid", ShortName = "setguid", Atomic = false, Description = "Set the GUID of the active project. Example: -forceguid \"{0f8fad5b-d9cb-469f-a165-70867728950e}\"", Hidden = true)]
		public string setGuid;

		[CommandLineParameter(Name = "buildgtsforgtex", ShortName = "buildgtsforgtex", Atomic = false, Description = "Build a GTS file stripping where a tile's mip if it resides in the same page as the tile, is only coded once", Hidden = false)]
		public bool buildGTSforGTex;
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public class CommandLineParser
	{
		private readonly object _optionsObject;

		private readonly Queue<MemberInfo> _requiredOptions = new Queue<MemberInfo>();

		private readonly Dictionary<string, MemberInfo> _optionalOptions = new Dictionary<string, MemberInfo>();

		private readonly Dictionary<string, MemberInfo> _shortOptions = new Dictionary<string, MemberInfo>();

		private readonly Dictionary<string, MemberInfo> _atomicOptions = new Dictionary<string, MemberInfo>();

		private readonly Dictionary<string, MemberInfo> _atomicShortOptions = new Dictionary<string, MemberInfo>();

		private readonly List<string> _requiredUsageHelp = new List<string>();

		public string Title { get; set; }

		public CommandLineParser(object optionsObject)
		{
			_optionsObject = optionsObject;
			FieldInfo[] fields = optionsObject.GetType().GetFields();
			foreach (FieldInfo fieldInfo in fields)
			{
				CommandLineParameterAttribute attribute = GetAttribute<CommandLineParameterAttribute>(fieldInfo);
				if (attribute == null)
				{
					continue;
				}
				if (attribute.RequiredSequential)
				{
					_requiredOptions.Enqueue(fieldInfo);
					_requiredUsageHelp.Add($"<{attribute.Name}>");
				}
				else if (attribute.Atomic)
				{
					_atomicOptions.Add(attribute.Name.ToLowerInvariant(), fieldInfo);
					if (!string.IsNullOrEmpty(attribute.ShortName))
					{
						_atomicShortOptions.Add(attribute.ShortName.ToLowerInvariant(), fieldInfo);
					}
				}
				else
				{
					_optionalOptions.Add(attribute.Name.ToLowerInvariant(), fieldInfo);
					if (!string.IsNullOrEmpty(attribute.ShortName))
					{
						_shortOptions.Add(attribute.ShortName.ToLowerInvariant(), fieldInfo);
					}
				}
			}
			MethodInfo[] methods = optionsObject.GetType().GetMethods();
			foreach (MethodInfo methodInfo in methods)
			{
				CommandLineParameterAttribute attribute2 = GetAttribute<CommandLineParameterAttribute>(methodInfo);
				if (attribute2 == null)
				{
					continue;
				}
				if (methodInfo.GetParameters().Length > 1)
				{
					throw new NotSupportedException("Methods must have one or zero parameters.");
				}
				if (attribute2.RequiredSequential)
				{
					_requiredOptions.Enqueue(methodInfo);
					_requiredUsageHelp.Add($"<{attribute2.Name}>");
				}
				else if (attribute2.Atomic)
				{
					_atomicOptions.Add(attribute2.Name.ToLowerInvariant(), methodInfo);
					if (!string.IsNullOrEmpty(attribute2.ShortName))
					{
						_atomicShortOptions.Add(attribute2.ShortName.ToLowerInvariant(), methodInfo);
					}
				}
				else
				{
					_optionalOptions.Add(attribute2.Name.ToLowerInvariant(), methodInfo);
					if (!string.IsNullOrEmpty(attribute2.ShortName))
					{
						_shortOptions.Add(attribute2.ShortName.ToLowerInvariant(), methodInfo);
					}
				}
			}
		}

		public bool ParseCommandLine(string[] args)
		{
			bool result = true;
			for (int i = 0; i < args.Length; i++)
			{
				if (args[i].StartsWith("-"))
				{
					string text = args[i];
					string value = "true";
					if (i + 1 < args.Length && !args[i + 1].StartsWith("-"))
					{
						value = args[i + 1];
						i++;
					}
					MemberInfo value2;
					if (text.StartsWith("--"))
					{
						text = text.Substring(2);
						if (_atomicOptions.TryGetValue(text.ToLowerInvariant(), out value2))
						{
							return SetOption(value2, value);
						}
						if (!_optionalOptions.TryGetValue(text.ToLowerInvariant(), out value2))
						{
							ShowError("Unknown option '{0}'", text);
							return false;
						}
					}
					else
					{
						text = text.Substring(1);
						if (_atomicShortOptions.TryGetValue(text.ToLowerInvariant(), out value2))
						{
							return SetOption(value2, value);
						}
						if (!_shortOptions.TryGetValue(text.ToLowerInvariant(), out value2))
						{
							ShowError("Unknown option '{0}'", text);
							return false;
						}
					}
					if (!SetOption(value2, value))
					{
						return false;
					}
				}
				else
				{
					if (_requiredOptions.Count <= 0)
					{
						ShowError("Too many arguments");
						return false;
					}
					MemberInfo memberInfo = _requiredOptions.Peek();
					if (!IsList(memberInfo))
					{
						_requiredOptions.Dequeue();
					}
					SetOption(memberInfo, args[i]);
				}
			}
			MemberInfo memberInfo2 = _requiredOptions.FirstOrDefault((MemberInfo field) => !IsList(field) || GetList(field).Count == 0);
			if (memberInfo2 != null)
			{
				ShowError("Missing argument '{0}'", GetAttribute<CommandLineParameterAttribute>(memberInfo2).Name);
				return false;
			}
			return result;
		}

		private bool SetOption(MemberInfo member, string value)
		{
			try
			{
				if (IsList(member))
				{
					GetList(member).Add(ChangeType(value, ListElementType(member as FieldInfo)));
				}
				else if (member is MethodInfo)
				{
					MethodInfo methodInfo = member as MethodInfo;
					ParameterInfo[] parameters = methodInfo.GetParameters();
					if (parameters.Length == 0)
					{
						methodInfo.Invoke(_optionsObject, null);
					}
					else
					{
						methodInfo.Invoke(_optionsObject, new object[1] { ChangeType(value, parameters[0].ParameterType) });
					}
				}
				else
				{
					FieldInfo fieldInfo = member as FieldInfo;
					fieldInfo.SetValue(_optionsObject, ChangeType(value, fieldInfo.FieldType));
				}
				return true;
			}
			catch
			{
				ShowError("Invalid value '{0}' for option '{1}'", value, GetAttribute<CommandLineParameterAttribute>(member).Name);
				return false;
			}
		}

		private static object ChangeType(string value, Type type)
		{
			return TypeDescriptor.GetConverter(type).ConvertFromInvariantString(value);
		}

		private static bool IsList(MemberInfo field)
		{
			if (field is MethodInfo)
			{
				return false;
			}
			return typeof(IList).IsAssignableFrom((field as FieldInfo).FieldType);
		}

		private IList GetList(MemberInfo field)
		{
			return (IList)(field as FieldInfo).GetValue(_optionsObject);
		}

		private static Type ListElementType(FieldInfo field)
		{
			return (from i in field.FieldType.GetInterfaces()
				where i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IEnumerable<>)
				select i).First().GetGenericArguments()[0];
		}

		public void ShowUsage()
		{
			ShowError(null);
		}

		public void ShowError(string message, params object[] args)
		{
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(System.Diagnostics.Process.GetCurrentProcess().ProcessName);
			if (!string.IsNullOrEmpty(Title))
			{
				Console.Error.WriteLine(Title);
				Console.Error.WriteLine();
			}
			if (!string.IsNullOrEmpty(message))
			{
				Console.Error.WriteLine(message, args);
				Console.Error.WriteLine();
			}
			Dictionary<string, MemberInfo> dictionary = _optionalOptions.Concat(_atomicOptions).ToDictionary((KeyValuePair<string, MemberInfo> e) => e.Key, (KeyValuePair<string, MemberInfo> e) => e.Value);
			Console.Error.WriteLine("Usage: {0} {1}{2}", fileNameWithoutExtension, string.Join(" ", _requiredUsageHelp.ToArray()), (dictionary.Count > 0) ? " <Options>" : string.Empty);
			if (dictionary.Count <= 0)
			{
				return;
			}
			Console.Error.WriteLine();
			Console.Error.WriteLine("Options:\n");
			foreach (KeyValuePair<string, MemberInfo> item in dictionary)
			{
				FieldInfo fieldInfo = item.Value as FieldInfo;
				MethodInfo methodInfo = item.Value as MethodInfo;
				CommandLineParameterAttribute attribute = GetAttribute<CommandLineParameterAttribute>(item.Value);
				if ((fieldInfo != null && fieldInfo.FieldType != typeof(bool)) || (methodInfo != null && methodInfo.GetParameters().Length != 0))
				{
					if (string.IsNullOrEmpty(attribute.ShortName))
					{
						Console.Error.WriteLine("  -{0} {1}\n", attribute.ShortName, attribute.ValueName);
					}
					Console.Error.WriteLine("  --{0} {1}\n     {2}\n", attribute.Name, attribute.ValueName, attribute.Description);
				}
				else if (!attribute.Hidden)
				{
					if (string.IsNullOrEmpty(attribute.ShortName))
					{
						Console.Error.WriteLine("  -{0}\n", attribute.ShortName);
					}
					Console.Error.WriteLine("  --{0}\n     {1}\n", attribute.Name, attribute.Description);
				}
			}
		}

		private static T GetAttribute<T>(ICustomAttributeProvider provider) where T : Attribute
		{
			return provider.GetCustomAttributes(typeof(T), inherit: false).OfType<T>().FirstOrDefault();
		}

		public static bool QuickScanParam(string flag, string[] args)
		{
			if (args.Length == 0)
			{
				return false;
			}
			for (int i = 0; i < args.Length; i++)
			{
				if (args[i].Equals(flag))
				{
					return true;
				}
			}
			return false;
		}
	}
	[AttributeUsage(AttributeTargets.Method | AttributeTargets.Field)]
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	public sealed class CommandLineParameterAttribute : Attribute
	{
		public string Name { get; set; }

		public string ShortName { get; set; }

		public bool RequiredSequential { get; set; }

		public string ValueName { get; set; }

		public string Description { get; set; }

		public bool Atomic { get; set; }

		public bool Hidden { get; set; }

		public CommandLineParameterAttribute()
		{
			ValueName = "value";
		}
	}
	[Serializable]
	public class CrashReport
	{
		public string Application { get; set; }

		public DateTime TimeStamp { get; set; }

		public string Message { get; set; }

		public string DetailedMessage { get; set; }

		public string StackTrace { get; set; }

		public string AssemblyVersion { get; set; }

		public string AssemblyDescription { get; set; }

		public CrashReport()
		{
		}

		public CrashReport(string message, Exception e)
		{
			Application = AssemblyHelper.AssemblyProduct;
			TimeStamp = DateTime.Now;
			Message = message;
			DetailedMessage = e.ToString();
			StackTrace = e.StackTrace;
			AssemblyDescription = AssemblyHelper.AssemblyDescription;
			AssemblyVersion = AssemblyHelper.AssemblyInformationalVersion;
		}

		public override string ToString()
		{
			return string.Format("Fatal Exception in {1} at {2}{0}Message: {3}{0}Detailed: {4}{0}StackTrace: {5}{0}Version: {6}{0}AssemblyInfo: {7}", Environment.NewLine, Application, TimeStamp, Message, DetailedMessage, StackTrace, AssemblyVersion, AssemblyDescription);
		}
	}
	[Obfuscation(Exclude = true, ApplyToMembers = true)]
	internal enum ReturnCode
	{
		Success = 0,
		InvalidCommandLine = 1,
		InvalidXml = 2,
		InvalidOutputPath = 3,
		InvalidImportPath = 4,
		InvalidProject = 5,
		InvalidConfigParameter = 6,
		InvalidOptionsParameter = 7,
		InvalidTaskParameter = 8,
		InvalidAssetDeletion = 9,
		InvalidWarningLevel = 10,
		InvalidPagesDir = 11,
		InvalidProfile = 12,
		InvalidCodingProfile = 13,
		InvalidSoupDir = 14,
		ImportError = 100,
		BuildError = 101,
		ImportErrorInvalidGTexFile = 102,
		MissingDlls = 200,
		InvalidLicense = 300
	}
	internal class Program
	{
		public static CommandLineOptions options = new CommandLineOptions();

		public static Logger logger = new Logger(Logger.Verbosity.Detailed);

		public static byte[] GrBuildTag = new byte[64]
		{
			167, 97, 249, 76, 171, 132, 16, 23, 61, 82,
			82, 43, 29, 29, 78, 33, 76, 142, 230, 28,
			142, 225, 149, 164, 56, 9, 69, 233, 13, 214,
			149, 232, 121, 230, 62, 229, 223, 27, 228, 75,
			204, 223, 71, 62, 46, 96, 187, 241, 89, 54,
			62, 122, 135, 254, 153, 146, 0, 128, 163, 249,
			234, 18, 16, 132
		};

		private static int Validate()
		{
			if (options.newProject)
			{
				Console.Error.WriteLine("Validation works on existing projects. Can not validate.");
				return 2;
			}
			new ProjectBuilder().logger.RegisterLogListener(logger);
			XMLValidator.XMLValidationResult xMLValidationResult = ProjectBuilder.ValidateProjectFile(options.projectPath);
			if (!xMLValidationResult.Valid)
			{
				Console.Error.WriteLine(xMLValidationResult.ToString());
				return 2;
			}
			Console.WriteLine("Valid XML project file.");
			return 0;
		}

		public static bool GetVerbosity(string flagstring, out Logger.Verbosity verbosity)
		{
			switch (flagstring.ToLowerInvariant()[0])
			{
			case 'q':
				verbosity = Logger.Verbosity.Quiet;
				break;
			case 'n':
				verbosity = Logger.Verbosity.Normal;
				break;
			case 'd':
				verbosity = Logger.Verbosity.Detailed;
				break;
			default:
				verbosity = Logger.Verbosity.Normal;
				return false;
			}
			return true;
		}

		private static void RemoveOldLogs()
		{
			int num = 100;
			try
			{
				string path = Path.Combine(Paths.GetDirectoryName(Assembly.GetEntryAssembly().Location), "Logs");
				FileScanner fileScanner = new FileScanner();
				fileScanner.Scan(path, "GrBuild-backup-*.log", recursive: false);
				if (fileScanner.FoundFiles.Count < num)
				{
					return;
				}
				List<FileInfo> list = new List<FileInfo>();
				foreach (string foundFile in fileScanner.FoundFiles)
				{
					string fileName = Path.GetFileName(foundFile);
					string pattern = "GrBuild-backup-\\d{4}.\\d{2}.\\d{2}-\\d{2}.\\d{2}.\\d{2}.log";
					if (Regex.Match(fileName, pattern).Success)
					{
						FileInfo item = new FileInfo(foundFile);
						list.Add(item);
					}
				}
				List<FileInfo> list2 = list.OrderByDescending((FileInfo o) => o.LastWriteTimeUtc).ToList();
				for (int i = num; i < list2.Count; i++)
				{
					File.Delete(list2[i].FullName);
				}
			}
			catch
			{
			}
		}

		private static void SetupLoggers()
		{
			logger.RegisterLogListener(new ConsoleLogListener());
			string text = Path.Combine(Paths.GetDirectoryName(Assembly.GetEntryAssembly().Location), "Logs");
			try
			{
				Paths.CreateDirectory(text);
				string text2 = Path.Combine(text, "GrBuild.log");
				if (File.Exists(text2))
				{
					string arg = new FileInfo(text2).CreationTime.ToString("yyyy.MM.dd-HH.mm.ss");
					string path = $"GrBuild-backup-{arg}.log";
					int num = 1;
					while (File.Exists(Path.Combine(text, path)))
					{
						path = $"GrBuild-backup-{arg}-{num}.log";
						num++;
					}
					string destFileName = Path.Combine(text, path);
					File.Move(text2, destFileName);
				}
				StreamLogListener streamLogListener = new StreamLogListener(text2);
				streamLogListener.LogMessage("GrBuild log started", Logger.Verbosity.Quiet);
				logger.RegisterLogListener(streamLogListener);
			}
			catch (Exception)
			{
				string message = $"Unable to set up log file. Logging will only be done to console. Make sure the log directory '{text}' is writable to the application";
				logger.LogError(message);
			}
			RemoveOldLogs();
		}

		private static int Main(string[] args)
		{
			SetupLoggers();
			ReturnCode result = ReturnCode.Success;
			try
			{
				result = ReturnCode.InvalidOptionsParameter;
				bool flag = (GrBuildLib.Constants.lightmapMode = CommandLineParser.QuickScanParam("-lightmapmode", args));
				result = ReturnCode.MissingDlls;
				if (!GrBuildLibInterface.IsInitialized)
				{
					GrBuildLibInterface.InitializeGrBuild();
				}
				result = ReturnCode.InvalidLicense;
				if (GrBuildLibInterface.InitializationInfo.nixelInfo.value2 == 1000 && !flag)
				{
					logger.LogError("Your license does not allow you to run GrBuild. Your license only supports the use of Tile Set Studio. Please upgrade your license in order to run GrBuild.");
					return 300;
				}
				CommandLineParser commandLineParser = new CommandLineParser(options);
				string text = string.Format("GrBuild {0} (project version {1})", new object[2]
				{
					GrBuildLib.Constants.Version.BuildVersion,
					GrBuildLib.Constants.Version.ProjectCompatibilityVersion
				});
				text = (commandLineParser.Title = text + " Copyright (c) 2012-" + DateTime.Now.Year + " Graphine NV");
				if (!commandLineParser.ParseCommandLine(args))
				{
					return 1;
				}
				if (args.Count() == 0)
				{
					commandLineParser.ShowError("");
					return 1;
				}
				if (options.validate)
				{
					return Validate();
				}
				if (options.showHelp)
				{
					commandLineParser.ShowUsage();
					return 0;
				}
				if (options.showVersion)
				{
					Console.WriteLine(string.Format("GrBuild version {0}, project compatibility version {1}, build info: {2}", new object[3]
					{
						GrBuildLib.Constants.Version.BuildVersion,
						GrBuildLib.Constants.Version.ProjectCompatibilityVersion,
						GrBuildLib.Constants.Version.BuildInfo
					}));
					return 0;
				}
				result = ReturnCode.InvalidImportPath;
				if (options.importAssetsPath != null)
				{
					try
					{
						options.importAssetsPath = Path.GetFullPath(options.importAssetsPath);
					}
					catch
					{
						logger.LogError("Invalid input for --importassets (-i): " + options.importAssetsPath);
						return 4;
					}
				}
				GrBuildLib.Constants.lightmapMode = options.lightmapmode;
				GrBuildLib.Constants.allowDeprecatedCodingProfiles = flag;
				ProjectBuilder projectBuilder = new ProjectBuilder();
				projectBuilder.logger.RegisterLogListener(logger);
				projectBuilder.ProjectUpgrading += projectBuilder_ProjectUpgrading;
				projectBuilder.HookBuildErrorsOnGlobalLogger();
				projectBuilder.NoFileLogging = options.noLog;
				projectBuilder.NoPatching = options.nopatching;
				projectBuilder.EnableUniformCoding = !options.disableUniformCoding;
				projectBuilder.EnableStrictMode = options.enableStrictMode;
				projectBuilder.ForceUseGTex = options.forceUseGTex;
				projectBuilder.AllowForeignGTex = options.allowForeignGTex;
				projectBuilder.NoGTSBuilding = options.omitGTS;
				projectBuilder.EnableRedirection = !options.noRedirection;
				projectBuilder.EnableSharedMipGeneration = !options.noSharedMipTiles;
				projectBuilder.EnableMipStripping = !options.noMipStripping;
				BuildMode buildMode = (options.buildGTSforGTex ? BuildMode.BuildForGTex : BuildMode.BuildForGTP);
				if (options.setGuid != null && !Guid.TryParse(options.setGuid, out var _))
				{
					logger.LogError("Invalid input for --setguid: string not a GUID, required format: 00000000-0000-0000-0000-000000000000");
					return 7;
				}
				projectBuilder.OverrideGuid = options.setGuid;
				Error error = Error.Ok;
				result = ReturnCode.InvalidProject;
				if (((!options.newProject) ? projectBuilder.LoadProject(options.projectPath) : projectBuilder.NewProject(options.projectPath)) != 0)
				{
					return 5;
				}
				if (projectBuilder.ReadOnly)
				{
					logger.LogWarning("Project is read only. Changes made to the project will not be saved!");
				}
				result = ReturnCode.InvalidProfile;
				if (!string.IsNullOrEmpty(options.profile) && projectBuilder.SetBuildProfile(options.profile) != 0)
				{
					return 12;
				}
				result = ReturnCode.InvalidCommandLine;
				if (options.verbosity != null)
				{
					if (!GetVerbosity(options.verbosity, out var verbosity))
					{
						logger.LogError("Invalid input for --verbosity (-v)");
						return 1;
					}
					projectBuilder.SetVerbosity(verbosity);
					logger.SetVerbosity(verbosity);
				}
				result = ReturnCode.InvalidConfigParameter;
				TargetConfiguration configuration = TargetConfiguration.Default;
				if (options.config != null)
				{
					logger.LogWarning("Changing target configuration is deprecated. Falling back to default (Optimized).");
				}
				result = ReturnCode.InvalidOptionsParameter;
				if (options.options != null && !SetExtraOptions(projectBuilder, options.options))
				{
					return 7;
				}
				result = ReturnCode.InvalidOutputPath;
				if (options.outputPath != null && !projectBuilder.SetOutputLocation(options.outputPath))
				{
					return 3;
				}
				result = ReturnCode.InvalidPagesDir;
				if (options.pagesDirectory != null && !projectBuilder.SetPagesDirectory(options.pagesDirectory))
				{
					logger.LogError("Invalid input for --pagesdir (-p): " + options.pagesDirectory);
					return 11;
				}
				result = ReturnCode.InvalidSoupDir;
				if (options.soupDirectory != null && !projectBuilder.SetSoupOutputDirectory(options.soupDirectory, tryToMake: true))
				{
					logger.LogError("Invalid input for --gtexdir (-g): " + options.soupDirectory);
					return 14;
				}
				result = ReturnCode.InvalidWarningLevel;
				if (options.warningLevel != null)
				{
					uint num = 0u;
					try
					{
						num = uint.Parse(options.warningLevel);
					}
					catch
					{
						logger.LogError("Invalid input for --warninglevel (-w): " + options.warningLevel);
						return 10;
					}
					if (!projectBuilder.SetWarningLevel(num))
					{
						return 10;
					}
				}
				if (options.importAssetsPath != null)
				{
					result = ReturnCode.InvalidXml;
					XMLValidator.XMLValidationResult xMLValidationResult = ProjectBuilder.ValidateImportXmlFile(options.importAssetsPath);
					if (!xMLValidationResult.Valid)
					{
						logger.LogError("Error validating Asset Import XML file \"" + options.importAssetsPath + "\". Detailed error message: " + xMLValidationResult.ToString());
						return 2;
					}
					projectBuilder.SetExclusiveImport(options.exclusiveImport);
					result = ReturnCode.ImportError;
					if (!projectBuilder.AddLayersAndAssetsFromXMLFile(options.importAssetsPath))
					{
						return 100;
					}
				}
				result = ReturnCode.InvalidTaskParameter;
				Task task = Task.Build;
				if (options.task != null)
				{
					try
					{
						task = (Task)Enum.Parse(typeof(Task), options.task, ignoreCase: true);
					}
					catch
					{
						logger.LogError("Invalid input for --task (-t):" + options.task);
						return 8;
					}
				}
				CleanOperationParameters cleanOperationParameters = default(CleanOperationParameters);
				cleanOperationParameters.intermediates = true;
				cleanOperationParameters.tileSet = options.cleanIncludeTileset;
				cleanOperationParameters.soups = options.cleanIncludeGTex;
				projectBuilder.SetCleanOperationParameters(cleanOperationParameters);
				result = ReturnCode.InvalidAssetDeletion;
				if (options.assetToDelete != null)
				{
					try
					{
						if (!projectBuilder.AddAssetsToRemove(options.assetToDelete))
						{
							return 9;
						}
					}
					catch (UnspecifiedException ex)
					{
						logger.LogError(ex.Message);
						return 9;
					}
					catch (Exception ex2)
					{
						logger.LogError(ex2.Message);
						return 9;
					}
				}
				GrBuildLib.Process process = GrBuildLib.Process.All;
				if (task == Task.NoBuild)
				{
					process = ((!string.IsNullOrEmpty(options.importAssetsPath) || !string.IsNullOrEmpty(options.assetToDelete)) ? GrBuildLib.Process.Import : GrBuildLib.Process.None);
				}
				result = ReturnCode.InvalidConfigParameter;
				projectBuilder.LoadConfiguration(configuration);
				result = ReturnCode.BuildError;
				projectBuilder.Build(task, process, buildMode);
				if (projectBuilder.ProcessResult != 0)
				{
					return 101;
				}
			}
			catch (UnspecifiedException ex3)
			{
				logger.LogError(ex3.Message);
				return (int)result;
			}
			catch (InvalidDllException ex4)
			{
				logger.LogError(ex4.Message);
				return 200;
			}
			catch (IncompatibleGTexException ex5)
			{
				logger.LogError("Incompatible GTex file, message: '" + ex5.Message + "'");
				return 102;
			}
			catch (Exception ex6)
			{
				CrashReport crashReport = new CrashReport(ex6.Message, ex6);
				string text3 = ex6.Message + "\n";
				text3 += "----------------------------------------\n";
				text3 += "An internal runtime exception has occurred. This may be caused by a configuration error or a internal bug. If this issue persists, please send a bug report with the following information to Granite support either via the support platform (http://support.graphinesoftware.com) or by email (support@graphinesoftware.com).\n";
				text3 += "----------------------------------------\n";
				text3 = text3 + "Error details: " + crashReport.ToString() + "\n";
				text3 += "----------------------------------------\n";
				logger.LogError(text3);
				return (int)result;
			}
			finally
			{
				GrBuildLibInterface.ReleaseGrBuild();
			}
			return 0;
		}

		private static void projectBuilder_ProjectUpgrading(object sender, ProjectBuilder.UpgradeInfo info)
		{
			if (info.WillUpgradeCodingProfiles2dot7)
			{
				string message = "The project will upgrade to the latest version. Layer compression formats and Stacked Texture's quality profiles could be altered. Please inspect them.";
				logger.LogInfo(message);
			}
		}

		private static bool SetExtraOptions(ProjectBuilder builder, string extra)
		{
			string[] array = extra.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
			foreach (string text in array)
			{
				string[] array2 = text.Split(new char[1] { ':' }, StringSplitOptions.RemoveEmptyEntries);
				if (array2.Length != 2)
				{
					logger.LogError("Invalid key/value: " + text);
					return false;
				}
				switch (array2[0].ToLowerInvariant())
				{
				case "tilingmode":
					try
					{
						builder.SetTilingMode((TilingMode)Enum.Parse(typeof(TilingMode), array2[1], ignoreCase: true));
					}
					catch
					{
						logger.LogError("Invalid value for Tiling Mode");
						return false;
					}
					break;
				case "maximumanisotropy":
					try
					{
						uint maximumAnisotropy = uint.Parse(array2[1]);
						builder.SetMaximumAnisotropy(maximumAnisotropy);
					}
					catch
					{
						logger.LogError("Invalid value for Minimum Anisotropy");
						return false;
					}
					break;
				case "pagesize":
					try
					{
						uint pageSize = uint.Parse(array2[1]);
						builder.SetPageSize(pageSize);
					}
					catch
					{
						logger.LogError("Invalid value for PageSize");
						return false;
					}
					break;
				case "pagingstrategy":
					try
					{
						PagingStrategy pagingStrategy = (PagingStrategy)Enum.Parse(typeof(PagingStrategy), array2[1]);
						builder.SetPagingStrategy(pagingStrategy);
					}
					catch
					{
						logger.LogError("Invalid value for PagingStrategy");
						return false;
					}
					break;
				case "targetdisk":
					try
					{
						builder.SetTargetDisk((TargetDisk)Enum.Parse(typeof(TargetDisk), array2[1], ignoreCase: true));
					}
					catch
					{
						logger.LogError("Invalid value for TargetDisk");
						return false;
					}
					break;
				case "tilewidth":
					try
					{
						uint tileWidth = uint.Parse(array2[1]);
						builder.SetTileWidth(tileWidth);
					}
					catch
					{
						logger.LogError("Invalid value for TileWidth");
						return false;
					}
					break;
				case "tileheight":
					try
					{
						uint tileHeight = uint.Parse(array2[1]);
						builder.SetTileHeight(tileHeight);
					}
					catch
					{
						logger.LogError("Invalid value for TileHeight");
						return false;
					}
					break;
				case "blocksize":
					try
					{
						uint blockSize = uint.Parse(array2[1]);
						builder.SetBlockSize(blockSize);
					}
					catch
					{
						logger.LogError("Invalid value for BlockSize");
						return false;
					}
					break;
				default:
					logger.LogError("Option not recognized: " + array2[0]);
					return false;
				}
			}
			return true;
		}
	}
	internal class Sample
	{
		public static void Test()
		{
		}

		public static void OnFatalError(ProjectBuilder source, BuildProcess process, BuildIssue error)
		{
			Console.Error.WriteLine(process.ToString() + ": " + error.ToString());
		}

		public static ErrorAction OnError(ProjectBuilder source, BuildProcess process, BuildIssue error)
		{
			Console.Error.WriteLine(process.ToString() + ": " + error.ToString());
			return ErrorAction.Stop;
		}

		public static void OnWarning(ProjectBuilder source, BuildProcess process, BuildIssue error)
		{
			Console.Error.WriteLine(process.ToString() + ": " + error.ToString());
		}

		private static void RegisterErrorCallbacks(ProjectBuilder projectBuilder)
		{
			projectBuilder.BuildReportingHandler.OnFatalErrorHandler += OnFatalError;
			projectBuilder.BuildReportingHandler.OnErrorHandler += OnError;
			projectBuilder.BuildReportingHandler.OnWarningHandler += OnWarning;
		}

		public static void GO()
		{
			try
			{
				GrBuildLibInterface.InitializeGrBuild();
				ProjectBuilder projectBuilder = new ProjectBuilder();
				projectBuilder.logger.RegisterLogListener(new ConsoleLogListener());
				RegisterErrorCallbacks(projectBuilder);
				projectBuilder.NewProject("myproject.grproj");
				projectBuilder.LoadConfiguration(TargetConfiguration.Fast);
				LayerConfig layerConfig = new LayerConfig();
				LayerDescription item = new LayerDescription
				{
					DataType = DataType.R8G8B8A8_LINEAR,
					QualityProfile = "Default"
				};
				layerConfig.Layers.Add(item);
				LayerDescription item2 = new LayerDescription
				{
					DataType = DataType.X8Y8Z0_TANGENT,
					QualityProfile = "Default"
				};
				layerConfig.Layers.Add(item2);
				projectBuilder.SetLayerConfig(layerConfig);
				ImportAsset importAsset = new ImportAsset
				{
					Name = "MyAsset"
				};
				ImportAssetLayer importAssetLayer = new ImportAssetLayer();
				importAssetLayer.Source.AddSource(".\\..\\..\\..\\..\\AcceptanceTestingFramework\\Content\\Random\\tile_metal_grey_dark02_dff.tif", 0);
				importAssetLayer.QualityProfile = "High";
				importAsset.AddAssetLayer(importAssetLayer);
				importAsset.AddAssetLayer(new ImportAssetLayer
				{
					QualityProfile = "High"
				});
				projectBuilder.AddImportAsset(importAsset);
				projectBuilder.Build(Task.Build, GrBuildLib.Process.Import);
				ImportSummary importSummary = projectBuilder.GetImportSummary();
				Console.WriteLine("Successful imports: " + importSummary.SuccessImportCount);
				Console.WriteLine("Failed imports: " + importSummary.FailedImportCount);
				projectBuilder.CloseProject();
				ProjectBuilder projectBuilder2 = new ProjectBuilder();
				projectBuilder2.logger.RegisterLogListener(new ConsoleLogListener());
				RegisterErrorCallbacks(projectBuilder2);
				projectBuilder2.LoadProject("myproject.grproj");
				projectBuilder2.LoadConfiguration(TargetConfiguration.Default);
				projectBuilder2.Build(Task.Build, GrBuildLib.Process.All);
				projectBuilder2.CloseProject();
				ProjectBuilder projectBuilder3 = new ProjectBuilder();
				projectBuilder3.logger.RegisterLogListener(new ConsoleLogListener());
				RegisterErrorCallbacks(projectBuilder3);
				projectBuilder3.LoadProject("myproject.grproj");
				CodingProfile obj = new CodingProfile
				{
					Name = "MyCustomCodingProfile",
					QualityProfiles = new List<QualityProfile>()
				};
				QualityProfile qualityProfile = new QualityProfile
				{
					Name = "MyCustomQualityProfile",
					Priority = 100u,
					CodingConfigs = new List<CodingConfig>()
				};
				CodingConfig codingConfig = new CodingConfig();
				codingConfig.DataTypes = new List<DataType>();
				codingConfig.DataTypes.Add(DataType.R8G8B8A8_SRGB);
				codingConfig.DataTypes.Add(DataType.R8G8B8_SRGB);
				codingConfig.DataTypes.Add(DataType.R8G8B8A8_LINEAR);
				codingConfig.DataTypes.Add(DataType.R8G8B8_LINEAR);
				codingConfig.CodecId = 1;
				codingConfig.CodecConfiguration = "<DefaultQP>1</DefaultQP>";
				qualityProfile.CodingConfigs.Add(codingConfig);
				obj.QualityProfiles.Add(qualityProfile);
				ImportAssetLayer importAssetLayer2 = new ImportAssetLayer();
				importAssetLayer2.Source.AddSource(".\\..\\..\\..\\..\\AcceptanceTestingFramework\\Content\\Random\\tile_metal_grey_dark02_dff.tif", 0);
				importAssetLayer2.QualityProfile = "MyCustomQualityProfile";
				ImportAssetLayer importAssetLayer3 = new ImportAssetLayer();
				importAssetLayer3.Source.AddSource(".\\..\\..\\..\\..\\AcceptanceTestingFramework\\Content\\Random\\tile_floor_rubber_nrm.tif", 0);
				importAssetLayer3.QualityProfile = "High";
				ImportAsset asset = new ImportAsset("MyAsset", new ImportAssetLayer[2] { importAssetLayer2, importAssetLayer3 });
				projectBuilder3.AddImportAsset(asset);
				projectBuilder3.LoadConfiguration(TargetConfiguration.Default);
				projectBuilder3.Build(Task.Build, GrBuildLib.Process.Import);
				projectBuilder3.CloseProject();
				ProjectBuilder projectBuilder4 = new ProjectBuilder();
				projectBuilder4.logger.RegisterLogListener(new ConsoleLogListener());
				RegisterErrorCallbacks(projectBuilder4);
				projectBuilder4.LoadProject("myproject.grproj");
				projectBuilder4.GetAsset("MyAsset").AssetLayers[0].QualityProfile = "MyCustomQualityProfile";
				projectBuilder4.LoadConfiguration(TargetConfiguration.Default);
				projectBuilder4.Build(Task.Build, GrBuildLib.Process.All);
				projectBuilder4.CloseProject();
				ProjectBuilder projectBuilder5 = new ProjectBuilder();
				projectBuilder5.logger.RegisterLogListener(new ConsoleLogListener());
				RegisterErrorCallbacks(projectBuilder5);
				projectBuilder5.LoadProject("myproject.grproj");
				List<string> assetNames = projectBuilder5.GetAssetNames();
				Console.WriteLine("Included assets: ");
				foreach (string item6 in assetNames)
				{
					Console.WriteLine(item6);
				}
				projectBuilder5.CloseProject();
				ProjectBuilder projectBuilder6 = new ProjectBuilder();
				projectBuilder6.logger.RegisterLogListener(new ConsoleLogListener());
				RegisterErrorCallbacks(projectBuilder6);
				projectBuilder6.NewProject("myproject2.grproj");
				LayerConfig layerConfig2 = new LayerConfig();
				LayerDescription item3 = new LayerDescription(DataType.R8G8B8A8_SRGB, "Default", "Default", "Diffuse");
				layerConfig2.Layers.Add(item3);
				projectBuilder6.SetLayerConfig(layerConfig2);
				ImportAssetTemplate importAssetTemplate = new ImportAssetTemplate
				{
					Name = "Kitten*"
				};
				ImportAssetLayerTemplate importAssetLayerTemplate = new ImportAssetLayerTemplate();
				importAssetLayerTemplate.Source.AddSource(".\\..\\..\\..\\..\\AcceptanceTestingFramework\\Content\\Random\\Kitten_*.jpg", 0);
				importAssetLayerTemplate.QualityProfile = "high";
				importAssetLayerTemplate.Swizzle[0] = "0123";
				importAssetLayerTemplate.InvertChannels[0] = "0000";
				importAssetTemplate.LayerTemplates.Add(importAssetLayerTemplate);
				projectBuilder6.AddImportAssetsByTemplate(importAssetTemplate);
				projectBuilder6.LoadConfiguration(TargetConfiguration.Default);
				projectBuilder6.Build(Task.Build, GrBuildLib.Process.All);
				projectBuilder6.CloseProject();
				ProjectBuilder projectBuilder7 = new ProjectBuilder();
				projectBuilder7.logger.RegisterLogListener(new ConsoleLogListener());
				RegisterErrorCallbacks(projectBuilder7);
				projectBuilder7.LoadProject("myproject2.grproj");
				projectBuilder7.GetAsset("Kitten5").TilingMethod = AssetTilingMethod.Repeat;
				projectBuilder7.LoadConfiguration(TargetConfiguration.Default);
				projectBuilder7.Build(Task.Build, GrBuildLib.Process.All);
				projectBuilder7.CloseProject();
				ProjectBuilder projectBuilder8 = new ProjectBuilder();
				projectBuilder8.logger.RegisterLogListener(new ConsoleLogListener());
				RegisterErrorCallbacks(projectBuilder8);
				projectBuilder8.LoadProject("myproject2.grproj");
				List<string> assetNames2 = projectBuilder8.GetAssetNames();
				Console.WriteLine("Imported assets: ");
				foreach (string item7 in assetNames2)
				{
					Console.WriteLine("\t" + item7);
				}
				projectBuilder8.AddAssetsToRemove(assetNames2[0]);
				projectBuilder8.AddAssetsToRemove(assetNames2[1]);
				Console.WriteLine("Deleting: " + assetNames2[0] + ", " + assetNames2[1]);
				projectBuilder8.LoadConfiguration(TargetConfiguration.Default);
				projectBuilder8.Build(Task.Build, GrBuildLib.Process.All);
				List<TextureChange> textureChanges = projectBuilder8.GetImportSummary().TextureChanges;
				Console.WriteLine("\nTexture changes: ");
				foreach (TextureChange item8 in textureChanges)
				{
					Console.WriteLine(item8.ChangeType.ToString() + " " + item8.Source);
				}
				SolutionBuilder solutionBuilder = new SolutionBuilder();
				solutionBuilder.NewSolution("myproject.grsol");
				LayerConfig layerConfig3 = new LayerConfig();
				LayerDescription item4 = new LayerDescription
				{
					DataType = DataType.R8G8B8A8_LINEAR,
					QualityProfile = "Default"
				};
				layerConfig3.Layers.Add(item4);
				LayerDescription item5 = new LayerDescription
				{
					DataType = DataType.X8Y8Z0_TANGENT,
					QualityProfile = "Default"
				};
				layerConfig3.Layers.Add(item5);
				Guid projectId = Guid.Empty;
				solutionBuilder.CreateNewProject("test", "C:\\Temp\\", layerConfig3, out projectId);
				ProjectBuilder projectBuilder9 = solutionBuilder.GetProjectBuilder(projectId);
				ImportAsset importAsset2 = new ImportAsset
				{
					Name = "MyAsset"
				};
				ImportAssetLayer importAssetLayer4 = new ImportAssetLayer();
				importAssetLayer4.Source.AddSource(".\\..\\..\\..\\..\\AcceptanceTestingFramework\\Content\\Random\\tile_metal_grey_dark02_dff.tif", 0);
				importAssetLayer4.QualityProfile = "High";
				importAsset2.AddAssetLayer(importAssetLayer4);
				importAsset2.AddAssetLayer(new ImportAssetLayer
				{
					QualityProfile = "High"
				});
				projectBuilder9.AddImportAsset(importAsset2);
				solutionBuilder.LoadConfiguration(TargetConfiguration.Default);
				solutionBuilder.BuildSolution(BuildMode.BuildForGTP);
				ProjectBuilder projectBuilder10 = new ProjectBuilder();
				projectBuilder10.logger.RegisterLogListener(new ConsoleLogListener());
				RegisterErrorCallbacks(projectBuilder10);
				projectBuilder10.LoadProject("myproject.grproj");
				ImportAsset importAsset3 = new ImportAsset
				{
					Name = "MyCube",
					Type = AssetType.CubeMap
				};
				ImportAssetLayer importAssetLayer5 = new ImportAssetLayer();
				importAssetLayer5.Source.AddSource("cube.dds", 0);
				importAssetLayer5.QualityProfile = "High";
				importAsset3.AddAssetLayer(importAssetLayer5);
				projectBuilder10.AddImportAsset(importAsset3);
				projectBuilder10.Import(importAsset3);
				ImportSummary importSummary2 = projectBuilder10.GetImportSummary();
				Console.WriteLine("Successful imports: " + importSummary2.SuccessImportCount);
				Console.WriteLine("Failed imports: " + importSummary2.FailedImportCount);
				projectBuilder10.CloseProject();
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.Message);
			}
			finally
			{
				GrBuildLibInterface.ReleaseGrBuild();
			}
		}
	}
}
