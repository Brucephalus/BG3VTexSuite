
// C:\WINDOWS\Microsoft.NET\assembly\GAC_MSIL\Microsoft.JScript\v4.0_10.0.0.0__b03f5f7f11d50a3a\Microsoft.JScript.dll
// Microsoft.JScript, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v4.0.30319
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Configuration.Assemblies;
using System.Diagnostics;
using System.Diagnostics.SymbolStore;
using System.Globalization;
using System.IO;
using System.IO.IsolatedStorage;
using System.Net.Sockets;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Expando;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Serialization;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Security.Policy;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using Microsoft.JScript.Vsa;
using Microsoft.Win32;

[assembly: CompilationRelaxations(8)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyFileVersion("14.8.9037.0")]
[assembly: AssemblyInformationalVersion("14.8.9037.0")]
[assembly: AllowPartiallyTrustedCallers]
[assembly: SecurityRules(SecurityRuleSet.Level1, SkipVerificationInFullTrust = true)]
[assembly: TypeLibVersion(10, 0)]
[assembly: Guid("D3295D87-D604-11D4-A704-00C04FA137E4")]
[assembly: ComVisible(false)]
[assembly: CLSCompliant(false)]
[assembly: AssemblyTitle("Microsoft.JScript.dll")]
[assembly: AssemblyDescription("Microsoft.JScript.dll")]
[assembly: AssemblyDefaultAlias("Microsoft.JScript.dll")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft® Visual Studio® 12 CTP")]
[assembly: AssemblyCopyright("© Microsoft Corporation. All rights reserved.")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: AssemblyDelaySign(true)]
[assembly: AssemblyKeyFile("f:\\dd\\tools\\devdiv\\FinalPublicKey.snk")]
[assembly: AssemblySignatureKey("002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3", "a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d")]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: DefaultDllImportSearchPaths(DllImportSearchPath.System32 | DllImportSearchPath.AssemblyDirectory)]
[assembly: TargetFramework(".NETFramework,Version=v4.5", FrameworkDisplayName = "")]
[assembly: PermissionSet(SecurityAction.RequestOptional, Name = "FullTrust")]
[assembly: ReflectionPermission(SecurityAction.RequestOptional, Unrestricted = true)]
[assembly: SecurityPermission(SecurityAction.RequestOptional, Flags = (SecurityPermissionFlag.UnmanagedCode | SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.SerializationFormatter))]
[assembly: FileIOPermission(SecurityAction.RequestOptional, Unrestricted = true)]
[assembly: RegistryPermission(SecurityAction.RequestOptional, Read = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\PROTOCOLS\\Handler")]
[assembly: AssemblyVersion("10.0.0.0")]
internal static class FXAssembly
{
	internal const string Version = "4.0.0.0";
}
internal static class ThisAssembly
{
	internal const string Title = "Microsoft.JScript.dll";

	internal const string Description = "Microsoft.JScript.dll";

	internal const string DefaultAlias = "Microsoft.JScript.dll";

	internal const string Copyright = "© Microsoft Corporation. All rights reserved.";

	internal const string Version = "14.0.0.0";

	internal const string InformationalVersion = "14.8.9037.0";

	internal const string DailyBuildNumberStr = "9037";

	internal const string BuildRevisionStr = "0";

	internal const int DailyBuildNumber = 9037;
}
namespace System.Net
{
	internal class VsaWebProxyScript : MarshalByRefObject, IWebProxyScript
	{
		private class VsaEngineSite : IJSVsaSite
		{
			private readonly Type m_GlobalType;

			internal VsaEngineSite(Type globalType)
			{
				m_GlobalType = globalType;
			}

			public void GetCompiledState(out byte[] pe, out byte[] debugInfo)
			{
				pe = null;
				debugInfo = null;
			}

			public object GetEventSourceInstance(string itemName, string eventSourceName)
			{
				return null;
			}

			[ReflectionPermission(SecurityAction.Assert, Flags = ReflectionPermissionFlag.MemberAccess)]
			public object GetGlobalInstance(string name)
			{
				if (name == "__om")
				{
					return Activator.CreateInstance(m_GlobalType, nonPublic: true);
				}
				throw new JSVsaException(JSVsaError.GlobalInstanceInvalid);
			}

			public void Notify(string notify, object info)
			{
			}

			public bool OnCompilerError(IJSVsaError error)
			{
				return error.Severity != 0;
			}
		}

		private const string RootNamespace = "__WebProxyScript";

		private static readonly Zone IntranetZone = new Zone(SecurityZone.Intranet);

		private VsaEngine engine;

		private object scriptInstance;

		private BaseVsaStartup startupInstance;

		private const string NetScriptSource_v4 = "import System.Security;\r\n[assembly:System.Security.SecurityTransparent()]\r\nfunction isPlainHostName(hostName: String): Boolean { return __om.isPlainHostName(hostName); }\r\nfunction dnsDomainIs(host: String, domain: String): Boolean { return __om.dnsDomainIs(host, domain); }\r\nfunction localHostOrDomainIs(host: String, hostdom: String): Boolean { return __om.localHostOrDomainIs(host, hostdom); }\r\nfunction isResolvable(host: String): Boolean { return __om.isResolvable(host); }\r\nfunction isInNet(host: String, pattern: String, mask: String): Boolean { return __om.isInNet(host, pattern, mask); }\r\nfunction dnsResolve(host: String): String { return __om.dnsResolve(host); }\r\nfunction myIpAddress(): String { return __om.myIpAddress(); }\r\nfunction dnsDomainLevels(host: String): int { return __om.dnsDomainLevels(host); }\r\nfunction shExpMatch(str: String, pattern: String): Boolean { return __om.shExpMatch(str, pattern); }\r\nfunction weekdayRange(wd1: String, wd2: String, gmt: String): Boolean { return __om.weekdayRange(wd1, wd2, gmt); }\r\nfunction dateRange(day1, month1, year1, day2, month2, year2, gmt): Boolean { return true; }\r\nfunction timeRange(hour1, min1, sec1, hour2, min2, sec2, gmt): Boolean { return true; }\r\n";

		private const string NetScriptSource_v6ExtClass = "function getClientVersion(): String { return __om.getClientVersion(); }\r\nfunction sortIpAddressList(IPAddressList:String): String { return __om.sortIpAddressList(IPAddressList); }\r\nfunction isInNetEx(ipAddress:String, ipPrefix:String): Boolean { return __om.isInNetEx(ipAddress, ipPrefix); }\r\nfunction myIpAddressEx(): String { return __om.myIpAddressEx(); }\r\nfunction dnsResolveEx(host:String): String { return __om.dnsResolveEx(host); }\r\nfunction isResolvableEx(host:String): Boolean { return __om.isResolvableEx(host); }\r\nvar __RefereceOfFindProxyForURLEx = this[\"FindProxyForURLEx\"];\r\nvar bFindProxyForURLExFound : Boolean = __RefereceOfFindProxyForURLEx != null && typeof(__RefereceOfFindProxyForURLEx) == \"function\";\r\nclass __WebProxyScript { \t\r\n\t\t\t     \tfunction ExecuteFindProxyForURL(url, host): String { \r\n\t\t         \t\tif(bFindProxyForURLExFound) {\r\n\t\t         \t\t\treturn String(FindProxyForURLEx(url, host)); \r\n\t\t         \t\t}\r\n\t\t         \t\telse {\r\n\t\t\t         \t\treturn String(FindProxyForURL(url, host)); \r\n\t\t         \t\t}\r\n\t\t\t       \t} \r\n\t\t\t       }\r\n\t\t\t         ";

		private const string NetScriptSource_v4Class = "class __WebProxyScript { function ExecuteFindProxyForURL(url, host): String { return String(FindProxyForURL(url, host)); } }\r\n";

		private const string NetScriptSource_bindings = "var ProxyConfig = { bindings:{} };\r\n";

		public void Close()
		{
			if (startupInstance != null)
			{
				try
				{
					startupInstance.Shutdown();
					startupInstance = null;
				}
				catch (Exception ex)
				{
					throw new JSVsaException(JSVsaError.EngineCannotReset, ex.ToString(), ex);
				}
			}
			engine.Close();
		}

		public string Run(string url, string host)
		{
			return CallMethod(scriptInstance, "ExecuteFindProxyForURL", new object[2] { url, host }) as string;
		}

		public override object InitializeLifetimeService()
		{
			return null;
		}

		[ReflectionPermission(SecurityAction.Assert, Flags = ReflectionPermissionFlag.MemberAccess)]
		private static object CallMethod(object targetObject, string name, object[] args)
		{
			if (targetObject == null || name == null)
			{
				return null;
			}
			Type type = targetObject.GetType();
			Type[] array = new Type[args.Length];
			for (int i = 0; i < args.Length; i++)
			{
				array[i] = args[i].GetType();
			}
			MethodInfo method = type.GetMethod(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.InvokeMethod | BindingFlags.CreateInstance, Type.DefaultBinder, array, null);
			return method.Invoke(targetObject, args);
		}

		public bool Load(Uri engineScriptLocation, string scriptBody, Type helperType)
		{
			if (!CompileScript(engineScriptLocation, scriptBody, helperType, out var pe, out var pdb))
			{
				return false;
			}
			return LoadAssembly(pe, pdb);
		}

		[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
		private bool CompileScript(Uri engineScriptLocation, string scriptBody, Type helperType, out byte[] pe, out byte[] pdb)
		{
			pe = null;
			pdb = null;
			try
			{
				engine = new VsaEngine();
				engine.RootMoniker = "pac-" + engineScriptLocation.ToString();
				engine.Site = new VsaEngineSite(helperType);
				engine.InitNew();
				engine.RootNamespace = "__WebProxyScript";
				engine.SetOption("print", false);
				engine.SetOption("fast", false);
				engine.SetOption("autoref", false);
				string text = typeof(SecurityTransparentAttribute).Assembly.GetName().Name + ".dll";
				IJSVsaReferenceItem iJSVsaReferenceItem = engine.Items.CreateItem(text, JSVsaItemType.Reference, JSVsaItemFlag.None) as IJSVsaReferenceItem;
				iJSVsaReferenceItem.AssemblyName = text;
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append("import System.Security;\r\n[assembly:System.Security.SecurityTransparent()]\r\nfunction isPlainHostName(hostName: String): Boolean { return __om.isPlainHostName(hostName); }\r\nfunction dnsDomainIs(host: String, domain: String): Boolean { return __om.dnsDomainIs(host, domain); }\r\nfunction localHostOrDomainIs(host: String, hostdom: String): Boolean { return __om.localHostOrDomainIs(host, hostdom); }\r\nfunction isResolvable(host: String): Boolean { return __om.isResolvable(host); }\r\nfunction isInNet(host: String, pattern: String, mask: String): Boolean { return __om.isInNet(host, pattern, mask); }\r\nfunction dnsResolve(host: String): String { return __om.dnsResolve(host); }\r\nfunction myIpAddress(): String { return __om.myIpAddress(); }\r\nfunction dnsDomainLevels(host: String): int { return __om.dnsDomainLevels(host); }\r\nfunction shExpMatch(str: String, pattern: String): Boolean { return __om.shExpMatch(str, pattern); }\r\nfunction weekdayRange(wd1: String, wd2: String, gmt: String): Boolean { return __om.weekdayRange(wd1, wd2, gmt); }\r\nfunction dateRange(day1, month1, year1, day2, month2, year2, gmt): Boolean { return true; }\r\nfunction timeRange(hour1, min1, sec1, hour2, min2, sec2, gmt): Boolean { return true; }\r\n");
				if (Socket.OSSupportsIPv6)
				{
					stringBuilder.Append("function getClientVersion(): String { return __om.getClientVersion(); }\r\nfunction sortIpAddressList(IPAddressList:String): String { return __om.sortIpAddressList(IPAddressList); }\r\nfunction isInNetEx(ipAddress:String, ipPrefix:String): Boolean { return __om.isInNetEx(ipAddress, ipPrefix); }\r\nfunction myIpAddressEx(): String { return __om.myIpAddressEx(); }\r\nfunction dnsResolveEx(host:String): String { return __om.dnsResolveEx(host); }\r\nfunction isResolvableEx(host:String): Boolean { return __om.isResolvableEx(host); }\r\nvar __RefereceOfFindProxyForURLEx = this[\"FindProxyForURLEx\"];\r\nvar bFindProxyForURLExFound : Boolean = __RefereceOfFindProxyForURLEx != null && typeof(__RefereceOfFindProxyForURLEx) == \"function\";\r\nclass __WebProxyScript { \t\r\n\t\t\t     \tfunction ExecuteFindProxyForURL(url, host): String { \r\n\t\t         \t\tif(bFindProxyForURLExFound) {\r\n\t\t         \t\t\treturn String(FindProxyForURLEx(url, host)); \r\n\t\t         \t\t}\r\n\t\t         \t\telse {\r\n\t\t\t         \t\treturn String(FindProxyForURL(url, host)); \r\n\t\t         \t\t}\r\n\t\t\t       \t} \r\n\t\t\t       }\r\n\t\t\t         ");
				}
				else
				{
					stringBuilder.Append("class __WebProxyScript { function ExecuteFindProxyForURL(url, host): String { return String(FindProxyForURL(url, host)); } }\r\n");
				}
				stringBuilder.Append("var ProxyConfig = { bindings:{} };\r\n");
				stringBuilder.Append("//@position(file=\"" + engineScriptLocation.ToString() + "\",line = 1)\n");
				stringBuilder.Append(scriptBody);
				IJSVsaCodeItem iJSVsaCodeItem = engine.Items.CreateItem("SourceText", JSVsaItemType.Code, JSVsaItemFlag.None) as IJSVsaCodeItem;
				iJSVsaCodeItem.SourceText = stringBuilder.ToString();
				engine.Items.CreateItem("__om", JSVsaItemType.AppGlobal, JSVsaItemFlag.None);
				if (engine.Compile())
				{
					engine.SaveCompiledState(out pe, out pdb);
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		private bool LoadAssembly(byte[] pe, byte[] pdb)
		{
			try
			{
				Assembly assembly = Assembly.Load(pe, pdb, SecurityContextSource.CurrentAppDomain);
				Type type = assembly.GetType(engine.RootNamespace + "._Startup");
				startupInstance = (BaseVsaStartup)Activator.CreateInstance(type);
				startupInstance.SetSite(engine.Site);
				startupInstance.Startup();
				Type type2 = assembly.GetType(engine.RootNamespace + ".__WebProxyScript");
				scriptInstance = Activator.CreateInstance(type2);
				CallMethod(scriptInstance, "SetEngine", new object[1] { engine });
			}
			catch
			{
				return false;
			}
			return true;
		}
	}
}
namespace Microsoft.JScript
{
	internal static class BuildVersionInfo
	{
		public const int MajorVersion = 14;

		public const int MinorVersion = 0;

		public const int Build = 9037;

		public const int Revision = 0;
	}
	/// <summary>Represents an object that is taking part in a scope hierarchy. This class contains methods for resolving scope and for getting member information. It belongs to the compilation and run-time state category.</summary>
	[ComVisible(true)]
	public abstract class ActivationObject : ScriptObject, IActivationObject
	{
		internal bool isKnownAtCompileTime;

		internal bool fast;

		internal SimpleHashtable name_table;

		/// <summary>Stores an array of variables that are in scope.</summary>
		protected ArrayList field_table;

		internal ActivationObject(ScriptObject parent)
			: base(parent)
		{
			name_table = new SimpleHashtable(32u);
			field_table = new ArrayList();
		}

		internal virtual JSVariableField AddFieldOrUseExistingField(string name, object value, FieldAttributes attributeFlags)
		{
			FieldInfo fieldInfo = (FieldInfo)name_table[name];
			if (fieldInfo is JSVariableField)
			{
				if (!(value is Missing))
				{
					((JSVariableField)fieldInfo).value = value;
				}
				return (JSVariableField)fieldInfo;
			}
			if (value is Missing)
			{
				value = null;
			}
			return AddNewField(name, value, attributeFlags);
		}

		internal void AddClassesExcluding(ClassScope excludedClass, string name, ArrayList result)
		{
			ArrayList arrayList = new ArrayList();
			MemberInfo[] members = GetMembers(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (MemberInfo memberInfo in members)
			{
				if (!(memberInfo is JSVariableField) || !((JSVariableField)memberInfo).IsLiteral)
				{
					continue;
				}
				object value = ((JSVariableField)memberInfo).value;
				if (value is ClassScope)
				{
					ClassScope classScope = (ClassScope)value;
					if (!(classScope.name != memberInfo.Name) && (excludedClass == null || !excludedClass.IsSameOrDerivedFrom(classScope)) && classScope.GetMember(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length != 0)
					{
						arrayList.Add(classScope);
					}
				}
			}
			if (arrayList.Count != 0)
			{
				ClassScope[] array = new ClassScope[arrayList.Count];
				arrayList.CopyTo(array);
				Array.Sort(array);
				result.AddRange(array);
			}
		}

		internal virtual JSVariableField AddNewField(string name, object value, FieldAttributes attributeFlags)
		{
			JSVariableField jSVariableField = CreateField(name, attributeFlags, value);
			name_table[name] = jSVariableField;
			field_table.Add(jSVariableField);
			return jSVariableField;
		}

		/// <summary>Creates a new global variable, using the specified name, value, and attributes.</summary>
		/// <param name="name">The name of the field.</param>
		/// <param name="attributeFlags">A bitwise combination of the enumeration values that describe the attributes of a field. <see cref="F:System.Reflection.FieldAttributes.Static" /> is added automatically.</param>
		/// <param name="value">The value of the field.</param>
		/// <returns>A global variable that has the specified name, value, and attributes.</returns>
		protected virtual JSVariableField CreateField(string name, FieldAttributes attributeFlags, object value)
		{
			return new JSGlobalField(this, name, value, attributeFlags | FieldAttributes.Static);
		}

		/// <summary>Returns a field that has the specified name by searching the scope hierarchy. This method searches only the scope that is specified by the lexical level.</summary>
		/// <param name="name">The name of the field to search for.</param>
		/// <param name="lexLevel">The lexical level to search.</param>
		/// <returns>A <see cref="T:System.Reflection.FieldInfo" /> object that has the specified name.</returns>
		public virtual FieldInfo GetField(string name, int lexLevel)
		{
			throw new JScriptException(JSError.InternalError);
		}

		internal virtual string GetName()
		{
			return null;
		}

		/// <summary>Gets the current default scope, which is either the contained object of a <see langword="with" /> statement scope, or the global scope.</summary>
		/// <returns>The current default scope.</returns>
		public virtual object GetDefaultThisObject()
		{
			return ((IActivationObject)GetParent()).GetDefaultThisObject();
		}

		/// <summary>Gets the global scope by searching the scope hierarchy until it finds a scope that includes static variables, for example, a module scope.</summary>
		/// <returns>The global scope.</returns>
		public virtual GlobalScope GetGlobalScope()
		{
			return ((IActivationObject)GetParent()).GetGlobalScope();
		}

		/// <summary>Gets the local declaration of a field that has the specified name. This is used at compile time for error checking.</summary>
		/// <param name="name">The name of the field.</param>
		/// <returns>The local declaration of the field.</returns>
		public virtual FieldInfo GetLocalField(string name)
		{
			return (FieldInfo)name_table[name];
		}

		/// <summary>Retrieves an array of <see cref="T:System.Reflection.MemberInfo" /> objects that correspond to all members that match a specified name.</summary>
		/// <param name="name">The name of the member to search for.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that match the <paramref name="name" /> argument.</returns>
		public override MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
		{
			FieldInfo fieldInfo = (FieldInfo)name_table[name];
			if (fieldInfo != null)
			{
				return new MemberInfo[1] { fieldInfo };
			}
			if (parent != null && (bindingAttr & BindingFlags.DeclaredOnly) == 0)
			{
				return ScriptObject.WrapMembers(parent.GetMember(name, bindingAttr), parent);
			}
			return new MemberInfo[0];
		}

		/// <summary>Retrieves an array of <see cref="T:System.Reflection.MemberInfo" /> objects that corresponds to all members of the current object.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all members of the current object.</returns>
		public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
		{
			int count = field_table.Count;
			MemberInfo[] array = new MemberInfo[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = (MemberInfo)field_table[i];
			}
			return array;
		}

		/// <summary>Gets the value of the specified member by searching the scope hierarchy. This method searches only the scope that is specified by the lexical level.</summary>
		/// <param name="name">The name of the member to search for.</param>
		/// <param name="lexlevel">The lexical level to search.</param>
		/// <returns>The value of the member <paramref name="name" />.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public object GetMemberValue(string name, int lexlevel)
		{
			if (lexlevel <= 0)
			{
				return Missing.Value;
			}
			FieldInfo fieldInfo = (FieldInfo)name_table[name];
			if (fieldInfo != null)
			{
				return fieldInfo.GetValue(this);
			}
			if (parent != null)
			{
				return ((IActivationObject)parent).GetMemberValue(name, lexlevel - 1);
			}
			return Missing.Value;
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public sealed class ActiveXObjectConstructor : ScriptFunction
	{
		internal static readonly ActiveXObjectConstructor ob = new ActiveXObjectConstructor();

		internal ActiveXObjectConstructor()
			: base(FunctionPrototype.ob, "ActiveXObject", 1)
		{
		}

		internal ActiveXObjectConstructor(LenientFunctionPrototype parent)
			: base(parent, "ActiveXObject", 1)
		{
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			return null;
		}

		internal override object Construct(object[] args)
		{
			return CreateInstance(args);
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>The instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new object CreateInstance(params object[] args)
		{
			if (args.Length == 0 || args[0].GetType() != typeof(string))
			{
				throw new JScriptException(JSError.TypeMismatch);
			}
			string progID = args[0].ToString();
			string text = null;
			if (args.Length == 2)
			{
				if (args[1].GetType() != typeof(string))
				{
					throw new JScriptException(JSError.TypeMismatch);
				}
				text = args[1].ToString();
			}
			try
			{
				Type type = null;
				type = ((text != null) ? Type.GetTypeFromProgID(progID, text) : Type.GetTypeFromProgID(progID));
				if (!type.IsPublic && type.Assembly == typeof(ActiveXObjectConstructor).Assembly)
				{
					throw new JScriptException(JSError.CantCreateObject);
				}
				return Activator.CreateInstance(type);
			}
			catch
			{
				throw new JScriptException(JSError.CantCreateObject);
			}
		}

		/// <summary>Returns null in all cases.</summary>
		/// <returns>null.</returns>
		public object Invoke()
		{
			return null;
		}

		internal override bool HasInstance(object ob)
		{
			if (ob is JSObject)
			{
				return false;
			}
			return true;
		}
	}
	internal sealed class AddressOf : UnaryOp
	{
		internal AddressOf(Context context, AST operand)
			: base(context, operand)
		{
		}

		internal override object Evaluate()
		{
			return operand.Evaluate();
		}

		internal FieldInfo GetField()
		{
			if (!(operand is Binding))
			{
				return null;
			}
			MemberInfo member = ((Binding)operand).member;
			if (member is FieldInfo)
			{
				return (FieldInfo)member;
			}
			return null;
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return operand.InferType(inference_target);
		}

		internal override AST PartiallyEvaluate()
		{
			operand = operand.PartiallyEvaluate();
			if (!(operand is Binding) || !((Binding)operand).RefersToMemoryLocation())
			{
				context.HandleError(JSError.DoesNotHaveAnAddress);
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			operand.TranslateToIL(il, rtype);
		}

		internal override void TranslateToILPreSet(ILGenerator il)
		{
			operand.TranslateToILPreSet(il);
		}

		internal override object TranslateToILReference(ILGenerator il, Type rtype)
		{
			return operand.TranslateToILReference(il, rtype);
		}

		internal override void TranslateToILSet(ILGenerator il, AST rhvalue)
		{
			operand.TranslateToILSet(il, rhvalue);
		}
	}
	/// <summary>Represents the information that is used to call a function. This includes the function, the caller, the arguments, and information about the stack frame. This class belongs to the objects and functions category.</summary>
	public sealed class ArgumentsObject : JSObject
	{
		private object[] arguments;

		private string[] formal_names;

		private ScriptObject scope;

		/// <summary>A closure function that represents the function that is being called.</summary>
		public object callee;

		/// <summary>The calling scope information from the stack frame.</summary>
		public object caller;

		/// <summary>The number of arguments.</summary>
		public object length;

		internal ArgumentsObject(ScriptObject parent, object[] arguments, FunctionObject function, Closure callee, ScriptObject scope, ArgumentsObject caller)
			: base(parent)
		{
			this.arguments = arguments;
			formal_names = function.formal_parameters;
			this.scope = scope;
			this.callee = callee;
			this.caller = caller;
			length = arguments.Length;
			noExpando = false;
		}

		internal override object GetValueAtIndex(uint index)
		{
			if (index < arguments.Length)
			{
				return arguments[index];
			}
			return base.GetValueAtIndex(index);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object GetMemberValue(string name)
		{
			long num = ArrayObject.Array_index_for(name);
			if (num < 0)
			{
				return base.GetMemberValue(name);
			}
			return GetValueAtIndex((uint)num);
		}

		internal override void SetValueAtIndex(uint index, object value)
		{
			if (index < arguments.Length)
			{
				arguments[index] = value;
			}
			else
			{
				base.SetValueAtIndex(index, value);
			}
		}

		internal object[] ToArray()
		{
			return arguments;
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public sealed class ArrayConstructor : ScriptFunction
	{
		internal static readonly ArrayConstructor ob = new ArrayConstructor();

		private ArrayPrototype originalPrototype;

		internal ArrayConstructor()
			: base(FunctionPrototype.ob, "Array", 1)
		{
			originalPrototype = ArrayPrototype.ob;
			ArrayPrototype._constructor = this;
			proto = ArrayPrototype.ob;
		}

		internal ArrayConstructor(LenientFunctionPrototype parent, LenientArrayPrototype prototypeProp)
			: base(parent, "Array", 1)
		{
			originalPrototype = prototypeProp;
			prototypeProp.constructor = this;
			proto = prototypeProp;
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			return Construct(args);
		}

		internal ArrayObject Construct()
		{
			return new ArrayObject(originalPrototype, typeof(ArrayObject));
		}

		internal override object Construct(object[] args)
		{
			return CreateInstance(args);
		}

		/// <summary>Helper method that creates a new array and populates it with the specified values.</summary>
		/// <param name="args">The values to populate the array with.</param>
		/// <returns>The new array.</returns>
		public ArrayObject ConstructArray(object[] args)
		{
			ArrayObject arrayObject = new ArrayObject(originalPrototype, typeof(ArrayObject));
			arrayObject.length = args.Length;
			for (int i = 0; i < args.Length; i++)
			{
				arrayObject.SetValueAtIndex((uint)i, args[i]);
			}
			return arrayObject;
		}

		internal ArrayObject ConstructWrapper()
		{
			return new ArrayWrapper(originalPrototype, null, implicitWrapper: false);
		}

		internal ArrayObject ConstructWrapper(Array arr)
		{
			return new ArrayWrapper(originalPrototype, arr, implicitWrapper: false);
		}

		internal ArrayObject ConstructImplicitWrapper(Array arr)
		{
			return new ArrayWrapper(originalPrototype, arr, implicitWrapper: true);
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>The instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new ArrayObject CreateInstance(params object[] args)
		{
			ArrayObject arrayObject = new ArrayObject(originalPrototype, typeof(ArrayObject));
			if (args.Length != 0)
			{
				if (args.Length == 1)
				{
					object value = args[0];
					IConvertible iConvertible = Convert.GetIConvertible(value);
					TypeCode typeCode = Convert.GetTypeCode(value, iConvertible);
					if ((uint)(typeCode - 4) <= 11u)
					{
						double num = Convert.ToNumber(value, iConvertible);
						uint num2 = Convert.ToUint32(value, iConvertible);
						if (num != (double)num2)
						{
							throw new JScriptException(JSError.ArrayLengthConstructIncorrect);
						}
						arrayObject.length = num2;
						return arrayObject;
					}
				}
				if (args.Length == 1 && args[0] is Array)
				{
					Array array = (Array)args[0];
					if (array.Rank != 1)
					{
						throw new JScriptException(JSError.TypeMismatch);
					}
					arrayObject.length = array.Length;
					for (int i = 0; i < array.Length; i++)
					{
						arrayObject.SetValueAtIndex((uint)i, array.GetValue(i));
					}
				}
				else
				{
					arrayObject.length = args.Length;
					for (int j = 0; j < args.Length; j++)
					{
						arrayObject.SetValueAtIndex((uint)j, args[j]);
					}
				}
			}
			return arrayObject;
		}

		/// <summary>Invokes a method of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the method.</param>
		/// <returns>The result of the call to the method.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public ArrayObject Invoke(params object[] args)
		{
			if (args.Length == 1 && args[0] is Array)
			{
				return ConstructWrapper((Array)args[0]);
			}
			return CreateInstance(args);
		}
	}
	internal class ArrayEnumerator : IEnumerator
	{
		private int curr;

		private bool doDenseEnum;

		private bool didDenseEnum;

		private ArrayObject arrayOb;

		private IEnumerator denseEnum;

		public virtual object Current
		{
			get
			{
				if (doDenseEnum)
				{
					return denseEnum.Current;
				}
				if (curr >= arrayOb.len || curr >= arrayOb.denseArrayLength)
				{
					return denseEnum.Current;
				}
				return curr.ToString(CultureInfo.InvariantCulture);
			}
		}

		internal ArrayEnumerator(ArrayObject arrayOb, IEnumerator denseEnum)
		{
			curr = -1;
			doDenseEnum = false;
			didDenseEnum = false;
			this.arrayOb = arrayOb;
			this.denseEnum = denseEnum;
		}

		public virtual bool MoveNext()
		{
			if (doDenseEnum)
			{
				if (denseEnum.MoveNext())
				{
					return true;
				}
				doDenseEnum = false;
				didDenseEnum = true;
			}
			int num = curr + 1;
			if (num >= arrayOb.len || num >= arrayOb.denseArrayLength)
			{
				doDenseEnum = !didDenseEnum;
				return denseEnum.MoveNext();
			}
			curr = num;
			if (arrayOb.GetValueAtIndex((uint)num) is Missing)
			{
				return MoveNext();
			}
			return true;
		}

		public virtual void Reset()
		{
			curr = -1;
			doDenseEnum = false;
			didDenseEnum = false;
			denseEnum.Reset();
		}
	}
	/// <summary>This class is used by the JScript parser to represent an array literal.</summary>
	public sealed class ArrayLiteral : AST
	{
		internal ASTList elements;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.ArrayLiteral" /> class, specifying the context and elements.</summary>
		/// <param name="context">The current document context.</param>
		/// <param name="elements">The elements of the array.</param>
		public ArrayLiteral(Context context, ASTList elements)
			: base(context)
		{
			this.elements = elements;
		}

		internal bool AssignmentCompatible(IReflect lhir, bool reportError)
		{
			if (lhir == Typeob.Object || lhir == Typeob.Array || lhir is ArrayObject)
			{
				return true;
			}
			IReflect lhir2;
			if (lhir == Typeob.Array)
			{
				lhir2 = Typeob.Object;
			}
			else if (lhir is TypedArray)
			{
				TypedArray typedArray = (TypedArray)lhir;
				if (typedArray.rank != 1)
				{
					context.HandleError(JSError.TypeMismatch, reportError);
					return false;
				}
				lhir2 = typedArray.elementType;
			}
			else
			{
				if (!(lhir is Type) || !((Type)lhir).IsArray)
				{
					return false;
				}
				Type type = (Type)lhir;
				if (type.GetArrayRank() != 1)
				{
					context.HandleError(JSError.TypeMismatch, reportError);
					return false;
				}
				lhir2 = type.GetElementType();
			}
			int i = 0;
			for (int count = elements.count; i < count; i++)
			{
				if (!Binding.AssignmentCompatible(lhir2, elements[i], elements[i].InferType(null), reportError))
				{
					return false;
				}
			}
			return true;
		}

		internal override void CheckIfOKToUseInSuperConstructorCall()
		{
			int i = 0;
			for (int count = elements.count; i < count; i++)
			{
				elements[i].CheckIfOKToUseInSuperConstructorCall();
			}
		}

		internal override object Evaluate()
		{
			if (VsaEngine.executeForJSEE)
			{
				throw new JScriptException(JSError.NonSupportedInDebugger);
			}
			int count = elements.count;
			object[] array = new object[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = elements[i].Evaluate();
			}
			return base.Engine.GetOriginalArrayConstructor().ConstructArray(array);
		}

		internal bool IsOkToUseInCustomAttribute()
		{
			int count = elements.count;
			for (int i = 0; i < count; i++)
			{
				object obj = elements[i];
				if (!(obj is ConstantWrapper))
				{
					return false;
				}
				if (CustomAttribute.TypeOfArgument(((ConstantWrapper)obj).Evaluate()) == null)
				{
					return false;
				}
			}
			return true;
		}

		internal override AST PartiallyEvaluate()
		{
			int count = elements.count;
			for (int i = 0; i < count; i++)
			{
				elements[i] = elements[i].PartiallyEvaluate();
			}
			return this;
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return Typeob.ArrayObject;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (rtype == Typeob.Array)
			{
				TranslateToILArray(il, Typeob.Object);
				return;
			}
			if (rtype.IsArray && rtype.GetArrayRank() == 1)
			{
				TranslateToILArray(il, rtype.GetElementType());
				return;
			}
			int count = elements.count;
			MethodInfo methodInfo = null;
			if (base.Engine.Globals.globalObject is LenientGlobalObject)
			{
				EmitILToLoadEngine(il);
				il.Emit(OpCodes.Call, CompilerGlobals.getOriginalArrayConstructorMethod);
				methodInfo = CompilerGlobals.constructArrayMethod;
			}
			else
			{
				methodInfo = CompilerGlobals.fastConstructArrayLiteralMethod;
			}
			ConstantWrapper.TranslateToILInt(il, count);
			il.Emit(OpCodes.Newarr, Typeob.Object);
			for (int i = 0; i < count; i++)
			{
				il.Emit(OpCodes.Dup);
				ConstantWrapper.TranslateToILInt(il, i);
				elements[i].TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Stelem_Ref);
			}
			il.Emit(OpCodes.Call, methodInfo);
			Convert.Emit(this, il, Typeob.ArrayObject, rtype);
		}

		private void TranslateToILArray(ILGenerator il, Type etype)
		{
			int count = elements.count;
			ConstantWrapper.TranslateToILInt(il, count);
			TypeCode typeCode = Type.GetTypeCode(etype);
			il.Emit(OpCodes.Newarr, etype);
			for (int i = 0; i < count; i++)
			{
				il.Emit(OpCodes.Dup);
				ConstantWrapper.TranslateToILInt(il, i);
				if (etype.IsValueType && !etype.IsPrimitive)
				{
					il.Emit(OpCodes.Ldelema, etype);
				}
				elements[i].TranslateToIL(il, etype);
				Binding.TranslateToStelem(il, etype);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			int i = 0;
			for (int count = elements.count; i < count; i++)
			{
				elements[i].TranslateToILInitializer(il);
			}
		}
	}
	/// <summary>Represents an array object. This class belongs to the built-in object model category.</summary>
	public class ArrayObject : JSObject
	{
		internal const int MaxIndex = 100000;

		internal const int MinDenseSize = 128;

		internal uint len;

		internal object[] denseArray;

		internal uint denseArrayLength;

		/// <summary>Gets or sets the length of the array.</summary>
		/// <returns>The length of the array.</returns>
		public virtual object length
		{
			get
			{
				if (len < int.MaxValue)
				{
					return (int)len;
				}
				return (double)len;
			}
			set
			{
				IConvertible iConvertible = Convert.GetIConvertible(value);
				uint num = Convert.ToUint32(value, iConvertible);
				if ((double)num != Convert.ToNumber(value, iConvertible))
				{
					throw new JScriptException(JSError.ArrayLengthAssignIncorrect);
				}
				SetLength(num);
			}
		}

		internal ArrayObject(ScriptObject prototype)
			: base(prototype)
		{
			len = 0u;
			denseArray = null;
			denseArrayLength = 0u;
			noExpando = false;
		}

		internal ArrayObject(ScriptObject prototype, Type subType)
			: base(prototype, subType)
		{
			len = 0u;
			denseArray = null;
			denseArrayLength = 0u;
			noExpando = false;
		}

		internal static long Array_index_for(object index)
		{
			if (index is int)
			{
				return (int)index;
			}
			IConvertible iConvertible = Convert.GetIConvertible(index);
			TypeCode typeCode = Convert.GetTypeCode(index, iConvertible);
			if ((uint)(typeCode - 4) <= 11u)
			{
				double num = iConvertible.ToDouble(null);
				long num2 = (long)num;
				if (num2 >= 0 && (double)num2 == num)
				{
					return num2;
				}
			}
			return -1L;
		}

		internal static long Array_index_for(string name)
		{
			int num = name.Length;
			if (num <= 0)
			{
				return -1L;
			}
			char c = name[0];
			if (c < '1' || c > '9')
			{
				if (c == '0' && num == 1)
				{
					return 0L;
				}
				return -1L;
			}
			long num2 = c - 48;
			for (int i = 1; i < num; i++)
			{
				c = name[i];
				if (c < '0' || c > '9')
				{
					return -1L;
				}
				num2 = num2 * 10 + (c - 48);
				if (num2 > uint.MaxValue)
				{
					return -1L;
				}
			}
			return num2;
		}

		internal virtual void Concat(ArrayObject source)
		{
			uint num = source.len;
			if (num == 0)
			{
				return;
			}
			uint num2 = len;
			SetLength((ulong)num2 + (ulong)num);
			uint num3 = num;
			if (!(source is ArrayWrapper) && num > source.denseArrayLength)
			{
				num3 = source.denseArrayLength;
			}
			uint num4 = num2;
			for (uint num5 = 0u; num5 < num3; num5++)
			{
				SetValueAtIndex(num4++, source.GetValueAtIndex(num5));
			}
			if (num3 == num)
			{
				return;
			}
			IDictionaryEnumerator enumerator = source.NameTable.GetEnumerator();
			while (enumerator.MoveNext())
			{
				long num6 = Array_index_for(enumerator.Key.ToString());
				if (num6 >= 0)
				{
					SetValueAtIndex(num2 + (uint)(int)num6, ((JSField)enumerator.Value).GetValue(null));
				}
			}
		}

		internal virtual void Concat(object value)
		{
			if (value is Array array && array.Rank == 1)
			{
				Concat(new ArrayWrapper(ArrayPrototype.ob, array, implicitWrapper: true));
				return;
			}
			uint num = len;
			SetLength(1uL + (ulong)num);
			SetValueAtIndex(num, value);
		}

		internal override bool DeleteMember(string name)
		{
			long num = Array_index_for(name);
			if (num >= 0)
			{
				return DeleteValueAtIndex((uint)num);
			}
			return base.DeleteMember(name);
		}

		internal virtual bool DeleteValueAtIndex(uint index)
		{
			if (index < denseArrayLength)
			{
				if (denseArray[index] is Missing)
				{
					return false;
				}
				denseArray[index] = Missing.Value;
				return true;
			}
			return base.DeleteMember(index.ToString(CultureInfo.InvariantCulture));
		}

		private void DeleteRange(uint start, uint end)
		{
			uint num = denseArrayLength;
			if (num > end)
			{
				num = end;
			}
			while (start < num)
			{
				denseArray[start] = Missing.Value;
				start++;
			}
			if (num == end)
			{
				return;
			}
			IDictionaryEnumerator enumerator = base.NameTable.GetEnumerator();
			ArrayList arrayList = new ArrayList(name_table.count);
			while (enumerator.MoveNext())
			{
				long num2 = Array_index_for(enumerator.Key.ToString());
				if (num2 >= start && num2 <= end)
				{
					arrayList.Add(enumerator.Key);
				}
			}
			IEnumerator enumerator2 = arrayList.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				DeleteMember((string)enumerator2.Current);
			}
		}

		internal override string GetClassName()
		{
			return "Array";
		}

		internal override object GetDefaultValue(PreferredType preferred_type)
		{
			if (GetParent() is LenientArrayPrototype)
			{
				return base.GetDefaultValue(preferred_type);
			}
			switch (preferred_type)
			{
			case PreferredType.String:
				if (!noExpando)
				{
					object obj2 = base.NameTable["toString"];
					if (obj2 != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return ArrayPrototype.toString(this);
			case PreferredType.LocaleString:
				if (!noExpando)
				{
					object obj3 = base.NameTable["toLocaleString"];
					if (obj3 != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return ArrayPrototype.toLocaleString(this);
			default:
				if (!noExpando)
				{
					object obj = base.NameTable["valueOf"];
					if (obj == null && preferred_type == PreferredType.Either)
					{
						obj = base.NameTable["toString"];
					}
					if (obj != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return ArrayPrototype.toString(this);
			}
		}

		internal override void GetPropertyEnumerator(ArrayList enums, ArrayList objects)
		{
			if (field_table == null)
			{
				field_table = new ArrayList();
			}
			enums.Add(new ArrayEnumerator(this, new ListEnumerator(field_table)));
			objects.Add(this);
			if (parent != null)
			{
				parent.GetPropertyEnumerator(enums, objects);
			}
		}

		internal override object GetValueAtIndex(uint index)
		{
			if (index < denseArrayLength)
			{
				object obj = denseArray[index];
				if (obj != Missing.Value)
				{
					return obj;
				}
			}
			return base.GetValueAtIndex(index);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object GetMemberValue(string name)
		{
			long num = Array_index_for(name);
			if (num < 0)
			{
				return base.GetMemberValue(name);
			}
			return GetValueAtIndex((uint)num);
		}

		private void Realloc(uint newLength)
		{
			uint num = denseArrayLength;
			uint num2 = num * 2;
			if (num2 < newLength)
			{
				num2 = newLength;
			}
			object[] array = new object[num2];
			if (num != 0)
			{
				Copy(denseArray, array, (int)num);
			}
			for (int i = (int)num; i < num2; i++)
			{
				array[i] = Missing.Value;
			}
			denseArray = array;
			denseArrayLength = num2;
		}

		private void SetLength(ulong newLength)
		{
			uint num = len;
			if (newLength < num)
			{
				DeleteRange((uint)newLength, num);
			}
			else
			{
				if (newLength > uint.MaxValue)
				{
					throw new JScriptException(JSError.ArrayLengthAssignIncorrect);
				}
				if (newLength > denseArrayLength && num <= denseArrayLength && newLength <= 100000 && (newLength <= 128 || newLength <= num * 2))
				{
					Realloc((uint)newLength);
				}
			}
			len = (uint)newLength;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override void SetMemberValue(string name, object value)
		{
			if (name.Equals("length"))
			{
				length = value;
				return;
			}
			long num = Array_index_for(name);
			if (num < 0)
			{
				base.SetMemberValue(name, value);
			}
			else
			{
				SetValueAtIndex((uint)num, value);
			}
		}

		internal override void SetValueAtIndex(uint index, object value)
		{
			if (index >= len && index < uint.MaxValue)
			{
				SetLength(index + 1);
			}
			if (index < denseArrayLength)
			{
				denseArray[index] = value;
			}
			else
			{
				base.SetMemberValue(index.ToString(CultureInfo.InvariantCulture), value);
			}
		}

		internal virtual object Shift()
		{
			object result = null;
			uint num = len;
			if (num == 0)
			{
				return result;
			}
			uint num2 = ((denseArrayLength >= num) ? num : denseArrayLength);
			if (num2 != 0)
			{
				result = denseArray[0];
				Copy(denseArray, 1, denseArray, 0, (int)(num2 - 1));
			}
			else
			{
				result = base.GetValueAtIndex(0u);
			}
			for (uint num3 = num2; num3 < num; num3++)
			{
				SetValueAtIndex(num3 - 1, GetValueAtIndex(num3));
			}
			SetValueAtIndex(num - 1, Missing.Value);
			SetLength(num - 1);
			if (result is Missing)
			{
				return null;
			}
			return result;
		}

		internal virtual void Sort(ScriptFunction compareFn)
		{
			QuickSort quickSort = new QuickSort(this, compareFn);
			uint num = len;
			if (num <= denseArrayLength)
			{
				quickSort.SortArray(0, (int)(num - 1));
			}
			else
			{
				quickSort.SortObject(0L, num - 1);
			}
		}

		internal virtual void Splice(uint start, uint deleteCount, object[] args, ArrayObject outArray, uint oldLength, uint newLength)
		{
			if (oldLength > denseArrayLength)
			{
				SpliceSlowly(start, deleteCount, args, outArray, oldLength, newLength);
				return;
			}
			if (newLength > oldLength)
			{
				SetLength(newLength);
				if (newLength > denseArrayLength)
				{
					SpliceSlowly(start, deleteCount, args, outArray, oldLength, newLength);
					return;
				}
			}
			if (deleteCount > oldLength)
			{
				deleteCount = oldLength;
			}
			if (deleteCount != 0)
			{
				Copy(denseArray, (int)start, outArray.denseArray, 0, (int)deleteCount);
			}
			if (oldLength != 0)
			{
				Copy(denseArray, (int)(start + deleteCount), denseArray, (int)start + args.Length, (int)(oldLength - start - deleteCount));
			}
			if (args != null)
			{
				int num = args.Length;
				if (num > 0)
				{
					Copy(args, 0, denseArray, (int)start, num);
				}
				if (num < deleteCount)
				{
					SetLength(newLength);
				}
			}
			else if (deleteCount != 0)
			{
				SetLength(newLength);
			}
		}

		/// <summary>Adds elements to and removes elements from an array, at the specified position in the array. You can add elements, remove elements, or both.</summary>
		/// <param name="start">The position in this array at which to add and remove elements.</param>
		/// <param name="deleteCount">The number of elements to remove, if any.</param>
		/// <param name="args">The elements to add, if any.</param>
		/// <param name="outArray">An array that contains the elements removed from this array, if any have been removed.</param>
		/// <param name="oldLength">The previous length of this array.</param>
		/// <param name="newLength">The new length of this array.</param>
		protected void SpliceSlowly(uint start, uint deleteCount, object[] args, ArrayObject outArray, uint oldLength, uint newLength)
		{
			for (uint num = 0u; num < deleteCount; num++)
			{
				outArray.SetValueAtIndex(num, GetValueAtIndex(num + start));
			}
			uint num2 = oldLength - start - deleteCount;
			if (newLength < oldLength)
			{
				for (uint num3 = 0u; num3 < num2; num3++)
				{
					SetValueAtIndex(num3 + start + (uint)args.Length, GetValueAtIndex(num3 + start + deleteCount));
				}
				SetLength(newLength);
			}
			else
			{
				if (newLength > oldLength)
				{
					SetLength(newLength);
				}
				for (uint num4 = num2; num4 != 0; num4--)
				{
					SetValueAtIndex((uint)((int)(num4 + start) + args.Length - 1), GetValueAtIndex(num4 + start + deleteCount - 1));
				}
			}
			int num5 = ((args != null) ? args.Length : 0);
			for (uint num6 = 0u; num6 < num5; num6++)
			{
				SetValueAtIndex(num6 + start, args[num6]);
			}
		}

		internal override void SwapValues(uint pi, uint qi)
		{
			if (pi > qi)
			{
				SwapValues(qi, pi);
				return;
			}
			if (pi >= denseArrayLength)
			{
				base.SwapValues(pi, qi);
				return;
			}
			object obj = denseArray[pi];
			denseArray[pi] = GetValueAtIndex(qi);
			if (obj == Missing.Value)
			{
				DeleteValueAtIndex(qi);
			}
			else
			{
				SetValueAtIndex(qi, obj);
			}
		}

		internal virtual object[] ToArray()
		{
			int num = (int)len;
			if (num == 0)
			{
				return new object[0];
			}
			if (num == denseArrayLength)
			{
				return denseArray;
			}
			if (num < denseArrayLength)
			{
				object[] array = new object[num];
				Copy(denseArray, 0, array, 0, num);
				return array;
			}
			object[] array2 = new object[num];
			Copy(denseArray, 0, array2, 0, (int)denseArrayLength);
			for (uint num2 = denseArrayLength; num2 < num; num2++)
			{
				array2[num2] = GetValueAtIndex(num2);
			}
			return array2;
		}

		internal virtual Array ToNativeArray(Type elementType)
		{
			uint num = len;
			if (num > int.MaxValue)
			{
				throw new JScriptException(JSError.OutOfMemory);
			}
			if (elementType == null)
			{
				elementType = typeof(object);
			}
			uint num2 = denseArrayLength;
			if (num2 > num)
			{
				num2 = num;
			}
			Array array = Array.CreateInstance(elementType, (int)num);
			for (int i = 0; i < num2; i++)
			{
				array.SetValue(Convert.CoerceT(denseArray[i], elementType), i);
			}
			for (int j = (int)num2; j < num; j++)
			{
				array.SetValue(Convert.CoerceT(GetValueAtIndex((uint)j), elementType), j);
			}
			return array;
		}

		internal static void Copy(object[] source, object[] target, int n)
		{
			Copy(source, 0, target, 0, n);
		}

		internal static void Copy(object[] source, int i, object[] target, int j, int n)
		{
			if (i < j)
			{
				for (int num = n - 1; num >= 0; num--)
				{
					target[j + num] = source[i + num];
				}
			}
			else
			{
				for (int k = 0; k < n; k++)
				{
					target[j + k] = source[i + k];
				}
			}
		}

		internal virtual ArrayObject Unshift(object[] args)
		{
			uint num = len;
			int num2 = args.Length;
			ulong num3 = (ulong)(num + num2);
			SetLength(num3);
			if (num3 <= denseArrayLength)
			{
				for (int num4 = (int)(num - 1); num4 >= 0; num4--)
				{
					denseArray[num4 + num2] = denseArray[num4];
				}
				Copy(args, 0, denseArray, 0, args.Length);
			}
			else
			{
				for (long num5 = num - 1; num5 >= 0; num5--)
				{
					SetValueAtIndex((uint)(num5 + num2), GetValueAtIndex((uint)num5));
				}
				for (uint num6 = 0u; num6 < num2; num6++)
				{
					SetValueAtIndex(num6, args[num6]);
				}
			}
			return this;
		}

		internal DebugArrayFieldEnumerator DebugGetEnumerator()
		{
			return new DebugArrayFieldEnumerator(new ScriptObjectPropertyEnumerator(this), this);
		}

		internal object DebugGetValueAtIndex(int index)
		{
			return GetValueAtIndex((uint)index);
		}

		internal void DebugSetValueAtIndex(int index, object value)
		{
			SetValueAtIndex((uint)index, value);
		}
	}
	internal sealed class QuickSort
	{
		internal ScriptFunction compareFn;

		internal object obj;

		internal QuickSort(object obj, ScriptFunction compareFn)
		{
			this.compareFn = compareFn;
			this.obj = obj;
		}

		private int Compare(object x, object y)
		{
			if (x == null || x is Missing)
			{
				if (y == null || y is Missing)
				{
					return 0;
				}
				return 1;
			}
			if (y == null || y is Missing)
			{
				return -1;
			}
			if (compareFn != null)
			{
				double num = Convert.ToNumber(compareFn.Call(new object[2] { x, y }, null));
				if (num != num)
				{
					throw new JScriptException(JSError.NumberExpected);
				}
				return (int)Runtime.DoubleToInt64(num);
			}
			return string.CompareOrdinal(Convert.ToString(x), Convert.ToString(y));
		}

		internal void SortObject(long left, long right)
		{
			if (right <= left)
			{
				return;
			}
			long num = left + (long)((double)(right - left) * MathObject.random());
			LateBinding.SwapValues(obj, (uint)num, (uint)right);
			object valueAtIndex = LateBinding.GetValueAtIndex(obj, (ulong)right);
			long num2 = left - 1;
			long num3 = right;
			while (true)
			{
				object valueAtIndex2 = LateBinding.GetValueAtIndex(obj, (ulong)(++num2));
				if (num2 >= num3 || Compare(valueAtIndex, valueAtIndex2) < 0)
				{
					do
					{
						valueAtIndex2 = LateBinding.GetValueAtIndex(obj, (ulong)(--num3));
					}
					while (num3 > num2 && Compare(valueAtIndex, valueAtIndex2) <= 0);
					if (num2 >= num3)
					{
						break;
					}
					LateBinding.SwapValues(obj, (uint)num2, (uint)num3);
				}
			}
			LateBinding.SwapValues(obj, (uint)num2, (uint)right);
			SortObject(left, num2 - 1);
			SortObject(num2 + 1, right);
		}

		internal void SortArray(int left, int right)
		{
			ArrayObject arrayObject = (ArrayObject)this.obj;
			if (right <= left)
			{
				return;
			}
			int num = left + (int)((double)(right - left) * MathObject.random());
			object obj = arrayObject.denseArray[num];
			arrayObject.denseArray[num] = arrayObject.denseArray[right];
			arrayObject.denseArray[right] = obj;
			int num2 = left - 1;
			int num3 = right;
			while (true)
			{
				object y = arrayObject.denseArray[++num2];
				if (num2 >= num3 || Compare(obj, y) < 0)
				{
					do
					{
						y = arrayObject.denseArray[--num3];
					}
					while (num3 > num2 && Compare(obj, y) <= 0);
					if (num2 >= num3)
					{
						break;
					}
					Swap(arrayObject.denseArray, num2, num3);
				}
			}
			Swap(arrayObject.denseArray, num2, right);
			SortArray(left, num2 - 1);
			SortArray(num2 + 1, right);
		}

		private static void Swap(object[] array, int i, int j)
		{
			object obj = array[i];
			array[i] = array[j];
			array[j] = obj;
		}
	}
	/// <summary>Provides static methods and properties for <see cref="T:Microsoft.JScript.ArrayObject" /> objects. All methods of this class are called by passing in a reference to the object that is requesting access to the method. This class belongs to the built-in object model category.</summary>
	public class ArrayPrototype : ArrayObject
	{
		internal static readonly ArrayPrototype ob = new ArrayPrototype(ObjectPrototype.ob);

		internal static ArrayConstructor _constructor;

		/// <summary>Gets a reference to a prototype-based object that is using this prototype.</summary>
		/// <returns>A reference to a prototype-based object.</returns>
		public static ArrayConstructor constructor => _constructor;

		internal ArrayPrototype(ObjectPrototype parent)
			: base(parent)
		{
			noExpando = true;
		}

		/// <summary>Concatenates objects or arrays to the end of the specified object or array.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <param name="args">The objects or arrays to append to <paramref name="thisob" />.</param>
		/// <returns>
		///   <paramref name="thisob" /> and <paramref name="args" /> concatenated.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasVarArgs | JSFunctionAttributeEnum.HasEngine, JSBuiltin.Array_concat)]
		public static ArrayObject concat(object thisob, VsaEngine engine, params object[] args)
		{
			ArrayObject arrayObject = engine.GetOriginalArrayConstructor().Construct();
			if (thisob is ArrayObject)
			{
				arrayObject.Concat((ArrayObject)thisob);
			}
			else
			{
				arrayObject.Concat(thisob);
			}
			foreach (object obj in args)
			{
				if (obj is ArrayObject)
				{
					arrayObject.Concat((ArrayObject)obj);
				}
				else
				{
					arrayObject.Concat(obj);
				}
			}
			return arrayObject;
		}

		/// <summary>Concatenates the elements of the specified array into a string. The elements are separated by the specified separator.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="separator">The string to use to separate the elements. The default is a comma.</param>
		/// <returns>A string that concatenates the elements of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Array_join)]
		public static string join(object thisob, object separator)
		{
			if (separator is Missing)
			{
				return Join(thisob, ",", localize: false);
			}
			return Join(thisob, Convert.ToString(separator), localize: false);
		}

		internal static string Join(object thisob, string separator, bool localize)
		{
			StringBuilder stringBuilder = new StringBuilder();
			uint num = Convert.ToUint32(LateBinding.GetMemberValue(thisob, "length"));
			if (num > int.MaxValue)
			{
				throw new JScriptException(JSError.OutOfMemory);
			}
			if (num > stringBuilder.Capacity)
			{
				stringBuilder.Capacity = (int)num;
			}
			for (uint num2 = 0u; num2 < num; num2++)
			{
				object valueAtIndex = LateBinding.GetValueAtIndex(thisob, num2);
				if (valueAtIndex != null && !(valueAtIndex is Missing))
				{
					if (localize)
					{
						stringBuilder.Append(Convert.ToLocaleString(valueAtIndex));
					}
					else
					{
						stringBuilder.Append(Convert.ToString(valueAtIndex));
					}
				}
				if (num2 < num - 1)
				{
					stringBuilder.Append(separator);
				}
			}
			return stringBuilder.ToString();
		}

		/// <summary>Removes the last element from the specified array and returns it.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The last element of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Array_pop)]
		public static object pop(object thisob)
		{
			uint num = Convert.ToUint32(LateBinding.GetMemberValue(thisob, "length"));
			if (num == 0)
			{
				LateBinding.SetMemberValue(thisob, "length", 0);
				return null;
			}
			object valueAtIndex = LateBinding.GetValueAtIndex(thisob, num - 1);
			LateBinding.DeleteValueAtIndex(thisob, num - 1);
			LateBinding.SetMemberValue(thisob, "length", num - 1);
			return valueAtIndex;
		}

		/// <summary>Adds new elements to the end of the specified array.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="args">The elements to add to <paramref name="thisob" />.</param>
		/// <returns>The new length of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasVarArgs, JSBuiltin.Array_push)]
		public static long push(object thisob, params object[] args)
		{
			uint num = Convert.ToUint32(LateBinding.GetMemberValue(thisob, "length"));
			for (uint num2 = 0u; num2 < args.Length; num2++)
			{
				LateBinding.SetValueAtIndex(thisob, (ulong)num2 + (ulong)num, args[num2]);
			}
			long num3 = num + args.Length;
			LateBinding.SetMemberValue(thisob, "length", num3);
			return num3;
		}

		/// <summary>Reverses the elements of the specified array.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>
		///   <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Array_reverse)]
		public static object reverse(object thisob)
		{
			uint num = Convert.ToUint32(LateBinding.GetMemberValue(thisob, "length"));
			uint num2 = num / 2u;
			uint num3 = 0u;
			uint num4 = num - 1;
			while (num3 < num2)
			{
				LateBinding.SwapValues(thisob, num3, num4);
				num3++;
				num4--;
			}
			return thisob;
		}

		internal override void SetMemberValue(string name, object value)
		{
			if (noExpando)
			{
				throw new JScriptException(JSError.OLENoPropOrMethod);
			}
			base.SetMemberValue(name, value);
		}

		internal override void SetValueAtIndex(uint index, object value)
		{
			if (noExpando)
			{
				throw new JScriptException(JSError.OLENoPropOrMethod);
			}
			base.SetValueAtIndex(index, value);
		}

		/// <summary>Removes the first element from the specified array and returns it. Shifts the remaining elements to the previous positions.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The first element of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Array_shift)]
		public static object shift(object thisob)
		{
			object result = null;
			if (thisob is ArrayObject)
			{
				return ((ArrayObject)thisob).Shift();
			}
			uint num = Convert.ToUint32(LateBinding.GetMemberValue(thisob, "length"));
			if (num == 0)
			{
				LateBinding.SetMemberValue(thisob, "length", 0);
				return result;
			}
			result = LateBinding.GetValueAtIndex(thisob, 0uL);
			for (uint num2 = 1u; num2 < num; num2++)
			{
				object valueAtIndex = LateBinding.GetValueAtIndex(thisob, num2);
				if (valueAtIndex is Missing)
				{
					LateBinding.DeleteValueAtIndex(thisob, num2 - 1);
				}
				else
				{
					LateBinding.SetValueAtIndex(thisob, num2 - 1, valueAtIndex);
				}
			}
			LateBinding.DeleteValueAtIndex(thisob, num - 1);
			LateBinding.SetMemberValue(thisob, "length", num - 1);
			return result;
		}

		/// <summary>Creates a new array that contains the specified consecutive elements from the specified array.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <param name="start">The first consecutive element to get.</param>
		/// <param name="end">The last consecutive element to get.</param>
		/// <returns>A new array that contains the consecutive elements between <paramref name="thisob" />[<paramref name="start" />] and <paramref name="thisob" />[<paramref name="end" />].</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasEngine, JSBuiltin.Array_slice)]
		public static ArrayObject slice(object thisob, VsaEngine engine, double start, object end)
		{
			ArrayObject arrayObject = engine.GetOriginalArrayConstructor().Construct();
			uint num = Convert.ToUint32(LateBinding.GetMemberValue(thisob, "length"));
			long num2 = Runtime.DoubleToInt64(Convert.ToInteger(start));
			if (num2 < 0)
			{
				num2 = num + num2;
				if (num2 < 0)
				{
					num2 = 0L;
				}
			}
			else if (num2 > num)
			{
				num2 = num;
			}
			long num3 = num;
			if (end != null && !(end is Missing))
			{
				num3 = Runtime.DoubleToInt64(Convert.ToInteger(end));
				if (num3 < 0)
				{
					num3 = num + num3;
					if (num3 < 0)
					{
						num3 = 0L;
					}
				}
				else if (num3 > num)
				{
					num3 = num;
				}
			}
			if (num3 > num2)
			{
				arrayObject.length = num3 - num2;
				ulong num4 = (ulong)num2;
				ulong num5 = 0uL;
				while (num4 < (ulong)num3)
				{
					object valueAtIndex = LateBinding.GetValueAtIndex(thisob, num4);
					if (!(valueAtIndex is Missing))
					{
						LateBinding.SetValueAtIndex(arrayObject, num5, valueAtIndex);
					}
					num4++;
					num5++;
				}
			}
			return arrayObject;
		}

		/// <summary>Sorts the elements of the specified array by using the specified function to compare the elements.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="function">The function to use to compare elements.</param>
		/// <returns>
		///   <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Array_sort)]
		public static object sort(object thisob, object function)
		{
			ScriptFunction compareFn = null;
			if (function is ScriptFunction)
			{
				compareFn = (ScriptFunction)function;
			}
			uint num = Convert.ToUint32(LateBinding.GetMemberValue(thisob, "length"));
			if (thisob is ArrayObject)
			{
				((ArrayObject)thisob).Sort(compareFn);
			}
			else if (num <= int.MaxValue)
			{
				QuickSort quickSort = new QuickSort(thisob, compareFn);
				quickSort.SortObject(0L, num);
			}
			return thisob;
		}

		/// <summary>Adds and removes elements from an array at the specified position in the array. You can add elements, remove elements, or both.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <param name="start">The position in the array to add and remove elements.</param>
		/// <param name="deleteCnt">The number of elements to remove, if any.</param>
		/// <param name="args">The elements to add, if any.</param>
		/// <returns>A new array that contains the elements removed from <paramref name="thisob" />, if any have been removed.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasVarArgs | JSFunctionAttributeEnum.HasEngine, JSBuiltin.Array_splice)]
		public static ArrayObject splice(object thisob, VsaEngine engine, double start, double deleteCnt, params object[] args)
		{
			uint num = Convert.ToUint32(LateBinding.GetMemberValue(thisob, "length"));
			long num2 = Runtime.DoubleToInt64(Convert.ToInteger(start));
			if (num2 < 0)
			{
				num2 = num + num2;
				if (num2 < 0)
				{
					num2 = 0L;
				}
			}
			else if (num2 > num)
			{
				num2 = num;
			}
			long num3 = Runtime.DoubleToInt64(Convert.ToInteger(deleteCnt));
			if (num3 < 0)
			{
				num3 = 0L;
			}
			else if (num3 > num - num2)
			{
				num3 = num - num2;
			}
			long num4 = num + args.Length - num3;
			ArrayObject arrayObject = engine.GetOriginalArrayConstructor().Construct();
			arrayObject.length = num3;
			if (thisob is ArrayObject)
			{
				((ArrayObject)thisob).Splice((uint)num2, (uint)num3, args, arrayObject, num, (uint)num4);
				return arrayObject;
			}
			for (ulong num5 = 0uL; num5 < (ulong)num3; num5++)
			{
				arrayObject.SetValueAtIndex((uint)num5, LateBinding.GetValueAtIndex(thisob, num5 + (ulong)num2));
			}
			long num6 = num - num2 - num3;
			if (num4 < num)
			{
				for (long num7 = 0L; num7 < num6; num7++)
				{
					LateBinding.SetValueAtIndex(thisob, (ulong)(num7 + num2 + args.Length), LateBinding.GetValueAtIndex(thisob, (ulong)(num7 + num2 + num3)));
				}
				LateBinding.SetMemberValue(thisob, "length", num4);
			}
			else
			{
				LateBinding.SetMemberValue(thisob, "length", num4);
				for (long num8 = num6 - 1; num8 >= 0; num8--)
				{
					LateBinding.SetValueAtIndex(thisob, (ulong)(num8 + num2 + args.Length), LateBinding.GetValueAtIndex(thisob, (ulong)(num8 + num2 + num3)));
				}
			}
			int num9 = ((args != null) ? args.Length : 0);
			for (uint num10 = 0u; num10 < num9; num10++)
			{
				LateBinding.SetValueAtIndex(thisob, (ulong)(num10 + num2), args[num10]);
			}
			return arrayObject;
		}

		/// <summary>Creates a string representation of the specified object that concatenates the elements and separates them with a <see cref="P:System.Globalization.TextInfo.ListSeparator" /> and a space.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string that concatenates the elements of <paramref name="thisob" /> and separates them with a <see cref="P:System.Globalization.TextInfo.ListSeparator" /> and a space.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Array_toLocaleString)]
		public static string toLocaleString(object thisob)
		{
			if (thisob is ArrayObject)
			{
				StringBuilder stringBuilder = new StringBuilder(CultureInfo.CurrentCulture.TextInfo.ListSeparator);
				if (stringBuilder[stringBuilder.Length - 1] != ' ')
				{
					stringBuilder.Append(' ');
				}
				return Join(thisob, stringBuilder.ToString(), localize: true);
			}
			throw new JScriptException(JSError.NeedArrayObject);
		}

		/// <summary>Creates a string representation of the specified object that concatenates the elements and separates them with a comma.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string that concatenates the elements of <paramref name="thisob" /> and separates them with a comma.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Array_toString)]
		public static string toString(object thisob)
		{
			if (thisob is ArrayObject)
			{
				return Join(thisob, ",", localize: false);
			}
			throw new JScriptException(JSError.NeedArrayObject);
		}

		/// <summary>Adds new elements to the start of the specified array. Shifts the existing elements to the next positions.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="args">The elements to add to <paramref name="thisob" />.</param>
		/// <returns>The new length of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasVarArgs, JSBuiltin.Array_unshift)]
		public static object unshift(object thisob, params object[] args)
		{
			if (args == null || args.Length == 0)
			{
				return thisob;
			}
			if (thisob is ArrayObject)
			{
				return ((ArrayObject)thisob).Unshift(args);
			}
			uint num = Convert.ToUint32(LateBinding.GetMemberValue(thisob, "length"));
			long num2 = num + args.Length;
			LateBinding.SetMemberValue(thisob, "length", num2);
			for (long num3 = num - 1; num3 >= 0; num3--)
			{
				object valueAtIndex = LateBinding.GetValueAtIndex(thisob, (ulong)num3);
				if (valueAtIndex is Missing)
				{
					LateBinding.DeleteValueAtIndex(thisob, (ulong)(num3 + args.Length));
				}
				else
				{
					LateBinding.SetValueAtIndex(thisob, (ulong)(num3 + args.Length), valueAtIndex);
				}
			}
			for (uint num4 = 0u; num4 < args.Length; num4++)
			{
				LateBinding.SetValueAtIndex(thisob, num4, args[num4]);
			}
			return thisob;
		}
	}
	/// <summary>Wraps an array to create a JScript <see cref="T:Microsoft.JScript.ArrayObject" />. This class wraps either a .NET Framework <see cref="T:System.Array" /> object or a JScript <see cref="T:Microsoft.JScript.ArrayObject" /> object.</summary>
	public class ArrayWrapper : ArrayObject
	{
		internal sealed class SortComparer : IComparer
		{
			internal ScriptFunction compareFn;

			internal SortComparer(ScriptFunction compareFn)
			{
				this.compareFn = compareFn;
			}

			public int Compare(object x, object y)
			{
				if (x == null || x is Missing)
				{
					if (y == null || y is Missing)
					{
						return 0;
					}
					return 1;
				}
				if (y == null || y is Missing)
				{
					return -1;
				}
				if (compareFn != null)
				{
					double num = Convert.ToNumber(compareFn.Call(new object[2] { x, y }, null));
					if (num != num)
					{
						throw new JScriptException(JSError.NumberExpected);
					}
					return (int)Runtime.DoubleToInt64(num);
				}
				return string.CompareOrdinal(Convert.ToString(x), Convert.ToString(y));
			}
		}

		internal Array value;

		private bool implicitWrapper;

		/// <summary>Gets the length of the array.</summary>
		/// <returns>The length of the array.</returns>
		public override object length
		{
			get
			{
				return len;
			}
			set
			{
				throw new JScriptException(JSError.AssignmentToReadOnly);
			}
		}

		internal ArrayWrapper(ScriptObject prototype, Array value, bool implicitWrapper)
			: base(prototype, typeof(ArrayWrapper))
		{
			this.value = value;
			this.implicitWrapper = implicitWrapper;
			if (value != null)
			{
				if (value.Rank != 1)
				{
					throw new JScriptException(JSError.TypeMismatch);
				}
				len = (uint)value.Length;
			}
			else
			{
				len = 0u;
			}
		}

		internal override void Concat(ArrayObject source)
		{
			throw new JScriptException(JSError.ActionNotSupported);
		}

		internal override void Concat(object value)
		{
			throw new JScriptException(JSError.ActionNotSupported);
		}

		internal override void GetPropertyEnumerator(ArrayList enums, ArrayList objects)
		{
			enums.Add(new ArrayEnumerator(this, new RangeEnumerator(0, (int)(len - 1))));
			objects.Add(this);
			if (parent != null)
			{
				parent.GetPropertyEnumerator(enums, objects);
			}
		}

		/// <summary>Gets the type of the array.</summary>
		/// <returns>The type of <see cref="T:System.Array" /> or <see cref="T:Microsoft.JScript.ArrayObject" />.</returns>
		public new Type GetType()
		{
			if (!implicitWrapper)
			{
				return typeof(ArrayObject);
			}
			return value.GetType();
		}

		internal override object GetValueAtIndex(uint index)
		{
			return value.GetValue(checked((int)index));
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override void SetMemberValue(string name, object val)
		{
			if (name.Equals("length"))
			{
				throw new JScriptException(JSError.AssignmentToReadOnly);
			}
			long num = ArrayObject.Array_index_for(name);
			if (num < 0)
			{
				base.SetMemberValue(name, val);
			}
			else
			{
				value.SetValue(val, (int)num);
			}
		}

		internal override void SetValueAtIndex(uint index, object val)
		{
			Type type = value.GetType();
			value.SetValue(Convert.CoerceT(val, type.GetElementType()), checked((int)index));
		}

		internal override object Shift()
		{
			throw new JScriptException(JSError.ActionNotSupported);
		}

		internal override void Splice(uint start, uint deleteCount, object[] args, ArrayObject outArray, uint oldLength, uint newLength)
		{
			if (oldLength != newLength)
			{
				throw new JScriptException(JSError.ActionNotSupported);
			}
			SpliceSlowly(start, deleteCount, args, outArray, oldLength, newLength);
		}

		internal override void Sort(ScriptFunction compareFn)
		{
			SortComparer comparer = new SortComparer(compareFn);
			Array.Sort(value, comparer);
		}

		internal override void SwapValues(uint pi, uint qi)
		{
			object valueAtIndex = GetValueAtIndex(pi);
			object valueAtIndex2 = GetValueAtIndex(qi);
			SetValueAtIndex(pi, valueAtIndex2);
			SetValueAtIndex(qi, valueAtIndex);
		}

		internal override Array ToNativeArray(Type elementType)
		{
			return value;
		}

		internal override object[] ToArray()
		{
			object[] array = new object[checked((int)len)];
			for (uint num = 0u; num < len; num++)
			{
				array[num] = GetValueAtIndex(num);
			}
			return array;
		}

		internal override ArrayObject Unshift(object[] args)
		{
			throw new JScriptException(JSError.ActionNotSupported);
		}
	}
	/// <summary>This class is used by the JScript parser to store the attributes that are assigned to an assembly.</summary>
	public sealed class AssemblyCustomAttributeList : AST
	{
		private CustomAttributeList list;

		internal bool okToUse;

		internal AssemblyCustomAttributeList(CustomAttributeList list)
			: base(list.context)
		{
			this.list = list;
			okToUse = false;
		}

		internal override object Evaluate()
		{
			return null;
		}

		internal void Process()
		{
			okToUse = true;
			list.SetTarget(this);
			list.PartiallyEvaluate();
		}

		internal override AST PartiallyEvaluate()
		{
			if (!okToUse)
			{
				context.HandleError(JSError.AssemblyAttributesMustBeGlobal);
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			CustomAttributeBuilder[] customAttributeBuilders = list.GetCustomAttributeBuilders(getForProperty: false);
			foreach (CustomAttributeBuilder customAttribute in customAttributeBuilders)
			{
				base.compilerGlobals.assemblyBuilder.SetCustomAttribute(customAttribute);
			}
			if (rtype != Typeob.Void)
			{
				il.Emit(OpCodes.Ldnull);
				if (rtype.IsValueType)
				{
					Convert.Emit(this, il, Typeob.Object, rtype);
				}
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
		}
	}
	internal sealed class Assign : AST
	{
		internal AST lhside;

		internal AST rhside;

		internal Assign(Context context, AST lhside, AST rhside)
			: base(context)
		{
			this.lhside = lhside;
			this.rhside = rhside;
		}

		internal override object Evaluate()
		{
			try
			{
				if (lhside is Call)
				{
					((Call)lhside).EvaluateIndices();
				}
				object obj = rhside.Evaluate();
				lhside.SetValue(obj);
				return obj;
			}
			catch (JScriptException ex)
			{
				if (ex.context == null)
				{
					ex.context = context;
				}
				throw ex;
			}
			catch (Exception e)
			{
				throw new JScriptException(e, context);
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return rhside.InferType(inference_target);
		}

		internal override AST PartiallyEvaluate()
		{
			AST aST = (lhside = lhside.PartiallyEvaluateAsReference());
			rhside = rhside.PartiallyEvaluate();
			aST.SetPartialValue(rhside);
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Type target_type = Convert.ToType(lhside.InferType(null));
			lhside.TranslateToILPreSet(il);
			if (rtype != Typeob.Void)
			{
				Type type = Convert.ToType(rhside.InferType(null));
				rhside.TranslateToIL(il, type);
				LocalBuilder local = il.DeclareLocal(type);
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Stloc, local);
				Convert.Emit(this, il, type, target_type);
				lhside.TranslateToILSet(il);
				il.Emit(OpCodes.Ldloc, local);
				Convert.Emit(this, il, type, rtype);
			}
			else
			{
				lhside.TranslateToILSet(il, rhside);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			lhside.TranslateToILInitializer(il);
			rhside.TranslateToILInitializer(il);
		}
	}
	/// <summary>Represents the abstract syntax tree that is used to parse JScript code.</summary>
	public abstract class AST
	{
		internal Context context;

		internal CompilerGlobals compilerGlobals => context.document.compilerGlobals;

		internal VsaEngine Engine => context.document.engine;

		internal Globals Globals => context.document.engine.Globals;

		internal AST(Context context)
		{
			this.context = context;
		}

		internal virtual void CheckIfOKToUseInSuperConstructorCall()
		{
		}

		internal virtual bool Delete()
		{
			return true;
		}

		internal void EmitILToLoadEngine(ILGenerator il)
		{
			ScriptObject scriptObject = Engine.ScriptObjectStackTop();
			while (scriptObject != null && (scriptObject is WithObject || scriptObject is BlockScope))
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is FunctionScope)
			{
				((FunctionScope)scriptObject).owner.TranslateToILToLoadEngine(il);
			}
			else if (scriptObject is ClassScope)
			{
				if (Engine.doCRS)
				{
					il.Emit(OpCodes.Ldsfld, CompilerGlobals.contextEngineField);
				}
				else if (context.document.engine.PEFileKind == PEFileKinds.Dll)
				{
					il.Emit(OpCodes.Ldtoken, ((ClassScope)scriptObject).GetTypeBuilder());
					il.Emit(OpCodes.Call, CompilerGlobals.createVsaEngineWithType);
				}
				else
				{
					il.Emit(OpCodes.Call, CompilerGlobals.createVsaEngine);
				}
			}
			else
			{
				il.Emit(OpCodes.Ldarg_0);
				il.Emit(OpCodes.Ldfld, CompilerGlobals.engineField);
			}
		}

		internal abstract object Evaluate();

		internal virtual LateBinding EvaluateAsLateBinding()
		{
			return new LateBinding(null, Evaluate(), VsaEngine.executeForJSEE);
		}

		internal virtual WrappedNamespace EvaluateAsWrappedNamespace(bool giveErrorIfNameInUse)
		{
			throw new JScriptException(JSError.InternalError, context);
		}

		internal virtual bool HasReturn()
		{
			return false;
		}

		internal virtual IReflect InferType(JSField inference_target)
		{
			return Typeob.Object;
		}

		internal virtual void InvalidateInferredTypes()
		{
		}

		internal virtual bool OkToUseAsType()
		{
			return false;
		}

		internal abstract AST PartiallyEvaluate();

		internal virtual AST PartiallyEvaluateAsCallable()
		{
			return new CallableExpression(PartiallyEvaluate());
		}

		internal virtual AST PartiallyEvaluateAsReference()
		{
			return PartiallyEvaluate();
		}

		internal virtual void ResolveCall(ASTList args, IReflect[] argIRs, bool constructor, bool brackets)
		{
			throw new JScriptException(JSError.InternalError, context);
		}

		internal virtual object ResolveCustomAttribute(ASTList args, IReflect[] argIRs, AST target)
		{
			throw new JScriptException(JSError.InternalError, context);
		}

		internal virtual void SetPartialValue(AST partial_value)
		{
			context.HandleError(JSError.IllegalAssignment);
		}

		internal virtual void SetValue(object value)
		{
			context.HandleError(JSError.IllegalAssignment);
		}

		internal virtual void TranslateToConditionalBranch(ILGenerator il, bool branchIfTrue, Label label, bool shortForm)
		{
			IReflect reflect = InferType(null);
			if (reflect != Typeob.Object && reflect is Type)
			{
				string name = (branchIfTrue ? "op_True" : "op_False");
				MethodInfo method = reflect.GetMethod(name, BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[1] { (Type)reflect }, null);
				if (method != null)
				{
					TranslateToIL(il, (Type)reflect);
					il.Emit(OpCodes.Call, method);
					il.Emit(OpCodes.Brtrue, label);
					return;
				}
			}
			Type type = Convert.ToType(reflect);
			TranslateToIL(il, type);
			Convert.Emit(this, il, type, Typeob.Boolean, truncationPermitted: true);
			if (branchIfTrue)
			{
				il.Emit(shortForm ? OpCodes.Brtrue_S : OpCodes.Brtrue, label);
			}
			else
			{
				il.Emit(shortForm ? OpCodes.Brfalse_S : OpCodes.Brfalse, label);
			}
		}

		internal abstract void TranslateToIL(ILGenerator il, Type rtype);

		internal virtual void TranslateToILCall(ILGenerator il, Type rtype, ASTList args, bool construct, bool brackets)
		{
			throw new JScriptException(JSError.InternalError, context);
		}

		internal virtual void TranslateToILDelete(ILGenerator il, Type rtype)
		{
			if (rtype != Typeob.Void)
			{
				il.Emit(OpCodes.Ldc_I4_1);
				Convert.Emit(this, il, Typeob.Boolean, rtype);
			}
		}

		internal virtual void TranslateToILInitializer(ILGenerator il)
		{
			throw new JScriptException(JSError.InternalError, context);
		}

		internal virtual void TranslateToILPreSet(ILGenerator il)
		{
			throw new JScriptException(JSError.InternalError, context);
		}

		internal virtual void TranslateToILPreSet(ILGenerator il, ASTList args)
		{
			TranslateToIL(il, Typeob.Object);
			args.TranslateToIL(il, Typeob.ArrayOfObject);
		}

		internal virtual void TranslateToILPreSetPlusGet(ILGenerator il)
		{
			throw new JScriptException(JSError.InternalError, context);
		}

		internal virtual void TranslateToILPreSetPlusGet(ILGenerator il, ASTList args, bool inBrackets)
		{
			il.Emit(OpCodes.Ldnull);
			TranslateToIL(il, Typeob.Object);
			il.Emit(OpCodes.Dup);
			LocalBuilder local = il.DeclareLocal(Typeob.Object);
			il.Emit(OpCodes.Stloc, local);
			args.TranslateToIL(il, Typeob.ArrayOfObject);
			il.Emit(OpCodes.Dup);
			LocalBuilder local2 = il.DeclareLocal(Typeob.ArrayOfObject);
			il.Emit(OpCodes.Stloc, local2);
			il.Emit(OpCodes.Ldc_I4_0);
			if (inBrackets)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.callValueMethod);
			LocalBuilder local3 = il.DeclareLocal(Typeob.Object);
			il.Emit(OpCodes.Stloc, local3);
			il.Emit(OpCodes.Ldloc, local);
			il.Emit(OpCodes.Ldloc, local2);
			il.Emit(OpCodes.Ldloc, local3);
		}

		internal void TranslateToILSet(ILGenerator il)
		{
			TranslateToILSet(il, null);
		}

		internal virtual void TranslateToILSet(ILGenerator il, AST rhvalue)
		{
			rhvalue?.TranslateToIL(il, Typeob.Object);
			il.Emit(OpCodes.Call, CompilerGlobals.setIndexedPropertyValueStaticMethod);
		}

		internal virtual object TranslateToILReference(ILGenerator il, Type rtype)
		{
			TranslateToIL(il, rtype);
			LocalBuilder localBuilder = il.DeclareLocal(rtype);
			il.Emit(OpCodes.Stloc, localBuilder);
			il.Emit(OpCodes.Ldloca, localBuilder);
			return localBuilder;
		}

		internal virtual Context GetFirstExecutableContext()
		{
			return context;
		}
	}
	/// <summary>Maintains a list of <see cref="T:Microsoft.JScript.AST" /> elements. This class belongs to the abstract syntax tree category.</summary>
	public sealed class ASTList : AST
	{
		internal int count;

		private AST[] list;

		private object[] array;

		internal AST this[int i]
		{
			get
			{
				return list[i];
			}
			set
			{
				list[i] = value;
			}
		}

		internal ASTList(Context context)
			: base(context)
		{
			count = 0;
			list = new AST[16];
			array = null;
		}

		internal ASTList Append(AST elem)
		{
			int num = count++;
			if (list.Length == num)
			{
				Grow();
			}
			list[num] = elem;
			context.UpdateWith(elem.context);
			return this;
		}

		internal override object Evaluate()
		{
			return EvaluateAsArray();
		}

		internal object[] EvaluateAsArray()
		{
			int num = count;
			object[] array = this.array;
			if (array == null)
			{
				array = (this.array = new object[num]);
			}
			AST[] array2 = list;
			for (int i = 0; i < num; i++)
			{
				array[i] = array2[i].Evaluate();
			}
			return array;
		}

		private void Grow()
		{
			AST[] array = list;
			int num = array.Length;
			AST[] array2 = (list = new AST[num + 16]);
			for (int i = 0; i < num; i++)
			{
				array2[i] = array[i];
			}
		}

		internal override AST PartiallyEvaluate()
		{
			AST[] array = list;
			int i = 0;
			for (int num = count; i < num; i++)
			{
				array[i] = array[i].PartiallyEvaluate();
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Type elementType = rtype.GetElementType();
			int num = count;
			ConstantWrapper.TranslateToILInt(il, num);
			il.Emit(OpCodes.Newarr, elementType);
			bool flag = elementType.IsValueType && !elementType.IsPrimitive;
			AST[] array = list;
			for (int i = 0; i < num; i++)
			{
				il.Emit(OpCodes.Dup);
				ConstantWrapper.TranslateToILInt(il, i);
				array[i].TranslateToIL(il, elementType);
				if (flag)
				{
					il.Emit(OpCodes.Ldelema, elementType);
				}
				Binding.TranslateToStelem(il, elementType);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			AST[] array = list;
			int i = 0;
			for (int num = count; i < num; i++)
			{
				array[i].TranslateToILInitializer(il);
			}
		}
	}
	/// <summary>Defines services for authoring JScript code in an editor.</summary>
	[Guid("9E2B453C-6EAA-4329-A619-62E4889C8C8A")]
	[ComVisible(true)]
	public interface IAuthorServices
	{
		/// <summary>When implemented in a class, gets an object that is used to colorize text when JScript code is being authored in an editor.</summary>
		/// <returns>An object that is used to colorize text.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		IColorizeText GetColorizer();

		/// <summary>When implemented in a class, gets an object that is used to add IntelliSense to text when JScript code is being authored in an editor.</summary>
		/// <returns>An object that is used to add IntelliSense to text.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		IParseText GetCodeSense();
	}
	/// <summary>Defines services for colorizing text when JScript code is being authored in an editor.</summary>
	[Guid("DB283E60-7ADB-4cf6-9758-2931893A12FC")]
	[ComVisible(true)]
	public interface IColorizeText
	{
		/// <summary>When implemented in a class, scans the specified source code for individual units of code and identifies the color that each should have.</summary>
		/// <param name="sourceCode">The source code to colorize.</param>
		/// <param name="state">The current state (normal, comment, string) of the source code.</param>
		/// <returns>An enumeration of <see cref="T:Microsoft.JScript.ITokenColorInfo" /> objects that represent units of code to colorize.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		ITokenEnumerator Colorize(string sourceCode, SourceState state);

		/// <summary>When implemented in a class, scans the specified source code for individual units of code and identifies the state (normal, comment, string) of the specified code.</summary>
		/// <param name="sourceCode">The source code to analyze.</param>
		/// <param name="currentState">The current state (normal, comment, string) of the source code.</param>
		/// <returns>The state of the source code.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		SourceState GetStateForText(string sourceCode, SourceState currentState);
	}
	/// <summary>Specifies the state of source code text. This class is used together with other classes that provide information to color JScript code in an editor.</summary>
	[Guid("BA731F6A-3D25-39AE-BE18-C2EF646AE58B")]
	[ComVisible(true)]
	public enum SourceState
	{
		/// <summary>Normal text.</summary>
		STATE_COLOR_NORMAL,
		/// <summary>Comment text.</summary>
		STATE_COLOR_COMMENT,
		/// <summary>String literal text.</summary>
		STATE_COLOR_STRING
	}
	/// <summary>Specifies the colors that individual units of code should have when text is being colorized in an editor. The members of this enumeration are used by the <see cref="P:Microsoft.JScript.ITokenColorInfo.Color" /> property of <see cref="T:Microsoft.JScript.ITokenColorInfo" /> objects.</summary>
	[Guid("78008402-40D4-30BF-BD91-A61D8815625E")]
	[ComVisible(true)]
	public enum TokenColor
	{
		/// <summary>The color for a unit of code that represents text. This is the default value.</summary>
		COLOR_TEXT,
		/// <summary>The color for a unit of code that represents an identifier.</summary>
		COLOR_IDENTIFIER,
		/// <summary>The color for a unit of code that represents a keyword.</summary>
		COLOR_KEYWORD,
		/// <summary>The color for a unit of code that represents a comment.</summary>
		COLOR_COMMENT,
		/// <summary>The color for a unit of code that represents an operator.</summary>
		COLOR_OPERATOR,
		/// <summary>The color for a unit of code that represents a numeric literal.</summary>
		COLOR_NUMBER,
		/// <summary>The color for a unit of code that represents a string literal.</summary>
		COLOR_STRING,
		/// <summary>Not used.</summary>
		COLOR_CONDITIONAL_COMP
	}
	/// <summary>Defines methods for iterating over a collection of <see cref="T:Microsoft.JScript.ITokenColorInfo" /> objects.</summary>
	[Guid("556BA9E0-BD6A-4837-89F0-C79B14759181")]
	[ComVisible(true)]
	public interface ITokenEnumerator
	{
		/// <summary>When implemented in a class, returns the next item in a collection of <see cref="T:Microsoft.JScript.ITokenColorInfo" /> objects.</summary>
		/// <returns>The next item in the collection.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		ITokenColorInfo GetNext();

		/// <summary>When implemented in a class, sets the enumerator to its initial position before the first item in a collection of <see cref="T:Microsoft.JScript.ITokenColorInfo" /> objects.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void Reset();
	}
	/// <summary>Defines properties for coloring specific units of code.</summary>
	[Guid("0F20D5C8-CBDB-4b64-AB7F-10B158407323")]
	[ComVisible(true)]
	public interface ITokenColorInfo
	{
		/// <summary>When implemented in a class, gets the position where a unit of code starts.</summary>
		/// <returns>The position where the unit of code starts.</returns>
		int StartPosition
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>When implemented in a class, gets the position where a unit of code ends.</summary>
		/// <returns>The position where the unit of code ends.</returns>
		int EndPosition
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>When implemented in a class, gets the color that should be used to show a unit of code.</summary>
		/// <returns>The color that should be used to show the unit of code.</returns>
		TokenColor Color
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}
	}
	/// <summary>Defines methods for parsing text when JScript code is being authored in an editor.</summary>
	[Guid("C1468187-3DA1-49df-ADF8-5F8600E59EA8")]
	[ComVisible(true)]
	public interface IParseText
	{
		/// <summary>When implemented in a class, parses the specified source code.</summary>
		/// <param name="code">The source code to parse.</param>
		/// <param name="error">An object that contains information about errors that occur when <paramref name="code" /> is being parsed.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void Parse(string code, IErrorHandler error);
	}
	/// <summary>Defines methods to handle errors that occur when code is being parsed.</summary>
	[Guid("E93D012C-56BB-4f32-864F-7C75EDA17B14")]
	[ComVisible(true)]
	public interface IErrorHandler
	{
		/// <summary>When implemented in a class, determines how to handle an error that occurs when code is being parsed.</summary>
		/// <param name="error">An object that contains information about the error.</param>
		/// <returns>
		///   <see langword="false" /> to handle the error; <see langword="true" /> to ignore the error and continue parsing.</returns>
		bool OnCompilerError(IVsaFullErrorInfo error);
	}
	/// <summary>This is a marker interface and has no methods.</summary>
	[Guid("052019B5-704B-4b99-AEF8-25A11A922B2E")]
	[ComVisible(true)]
	public interface IObjectCompletionInfo
	{
	}
	/// <summary>This is a marker interface and has no methods.</summary>
	[Guid("E0BCF37B-1C24-451c-AC43-40FF86839117")]
	[ComVisible(true)]
	public interface IMethodsCompletionInfo
	{
	}
	/// <summary>Represents the base class for classes that perform operations on two operands, such as <see cref="T:Microsoft.JScript.Plus" />, <see cref="T:Microsoft.JScript.Equality" />, and <see cref="T:Microsoft.JScript.Relational" />. This class belongs to the abstract syntax tree category.</summary>
	public abstract class BinaryOp : AST
	{
		/// <summary>Represents the first operand of the operation.</summary>
		protected AST operand1;

		/// <summary>Represents the second operand of the operation.</summary>
		protected AST operand2;

		/// <summary>Represents the operation that is requested. One of the <see cref="T:Microsoft.JScript.JSToken" /> enumeration values.</summary>
		protected JSToken operatorTok;

		/// <summary>Represents the data type of the first operand of the operation.</summary>
		protected Type type1;

		/// <summary>Represents the data type of the second operand of the operation.</summary>
		protected Type type2;

		/// <summary>Represents the operation that is actually performed.</summary>
		protected MethodInfo operatorMeth;

		internal BinaryOp(Context context, AST operand1, AST operand2)
			: this(context, operand1, operand2, JSToken.EndOfFile)
		{
		}

		internal BinaryOp(Context context, AST operand1, AST operand2, JSToken operatorTok)
			: base(context)
		{
			this.operand1 = operand1;
			this.operand2 = operand2;
			this.operatorTok = operatorTok;
			type1 = null;
			type2 = null;
			operatorMeth = null;
		}

		internal override void CheckIfOKToUseInSuperConstructorCall()
		{
			operand1.CheckIfOKToUseInSuperConstructorCall();
			operand2.CheckIfOKToUseInSuperConstructorCall();
		}

		/// <summary>Determines the best method to call based on the operation that is requested and the data types of the operands.</summary>
		/// <param name="ir1">The data type of the first operand.</param>
		/// <param name="ir2">The data type of the second operand.</param>
		/// <returns>The recommended method to call on the operands.</returns>
		protected MethodInfo GetOperator(IReflect ir1, IReflect ir2)
		{
			if (ir1 is ClassScope)
			{
				ir1 = ((ClassScope)ir1).GetUnderlyingTypeIfEnum();
			}
			if (ir2 is ClassScope)
			{
				ir2 = ((ClassScope)ir2).GetUnderlyingTypeIfEnum();
			}
			Type type = ((ir1 is Type) ? ((Type)ir1) : Typeob.Object);
			Type type2 = ((ir2 is Type) ? ((Type)ir2) : Typeob.Object);
			if (type1 == type && this.type2 == type2)
			{
				return operatorMeth;
			}
			type1 = type;
			this.type2 = type2;
			operatorMeth = null;
			if (type == Typeob.String || Convert.IsPrimitiveNumericType(ir1) || Typeob.JSObject.IsAssignableFrom(type))
			{
				type = null;
			}
			if (type2 == Typeob.String || Convert.IsPrimitiveNumericType(ir2) || Typeob.JSObject.IsAssignableFrom(type2))
			{
				type2 = null;
			}
			if (type == null && type2 == null)
			{
				return null;
			}
			string name = "op_NoSuchOp";
			switch (operatorTok)
			{
			case JSToken.BitwiseAnd:
				name = "op_BitwiseAnd";
				break;
			case JSToken.BitwiseOr:
				name = "op_BitwiseOr";
				break;
			case JSToken.BitwiseXor:
				name = "op_ExclusiveOr";
				break;
			case JSToken.Divide:
				name = "op_Division";
				break;
			case JSToken.Equal:
				name = "op_Equality";
				break;
			case JSToken.GreaterThan:
				name = "op_GreaterThan";
				break;
			case JSToken.GreaterThanEqual:
				name = "op_GreaterThanOrEqual";
				break;
			case JSToken.LeftShift:
				name = "op_LeftShift";
				break;
			case JSToken.LessThan:
				name = "op_LessThan";
				break;
			case JSToken.LessThanEqual:
				name = "op_LessThanOrEqual";
				break;
			case JSToken.Minus:
				name = "op_Subtraction";
				break;
			case JSToken.Modulo:
				name = "op_Modulus";
				break;
			case JSToken.Multiply:
				name = "op_Multiply";
				break;
			case JSToken.NotEqual:
				name = "op_Inequality";
				break;
			case JSToken.FirstBinaryOp:
				name = "op_Addition";
				break;
			case JSToken.RightShift:
				name = "op_RightShift";
				break;
			}
			Type[] types = new Type[2] { type1, this.type2 };
			if (type == type2)
			{
				MethodInfo method = type.GetMethod(name, BindingFlags.Static | BindingFlags.Public, JSBinder.ob, types, null);
				if (method != null && (method.Attributes & MethodAttributes.SpecialName) != 0 && method.GetParameters().Length == 2)
				{
					operatorMeth = method;
				}
			}
			else
			{
				MethodInfo op = ((type == null) ? null : type.GetMethod(name, BindingFlags.Static | BindingFlags.Public, JSBinder.ob, types, null));
				MethodInfo op2 = ((type2 == null) ? null : type2.GetMethod(name, BindingFlags.Static | BindingFlags.Public, JSBinder.ob, types, null));
				operatorMeth = JSBinder.SelectOperator(op, op2, type1, this.type2);
			}
			if (operatorMeth != null)
			{
				operatorMeth = new JSMethodInfo(operatorMeth);
			}
			return operatorMeth;
		}

		internal override AST PartiallyEvaluate()
		{
			operand1 = operand1.PartiallyEvaluate();
			operand2 = operand2.PartiallyEvaluate();
			try
			{
				if (operand1 is ConstantWrapper)
				{
					if (operand2 is ConstantWrapper)
					{
						return new ConstantWrapper(Evaluate(), context);
					}
					object value = ((ConstantWrapper)operand1).value;
					if (value is string)
					{
						if (((string)value).Length == 1)
						{
							if (operand2.InferType(null) == Typeob.Char)
							{
								((ConstantWrapper)operand1).value = ((string)value)[0];
								return this;
							}
							return this;
						}
						return this;
					}
					return this;
				}
				if (operand2 is ConstantWrapper)
				{
					object value2 = ((ConstantWrapper)operand2).value;
					if (value2 is string)
					{
						if (((string)value2).Length == 1)
						{
							if (operand1.InferType(null) == Typeob.Char)
							{
								((ConstantWrapper)operand2).value = ((string)value2)[0];
								return this;
							}
							return this;
						}
						return this;
					}
					return this;
				}
				return this;
			}
			catch (JScriptException ex)
			{
				context.HandleError((JSError)(ex.ErrorNumber & 0xFFFF));
				return this;
			}
			catch
			{
				context.HandleError(JSError.TypeMismatch);
				return this;
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			operand1.TranslateToILInitializer(il);
			operand2.TranslateToILInitializer(il);
		}
	}
	/// <summary>Represents a reference to a class member, callable expression, or variable name. This class attempts to resolve the reference to the correct value at compile time.</summary>
	public abstract class Binding : AST
	{
		private IReflect[] argIRs;

		/// <summary>Stores a reference to a default indexed property.</summary>
		protected MemberInfo defaultMember;

		private IReflect defaultMemberReturnIR;

		private bool isArrayElementAccess;

		private bool isArrayConstructor;

		/// <summary>Stores a value that indicates whether the binding reference is to a default indexed property.</summary>
		protected bool isAssignmentToDefaultIndexedProperty;

		/// <summary>Stores a value that indicates whether the binding reference is fully resolved.</summary>
		protected bool isFullyResolved;

		/// <summary>Stores a value that indicates whether the binding reference is to a member that overrides a member in a base class.</summary>
		protected bool isNonVirtual;

		internal MemberInfo[] members;

		internal MemberInfo member;

		/// <summary>Stores a string that identifies the binding reference.</summary>
		protected string name;

		private bool giveErrors;

		internal static ConstantWrapper ReflectionMissingCW = new ConstantWrapper(System.Reflection.Missing.Value, null);

		private static ConstantWrapper JScriptMissingCW = new ConstantWrapper(Missing.Value, null);

		internal Binding(Context context, string name)
			: base(context)
		{
			argIRs = null;
			defaultMember = null;
			defaultMemberReturnIR = null;
			isArrayElementAccess = false;
			isArrayConstructor = false;
			isAssignmentToDefaultIndexedProperty = false;
			isFullyResolved = true;
			isNonVirtual = false;
			members = null;
			member = null;
			this.name = name;
			giveErrors = true;
		}

		private bool Accessible(bool checkSetter)
		{
			if (member == null)
			{
				return false;
			}
			switch (member.MemberType)
			{
			case MemberTypes.Constructor:
				return AccessibleConstructor();
			case MemberTypes.Event:
				return false;
			case MemberTypes.Field:
				return AccessibleField(checkSetter);
			case MemberTypes.Method:
				return AccessibleMethod();
			case MemberTypes.NestedType:
				if (!((Type)member).IsNestedPublic)
				{
					if (giveErrors)
					{
						context.HandleError(JSError.NotAccessible, isFullyResolved);
					}
					return false;
				}
				if (checkSetter)
				{
					return false;
				}
				return true;
			case MemberTypes.TypeInfo:
				if (!((Type)member).IsPublic)
				{
					if (giveErrors)
					{
						context.HandleError(JSError.NotAccessible, isFullyResolved);
					}
					return false;
				}
				if (checkSetter)
				{
					return false;
				}
				return true;
			case MemberTypes.Property:
				return AccessibleProperty(checkSetter);
			default:
				return false;
			}
		}

		private bool AccessibleConstructor()
		{
			ConstructorInfo constructorInfo = (ConstructorInfo)member;
			if ((constructorInfo is JSConstructor && ((JSConstructor)member).GetClassScope().owner.isAbstract) || (!(constructorInfo is JSConstructor) && constructorInfo.DeclaringType.IsAbstract))
			{
				context.HandleError(JSError.CannotInstantiateAbstractClass);
				return false;
			}
			if (constructorInfo.IsPublic)
			{
				return true;
			}
			if (constructorInfo is JSConstructor && ((JSConstructor)constructorInfo).IsAccessibleFrom(base.Globals.ScopeStack.Peek()))
			{
				return true;
			}
			if (giveErrors)
			{
				context.HandleError(JSError.NotAccessible, isFullyResolved);
			}
			return false;
		}

		private bool AccessibleField(bool checkWritable)
		{
			FieldInfo fieldInfo = (FieldInfo)member;
			if (checkWritable && (fieldInfo.IsInitOnly || fieldInfo.IsLiteral))
			{
				return false;
			}
			if (!fieldInfo.IsPublic)
			{
				JSWrappedField jSWrappedField = fieldInfo as JSWrappedField;
				if (jSWrappedField != null)
				{
					fieldInfo = (FieldInfo)(member = jSWrappedField.wrappedField);
				}
				JSClosureField jSClosureField = fieldInfo as JSClosureField;
				JSMemberField jSMemberField = ((jSClosureField != null) ? jSClosureField.field : fieldInfo) as JSMemberField;
				if (jSMemberField == null)
				{
					if ((!fieldInfo.IsFamily && !fieldInfo.IsFamilyOrAssembly) || !InsideClassThatExtends(base.Globals.ScopeStack.Peek(), fieldInfo.ReflectedType))
					{
						if (giveErrors)
						{
							context.HandleError(JSError.NotAccessible, isFullyResolved);
						}
						return false;
					}
				}
				else if (!jSMemberField.IsAccessibleFrom(base.Globals.ScopeStack.Peek()))
				{
					if (giveErrors)
					{
						context.HandleError(JSError.NotAccessible, isFullyResolved);
					}
					return false;
				}
			}
			if (fieldInfo.IsLiteral && fieldInfo is JSVariableField && ((JSVariableField)fieldInfo).value is ClassScope classScope && !classScope.owner.IsStatic)
			{
				if (!(this is Lookup lookup) || !lookup.InStaticCode() || lookup.InFunctionNestedInsideInstanceMethod())
				{
					return true;
				}
				if (giveErrors)
				{
					context.HandleError(JSError.InstanceNotAccessibleFromStatic, isFullyResolved);
				}
				return true;
			}
			if (fieldInfo.IsStatic || fieldInfo.IsLiteral || defaultMember != null || !(this is Lookup) || !((Lookup)this).InStaticCode())
			{
				return true;
			}
			if (fieldInfo is JSWrappedField && fieldInfo.DeclaringType == Typeob.LenientGlobalObject)
			{
				return true;
			}
			if (giveErrors)
			{
				if (!fieldInfo.IsStatic && this is Lookup && ((Lookup)this).InStaticCode())
				{
					context.HandleError(JSError.InstanceNotAccessibleFromStatic, isFullyResolved);
				}
				else
				{
					context.HandleError(JSError.NotAccessible, isFullyResolved);
				}
			}
			return false;
		}

		private bool AccessibleMethod()
		{
			MethodInfo meth = (MethodInfo)member;
			return AccessibleMethod(meth);
		}

		private bool AccessibleMethod(MethodInfo meth)
		{
			if (meth == null)
			{
				return false;
			}
			if (isNonVirtual && meth.IsAbstract)
			{
				context.HandleError(JSError.InvalidCall);
				return false;
			}
			if (!meth.IsPublic)
			{
				JSWrappedMethod jSWrappedMethod = meth as JSWrappedMethod;
				if (jSWrappedMethod != null)
				{
					meth = jSWrappedMethod.method;
				}
				JSClosureMethod jSClosureMethod = meth as JSClosureMethod;
				JSFieldMethod jSFieldMethod = ((jSClosureMethod != null) ? jSClosureMethod.method : meth) as JSFieldMethod;
				if (jSFieldMethod == null)
				{
					if ((meth.IsFamily || meth.IsFamilyOrAssembly) && InsideClassThatExtends(base.Globals.ScopeStack.Peek(), meth.ReflectedType))
					{
						return true;
					}
					if (giveErrors)
					{
						context.HandleError(JSError.NotAccessible, isFullyResolved);
					}
					return false;
				}
				if (!jSFieldMethod.IsAccessibleFrom(base.Globals.ScopeStack.Peek()))
				{
					if (giveErrors)
					{
						context.HandleError(JSError.NotAccessible, isFullyResolved);
					}
					return false;
				}
			}
			if (meth.IsStatic || defaultMember != null || !(this is Lookup) || !((Lookup)this).InStaticCode())
			{
				return true;
			}
			if (meth is JSWrappedMethod && ((Lookup)this).CanPlaceAppropriateObjectOnStack(((JSWrappedMethod)meth).obj))
			{
				return true;
			}
			if (giveErrors)
			{
				if (!meth.IsStatic && this is Lookup && ((Lookup)this).InStaticCode())
				{
					context.HandleError(JSError.InstanceNotAccessibleFromStatic, isFullyResolved);
				}
				else
				{
					context.HandleError(JSError.NotAccessible, isFullyResolved);
				}
			}
			return false;
		}

		private bool AccessibleProperty(bool checkSetter)
		{
			PropertyInfo prop = (PropertyInfo)member;
			if (AccessibleMethod(checkSetter ? JSProperty.GetSetMethod(prop, nonPublic: true) : JSProperty.GetGetMethod(prop, nonPublic: true)))
			{
				return true;
			}
			if (giveErrors && !checkSetter)
			{
				context.HandleError(JSError.WriteOnlyProperty);
			}
			return false;
		}

		internal static bool AssignmentCompatible(IReflect lhir, AST rhexpr, IReflect rhir, bool reportError)
		{
			if (rhexpr is ConstantWrapper)
			{
				object obj = rhexpr.Evaluate();
				if (obj is ClassScope)
				{
					if (lhir == Typeob.Type || lhir == Typeob.Object || lhir == Typeob.String)
					{
						return true;
					}
					if (reportError)
					{
						rhexpr.context.HandleError(JSError.TypeMismatch);
					}
					return false;
				}
				if (lhir is ClassScope classScope)
				{
					if (classScope.owner is EnumDeclaration enumDeclaration)
					{
						if (rhexpr is ConstantWrapper constantWrapper && constantWrapper.value is string)
						{
							FieldInfo field = classScope.GetField((string)constantWrapper.value, BindingFlags.Static | BindingFlags.Public);
							if (field == null)
							{
								return false;
							}
							enumDeclaration.PartiallyEvaluate();
							constantWrapper.value = new DeclaredEnumValue(((JSMemberField)field).value, field.Name, classScope);
						}
						if (rhir == Typeob.String)
						{
							return true;
						}
						lhir = enumDeclaration.baseType.ToType();
					}
				}
				else if (lhir is Type)
				{
					Type type = lhir as Type;
					if (type.IsEnum)
					{
						if (rhexpr is ConstantWrapper constantWrapper2 && constantWrapper2.value is string)
						{
							FieldInfo field2 = type.GetField((string)constantWrapper2.value, BindingFlags.Static | BindingFlags.Public);
							if (field2 == null)
							{
								return false;
							}
							constantWrapper2.value = MetadataEnumValue.GetEnumValue(field2.FieldType, field2.GetRawConstantValue());
						}
						if (rhir == Typeob.String)
						{
							return true;
						}
						lhir = Enum.GetUnderlyingType(type);
					}
				}
				if (lhir is Type)
				{
					try
					{
						Convert.CoerceT(obj, (Type)lhir);
						return true;
					}
					catch
					{
						if (lhir == Typeob.Single && obj is double)
						{
							if (((ConstantWrapper)rhexpr).isNumericLiteral)
							{
								return true;
							}
							double num = (double)obj;
							float num2 = (float)num;
							if (num.ToString(CultureInfo.InvariantCulture).Equals(num2.ToString(CultureInfo.InvariantCulture)))
							{
								((ConstantWrapper)rhexpr).value = num2;
								return true;
							}
						}
						if (lhir == Typeob.Decimal && rhexpr is ConstantWrapper constantWrapper3 && constantWrapper3.isNumericLiteral)
						{
							try
							{
								Convert.CoerceT(constantWrapper3.context.GetCode(), Typeob.Decimal);
								return true;
							}
							catch
							{
							}
						}
						if (reportError)
						{
							rhexpr.context.HandleError(JSError.TypeMismatch);
						}
					}
					return false;
				}
			}
			else if (rhexpr is ArrayLiteral)
			{
				return ((ArrayLiteral)rhexpr).AssignmentCompatible(lhir, reportError);
			}
			if (rhir == Typeob.Object)
			{
				return true;
			}
			if (rhir == Typeob.Double && Convert.IsPrimitiveNumericType(lhir))
			{
				return true;
			}
			if (lhir is Type && Typeob.Delegate.IsAssignableFrom((Type)lhir) && rhir == Typeob.ScriptFunction && rhexpr is Binding && ((Binding)rhexpr).IsCompatibleWithDelegate((Type)lhir))
			{
				return true;
			}
			if (Convert.IsPromotableTo(rhir, lhir))
			{
				return true;
			}
			if (Convert.IsJScriptArray(rhir) && ArrayAssignmentCompatible(rhexpr, lhir))
			{
				return true;
			}
			if (lhir == Typeob.String)
			{
				return true;
			}
			if (rhir == Typeob.String && (lhir == Typeob.Boolean || Convert.IsPrimitiveNumericType(lhir)))
			{
				if (reportError)
				{
					rhexpr.context.HandleError(JSError.PossibleBadConversionFromString);
				}
				return true;
			}
			if ((lhir == Typeob.Char && rhir == Typeob.String) || Convert.IsPromotableTo(lhir, rhir) || (Convert.IsPrimitiveNumericType(lhir) && Convert.IsPrimitiveNumericType(rhir)))
			{
				if (reportError)
				{
					rhexpr.context.HandleError(JSError.PossibleBadConversion);
				}
				return true;
			}
			if (reportError)
			{
				rhexpr.context.HandleError(JSError.TypeMismatch);
			}
			return false;
		}

		private static bool ArrayAssignmentCompatible(AST ast, IReflect lhir)
		{
			if (!Convert.IsArray(lhir))
			{
				return false;
			}
			if (lhir == Typeob.Array)
			{
				ast.context.HandleError(JSError.ArrayMayBeCopied);
				return true;
			}
			if (Convert.GetArrayRank(lhir) == 1)
			{
				ast.context.HandleError(JSError.ArrayMayBeCopied);
				return true;
			}
			return false;
		}

		internal void CheckIfDeletable()
		{
			if (member != null || defaultMember != null)
			{
				context.HandleError(JSError.NotDeletable);
			}
			member = null;
			defaultMember = null;
		}

		internal void CheckIfUseless()
		{
			if (members != null && members.Length != 0)
			{
				context.HandleError(JSError.UselessExpression);
			}
		}

		internal static bool CheckParameters(ParameterInfo[] pars, IReflect[] argIRs, ASTList argAST, Context ctx)
		{
			return CheckParameters(pars, argIRs, argAST, ctx, 0, defaultIsUndefined: false, reportError: true);
		}

		internal static bool CheckParameters(ParameterInfo[] pars, IReflect[] argIRs, ASTList argAST, Context ctx, int offset, bool defaultIsUndefined, bool reportError)
		{
			int num = argIRs.Length;
			int num2 = pars.Length;
			bool flag = false;
			if (num > num2 - offset)
			{
				num = num2 - offset;
				flag = true;
			}
			for (int i = 0; i < num; i++)
			{
				IReflect reflect;
				if (!(pars[i + offset] is ParameterDeclaration))
				{
					IReflect parameterType = pars[i + offset].ParameterType;
					reflect = parameterType;
				}
				else
				{
					reflect = ((ParameterDeclaration)pars[i + offset]).ParameterIReflect;
				}
				IReflect reflect2 = reflect;
				IReflect rhir = argIRs[i];
				if (i == num - 1 && ((reflect2 is Type && Typeob.Array.IsAssignableFrom((Type)reflect2)) || reflect2 is TypedArray) && CustomAttribute.IsDefined(pars[i + offset], typeof(ParamArrayAttribute), inherit: false))
				{
					flag = false;
					int num3 = argIRs.Length;
					if (i == num3 - 1 && AssignmentCompatible(reflect2, argAST[i], argIRs[i], reportError: false))
					{
						return true;
					}
					IReflect reflect3;
					if (!(reflect2 is Type))
					{
						reflect3 = ((TypedArray)reflect2).elementType;
					}
					else
					{
						IReflect parameterType = ((Type)reflect2).GetElementType();
						reflect3 = parameterType;
					}
					IReflect lhir = reflect3;
					for (int j = i; j < num3; j++)
					{
						if (!AssignmentCompatible(lhir, argAST[j], argIRs[j], reportError))
						{
							return false;
						}
					}
					return true;
				}
				if (!AssignmentCompatible(reflect2, argAST[i], rhir, reportError))
				{
					return false;
				}
			}
			if (flag && reportError)
			{
				ctx.HandleError(JSError.TooManyParameters);
			}
			if (offset == 0 && num < num2 && !defaultIsUndefined)
			{
				for (int k = num; k < num2; k++)
				{
					if (TypeReferences.GetDefaultParameterValue(pars[k]) != System.Convert.DBNull)
					{
						continue;
					}
					if (pars[k] is ParameterDeclaration parameterDeclaration)
					{
						parameterDeclaration.PartiallyEvaluate();
					}
					if (k < num2 - 1 || !CustomAttribute.IsDefined(pars[k], typeof(ParamArrayAttribute), inherit: false))
					{
						if (reportError)
						{
							ctx.HandleError(JSError.TooFewParameters);
						}
						IReflect reflect4;
						if (!(pars[k + offset] is ParameterDeclaration))
						{
							IReflect parameterType = pars[k + offset].ParameterType;
							reflect4 = parameterType;
						}
						else
						{
							reflect4 = ((ParameterDeclaration)pars[k + offset]).ParameterIReflect;
						}
						IReflect reflect5 = reflect4;
						Type type = reflect5 as Type;
						if (type != null && type.IsValueType && !type.IsPrimitive && !type.IsEnum)
						{
							return false;
						}
					}
				}
			}
			return true;
		}

		internal override bool Delete()
		{
			return EvaluateAsLateBinding().Delete();
		}

		internal override object Evaluate()
		{
			object @object = GetObject();
			MemberInfo memberInfo = member;
			if (memberInfo != null)
			{
				switch (memberInfo.MemberType)
				{
				case MemberTypes.Field:
					return ((FieldInfo)memberInfo).GetValue(@object);
				case MemberTypes.Property:
				{
					MemberInfo[] array = new MemberInfo[1] { JSProperty.GetGetMethod((PropertyInfo)memberInfo, nonPublic: false) };
					return LateBinding.CallOneOfTheMembers(array, new object[0], construct: false, @object, null, null, null, base.Engine);
				}
				case MemberTypes.Event:
					return null;
				case MemberTypes.NestedType:
					return memberInfo;
				}
			}
			if (members != null && members.Length != 0)
			{
				if (members.Length == 1 && members[0].MemberType == MemberTypes.Method)
				{
					MethodInfo methodInfo = (MethodInfo)members[0];
					Type type = ((methodInfo is JSMethod) ? null : methodInfo.DeclaringType);
					if (type == Typeob.GlobalObject || (type != null && type != Typeob.StringObject && type != Typeob.NumberObject && type != Typeob.BooleanObject && type.IsSubclassOf(Typeob.JSObject)))
					{
						return Globals.BuiltinFunctionFor(@object, TypeReferences.ToExecutionContext(methodInfo));
					}
				}
				return new FunctionWrapper(name, @object, members);
			}
			return EvaluateAsLateBinding().GetValue();
		}

		private MemberInfoList GetAllKnownInstanceBindingsForThisName()
		{
			IReflect[] allEligibleClasses = GetAllEligibleClasses();
			MemberInfoList memberInfoList = new MemberInfoList();
			IReflect[] array = allEligibleClasses;
			foreach (IReflect reflect in array)
			{
				if (reflect is ClassScope)
				{
					if (((ClassScope)reflect).ParentIsInSamePackage())
					{
						memberInfoList.AddRange(reflect.GetMember(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
					}
					else
					{
						memberInfoList.AddRange(reflect.GetMember(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
					}
				}
				else
				{
					memberInfoList.AddRange(reflect.GetMember(name, BindingFlags.Instance | BindingFlags.Public));
				}
			}
			return memberInfoList;
		}

		private IReflect[] GetAllEligibleClasses()
		{
			ArrayList arrayList = new ArrayList(16);
			ClassScope classScope = null;
			PackageScope packageScope = null;
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject || scriptObject is BlockScope)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is FunctionScope)
			{
				scriptObject = ((FunctionScope)scriptObject).owner.enclosing_scope;
			}
			if (scriptObject is ClassScope)
			{
				classScope = (ClassScope)scriptObject;
				packageScope = classScope.package;
			}
			classScope?.AddClassesFromInheritanceChain(name, arrayList);
			if (packageScope != null)
			{
				packageScope.AddClassesExcluding(classScope, name, arrayList);
			}
			else
			{
				((IActivationObject)scriptObject).GetGlobalScope().AddClassesExcluding(classScope, name, arrayList);
			}
			IReflect[] array = new IReflect[arrayList.Count];
			arrayList.CopyTo(array);
			return array;
		}

		/// <summary>When overridden in a derived class, gets the object that the binding reference is defined on.</summary>
		/// <returns>The object that the binding reference is defined on.</returns>
		protected abstract object GetObject();

		/// <summary>When overridden in a derived class, handles situations in which the binding reference is to a member that cannot be found.</summary>
		protected abstract void HandleNoSuchMemberError();

		internal override IReflect InferType(JSField inference_target)
		{
			if (isArrayElementAccess)
			{
				IReflect reflect = defaultMemberReturnIR;
				if (!(reflect is TypedArray))
				{
					return ((Type)reflect).GetElementType();
				}
				return ((TypedArray)reflect).elementType;
			}
			if (isAssignmentToDefaultIndexedProperty)
			{
				if (member is PropertyInfo)
				{
					return ((PropertyInfo)member).PropertyType;
				}
				return Typeob.Object;
			}
			MemberInfo memberInfo = member;
			if (memberInfo is FieldInfo)
			{
				JSWrappedField jSWrappedField = memberInfo as JSWrappedField;
				if (jSWrappedField != null)
				{
					memberInfo = jSWrappedField.wrappedField;
				}
				if (memberInfo is JSVariableField)
				{
					return ((JSVariableField)memberInfo).GetInferredType(inference_target);
				}
				return ((FieldInfo)memberInfo).FieldType;
			}
			if (memberInfo is PropertyInfo)
			{
				JSWrappedProperty jSWrappedProperty = memberInfo as JSWrappedProperty;
				if (jSWrappedProperty != null)
				{
					memberInfo = jSWrappedProperty.property;
				}
				if (memberInfo is JSProperty)
				{
					return ((JSProperty)memberInfo).PropertyIR();
				}
				PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
				if (propertyInfo.DeclaringType == Typeob.GlobalObject)
				{
					return (IReflect)propertyInfo.GetValue(base.Globals.globalObject, null);
				}
				return propertyInfo.PropertyType;
			}
			if (memberInfo is Type)
			{
				return Typeob.Type;
			}
			if (memberInfo is EventInfo)
			{
				return Typeob.EventInfo;
			}
			if (members.Length != 0 && base.Engine.doFast)
			{
				return Typeob.ScriptFunction;
			}
			return Typeob.Object;
		}

		internal virtual IReflect InferTypeOfCall(JSField inference_target, bool isConstructor)
		{
			if (!isFullyResolved)
			{
				return Typeob.Object;
			}
			if (isArrayConstructor)
			{
				return defaultMemberReturnIR;
			}
			if (isArrayElementAccess)
			{
				IReflect reflect = defaultMemberReturnIR;
				if (!(reflect is TypedArray))
				{
					return ((Type)reflect).GetElementType();
				}
				return ((TypedArray)reflect).elementType;
			}
			MemberInfo memberInfo = member;
			if (memberInfo is JSFieldMethod)
			{
				if (!isConstructor)
				{
					return ((JSFieldMethod)memberInfo).ReturnIR();
				}
				return Typeob.Object;
			}
			if (memberInfo is MethodInfo)
			{
				return ((MethodInfo)memberInfo).ReturnType;
			}
			if (memberInfo is JSConstructor)
			{
				return ((JSConstructor)memberInfo).GetClassScope();
			}
			if (memberInfo is ConstructorInfo)
			{
				return ((ConstructorInfo)memberInfo).DeclaringType;
			}
			if (memberInfo is Type)
			{
				return (Type)memberInfo;
			}
			if (memberInfo is FieldInfo && ((FieldInfo)memberInfo).IsLiteral)
			{
				object obj = ((memberInfo is JSVariableField) ? ((JSVariableField)memberInfo).value : TypeReferences.GetConstantValue((FieldInfo)memberInfo));
				if (obj is ClassScope || obj is TypedArray)
				{
					return (IReflect)obj;
				}
			}
			return Typeob.Object;
		}

		private static bool InsideClassThatExtends(ScriptObject scope, Type type)
		{
			while (scope is WithObject || scope is BlockScope)
			{
				scope = scope.GetParent();
			}
			if (scope is ClassScope)
			{
				return type.IsAssignableFrom(((ClassScope)scope).GetBakedSuperType());
			}
			if (scope is FunctionScope)
			{
				return InsideClassThatExtends(((FunctionScope)scope).owner.enclosing_scope, type);
			}
			return false;
		}

		internal void InvalidateBinding()
		{
			isAssignmentToDefaultIndexedProperty = false;
			isArrayConstructor = false;
			isArrayElementAccess = false;
			defaultMember = null;
			member = null;
			members = new MemberInfo[0];
		}

		internal bool IsCompatibleWithDelegate(Type delegateType)
		{
			MethodInfo method = delegateType.GetMethod("Invoke");
			ParameterInfo[] parameters = method.GetParameters();
			Type returnType = method.ReturnType;
			MemberInfo[] array = members;
			foreach (MemberInfo memberInfo in array)
			{
				if (!(memberInfo is MethodInfo))
				{
					continue;
				}
				MethodInfo methodInfo = (MethodInfo)memberInfo;
				Type type = null;
				if (methodInfo is JSFieldMethod)
				{
					IReflect reflect = ((JSFieldMethod)methodInfo).ReturnIR();
					type = ((reflect is ClassScope) ? ((ClassScope)reflect).GetBakedSuperType() : ((!(reflect is Type)) ? Convert.ToType(reflect) : ((Type)reflect)));
					if (((JSFieldMethod)methodInfo).func.isExpandoMethod)
					{
						return false;
					}
				}
				else
				{
					type = methodInfo.ReturnType;
				}
				if (type == returnType && Class.ParametersMatch(parameters, methodInfo.GetParameters()))
				{
					member = methodInfo;
					isFullyResolved = true;
					return true;
				}
			}
			return false;
		}

		/// <summary>Determines whether the specified object is equivalent to <see cref="T:Microsoft.JScript.Missing" />.</summary>
		/// <param name="value">The object to compare.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="value" /> is equivalent to <see cref="T:Microsoft.JScript.Missing" />; otherwise, <see langword="false" />.</returns>
		public static bool IsMissing(object value)
		{
			return value is Missing;
		}

		private MethodInfo LookForParameterlessPropertyGetter()
		{
			int i = 0;
			for (int num = members.Length; i < num; i++)
			{
				PropertyInfo propertyInfo = members[i] as PropertyInfo;
				if (propertyInfo != null)
				{
					MethodInfo getMethod = propertyInfo.GetGetMethod(nonPublic: true);
					if (getMethod == null)
					{
						continue;
					}
					ParameterInfo[] parameters = getMethod.GetParameters();
					if (parameters == null || parameters.Length == 0)
					{
						continue;
					}
				}
				return null;
			}
			try
			{
				MethodInfo methodInfo = JSBinder.SelectMethod(members, new IReflect[0]);
				if (methodInfo != null && methodInfo.IsSpecialName)
				{
					return methodInfo;
				}
			}
			catch (AmbiguousMatchException)
			{
			}
			return null;
		}

		internal override bool OkToUseAsType()
		{
			MemberInfo memberInfo = member;
			if (memberInfo is Type)
			{
				return isFullyResolved = true;
			}
			if (memberInfo is FieldInfo)
			{
				FieldInfo fieldInfo = (FieldInfo)memberInfo;
				if (fieldInfo.IsLiteral)
				{
					if (fieldInfo is JSMemberField && ((JSMemberField)fieldInfo).value is ClassScope && !fieldInfo.IsStatic)
					{
						return false;
					}
					return isFullyResolved = true;
				}
				if (!(memberInfo is JSField) && fieldInfo.IsStatic && fieldInfo.GetValue(null) is Type)
				{
					return isFullyResolved = true;
				}
			}
			return false;
		}

		private int PlaceValuesForHiddenParametersOnStack(ILGenerator il, MethodInfo meth, ParameterInfo[] pars)
		{
			int num = 0;
			if (meth is JSFieldMethod)
			{
				FunctionObject func = ((JSFieldMethod)meth).func;
				if (func != null && func.isMethod)
				{
					return 0;
				}
				if (this is Lookup)
				{
					((Lookup)this).TranslateToILDefaultThisObject(il);
				}
				else
				{
					TranslateToILObject(il, Typeob.Object, noValue: false);
				}
				EmitILToLoadEngine(il);
				return 0;
			}
			object[] customAttributes = CustomAttribute.GetCustomAttributes(meth, typeof(JSFunctionAttribute), inherit: false);
			if (customAttributes == null || customAttributes.Length == 0)
			{
				return 0;
			}
			JSFunctionAttributeEnum attributeValue = ((JSFunctionAttribute)customAttributes[0]).attributeValue;
			if ((attributeValue & JSFunctionAttributeEnum.HasThisObject) != 0)
			{
				num = 1;
				Type parameterType = pars[0].ParameterType;
				if (this is Lookup && parameterType == Typeob.Object)
				{
					((Lookup)this).TranslateToILDefaultThisObject(il);
				}
				else if (Typeob.ArrayObject.IsAssignableFrom(member.DeclaringType))
				{
					TranslateToILObject(il, Typeob.ArrayObject, noValue: false);
				}
				else
				{
					TranslateToILObject(il, parameterType, noValue: false);
				}
			}
			if ((attributeValue & JSFunctionAttributeEnum.HasEngine) != 0)
			{
				num++;
				EmitILToLoadEngine(il);
			}
			return num;
		}

		private bool ParameterlessPropertyValueIsCallable(MethodInfo meth, ASTList args, IReflect[] argIRs, bool constructor, bool brackets)
		{
			ParameterInfo[] parameters = meth.GetParameters();
			if (parameters == null || parameters.Length == 0)
			{
				if ((meth is JSWrappedMethod && ((JSWrappedMethod)meth).GetWrappedObject() is GlobalObject) || argIRs.Length != 0 || (!(meth is JSMethod) && Typeob.ScriptFunction.IsAssignableFrom(meth.ReturnType)))
				{
					member = ResolveOtherKindOfCall(args, argIRs, constructor, brackets);
					return true;
				}
				IReflect reflect;
				if (!(meth is JSFieldMethod))
				{
					IReflect returnType = meth.ReturnType;
					reflect = returnType;
				}
				else
				{
					reflect = ((JSFieldMethod)meth).ReturnIR();
				}
				IReflect reflect2 = reflect;
				if (reflect2 == Typeob.Object || reflect2 == Typeob.ScriptFunction)
				{
					member = ResolveOtherKindOfCall(args, argIRs, constructor, brackets);
					return true;
				}
				context.HandleError(JSError.InvalidCall);
			}
			return false;
		}

		internal static void PlaceArgumentsOnStack(ILGenerator il, ParameterInfo[] pars, ASTList args, int offset, int rhoffset, AST missing)
		{
			int count = args.count;
			int num = count + offset;
			int num2 = pars.Length - rhoffset;
			bool flag = num2 > 0 && CustomAttribute.IsDefined(pars[num2 - 1], typeof(ParamArrayAttribute), inherit: false) && (count != num2 || !Convert.IsArrayType(args[count - 1].InferType(null)));
			Type type = (flag ? pars[--num2].ParameterType.GetElementType() : null);
			if (num > num2)
			{
				num = num2;
			}
			for (int i = offset; i < num; i++)
			{
				Type parameterType = pars[i].ParameterType;
				AST aST = args[i - offset];
				if (aST is ConstantWrapper && ((ConstantWrapper)aST).value == System.Reflection.Missing.Value)
				{
					object defaultParameterValue = TypeReferences.GetDefaultParameterValue(pars[i]);
					((ConstantWrapper)aST).value = ((defaultParameterValue != System.Convert.DBNull) ? defaultParameterValue : null);
				}
				if (parameterType.IsByRef)
				{
					aST.TranslateToILReference(il, parameterType.GetElementType());
				}
				else
				{
					aST.TranslateToIL(il, parameterType);
				}
			}
			if (num < num2)
			{
				for (int j = num; j < num2; j++)
				{
					Type parameterType2 = pars[j].ParameterType;
					if (TypeReferences.GetDefaultParameterValue(pars[j]) == System.Convert.DBNull)
					{
						if (parameterType2.IsByRef)
						{
							missing.TranslateToILReference(il, parameterType2.GetElementType());
						}
						else
						{
							missing.TranslateToIL(il, parameterType2);
						}
					}
					else if (parameterType2.IsByRef)
					{
						new ConstantWrapper(TypeReferences.GetDefaultParameterValue(pars[j]), null).TranslateToILReference(il, parameterType2.GetElementType());
					}
					else
					{
						new ConstantWrapper(TypeReferences.GetDefaultParameterValue(pars[j]), null).TranslateToIL(il, parameterType2);
					}
				}
			}
			if (!flag)
			{
				return;
			}
			num -= offset;
			num2 = ((count > num) ? (count - num) : 0);
			ConstantWrapper.TranslateToILInt(il, num2);
			il.Emit(OpCodes.Newarr, type);
			bool flag2 = type.IsValueType && !type.IsPrimitive;
			for (int k = 0; k < num2; k++)
			{
				il.Emit(OpCodes.Dup);
				ConstantWrapper.TranslateToILInt(il, k);
				if (flag2)
				{
					il.Emit(OpCodes.Ldelema, type);
				}
				args[k + num].TranslateToIL(il, type);
				TranslateToStelem(il, type);
			}
		}

		internal bool RefersToMemoryLocation()
		{
			if (isFullyResolved)
			{
				if (isArrayElementAccess)
				{
					return true;
				}
				return member is FieldInfo;
			}
			return false;
		}

		internal override void ResolveCall(ASTList args, IReflect[] argIRs, bool constructor, bool brackets)
		{
			this.argIRs = argIRs;
			if (members == null || members.Length == 0)
			{
				if (constructor && isFullyResolved && base.Engine.doFast)
				{
					if (member != null && (member is Type || (member is FieldInfo && ((FieldInfo)member).IsLiteral)))
					{
						context.HandleError(JSError.NoConstructor);
					}
					else
					{
						HandleNoSuchMemberError();
					}
				}
				else
				{
					HandleNoSuchMemberError();
				}
				return;
			}
			MemberInfo memberInfo = null;
			if (!(this is CallableExpression) && !(constructor && brackets))
			{
				try
				{
					if (constructor)
					{
						memberInfo = (member = JSBinder.SelectConstructor(members, argIRs));
					}
					else
					{
						MethodInfo methodInfo;
						memberInfo = (member = (methodInfo = JSBinder.SelectMethod(members, argIRs)));
						if (methodInfo != null && methodInfo.IsSpecialName)
						{
							if (name == methodInfo.Name)
							{
								if (name.StartsWith("get_", StringComparison.Ordinal) || name.StartsWith("set_", StringComparison.Ordinal))
								{
									context.HandleError(JSError.NotMeantToBeCalledDirectly);
									member = null;
									return;
								}
							}
							else if (ParameterlessPropertyValueIsCallable(methodInfo, args, argIRs, constructor, brackets))
							{
								return;
							}
						}
					}
				}
				catch (AmbiguousMatchException)
				{
					if (constructor)
					{
						context.HandleError(JSError.AmbiguousConstructorCall, isFullyResolved);
						return;
					}
					MethodInfo methodInfo2 = LookForParameterlessPropertyGetter();
					if (!(methodInfo2 != null) || !ParameterlessPropertyValueIsCallable(methodInfo2, args, argIRs, constructor, brackets))
					{
						context.HandleError(JSError.AmbiguousMatch, isFullyResolved);
						member = null;
					}
					return;
				}
				catch (JScriptException ex2)
				{
					context.HandleError((JSError)(ex2.ErrorNumber & 0xFFFF), ex2.Message, treatAsError: true);
					return;
				}
			}
			if (memberInfo == null)
			{
				memberInfo = ResolveOtherKindOfCall(args, argIRs, constructor, brackets);
			}
			if (memberInfo == null)
			{
				return;
			}
			if (!Accessible(checkSetter: false))
			{
				member = null;
				return;
			}
			WarnIfObsolete();
			if (!(memberInfo is MethodBase))
			{
				return;
			}
			if (CustomAttribute.IsDefined(memberInfo, typeof(JSFunctionAttribute), inherit: false) && !(defaultMember is PropertyInfo))
			{
				int num = 0;
				object[] customAttributes = CustomAttribute.GetCustomAttributes(memberInfo, typeof(JSFunctionAttribute), inherit: false);
				JSFunctionAttributeEnum attributeValue = ((JSFunctionAttribute)customAttributes[0]).attributeValue;
				if ((constructor && !(memberInfo is ConstructorInfo)) || (attributeValue & JSFunctionAttributeEnum.HasArguments) != 0)
				{
					member = LateBinding.SelectMember(members);
					defaultMember = null;
					return;
				}
				if ((attributeValue & JSFunctionAttributeEnum.HasThisObject) != 0)
				{
					num = 1;
				}
				if ((attributeValue & JSFunctionAttributeEnum.HasEngine) != 0)
				{
					num++;
				}
				if (!CheckParameters(((MethodBase)memberInfo).GetParameters(), argIRs, args, context, num, defaultIsUndefined: true, isFullyResolved))
				{
					member = null;
				}
			}
			else if (constructor && memberInfo is JSFieldMethod)
			{
				member = LateBinding.SelectMember(members);
			}
			else if (constructor && memberInfo is ConstructorInfo && !(memberInfo is JSConstructor) && Typeob.Delegate.IsAssignableFrom(memberInfo.DeclaringType))
			{
				context.HandleError(JSError.DelegatesShouldNotBeExplicitlyConstructed);
				member = null;
			}
			else if (!CheckParameters(((MethodBase)memberInfo).GetParameters(), argIRs, args, context, 0, defaultIsUndefined: false, isFullyResolved))
			{
				member = null;
			}
		}

		internal override object ResolveCustomAttribute(ASTList args, IReflect[] argIRs, AST target)
		{
			try
			{
				ResolveCall(args, argIRs, constructor: true, brackets: false);
			}
			catch (AmbiguousMatchException)
			{
				context.HandleError(JSError.AmbiguousConstructorCall);
				return null;
			}
			JSConstructor jSConstructor = member as JSConstructor;
			if (jSConstructor != null)
			{
				ClassScope classScope = jSConstructor.GetClassScope();
				if (classScope.owner.IsCustomAttribute())
				{
					return classScope;
				}
			}
			else
			{
				ConstructorInfo constructorInfo = member as ConstructorInfo;
				if (constructorInfo != null)
				{
					Type declaringType = constructorInfo.DeclaringType;
					if (Typeob.Attribute.IsAssignableFrom(declaringType))
					{
						object[] customAttributes = CustomAttribute.GetCustomAttributes(declaringType, typeof(AttributeUsageAttribute), inherit: false);
						if (customAttributes.Length != 0)
						{
							return declaringType;
						}
					}
				}
			}
			context.HandleError(JSError.InvalidCustomAttributeClassOrCtor);
			return null;
		}

		internal void ResolveLHValue()
		{
			MemberInfo memberInfo = (member = LateBinding.SelectMember(members));
			if ((memberInfo != null && !Accessible(checkSetter: true)) || (member == null && members.Length != 0))
			{
				context.HandleError(JSError.AssignmentToReadOnly, isFullyResolved);
				member = null;
				members = new MemberInfo[0];
			}
			else if (memberInfo is JSPrototypeField)
			{
				member = null;
				members = new MemberInfo[0];
			}
			else
			{
				WarnIfNotFullyResolved();
				WarnIfObsolete();
			}
		}

		private MemberInfo ResolveOtherKindOfCall(ASTList argList, IReflect[] argIRs, bool constructor, bool brackets)
		{
			MemberInfo memberInfo = (member = LateBinding.SelectMember(members));
			if (memberInfo is PropertyInfo && !(memberInfo is JSProperty) && memberInfo.DeclaringType == Typeob.GlobalObject)
			{
				PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
				Type propertyType = propertyInfo.PropertyType;
				if (propertyType == Typeob.Type)
				{
					memberInfo = (Type)propertyInfo.GetValue(null, null);
				}
				else if (constructor && brackets)
				{
					MethodInfo method = propertyType.GetMethod("CreateInstance", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
					if (method != null)
					{
						Type returnType = method.ReturnType;
						memberInfo = ((returnType == Typeob.BooleanObject) ? Typeob.Boolean : ((!(returnType == Typeob.StringObject)) ? returnType : Typeob.String));
					}
				}
			}
			if (this is CallableExpression callableExpression && callableExpression.expression is ConstantWrapper constantWrapper && constantWrapper.InferType(null) is Type)
			{
				memberInfo = new JSGlobalField(null, null, constantWrapper.value, FieldAttributes.Public | FieldAttributes.Literal);
			}
			if (memberInfo is Type)
			{
				if (constructor)
				{
					if (brackets)
					{
						isArrayConstructor = true;
						defaultMember = memberInfo;
						defaultMemberReturnIR = new TypedArray((Type)memberInfo, argIRs.Length);
						int i = 0;
						for (int num = argIRs.Length; i < num; i++)
						{
							if (argIRs[i] != Typeob.Object && !Convert.IsPrimitiveNumericType(argIRs[i]))
							{
								argList[i].context.HandleError(JSError.TypeMismatch, isFullyResolved);
								break;
							}
						}
						return member = memberInfo;
					}
					ConstructorInfo[] constructors = ((Type)memberInfo).GetConstructors(BindingFlags.Instance | BindingFlags.Public);
					if (constructors == null || constructors.Length == 0)
					{
						context.HandleError(JSError.NoConstructor);
						member = null;
						return null;
					}
					MemberInfo[] array = (members = constructors);
					ResolveCall(argList, argIRs, constructor: true, brackets);
					return member;
				}
				if (!brackets && argIRs.Length == 1)
				{
					return memberInfo;
				}
				context.HandleError(JSError.InvalidCall);
				return member = null;
			}
			if (memberInfo is JSPrototypeField)
			{
				return member = null;
			}
			if (memberInfo is FieldInfo && ((FieldInfo)memberInfo).IsLiteral)
			{
				if (!AccessibleField(checkWritable: false))
				{
					return member = null;
				}
				object obj = ((memberInfo is JSVariableField) ? ((JSVariableField)memberInfo).value : TypeReferences.GetConstantValue((FieldInfo)memberInfo));
				if (obj is ClassScope || obj is Type)
				{
					if (constructor)
					{
						if (brackets)
						{
							isArrayConstructor = true;
							defaultMember = memberInfo;
							defaultMemberReturnIR = new TypedArray((obj is ClassScope) ? ((IReflect)obj) : ((IReflect)obj), argIRs.Length);
							int j = 0;
							for (int num2 = argIRs.Length; j < num2; j++)
							{
								if (argIRs[j] != Typeob.Object && !Convert.IsPrimitiveNumericType(argIRs[j]))
								{
									argList[j].context.HandleError(JSError.TypeMismatch, isFullyResolved);
									break;
								}
							}
							return member = memberInfo;
						}
						if (obj is ClassScope && !((ClassScope)obj).owner.isStatic)
						{
							ConstantWrapper constantWrapper2 = null;
							if (this is Member && ((Member)this).rootObject is ConstantWrapper constantWrapper3 && !(constantWrapper3.Evaluate() is Namespace))
							{
								((Member)this).rootObject.context.HandleError(JSError.NeedInstance);
								return null;
							}
						}
						MemberInfo[] array = (members = ((obj is ClassScope) ? ((ClassScope)obj).constructors : ((Type)obj).GetConstructors(BindingFlags.Instance | BindingFlags.Public)));
						if (members == null || members.Length == 0)
						{
							context.HandleError(JSError.NoConstructor);
							member = null;
							return null;
						}
						ResolveCall(argList, argIRs, constructor: true, brackets);
						return member;
					}
					if (!brackets && argIRs.Length == 1)
					{
						Type type = obj as Type;
						return member = ((type != null) ? type : memberInfo);
					}
					context.HandleError(JSError.InvalidCall);
					return member = null;
				}
				if (obj is TypedArray)
				{
					if (!constructor)
					{
						if (!(argIRs.Length != 1 || brackets))
						{
							return member = memberInfo;
						}
					}
					else if (brackets && argIRs.Length != 0)
					{
						isArrayConstructor = true;
						defaultMember = memberInfo;
						defaultMemberReturnIR = new TypedArray((IReflect)obj, argIRs.Length);
						int k = 0;
						for (int num3 = argIRs.Length; k < num3; k++)
						{
							if (argIRs[k] != Typeob.Object && !Convert.IsPrimitiveNumericType(argIRs[k]))
							{
								argList[k].context.HandleError(JSError.TypeMismatch, isFullyResolved);
								break;
							}
						}
						return member = memberInfo;
					}
					goto IL_0901;
				}
				if (obj is FunctionObject)
				{
					FunctionObject functionObject = (FunctionObject)obj;
					if (!functionObject.isExpandoMethod && !functionObject.Must_save_stack_locals && (functionObject.own_scope.ProvidesOuterScopeLocals == null || functionObject.own_scope.ProvidesOuterScopeLocals.count == 0))
					{
						return member = ((JSVariableField)member).GetAsMethod(functionObject.own_scope);
					}
					return member;
				}
			}
			IReflect reflect = InferType(null);
			Type type2 = reflect as Type;
			if (!brackets && ((type2 != null && Typeob.ScriptFunction.IsAssignableFrom(type2)) || reflect is ScriptFunction))
			{
				defaultMember = memberInfo;
				if (type2 == null)
				{
					defaultMemberReturnIR = Globals.TypeRefs.ToReferenceContext(reflect.GetType());
					member = defaultMemberReturnIR.GetMethod(constructor ? "CreateInstance" : "Invoke", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
					if (member == null)
					{
						defaultMemberReturnIR = Typeob.ScriptFunction;
						member = defaultMemberReturnIR.GetMethod(constructor ? "CreateInstance" : "Invoke", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
					}
					return member;
				}
				if (constructor && members.Length != 0 && members[0] is JSFieldMethod)
				{
					JSFieldMethod jSFieldMethod = (JSFieldMethod)members[0];
					jSFieldMethod.func.PartiallyEvaluate();
					if (!jSFieldMethod.func.isExpandoMethod)
					{
						context.HandleError(JSError.NotAnExpandoFunction, isFullyResolved);
					}
				}
				defaultMemberReturnIR = type2;
				return member = type2.GetMethod(constructor ? "CreateInstance" : "Invoke", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
			}
			if (reflect == Typeob.Type)
			{
				member = null;
				return null;
			}
			if (reflect == Typeob.Object || (reflect is ScriptObject && brackets && !(reflect is ClassScope)))
			{
				return memberInfo;
			}
			if (reflect is TypedArray || (reflect is Type && ((Type)reflect).IsArray))
			{
				int num4 = argIRs.Length;
				int num5 = ((reflect is TypedArray) ? ((TypedArray)reflect).rank : ((Type)reflect).GetArrayRank());
				if (num4 != num5)
				{
					context.HandleError(JSError.IncorrectNumberOfIndices, isFullyResolved);
				}
				else
				{
					for (int l = 0; l < num5; l++)
					{
						if (argIRs[l] != Typeob.Object && (!Convert.IsPrimitiveNumericType(argIRs[l]) || Convert.IsBadIndex(argList[l])))
						{
							argList[l].context.HandleError(JSError.TypeMismatch, isFullyResolved);
							break;
						}
					}
				}
				if (!constructor)
				{
					goto IL_07f8;
				}
				if (brackets)
				{
					IReflect reflect2;
					if (!(reflect is TypedArray))
					{
						IReflect elementType = ((Type)reflect).GetElementType();
						reflect2 = elementType;
					}
					else
					{
						reflect2 = ((TypedArray)reflect).elementType;
					}
					IReflect reflect3 = reflect2;
					if (reflect == Typeob.Object || reflect is ClassScope || (reflect is Type && !Typeob.Type.IsAssignableFrom((Type)reflect) && !Typeob.ScriptFunction.IsAssignableFrom((Type)reflect)))
					{
						goto IL_07f8;
					}
				}
			}
			else if (!constructor)
			{
				if (brackets && reflect == Typeob.String && (this.argIRs.Length != 1 || !Convert.IsPrimitiveNumericType(argIRs[0])))
				{
					reflect = Typeob.StringObject;
				}
				MemberInfo[] array2 = ((brackets || !(reflect is ScriptObject)) ? JSBinder.GetDefaultMembers(reflect) : null);
				if (array2 != null && array2.Length != 0)
				{
					try
					{
						defaultMember = memberInfo;
						defaultMemberReturnIR = reflect;
						return member = JSBinder.SelectMethod(members = array2, argIRs);
					}
					catch (AmbiguousMatchException)
					{
						context.HandleError(JSError.AmbiguousMatch, isFullyResolved);
						return member = null;
					}
				}
				if (!brackets && reflect is Type && Typeob.Delegate.IsAssignableFrom((Type)reflect))
				{
					defaultMember = memberInfo;
					defaultMemberReturnIR = reflect;
					return member = ((Type)reflect).GetMethod("Invoke");
				}
			}
			goto IL_0901;
			IL_07f8:
			isArrayElementAccess = true;
			defaultMember = memberInfo;
			defaultMemberReturnIR = reflect;
			return null;
			IL_0901:
			if (constructor)
			{
				context.HandleError(JSError.NeedType, isFullyResolved);
			}
			else if (brackets)
			{
				context.HandleError(JSError.NotIndexable, isFullyResolved);
			}
			else
			{
				context.HandleError(JSError.FunctionExpected, isFullyResolved);
			}
			return member = null;
		}

		/// <summary>Resolves the right-hand side of the binding reference.</summary>
		protected void ResolveRHValue()
		{
			MemberInfo memberInfo = (member = LateBinding.SelectMember(members));
			JSLocalField jSLocalField = member as JSLocalField;
			if (jSLocalField != null && jSLocalField.value is FunctionObject functionObject && functionObject.enclosing_scope is FunctionScope functionScope)
			{
				functionScope.closuresMightEscape = true;
			}
			if (memberInfo is JSPrototypeField)
			{
				member = null;
				return;
			}
			if (!Accessible(checkSetter: false))
			{
				member = null;
				return;
			}
			WarnIfObsolete();
			WarnIfNotFullyResolved();
		}

		internal override void SetPartialValue(AST partial_value)
		{
			AssignmentCompatible(InferType(null), partial_value, partial_value.InferType(null), isFullyResolved);
		}

		internal void SetPartialValue(ASTList argList, IReflect[] argIRs, AST partial_value, bool inBrackets)
		{
			if (members == null || members.Length == 0)
			{
				HandleNoSuchMemberError();
				isAssignmentToDefaultIndexedProperty = true;
				return;
			}
			PartiallyEvaluate();
			IReflect reflect = InferType(null);
			isAssignmentToDefaultIndexedProperty = true;
			if (reflect == Typeob.Object)
			{
				JSVariableField jSVariableField = member as JSVariableField;
				if (jSVariableField == null || !jSVariableField.IsLiteral || !(jSVariableField.value is ClassScope))
				{
					return;
				}
				reflect = Typeob.Type;
			}
			else
			{
				if (reflect is TypedArray || (reflect is Type && ((Type)reflect).IsArray))
				{
					bool flag = false;
					int num = argIRs.Length;
					int num2 = ((reflect is TypedArray) ? ((TypedArray)reflect).rank : ((Type)reflect).GetArrayRank());
					if (num != num2)
					{
						context.HandleError(JSError.IncorrectNumberOfIndices, isFullyResolved);
						flag = true;
					}
					for (int i = 0; i < num2; i++)
					{
						if (!flag && i < num && argIRs[i] != Typeob.Object && (!Convert.IsPrimitiveNumericType(argIRs[i]) || Convert.IsBadIndex(argList[i])))
						{
							argList[i].context.HandleError(JSError.TypeMismatch, isFullyResolved);
							flag = true;
						}
					}
					isArrayElementAccess = true;
					isAssignmentToDefaultIndexedProperty = false;
					defaultMember = member;
					defaultMemberReturnIR = reflect;
					IReflect reflect2;
					if (!(reflect is TypedArray))
					{
						IReflect elementType = ((Type)reflect).GetElementType();
						reflect2 = elementType;
					}
					else
					{
						reflect2 = ((TypedArray)reflect).elementType;
					}
					IReflect lhir = reflect2;
					AssignmentCompatible(lhir, partial_value, partial_value.InferType(null), isFullyResolved);
					return;
				}
				MemberInfo[] defaultMembers = JSBinder.GetDefaultMembers(reflect);
				if (defaultMembers != null && defaultMembers.Length != 0 && member != null)
				{
					try
					{
						PropertyInfo propertyInfo = JSBinder.SelectProperty(defaultMembers, argIRs);
						if (propertyInfo == null)
						{
							context.HandleError(JSError.NotIndexable, Convert.ToTypeName(reflect));
						}
						else if (JSProperty.GetSetMethod(propertyInfo, nonPublic: true) == null)
						{
							if (reflect == Typeob.String)
							{
								context.HandleError(JSError.UselessAssignment);
							}
							else
							{
								context.HandleError(JSError.AssignmentToReadOnly, isFullyResolved && base.Engine.doFast);
							}
						}
						else if (CheckParameters(propertyInfo.GetIndexParameters(), argIRs, argList, context, 0, defaultIsUndefined: false, reportError: true))
						{
							defaultMember = member;
							defaultMemberReturnIR = reflect;
							members = defaultMembers;
							member = propertyInfo;
						}
						return;
					}
					catch (AmbiguousMatchException)
					{
						context.HandleError(JSError.AmbiguousMatch, isFullyResolved);
						member = null;
						return;
					}
				}
			}
			member = null;
			if (!inBrackets)
			{
				context.HandleError(JSError.IllegalAssignment);
			}
			else
			{
				context.HandleError(JSError.NotIndexable, Convert.ToTypeName(reflect));
			}
		}

		internal override void SetValue(object value)
		{
			MemberInfo memberInfo = member;
			object @object = GetObject();
			if (memberInfo is FieldInfo)
			{
				FieldInfo fieldInfo = (FieldInfo)memberInfo;
				if (!fieldInfo.IsLiteral && !fieldInfo.IsInitOnly)
				{
					if (!(fieldInfo is JSField) || fieldInfo is JSWrappedField)
					{
						value = Convert.CoerceT(value, fieldInfo.FieldType, explicitOK: false);
					}
					fieldInfo.SetValue(@object, value, BindingFlags.SuppressChangeType, null, null);
				}
			}
			else if (memberInfo is PropertyInfo)
			{
				PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
				if (@object is ClassScope && !(propertyInfo is JSProperty))
				{
					JSProperty.SetValue(propertyInfo, ((WithObject)((ClassScope)@object).GetParent()).contained_object, value, null);
					return;
				}
				if (!(propertyInfo is JSProperty))
				{
					value = Convert.CoerceT(value, propertyInfo.PropertyType, explicitOK: false);
				}
				JSProperty.SetValue(propertyInfo, @object, value, null);
			}
			else
			{
				if (members != null && members.Length != 0)
				{
					throw new JScriptException(JSError.IllegalAssignment);
				}
				EvaluateAsLateBinding().SetValue(value);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			TranslateToIL(il, rtype, preSet: false, preSetPlusGet: false);
		}

		internal void TranslateToIL(ILGenerator il, Type rtype, bool calledFromDelete)
		{
			TranslateToIL(il, rtype, preSet: false, preSetPlusGet: false, calledFromDelete);
		}

		private void TranslateToIL(ILGenerator il, Type rtype, bool preSet, bool preSetPlusGet)
		{
			TranslateToIL(il, rtype, preSet, preSetPlusGet, calledFromDelete: false);
		}

		private void TranslateToIL(ILGenerator il, Type rtype, bool preSet, bool preSetPlusGet, bool calledFromDelete)
		{
			if (member is FieldInfo)
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				bool flag = fieldInfo.IsStatic || fieldInfo.IsLiteral;
				if (fieldInfo.IsLiteral && fieldInfo is JSMemberField)
				{
					object value = ((JSMemberField)fieldInfo).value;
					flag = !(value is FunctionObject functionObject) || !functionObject.isExpandoMethod;
				}
				if (!flag || fieldInfo is JSClosureField)
				{
					TranslateToILObject(il, fieldInfo.DeclaringType, noValue: true);
					if (preSetPlusGet)
					{
						il.Emit(OpCodes.Dup);
					}
					flag = false;
				}
				if (preSet)
				{
					return;
				}
				object obj = ((fieldInfo is JSField) ? ((JSField)fieldInfo).GetMetaData() : ((fieldInfo is JSFieldInfo) ? ((JSFieldInfo)fieldInfo).field : fieldInfo));
				if (obj is FieldInfo && !((FieldInfo)obj).IsLiteral)
				{
					il.Emit(flag ? OpCodes.Ldsfld : OpCodes.Ldfld, (FieldInfo)obj);
				}
				else if (obj is LocalBuilder)
				{
					il.Emit(OpCodes.Ldloc, (LocalBuilder)obj);
				}
				else
				{
					if (fieldInfo.IsLiteral)
					{
						new ConstantWrapper(TypeReferences.GetConstantValue(fieldInfo), context).TranslateToIL(il, rtype);
						return;
					}
					Convert.EmitLdarg(il, (short)obj);
				}
				Convert.Emit(this, il, fieldInfo.FieldType, rtype);
				return;
			}
			if (member is PropertyInfo)
			{
				PropertyInfo prop = (PropertyInfo)member;
				MethodInfo methodInfo = (preSet ? JSProperty.GetSetMethod(prop, nonPublic: true) : JSProperty.GetGetMethod(prop, nonPublic: true));
				if (methodInfo == null)
				{
					if (!preSet)
					{
						if (this is Lookup)
						{
							il.Emit(OpCodes.Ldc_I4, 5041);
							il.Emit(OpCodes.Newobj, CompilerGlobals.scriptExceptionConstructor);
							il.Emit(OpCodes.Throw);
						}
						else
						{
							il.Emit(OpCodes.Ldnull);
						}
					}
					return;
				}
				bool flag2 = methodInfo.IsStatic && !(methodInfo is JSClosureMethod);
				if (!flag2)
				{
					Type declaringType = methodInfo.DeclaringType;
					if (declaringType == Typeob.StringObject && methodInfo.Name.Equals("get_length"))
					{
						TranslateToILObject(il, Typeob.String, noValue: false);
						methodInfo = CompilerGlobals.stringLengthMethod;
					}
					else
					{
						TranslateToILObject(il, declaringType, noValue: true);
					}
				}
				if (preSet)
				{
					return;
				}
				methodInfo = GetMethodInfoMetadata(methodInfo);
				if (flag2)
				{
					il.Emit(OpCodes.Call, methodInfo);
				}
				else
				{
					if (preSetPlusGet)
					{
						il.Emit(OpCodes.Dup);
					}
					if (!isNonVirtual && methodInfo.IsVirtual && !methodInfo.IsFinal && (!methodInfo.ReflectedType.IsSealed || !methodInfo.ReflectedType.IsValueType))
					{
						il.Emit(OpCodes.Callvirt, methodInfo);
					}
					else
					{
						il.Emit(OpCodes.Call, methodInfo);
					}
				}
				Convert.Emit(this, il, methodInfo.ReturnType, rtype);
				return;
			}
			if (member is MethodInfo)
			{
				MethodInfo methodInfoMetadata = GetMethodInfoMetadata((MethodInfo)member);
				if (Typeob.Delegate.IsAssignableFrom(rtype))
				{
					if (!methodInfoMetadata.IsStatic)
					{
						Type declaringType2 = methodInfoMetadata.DeclaringType;
						TranslateToILObject(il, declaringType2, noValue: false);
						if (declaringType2.IsValueType)
						{
							il.Emit(OpCodes.Box, declaringType2);
						}
					}
					else
					{
						il.Emit(OpCodes.Ldnull);
					}
					if (methodInfoMetadata.IsVirtual && !methodInfoMetadata.IsFinal && (!methodInfoMetadata.ReflectedType.IsSealed || !methodInfoMetadata.ReflectedType.IsValueType))
					{
						il.Emit(OpCodes.Dup);
						il.Emit(OpCodes.Ldvirtftn, methodInfoMetadata);
					}
					else
					{
						il.Emit(OpCodes.Ldftn, methodInfoMetadata);
					}
					ConstructorInfo constructor = rtype.GetConstructor(new Type[2]
					{
						Typeob.Object,
						Typeob.UIntPtr
					});
					if (constructor == null)
					{
						constructor = rtype.GetConstructor(new Type[2]
						{
							Typeob.Object,
							Typeob.IntPtr
						});
					}
					il.Emit(OpCodes.Newobj, constructor);
				}
				else if (member is JSExpandoIndexerMethod)
				{
					MemberInfo memberInfo = member;
					member = defaultMember;
					TranslateToIL(il, Typeob.Object);
					member = memberInfo;
				}
				else
				{
					il.Emit(OpCodes.Ldnull);
					Convert.Emit(this, il, Typeob.Object, rtype);
				}
				return;
			}
			object obj2 = null;
			if (this is Lookup)
			{
				((Lookup)this).TranslateToLateBinding(il);
			}
			else
			{
				if (!isFullyResolved && !preSet && !preSetPlusGet)
				{
					obj2 = TranslateToSpeculativeEarlyBindings(il, rtype, getObjectFromLateBindingInstance: false);
				}
				((Member)this).TranslateToLateBinding(il, obj2 != null);
				if (!isFullyResolved && preSetPlusGet)
				{
					obj2 = TranslateToSpeculativeEarlyBindings(il, rtype, getObjectFromLateBindingInstance: true);
				}
			}
			if (preSetPlusGet)
			{
				il.Emit(OpCodes.Dup);
			}
			if (!preSet)
			{
				if (this is Lookup && !calledFromDelete)
				{
					il.Emit(OpCodes.Call, CompilerGlobals.getValue2Method);
				}
				else
				{
					il.Emit(OpCodes.Call, CompilerGlobals.getNonMissingValueMethod);
				}
				Convert.Emit(this, il, Typeob.Object, rtype);
				if (obj2 != null)
				{
					il.MarkLabel((Label)obj2);
				}
			}
		}

		internal override void TranslateToILCall(ILGenerator il, Type rtype, ASTList argList, bool construct, bool brackets)
		{
			MemberInfo memberInfo = member;
			if (defaultMember != null)
			{
				if (isArrayConstructor)
				{
					TypedArray typedArray = (TypedArray)defaultMemberReturnIR;
					Type type = Convert.ToType(typedArray.elementType);
					int rank = typedArray.rank;
					if (rank == 1)
					{
						argList[0].TranslateToIL(il, Typeob.Int32);
						il.Emit(OpCodes.Newarr, type);
					}
					else
					{
						Type type2 = typedArray.ToType();
						Type[] array = new Type[rank];
						for (int i = 0; i < rank; i++)
						{
							array[i] = Typeob.Int32;
						}
						int j = 0;
						for (int count = argList.count; j < count; j++)
						{
							argList[j].TranslateToIL(il, Typeob.Int32);
						}
						TypeBuilder typeBuilder = type as TypeBuilder;
						if (typeBuilder != null)
						{
							MethodInfo arrayMethod = ((ModuleBuilder)type2.Module).GetArrayMethod(type2, ".ctor", CallingConventions.HasThis, Typeob.Void, array);
							il.Emit(OpCodes.Newobj, arrayMethod);
						}
						else
						{
							ConstructorInfo constructor = type2.GetConstructor(array);
							il.Emit(OpCodes.Newobj, constructor);
						}
					}
					Convert.Emit(this, il, typedArray.ToType(), rtype);
					return;
				}
				member = defaultMember;
				IReflect reflect = defaultMemberReturnIR;
				Type type3 = ((reflect is Type) ? ((Type)reflect) : Convert.ToType(reflect));
				TranslateToIL(il, type3);
				if (isArrayElementAccess)
				{
					int k = 0;
					for (int count2 = argList.count; k < count2; k++)
					{
						argList[k].TranslateToIL(il, Typeob.Int32);
					}
					Type elementType = type3.GetElementType();
					int arrayRank = type3.GetArrayRank();
					if (arrayRank == 1)
					{
						TranslateToLdelem(il, elementType);
					}
					else
					{
						Type[] array2 = new Type[arrayRank];
						for (int l = 0; l < arrayRank; l++)
						{
							array2[l] = Typeob.Int32;
						}
						MethodInfo arrayMethod2 = base.compilerGlobals.module.GetArrayMethod(type3, "Get", CallingConventions.HasThis, elementType, array2);
						il.Emit(OpCodes.Call, arrayMethod2);
					}
					Convert.Emit(this, il, elementType, rtype);
					return;
				}
				member = memberInfo;
			}
			if (memberInfo is MethodInfo)
			{
				MethodInfo methodInfo = (MethodInfo)memberInfo;
				Type declaringType = methodInfo.DeclaringType;
				Type reflectedType = methodInfo.ReflectedType;
				ParameterInfo[] parameters = methodInfo.GetParameters();
				if (!methodInfo.IsStatic && defaultMember == null)
				{
					TranslateToILObject(il, declaringType, noValue: true);
				}
				if (methodInfo is JSClosureMethod)
				{
					TranslateToILObject(il, declaringType, noValue: false);
				}
				ConstantWrapper constantWrapper = null;
				int offset = 0;
				if (methodInfo is JSFieldMethod || CustomAttribute.IsDefined(methodInfo, typeof(JSFunctionAttribute), inherit: false))
				{
					offset = PlaceValuesForHiddenParametersOnStack(il, methodInfo, parameters);
					constantWrapper = JScriptMissingCW;
				}
				else
				{
					constantWrapper = ReflectionMissingCW;
				}
				if (argList.count == 1 && constantWrapper == JScriptMissingCW && defaultMember is PropertyInfo)
				{
					il.Emit(OpCodes.Ldc_I4_1);
					il.Emit(OpCodes.Newarr, Typeob.Object);
					il.Emit(OpCodes.Dup);
					il.Emit(OpCodes.Ldc_I4_0);
					argList[0].TranslateToIL(il, Typeob.Object);
					il.Emit(OpCodes.Stelem_Ref);
				}
				else
				{
					PlaceArgumentsOnStack(il, parameters, argList, offset, 0, constantWrapper);
				}
				methodInfo = GetMethodInfoMetadata(methodInfo);
				if (!isNonVirtual && methodInfo.IsVirtual && !methodInfo.IsFinal && (!reflectedType.IsSealed || !reflectedType.IsValueType))
				{
					il.Emit(OpCodes.Callvirt, methodInfo);
				}
				else
				{
					il.Emit(OpCodes.Call, methodInfo);
				}
				Convert.Emit(this, il, methodInfo.ReturnType, rtype);
				return;
			}
			if (memberInfo is ConstructorInfo)
			{
				ConstructorInfo constructorInfo = (ConstructorInfo)memberInfo;
				ParameterInfo[] parameters2 = constructorInfo.GetParameters();
				bool flag = false;
				if (CustomAttribute.IsDefined(constructorInfo, typeof(JSFunctionAttribute), inherit: false))
				{
					object[] customAttributes = CustomAttribute.GetCustomAttributes(constructorInfo, typeof(JSFunctionAttribute), inherit: false);
					flag = (((JSFunctionAttribute)customAttributes[0]).attributeValue & JSFunctionAttributeEnum.IsInstanceNestedClassConstructor) != 0;
				}
				if (flag)
				{
					PlaceArgumentsOnStack(il, parameters2, argList, 0, 1, ReflectionMissingCW);
					TranslateToILObject(il, parameters2[parameters2.Length - 1].ParameterType, noValue: false);
				}
				else
				{
					PlaceArgumentsOnStack(il, parameters2, argList, 0, 0, ReflectionMissingCW);
				}
				Type type4 = null;
				if (memberInfo is JSConstructor && (type4 = ((JSConstructor)memberInfo).OuterClassType()) != null)
				{
					TranslateToILObject(il, type4, noValue: false);
				}
				bool flag2 = false;
				Type declaringType2 = constructorInfo.DeclaringType;
				if (constructorInfo is JSConstructor)
				{
					constructorInfo = ((JSConstructor)constructorInfo).GetConstructorInfo(base.compilerGlobals);
					flag2 = true;
				}
				else
				{
					flag2 = Typeob.INeedEngine.IsAssignableFrom(declaringType2);
				}
				il.Emit(OpCodes.Newobj, constructorInfo);
				if (flag2)
				{
					il.Emit(OpCodes.Dup);
					EmitILToLoadEngine(il);
					il.Emit(OpCodes.Callvirt, CompilerGlobals.setEngineMethod);
				}
				Convert.Emit(this, il, declaringType2, rtype);
				return;
			}
			Type type5 = memberInfo as Type;
			if (type5 != null)
			{
				AST aST = argList[0];
				if (aST is NullLiteral)
				{
					aST.TranslateToIL(il, type5);
					Convert.Emit(this, il, type5, rtype);
					return;
				}
				IReflect reflect2 = aST.InferType(null);
				if (reflect2 == Typeob.ScriptFunction && Typeob.Delegate.IsAssignableFrom(type5))
				{
					aST.TranslateToIL(il, type5);
				}
				else
				{
					Type type6 = Convert.ToType(reflect2);
					aST.TranslateToIL(il, type6);
					Convert.Emit(this, il, type6, type5, truncationPermitted: true);
				}
				Convert.Emit(this, il, type5, rtype);
				return;
			}
			if (memberInfo is FieldInfo && ((FieldInfo)memberInfo).IsLiteral)
			{
				object obj = ((memberInfo is JSVariableField) ? ((JSVariableField)memberInfo).value : TypeReferences.GetConstantValue((FieldInfo)memberInfo));
				if (obj is Type || obj is ClassScope || obj is TypedArray)
				{
					AST aST2 = argList[0];
					if (aST2 is NullLiteral)
					{
						il.Emit(OpCodes.Ldnull);
						return;
					}
					if (obj is ClassScope classScope && classScope.owner is EnumDeclaration enumDeclaration)
					{
						obj = enumDeclaration.baseType.ToType();
					}
					Type type7 = Convert.ToType(aST2.InferType(null));
					aST2.TranslateToIL(il, type7);
					Type type8 = ((obj is Type) ? ((Type)obj) : ((obj is ClassScope) ? Convert.ToType((ClassScope)obj) : ((TypedArray)obj).ToType()));
					Convert.Emit(this, il, type7, type8, truncationPermitted: true);
					if (!rtype.IsEnum)
					{
						Convert.Emit(this, il, type8, rtype);
					}
					return;
				}
			}
			LocalBuilder localBuilder = null;
			int m = 0;
			for (int count3 = argList.count; m < count3; m++)
			{
				if (argList[m] is AddressOf)
				{
					localBuilder = il.DeclareLocal(Typeob.ArrayOfObject);
					break;
				}
			}
			object obj2 = null;
			if (memberInfo == null && (members == null || members.Length == 0))
			{
				if (this is Lookup)
				{
					((Lookup)this).TranslateToLateBinding(il);
				}
				else
				{
					obj2 = TranslateToSpeculativeEarlyBoundCalls(il, rtype, argList, construct, brackets);
					((Member)this).TranslateToLateBinding(il, obj2 != null);
				}
				argList.TranslateToIL(il, Typeob.ArrayOfObject);
				if (localBuilder != null)
				{
					il.Emit(OpCodes.Dup);
					il.Emit(OpCodes.Stloc, localBuilder);
				}
				if (construct)
				{
					il.Emit(OpCodes.Ldc_I4_1);
				}
				else
				{
					il.Emit(OpCodes.Ldc_I4_0);
				}
				if (brackets)
				{
					il.Emit(OpCodes.Ldc_I4_1);
				}
				else
				{
					il.Emit(OpCodes.Ldc_I4_0);
				}
				EmitILToLoadEngine(il);
				il.Emit(OpCodes.Call, CompilerGlobals.callMethod);
				Convert.Emit(this, il, Typeob.Object, rtype);
				if (localBuilder != null)
				{
					int n = 0;
					for (int count4 = argList.count; n < count4; n++)
					{
						if (argList[n] is AddressOf addressOf)
						{
							addressOf.TranslateToILPreSet(il);
							il.Emit(OpCodes.Ldloc, localBuilder);
							ConstantWrapper.TranslateToILInt(il, n);
							il.Emit(OpCodes.Ldelem_Ref);
							Convert.Emit(this, il, Typeob.Object, Convert.ToType(addressOf.InferType(null)));
							addressOf.TranslateToILSet(il, null);
						}
					}
				}
				if (obj2 != null)
				{
					il.MarkLabel((Label)obj2);
				}
				return;
			}
			TranslateToILWithDupOfThisOb(il);
			argList.TranslateToIL(il, Typeob.ArrayOfObject);
			if (localBuilder != null)
			{
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Stloc, localBuilder);
			}
			if (construct)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			if (brackets)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.callValueMethod);
			Convert.Emit(this, il, Typeob.Object, rtype);
			if (localBuilder == null)
			{
				return;
			}
			int num = 0;
			for (int count5 = argList.count; num < count5; num++)
			{
				if (argList[num] is AddressOf addressOf2)
				{
					addressOf2.TranslateToILPreSet(il);
					il.Emit(OpCodes.Ldloc, localBuilder);
					ConstantWrapper.TranslateToILInt(il, num);
					il.Emit(OpCodes.Ldelem_Ref);
					Convert.Emit(this, il, Typeob.Object, Convert.ToType(addressOf2.InferType(null)));
					addressOf2.TranslateToILSet(il, null);
				}
			}
		}

		internal override void TranslateToILDelete(ILGenerator il, Type rtype)
		{
			if (this is Lookup)
			{
				((Lookup)this).TranslateToLateBinding(il);
			}
			else
			{
				((Member)this).TranslateToLateBinding(il, speculativeEarlyBindingsExist: false);
			}
			il.Emit(OpCodes.Call, CompilerGlobals.deleteMethod);
			Convert.Emit(this, il, Typeob.Boolean, rtype);
		}

		/// <summary>When overridden in a derived class, generates Microsoft intermediate language (MSIL) code for the object that the binding reference is defined on.</summary>
		/// <param name="il">An object that generates Microsoft intermediate language (MSIL) instructions.</param>
		/// <param name="obtype">The type of the object.</param>
		/// <param name="noValue">
		///   <see langword="true" /> if the object does not have a value; otherwise, <see langword="false" />.</param>
		protected abstract void TranslateToILObject(ILGenerator il, Type obtype, bool noValue);

		internal override void TranslateToILPreSet(ILGenerator il)
		{
			TranslateToIL(il, null, preSet: true, preSetPlusGet: false);
		}

		internal override void TranslateToILPreSet(ILGenerator il, ASTList argList)
		{
			if (isArrayElementAccess)
			{
				member = defaultMember;
				IReflect reflect = defaultMemberReturnIR;
				Type type = ((reflect is Type) ? ((Type)reflect) : Convert.ToType(reflect));
				TranslateToIL(il, type);
				int i = 0;
				for (int count = argList.count; i < count; i++)
				{
					argList[i].TranslateToIL(il, Typeob.Int32);
				}
				if (type.GetArrayRank() == 1)
				{
					Type elementType = type.GetElementType();
					if (elementType.IsValueType && !elementType.IsPrimitive && !elementType.IsEnum)
					{
						il.Emit(OpCodes.Ldelema, elementType);
					}
				}
			}
			else if (member is PropertyInfo && defaultMember != null)
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				member = defaultMember;
				TranslateToIL(il, Convert.ToType(defaultMemberReturnIR));
				member = propertyInfo;
				PlaceArgumentsOnStack(il, propertyInfo.GetIndexParameters(), argList, 0, 0, ReflectionMissingCW);
			}
			else
			{
				base.TranslateToILPreSet(il, argList);
			}
		}

		internal override void TranslateToILPreSetPlusGet(ILGenerator il)
		{
			TranslateToIL(il, Convert.ToType(InferType(null)), preSet: false, preSetPlusGet: true);
		}

		internal override void TranslateToILPreSetPlusGet(ILGenerator il, ASTList argList, bool inBrackets)
		{
			if (isArrayElementAccess)
			{
				member = defaultMember;
				IReflect reflect = defaultMemberReturnIR;
				Type type = ((reflect is Type) ? ((Type)reflect) : Convert.ToType(reflect));
				TranslateToIL(il, type);
				il.Emit(OpCodes.Dup);
				int arrayRank = type.GetArrayRank();
				LocalBuilder[] array = new LocalBuilder[arrayRank];
				int i = 0;
				for (int count = argList.count; i < count; i++)
				{
					argList[i].TranslateToIL(il, Typeob.Int32);
					array[i] = il.DeclareLocal(Typeob.Int32);
					il.Emit(OpCodes.Dup);
					il.Emit(OpCodes.Stloc, array[i]);
				}
				Type elementType = type.GetElementType();
				if (arrayRank == 1)
				{
					TranslateToLdelem(il, elementType);
				}
				else
				{
					Type[] array2 = new Type[arrayRank];
					for (int j = 0; j < arrayRank; j++)
					{
						array2[j] = Typeob.Int32;
					}
					MethodInfo method = type.GetMethod("Get", array2);
					il.Emit(OpCodes.Call, method);
				}
				LocalBuilder local = il.DeclareLocal(elementType);
				il.Emit(OpCodes.Stloc, local);
				for (int k = 0; k < arrayRank; k++)
				{
					il.Emit(OpCodes.Ldloc, array[k]);
				}
				if (arrayRank == 1 && elementType.IsValueType && !elementType.IsPrimitive)
				{
					il.Emit(OpCodes.Ldelema, elementType);
				}
				il.Emit(OpCodes.Ldloc, local);
			}
			else
			{
				if (member != null && defaultMember != null)
				{
					member = defaultMember;
					defaultMember = null;
				}
				base.TranslateToILPreSetPlusGet(il, argList, inBrackets);
			}
		}

		internal override object TranslateToILReference(ILGenerator il, Type rtype)
		{
			if (member is FieldInfo)
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				Type fieldType = fieldInfo.FieldType;
				if (rtype == fieldType)
				{
					bool isStatic = fieldInfo.IsStatic;
					if (!isStatic)
					{
						TranslateToILObject(il, fieldInfo.DeclaringType, noValue: true);
					}
					object obj = ((fieldInfo is JSField) ? ((JSField)fieldInfo).GetMetaData() : ((fieldInfo is JSFieldInfo) ? ((JSFieldInfo)fieldInfo).field : fieldInfo));
					if (obj is FieldInfo)
					{
						if (fieldInfo.IsInitOnly)
						{
							LocalBuilder local = il.DeclareLocal(fieldType);
							il.Emit(isStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, (FieldInfo)obj);
							il.Emit(OpCodes.Stloc, local);
							il.Emit(OpCodes.Ldloca, local);
						}
						else
						{
							il.Emit(isStatic ? OpCodes.Ldsflda : OpCodes.Ldflda, (FieldInfo)obj);
						}
					}
					else if (obj is LocalBuilder)
					{
						il.Emit(OpCodes.Ldloca, (LocalBuilder)obj);
					}
					else
					{
						il.Emit(OpCodes.Ldarga, (short)obj);
					}
					return null;
				}
			}
			return base.TranslateToILReference(il, rtype);
		}

		internal override void TranslateToILSet(ILGenerator il, AST rhvalue)
		{
			if (isArrayElementAccess)
			{
				IReflect reflect = defaultMemberReturnIR;
				Type type = ((reflect is Type) ? ((Type)reflect) : Convert.ToType(reflect));
				int arrayRank = type.GetArrayRank();
				Type elementType = type.GetElementType();
				rhvalue?.TranslateToIL(il, elementType);
				if (arrayRank == 1)
				{
					TranslateToStelem(il, elementType);
					return;
				}
				Type[] array = new Type[arrayRank + 1];
				for (int i = 0; i < arrayRank; i++)
				{
					array[i] = Typeob.Int32;
				}
				array[arrayRank] = elementType;
				MethodInfo arrayMethod = base.compilerGlobals.module.GetArrayMethod(type, "Set", CallingConventions.HasThis, Typeob.Void, array);
				il.Emit(OpCodes.Call, arrayMethod);
			}
			else if (isAssignmentToDefaultIndexedProperty)
			{
				if (member is PropertyInfo && defaultMember != null)
				{
					PropertyInfo propertyInfo = (PropertyInfo)member;
					MethodInfo setMethod = JSProperty.GetSetMethod(propertyInfo, nonPublic: false);
					JSWrappedMethod jSWrappedMethod = setMethod as JSWrappedMethod;
					if (jSWrappedMethod == null || !(jSWrappedMethod.GetWrappedObject() is GlobalObject))
					{
						setMethod = GetMethodInfoMetadata(setMethod);
						rhvalue?.TranslateToIL(il, propertyInfo.PropertyType);
						if (setMethod.IsVirtual && !setMethod.IsFinal && (!setMethod.ReflectedType.IsSealed || !setMethod.ReflectedType.IsValueType))
						{
							il.Emit(OpCodes.Callvirt, setMethod);
						}
						else
						{
							il.Emit(OpCodes.Call, setMethod);
						}
						return;
					}
				}
				base.TranslateToILSet(il, rhvalue);
			}
			else if (member is FieldInfo)
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				rhvalue?.TranslateToIL(il, fieldInfo.FieldType);
				if (fieldInfo.IsLiteral || fieldInfo.IsInitOnly)
				{
					il.Emit(OpCodes.Pop);
					return;
				}
				object obj = ((fieldInfo is JSField) ? ((JSField)fieldInfo).GetMetaData() : ((fieldInfo is JSFieldInfo) ? ((JSFieldInfo)fieldInfo).field : fieldInfo));
				FieldInfo fieldInfo2 = obj as FieldInfo;
				if (fieldInfo2 != null)
				{
					il.Emit(fieldInfo2.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fieldInfo2);
				}
				else if (obj is LocalBuilder)
				{
					il.Emit(OpCodes.Stloc, (LocalBuilder)obj);
				}
				else
				{
					il.Emit(OpCodes.Starg, (short)obj);
				}
			}
			else if (member is PropertyInfo)
			{
				PropertyInfo propertyInfo2 = (PropertyInfo)member;
				rhvalue?.TranslateToIL(il, propertyInfo2.PropertyType);
				MethodInfo setMethod2 = JSProperty.GetSetMethod(propertyInfo2, nonPublic: true);
				if (setMethod2 == null)
				{
					il.Emit(OpCodes.Pop);
					return;
				}
				setMethod2 = GetMethodInfoMetadata(setMethod2);
				if (setMethod2.IsStatic && !(setMethod2 is JSClosureMethod))
				{
					il.Emit(OpCodes.Call, setMethod2);
				}
				else if (!isNonVirtual && setMethod2.IsVirtual && !setMethod2.IsFinal && (!setMethod2.ReflectedType.IsSealed || !setMethod2.ReflectedType.IsValueType))
				{
					il.Emit(OpCodes.Callvirt, setMethod2);
				}
				else
				{
					il.Emit(OpCodes.Call, setMethod2);
				}
			}
			else
			{
				object obj2 = TranslateToSpeculativeEarlyBoundSet(il, rhvalue);
				rhvalue?.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.setValueMethod);
				if (obj2 != null)
				{
					il.MarkLabel((Label)obj2);
				}
			}
		}

		/// <summary>When overridden in a derived class, generates Microsoft intermediate language (MSIL) code for the binding reference. If necessary, copies the current topmost value on the evaluation stack and then pushes the copy onto the evaluation stack.</summary>
		/// <param name="il">An object that generates Microsoft intermediate language (MSIL) instructions.</param>
		protected abstract void TranslateToILWithDupOfThisOb(ILGenerator il);

		private static void TranslateToLdelem(ILGenerator il, Type etype)
		{
			switch (Type.GetTypeCode(etype))
			{
			case TypeCode.SByte:
				il.Emit(OpCodes.Ldelem_I1);
				break;
			case TypeCode.Boolean:
			case TypeCode.Byte:
				il.Emit(OpCodes.Ldelem_U1);
				break;
			case TypeCode.Int16:
				il.Emit(OpCodes.Ldelem_I2);
				break;
			case TypeCode.Char:
			case TypeCode.UInt16:
				il.Emit(OpCodes.Ldelem_U2);
				break;
			case TypeCode.Int32:
				il.Emit(OpCodes.Ldelem_I4);
				break;
			case TypeCode.UInt32:
				il.Emit(OpCodes.Ldelem_U4);
				break;
			case TypeCode.Int64:
			case TypeCode.UInt64:
				il.Emit(OpCodes.Ldelem_I8);
				break;
			case TypeCode.Single:
				il.Emit(OpCodes.Ldelem_R4);
				break;
			case TypeCode.Double:
				il.Emit(OpCodes.Ldelem_R8);
				break;
			case TypeCode.Object:
			case TypeCode.Decimal:
			case TypeCode.DateTime:
			case TypeCode.String:
				if (etype.IsValueType)
				{
					il.Emit(OpCodes.Ldelema, etype);
					il.Emit(OpCodes.Ldobj, etype);
				}
				else
				{
					il.Emit(OpCodes.Ldelem_Ref);
				}
				break;
			case TypeCode.DBNull:
			case (TypeCode)17:
				break;
			}
		}

		private object TranslateToSpeculativeEarlyBoundSet(ILGenerator il, AST rhvalue)
		{
			giveErrors = false;
			object obj = null;
			bool flag = true;
			LocalBuilder local = null;
			LocalBuilder localBuilder = null;
			Label label = il.DefineLabel();
			MemberInfoList allKnownInstanceBindingsForThisName = GetAllKnownInstanceBindingsForThisName();
			int i = 0;
			for (int count = allKnownInstanceBindingsForThisName.count; i < count; i++)
			{
				MemberInfo memberInfo = allKnownInstanceBindingsForThisName[i];
				FieldInfo fieldInfo = null;
				MethodInfo method = null;
				PropertyInfo propertyInfo = null;
				if (memberInfo is FieldInfo)
				{
					fieldInfo = (FieldInfo)memberInfo;
					if (fieldInfo.IsLiteral || fieldInfo.IsInitOnly)
					{
						continue;
					}
				}
				else
				{
					if (!(memberInfo is PropertyInfo))
					{
						continue;
					}
					propertyInfo = (PropertyInfo)memberInfo;
					if (propertyInfo.GetIndexParameters().Length != 0 || (method = JSProperty.GetSetMethod(propertyInfo, nonPublic: true)) == null)
					{
						continue;
					}
				}
				member = memberInfo;
				if (!Accessible(checkSetter: true))
				{
					continue;
				}
				if (flag)
				{
					flag = false;
					if (rhvalue == null)
					{
						localBuilder = il.DeclareLocal(Typeob.Object);
						il.Emit(OpCodes.Stloc, localBuilder);
					}
					il.Emit(OpCodes.Dup);
					il.Emit(OpCodes.Ldfld, CompilerGlobals.objectField);
					local = il.DeclareLocal(Typeob.Object);
					il.Emit(OpCodes.Stloc, local);
					obj = il.DefineLabel();
				}
				Type declaringType = memberInfo.DeclaringType;
				il.Emit(OpCodes.Ldloc, local);
				il.Emit(OpCodes.Isinst, declaringType);
				LocalBuilder local2 = il.DeclareLocal(declaringType);
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Stloc, local2);
				il.Emit(OpCodes.Brfalse, label);
				il.Emit(OpCodes.Ldloc, local2);
				if (rhvalue == null)
				{
					il.Emit(OpCodes.Ldloc, localBuilder);
				}
				if (fieldInfo != null)
				{
					if (rhvalue == null)
					{
						Convert.Emit(this, il, Typeob.Object, fieldInfo.FieldType);
					}
					else
					{
						rhvalue.TranslateToIL(il, fieldInfo.FieldType);
					}
					if (fieldInfo is JSField)
					{
						il.Emit(OpCodes.Stfld, (FieldInfo)((JSField)fieldInfo).GetMetaData());
					}
					else if (fieldInfo is JSFieldInfo)
					{
						il.Emit(OpCodes.Stfld, ((JSFieldInfo)fieldInfo).field);
					}
					else
					{
						il.Emit(OpCodes.Stfld, fieldInfo);
					}
				}
				else
				{
					if (rhvalue == null)
					{
						Convert.Emit(this, il, Typeob.Object, propertyInfo.PropertyType);
					}
					else
					{
						rhvalue.TranslateToIL(il, propertyInfo.PropertyType);
					}
					method = GetMethodInfoMetadata(method);
					if (method.IsVirtual && !method.IsFinal && (!declaringType.IsSealed || !declaringType.IsValueType))
					{
						il.Emit(OpCodes.Callvirt, method);
					}
					else
					{
						il.Emit(OpCodes.Call, method);
					}
				}
				il.Emit(OpCodes.Pop);
				il.Emit(OpCodes.Br, (Label)obj);
				il.MarkLabel(label);
				label = il.DefineLabel();
			}
			if (localBuilder != null)
			{
				il.Emit(OpCodes.Ldloc, localBuilder);
			}
			member = null;
			return obj;
		}

		private object TranslateToSpeculativeEarlyBindings(ILGenerator il, Type rtype, bool getObjectFromLateBindingInstance)
		{
			giveErrors = false;
			object obj = null;
			bool flag = true;
			LocalBuilder local = null;
			Label label = il.DefineLabel();
			MemberInfoList allKnownInstanceBindingsForThisName = GetAllKnownInstanceBindingsForThisName();
			int i = 0;
			for (int count = allKnownInstanceBindingsForThisName.count; i < count; i++)
			{
				MemberInfo memberInfo = allKnownInstanceBindingsForThisName[i];
				if (!(memberInfo is FieldInfo) && (!(memberInfo is PropertyInfo) || ((PropertyInfo)memberInfo).GetIndexParameters().Length != 0 || JSProperty.GetGetMethod((PropertyInfo)memberInfo, nonPublic: true) == null))
				{
					continue;
				}
				member = memberInfo;
				if (!Accessible(checkSetter: false))
				{
					continue;
				}
				if (flag)
				{
					flag = false;
					if (getObjectFromLateBindingInstance)
					{
						il.Emit(OpCodes.Dup);
						il.Emit(OpCodes.Ldfld, CompilerGlobals.objectField);
					}
					else
					{
						TranslateToILObject(il, Typeob.Object, noValue: false);
					}
					local = il.DeclareLocal(Typeob.Object);
					il.Emit(OpCodes.Stloc, local);
					obj = il.DefineLabel();
				}
				Type declaringType = memberInfo.DeclaringType;
				il.Emit(OpCodes.Ldloc, local);
				il.Emit(OpCodes.Isinst, declaringType);
				LocalBuilder local2 = il.DeclareLocal(declaringType);
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Stloc, local2);
				il.Emit(OpCodes.Brfalse_S, label);
				il.Emit(OpCodes.Ldloc, local2);
				if (memberInfo is FieldInfo)
				{
					FieldInfo fieldInfo = (FieldInfo)memberInfo;
					if (fieldInfo.IsLiteral)
					{
						il.Emit(OpCodes.Pop);
						continue;
					}
					if (fieldInfo is JSField)
					{
						il.Emit(OpCodes.Ldfld, (FieldInfo)((JSField)fieldInfo).GetMetaData());
					}
					else if (fieldInfo is JSFieldInfo)
					{
						il.Emit(OpCodes.Ldfld, ((JSFieldInfo)fieldInfo).field);
					}
					else
					{
						il.Emit(OpCodes.Ldfld, fieldInfo);
					}
					Convert.Emit(this, il, fieldInfo.FieldType, rtype);
				}
				else if (memberInfo is PropertyInfo)
				{
					MethodInfo getMethod = JSProperty.GetGetMethod((PropertyInfo)memberInfo, nonPublic: true);
					getMethod = GetMethodInfoMetadata(getMethod);
					if (getMethod.IsVirtual && !getMethod.IsFinal && (!declaringType.IsSealed || declaringType.IsValueType))
					{
						il.Emit(OpCodes.Callvirt, getMethod);
					}
					else
					{
						il.Emit(OpCodes.Call, getMethod);
					}
					Convert.Emit(this, il, getMethod.ReturnType, rtype);
				}
				il.Emit(OpCodes.Br, (Label)obj);
				il.MarkLabel(label);
				label = il.DefineLabel();
			}
			il.MarkLabel(label);
			if (!flag && !getObjectFromLateBindingInstance)
			{
				il.Emit(OpCodes.Ldloc, local);
			}
			member = null;
			return obj;
		}

		private object TranslateToSpeculativeEarlyBoundCalls(ILGenerator il, Type rtype, ASTList argList, bool construct, bool brackets)
		{
			giveErrors = false;
			object obj = null;
			bool flag = true;
			LocalBuilder local = null;
			Label label = il.DefineLabel();
			IReflect[] allEligibleClasses = GetAllEligibleClasses();
			if (construct)
			{
				return obj;
			}
			IReflect[] array = allEligibleClasses;
			foreach (IReflect reflect in array)
			{
				MemberInfo[] match = reflect.GetMember(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				try
				{
					MemberInfo memberInfo = JSBinder.SelectCallableMember(match, argIRs);
					MethodInfo methodInfo;
					if (memberInfo != null && memberInfo.MemberType == MemberTypes.Property)
					{
						methodInfo = ((PropertyInfo)memberInfo).GetGetMethod(nonPublic: true);
						ParameterInfo[] parameters;
						if (!(methodInfo == null) && (parameters = methodInfo.GetParameters()) != null && parameters.Length != 0)
						{
							goto IL_00a2;
						}
						continue;
					}
					methodInfo = memberInfo as MethodInfo;
					goto IL_00a2;
					IL_014a:
					member = methodInfo;
					if (Accessible(checkSetter: false))
					{
						if (flag)
						{
							flag = false;
							TranslateToILObject(il, Typeob.Object, noValue: false);
							local = il.DeclareLocal(Typeob.Object);
							il.Emit(OpCodes.Stloc, local);
							obj = il.DefineLabel();
						}
						Type declaringType = methodInfo.DeclaringType;
						il.Emit(OpCodes.Ldloc, local);
						il.Emit(OpCodes.Isinst, declaringType);
						LocalBuilder local2 = il.DeclareLocal(declaringType);
						il.Emit(OpCodes.Dup);
						il.Emit(OpCodes.Stloc, local2);
						il.Emit(OpCodes.Brfalse, label);
						il.Emit(OpCodes.Ldloc, local2);
						PlaceArgumentsOnStack(il, methodInfo.GetParameters(), argList, 0, 0, ReflectionMissingCW);
						methodInfo = GetMethodInfoMetadata(methodInfo);
						if (methodInfo.IsVirtual && !methodInfo.IsFinal && (!declaringType.IsSealed || declaringType.IsValueType))
						{
							il.Emit(OpCodes.Callvirt, methodInfo);
						}
						else
						{
							il.Emit(OpCodes.Call, methodInfo);
						}
						Convert.Emit(this, il, methodInfo.ReturnType, rtype);
						il.Emit(OpCodes.Br, (Label)obj);
						il.MarkLabel(label);
						label = il.DefineLabel();
					}
					goto end_IL_0046;
					IL_00a2:
					if (!(methodInfo != null) || !CheckParameters(methodInfo.GetParameters(), argIRs, argList, context, 0, defaultIsUndefined: true, reportError: false))
					{
						continue;
					}
					if (methodInfo is JSFieldMethod)
					{
						FunctionObject func = ((JSFieldMethod)methodInfo).func;
						if (func == null || (func.attributes & MethodAttributes.VtableLayoutMask) != 0 || !((ClassScope)reflect).ParentIsInSamePackage())
						{
							goto IL_014a;
						}
					}
					else if (!(methodInfo is JSWrappedMethod) || !(((JSWrappedMethod)methodInfo).obj is ClassScope) || ((JSWrappedMethod)methodInfo).GetPackage() != ((ClassScope)reflect).package)
					{
						goto IL_014a;
					}
					end_IL_0046:;
				}
				catch (AmbiguousMatchException)
				{
				}
			}
			il.MarkLabel(label);
			if (!flag)
			{
				il.Emit(OpCodes.Ldloc, local);
			}
			member = null;
			return obj;
		}

		internal static void TranslateToStelem(ILGenerator il, Type etype)
		{
			switch (Type.GetTypeCode(etype))
			{
			case TypeCode.Boolean:
			case TypeCode.SByte:
			case TypeCode.Byte:
				il.Emit(OpCodes.Stelem_I1);
				break;
			case TypeCode.Char:
			case TypeCode.Int16:
			case TypeCode.UInt16:
				il.Emit(OpCodes.Stelem_I2);
				break;
			case TypeCode.Int32:
			case TypeCode.UInt32:
				il.Emit(OpCodes.Stelem_I4);
				break;
			case TypeCode.Int64:
			case TypeCode.UInt64:
				il.Emit(OpCodes.Stelem_I8);
				break;
			case TypeCode.Single:
				il.Emit(OpCodes.Stelem_R4);
				break;
			case TypeCode.Double:
				il.Emit(OpCodes.Stelem_R8);
				break;
			case TypeCode.Object:
			case TypeCode.Decimal:
			case TypeCode.DateTime:
			case TypeCode.String:
				if (etype.IsValueType)
				{
					il.Emit(OpCodes.Stobj, etype);
				}
				else
				{
					il.Emit(OpCodes.Stelem_Ref);
				}
				break;
			case TypeCode.DBNull:
			case (TypeCode)17:
				break;
			}
		}

		private void WarnIfNotFullyResolved()
		{
			if (isFullyResolved || member == null || (member is JSVariableField && ((JSVariableField)member).type == null) || (!base.Engine.doFast && member is IWrappedMember))
			{
				return;
			}
			for (ScriptObject scriptObject = base.Globals.ScopeStack.Peek(); scriptObject != null; scriptObject = scriptObject.GetParent())
			{
				if (scriptObject is WithObject && !((WithObject)scriptObject).isKnownAtCompileTime)
				{
					context.HandleError(JSError.AmbiguousBindingBecauseOfWith);
					break;
				}
				if (scriptObject is ActivationObject && !((ActivationObject)scriptObject).isKnownAtCompileTime)
				{
					context.HandleError(JSError.AmbiguousBindingBecauseOfEval);
					break;
				}
			}
		}

		private void WarnIfObsolete()
		{
			WarnIfObsolete(member, context);
		}

		internal static void WarnIfObsolete(MemberInfo member, Context context)
		{
			if (member == null)
			{
				return;
			}
			string text = null;
			bool flag = false;
			object[] customAttributes = CustomAttribute.GetCustomAttributes(member, typeof(ObsoleteAttribute), inherit: false);
			if (customAttributes != null && customAttributes.Length != 0)
			{
				ObsoleteAttribute obsoleteAttribute = (ObsoleteAttribute)customAttributes[0];
				text = obsoleteAttribute.Message;
				flag = obsoleteAttribute.IsError;
			}
			else
			{
				customAttributes = CustomAttribute.GetCustomAttributes(member, typeof(NotRecommended), inherit: false);
				if (customAttributes == null || customAttributes.Length == 0)
				{
					return;
				}
				NotRecommended notRecommended = (NotRecommended)customAttributes[0];
				text = ": " + notRecommended.Message;
				flag = false;
			}
			context.HandleError(JSError.Deprecated, text, flag);
		}

		private MethodInfo GetMethodInfoMetadata(MethodInfo method)
		{
			if (method is JSMethod)
			{
				return ((JSMethod)method).GetMethodInfo(base.compilerGlobals);
			}
			if (method is JSMethodInfo)
			{
				return ((JSMethodInfo)method).method;
			}
			return method;
		}
	}
	/// <summary>Performs bitwise binary operations. This class belongs to the abstract syntax tree category.</summary>
	public sealed class BitwiseBinary : BinaryOp
	{
		private object metaData;

		internal BitwiseBinary(Context context, AST operand1, AST operand2, JSToken operatorTok)
			: base(context, operand1, operand2, operatorTok)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.BitwiseBinary" /> class.</summary>
		/// <param name="operatorTok">One of the <see cref="T:Microsoft.JScript.JSToken" /> enumeration values. Specifies the operation to perform.</param>
		public BitwiseBinary(int operatorTok)
			: base(null, null, null, (JSToken)operatorTok)
		{
		}

		internal override object Evaluate()
		{
			return EvaluateBitwiseBinary(operand1.Evaluate(), operand2.Evaluate());
		}

		/// <summary>Performs a bitwise binary operation.</summary>
		/// <param name="v1">The first operand.</param>
		/// <param name="v2">The second operand.</param>
		/// <returns>The result of the operation.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public object EvaluateBitwiseBinary(object v1, object v2)
		{
			if (v1 is int && v2 is int)
			{
				return DoOp((int)v1, (int)v2, operatorTok);
			}
			return EvaluateBitwiseBinary(v1, v2, operatorTok);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		private object EvaluateBitwiseBinary(object v1, object v2, JSToken operatorTok)
		{
			IConvertible iConvertible = Convert.GetIConvertible(v1);
			IConvertible iConvertible2 = Convert.GetIConvertible(v2);
			TypeCode typeCode = Convert.GetTypeCode(v1, iConvertible);
			TypeCode typeCode2 = Convert.GetTypeCode(v2, iConvertible2);
			switch (typeCode)
			{
			case TypeCode.Empty:
			case TypeCode.DBNull:
				return EvaluateBitwiseBinary(0, v2, operatorTok);
			case TypeCode.Boolean:
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			{
				int i = iConvertible.ToInt32(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
				case TypeCode.DBNull:
					return DoOp(i, 0, operatorTok);
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
					return DoOp(i, iConvertible2.ToInt32(null), operatorTok);
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
					return DoOp(i, (int)Runtime.DoubleToInt64(iConvertible2.ToDouble(null)), operatorTok);
				}
				break;
			}
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
			{
				int i = (int)Runtime.DoubleToInt64(iConvertible.ToDouble(null));
				switch (typeCode2)
				{
				case TypeCode.Empty:
				case TypeCode.DBNull:
					return DoOp(i, 0, operatorTok);
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
					return DoOp(i, iConvertible2.ToInt32(null), operatorTok);
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
					return DoOp(i, (int)Runtime.DoubleToInt64(iConvertible2.ToDouble(null)), operatorTok);
				}
				break;
			}
			}
			if (v2 == null)
			{
				return DoOp(Convert.ToInt32(v1), 0, base.operatorTok);
			}
			MethodInfo @operator = GetOperator(v1.GetType(), v2.GetType());
			if (@operator != null)
			{
				return @operator.Invoke(null, BindingFlags.Default, JSBinder.ob, new object[2] { v1, v2 }, null);
			}
			return DoOp(Convert.ToInt32(v1), Convert.ToInt32(v2), base.operatorTok);
		}

		internal static object DoOp(int i, int j, JSToken operatorTok)
		{
			return operatorTok switch
			{
				JSToken.BitwiseAnd => i & j, 
				JSToken.BitwiseOr => i | j, 
				JSToken.BitwiseXor => i ^ j, 
				JSToken.LeftShift => i << j, 
				JSToken.RightShift => i >> j, 
				JSToken.UnsignedRightShift => (uint)i >> j, 
				_ => throw new JScriptException(JSError.InternalError), 
			};
		}

		internal override IReflect InferType(JSField inference_target)
		{
			MethodInfo methodInfo = ((!(type1 == null) && !(inference_target != null)) ? GetOperator(type1, type2) : GetOperator(operand1.InferType(inference_target), operand2.InferType(inference_target)));
			if (methodInfo != null)
			{
				metaData = methodInfo;
				return methodInfo.ReturnType;
			}
			return ResultType(type1, type2, operatorTok);
		}

		internal static Type Operand2Type(JSToken operatorTok, Type bbrType)
		{
			if ((uint)(operatorTok - 61) <= 2u)
			{
				return Typeob.Int32;
			}
			return bbrType;
		}

		internal static Type ResultType(Type type1, Type type2, JSToken operatorTok)
		{
			switch (operatorTok)
			{
			case JSToken.LeftShift:
			case JSToken.RightShift:
				if (Convert.IsPrimitiveIntegerType(type1))
				{
					return type1;
				}
				if (Typeob.JSObject.IsAssignableFrom(type1))
				{
					return Typeob.Int32;
				}
				return Typeob.Object;
			case JSToken.UnsignedRightShift:
				switch (Type.GetTypeCode(type1))
				{
				case TypeCode.SByte:
				case TypeCode.Byte:
					return Typeob.Byte;
				case TypeCode.Int16:
				case TypeCode.UInt16:
					return Typeob.UInt16;
				case TypeCode.Int32:
				case TypeCode.UInt32:
					return Typeob.UInt32;
				case TypeCode.Int64:
				case TypeCode.UInt64:
					return Typeob.UInt64;
				default:
					if (Typeob.JSObject.IsAssignableFrom(type1))
					{
						return Typeob.Int32;
					}
					return Typeob.Object;
				}
			default:
			{
				TypeCode typeCode = Type.GetTypeCode(type1);
				TypeCode typeCode2 = Type.GetTypeCode(type2);
				switch (typeCode)
				{
				case TypeCode.Empty:
				case TypeCode.DBNull:
				case TypeCode.Boolean:
					switch (typeCode2)
					{
					case TypeCode.SByte:
						return Typeob.SByte;
					case TypeCode.Byte:
						return Typeob.Byte;
					case TypeCode.Char:
					case TypeCode.UInt16:
						return Typeob.UInt16;
					case TypeCode.Int16:
						return Typeob.Int16;
					case TypeCode.Empty:
					case TypeCode.DBNull:
					case TypeCode.Boolean:
					case TypeCode.Int32:
					case TypeCode.Single:
					case TypeCode.Double:
						return Typeob.Int32;
					case TypeCode.UInt32:
						return Typeob.UInt32;
					case TypeCode.Int64:
						return Typeob.Int64;
					case TypeCode.UInt64:
						return Typeob.UInt64;
					case TypeCode.Object:
						if (Typeob.JSObject.IsAssignableFrom(type2))
						{
							return Typeob.Int32;
						}
						break;
					}
					break;
				case TypeCode.SByte:
					switch (typeCode2)
					{
					case TypeCode.Empty:
					case TypeCode.DBNull:
					case TypeCode.Boolean:
					case TypeCode.SByte:
						return Typeob.SByte;
					case TypeCode.Byte:
						return Typeob.Byte;
					case TypeCode.Char:
					case TypeCode.Int16:
						return Typeob.Int16;
					case TypeCode.UInt16:
						return Typeob.UInt16;
					case TypeCode.Int32:
					case TypeCode.Single:
					case TypeCode.Double:
						return Typeob.Int32;
					case TypeCode.UInt32:
						return Typeob.UInt32;
					case TypeCode.Int64:
						return Typeob.Int64;
					case TypeCode.UInt64:
						return Typeob.UInt64;
					case TypeCode.Object:
						if (Typeob.JSObject.IsAssignableFrom(type2))
						{
							return Typeob.Int32;
						}
						break;
					}
					break;
				case TypeCode.Byte:
					switch (typeCode2)
					{
					case TypeCode.Empty:
					case TypeCode.DBNull:
					case TypeCode.Boolean:
					case TypeCode.SByte:
					case TypeCode.Byte:
						return Typeob.Byte;
					case TypeCode.Char:
					case TypeCode.Int16:
					case TypeCode.UInt16:
						return Typeob.UInt16;
					case TypeCode.Int32:
					case TypeCode.UInt32:
					case TypeCode.Single:
					case TypeCode.Double:
						return Typeob.UInt32;
					case TypeCode.Int64:
					case TypeCode.UInt64:
						return Typeob.UInt64;
					case TypeCode.Object:
						if (Typeob.JSObject.IsAssignableFrom(type2))
						{
							return Typeob.UInt32;
						}
						break;
					}
					break;
				case TypeCode.Int16:
					switch (typeCode2)
					{
					case TypeCode.Empty:
					case TypeCode.DBNull:
					case TypeCode.Boolean:
					case TypeCode.SByte:
					case TypeCode.Int16:
						return Typeob.Int16;
					case TypeCode.Char:
					case TypeCode.Byte:
					case TypeCode.UInt16:
						return Typeob.UInt16;
					case TypeCode.Int32:
					case TypeCode.Single:
					case TypeCode.Double:
						return Typeob.Int32;
					case TypeCode.UInt32:
						return Typeob.UInt32;
					case TypeCode.Int64:
						return Typeob.Int64;
					case TypeCode.UInt64:
						return Typeob.UInt64;
					case TypeCode.Object:
						if (Typeob.JSObject.IsAssignableFrom(type2))
						{
							return Typeob.Int32;
						}
						break;
					}
					break;
				case TypeCode.Char:
				case TypeCode.UInt16:
					switch (typeCode2)
					{
					case TypeCode.Empty:
					case TypeCode.DBNull:
					case TypeCode.Boolean:
					case TypeCode.Char:
					case TypeCode.SByte:
					case TypeCode.Byte:
					case TypeCode.Int16:
					case TypeCode.UInt16:
						return Typeob.UInt16;
					case TypeCode.Int32:
					case TypeCode.UInt32:
					case TypeCode.Single:
					case TypeCode.Double:
						return Typeob.UInt32;
					case TypeCode.Int64:
					case TypeCode.UInt64:
						return Typeob.UInt64;
					case TypeCode.Object:
						if (Typeob.JSObject.IsAssignableFrom(type2))
						{
							return Typeob.UInt32;
						}
						break;
					}
					break;
				case TypeCode.Int32:
				case TypeCode.Single:
				case TypeCode.Double:
					switch (typeCode2)
					{
					case TypeCode.Empty:
					case TypeCode.DBNull:
					case TypeCode.Boolean:
					case TypeCode.SByte:
					case TypeCode.Int16:
					case TypeCode.Int32:
					case TypeCode.Single:
					case TypeCode.Double:
						return Typeob.Int32;
					case TypeCode.Char:
					case TypeCode.Byte:
					case TypeCode.UInt16:
					case TypeCode.UInt32:
						return Typeob.UInt32;
					case TypeCode.Int64:
						return Typeob.Int64;
					case TypeCode.UInt64:
						return Typeob.UInt64;
					case TypeCode.Object:
						if (Typeob.JSObject.IsAssignableFrom(type2))
						{
							return Typeob.Int32;
						}
						break;
					}
					break;
				case TypeCode.UInt32:
					switch (typeCode2)
					{
					case TypeCode.Empty:
					case TypeCode.DBNull:
					case TypeCode.Boolean:
					case TypeCode.Char:
					case TypeCode.SByte:
					case TypeCode.Byte:
					case TypeCode.Int16:
					case TypeCode.UInt16:
					case TypeCode.Int32:
					case TypeCode.UInt32:
					case TypeCode.Single:
					case TypeCode.Double:
						return Typeob.UInt32;
					case TypeCode.Int64:
					case TypeCode.UInt64:
						return Typeob.UInt64;
					case TypeCode.Object:
						if (Typeob.JSObject.IsAssignableFrom(type2))
						{
							return Typeob.UInt32;
						}
						break;
					}
					break;
				case TypeCode.Int64:
					switch (typeCode2)
					{
					case TypeCode.Empty:
					case TypeCode.DBNull:
					case TypeCode.Boolean:
					case TypeCode.SByte:
					case TypeCode.Int16:
					case TypeCode.Int32:
					case TypeCode.Int64:
					case TypeCode.Single:
					case TypeCode.Double:
						return Typeob.Int64;
					case TypeCode.Char:
					case TypeCode.Byte:
					case TypeCode.UInt16:
					case TypeCode.UInt32:
					case TypeCode.UInt64:
						return Typeob.UInt64;
					case TypeCode.Object:
						if (Typeob.JSObject.IsAssignableFrom(type2))
						{
							return Typeob.Int64;
						}
						break;
					}
					break;
				case TypeCode.UInt64:
					switch (typeCode2)
					{
					case TypeCode.Empty:
					case TypeCode.DBNull:
					case TypeCode.Boolean:
					case TypeCode.Char:
					case TypeCode.SByte:
					case TypeCode.Byte:
					case TypeCode.Int16:
					case TypeCode.UInt16:
					case TypeCode.Int32:
					case TypeCode.UInt32:
					case TypeCode.Int64:
					case TypeCode.UInt64:
					case TypeCode.Single:
					case TypeCode.Double:
						return Typeob.UInt64;
					case TypeCode.Object:
						if (Typeob.JSObject.IsAssignableFrom(type2))
						{
							return Typeob.UInt64;
						}
						break;
					}
					break;
				case TypeCode.Object:
					if (Typeob.JSObject.IsAssignableFrom(type1))
					{
						return Typeob.Int32;
					}
					break;
				}
				return Typeob.Object;
			}
			}
		}

		internal static void TranslateToBitCountMask(ILGenerator il, Type type, AST operand2)
		{
			int num = 0;
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.SByte:
			case TypeCode.Byte:
				num = 7;
				break;
			case TypeCode.Int16:
			case TypeCode.UInt16:
				num = 15;
				break;
			case TypeCode.Int32:
			case TypeCode.UInt32:
				num = 31;
				break;
			case TypeCode.Int64:
			case TypeCode.UInt64:
				num = 63;
				break;
			}
			if (operand2 is ConstantWrapper constantWrapper)
			{
				int num2 = Convert.ToInt32(constantWrapper.value);
				if (num2 <= num)
				{
					return;
				}
			}
			il.Emit(OpCodes.Ldc_I4_S, num);
			il.Emit(OpCodes.And);
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (metaData == null)
			{
				Type type = ResultType(type1, type2, operatorTok);
				if (Convert.IsPrimitiveNumericType(type1))
				{
					operand1.TranslateToIL(il, type1);
					Convert.Emit(this, il, type1, type, truncationPermitted: true);
				}
				else
				{
					operand1.TranslateToIL(il, Typeob.Double);
					Convert.Emit(this, il, Typeob.Double, type, truncationPermitted: true);
				}
				Type target_type = Operand2Type(operatorTok, type);
				if (Convert.IsPrimitiveNumericType(type2))
				{
					operand2.TranslateToIL(il, type2);
					Convert.Emit(this, il, type2, target_type, truncationPermitted: true);
				}
				else
				{
					operand2.TranslateToIL(il, Typeob.Double);
					Convert.Emit(this, il, Typeob.Double, target_type, truncationPermitted: true);
				}
				switch (operatorTok)
				{
				case JSToken.BitwiseAnd:
					il.Emit(OpCodes.And);
					break;
				case JSToken.BitwiseOr:
					il.Emit(OpCodes.Or);
					break;
				case JSToken.BitwiseXor:
					il.Emit(OpCodes.Xor);
					break;
				case JSToken.LeftShift:
					TranslateToBitCountMask(il, type, operand2);
					il.Emit(OpCodes.Shl);
					break;
				case JSToken.RightShift:
					TranslateToBitCountMask(il, type, operand2);
					il.Emit(OpCodes.Shr);
					break;
				case JSToken.UnsignedRightShift:
					TranslateToBitCountMask(il, type, operand2);
					il.Emit(OpCodes.Shr_Un);
					break;
				default:
					throw new JScriptException(JSError.InternalError, context);
				}
				Convert.Emit(this, il, type, rtype);
			}
			else if (metaData is MethodInfo)
			{
				MethodInfo methodInfo = (MethodInfo)metaData;
				ParameterInfo[] parameters = methodInfo.GetParameters();
				operand1.TranslateToIL(il, parameters[0].ParameterType);
				operand2.TranslateToIL(il, parameters[1].ParameterType);
				il.Emit(OpCodes.Call, methodInfo);
				Convert.Emit(this, il, methodInfo.ReturnType, rtype);
			}
			else
			{
				il.Emit(OpCodes.Ldloc, (LocalBuilder)metaData);
				operand1.TranslateToIL(il, Typeob.Object);
				operand2.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.evaluateBitwiseBinaryMethod);
				Convert.Emit(this, il, Typeob.Object, rtype);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			IReflect reflect = InferType(null);
			operand1.TranslateToILInitializer(il);
			operand2.TranslateToILInitializer(il);
			if (reflect == Typeob.Object)
			{
				metaData = il.DeclareLocal(Typeob.BitwiseBinary);
				ConstantWrapper.TranslateToILInt(il, (int)operatorTok);
				il.Emit(OpCodes.Newobj, CompilerGlobals.bitwiseBinaryConstructor);
				il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
			}
		}
	}
	internal sealed class BitwiseBinaryAssign : BinaryOp
	{
		private BitwiseBinary binOp;

		private object metaData;

		internal BitwiseBinaryAssign(Context context, AST operand1, AST operand2, JSToken operatorTok)
			: base(context, operand1, operand2, operatorTok)
		{
			binOp = new BitwiseBinary(context, operand1, operand2, operatorTok);
			metaData = null;
		}

		internal override object Evaluate()
		{
			object v = operand1.Evaluate();
			object v2 = operand2.Evaluate();
			object obj = binOp.EvaluateBitwiseBinary(v, v2);
			try
			{
				operand1.SetValue(obj);
				return obj;
			}
			catch (JScriptException ex)
			{
				if (ex.context == null)
				{
					ex.context = context;
				}
				throw ex;
			}
			catch (Exception e)
			{
				throw new JScriptException(e, context);
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			MethodInfo methodInfo = ((!(type1 == null)) ? GetOperator(type1, type2) : GetOperator(operand1.InferType(inference_target), operand2.InferType(inference_target)));
			if (methodInfo != null)
			{
				metaData = methodInfo;
				return methodInfo.ReturnType;
			}
			if ((type1.IsPrimitive || Typeob.JSObject.IsAssignableFrom(type1)) && (type2.IsPrimitive || Typeob.JSObject.IsAssignableFrom(type2)))
			{
				return Typeob.Int32;
			}
			return Typeob.Object;
		}

		internal override AST PartiallyEvaluate()
		{
			operand1 = operand1.PartiallyEvaluateAsReference();
			operand2 = operand2.PartiallyEvaluate();
			binOp = new BitwiseBinary(context, operand1, operand2, operatorTok);
			operand1.SetPartialValue(binOp);
			return this;
		}

		private void TranslateToILForNoOverloadCase(ILGenerator il, Type rtype)
		{
			Type type = Convert.ToType(operand1.InferType(null));
			Type type2 = Convert.ToType(operand2.InferType(null));
			Type type3 = BitwiseBinary.ResultType(type, type2, operatorTok);
			operand1.TranslateToILPreSetPlusGet(il);
			Convert.Emit(this, il, type, type3, truncationPermitted: true);
			operand2.TranslateToIL(il, type2);
			Convert.Emit(this, il, type2, BitwiseBinary.Operand2Type(operatorTok, type3), truncationPermitted: true);
			switch (operatorTok)
			{
			case JSToken.BitwiseAnd:
				il.Emit(OpCodes.And);
				break;
			case JSToken.BitwiseOr:
				il.Emit(OpCodes.Or);
				break;
			case JSToken.BitwiseXor:
				il.Emit(OpCodes.Xor);
				break;
			case JSToken.LeftShift:
				BitwiseBinary.TranslateToBitCountMask(il, type3, operand2);
				il.Emit(OpCodes.Shl);
				break;
			case JSToken.RightShift:
				BitwiseBinary.TranslateToBitCountMask(il, type3, operand2);
				il.Emit(OpCodes.Shr);
				break;
			case JSToken.UnsignedRightShift:
				BitwiseBinary.TranslateToBitCountMask(il, type3, operand2);
				il.Emit(OpCodes.Shr_Un);
				break;
			default:
				throw new JScriptException(JSError.InternalError, context);
			}
			if (rtype != Typeob.Void)
			{
				LocalBuilder local = il.DeclareLocal(type3);
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Stloc, local);
				Convert.Emit(this, il, type3, type);
				operand1.TranslateToILSet(il);
				il.Emit(OpCodes.Ldloc, local);
				Convert.Emit(this, il, type3, rtype);
			}
			else
			{
				Convert.Emit(this, il, type3, type);
				operand1.TranslateToILSet(il);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (metaData == null)
			{
				TranslateToILForNoOverloadCase(il, rtype);
			}
			else if (metaData is MethodInfo)
			{
				object obj = null;
				MethodInfo methodInfo = (MethodInfo)metaData;
				Type type = Convert.ToType(operand1.InferType(null));
				ParameterInfo[] parameters = methodInfo.GetParameters();
				operand1.TranslateToILPreSetPlusGet(il);
				Convert.Emit(this, il, type, parameters[0].ParameterType);
				operand2.TranslateToIL(il, parameters[1].ParameterType);
				il.Emit(OpCodes.Call, methodInfo);
				if (rtype != Typeob.Void)
				{
					obj = il.DeclareLocal(rtype);
					il.Emit(OpCodes.Dup);
					Convert.Emit(this, il, type, rtype);
					il.Emit(OpCodes.Stloc, (LocalBuilder)obj);
				}
				Convert.Emit(this, il, methodInfo.ReturnType, type);
				operand1.TranslateToILSet(il);
				if (rtype != Typeob.Void)
				{
					il.Emit(OpCodes.Ldloc, (LocalBuilder)obj);
				}
			}
			else
			{
				Type type2 = Convert.ToType(operand1.InferType(null));
				LocalBuilder local = il.DeclareLocal(Typeob.Object);
				operand1.TranslateToILPreSetPlusGet(il);
				Convert.Emit(this, il, type2, Typeob.Object);
				il.Emit(OpCodes.Stloc, local);
				il.Emit(OpCodes.Ldloc, (LocalBuilder)metaData);
				il.Emit(OpCodes.Ldloc, local);
				operand2.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.evaluateBitwiseBinaryMethod);
				if (rtype != Typeob.Void)
				{
					il.Emit(OpCodes.Dup);
					il.Emit(OpCodes.Stloc, local);
				}
				Convert.Emit(this, il, Typeob.Object, type2);
				operand1.TranslateToILSet(il);
				if (rtype != Typeob.Void)
				{
					il.Emit(OpCodes.Ldloc, local);
					Convert.Emit(this, il, Typeob.Object, rtype);
				}
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			IReflect reflect = InferType(null);
			operand1.TranslateToILInitializer(il);
			operand2.TranslateToILInitializer(il);
			if (reflect == Typeob.Object)
			{
				metaData = il.DeclareLocal(Typeob.BitwiseBinary);
				ConstantWrapper.TranslateToILInt(il, (int)operatorTok);
				il.Emit(OpCodes.Newobj, CompilerGlobals.bitwiseBinaryConstructor);
				il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
			}
		}
	}
	/// <summary>Represents a block in JScript. This class is used mainly by the <see cref="T:Microsoft.JScript.JSParser" /> to create <see cref="T:Microsoft.JScript.Block" /> objects when it parses code. This class belongs to the abstract syntax tree category.</summary>
	public sealed class Block : AST
	{
		private Completion completion;

		private ArrayList list;

		internal Block(Context context)
			: base(context)
		{
			completion = new Completion();
			list = new ArrayList();
		}

		internal void Append(AST elem)
		{
			list.Add(elem);
		}

		internal void ComplainAboutAnythingOtherThanClassOrPackage()
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				object obj = list[i];
				if (!(obj is Class) && !(obj is Package) && !(obj is Import) && (!(obj is Block block) || block.list.Count != 0) && (!(obj is Expression expression) || !(expression.operand is AssemblyCustomAttributeList)))
				{
					((AST)obj).context.HandleError(JSError.OnlyClassesAndPackagesAllowed);
					break;
				}
			}
		}

		internal override object Evaluate()
		{
			this.completion.Continue = 0;
			this.completion.Exit = 0;
			this.completion.value = null;
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				AST aST = (AST)list[i];
				object obj;
				try
				{
					obj = aST.Evaluate();
				}
				catch (JScriptException ex)
				{
					if (ex.context == null)
					{
						ex.context = aST.context;
					}
					throw ex;
				}
				Completion completion = (Completion)obj;
				if (completion.value != null)
				{
					this.completion.value = completion.value;
				}
				if (completion.Continue > 1)
				{
					this.completion.Continue = completion.Continue - 1;
					break;
				}
				if (completion.Exit > 0)
				{
					this.completion.Exit = completion.Exit - 1;
					break;
				}
				if (completion.Return)
				{
					return completion;
				}
			}
			return this.completion;
		}

		internal void EvaluateStaticVariableInitializers()
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				object obj = list[i];
				if (obj is VariableDeclaration variableDeclaration && variableDeclaration.field.IsStatic && !variableDeclaration.field.IsLiteral)
				{
					variableDeclaration.Evaluate();
				}
				else if (obj is StaticInitializer staticInitializer)
				{
					staticInitializer.Evaluate();
				}
				else if (obj is Class @class)
				{
					@class.Evaluate();
				}
				else if (obj is Constant constant && constant.field.IsStatic)
				{
					constant.Evaluate();
				}
				else if (obj is Block block)
				{
					block.EvaluateStaticVariableInitializers();
				}
			}
		}

		internal void EvaluateInstanceVariableInitializers()
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				object obj = list[i];
				if (obj is VariableDeclaration variableDeclaration && !variableDeclaration.field.IsStatic && !variableDeclaration.field.IsLiteral)
				{
					variableDeclaration.Evaluate();
				}
				else if (obj is Block block)
				{
					block.EvaluateInstanceVariableInitializers();
				}
			}
		}

		internal override bool HasReturn()
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				AST aST = (AST)list[i];
				if (aST.HasReturn())
				{
					return true;
				}
			}
			return false;
		}

		internal void ProcessAssemblyAttributeLists()
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				if (list[i] is Expression expression && expression.operand is AssemblyCustomAttributeList assemblyCustomAttributeList)
				{
					assemblyCustomAttributeList.Process();
				}
			}
		}

		internal void MarkSuperOKIfIsFirstStatement()
		{
			if (list.Count > 0 && list[0] is ConstructorCall)
			{
				((ConstructorCall)list[0]).isOK = true;
			}
		}

		internal override AST PartiallyEvaluate()
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				AST aST = (AST)list[i];
				list[i] = aST.PartiallyEvaluate();
			}
			return this;
		}

		internal Expression ToExpression()
		{
			if (list.Count == 1 && list[0] is Expression)
			{
				return (Expression)list[0];
			}
			return null;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Label label = il.DefineLabel();
			base.compilerGlobals.BreakLabelStack.Push(label);
			base.compilerGlobals.ContinueLabelStack.Push(label);
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				AST aST = (AST)list[i];
				aST.TranslateToIL(il, Typeob.Void);
			}
			il.MarkLabel(label);
			base.compilerGlobals.BreakLabelStack.Pop();
			base.compilerGlobals.ContinueLabelStack.Pop();
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				AST aST = (AST)list[i];
				aST.TranslateToILInitializer(il);
			}
		}

		internal void TranslateToILInitOnlyInitializers(ILGenerator il)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				if (list[i] is Constant constant)
				{
					constant.TranslateToILInitOnlyInitializers(il);
				}
			}
		}

		internal void TranslateToILInstanceInitializers(ILGenerator il)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				AST aST = (AST)list[i];
				if (aST is VariableDeclaration && !((VariableDeclaration)aST).field.IsStatic && !((VariableDeclaration)aST).field.IsLiteral)
				{
					aST.TranslateToILInitializer(il);
					aST.TranslateToIL(il, Typeob.Void);
				}
				else if (aST is FunctionDeclaration && !((FunctionDeclaration)aST).func.isStatic)
				{
					aST.TranslateToILInitializer(il);
				}
				else if (aST is Constant && !((Constant)aST).field.IsStatic)
				{
					aST.TranslateToIL(il, Typeob.Void);
				}
				else if (aST is Block)
				{
					((Block)aST).TranslateToILInstanceInitializers(il);
				}
			}
		}

		internal void TranslateToILStaticInitializers(ILGenerator il)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				AST aST = (AST)list[i];
				if ((aST is VariableDeclaration && ((VariableDeclaration)aST).field.IsStatic) || (aST is Constant && ((Constant)aST).field.IsStatic))
				{
					aST.TranslateToILInitializer(il);
					aST.TranslateToIL(il, Typeob.Void);
				}
				else if (aST is StaticInitializer)
				{
					aST.TranslateToIL(il, Typeob.Void);
				}
				else if (aST is FunctionDeclaration && ((FunctionDeclaration)aST).func.isStatic)
				{
					aST.TranslateToILInitializer(il);
				}
				else if (aST is Class)
				{
					aST.TranslateToIL(il, Typeob.Void);
				}
				else if (aST is Block)
				{
					((Block)aST).TranslateToILStaticInitializers(il);
				}
			}
		}

		internal override Context GetFirstExecutableContext()
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				AST aST = (AST)list[i];
				Context firstExecutableContext;
				if ((firstExecutableContext = aST.GetFirstExecutableContext()) != null)
				{
					return firstExecutableContext;
				}
			}
			return null;
		}
	}
	/// <summary>Represents the scope of a block of code that is taking part in a scope hierarchy and that can be pushed onto the global scope stack. For example, this class can represent the scope of a <see langword="try" /> block.</summary>
	public class BlockScope : ActivationObject
	{
		private static int counter;

		internal bool catchHanderScope;

		internal int scopeId;

		private ArrayList localFieldsForDebugInfo;

		internal BlockScope(ScriptObject parent)
			: base(parent)
		{
			scopeId = counter++;
			isKnownAtCompileTime = true;
			fast = !(parent is ActivationObject) || ((ActivationObject)parent).fast;
			localFieldsForDebugInfo = new ArrayList();
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.BlockScope" /> class.</summary>
		/// <param name="parent">The parent of the scope.</param>
		/// <param name="name">The name of the scope.</param>
		/// <param name="scopeId">The ID of the scope.</param>
		public BlockScope(ScriptObject parent, string name, int scopeId)
			: base(parent)
		{
			this.scopeId = scopeId;
			JSField value = (JSField)base.parent.GetField(name + ":" + this.scopeId, BindingFlags.Public);
			name_table[name] = value;
			field_table.Add(value);
		}

		internal void AddFieldForLocalScopeDebugInfo(JSLocalField field)
		{
			localFieldsForDebugInfo.Add(field);
		}

		/// <summary>Creates a new scope variable, using the specified name, value, and attributes.</summary>
		/// <param name="name">The name of the field.</param>
		/// <param name="attributeFlags">A bitwise combination of the enumeration values that describe the attributes of the field.</param>
		/// <param name="value">The value of the field.</param>
		/// <returns>A scope variable that has the specified name, value, and attributes.</returns>
		protected override JSVariableField CreateField(string name, FieldAttributes attributeFlags, object value)
		{
			if (!(parent is ActivationObject))
			{
				return base.CreateField(name, attributeFlags, value);
			}
			JSVariableField jSVariableField = ((ActivationObject)parent).AddNewField(name + ":" + scopeId, value, attributeFlags);
			jSVariableField.debuggerName = name;
			return jSVariableField;
		}

		internal void EmitLocalInfoForFields(ILGenerator il)
		{
			foreach (JSLocalField item in localFieldsForDebugInfo)
			{
				((LocalBuilder)item.metaData).SetLocalSymInfo(item.debuggerName);
			}
			if (parent is GlobalScope)
			{
				LocalBuilder localBuilder = il.DeclareLocal(Typeob.Int32);
				localBuilder.SetLocalSymInfo("scopeId for catch block");
				ConstantWrapper.TranslateToILInt(il, scopeId);
				il.Emit(OpCodes.Stloc, localBuilder);
			}
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public sealed class BooleanConstructor : ScriptFunction
	{
		internal static readonly BooleanConstructor ob = new BooleanConstructor();

		private BooleanPrototype originalPrototype;

		internal BooleanConstructor()
			: base(FunctionPrototype.ob, "Boolean", 1)
		{
			originalPrototype = BooleanPrototype.ob;
			BooleanPrototype._constructor = this;
			proto = BooleanPrototype.ob;
		}

		internal BooleanConstructor(LenientFunctionPrototype parent, LenientBooleanPrototype prototypeProp)
			: base(parent, "Boolean", 1)
		{
			originalPrototype = prototypeProp;
			prototypeProp.constructor = this;
			proto = prototypeProp;
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			if (args.Length == 0)
			{
				return false;
			}
			return Convert.ToBoolean(args[0]);
		}

		internal BooleanObject Construct()
		{
			return new BooleanObject(originalPrototype, value: false, implicitWrapper: false);
		}

		internal override object Construct(object[] args)
		{
			return CreateInstance(args);
		}

		internal BooleanObject ConstructImplicitWrapper(bool arg)
		{
			return new BooleanObject(originalPrototype, arg, implicitWrapper: true);
		}

		internal BooleanObject ConstructWrapper(bool arg)
		{
			return new BooleanObject(originalPrototype, arg, implicitWrapper: false);
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>The instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new BooleanObject CreateInstance(params object[] args)
		{
			return new BooleanObject(originalPrototype, args.Length != 0 && Convert.ToBoolean(args[0]), implicitWrapper: false);
		}

		/// <summary>Invokes a method of a prototype-based object, passing in the specified arguments.</summary>
		/// <param name="arg">The arguments to pass to the method.</param>
		/// <returns>The result of the call to the method.</returns>
		public bool Invoke(object arg)
		{
			return Convert.ToBoolean(arg);
		}
	}
	/// <summary>Represents a Boolean object. This class belongs to the built-in object model category.</summary>
	public class BooleanObject : JSObject
	{
		internal bool value;

		private bool implicitWrapper;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.BooleanObject" /> class, specifying the parent and subtype.</summary>
		/// <param name="prototype">The parent of the object.</param>
		/// <param name="subType">The subtype of the object.</param>
		protected BooleanObject(ScriptObject prototype, Type subType)
			: base(prototype, subType)
		{
			value = value;
			noExpando = false;
			implicitWrapper = false;
		}

		internal BooleanObject(ScriptObject prototype, bool value, bool implicitWrapper)
			: base(prototype, typeof(BooleanObject))
		{
			this.value = value;
			noExpando = implicitWrapper;
			this.implicitWrapper = implicitWrapper;
		}

		internal override string GetClassName()
		{
			return "Boolean";
		}

		internal override object GetDefaultValue(PreferredType preferred_type)
		{
			if (GetParent() is LenientBooleanPrototype)
			{
				return base.GetDefaultValue(preferred_type);
			}
			switch (preferred_type)
			{
			case PreferredType.String:
				if (!noExpando)
				{
					object obj2 = base.NameTable["toString"];
					if (obj2 != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return Convert.ToString(value);
			case PreferredType.LocaleString:
				return base.GetDefaultValue(preferred_type);
			default:
				if (!noExpando)
				{
					object obj = base.NameTable["valueOf"];
					if (obj == null && preferred_type == PreferredType.Either)
					{
						obj = base.NameTable["toString"];
					}
					if (obj != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return value;
			}
		}

		/// <summary>Returns <see cref="T:System.Boolean" /> or <see cref="T:Microsoft.JScript.BooleanObject" />.</summary>
		/// <returns>
		///   <see cref="T:System.Boolean" /> or <see cref="T:Microsoft.JScript.BooleanObject" />.</returns>
		public new Type GetType()
		{
			if (!implicitWrapper)
			{
				return Typeob.BooleanObject;
			}
			return Typeob.Boolean;
		}
	}
	/// <summary>Provides static methods and properties for <see cref="T:Microsoft.JScript.BooleanObject" /> objects. All methods of this class are called by passing in a reference to the object that is requesting access to the method. This class belongs to the built-in object model category.</summary>
	public class BooleanPrototype : BooleanObject
	{
		internal static readonly BooleanPrototype ob = new BooleanPrototype(ObjectPrototype.ob, typeof(BooleanPrototype));

		internal static BooleanConstructor _constructor;

		/// <summary>Gets a reference to a prototype-based object that is using this prototype.</summary>
		/// <returns>A reference to a prototype-based object.</returns>
		public static BooleanConstructor constructor => _constructor;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.BooleanPrototype" /> class.</summary>
		/// <param name="parent">A static instance of the parent class of this class.</param>
		/// <param name="baseType">An instance of the type of this class.</param>
		protected BooleanPrototype(ObjectPrototype parent, Type baseType)
			: base(parent, baseType)
		{
			noExpando = true;
		}

		/// <summary>Creates a string representation of the specified object by using the <see cref="T:Microsoft.JScript.Convert" /> class.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" /> that is created by the <see cref="T:Microsoft.JScript.Convert" /> class.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Boolean_toString)]
		public static string toString(object thisob)
		{
			if (thisob is BooleanObject)
			{
				return Convert.ToString(((BooleanObject)thisob).value);
			}
			if (Convert.GetTypeCode(thisob) == TypeCode.Boolean)
			{
				return Convert.ToString(thisob);
			}
			throw new JScriptException(JSError.BooleanExpected);
		}

		/// <summary>Returns the specified object as a <see cref="T:Microsoft.JScript.BooleanObject" /> or a <see cref="T:System.Boolean" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>
		///   <paramref name="thisob" /> as a <see cref="T:Microsoft.JScript.BooleanObject" /> or a <see cref="T:System.Boolean" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Boolean_valueOf)]
		public static object valueOf(object thisob)
		{
			if (thisob is BooleanObject)
			{
				return ((BooleanObject)thisob).value;
			}
			if (Convert.GetTypeCode(thisob) == TypeCode.Boolean)
			{
				return thisob;
			}
			throw new JScriptException(JSError.BooleanExpected);
		}
	}
	internal sealed class Break : AST
	{
		private Completion completion;

		private bool leavesFinally;

		internal Break(Context context, int count, bool leavesFinally)
			: base(context)
		{
			completion = new Completion();
			completion.Exit = count;
			this.leavesFinally = leavesFinally;
		}

		internal override object Evaluate()
		{
			return completion;
		}

		internal override AST PartiallyEvaluate()
		{
			if (leavesFinally)
			{
				context.HandleError(JSError.BadWayToLeaveFinally);
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Label label = (Label)base.compilerGlobals.BreakLabelStack.Peek(completion.Exit - 1);
			context.EmitLineInfo(il);
			if (leavesFinally)
			{
				ConstantWrapper.TranslateToILInt(il, base.compilerGlobals.BreakLabelStack.Size() - completion.Exit);
				il.Emit(OpCodes.Newobj, CompilerGlobals.breakOutOfFinallyConstructor);
				il.Emit(OpCodes.Throw);
			}
			else if (base.compilerGlobals.InsideProtectedRegion)
			{
				il.Emit(OpCodes.Leave, label);
			}
			else
			{
				il.Emit(OpCodes.Br, label);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
		}
	}
	/// <summary>Represents the exception state when code execution breaks out of a <see langword="finally" /> block.</summary>
	[Serializable]
	public sealed class BreakOutOfFinally : ApplicationException
	{
		/// <summary>Stores the target of the exception.</summary>
		public int target;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.BreakOutOfFinally" /> class, using the specified target.</summary>
		/// <param name="target">The target of the exception.</param>
		public BreakOutOfFinally(int target)
		{
			this.target = target;
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.BreakOutOfFinally" /> class, using the specified error message.</summary>
		/// <param name="m">The message that describes the error.</param>
		public BreakOutOfFinally(string m)
			: base(m)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.BreakOutOfFinally" /> class, using the specified error message and a reference to the inner exception that is the cause of this exception.</summary>
		/// <param name="m">The message that describes the error.</param>
		/// <param name="e">The exception that is the cause of the current exception.</param>
		public BreakOutOfFinally(string m, Exception e)
			: base(m, e)
		{
		}

		private BreakOutOfFinally(SerializationInfo s, StreamingContext c)
			: base(s, c)
		{
			target = s.GetInt32("Target");
		}

		/// <summary>Stores information about the exception in the <see cref="T:System.Runtime.Serialization.SerializationInfo" />. The stored information includes the <see cref="F:Microsoft.JScript.ContinueOutOfFinally.target" /> value.</summary>
		/// <param name="s">The serialized object data about the exception that is being thrown.</param>
		/// <param name="c">Contextual information about the source or destination.</param>
		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo s, StreamingContext c)
		{
			base.GetObjectData(s, c);
			s.AddValue("Target", target);
		}
	}
	/// <summary>Specifies the built-in JScript functions. These functions correspond to the static methods of the intrinsic JScript objects. The members of this enumeration are used to create <see cref="T:Microsoft.JScript.JSFunctionAttribute" /> objects.</summary>
	public enum JSBuiltin
	{
		/// <summary>No method. This is the default value.</summary>
		None,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.concat(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_concat,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.join(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_join,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.pop(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_pop,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.push(System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_push,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.reverse(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_reverse,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.shift(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_shift,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.slice(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_slice,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.sort(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_sort,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.splice(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Double,System.Double,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_splice,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.toLocaleString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_toLocaleString,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_toString,
		/// <summary>The static <see cref="M:Microsoft.JScript.ArrayPrototype.unshift(System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		Array_unshift,
		/// <summary>The static <see cref="M:Microsoft.JScript.BooleanPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.BooleanPrototype" /> class.</summary>
		Boolean_toString,
		/// <summary>The static <see cref="M:Microsoft.JScript.BooleanPrototype.valueOf(System.Object)" /> method of the <see cref="T:Microsoft.JScript.BooleanPrototype" /> class.</summary>
		Boolean_valueOf,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getDate(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getDate,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getDay(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getDay,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getFullYear(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getFullYear,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getHours(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getHours,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getMilliseconds(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getMilliseconds,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getMinutes(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getMinutes,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getMonth(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getMonth,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getSeconds(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getSeconds,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getTime(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getTime,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getTimezoneOffset(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getTimezoneOffset,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getUTCDate(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getUTCDate,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getUTCDay(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getUTCDay,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getUTCFullYear(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getUTCFullYear,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getUTCHours(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getUTCHours,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getUTCMilliseconds(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getUTCMilliseconds,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getUTCMinutes(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getUTCMinutes,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getUTCMonth(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getUTCMonth,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getUTCSeconds(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getUTCSeconds,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getVarDate(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getVarDate,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.getYear(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_getYear,
		/// <summary>The static <see cref="M:Microsoft.JScript.DateConstructor.parse(System.String)" /> method of the <see cref="T:Microsoft.JScript.DateConstructor" /> class.</summary>
		Date_parse,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setDate(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setDate,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setFullYear(System.Object,System.Double,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setFullYear,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setHours(System.Object,System.Double,System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setHours,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setMinutes(System.Object,System.Double,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setMinutes,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setMilliseconds(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setMilliseconds,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setMonth(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setMonth,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setSeconds(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setSeconds,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setTime(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setTime,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setUTCDate(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setUTCDate,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setUTCFullYear(System.Object,System.Double,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setUTCFullYear,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setUTCHours(System.Object,System.Double,System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setUTCHours,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setUTCMinutes(System.Object,System.Double,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setUTCMinutes,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setUTCMilliseconds(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setUTCMilliseconds,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setUTCMonth(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setUTCMonth,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setUTCSeconds(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setUTCSeconds,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.setYear(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_setYear,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.toDateString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_toDateString,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.toGMTString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_toGMTString,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.toLocaleDateString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_toLocaleDateString,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.toLocaleString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_toLocaleString,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.toLocaleTimeString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_toLocaleTimeString,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_toString,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.toTimeString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_toTimeString,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.toUTCString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_toUTCString,
		/// <summary>The static <see cref="M:Microsoft.JScript.DateConstructor.UTC(System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DateConstructor" /> class.</summary>
		Date_UTC,
		/// <summary>The static <see cref="M:Microsoft.JScript.DatePrototype.valueOf(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		Date_valueOf,
		/// <summary>The static <see cref="M:Microsoft.JScript.EnumeratorPrototype.atEnd(System.Object)" /> method of the <see cref="T:Microsoft.JScript.EnumeratorPrototype" /> class.</summary>
		Enumerator_atEnd,
		/// <summary>The static <see cref="M:Microsoft.JScript.EnumeratorPrototype.item(System.Object)" /> method of the <see cref="T:Microsoft.JScript.EnumeratorPrototype" /> class.</summary>
		Enumerator_item,
		/// <summary>The static <see cref="M:Microsoft.JScript.EnumeratorPrototype.moveFirst(System.Object)" /> method of the <see cref="T:Microsoft.JScript.EnumeratorPrototype" /> class.</summary>
		Enumerator_moveFirst,
		/// <summary>The static <see cref="M:Microsoft.JScript.EnumeratorPrototype.moveNext(System.Object)" /> method of the <see cref="T:Microsoft.JScript.EnumeratorPrototype" /> class.</summary>
		Enumerator_moveNext,
		/// <summary>The static <see cref="M:Microsoft.JScript.ErrorPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ErrorPrototype" /> class.</summary>
		Error_toString,
		/// <summary>The static <see cref="M:Microsoft.JScript.FunctionPrototype.apply(System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.FunctionPrototype" /> class.</summary>
		Function_apply,
		/// <summary>The static <see cref="M:Microsoft.JScript.FunctionPrototype.call(System.Object,System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.FunctionPrototype" /> class.</summary>
		Function_call,
		/// <summary>The static <see cref="M:Microsoft.JScript.FunctionPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.FunctionPrototype" /> class.</summary>
		Function_toString,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.CollectGarbage" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_CollectGarbage,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.decodeURI(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_decodeURI,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.decodeURIComponent(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_decodeURIComponent,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.encodeURI(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_encodeURI,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.encodeURIComponent(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_encodeURIComponent,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.escape(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_escape,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.eval(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_eval,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.GetObject(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_GetObject,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.isNaN(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_isNaN,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.isFinite(System.Double)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_isFinite,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.parseFloat(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_parseFloat,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.parseInt(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_parseInt,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.ScriptEngine" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_ScriptEngine,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.ScriptEngineBuildVersion" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_ScriptEngineBuildVersion,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.ScriptEngineMajorVersion" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_ScriptEngineMajorVersion,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.ScriptEngineMinorVersion" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_ScriptEngineMinorVersion,
		/// <summary>The static <see cref="M:Microsoft.JScript.GlobalObject.unescape(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		Global_unescape,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.abs(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_abs,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.acos(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_acos,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.asin(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_asin,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.atan(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_atan,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.atan2(System.Double,System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_atan2,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.ceil(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_ceil,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.cos(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_cos,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.exp(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_exp,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.floor(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_floor,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.log(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_log,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.max(System.Object,System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_max,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.min(System.Object,System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_min,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.pow(System.Double,System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_pow,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.random" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_random,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.round(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_round,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.sin(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_sin,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.sqrt(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_sqrt,
		/// <summary>The static <see cref="M:Microsoft.JScript.MathObject.tan(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		Math_tan,
		/// <summary>The static <see cref="M:Microsoft.JScript.NumberPrototype.toExponential(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		Number_toExponential,
		/// <summary>The static <see cref="M:Microsoft.JScript.NumberPrototype.toFixed(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		Number_toFixed,
		/// <summary>The static <see cref="M:Microsoft.JScript.NumberPrototype.toLocaleString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		Number_toLocaleString,
		/// <summary>The static <see cref="M:Microsoft.JScript.NumberPrototype.toPrecision(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		Number_toPrecision,
		/// <summary>The static <see cref="M:Microsoft.JScript.NumberPrototype.toString(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		Number_toString,
		/// <summary>The static <see cref="M:Microsoft.JScript.NumberPrototype.valueOf(System.Object)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		Number_valueOf,
		/// <summary>The static <see cref="M:Microsoft.JScript.ObjectPrototype.hasOwnProperty(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		Object_hasOwnProperty,
		/// <summary>The static <see cref="M:Microsoft.JScript.ObjectPrototype.isPrototypeOf(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		Object_isPrototypeOf,
		/// <summary>The static <see cref="M:Microsoft.JScript.ObjectPrototype.propertyIsEnumerable(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		Object_propertyIsEnumerable,
		/// <summary>The static <see cref="M:Microsoft.JScript.ObjectPrototype.toLocaleString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		Object_toLocaleString,
		/// <summary>The static <see cref="M:Microsoft.JScript.ObjectPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		Object_toString,
		/// <summary>The static <see cref="M:Microsoft.JScript.ObjectPrototype.valueOf(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		Object_valueOf,
		/// <summary>The static <see cref="M:Microsoft.JScript.RegExpPrototype.compile(System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.RegExpPrototype" /> class.</summary>
		RegExp_compile,
		/// <summary>The static <see cref="M:Microsoft.JScript.RegExpPrototype.exec(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.RegExpPrototype" /> class.</summary>
		RegExp_exec,
		/// <summary>The static <see cref="M:Microsoft.JScript.RegExpPrototype.test(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.RegExpPrototype" /> class.</summary>
		RegExp_test,
		/// <summary>The static <see cref="M:Microsoft.JScript.RegExpPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.RegExpPrototype" /> class.</summary>
		RegExp_toString,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.anchor(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_anchor,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.big(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_big,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.blink(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_blink,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.bold(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_bold,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.charAt(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_charAt,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.charCodeAt(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_charCodeAt,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.concat(System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_concat,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.fixed(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_fixed,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.fontcolor(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_fontcolor,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.fontsize(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_fontsize,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringConstructor.fromCharCode(System.Object[])" /> method of the <see cref="T:Microsoft.JScript.StringConstructor" /> class.</summary>
		String_fromCharCode,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.indexOf(System.Object,System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_indexOf,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.italics(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_italics,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.lastIndexOf(System.Object,System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_lastIndexOf,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.link(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_link,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.localeCompare(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_localeCompare,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.match(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_match,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.replace(System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_replace,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.search(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_search,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.slice(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_slice,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.small(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_small,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.split(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_split,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.strike(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_strike,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.sub(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_sub,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.substr(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_substr,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.substring(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_substring,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.sup(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_sup,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.toLocaleLowerCase(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_toLocaleLowerCase,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.toLocaleUpperCase(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_toLocaleUpperCase,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.toLowerCase(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_toLowerCase,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_toString,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.toUpperCase(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_toUpperCase,
		/// <summary>The static <see cref="M:Microsoft.JScript.StringPrototype.valueOf(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		String_valueOf,
		/// <summary>The static <see cref="M:Microsoft.JScript.VBArrayPrototype.dimensions(System.Object)" /> method of the <see cref="T:Microsoft.JScript.VBArrayPrototype" /> class.</summary>
		VBArray_dimensions,
		/// <summary>The static <see cref="M:Microsoft.JScript.VBArrayPrototype.getItem(System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.VBArrayPrototype" /> class.</summary>
		VBArray_getItem,
		/// <summary>The static <see cref="M:Microsoft.JScript.VBArrayPrototype.lbound(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.VBArrayPrototype" /> class.</summary>
		VBArray_lbound,
		/// <summary>The static <see cref="M:Microsoft.JScript.VBArrayPrototype.toArray(System.Object,Microsoft.JScript.Vsa.VsaEngine)" /> method of the <see cref="T:Microsoft.JScript.VBArrayPrototype" /> class.</summary>
		VBArray_toArray,
		/// <summary>The static <see cref="M:Microsoft.JScript.VBArrayPrototype.ubound(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.VBArrayPrototype" /> class.</summary>
		VBArray_ubound
	}
	internal sealed class BuiltinFunction : ScriptFunction
	{
		internal MethodInfo method;

		private JSBuiltin biFunc;

		internal BuiltinFunction(object obj, MethodInfo method)
			: this(method.Name, obj, method, FunctionPrototype.ob)
		{
		}

		internal BuiltinFunction(string name, object obj, MethodInfo method, ScriptFunction parent)
			: base(parent, name)
		{
			noExpando = false;
			ParameterInfo[] parameters = method.GetParameters();
			int num = (ilength = parameters.Length);
			object[] customAttributes = CustomAttribute.GetCustomAttributes(method, typeof(JSFunctionAttribute), inherit: false);
			JSFunctionAttribute jSFunctionAttribute = ((customAttributes.Length != 0) ? ((JSFunctionAttribute)customAttributes[0]) : new JSFunctionAttribute(JSFunctionAttributeEnum.None));
			JSFunctionAttributeEnum attributeValue = jSFunctionAttribute.attributeValue;
			if ((attributeValue & JSFunctionAttributeEnum.HasThisObject) != 0)
			{
				ilength--;
			}
			if ((attributeValue & JSFunctionAttributeEnum.HasEngine) != 0)
			{
				ilength--;
			}
			if ((attributeValue & JSFunctionAttributeEnum.HasVarArgs) != 0)
			{
				ilength--;
			}
			biFunc = jSFunctionAttribute.builtinFunction;
			if (biFunc == JSBuiltin.None)
			{
				this.method = new JSNativeMethod(method, obj, engine);
			}
			else
			{
				this.method = null;
			}
		}

		internal override object Call(object[] args, object thisob)
		{
			return QuickCall(args, thisob, biFunc, method, engine);
		}

		internal static object QuickCall(object[] args, object thisob, JSBuiltin biFunc, MethodInfo method, VsaEngine engine)
		{
			int n = args.Length;
			switch (biFunc)
			{
			case JSBuiltin.Array_concat:
				return ArrayPrototype.concat(thisob, engine, args);
			case JSBuiltin.Array_join:
				return ArrayPrototype.join(thisob, GetArg(args, 0, n));
			case JSBuiltin.Array_pop:
				return ArrayPrototype.pop(thisob);
			case JSBuiltin.Array_push:
				return ArrayPrototype.push(thisob, args);
			case JSBuiltin.Array_reverse:
				return ArrayPrototype.reverse(thisob);
			case JSBuiltin.Array_shift:
				return ArrayPrototype.shift(thisob);
			case JSBuiltin.Array_slice:
				return ArrayPrototype.slice(thisob, engine, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n));
			case JSBuiltin.Array_sort:
				return ArrayPrototype.sort(thisob, GetArg(args, 0, n));
			case JSBuiltin.Array_splice:
				return ArrayPrototype.splice(thisob, engine, Convert.ToNumber(GetArg(args, 0, n)), Convert.ToNumber(GetArg(args, 1, n)), VarArgs(args, 2, n));
			case JSBuiltin.Array_toLocaleString:
				return ArrayPrototype.toLocaleString(thisob);
			case JSBuiltin.Array_toString:
				return ArrayPrototype.toString(thisob);
			case JSBuiltin.Array_unshift:
				return ArrayPrototype.unshift(thisob, args);
			case JSBuiltin.Boolean_toString:
				return BooleanPrototype.toString(thisob);
			case JSBuiltin.Boolean_valueOf:
				return BooleanPrototype.valueOf(thisob);
			case JSBuiltin.Date_getDate:
				return DatePrototype.getDate(thisob);
			case JSBuiltin.Date_getDay:
				return DatePrototype.getDay(thisob);
			case JSBuiltin.Date_getFullYear:
				return DatePrototype.getFullYear(thisob);
			case JSBuiltin.Date_getHours:
				return DatePrototype.getHours(thisob);
			case JSBuiltin.Date_getMilliseconds:
				return DatePrototype.getMilliseconds(thisob);
			case JSBuiltin.Date_getMinutes:
				return DatePrototype.getMinutes(thisob);
			case JSBuiltin.Date_getMonth:
				return DatePrototype.getMonth(thisob);
			case JSBuiltin.Date_getSeconds:
				return DatePrototype.getSeconds(thisob);
			case JSBuiltin.Date_getTime:
				return DatePrototype.getTime(thisob);
			case JSBuiltin.Date_getTimezoneOffset:
				return DatePrototype.getTimezoneOffset(thisob);
			case JSBuiltin.Date_getUTCDate:
				return DatePrototype.getUTCDate(thisob);
			case JSBuiltin.Date_getUTCDay:
				return DatePrototype.getUTCDay(thisob);
			case JSBuiltin.Date_getUTCFullYear:
				return DatePrototype.getUTCFullYear(thisob);
			case JSBuiltin.Date_getUTCHours:
				return DatePrototype.getUTCHours(thisob);
			case JSBuiltin.Date_getUTCMilliseconds:
				return DatePrototype.getUTCMilliseconds(thisob);
			case JSBuiltin.Date_getUTCMinutes:
				return DatePrototype.getUTCMinutes(thisob);
			case JSBuiltin.Date_getUTCMonth:
				return DatePrototype.getUTCMonth(thisob);
			case JSBuiltin.Date_getUTCSeconds:
				return DatePrototype.getUTCSeconds(thisob);
			case JSBuiltin.Date_getVarDate:
				return DatePrototype.getVarDate(thisob);
			case JSBuiltin.Date_getYear:
				return DatePrototype.getYear(thisob);
			case JSBuiltin.Date_parse:
				return DateConstructor.parse(Convert.ToString(GetArg(args, 0, n)));
			case JSBuiltin.Date_setDate:
				return DatePrototype.setDate(thisob, Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Date_setFullYear:
				return DatePrototype.setFullYear(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n), GetArg(args, 2, n));
			case JSBuiltin.Date_setHours:
				return DatePrototype.setHours(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n), GetArg(args, 2, n), GetArg(args, 3, n));
			case JSBuiltin.Date_setMinutes:
				return DatePrototype.setMinutes(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n), GetArg(args, 2, n));
			case JSBuiltin.Date_setMilliseconds:
				return DatePrototype.setMilliseconds(thisob, Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Date_setMonth:
				return DatePrototype.setMonth(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n));
			case JSBuiltin.Date_setSeconds:
				return DatePrototype.setSeconds(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n));
			case JSBuiltin.Date_setTime:
				return DatePrototype.setTime(thisob, Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Date_setUTCDate:
				return DatePrototype.setUTCDate(thisob, Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Date_setUTCFullYear:
				return DatePrototype.setUTCFullYear(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n), GetArg(args, 2, n));
			case JSBuiltin.Date_setUTCHours:
				return DatePrototype.setUTCHours(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n), GetArg(args, 2, n), GetArg(args, 3, n));
			case JSBuiltin.Date_setUTCMinutes:
				return DatePrototype.setUTCMinutes(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n), GetArg(args, 2, n));
			case JSBuiltin.Date_setUTCMilliseconds:
				return DatePrototype.setUTCMilliseconds(thisob, Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Date_setUTCMonth:
				return DatePrototype.setUTCMonth(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n));
			case JSBuiltin.Date_setUTCSeconds:
				return DatePrototype.setUTCSeconds(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n));
			case JSBuiltin.Date_setYear:
				return DatePrototype.setYear(thisob, Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Date_toDateString:
				return DatePrototype.toDateString(thisob);
			case JSBuiltin.Date_toGMTString:
				return DatePrototype.toGMTString(thisob);
			case JSBuiltin.Date_toLocaleDateString:
				return DatePrototype.toLocaleDateString(thisob);
			case JSBuiltin.Date_toLocaleString:
				return DatePrototype.toLocaleString(thisob);
			case JSBuiltin.Date_toLocaleTimeString:
				return DatePrototype.toLocaleTimeString(thisob);
			case JSBuiltin.Date_toString:
				return DatePrototype.toString(thisob);
			case JSBuiltin.Date_toTimeString:
				return DatePrototype.toTimeString(thisob);
			case JSBuiltin.Date_toUTCString:
				return DatePrototype.toUTCString(thisob);
			case JSBuiltin.Date_UTC:
				return DateConstructor.UTC(GetArg(args, 0, n), GetArg(args, 1, n), GetArg(args, 2, n), GetArg(args, 3, n), GetArg(args, 4, n), GetArg(args, 5, n), GetArg(args, 6, n));
			case JSBuiltin.Date_valueOf:
				return DatePrototype.valueOf(thisob);
			case JSBuiltin.Enumerator_atEnd:
				return EnumeratorPrototype.atEnd(thisob);
			case JSBuiltin.Enumerator_item:
				return EnumeratorPrototype.item(thisob);
			case JSBuiltin.Enumerator_moveFirst:
				EnumeratorPrototype.moveFirst(thisob);
				return null;
			case JSBuiltin.Enumerator_moveNext:
				EnumeratorPrototype.moveNext(thisob);
				return null;
			case JSBuiltin.Error_toString:
				return ErrorPrototype.toString(thisob);
			case JSBuiltin.Function_apply:
				return FunctionPrototype.apply(thisob, GetArg(args, 0, n), GetArg(args, 1, n));
			case JSBuiltin.Function_call:
				return FunctionPrototype.call(thisob, GetArg(args, 0, n), VarArgs(args, 1, n));
			case JSBuiltin.Function_toString:
				return FunctionPrototype.toString(thisob);
			case JSBuiltin.Global_CollectGarbage:
				GlobalObject.CollectGarbage();
				return null;
			case JSBuiltin.Global_decodeURI:
				return GlobalObject.decodeURI(GetArg(args, 0, n));
			case JSBuiltin.Global_decodeURIComponent:
				return GlobalObject.decodeURIComponent(GetArg(args, 0, n));
			case JSBuiltin.Global_encodeURI:
				return GlobalObject.encodeURI(GetArg(args, 0, n));
			case JSBuiltin.Global_encodeURIComponent:
				return GlobalObject.encodeURIComponent(GetArg(args, 0, n));
			case JSBuiltin.Global_escape:
				return GlobalObject.escape(GetArg(args, 0, n));
			case JSBuiltin.Global_eval:
				return GlobalObject.eval(GetArg(args, 0, n));
			case JSBuiltin.Global_GetObject:
				return GlobalObject.GetObject(GetArg(args, 0, n), GetArg(args, 1, n));
			case JSBuiltin.Global_isNaN:
				return GlobalObject.isNaN(GetArg(args, 0, n));
			case JSBuiltin.Global_isFinite:
				return GlobalObject.isFinite(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Global_parseFloat:
				return GlobalObject.parseFloat(GetArg(args, 0, n));
			case JSBuiltin.Global_parseInt:
				return GlobalObject.parseInt(GetArg(args, 0, n), GetArg(args, 1, n));
			case JSBuiltin.Global_ScriptEngine:
				return GlobalObject.ScriptEngine();
			case JSBuiltin.Global_ScriptEngineBuildVersion:
				return GlobalObject.ScriptEngineBuildVersion();
			case JSBuiltin.Global_ScriptEngineMajorVersion:
				return GlobalObject.ScriptEngineMajorVersion();
			case JSBuiltin.Global_ScriptEngineMinorVersion:
				return GlobalObject.ScriptEngineMinorVersion();
			case JSBuiltin.Global_unescape:
				return GlobalObject.unescape(GetArg(args, 0, n));
			case JSBuiltin.Math_abs:
				return MathObject.abs(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_acos:
				return MathObject.acos(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_asin:
				return MathObject.asin(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_atan:
				return MathObject.atan(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_atan2:
				return MathObject.atan2(Convert.ToNumber(GetArg(args, 0, n)), Convert.ToNumber(GetArg(args, 1, n)));
			case JSBuiltin.Math_ceil:
				return MathObject.ceil(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_cos:
				return MathObject.cos(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_exp:
				return MathObject.exp(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_floor:
				return MathObject.floor(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_log:
				return MathObject.log(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_max:
				return MathObject.max(GetArg(args, 0, n), GetArg(args, 1, n), VarArgs(args, 2, n));
			case JSBuiltin.Math_min:
				return MathObject.min(GetArg(args, 0, n), GetArg(args, 1, n), VarArgs(args, 2, n));
			case JSBuiltin.Math_pow:
				return MathObject.pow(Convert.ToNumber(GetArg(args, 0, n)), Convert.ToNumber(GetArg(args, 1, n)));
			case JSBuiltin.Math_random:
				return MathObject.random();
			case JSBuiltin.Math_round:
				return MathObject.round(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_sin:
				return MathObject.sin(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_sqrt:
				return MathObject.sqrt(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Math_tan:
				return MathObject.tan(Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Number_toExponential:
				return NumberPrototype.toExponential(thisob, GetArg(args, 0, n));
			case JSBuiltin.Number_toFixed:
				return NumberPrototype.toFixed(thisob, Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.Number_toLocaleString:
				return NumberPrototype.toLocaleString(thisob);
			case JSBuiltin.Number_toPrecision:
				return NumberPrototype.toPrecision(thisob, GetArg(args, 0, n));
			case JSBuiltin.Number_toString:
				return NumberPrototype.toString(thisob, GetArg(args, 0, n));
			case JSBuiltin.Number_valueOf:
				return NumberPrototype.valueOf(thisob);
			case JSBuiltin.Object_hasOwnProperty:
				return ObjectPrototype.hasOwnProperty(thisob, GetArg(args, 0, n));
			case JSBuiltin.Object_isPrototypeOf:
				return ObjectPrototype.isPrototypeOf(thisob, GetArg(args, 0, n));
			case JSBuiltin.Object_propertyIsEnumerable:
				return ObjectPrototype.propertyIsEnumerable(thisob, GetArg(args, 0, n));
			case JSBuiltin.Object_toLocaleString:
				return ObjectPrototype.toLocaleString(thisob);
			case JSBuiltin.Object_toString:
				return ObjectPrototype.toString(thisob);
			case JSBuiltin.Object_valueOf:
				return ObjectPrototype.valueOf(thisob);
			case JSBuiltin.RegExp_compile:
				return RegExpPrototype.compile(thisob, GetArg(args, 0, n), GetArg(args, 1, n));
			case JSBuiltin.RegExp_exec:
				return RegExpPrototype.exec(thisob, GetArg(args, 0, n));
			case JSBuiltin.RegExp_test:
				return RegExpPrototype.test(thisob, GetArg(args, 0, n));
			case JSBuiltin.RegExp_toString:
				return RegExpPrototype.toString(thisob);
			case JSBuiltin.String_anchor:
				return StringPrototype.anchor(thisob, GetArg(args, 0, n));
			case JSBuiltin.String_big:
				return StringPrototype.big(thisob);
			case JSBuiltin.String_blink:
				return StringPrototype.blink(thisob);
			case JSBuiltin.String_bold:
				return StringPrototype.bold(thisob);
			case JSBuiltin.String_charAt:
				return StringPrototype.charAt(thisob, Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.String_charCodeAt:
				return StringPrototype.charCodeAt(thisob, Convert.ToNumber(GetArg(args, 0, n)));
			case JSBuiltin.String_concat:
				return StringPrototype.concat(thisob, args);
			case JSBuiltin.String_fixed:
				return StringPrototype.@fixed(thisob);
			case JSBuiltin.String_fontcolor:
				return StringPrototype.fontcolor(thisob, GetArg(args, 0, n));
			case JSBuiltin.String_fontsize:
				return StringPrototype.fontsize(thisob, GetArg(args, 0, n));
			case JSBuiltin.String_fromCharCode:
				return StringConstructor.fromCharCode(args);
			case JSBuiltin.String_indexOf:
				return StringPrototype.indexOf(thisob, GetArg(args, 0, n), Convert.ToNumber(GetArg(args, 1, n)));
			case JSBuiltin.String_italics:
				return StringPrototype.italics(thisob);
			case JSBuiltin.String_lastIndexOf:
				return StringPrototype.lastIndexOf(thisob, GetArg(args, 0, n), Convert.ToNumber(GetArg(args, 1, n)));
			case JSBuiltin.String_link:
				return StringPrototype.link(thisob, GetArg(args, 0, n));
			case JSBuiltin.String_localeCompare:
				return StringPrototype.localeCompare(thisob, GetArg(args, 0, n));
			case JSBuiltin.String_match:
				return StringPrototype.match(thisob, engine, GetArg(args, 0, n));
			case JSBuiltin.String_replace:
				return StringPrototype.replace(thisob, GetArg(args, 0, n), GetArg(args, 1, n));
			case JSBuiltin.String_search:
				return StringPrototype.search(thisob, engine, GetArg(args, 0, n));
			case JSBuiltin.String_slice:
				return StringPrototype.slice(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n));
			case JSBuiltin.String_small:
				return StringPrototype.small(thisob);
			case JSBuiltin.String_split:
				return StringPrototype.split(thisob, engine, GetArg(args, 0, n), GetArg(args, 1, n));
			case JSBuiltin.String_strike:
				return StringPrototype.strike(thisob);
			case JSBuiltin.String_sub:
				return StringPrototype.sub(thisob);
			case JSBuiltin.String_substr:
				return StringPrototype.substr(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n));
			case JSBuiltin.String_substring:
				return StringPrototype.substring(thisob, Convert.ToNumber(GetArg(args, 0, n)), GetArg(args, 1, n));
			case JSBuiltin.String_sup:
				return StringPrototype.sup(thisob);
			case JSBuiltin.String_toLocaleLowerCase:
				return StringPrototype.toLocaleLowerCase(thisob);
			case JSBuiltin.String_toLocaleUpperCase:
				return StringPrototype.toLocaleUpperCase(thisob);
			case JSBuiltin.String_toLowerCase:
				return StringPrototype.toLowerCase(thisob);
			case JSBuiltin.String_toString:
				return StringPrototype.toString(thisob);
			case JSBuiltin.String_toUpperCase:
				return StringPrototype.toUpperCase(thisob);
			case JSBuiltin.String_valueOf:
				return StringPrototype.valueOf(thisob);
			case JSBuiltin.VBArray_dimensions:
				return VBArrayPrototype.dimensions(thisob);
			case JSBuiltin.VBArray_getItem:
				return VBArrayPrototype.getItem(thisob, args);
			case JSBuiltin.VBArray_lbound:
				return VBArrayPrototype.lbound(thisob, GetArg(args, 0, n));
			case JSBuiltin.VBArray_toArray:
				return VBArrayPrototype.toArray(thisob, engine);
			case JSBuiltin.VBArray_ubound:
				return VBArrayPrototype.ubound(thisob, GetArg(args, 0, n));
			default:
				return method.Invoke(thisob, BindingFlags.Default, JSBinder.ob, args, null);
			}
		}

		private static object GetArg(object[] args, int i, int n)
		{
			if (i >= n)
			{
				return Missing.Value;
			}
			return args[i];
		}

		private static object[] VarArgs(object[] args, int offset, int n)
		{
			object[] array = new object[(n >= offset) ? (n - offset) : 0];
			for (int i = offset; i < n; i++)
			{
				array[i - offset] = args[i];
			}
			return array;
		}

		public override string ToString()
		{
			return "function " + name + "() {\n    [native code]\n}";
		}
	}
	internal class Call : AST
	{
		internal AST func;

		private ASTList args;

		private object[] argValues;

		private int outParameterCount;

		internal bool isConstructor;

		internal bool inBrackets;

		private FunctionScope enclosingFunctionScope;

		private bool alreadyPartiallyEvaluated;

		private bool isAssignmentToDefaultIndexedProperty;

		internal Call(Context context, AST func, ASTList args, bool inBrackets)
			: base(context)
		{
			this.func = func;
			this.args = ((args == null) ? new ASTList(context) : args);
			argValues = null;
			outParameterCount = 0;
			int i = 0;
			for (int count = this.args.count; i < count; i++)
			{
				if (this.args[i] is AddressOf)
				{
					outParameterCount++;
				}
			}
			isConstructor = false;
			this.inBrackets = inBrackets;
			enclosingFunctionScope = null;
			alreadyPartiallyEvaluated = false;
			isAssignmentToDefaultIndexedProperty = false;
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (!(scriptObject is FunctionScope))
			{
				scriptObject = scriptObject.GetParent();
				if (scriptObject == null)
				{
					return;
				}
			}
			enclosingFunctionScope = (FunctionScope)scriptObject;
		}

		private bool AllParamsAreMissing()
		{
			int i = 0;
			for (int count = args.count; i < count; i++)
			{
				AST aST = args[i];
				if (!(aST is ConstantWrapper) || ((ConstantWrapper)aST).value != System.Reflection.Missing.Value)
				{
					return false;
				}
			}
			return true;
		}

		private IReflect[] ArgIRs()
		{
			int count = args.count;
			IReflect[] array = new IReflect[count];
			for (int i = 0; i < count; i++)
			{
				AST aST = args[i];
				IReflect reflect = (array[i] = aST.InferType(null));
				if (aST is AddressOf)
				{
					if (reflect is ClassScope)
					{
						reflect = ((ClassScope)reflect).GetBakedSuperType();
					}
					array[i] = Convert.ToType("&", Convert.ToType(reflect));
				}
			}
			return array;
		}

		internal bool CanBeFunctionDeclaration()
		{
			bool flag = func is Lookup && outParameterCount == 0;
			if (flag)
			{
				int i = 0;
				for (int count = args.count; i < count; i++)
				{
					AST aST = args[i];
					flag = aST is Lookup;
					if (!flag)
					{
						break;
					}
				}
			}
			return flag;
		}

		internal override void CheckIfOKToUseInSuperConstructorCall()
		{
			func.CheckIfOKToUseInSuperConstructorCall();
		}

		internal override bool Delete()
		{
			object[] array = ((args == null) ? null : args.EvaluateAsArray());
			int num = array.Length;
			object obj = func.Evaluate();
			if (obj == null)
			{
				return true;
			}
			if (num == 0)
			{
				return true;
			}
			Type type = obj.GetType();
			MethodInfo method = type.GetMethod("op_Delete", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[2]
			{
				type,
				Typeob.ArrayOfObject
			}, null);
			if (method == null || (method.Attributes & MethodAttributes.SpecialName) == 0 || method.ReturnType != Typeob.Boolean)
			{
				return LateBinding.DeleteMember(obj, Convert.ToString(array[num - 1]));
			}
			method = new JSMethodInfo(method);
			return (bool)method.Invoke(null, new object[2] { obj, array });
		}

		internal override object Evaluate()
		{
			if (outParameterCount > 0 && VsaEngine.executeForJSEE)
			{
				throw new JScriptException(JSError.RefParamsNonSupportedInDebugger);
			}
			LateBinding lateBinding = func.EvaluateAsLateBinding();
			object[] array = ((args == null) ? null : args.EvaluateAsArray());
			base.Globals.CallContextStack.Push(new CallContext(context, lateBinding, array));
			try
			{
				object obj = null;
				obj = ((func is CallableExpression callableExpression && callableExpression.expression is Call) ? LateBinding.CallValue(lateBinding.obj, array, isConstructor, inBrackets, base.Engine, callableExpression.GetObject2(), JSBinder.ob, null, null) : lateBinding.Call(array, isConstructor, inBrackets, base.Engine));
				if (outParameterCount > 0)
				{
					int i = 0;
					for (int count = args.count; i < count; i++)
					{
						if (args[i] is AddressOf)
						{
							args[i].SetValue(array[i]);
						}
					}
				}
				return obj;
			}
			catch (TargetInvocationException ex)
			{
				JScriptException ex2;
				if (ex.InnerException is JScriptException)
				{
					ex2 = (JScriptException)ex.InnerException;
					if (ex2.context == null)
					{
						if (ex2.Number == -2146823281)
						{
							ex2.context = func.context;
						}
						else
						{
							ex2.context = context;
						}
					}
				}
				else
				{
					ex2 = new JScriptException(ex.InnerException, context);
				}
				throw ex2;
			}
			catch (JScriptException ex3)
			{
				if (ex3.context == null)
				{
					if (ex3.Number == -2146823281)
					{
						ex3.context = func.context;
					}
					else
					{
						ex3.context = context;
					}
				}
				throw ex3;
			}
			catch (Exception e)
			{
				throw new JScriptException(e, context);
			}
			finally
			{
				base.Globals.CallContextStack.Pop();
			}
		}

		internal void EvaluateIndices()
		{
			argValues = args.EvaluateAsArray();
		}

		internal IdentifierLiteral GetName()
		{
			return new IdentifierLiteral(func.ToString(), func.context);
		}

		internal void GetParameters(ArrayList parameters)
		{
			int i = 0;
			for (int count = args.count; i < count; i++)
			{
				AST aST = args[i];
				parameters.Add(new ParameterDeclaration(aST.context, aST.ToString(), null, null));
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			if (func is Binding)
			{
				return ((Binding)func).InferTypeOfCall(inference_target, isConstructor);
			}
			if (func is ConstantWrapper)
			{
				object value = ((ConstantWrapper)func).value;
				if (value is Type || value is ClassScope || value is TypedArray)
				{
					return (IReflect)value;
				}
			}
			return Typeob.Object;
		}

		private JSLocalField[] LocalsThatWereOutParameters()
		{
			int num = outParameterCount;
			if (num == 0)
			{
				return null;
			}
			JSLocalField[] array = new JSLocalField[num];
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				AST aST = args[i];
				if (aST is AddressOf)
				{
					FieldInfo field = ((AddressOf)aST).GetField();
					if (field is JSLocalField)
					{
						array[num2++] = (JSLocalField)field;
					}
				}
			}
			return array;
		}

		internal void MakeDeletable()
		{
			if (func is Binding)
			{
				Binding binding = (Binding)func;
				binding.InvalidateBinding();
				binding.PartiallyEvaluateAsCallable();
				binding.ResolveLHValue();
			}
		}

		internal override AST PartiallyEvaluate()
		{
			if (alreadyPartiallyEvaluated)
			{
				return this;
			}
			alreadyPartiallyEvaluated = true;
			if (inBrackets && AllParamsAreMissing())
			{
				if (isConstructor)
				{
					args.context.HandleError(JSError.TypeMismatch);
				}
				IReflect elementType = ((TypeExpression)new TypeExpression(func).PartiallyEvaluate()).ToIReflect();
				return new ConstantWrapper(new TypedArray(elementType, args.count + 1), context);
			}
			func = func.PartiallyEvaluateAsCallable();
			args = (ASTList)args.PartiallyEvaluate();
			IReflect[] array = ArgIRs();
			func.ResolveCall(args, array, isConstructor, inBrackets);
			if (!isConstructor && !inBrackets && func is Binding && args.count == 1)
			{
				Binding binding = (Binding)func;
				if (binding.member is Type)
				{
					Type type = (Type)binding.member;
					if (args[0] is ConstantWrapper constantWrapper)
					{
						try
						{
							if (constantWrapper.value == null || constantWrapper.value is DBNull)
							{
								return this;
							}
							if (constantWrapper.isNumericLiteral && (type == Typeob.Decimal || type == Typeob.Int64 || type == Typeob.UInt64 || type == Typeob.Single))
							{
								return new ConstantWrapper(Convert.CoerceT(constantWrapper.context.GetCode(), type, explicitOK: true), context);
							}
							return new ConstantWrapper(Convert.CoerceT(constantWrapper.Evaluate(), type, explicitOK: true), context);
						}
						catch
						{
							constantWrapper.context.HandleError(JSError.TypeMismatch);
							return this;
						}
					}
					if (!Binding.AssignmentCompatible(type, args[0], array[0], reportError: false))
					{
						args[0].context.HandleError(JSError.ImpossibleConversion);
					}
				}
				else if (binding.member is JSVariableField)
				{
					JSVariableField jSVariableField = (JSVariableField)binding.member;
					if (jSVariableField.IsLiteral)
					{
						if (jSVariableField.value is ClassScope)
						{
							ClassScope classScope = (ClassScope)jSVariableField.value;
							IReflect underlyingTypeIfEnum = classScope.GetUnderlyingTypeIfEnum();
							if (underlyingTypeIfEnum != null)
							{
								if (!Convert.IsPromotableTo(array[0], underlyingTypeIfEnum) && !Convert.IsPromotableTo(underlyingTypeIfEnum, array[0]) && (array[0] != Typeob.String || underlyingTypeIfEnum == classScope))
								{
									args[0].context.HandleError(JSError.ImpossibleConversion);
								}
							}
							else if (!Convert.IsPromotableTo(array[0], classScope) && !Convert.IsPromotableTo(classScope, array[0]))
							{
								args[0].context.HandleError(JSError.ImpossibleConversion);
							}
						}
						else if (jSVariableField.value is TypedArray)
						{
							TypedArray typedArray = (TypedArray)jSVariableField.value;
							if (!Convert.IsPromotableTo(array[0], typedArray) && !Convert.IsPromotableTo(typedArray, array[0]))
							{
								args[0].context.HandleError(JSError.ImpossibleConversion);
							}
						}
					}
				}
			}
			return this;
		}

		internal override AST PartiallyEvaluateAsReference()
		{
			func = func.PartiallyEvaluateAsCallable();
			args = (ASTList)args.PartiallyEvaluate();
			return this;
		}

		internal override void SetPartialValue(AST partial_value)
		{
			if (isConstructor)
			{
				context.HandleError(JSError.IllegalAssignment);
			}
			else if (func is Binding)
			{
				((Binding)func).SetPartialValue(args, ArgIRs(), partial_value, inBrackets);
			}
			else if (func is ThisLiteral)
			{
				((ThisLiteral)func).ResolveAssignmentToDefaultIndexedProperty(args, ArgIRs(), partial_value);
			}
		}

		internal override void SetValue(object value)
		{
			LateBinding lateBinding = func.EvaluateAsLateBinding();
			try
			{
				lateBinding.SetIndexedPropertyValue((argValues != null) ? argValues : args.EvaluateAsArray(), value);
			}
			catch (JScriptException ex)
			{
				if (ex.context == null)
				{
					ex.context = func.context;
				}
				throw ex;
			}
			catch (Exception e)
			{
				throw new JScriptException(e, func.context);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (context.document.debugOn)
			{
				il.Emit(OpCodes.Nop);
			}
			bool flag = true;
			if (enclosingFunctionScope != null && enclosingFunctionScope.owner != null)
			{
				if (func is Binding binding && !enclosingFunctionScope.closuresMightEscape)
				{
					if (binding.member is JSLocalField)
					{
						enclosingFunctionScope.owner.TranslateToILToSaveLocals(il);
					}
					else
					{
						flag = false;
					}
				}
				else
				{
					enclosingFunctionScope.owner.TranslateToILToSaveLocals(il);
				}
			}
			func.TranslateToILCall(il, rtype, args, isConstructor, inBrackets);
			if (flag && enclosingFunctionScope != null && enclosingFunctionScope.owner != null)
			{
				if (outParameterCount == 0)
				{
					enclosingFunctionScope.owner.TranslateToILToRestoreLocals(il);
				}
				else
				{
					enclosingFunctionScope.owner.TranslateToILToRestoreLocals(il, LocalsThatWereOutParameters());
				}
			}
			if (context.document.debugOn)
			{
				il.Emit(OpCodes.Nop);
			}
		}

		internal CustomAttribute ToCustomAttribute()
		{
			return new CustomAttribute(context, func, args);
		}

		internal override void TranslateToILDelete(ILGenerator il, Type rtype)
		{
			IReflect reflect = func.InferType(null);
			Type type = Convert.ToType(reflect);
			func.TranslateToIL(il, type);
			args.TranslateToIL(il, Typeob.ArrayOfObject);
			if (func is Binding)
			{
				MethodInfo methodInfo = ((!(reflect is ClassScope)) ? reflect.GetMethod("op_Delete", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[2]
				{
					type,
					Typeob.ArrayOfObject
				}, null) : ((ClassScope)reflect).owner.deleteOpMethod);
				if (methodInfo != null && (methodInfo.Attributes & MethodAttributes.SpecialName) != 0 && methodInfo.ReturnType == Typeob.Boolean)
				{
					il.Emit(OpCodes.Call, methodInfo);
					Convert.Emit(this, il, Typeob.Boolean, rtype);
					return;
				}
			}
			ConstantWrapper.TranslateToILInt(il, args.count - 1);
			il.Emit(OpCodes.Ldelem_Ref);
			Convert.Emit(this, il, Typeob.Object, Typeob.String);
			il.Emit(OpCodes.Call, CompilerGlobals.deleteMemberMethod);
			Convert.Emit(this, il, Typeob.Boolean, rtype);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			func.TranslateToILInitializer(il);
			args.TranslateToILInitializer(il);
		}

		internal override void TranslateToILPreSet(ILGenerator il)
		{
			func.TranslateToILPreSet(il, args);
		}

		internal override void TranslateToILPreSet(ILGenerator il, ASTList args)
		{
			isAssignmentToDefaultIndexedProperty = true;
			base.TranslateToILPreSet(il, args);
		}

		internal override void TranslateToILPreSetPlusGet(ILGenerator il)
		{
			func.TranslateToILPreSetPlusGet(il, args, inBrackets);
		}

		internal override void TranslateToILSet(ILGenerator il, AST rhvalue)
		{
			if (isAssignmentToDefaultIndexedProperty)
			{
				base.TranslateToILSet(il, rhvalue);
			}
			else
			{
				func.TranslateToILSet(il, rhvalue);
			}
		}
	}
	internal sealed class CallableExpression : Binding
	{
		internal AST expression;

		private IReflect expressionInferredType;

		internal CallableExpression(AST expression)
			: base(expression.context, "")
		{
			this.expression = expression;
			JSLocalField jSLocalField = new JSLocalField("", null, 0, Missing.Value);
			expressionInferredType = expression.InferType(jSLocalField);
			jSLocalField.inferred_type = expressionInferredType;
			member = jSLocalField;
			members = new MemberInfo[1] { jSLocalField };
		}

		internal override LateBinding EvaluateAsLateBinding()
		{
			return new LateBinding(null, expression.Evaluate(), VsaEngine.executeForJSEE);
		}

		protected override object GetObject()
		{
			return GetObject2();
		}

		internal object GetObject2()
		{
			if (!(expression is Call call) || !call.inBrackets)
			{
				return Convert.ToObject(expression.Evaluate(), base.Engine);
			}
			return Convert.ToObject(call.func.Evaluate(), base.Engine);
		}

		protected override void HandleNoSuchMemberError()
		{
			throw new JScriptException(JSError.InternalError, context);
		}

		internal override AST PartiallyEvaluate()
		{
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			expression.TranslateToIL(il, rtype);
		}

		internal override void TranslateToILCall(ILGenerator il, Type rtype, ASTList argList, bool construct, bool brackets)
		{
			if (defaultMember != null && construct && brackets)
			{
				base.TranslateToILCall(il, rtype, argList, construct, brackets);
				return;
			}
			JSGlobalField jSGlobalField = member as JSGlobalField;
			if (jSGlobalField != null && jSGlobalField.IsLiteral && argList.count == 1)
			{
				Type type = Convert.ToType((IReflect)jSGlobalField.value);
				argList[0].TranslateToIL(il, type);
				Convert.Emit(this, il, type, rtype);
				return;
			}
			TranslateToILWithDupOfThisOb(il);
			argList.TranslateToIL(il, Typeob.ArrayOfObject);
			if (construct)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			if (brackets)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.callValueMethod);
			Convert.Emit(this, il, Typeob.Object, rtype);
		}

		protected override void TranslateToILObject(ILGenerator il, Type obType, bool noValue)
		{
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
			il.Emit(OpCodes.Castclass, Typeob.IActivationObject);
			il.Emit(OpCodes.Callvirt, CompilerGlobals.getGlobalScopeMethod);
		}

		protected override void TranslateToILWithDupOfThisOb(ILGenerator il)
		{
			if (!(expression is Call call) || !call.inBrackets)
			{
				TranslateToILObject(il, null, noValue: false);
			}
			else
			{
				if (call.isConstructor && call.inBrackets)
				{
					call.TranslateToIL(il, Typeob.Object);
					il.Emit(OpCodes.Dup);
					return;
				}
				call.func.TranslateToIL(il, Typeob.Object);
			}
			expression.TranslateToIL(il, Typeob.Object);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			expression.TranslateToILInitializer(il);
			if (!expressionInferredType.Equals(expression.InferType(null)))
			{
				MemberInfo[] array = members;
				InvalidateBinding();
				members = array;
			}
		}
	}
	internal class CallContext
	{
		internal readonly Context sourceContext;

		private readonly LateBinding callee;

		private readonly object[] actual_parameters;

		internal CallContext(Context sourceContext, LateBinding callee, object[] actual_parameters)
		{
			this.sourceContext = sourceContext;
			this.callee = callee;
			this.actual_parameters = actual_parameters;
		}

		internal string FunctionName()
		{
			if (callee == null)
			{
				return "eval";
			}
			return callee.ToString();
		}
	}
	internal class Class : AST
	{
		internal string name;

		private TypeExpression superTypeExpression;

		private TypeExpression[] interfaces;

		internal Block body;

		internal ScriptObject enclosingScope;

		internal TypeAttributes attributes;

		private bool hasAlreadyBeenAskedAboutExpando;

		internal bool isAbstract;

		private bool isAlreadyPartiallyEvaluated;

		private bool isCooked;

		private Type cookedType;

		private bool isExpando;

		internal bool isInterface;

		internal bool isStatic;

		protected bool needsEngine;

		internal AttributeTargets validOn;

		internal bool allowMultiple;

		protected ClassScope classob;

		private FunctionObject implicitDefaultConstructor;

		private JSVariableField ownField;

		protected JSMemberField[] fields;

		private Class superClass;

		private IReflect superIR;

		private object[] superMembers;

		private SimpleHashtable firstIndex;

		private MethodInfo fieldInitializer;

		internal CustomAttributeList customAttributes;

		internal CLSComplianceSpec clsCompliance;

		private bool generateCodeForExpando;

		private PropertyBuilder expandoItemProp;

		private MethodBuilder getHashTableMethod;

		private MethodBuilder getItem;

		private MethodBuilder setItem;

		internal MethodBuilder deleteOpMethod;

		private static int badTypeNameCount;

		internal bool IsStatic
		{
			get
			{
				if (!isStatic)
				{
					return !(enclosingScope is ClassScope);
				}
				return true;
			}
		}

		internal Class(Context context, AST id, TypeExpression superTypeExpression, TypeExpression[] interfaces, Block body, FieldAttributes attributes, bool isAbstract, bool isFinal, bool isStatic, bool isInterface, CustomAttributeList customAttributes)
			: base(context)
		{
			name = id.ToString();
			this.superTypeExpression = superTypeExpression;
			this.interfaces = interfaces;
			this.body = body;
			enclosingScope = (ScriptObject)base.Globals.ScopeStack.Peek(1);
			this.attributes = TypeAttributes.Serializable;
			SetAccessibility(attributes);
			if (isAbstract)
			{
				this.attributes |= TypeAttributes.Abstract;
			}
			this.isAbstract = isAbstract || isInterface;
			isAlreadyPartiallyEvaluated = false;
			if (isFinal)
			{
				this.attributes |= TypeAttributes.Sealed;
			}
			if (isInterface)
			{
				this.attributes |= TypeAttributes.ClassSemanticsMask | TypeAttributes.Abstract;
			}
			isCooked = false;
			cookedType = null;
			isExpando = false;
			this.isInterface = isInterface;
			this.isStatic = isStatic;
			needsEngine = !isInterface;
			validOn = (AttributeTargets)0;
			allowMultiple = true;
			classob = (ClassScope)base.Globals.ScopeStack.Peek();
			classob.name = name;
			classob.owner = this;
			implicitDefaultConstructor = null;
			if (!isInterface && !(this is EnumDeclaration))
			{
				SetupConstructors();
			}
			EnterNameIntoEnclosingScopeAndGetOwnField(id, isStatic);
			fields = classob.GetMemberFields();
			superClass = null;
			superIR = null;
			superMembers = null;
			firstIndex = null;
			fieldInitializer = null;
			this.customAttributes = customAttributes;
			clsCompliance = CLSComplianceSpec.NotAttributed;
			generateCodeForExpando = false;
			expandoItemProp = null;
			getHashTableMethod = null;
			getItem = null;
			setItem = null;
		}

		private void AddImplicitInterfaces(IReflect iface, IReflect[] explicitInterfaces, ArrayList implicitInterfaces)
		{
			Type type = iface as Type;
			if (type != null)
			{
				Type[] array = type.GetInterfaces();
				Type[] array2 = array;
				foreach (Type value in array2)
				{
					if (Array.IndexOf(explicitInterfaces, value, 0) >= 0 || implicitInterfaces.IndexOf(value, 0) >= 0)
					{
						break;
					}
					implicitInterfaces.Add(value);
				}
				return;
			}
			TypeExpression[] array3 = ((ClassScope)iface).owner.interfaces;
			foreach (TypeExpression typeExpression in array3)
			{
				IReflect value2 = typeExpression.ToIReflect();
				if (Array.IndexOf(explicitInterfaces, value2, 0) >= 0 || implicitInterfaces.IndexOf(value2, 0) >= 0)
				{
					break;
				}
				implicitInterfaces.Add(value2);
			}
		}

		private void AllocateImplicitDefaultConstructor()
		{
			implicitDefaultConstructor = new FunctionObject(".ctor", new ParameterDeclaration[0], null, new Block(context), new FunctionScope(classob, isMethod: true), classob, context, MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.VtableLayoutMask, null, isMethod: true);
			implicitDefaultConstructor.isImplicitCtor = true;
			implicitDefaultConstructor.isConstructor = true;
			implicitDefaultConstructor.proto = classob;
		}

		private bool CanSee(MemberInfo member)
		{
			switch (member.MemberType)
			{
			case MemberTypes.Method:
				switch (((MethodBase)member).Attributes & MethodAttributes.MemberAccessMask)
				{
				case MethodAttributes.PrivateScope:
				case MethodAttributes.Private:
				case MethodAttributes.FamANDAssem:
					return false;
				case MethodAttributes.Assembly:
					return IsInTheSamePackage(member);
				default:
					return true;
				}
			case MemberTypes.Field:
				switch (((FieldInfo)member).Attributes & FieldAttributes.FieldAccessMask)
				{
				case FieldAttributes.PrivateScope:
				case FieldAttributes.Private:
				case FieldAttributes.FamANDAssem:
					return false;
				case FieldAttributes.Assembly:
					return IsInTheSamePackage(member);
				default:
					return true;
				}
			case MemberTypes.Property:
			{
				MethodBase methodBase = JSProperty.GetGetMethod((PropertyInfo)member, nonPublic: true);
				if (methodBase == null)
				{
					methodBase = JSProperty.GetSetMethod((PropertyInfo)member, nonPublic: true);
				}
				if (methodBase == null)
				{
					return false;
				}
				switch (methodBase.Attributes & MethodAttributes.MemberAccessMask)
				{
				case MethodAttributes.PrivateScope:
				case MethodAttributes.Private:
				case MethodAttributes.FamANDAssem:
					return false;
				case MethodAttributes.Assembly:
					return IsInTheSamePackage(member);
				default:
					return true;
				}
			}
			case MemberTypes.Event:
			{
				MethodBase addMethod = ((EventInfo)member).GetAddMethod();
				if (addMethod == null)
				{
					return false;
				}
				switch (addMethod.Attributes & MethodAttributes.MemberAccessMask)
				{
				case MethodAttributes.PrivateScope:
				case MethodAttributes.Private:
				case MethodAttributes.FamANDAssem:
					return false;
				case MethodAttributes.Assembly:
					return IsInTheSamePackage(member);
				default:
					return true;
				}
			}
			case MemberTypes.TypeInfo:
			case MemberTypes.NestedType:
				switch (((Type)member).Attributes & TypeAttributes.VisibilityMask)
				{
				case TypeAttributes.NestedPrivate:
				case TypeAttributes.NestedFamANDAssem:
					return false;
				case TypeAttributes.NestedAssembly:
					return IsInTheSamePackage(member);
				default:
					return true;
				}
			default:
				return true;
			}
		}

		private void CheckFieldDeclarationConsistency(JSMemberField field)
		{
			object obj = firstIndex[field.Name];
			if (obj == null)
			{
				return;
			}
			int i = (int)obj;
			for (int num = superMembers.Length; i < num; i++)
			{
				object obj2 = superMembers[i];
				if (!(obj2 is MemberInfo))
				{
					break;
				}
				MemberInfo memberInfo = (MemberInfo)obj2;
				if (!memberInfo.Name.Equals(field.Name))
				{
					break;
				}
				if (CanSee(memberInfo))
				{
					string fullNameFor = GetFullNameFor(memberInfo);
					field.originalContext.HandleError(JSError.HidesParentMember, fullNameFor, IsInTheSameCompilationUnit(memberInfo));
					break;
				}
			}
		}

		private void CheckIfOKToGenerateCodeForExpando(bool superClassIsExpando)
		{
			if (superClassIsExpando)
			{
				context.HandleError(JSError.BaseClassIsExpandoAlready);
				generateCodeForExpando = false;
				return;
			}
			if (classob.GetMember("Item", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic).Length != 0)
			{
				context.HandleError(JSError.ItemNotAllowedOnExpandoClass);
				generateCodeForExpando = false;
				return;
			}
			if (classob.GetMember("get_Item", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic).Length != 0 || classob.GetMember("set_Item", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic).Length != 0)
			{
				context.HandleError(JSError.MethodNotAllowedOnExpandoClass);
				generateCodeForExpando = false;
				return;
			}
			if (ImplementsInterface(Typeob.IEnumerable))
			{
				context.HandleError(JSError.ExpandoClassShouldNotImpleEnumerable);
				generateCodeForExpando = false;
				return;
			}
			if (superIR.GetMember("Item", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length != 0 || superIR.GetMember("get_Item", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length != 0 || superIR.GetMember("set_Item", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length != 0)
			{
				context.HandleError(JSError.MethodClashOnExpandoSuperClass);
				generateCodeForExpando = false;
				return;
			}
			JSProperty jSProperty = (classob.itemProp = new JSProperty("Item"));
			jSProperty.getter = new JSExpandoIndexerMethod(classob, isGetter: true);
			jSProperty.setter = new JSExpandoIndexerMethod(classob, isGetter: false);
			classob.AddNewField("Item", jSProperty, FieldAttributes.Literal);
		}

		private string GetFullName()
		{
			string rootNamespace = ((ActivationObject)enclosingScope).GetName();
			if (rootNamespace == null)
			{
				VsaEngine engine = context.document.engine;
				if (engine != null && engine.genStartupClass)
				{
					rootNamespace = engine.RootNamespace;
				}
			}
			if (rootNamespace != null)
			{
				return rootNamespace + "." + name;
			}
			return name;
		}

		protected void CheckMemberNamesForCLSCompliance()
		{
			if (!(enclosingScope is ClassScope))
			{
				base.Engine.CheckTypeNameForCLSCompliance(name, GetFullName(), context);
			}
			Hashtable hashtable = new Hashtable(StringComparer.OrdinalIgnoreCase);
			int i = 0;
			for (int num = fields.Length; i < num; i++)
			{
				JSMemberField jSMemberField = fields[i];
				if (!jSMemberField.IsPrivate)
				{
					if (!VsaEngine.CheckIdentifierForCLSCompliance(jSMemberField.Name))
					{
						jSMemberField.originalContext.HandleError(JSError.NonCLSCompliantMember);
					}
					else if ((JSMemberField)hashtable[jSMemberField.Name] == null)
					{
						hashtable.Add(jSMemberField.Name, jSMemberField);
					}
					else
					{
						jSMemberField.originalContext.HandleError(JSError.NonCLSCompliantMember);
					}
				}
			}
		}

		private void CheckIfValidExtensionOfSuperType()
		{
			GetIRForSuperType();
			if (superIR is ClassScope classScope)
			{
				if (IsStatic)
				{
					if (!classScope.owner.IsStatic)
					{
						superTypeExpression.context.HandleError(JSError.NestedInstanceTypeCannotBeExtendedByStatic);
						superIR = Typeob.Object;
						superTypeExpression = null;
					}
				}
				else if (!classScope.owner.IsStatic && enclosingScope != classScope.owner.enclosingScope)
				{
					superTypeExpression.context.HandleError(JSError.NestedInstanceTypeCannotBeExtendedByStatic);
					superIR = Typeob.Object;
					superTypeExpression = null;
				}
			}
			GetSuperTypeMembers();
			GetStartIndexForEachName();
			bool flag = NeedsToBeCheckedForCLSCompliance();
			if (flag)
			{
				CheckMemberNamesForCLSCompliance();
			}
			int i = 0;
			for (int num = fields.Length; i < num; i++)
			{
				JSMemberField jSMemberField = fields[i];
				if (!jSMemberField.IsLiteral)
				{
					continue;
				}
				object value = jSMemberField.value;
				if (value is FunctionObject)
				{
					JSMemberField jSMemberField2 = jSMemberField;
					while (true)
					{
						FunctionObject functionObject = (FunctionObject)value;
						if (functionObject.implementedIface == null)
						{
							break;
						}
						CheckMethodDeclarationConsistency(functionObject);
						if (functionObject.implementedIfaceMethod == null)
						{
							functionObject.funcContext.HandleError(JSError.NoMethodInBaseToOverride);
						}
						if (jSMemberField.IsPublic || jSMemberField.IsFamily || jSMemberField.IsFamilyOrAssembly)
						{
							functionObject.CheckCLSCompliance(flag);
						}
						jSMemberField = jSMemberField.nextOverload;
						if (jSMemberField == null)
						{
							break;
						}
						value = jSMemberField.value;
					}
				}
				else
				{
					_ = value is JSProperty;
				}
			}
			int j = 0;
			for (int num2 = fields.Length; j < num2; j++)
			{
				JSMemberField jSMemberField3 = fields[j];
				if (jSMemberField3.IsLiteral)
				{
					object value2 = jSMemberField3.value;
					if (value2 is FunctionObject)
					{
						JSMemberField jSMemberField4 = jSMemberField3;
						while (true)
						{
							FunctionObject functionObject2 = (FunctionObject)value2;
							if (functionObject2.implementedIface != null)
							{
								break;
							}
							CheckMethodDeclarationConsistency(functionObject2);
							if (jSMemberField3.IsPublic || jSMemberField3.IsFamily || jSMemberField3.IsFamilyOrAssembly)
							{
								functionObject2.CheckCLSCompliance(flag);
							}
							jSMemberField3 = jSMemberField3.nextOverload;
							if (jSMemberField3 == null)
							{
								break;
							}
							value2 = jSMemberField3.value;
						}
						continue;
					}
					if (value2 is JSProperty)
					{
						continue;
					}
				}
				CheckFieldDeclarationConsistency(jSMemberField3);
				if (jSMemberField3.IsPublic || jSMemberField3.IsFamily || jSMemberField3.IsFamilyOrAssembly)
				{
					jSMemberField3.CheckCLSCompliance(flag);
				}
			}
		}

		private void CheckMethodDeclarationConsistency(FunctionObject func)
		{
			if ((func.isStatic && !func.isExpandoMethod) || func.isConstructor)
			{
				return;
			}
			object obj = firstIndex[func.name];
			if (obj == null)
			{
				CheckThatMethodIsNotMarkedWithOverrideOrHide(func);
				if ((func.attributes & MethodAttributes.Final) != 0)
				{
					func.attributes &= ~(MethodAttributes.Final | MethodAttributes.Virtual | MethodAttributes.VtableLayoutMask);
				}
				return;
			}
			MemberInfo memberInfo = null;
			int i = (int)obj;
			for (int num = superMembers.Length; i < num; i++)
			{
				MemberInfo memberInfo2 = superMembers[i] as MemberInfo;
				if (memberInfo2 == null)
				{
					continue;
				}
				if (!memberInfo2.Name.Equals(func.name))
				{
					break;
				}
				if (!CanSee(memberInfo2))
				{
					continue;
				}
				if (memberInfo2.MemberType != MemberTypes.Method)
				{
					memberInfo = memberInfo2;
					continue;
				}
				if (func.isExpandoMethod)
				{
					memberInfo = memberInfo2;
					break;
				}
				MethodInfo methodInfo = (MethodInfo)memberInfo2;
				if (func.implementedIface != null)
				{
					if (methodInfo is JSFieldMethod)
					{
						if (((JSFieldMethod)methodInfo).EnclosingScope() != func.implementedIface)
						{
							continue;
						}
					}
					else if (methodInfo.DeclaringType != func.implementedIface)
					{
						continue;
					}
				}
				ParameterInfo[] parameters = methodInfo.GetParameters();
				ParameterInfo[] parameter_declarations = func.parameter_declarations;
				if (!ParametersMatch(parameters, parameter_declarations))
				{
					continue;
				}
				if (methodInfo is JSWrappedMethod)
				{
					methodInfo = ((JSWrappedMethod)methodInfo).method;
				}
				if (func.noVersionSafeAttributeSpecified || (func.attributes & MethodAttributes.VtableLayoutMask) != MethodAttributes.VtableLayoutMask)
				{
					CheckMatchingMethodForConsistency(methodInfo, func, i, num);
				}
				return;
			}
			if (memberInfo != null)
			{
				if (func.noVersionSafeAttributeSpecified || ((func.attributes & MethodAttributes.VtableLayoutMask) != MethodAttributes.VtableLayoutMask && !func.isExpandoMethod))
				{
					string fullNameFor = GetFullNameFor(memberInfo);
					func.funcContext.HandleError(JSError.HidesParentMember, fullNameFor, IsInTheSameCompilationUnit(memberInfo));
				}
			}
			else
			{
				CheckThatMethodIsNotMarkedWithOverrideOrHide(func);
				if ((func.attributes & MethodAttributes.Final) != 0)
				{
					func.attributes &= ~(MethodAttributes.Final | MethodAttributes.Virtual | MethodAttributes.VtableLayoutMask);
				}
			}
		}

		private void CheckMatchingMethodForConsistency(MethodInfo matchingMethod, FunctionObject func, int i, int n)
		{
			IReflect reflect = func.ReturnType(null);
			IReflect reflect2;
			if (!(matchingMethod is JSFieldMethod))
			{
				IReflect returnType = matchingMethod.ReturnType;
				reflect2 = returnType;
			}
			else
			{
				reflect2 = ((JSFieldMethod)matchingMethod).func.ReturnType(null);
			}
			IReflect obj = reflect2;
			if (!reflect.Equals(obj))
			{
				func.funcContext.HandleError(JSError.DifferentReturnTypeFromBase, func.name, treatAsError: true);
				return;
			}
			if (func.implementedIface != null)
			{
				func.implementedIfaceMethod = matchingMethod;
				superMembers[i] = func.name;
				return;
			}
			MethodAttributes methodAttributes = func.attributes & MethodAttributes.MemberAccessMask;
			if ((matchingMethod.Attributes & MethodAttributes.MemberAccessMask) != methodAttributes && ((matchingMethod.Attributes & MethodAttributes.MemberAccessMask) != MethodAttributes.FamORAssem || methodAttributes != MethodAttributes.Family))
			{
				func.funcContext.HandleError(JSError.CannotChangeVisibility);
			}
			if (func.noVersionSafeAttributeSpecified)
			{
				if (base.Engine.versionSafe)
				{
					if ((matchingMethod.Attributes & MethodAttributes.Abstract) != 0)
					{
						func.funcContext.HandleError(JSError.HidesAbstractInBase, name + "." + func.name);
						func.attributes &= ~MethodAttributes.VtableLayoutMask;
					}
					else
					{
						func.funcContext.HandleError(JSError.NewNotSpecifiedInMethodDeclaration, IsInTheSameCompilationUnit(matchingMethod));
						i = -1;
					}
				}
				else if ((matchingMethod.Attributes & MethodAttributes.Virtual) == 0 || (matchingMethod.Attributes & MethodAttributes.Final) != 0)
				{
					i = -1;
				}
				else
				{
					func.attributes &= ~MethodAttributes.VtableLayoutMask;
					if ((matchingMethod.Attributes & MethodAttributes.Abstract) == 0)
					{
						i = -1;
					}
				}
			}
			else if ((func.attributes & MethodAttributes.VtableLayoutMask) == 0)
			{
				if ((matchingMethod.Attributes & MethodAttributes.Virtual) == 0 || (matchingMethod.Attributes & MethodAttributes.Final) != 0)
				{
					func.funcContext.HandleError(JSError.MethodInBaseIsNotVirtual);
					i = -1;
				}
				else
				{
					func.attributes &= ~MethodAttributes.VtableLayoutMask;
					if ((matchingMethod.Attributes & MethodAttributes.Abstract) == 0)
					{
						i = -1;
					}
				}
			}
			else if ((matchingMethod.Attributes & MethodAttributes.Abstract) != 0)
			{
				func.funcContext.HandleError(JSError.HidesAbstractInBase, name + "." + func.name);
				func.attributes &= ~MethodAttributes.VtableLayoutMask;
			}
			else
			{
				i = -1;
			}
			if (i < 0)
			{
				return;
			}
			superMembers[i] = func.name;
			for (int j = i + 1; j < n; j++)
			{
				MemberInfo memberInfo = superMembers[j] as MemberInfo;
				if (memberInfo == null)
				{
					continue;
				}
				if (memberInfo.Name != matchingMethod.Name)
				{
					break;
				}
				MethodInfo methodInfo = memberInfo as MethodInfo;
				if (!(methodInfo == null) && methodInfo.IsAbstract && ParametersMatch(methodInfo.GetParameters(), matchingMethod.GetParameters()))
				{
					IReflect reflect3;
					if (!(matchingMethod is JSFieldMethod))
					{
						IReflect returnType = matchingMethod.ReturnType;
						reflect3 = returnType;
					}
					else
					{
						reflect3 = ((JSFieldMethod)matchingMethod).ReturnIR();
					}
					IReflect reflect4 = reflect3;
					IReflect reflect5;
					if (!(methodInfo is JSFieldMethod))
					{
						IReflect returnType = methodInfo.ReturnType;
						reflect5 = returnType;
					}
					else
					{
						reflect5 = ((JSFieldMethod)methodInfo).ReturnIR();
					}
					IReflect reflect6 = reflect5;
					if (reflect4 == reflect6)
					{
						superMembers[j] = func.name;
					}
				}
			}
		}

		private void CheckThatAllAbstractSuperClassMethodsAreImplemented()
		{
			int i = 0;
			for (int num = superMembers.Length; i < num; i++)
			{
				object obj = superMembers[i];
				MethodInfo methodInfo = obj as MethodInfo;
				if (!(methodInfo != null) || !methodInfo.IsAbstract)
				{
					continue;
				}
				int num2 = i - 1;
				while (true)
				{
					if (num2 >= 0)
					{
						object obj2 = superMembers[num2];
						if (!(obj2 is MethodInfo))
						{
							goto IL_00f3;
						}
						MethodInfo methodInfo2 = (MethodInfo)obj2;
						if (!(methodInfo2.Name != methodInfo.Name))
						{
							if (!methodInfo2.IsAbstract && ParametersMatch(methodInfo2.GetParameters(), methodInfo.GetParameters()))
							{
								IReflect reflect;
								if (!(methodInfo is JSFieldMethod))
								{
									IReflect returnType = methodInfo.ReturnType;
									reflect = returnType;
								}
								else
								{
									reflect = ((JSFieldMethod)methodInfo).ReturnIR();
								}
								IReflect reflect2 = reflect;
								IReflect reflect3;
								if (!(methodInfo2 is JSFieldMethod))
								{
									IReflect returnType = methodInfo2.ReturnType;
									reflect3 = returnType;
								}
								else
								{
									reflect3 = ((JSFieldMethod)methodInfo2).ReturnIR();
								}
								IReflect reflect4 = reflect3;
								if (reflect2 == reflect4)
								{
									superMembers[i] = methodInfo.Name;
									break;
								}
							}
							goto IL_00f3;
						}
					}
					if (isAbstract && (isInterface || !DefinedOnInterface(methodInfo)))
					{
						break;
					}
					StringBuilder stringBuilder = new StringBuilder(methodInfo.DeclaringType.ToString());
					stringBuilder.Append('.');
					stringBuilder.Append(methodInfo.Name);
					stringBuilder.Append('(');
					ParameterInfo[] parameters = methodInfo.GetParameters();
					int j = 0;
					for (int num3 = parameters.Length; j < num3; j++)
					{
						stringBuilder.Append(parameters[j].ParameterType.FullName);
						if (j < num3 - 1)
						{
							stringBuilder.Append(", ");
						}
					}
					stringBuilder.Append(")");
					if (methodInfo.ReturnType != Typeob.Void)
					{
						stringBuilder.Append(" : ");
						stringBuilder.Append(methodInfo.ReturnType.FullName);
					}
					context.HandleError(JSError.MustImplementMethod, stringBuilder.ToString());
					attributes |= TypeAttributes.Abstract;
					break;
					IL_00f3:
					num2--;
				}
			}
		}

		private void CheckThatMethodIsNotMarkedWithOverrideOrHide(FunctionObject func)
		{
			if (!func.noVersionSafeAttributeSpecified)
			{
				if ((func.attributes & MethodAttributes.VtableLayoutMask) == 0)
				{
					func.funcContext.HandleError(JSError.NoMethodInBaseToOverride);
				}
				else
				{
					func.funcContext.HandleError(JSError.NoMethodInBaseToNew);
				}
			}
		}

		private static bool DefinedOnInterface(MethodInfo meth)
		{
			JSFieldMethod jSFieldMethod = meth as JSFieldMethod;
			if (jSFieldMethod != null)
			{
				return ((ClassScope)jSFieldMethod.func.enclosing_scope).owner.isInterface;
			}
			return meth.DeclaringType.IsInterface;
		}

		private void EmitILForINeedEngineMethods()
		{
			if (needsEngine)
			{
				TypeBuilder typeBuilder = (TypeBuilder)classob.classwriter;
				FieldBuilder field = typeBuilder.DefineField("vsa Engine", Typeob.VsaEngine, FieldAttributes.Private | FieldAttributes.NotSerialized);
				MethodBuilder methodBuilder = typeBuilder.DefineMethod("GetEngine", MethodAttributes.Private | MethodAttributes.Virtual, Typeob.VsaEngine, null);
				ILGenerator iLGenerator = methodBuilder.GetILGenerator();
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Ldfld, field);
				iLGenerator.Emit(OpCodes.Ldnull);
				Label label = iLGenerator.DefineLabel();
				iLGenerator.Emit(OpCodes.Bne_Un_S, label);
				iLGenerator.Emit(OpCodes.Ldarg_0);
				if (body.Engine.doCRS)
				{
					iLGenerator.Emit(OpCodes.Ldsfld, CompilerGlobals.contextEngineField);
				}
				else if (context.document.engine.PEFileKind == PEFileKinds.Dll)
				{
					iLGenerator.Emit(OpCodes.Ldtoken, typeBuilder);
					iLGenerator.Emit(OpCodes.Call, CompilerGlobals.createVsaEngineWithType);
				}
				else
				{
					iLGenerator.Emit(OpCodes.Call, CompilerGlobals.createVsaEngine);
				}
				iLGenerator.Emit(OpCodes.Stfld, field);
				iLGenerator.MarkLabel(label);
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Ldfld, field);
				iLGenerator.Emit(OpCodes.Ret);
				typeBuilder.DefineMethodOverride(methodBuilder, CompilerGlobals.getEngineMethod);
				MethodBuilder methodBuilder2 = typeBuilder.DefineMethod("SetEngine", MethodAttributes.Private | MethodAttributes.Virtual, Typeob.Void, new Type[1] { Typeob.VsaEngine });
				iLGenerator = methodBuilder2.GetILGenerator();
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Ldarg_1);
				iLGenerator.Emit(OpCodes.Stfld, field);
				iLGenerator.Emit(OpCodes.Ret);
				typeBuilder.DefineMethodOverride(methodBuilder2, CompilerGlobals.setEngineMethod);
			}
		}

		internal void EmitInitialCalls(ILGenerator il, MethodBase supcons, ParameterInfo[] pars, ASTList argAST, int callerParameterCount)
		{
			bool flag = true;
			if (supcons != null)
			{
				il.Emit(OpCodes.Ldarg_0);
				int num = pars.Length;
				int num2 = argAST?.count ?? 0;
				object[] array = new object[num];
				for (int i = 0; i < num; i++)
				{
					AST aST = ((i < num2) ? argAST[i] : new ConstantWrapper(null, null));
					if (pars[i].ParameterType.IsByRef)
					{
						array[i] = aST.TranslateToILReference(il, pars[i].ParameterType.GetElementType());
						continue;
					}
					aST.TranslateToIL(il, pars[i].ParameterType);
					array[i] = null;
				}
				if (supcons is JSConstructor)
				{
					JSConstructor jSConstructor = (JSConstructor)supcons;
					flag = jSConstructor.GetClassScope() != classob;
					supcons = jSConstructor.GetConstructorInfo(base.compilerGlobals);
					if (jSConstructor.GetClassScope().outerClassField != null)
					{
						Convert.EmitLdarg(il, (short)callerParameterCount);
					}
				}
				il.Emit(OpCodes.Call, (ConstructorInfo)supcons);
				for (int j = 0; j < num2; j++)
				{
					AST aST2 = argAST[j];
					if (aST2 is AddressOf && array[j] != null)
					{
						Type target_type = Convert.ToType(aST2.InferType(null));
						aST2.TranslateToILPreSet(il);
						il.Emit(OpCodes.Ldloc, (LocalBuilder)array[j]);
						Convert.Emit(this, il, pars[j].ParameterType, target_type);
						aST2.TranslateToILSet(il);
					}
				}
			}
			if (classob.outerClassField != null)
			{
				il.Emit(OpCodes.Ldarg_0);
				Convert.EmitLdarg(il, (short)callerParameterCount);
				il.Emit(OpCodes.Stfld, classob.outerClassField);
			}
			if (flag)
			{
				il.Emit(OpCodes.Ldarg_0);
				il.Emit(OpCodes.Call, fieldInitializer);
				body.TranslateToILInitOnlyInitializers(il);
			}
		}

		private void EnterNameIntoEnclosingScopeAndGetOwnField(AST id, bool isStatic)
		{
			if (((IActivationObject)enclosingScope).GetLocalField(name) != null)
			{
				id.context.HandleError(JSError.DuplicateName, treatAsError: true);
				name += " class";
			}
			FieldAttributes fieldAttributes = FieldAttributes.Literal;
			fieldAttributes = (attributes & TypeAttributes.VisibilityMask) switch
			{
				TypeAttributes.NestedAssembly => fieldAttributes | FieldAttributes.Assembly, 
				TypeAttributes.NestedFamANDAssem => fieldAttributes | FieldAttributes.FamANDAssem, 
				TypeAttributes.NestedFamily => fieldAttributes | FieldAttributes.Family, 
				TypeAttributes.VisibilityMask => fieldAttributes | FieldAttributes.FamORAssem, 
				TypeAttributes.NestedPrivate => fieldAttributes | FieldAttributes.Private, 
				_ => fieldAttributes | FieldAttributes.Public, 
			};
			ScriptObject parent = enclosingScope;
			while (parent is BlockScope)
			{
				parent = parent.GetParent();
			}
			if (!(parent is GlobalScope) && !(parent is PackageScope) && !(parent is ClassScope))
			{
				isStatic = false;
				if (this is EnumDeclaration)
				{
					context.HandleError(JSError.EnumNotAllowed);
				}
				else
				{
					context.HandleError(JSError.ClassNotAllowed);
				}
			}
			if (isStatic)
			{
				fieldAttributes |= FieldAttributes.Static;
			}
			if (enclosingScope is ActivationObject)
			{
				if (enclosingScope is ClassScope && name == ((ClassScope)enclosingScope).name)
				{
					context.HandleError(JSError.CannotUseNameOfClass);
					name += " nested class";
				}
				ownField = ((ActivationObject)enclosingScope).AddNewField(name, classob, fieldAttributes);
				if (ownField is JSLocalField)
				{
					((JSLocalField)ownField).isDefined = true;
				}
			}
			else
			{
				ownField = ((StackFrame)enclosingScope).AddNewField(name, classob, fieldAttributes);
			}
			ownField.originalContext = id.context;
		}

		internal override object Evaluate()
		{
			base.Globals.ScopeStack.GuardedPush(classob);
			try
			{
				body.EvaluateStaticVariableInitializers();
			}
			finally
			{
				base.Globals.ScopeStack.Pop();
			}
			return new Completion();
		}

		private void GenerateGetEnumerator()
		{
			TypeBuilder typeBuilder = classob.GetTypeBuilder();
			MethodBuilder methodBuilder = typeBuilder.DefineMethod("get enumerator", MethodAttributes.Private | MethodAttributes.Virtual, Typeob.IEnumerator, null);
			ILGenerator iLGenerator = methodBuilder.GetILGenerator();
			iLGenerator.Emit(OpCodes.Ldarg_0);
			iLGenerator.Emit(OpCodes.Call, getHashTableMethod);
			iLGenerator.Emit(OpCodes.Call, CompilerGlobals.hashTableGetEnumerator);
			iLGenerator.Emit(OpCodes.Ret);
			typeBuilder.DefineMethodOverride(methodBuilder, CompilerGlobals.getEnumeratorMethod);
		}

		private void GetExpandoFieldGetter(TypeBuilder classwriter)
		{
			if (expandoItemProp == null)
			{
				expandoItemProp = classwriter.DefineProperty("Item", PropertyAttributes.None, Typeob.Object, new Type[1] { Typeob.String });
				FieldInfo field = classwriter.DefineField("expando table", Typeob.SimpleHashtable, FieldAttributes.Private);
				getHashTableMethod = classwriter.DefineMethod("get expando table", MethodAttributes.Private, Typeob.SimpleHashtable, null);
				ILGenerator iLGenerator = getHashTableMethod.GetILGenerator();
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Ldfld, field);
				iLGenerator.Emit(OpCodes.Ldnull);
				Label label = iLGenerator.DefineLabel();
				iLGenerator.Emit(OpCodes.Bne_Un_S, label);
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Ldc_I4_8);
				iLGenerator.Emit(OpCodes.Newobj, CompilerGlobals.hashtableCtor);
				iLGenerator.Emit(OpCodes.Stfld, field);
				iLGenerator.MarkLabel(label);
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Ldfld, field);
				iLGenerator.Emit(OpCodes.Ret);
			}
		}

		internal MethodInfo GetExpandoIndexerGetter()
		{
			if (getItem == null)
			{
				TypeBuilder typeBuilder = classob.GetTypeBuilder();
				GetExpandoFieldGetter(typeBuilder);
				getItem = typeBuilder.DefineMethod("get_Item", MethodAttributes.Public | MethodAttributes.SpecialName, Typeob.Object, new Type[1] { Typeob.String });
				ILGenerator iLGenerator = getItem.GetILGenerator();
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Call, getHashTableMethod);
				iLGenerator.Emit(OpCodes.Ldarg_1);
				iLGenerator.Emit(OpCodes.Call, CompilerGlobals.hashtableGetItem);
				iLGenerator.Emit(OpCodes.Dup);
				Label label = iLGenerator.DefineLabel();
				iLGenerator.Emit(OpCodes.Brtrue_S, label);
				iLGenerator.Emit(OpCodes.Pop);
				iLGenerator.Emit(OpCodes.Ldsfld, CompilerGlobals.missingField);
				iLGenerator.MarkLabel(label);
				iLGenerator.Emit(OpCodes.Ret);
				expandoItemProp.SetGetMethod(getItem);
			}
			return getItem;
		}

		internal MethodInfo GetExpandoIndexerSetter()
		{
			if (setItem == null)
			{
				TypeBuilder typeBuilder = classob.GetTypeBuilder();
				GetExpandoFieldGetter(typeBuilder);
				setItem = typeBuilder.DefineMethod("set_Item", MethodAttributes.Public | MethodAttributes.SpecialName, Typeob.Void, new Type[2]
				{
					Typeob.String,
					Typeob.Object
				});
				ILGenerator iLGenerator = setItem.GetILGenerator();
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Call, getHashTableMethod);
				iLGenerator.Emit(OpCodes.Ldarg_2);
				iLGenerator.Emit(OpCodes.Ldsfld, CompilerGlobals.missingField);
				Label label = iLGenerator.DefineLabel();
				iLGenerator.Emit(OpCodes.Beq_S, label);
				iLGenerator.Emit(OpCodes.Ldarg_1);
				iLGenerator.Emit(OpCodes.Ldarg_2);
				iLGenerator.Emit(OpCodes.Call, CompilerGlobals.hashtableSetItem);
				iLGenerator.Emit(OpCodes.Ret);
				iLGenerator.MarkLabel(label);
				iLGenerator.Emit(OpCodes.Ldarg_1);
				iLGenerator.Emit(OpCodes.Call, CompilerGlobals.hashtableRemove);
				iLGenerator.Emit(OpCodes.Ret);
				expandoItemProp.SetSetMethod(setItem);
			}
			return setItem;
		}

		private void GetExpandoDeleteMethod()
		{
			TypeBuilder typeBuilder = classob.GetTypeBuilder();
			MethodBuilder methodBuilder = (deleteOpMethod = typeBuilder.DefineMethod("op_Delete", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, Typeob.Boolean, new Type[2]
			{
				typeBuilder,
				Typeob.ArrayOfObject
			}));
			ParameterBuilder parameterBuilder = methodBuilder.DefineParameter(2, ParameterAttributes.None, null);
			parameterBuilder.SetCustomAttribute(new CustomAttributeBuilder(Typeob.ParamArrayAttribute.GetConstructor(Type.EmptyTypes), new object[0]));
			ILGenerator iLGenerator = methodBuilder.GetILGenerator();
			iLGenerator.Emit(OpCodes.Ldarg_0);
			iLGenerator.Emit(OpCodes.Call, getHashTableMethod);
			iLGenerator.Emit(OpCodes.Ldarg_1);
			iLGenerator.Emit(OpCodes.Dup);
			iLGenerator.Emit(OpCodes.Ldlen);
			iLGenerator.Emit(OpCodes.Ldc_I4_1);
			iLGenerator.Emit(OpCodes.Sub);
			iLGenerator.Emit(OpCodes.Ldelem_Ref);
			iLGenerator.Emit(OpCodes.Call, CompilerGlobals.hashtableRemove);
			iLGenerator.Emit(OpCodes.Ldc_I4_1);
			iLGenerator.Emit(OpCodes.Ret);
		}

		private string GetFullNameFor(MemberInfo supMem)
		{
			string text = ((supMem is JSField) ? ((JSField)supMem).GetClassFullName() : ((supMem is JSConstructor) ? ((JSConstructor)supMem).GetClassFullName() : ((supMem is JSMethod) ? ((JSMethod)supMem).GetClassFullName() : ((supMem is JSProperty) ? ((JSProperty)supMem).GetClassFullName() : ((!(supMem is JSWrappedProperty)) ? supMem.DeclaringType.FullName : ((JSWrappedProperty)supMem).GetClassFullName())))));
			return text + "." + supMem.Name;
		}

		internal MemberInfo[] GetInterfaceMember(string name)
		{
			PartiallyEvaluate();
			if (isInterface)
			{
				MemberInfo[] member = classob.GetMember(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
				if (member != null && member.Length != 0)
				{
					return member;
				}
			}
			TypeExpression[] array = interfaces;
			foreach (TypeExpression typeExpression in array)
			{
				IReflect reflect = typeExpression.ToIReflect();
				MemberInfo[] member = reflect.GetMember(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
				if (member != null && member.Length != 0)
				{
					return member;
				}
			}
			return new MemberInfo[0];
		}

		private void GetIRForSuperType()
		{
			IReflect reflect = (superIR = Typeob.Object);
			if (superTypeExpression != null)
			{
				superTypeExpression.PartiallyEvaluate();
				reflect = (superIR = superTypeExpression.ToIReflect());
			}
			Type type = reflect as Type;
			if (type != null)
			{
				if (type.IsSealed || type.IsInterface || type == Typeob.ValueType || type == Typeob.ArrayObject)
				{
					if (superTypeExpression.Evaluate() is Namespace)
					{
						superTypeExpression.context.HandleError(JSError.NeedType);
					}
					else
					{
						superTypeExpression.context.HandleError(JSError.TypeCannotBeExtended, type.FullName);
					}
					superTypeExpression = null;
					superIR = Typeob.Object;
				}
				else if (Typeob.INeedEngine.IsAssignableFrom(type))
				{
					needsEngine = false;
				}
			}
			else if (reflect is ClassScope)
			{
				if (((ClassScope)reflect).owner.IsASubClassOf(this))
				{
					superTypeExpression.context.HandleError(JSError.CircularDefinition);
					superTypeExpression = null;
					superIR = Typeob.Object;
					return;
				}
				needsEngine = false;
				superClass = ((ClassScope)reflect).owner;
				if ((superClass.attributes & TypeAttributes.Sealed) != 0)
				{
					superTypeExpression.context.HandleError(JSError.TypeCannotBeExtended, superClass.name);
					superClass.attributes &= ~TypeAttributes.Sealed;
					superTypeExpression = null;
				}
				else if (superClass.isInterface)
				{
					superTypeExpression.context.HandleError(JSError.TypeCannotBeExtended, superClass.name);
					superIR = Typeob.Object;
					superTypeExpression = null;
				}
			}
			else
			{
				superTypeExpression.context.HandleError(JSError.TypeCannotBeExtended);
				superIR = Typeob.Object;
				superTypeExpression = null;
			}
		}

		private void GetStartIndexForEachName()
		{
			SimpleHashtable simpleHashtable = new SimpleHashtable(32u);
			string text = null;
			int i = 0;
			for (int num = superMembers.Length; i < num; i++)
			{
				string text2 = ((MemberInfo)superMembers[i]).Name;
				if (text2 != text)
				{
					simpleHashtable[text = text2] = i;
				}
			}
			firstIndex = simpleHashtable;
		}

		internal ConstructorInfo GetSuperConstructor(IReflect[] argIRs)
		{
			object obj = null;
			obj = ((superTypeExpression == null) ? Typeob.Object : superTypeExpression.Evaluate());
			MemberInfo[] constructors;
			if (obj is ClassScope)
			{
				constructors = ((ClassScope)obj).constructors;
				return JSBinder.SelectConstructor(constructors, argIRs);
			}
			constructors = ((Type)obj).GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			return JSBinder.SelectConstructor(constructors, argIRs);
		}

		private void GetSuperTypeMembers()
		{
			SuperTypeMembersSorter superTypeMembersSorter = new SuperTypeMembersSorter();
			IReflect reflect;
			for (reflect = superIR; reflect != null; reflect = ((!(reflect is Type)) ? ((ClassScope)reflect).GetSuperType() : ((Type)reflect).BaseType))
			{
				superTypeMembersSorter.Add(reflect.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic));
			}
			ArrayList arrayList = new ArrayList();
			int num = interfaces.Length;
			IReflect[] array = new IReflect[num];
			for (int i = 0; i < num; i++)
			{
				IReflect reflect2 = (array[i] = interfaces[i].ToIReflect());
				Type type = reflect2 as Type;
				bool flag;
				if (type != null)
				{
					flag = type.IsInterface;
				}
				else
				{
					ClassScope classScope = (ClassScope)reflect2;
					flag = classScope.owner.isInterface;
				}
				if (!flag)
				{
					interfaces[i].context.HandleError(JSError.NeedInterface);
				}
			}
			IReflect[] array2 = array;
			foreach (IReflect iface in array2)
			{
				AddImplicitInterfaces(iface, array, arrayList);
			}
			for (int k = 0; k < arrayList.Count; k++)
			{
				IReflect iface2 = (IReflect)arrayList[k];
				AddImplicitInterfaces(iface2, array, arrayList);
			}
			int count = arrayList.Count;
			if (count > 0)
			{
				TypeExpression[] array3 = new TypeExpression[num + count];
				for (int l = 0; l < num; l++)
				{
					array3[l] = interfaces[l];
				}
				for (int m = 0; m < count; m++)
				{
					array3[m + num] = new TypeExpression(new ConstantWrapper(arrayList[m], null));
				}
				interfaces = array3;
			}
			TypeExpression[] array4 = interfaces;
			foreach (TypeExpression typeExpression in array4)
			{
				if (typeExpression.ToIReflect() is ClassScope classScope2 && classScope2.owner.ImplementsInterface(classob))
				{
					context.HandleError(JSError.CircularDefinition);
					interfaces = new TypeExpression[0];
					break;
				}
				superTypeMembersSorter.Add(typeExpression.ToIReflect().GetMembers(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			}
			reflect = superIR;
			while (reflect != null)
			{
				Type type2 = reflect as Type;
				if (type2 != null)
				{
					if (!type2.IsAbstract)
					{
						break;
					}
					GetUnimplementedInferfaceMembersFor(type2, superTypeMembersSorter);
					reflect = type2.BaseType;
					continue;
				}
				ClassScope classScope3 = (ClassScope)reflect;
				if (!classScope3.owner.isAbstract)
				{
					break;
				}
				classScope3.owner.GetUnimplementedInferfaceMembers(superTypeMembersSorter);
				reflect = null;
			}
			superMembers = superTypeMembersSorter.GetMembers();
		}

		internal TypeBuilder GetTypeBuilder()
		{
			return (TypeBuilder)GetTypeBuilderOrEnumBuilder();
		}

		internal virtual Type GetTypeBuilderOrEnumBuilder()
		{
			if (classob.classwriter != null)
			{
				return classob.classwriter;
			}
			if (!isAlreadyPartiallyEvaluated)
			{
				PartiallyEvaluate();
			}
			Type type = null;
			type = ((superTypeExpression == null) ? (isInterface ? null : Typeob.Object) : superTypeExpression.ToType());
			int num = (needsEngine ? 1 : 0) + (generateCodeForExpando ? 1 : 0);
			int num2 = interfaces.Length + num;
			Type[] array = new Type[num2];
			for (int i = num; i < num2; i++)
			{
				array[i] = interfaces[i - num].ToType();
			}
			if (needsEngine)
			{
				array[--num] = Typeob.INeedEngine;
			}
			if (generateCodeForExpando)
			{
				array[--num] = Typeob.IEnumerable;
			}
			TypeBuilder typeBuilder;
			if (enclosingScope is ClassScope)
			{
				if ((typeBuilder = (TypeBuilder)classob.classwriter) == null)
				{
					TypeBuilder typeBuilder2 = ((ClassScope)enclosingScope).owner.GetTypeBuilder();
					if (classob.classwriter != null)
					{
						return classob.classwriter;
					}
					typeBuilder = typeBuilder2.DefineNestedType(name, attributes, type, array);
					classob.classwriter = typeBuilder;
					if (!isStatic && !isInterface)
					{
						classob.outerClassField = typeBuilder.DefineField("outer class instance", typeBuilder2, FieldAttributes.Private);
					}
				}
			}
			else
			{
				string rootNamespace = ((ActivationObject)enclosingScope).GetName();
				if (rootNamespace == null)
				{
					VsaEngine engine = context.document.engine;
					if (engine != null && engine.genStartupClass)
					{
						rootNamespace = engine.RootNamespace;
					}
				}
				if ((typeBuilder = (TypeBuilder)classob.classwriter) == null)
				{
					string text = name;
					if (rootNamespace != null)
					{
						text = rootNamespace + "." + text;
					}
					if (text.Length >= 1024)
					{
						context.HandleError(JSError.TypeNameTooLong, text);
						text = "bad type name " + badTypeNameCount.ToString(CultureInfo.InvariantCulture);
						badTypeNameCount++;
					}
					typeBuilder = base.compilerGlobals.module.DefineType(text, attributes, type, array);
					classob.classwriter = typeBuilder;
				}
			}
			if (customAttributes != null)
			{
				CustomAttributeBuilder[] customAttributeBuilders = customAttributes.GetCustomAttributeBuilders(getForProperty: false);
				for (int j = 0; j < customAttributeBuilders.Length; j++)
				{
					typeBuilder.SetCustomAttribute(customAttributeBuilders[j]);
				}
			}
			if (clsCompliance == CLSComplianceSpec.CLSCompliant)
			{
				typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(CompilerGlobals.clsCompliantAttributeCtor, new object[1] { true }));
			}
			else if (clsCompliance == CLSComplianceSpec.NonCLSCompliant)
			{
				typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(CompilerGlobals.clsCompliantAttributeCtor, new object[1] { false }));
			}
			if (generateCodeForExpando)
			{
				typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(CompilerGlobals.defaultMemberAttributeCtor, new object[1] { "Item" }));
			}
			int k = 0;
			for (int num3 = fields.Length; k < num3; k++)
			{
				JSMemberField jSMemberField = fields[k];
				if (jSMemberField.IsLiteral)
				{
					object value = jSMemberField.value;
					if (value is JSProperty)
					{
						JSProperty jSProperty = (JSProperty)value;
						ParameterInfo[] indexParameters = jSProperty.GetIndexParameters();
						int num4 = indexParameters.Length;
						Type[] array2 = new Type[num4];
						for (int l = 0; l < num4; l++)
						{
							array2[l] = indexParameters[l].ParameterType;
						}
						PropertyBuilder propertyBuilder = (jSProperty.metaData = typeBuilder.DefineProperty(jSMemberField.Name, jSProperty.Attributes, jSProperty.PropertyType, array2));
						if (jSProperty.getter != null)
						{
							CustomAttributeList customAttributeList = ((JSFieldMethod)jSProperty.getter).func.customAttributes;
							if (customAttributeList != null)
							{
								CustomAttributeBuilder[] customAttributeBuilders2 = customAttributeList.GetCustomAttributeBuilders(getForProperty: true);
								CustomAttributeBuilder[] array3 = customAttributeBuilders2;
								foreach (CustomAttributeBuilder customAttribute in array3)
								{
									propertyBuilder.SetCustomAttribute(customAttribute);
								}
							}
							propertyBuilder.SetGetMethod((MethodBuilder)jSProperty.getter.GetMethodInfo(base.compilerGlobals));
						}
						if (!(jSProperty.setter != null))
						{
							continue;
						}
						CustomAttributeList customAttributeList2 = ((JSFieldMethod)jSProperty.setter).func.customAttributes;
						if (customAttributeList2 != null)
						{
							CustomAttributeBuilder[] customAttributeBuilders3 = customAttributeList2.GetCustomAttributeBuilders(getForProperty: true);
							CustomAttributeBuilder[] array4 = customAttributeBuilders3;
							foreach (CustomAttributeBuilder customAttribute2 in array4)
							{
								propertyBuilder.SetCustomAttribute(customAttribute2);
							}
						}
						propertyBuilder.SetSetMethod((MethodBuilder)jSProperty.setter.GetMethodInfo(base.compilerGlobals));
					}
					else if (value is ClassScope)
					{
						((ClassScope)value).GetTypeBuilderOrEnumBuilder();
					}
					else if (Convert.GetTypeCode(value) != TypeCode.Object)
					{
						FieldBuilder fieldBuilder = typeBuilder.DefineField(jSMemberField.Name, jSMemberField.FieldType, jSMemberField.Attributes);
						fieldBuilder.SetConstant(jSMemberField.value);
						jSMemberField.metaData = fieldBuilder;
						jSMemberField.WriteCustomAttribute(base.Engine.doCRS);
					}
					else
					{
						if (!(value is FunctionObject))
						{
							continue;
						}
						FunctionObject functionObject = (FunctionObject)value;
						if (functionObject.isExpandoMethod)
						{
							jSMemberField.metaData = typeBuilder.DefineField(jSMemberField.Name, Typeob.ScriptFunction, jSMemberField.Attributes & ~(FieldAttributes.Static | FieldAttributes.Literal));
							functionObject.isStatic = false;
						}
						if (!isInterface)
						{
							continue;
						}
						while (true)
						{
							functionObject.GetMethodInfo(base.compilerGlobals);
							jSMemberField = jSMemberField.nextOverload;
							if (jSMemberField == null)
							{
								break;
							}
							functionObject = (FunctionObject)jSMemberField.value;
						}
					}
				}
				else
				{
					jSMemberField.metaData = typeBuilder.DefineField(jSMemberField.Name, jSMemberField.FieldType, jSMemberField.Attributes);
					jSMemberField.WriteCustomAttribute(base.Engine.doCRS);
				}
			}
			return typeBuilder;
		}

		private void GetUnimplementedInferfaceMembers(SuperTypeMembersSorter sorter)
		{
			int i = 0;
			for (int num = superMembers.Length; i < num; i++)
			{
				MethodInfo methodInfo = superMembers[i] as MethodInfo;
				if (methodInfo != null && methodInfo.DeclaringType.IsInterface)
				{
					sorter.Add(methodInfo);
				}
			}
		}

		private static void GetUnimplementedInferfaceMembersFor(Type type, SuperTypeMembersSorter sorter)
		{
			Type[] array = type.GetInterfaces();
			foreach (Type interfaceType in array)
			{
				InterfaceMapping interfaceMap = type.GetInterfaceMap(interfaceType);
				MethodInfo[] interfaceMethods = interfaceMap.InterfaceMethods;
				MethodInfo[] targetMethods = interfaceMap.TargetMethods;
				int j = 0;
				for (int num = interfaceMethods.Length; j < num; j++)
				{
					if (targetMethods[j] == null || targetMethods[j].IsAbstract)
					{
						sorter.Add(interfaceMethods[j]);
					}
				}
			}
		}

		internal bool ImplementsInterface(IReflect iface)
		{
			TypeExpression[] array = interfaces;
			foreach (TypeExpression typeExpression in array)
			{
				IReflect reflect = typeExpression.ToIReflect();
				if (reflect == iface)
				{
					return true;
				}
				if (reflect is ClassScope && ((ClassScope)reflect).ImplementsInterface(iface))
				{
					return true;
				}
				if (reflect is Type && iface is Type && ((Type)iface).IsAssignableFrom((Type)reflect))
				{
					return true;
				}
			}
			return false;
		}

		private bool IsASubClassOf(Class cl)
		{
			if (superTypeExpression != null)
			{
				superTypeExpression.PartiallyEvaluate();
				IReflect reflect = superTypeExpression.ToIReflect();
				if (reflect is ClassScope)
				{
					Class owner = ((ClassScope)reflect).owner;
					if (owner == cl)
					{
						return true;
					}
					return owner.IsASubClassOf(cl);
				}
			}
			return false;
		}

		internal bool IsCustomAttribute()
		{
			GetIRForSuperType();
			if (superIR != Typeob.Attribute)
			{
				return false;
			}
			if (customAttributes == null)
			{
				return false;
			}
			customAttributes.PartiallyEvaluate();
			if (validOn == (AttributeTargets)0)
			{
				return false;
			}
			return true;
		}

		internal bool IsExpando()
		{
			if (hasAlreadyBeenAskedAboutExpando)
			{
				return isExpando;
			}
			if (customAttributes != null)
			{
				customAttributes.PartiallyEvaluate();
				if (customAttributes.GetAttribute(Typeob.Expando) != null)
				{
					generateCodeForExpando = (isExpando = true);
				}
			}
			bool superClassIsExpando = false;
			GetIRForSuperType();
			if (superIR is ClassScope classScope)
			{
				classScope.owner.PartiallyEvaluate();
				if (classScope.owner.IsExpando())
				{
					superClassIsExpando = (isExpando = true);
				}
			}
			else if (CustomAttribute.IsDefined((Type)superIR, typeof(Expando), inherit: true))
			{
				superClassIsExpando = (isExpando = true);
			}
			hasAlreadyBeenAskedAboutExpando = true;
			if (generateCodeForExpando)
			{
				CheckIfOKToGenerateCodeForExpando(superClassIsExpando);
			}
			if (isExpando)
			{
				classob.noExpando = false;
				return true;
			}
			return false;
		}

		private bool IsInTheSameCompilationUnit(MemberInfo member)
		{
			if (!(member is JSField))
			{
				return member is JSMethod;
			}
			return true;
		}

		private bool IsInTheSamePackage(MemberInfo member)
		{
			if (member is JSMethod || member is JSField)
			{
				PackageScope packageScope = null;
				packageScope = ((member is JSMethod) ? ((JSMethod)member).GetPackage() : ((!(member is JSConstructor)) ? ((JSField)member).GetPackage() : ((JSConstructor)member).GetPackage()));
				PackageScope package = classob.GetPackage();
				return package == packageScope;
			}
			return false;
		}

		protected bool NeedsToBeCheckedForCLSCompliance()
		{
			bool result = false;
			clsCompliance = CLSComplianceSpec.NotAttributed;
			if (customAttributes != null)
			{
				CustomAttribute attribute = customAttributes.GetAttribute(Typeob.CLSCompliantAttribute);
				if (attribute != null)
				{
					clsCompliance = attribute.GetCLSComplianceValue();
					result = clsCompliance == CLSComplianceSpec.CLSCompliant;
					customAttributes.Remove(attribute);
				}
			}
			if (clsCompliance == CLSComplianceSpec.CLSCompliant && !base.Engine.isCLSCompliant)
			{
				context.HandleError(JSError.TypeAssemblyCLSCompliantMismatch);
			}
			if (clsCompliance == CLSComplianceSpec.NotAttributed && (attributes & TypeAttributes.Public) != 0)
			{
				result = base.Engine.isCLSCompliant;
			}
			return result;
		}

		internal static bool ParametersMatch(ParameterInfo[] suppars, ParameterInfo[] pars)
		{
			if (suppars.Length != pars.Length)
			{
				return false;
			}
			int i = 0;
			for (int num = pars.Length; i < num; i++)
			{
				IReflect reflect;
				if (!(suppars[i] is ParameterDeclaration))
				{
					IReflect parameterType = suppars[i].ParameterType;
					reflect = parameterType;
				}
				else
				{
					reflect = ((ParameterDeclaration)suppars[i]).ParameterIReflect;
				}
				IReflect obj = reflect;
				IReflect reflect2;
				if (!(pars[i] is ParameterDeclaration))
				{
					IReflect parameterType = pars[i].ParameterType;
					reflect2 = parameterType;
				}
				else
				{
					reflect2 = ((ParameterDeclaration)pars[i]).ParameterIReflect;
				}
				IReflect reflect3 = reflect2;
				if (!reflect3.Equals(obj))
				{
					return false;
				}
			}
			return true;
		}

		internal override AST PartiallyEvaluate()
		{
			if (isAlreadyPartiallyEvaluated)
			{
				return this;
			}
			isAlreadyPartiallyEvaluated = true;
			IsExpando();
			classob.SetParent(new WithObject(enclosingScope, superIR, isSuperType: true));
			base.Globals.ScopeStack.Push(classob);
			try
			{
				body.PartiallyEvaluate();
				if (implicitDefaultConstructor != null)
				{
					implicitDefaultConstructor.PartiallyEvaluate();
				}
			}
			finally
			{
				base.Globals.ScopeStack.Pop();
			}
			JSMemberField[] array = fields;
			foreach (JSMemberField jSMemberField in array)
			{
				jSMemberField.CheckOverloadsForDuplicates();
			}
			CheckIfValidExtensionOfSuperType();
			CheckThatAllAbstractSuperClassMethodsAreImplemented();
			return this;
		}

		private void SetAccessibility(FieldAttributes attributes)
		{
			FieldAttributes fieldAttributes = attributes & FieldAttributes.FieldAccessMask;
			if (enclosingScope is ClassScope)
			{
				switch (fieldAttributes)
				{
				case FieldAttributes.Public:
					this.attributes |= TypeAttributes.NestedPublic;
					break;
				case FieldAttributes.Family:
					this.attributes |= TypeAttributes.NestedFamily;
					break;
				case FieldAttributes.Assembly:
					this.attributes |= TypeAttributes.NestedAssembly;
					break;
				case FieldAttributes.Private:
					this.attributes |= TypeAttributes.NestedPrivate;
					break;
				case FieldAttributes.FamORAssem:
					this.attributes |= TypeAttributes.VisibilityMask;
					break;
				default:
					this.attributes |= TypeAttributes.NestedPublic;
					break;
				}
			}
			else if (fieldAttributes == FieldAttributes.Public || fieldAttributes == FieldAttributes.PrivateScope)
			{
				this.attributes |= TypeAttributes.Public;
			}
		}

		private void SetupConstructors()
		{
			MemberInfo[] member = classob.GetMember(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			if (member == null)
			{
				AllocateImplicitDefaultConstructor();
				FieldInfo fieldInfo = classob.AddNewField(name, implicitDefaultConstructor, FieldAttributes.Literal);
				classob.constructors = new ConstructorInfo[1]
				{
					new JSConstructor(implicitDefaultConstructor)
				};
				return;
			}
			MemberInfo memberInfo = null;
			MemberInfo[] array = member;
			foreach (MemberInfo memberInfo2 in array)
			{
				if (memberInfo2 is JSFieldMethod)
				{
					FunctionObject func = ((JSFieldMethod)memberInfo2).func;
					if (memberInfo == null)
					{
						memberInfo = memberInfo2;
					}
					if (func.return_type_expr != null)
					{
						func.return_type_expr.context.HandleError(JSError.ConstructorMayNotHaveReturnType);
					}
					if ((func.attributes & MethodAttributes.Abstract) != 0 || (func.attributes & MethodAttributes.Static) != 0)
					{
						func.isStatic = false;
						JSVariableField jSVariableField = (JSVariableField)((JSFieldMethod)memberInfo2).field;
						jSVariableField.attributeFlags &= ~FieldAttributes.Static;
						jSVariableField.originalContext.HandleError(JSError.NotValidForConstructor);
					}
					func.return_type_expr = new TypeExpression(new ConstantWrapper(Typeob.Void, context));
					func.own_scope.AddReturnValueField();
				}
			}
			if (memberInfo != null)
			{
				classob.constructors = ((JSMemberField)((JSFieldMethod)memberInfo).field).GetAsConstructors(classob);
				return;
			}
			AllocateImplicitDefaultConstructor();
			classob.constructors = new ConstructorInfo[1]
			{
				new JSConstructor(implicitDefaultConstructor)
			};
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			GetTypeBuilderOrEnumBuilder();
			TranslateToCOMPlusClass();
			object metaData = ownField.GetMetaData();
			if (metaData != null)
			{
				il.Emit(OpCodes.Ldtoken, classob.classwriter);
				il.Emit(OpCodes.Call, CompilerGlobals.getTypeFromHandleMethod);
				if (metaData is LocalBuilder)
				{
					il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
				}
				else
				{
					il.Emit(OpCodes.Stsfld, (FieldInfo)metaData);
				}
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
		}

		private void EmitUsingNamespaces(ILGenerator il)
		{
			if (!body.Engine.GenerateDebugInfo)
			{
				return;
			}
			for (ScriptObject parent = enclosingScope; parent != null; parent = parent.GetParent())
			{
				if (parent is PackageScope)
				{
					il.UsingNamespace(((PackageScope)parent).name);
				}
				else if (parent is WrappedNamespace && !((WrappedNamespace)parent).name.Equals(""))
				{
					il.UsingNamespace(((WrappedNamespace)parent).name);
				}
			}
		}

		private void TranslateToCOMPlusClass()
		{
			if (isCooked)
			{
				return;
			}
			isCooked = true;
			if (this is EnumDeclaration)
			{
				if (!(enclosingScope is ClassScope))
				{
					TranslateToCreateTypeCall();
				}
				return;
			}
			if (superClass != null)
			{
				superClass.TranslateToCOMPlusClass();
			}
			int i = 0;
			for (int num = interfaces.Length; i < num; i++)
			{
				IReflect reflect = interfaces[i].ToIReflect();
				if (reflect is ClassScope)
				{
					((ClassScope)reflect).owner.TranslateToCOMPlusClass();
				}
			}
			base.Globals.ScopeStack.Push(classob);
			TypeBuilder classwriter = base.compilerGlobals.classwriter;
			base.compilerGlobals.classwriter = (TypeBuilder)classob.classwriter;
			if (!isInterface)
			{
				ConstructorBuilder constructorBuilder = base.compilerGlobals.classwriter.DefineTypeInitializer();
				ILGenerator iLGenerator = constructorBuilder.GetILGenerator();
				LocalBuilder local = null;
				if (classob.staticInitializerUsesEval)
				{
					local = iLGenerator.DeclareLocal(Typeob.VsaEngine);
					iLGenerator.Emit(OpCodes.Ldtoken, classob.GetTypeBuilder());
					ConstantWrapper.TranslateToILInt(iLGenerator, 0);
					iLGenerator.Emit(OpCodes.Newarr, Typeob.JSLocalField);
					if (base.Engine.PEFileKind == PEFileKinds.Dll)
					{
						iLGenerator.Emit(OpCodes.Ldtoken, classob.GetTypeBuilder());
						iLGenerator.Emit(OpCodes.Call, CompilerGlobals.createVsaEngineWithType);
					}
					else
					{
						iLGenerator.Emit(OpCodes.Call, CompilerGlobals.createVsaEngine);
					}
					iLGenerator.Emit(OpCodes.Dup);
					iLGenerator.Emit(OpCodes.Stloc, local);
					iLGenerator.Emit(OpCodes.Call, CompilerGlobals.pushStackFrameForStaticMethod);
					iLGenerator.BeginExceptionBlock();
				}
				body.TranslateToILStaticInitializers(iLGenerator);
				if (classob.staticInitializerUsesEval)
				{
					iLGenerator.BeginFinallyBlock();
					iLGenerator.Emit(OpCodes.Ldloc, local);
					iLGenerator.Emit(OpCodes.Call, CompilerGlobals.popScriptObjectMethod);
					iLGenerator.Emit(OpCodes.Pop);
					iLGenerator.EndExceptionBlock();
				}
				iLGenerator.Emit(OpCodes.Ret);
				EmitUsingNamespaces(iLGenerator);
				iLGenerator = ((MethodBuilder)(fieldInitializer = base.compilerGlobals.classwriter.DefineMethod(".init", MethodAttributes.Private, Typeob.Void, new Type[0]))).GetILGenerator();
				if (classob.instanceInitializerUsesEval)
				{
					iLGenerator.Emit(OpCodes.Ldarg_0);
					ConstantWrapper.TranslateToILInt(iLGenerator, 0);
					iLGenerator.Emit(OpCodes.Newarr, Typeob.JSLocalField);
					iLGenerator.Emit(OpCodes.Ldarg_0);
					iLGenerator.Emit(OpCodes.Callvirt, CompilerGlobals.getEngineMethod);
					iLGenerator.Emit(OpCodes.Call, CompilerGlobals.pushStackFrameForMethod);
					iLGenerator.BeginExceptionBlock();
				}
				body.TranslateToILInstanceInitializers(iLGenerator);
				if (classob.instanceInitializerUsesEval)
				{
					iLGenerator.BeginFinallyBlock();
					iLGenerator.Emit(OpCodes.Ldarg_0);
					iLGenerator.Emit(OpCodes.Callvirt, CompilerGlobals.getEngineMethod);
					iLGenerator.Emit(OpCodes.Call, CompilerGlobals.popScriptObjectMethod);
					iLGenerator.Emit(OpCodes.Pop);
					iLGenerator.EndExceptionBlock();
				}
				iLGenerator.Emit(OpCodes.Ret);
				EmitUsingNamespaces(iLGenerator);
				if (implicitDefaultConstructor != null)
				{
					implicitDefaultConstructor.TranslateToIL(base.compilerGlobals);
				}
				if (generateCodeForExpando)
				{
					GetExpandoIndexerGetter();
					GetExpandoIndexerSetter();
					GetExpandoDeleteMethod();
					GenerateGetEnumerator();
				}
				EmitILForINeedEngineMethods();
			}
			if (!(enclosingScope is ClassScope))
			{
				TranslateToCreateTypeCall();
			}
			base.compilerGlobals.classwriter = classwriter;
			base.Globals.ScopeStack.Pop();
		}

		private void TranslateToCreateTypeCall()
		{
			if (cookedType != null)
			{
				return;
			}
			if (this is EnumDeclaration)
			{
				EnumBuilder enumBuilder = classob.classwriter as EnumBuilder;
				if (enumBuilder != null)
				{
					cookedType = enumBuilder.CreateType();
				}
				else
				{
					cookedType = ((TypeBuilder)classob.classwriter).CreateType();
				}
				return;
			}
			if (superClass != null)
			{
				superClass.TranslateToCreateTypeCall();
			}
			AppDomain domain = Thread.GetDomain();
			ResolveEventHandler value = ResolveEnum;
			domain.TypeResolve += value;
			cookedType = ((TypeBuilder)classob.classwriter).CreateType();
			domain.TypeResolve -= value;
			JSMemberField[] array = fields;
			foreach (JSMemberField jSMemberField in array)
			{
				if (jSMemberField.value is ClassScope classScope)
				{
					classScope.owner.TranslateToCreateTypeCall();
				}
			}
		}

		private Assembly ResolveEnum(object sender, ResolveEventArgs args)
		{
			FieldInfo field = classob.GetField(args.Name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			if (field != null && field.IsLiteral && TypeReferences.GetConstantValue(field) is ClassScope classScope)
			{
				classScope.owner.TranslateToCreateTypeCall();
			}
			return base.compilerGlobals.assemblyBuilder;
		}

		internal override Context GetFirstExecutableContext()
		{
			return null;
		}
	}
	internal sealed class ClassScope : ActivationObject, IComparable
	{
		internal string name;

		internal Type classwriter;

		internal Class owner;

		internal ConstructorInfo[] constructors;

		internal bool noExpando;

		internal PackageScope package;

		internal JSProperty itemProp;

		internal FieldInfo outerClassField;

		internal bool inStaticInitializerCode;

		internal bool staticInitializerUsesEval;

		internal bool instanceInitializerUsesEval;

		internal ClassScope(AST name, GlobalScope scope)
			: base(scope)
		{
			this.name = name.ToString();
			engine = scope.engine;
			fast = scope.fast;
			noExpando = true;
			isKnownAtCompileTime = true;
			owner = null;
			ConstructorInfo[] array = (constructors = new JSConstructor[0]);
			ScriptObject scriptObject = engine.ScriptObjectStackTop();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is ClassScope)
			{
				package = ((ClassScope)scriptObject).GetPackage();
			}
			else if (scriptObject is PackageScope)
			{
				package = (PackageScope)scriptObject;
			}
			else
			{
				package = null;
			}
			itemProp = null;
			outerClassField = null;
			inStaticInitializerCode = false;
			staticInitializerUsesEval = false;
			instanceInitializerUsesEval = false;
		}

		internal void AddClassesFromInheritanceChain(string name, ArrayList result)
		{
			IReflect reflect = this;
			bool flag = true;
			while (reflect is ClassScope)
			{
				if (reflect.GetMember(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length != 0)
				{
					result.Add(reflect);
					flag = false;
				}
				reflect = ((!(reflect is ClassScope)) ? ((Type)reflect).BaseType : ((ClassScope)reflect).GetSuperType());
			}
			if (flag && reflect is Type && reflect.GetMember(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length != 0)
			{
				result.Add(reflect);
			}
		}

		internal static ClassScope ScopeOfClassMemberInitializer(ScriptObject scope)
		{
			while (scope != null)
			{
				if (scope is FunctionScope)
				{
					return null;
				}
				if (scope is ClassScope result)
				{
					return result;
				}
				scope = scope.GetParent();
			}
			return null;
		}

		public int CompareTo(object ob)
		{
			if (ob == this)
			{
				return 0;
			}
			if (ob == null)
			{
				return 1;
			}
			ClassScope classScope = ob as ClassScope;
			if (classScope == null)
			{
				return StringComparer.Ordinal.Compare(typeof(ClassScope).AssemblyQualifiedName, classScope.GetType().AssemblyQualifiedName);
			}
			bool flag = IsSameOrDerivedFrom(classScope);
			bool flag2 = classScope.IsSameOrDerivedFrom(this);
			if (flag == flag2)
			{
				return StringComparer.Ordinal.Compare(name, classScope.name);
			}
			if (!flag)
			{
				return 1;
			}
			return -1;
		}

		protected override JSVariableField CreateField(string name, FieldAttributes attributeFlags, object value)
		{
			return new JSMemberField(this, name, value, attributeFlags);
		}

		internal object FakeCallToTypeMethod(MethodInfo method, object[] arguments, Exception e)
		{
			ParameterInfo[] parameters = method.GetParameters();
			int num = parameters.Length;
			Type[] array = new Type[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = parameters[i].ParameterType;
			}
			MethodInfo method2 = typeof(ClassScope).GetMethod(method.Name, array);
			if (method2 != null)
			{
				return method2.Invoke(this, arguments);
			}
			throw e;
		}

		public object[] GetCustomAttributes(bool inherit)
		{
			CustomAttributeList customAttributes = owner.customAttributes;
			if (customAttributes == null)
			{
				return new object[0];
			}
			return (object[])customAttributes.Evaluate();
		}

		public ConstructorInfo[] GetConstructors()
		{
			return constructors;
		}

		public FieldInfo GetField(string name)
		{
			return GetField(name, BindingFlags.Instance | BindingFlags.Public);
		}

		public MethodInfo GetMethod(string name)
		{
			return GetMethod(name, BindingFlags.Instance | BindingFlags.Public);
		}

		public PropertyInfo GetProperty(string name)
		{
			return GetProperty(name, BindingFlags.Instance | BindingFlags.Public);
		}

		internal override object GetDefaultValue(PreferredType preferred_type)
		{
			return GetFullName();
		}

		internal override void GetPropertyEnumerator(ArrayList enums, ArrayList objects)
		{
		}

		internal string GetFullName()
		{
			PackageScope packageScope = GetPackage();
			if (packageScope != null)
			{
				return packageScope.GetName() + "." + name;
			}
			if (owner.enclosingScope is ClassScope)
			{
				return ((ClassScope)owner.enclosingScope).GetFullName() + "." + name;
			}
			return name;
		}

		public override MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
		{
			MemberInfoList memberInfoList = new MemberInfoList();
			FieldInfo fieldInfo = (FieldInfo)name_table[name];
			if (fieldInfo != null)
			{
				if (fieldInfo.IsPublic)
				{
					if ((bindingAttr & BindingFlags.Public) != 0)
					{
						goto IL_0040;
					}
				}
				else if ((bindingAttr & BindingFlags.NonPublic) != 0)
				{
					goto IL_0040;
				}
			}
			goto IL_0139;
			IL_00ec:
			JSProperty jSProperty;
			memberInfoList.Add(jSProperty);
			goto IL_0139;
			IL_011e:
			if (fieldInfo.IsStatic)
			{
				if ((bindingAttr & BindingFlags.Static) != 0)
				{
					goto IL_0132;
				}
			}
			else if ((bindingAttr & BindingFlags.Instance) != 0)
			{
				goto IL_0132;
			}
			goto IL_0139;
			IL_0132:
			memberInfoList.Add(fieldInfo);
			goto IL_0139;
			IL_0040:
			if (!fieldInfo.IsLiteral)
			{
				goto IL_011e;
			}
			object value = ((JSMemberField)fieldInfo).value;
			if (value is FunctionObject)
			{
				FunctionObject functionObject = (FunctionObject)value;
				if (functionObject.isConstructor)
				{
					return new MemberInfo[0];
				}
				if (functionObject.isExpandoMethod)
				{
					if ((bindingAttr & BindingFlags.Instance) != 0)
					{
						memberInfoList.Add(fieldInfo);
					}
				}
				else
				{
					((JSMemberField)fieldInfo).AddOverloadedMembers(memberInfoList, this, bindingAttr | BindingFlags.DeclaredOnly);
				}
			}
			else if (value is JSProperty)
			{
				jSProperty = (JSProperty)value;
				MethodInfo methodInfo = ((jSProperty.getter != null) ? jSProperty.getter : jSProperty.setter);
				if (methodInfo.IsStatic)
				{
					if ((bindingAttr & BindingFlags.Static) != 0)
					{
						goto IL_00ec;
					}
				}
				else if ((bindingAttr & BindingFlags.Instance) != 0)
				{
					goto IL_00ec;
				}
			}
			else
			{
				if (!(value is ClassScope) || (bindingAttr & BindingFlags.Instance) == 0 || ((ClassScope)value).owner.isStatic)
				{
					goto IL_011e;
				}
				memberInfoList.Add(fieldInfo);
			}
			goto IL_0139;
			IL_0139:
			if (owner != null && owner.isInterface && (bindingAttr & BindingFlags.DeclaredOnly) == 0)
			{
				return owner.GetInterfaceMember(name);
			}
			if (parent != null && (bindingAttr & BindingFlags.DeclaredOnly) == 0)
			{
				MemberInfo[] member = parent.GetMember(name, bindingAttr);
				if (member != null)
				{
					MemberInfo[] array = member;
					foreach (MemberInfo memberInfo in array)
					{
						if (memberInfo.MemberType == MemberTypes.Field)
						{
							fieldInfo = (FieldInfo)memberInfo;
							if (!fieldInfo.IsStatic && !fieldInfo.IsLiteral && !(fieldInfo is JSWrappedField))
							{
								fieldInfo = new JSWrappedField(fieldInfo, parent);
							}
							memberInfoList.Add(fieldInfo);
						}
						else
						{
							memberInfoList.Add(ScriptObject.WrapMember(memberInfo, parent));
						}
					}
				}
			}
			return memberInfoList.ToArray();
		}

		internal bool HasInstance(object ob)
		{
			if (!(ob is JSObject))
			{
				return false;
			}
			for (ScriptObject scriptObject = ((JSObject)ob).GetParent(); scriptObject != null; scriptObject = scriptObject.GetParent())
			{
				if (scriptObject == this)
				{
					return true;
				}
				if (scriptObject is WithObject)
				{
					object contained_object = ((WithObject)scriptObject).contained_object;
					if (contained_object == this)
					{
						return true;
					}
				}
			}
			return false;
		}

		internal JSMemberField[] GetMemberFields()
		{
			int count = field_table.Count;
			JSMemberField[] array = new JSMemberField[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = (JSMemberField)field_table[i];
			}
			return array;
		}

		public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
		{
			MemberInfoList memberInfoList = new MemberInfoList();
			IEnumerator enumerator = field_table.GetEnumerator();
			while (enumerator.MoveNext())
			{
				FieldInfo fieldInfo = (FieldInfo)enumerator.Current;
				if (fieldInfo.IsLiteral && fieldInfo is JSMemberField)
				{
					object obj = null;
					if ((obj = ((JSMemberField)fieldInfo).value) is FunctionObject)
					{
						if (!((FunctionObject)obj).isConstructor)
						{
							((JSMemberField)fieldInfo).AddOverloadedMembers(memberInfoList, this, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
						}
					}
					else if (obj is JSProperty)
					{
						memberInfoList.Add((MemberInfo)obj);
					}
					else
					{
						memberInfoList.Add(fieldInfo);
					}
				}
				else
				{
					memberInfoList.Add(fieldInfo);
				}
			}
			if (parent != null)
			{
				memberInfoList.AddRange(parent.GetMembers(bindingAttr));
			}
			return memberInfoList.ToArray();
		}

		internal override string GetName()
		{
			return name;
		}

		internal Type GetBakedSuperType()
		{
			owner.PartiallyEvaluate();
			if (owner is EnumDeclaration)
			{
				return ((EnumDeclaration)owner).baseType.ToType();
			}
			object contained_object = ((WithObject)parent).contained_object;
			if (contained_object is ClassScope)
			{
				return ((ClassScope)contained_object).GetBakedSuperType();
			}
			if (contained_object is Type)
			{
				return (Type)contained_object;
			}
			return Globals.TypeRefs.ToReferenceContext(contained_object.GetType());
		}

		internal PackageScope GetPackage()
		{
			return package;
		}

		internal IReflect GetSuperType()
		{
			owner.PartiallyEvaluate();
			return (IReflect)((WithObject)parent).contained_object;
		}

		internal Type GetTypeBuilderOrEnumBuilder()
		{
			if (classwriter == null)
			{
				classwriter = owner.GetTypeBuilderOrEnumBuilder();
			}
			return classwriter;
		}

		internal TypeBuilder GetTypeBuilder()
		{
			return (TypeBuilder)GetTypeBuilderOrEnumBuilder();
		}

		internal IReflect GetUnderlyingTypeIfEnum()
		{
			if (owner is EnumDeclaration)
			{
				return ((EnumDeclaration)owner.PartiallyEvaluate()).baseType.ToIReflect();
			}
			return this;
		}

		internal bool ImplementsInterface(IReflect iface)
		{
			owner.PartiallyEvaluate();
			object contained_object = ((WithObject)parent).contained_object;
			if (contained_object is ClassScope)
			{
				if (!((ClassScope)contained_object).ImplementsInterface(iface))
				{
					return owner.ImplementsInterface(iface);
				}
				return true;
			}
			if (contained_object is Type && iface is Type)
			{
				if (!((Type)iface).IsAssignableFrom((Type)contained_object))
				{
					return owner.ImplementsInterface(iface);
				}
				return true;
			}
			return owner.ImplementsInterface(iface);
		}

		internal bool IsCLSCompliant()
		{
			owner.PartiallyEvaluate();
			TypeAttributes typeAttributes = owner.attributes & TypeAttributes.VisibilityMask;
			if (typeAttributes != TypeAttributes.Public && typeAttributes != TypeAttributes.NestedPublic)
			{
				return false;
			}
			if (owner.clsCompliance == CLSComplianceSpec.NotAttributed)
			{
				return owner.Engine.isCLSCompliant;
			}
			if (owner.clsCompliance == CLSComplianceSpec.CLSCompliant)
			{
				return true;
			}
			return false;
		}

		internal bool IsNestedIn(ClassScope other, bool isStatic)
		{
			if (parent == null)
			{
				return false;
			}
			owner.PartiallyEvaluate();
			if (owner.enclosingScope == other)
			{
				if (!isStatic)
				{
					return !owner.isStatic;
				}
				return true;
			}
			if (owner.enclosingScope is ClassScope)
			{
				return ((ClassScope)owner.enclosingScope).IsNestedIn(other, isStatic);
			}
			return false;
		}

		internal bool IsSameOrDerivedFrom(ClassScope other)
		{
			if (this == other)
			{
				return true;
			}
			if (other.owner.isInterface)
			{
				return ImplementsInterface(other);
			}
			if (parent == null)
			{
				return false;
			}
			owner.PartiallyEvaluate();
			object contained_object = ((WithObject)parent).contained_object;
			if (contained_object is ClassScope)
			{
				return ((ClassScope)contained_object).IsSameOrDerivedFrom(other);
			}
			return false;
		}

		internal bool IsSameOrDerivedFrom(Type other)
		{
			if (owner.GetTypeBuilder() == other)
			{
				return true;
			}
			if (parent == null)
			{
				return false;
			}
			owner.PartiallyEvaluate();
			object contained_object = ((WithObject)parent).contained_object;
			if (contained_object is ClassScope)
			{
				return ((ClassScope)contained_object).IsSameOrDerivedFrom(other);
			}
			return other.IsAssignableFrom((Type)contained_object);
		}

		internal bool IsPromotableTo(Type other)
		{
			Type bakedSuperType = GetBakedSuperType();
			if (other.IsAssignableFrom(bakedSuperType))
			{
				return true;
			}
			if (other.IsInterface && ImplementsInterface(other))
			{
				return true;
			}
			if (owner is EnumDeclaration enumDeclaration && Convert.IsPromotableTo(enumDeclaration.baseType.ToType(), other))
			{
				return true;
			}
			return false;
		}

		internal bool ParentIsInSamePackage()
		{
			object contained_object = ((WithObject)parent).contained_object;
			if (contained_object is ClassScope)
			{
				return ((ClassScope)contained_object).package == package;
			}
			return false;
		}
	}
	/// <summary>Represents a closure function. This class belongs to the objects and functions category.</summary>
	public sealed class Closure : ScriptFunction
	{
		internal FunctionObject func;

		private ScriptObject enclosing_scope;

		private object declaringObject;

		/// <summary>The arguments to use for the function.</summary>
		public object arguments;

		/// <summary>The calling scope information from the stack frame.</summary>
		public object caller;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Closure" /> class.</summary>
		/// <param name="func">The function that this closure represents.</param>
		public Closure(FunctionObject func)
			: this(func, null)
		{
			if (func.enclosing_scope is StackFrame)
			{
				enclosing_scope = func.enclosing_scope;
			}
		}

		internal Closure(FunctionObject func, object declaringObject)
			: base(func.GetParent(), func.name, func.GetNumberOfFormalParameters())
		{
			this.func = func;
			engine = func.engine;
			proto = new JSPrototypeObject(((ScriptObject)func.proto).GetParent(), this);
			enclosing_scope = engine.ScriptObjectStackTop();
			arguments = DBNull.Value;
			caller = DBNull.Value;
			this.declaringObject = declaringObject;
			noExpando = func.noExpando;
			if (func.isExpandoMethod)
			{
				((StackFrame)(enclosing_scope = new StackFrame(new WithObject(enclosing_scope, declaringObject), new JSLocalField[0], new object[0], null))).closureInstance = declaringObject;
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object Call(object[] args, object thisob)
		{
			return Call(args, thisob, JSBinder.ob, null);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object Call(object[] args, object thisob, Binder binder, CultureInfo culture)
		{
			if (func.isExpandoMethod)
			{
				((StackFrame)enclosing_scope).thisObject = thisob;
			}
			else if (declaringObject != null && !(declaringObject is ClassScope))
			{
				thisob = declaringObject;
			}
			if (thisob == null)
			{
				thisob = ((IActivationObject)engine.ScriptObjectStackTop()).GetDefaultThisObject();
			}
			if (enclosing_scope is ClassScope && declaringObject == null)
			{
				if (thisob is StackFrame)
				{
					thisob = ((StackFrame)thisob).closureInstance;
				}
				if (!func.isStatic && !((ClassScope)enclosing_scope).HasInstance(thisob))
				{
					throw new JScriptException(JSError.InvalidCall);
				}
			}
			return func.Call(args, thisob, enclosing_scope, this, binder, culture);
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		internal Delegate ConvertToDelegate(Type delegateType)
		{
			return Delegate.CreateDelegate(delegateType, declaringObject, func.name);
		}

		/// <summary>Creates a string representation of the function, such as the name of the function or the context.</summary>
		/// <returns>A string representation of the function.</returns>
		public override string ToString()
		{
			return func.ToString();
		}
	}
	internal enum CLSComplianceSpec
	{
		NotAttributed,
		CLSCompliant,
		NonCLSCompliant
	}
	/// <summary>Specifies errors that occur when you run the command-line compiler jsc.exe. This enumeration is used to create <see cref="T:Microsoft.JScript.CmdLineException" /> objects.</summary>
	public enum CmdLineError
	{
		/// <summary>No error. This is the default value.</summary>
		NoError = 0,
		/// <summary>The referenced assembly '{0}' could not be found.</summary>
		AssemblyNotFound = 2001,
		/// <summary>Cannot create JScript engine.</summary>
		CannotCreateEngine = 2002,
		/// <summary>Cannot change value of compiler constant '{0}'.</summary>
		CompilerConstant = 2003,
		/// <summary>Duplicate file name: '{0}' is listed as both a source file and an imported assembly.</summary>
		DuplicateFileAsSourceAndAssembly = 2004,
		/// <summary>Resource file '{0}' referenced more than once.</summary>
		DuplicateResourceFile = 2005,
		/// <summary>Resource name '{0}' is not unique.</summary>
		DuplicateResourceName = 2006,
		/// <summary>Duplicate file name: '{0}' is listed as a source file more than once.</summary>
		DuplicateSourceFile = 2007,
		/// <summary>Error saving compiled state: {0}.</summary>
		ErrorSavingCompiledState = 2008,
		/// <summary>The value of the <see cref="P:System.CodeDom.Compiler.CompilerParameters.GenerateExecutable" /> property is not compatible with target type '{0}'.</summary>
		IncompatibleTargets = 2038,
		/// <summary>'{0}' is not a valid assembly.</summary>
		InvalidAssembly = 2009,
		/// <summary>File name '{0}' contains invalid characters (wildcard characters are not supported).</summary>
		InvalidCharacters = 2036,
		/// <summary>Code page '{0}' is invalid or not installed.</summary>
		InvalidCodePage = 2010,
		/// <summary>Definition '{0}' must be assigned a Boolean or integral value.</summary>
		InvalidDefinition = 2011,
		/// <summary>'{0}' is not allowed in the CompilerOptions field.</summary>
		InvalidForCompilerOptions = 2037,
		/// <summary>Locale ID '{0}' is invalid or not installed.</summary>
		InvalidLocaleID = 2012,
		/// <summary>Platform '{0}' is invalid. Specify 'x86', 'Itanium', 'x64', or 'anycpu'.</summary>
		InvalidPlatform = 2039,
		/// <summary>Target '{0}' is invalid. Specify 'exe' or 'library'.</summary>
		InvalidTarget = 2013,
		/// <summary>'{0}' is not a valid source file.</summary>
		InvalidSourceFile = 2014,
		/// <summary>'{0}' is not a valid version string.</summary>
		InvalidVersion = 2031,
		/// <summary>Invalid warning level specified with option '{0}'.</summary>
		InvalidWarningLevel = 2015,
		/// <summary>Managed resource '{0}' was not found.</summary>
		ManagedResourceNotFound = 2022,
		/// <summary>Missing identifier for '-define:' command-line option.</summary>
		MissingDefineArgument = 2018,
		/// <summary>Missing file extension for '{0}'.</summary>
		MissingExtension = 2019,
		/// <summary>Missing file specification for '-lib:' command-line option.</summary>
		MissingLibArgument = 2020,
		/// <summary>Missing reference in argument list '{0}'.</summary>
		MissingReference = 2034,
		/// <summary>Missing version information in -assembly.version option.</summary>
		MissingVersionInfo = 2021,
		/// <summary>Multiple output file names specified.</summary>
		MultipleOutputNames = 2016,
		/// <summary>Multiple targets specified.</summary>
		MultipleTargets = 2017,
		/// <summary>Cannot specify more than one Win32 resource file.</summary>
		MultipleWin32Resources = 2033,
		/// <summary>Cannot process nested response files.</summary>
		NestedResponseFiles = 2023,
		/// <summary>No code page is specified with option '{0}'.</summary>
		NoCodePage = 2024,
		/// <summary>No file name specified with option '{0}'.</summary>
		NoFileName = 2025,
		/// <summary>No input sources specified.</summary>
		NoInputSourcesSpecified = 2026,
		/// <summary>No Locale ID is specified with option '{0}'.</summary>
		NoLocaleID = 2027,
		/// <summary>No warning level specified with option '{0}'.</summary>
		NoWarningLevel = 2028,
		/// <summary>Win32 resource '{0}' was not found.</summary>
		ResourceNotFound = 2029,
		/// <summary>Source file too big.</summary>
		SourceFileTooBig = 2032,
		/// <summary>Could not find source file '{0}'.</summary>
		SourceNotFound = 2035,
		/// <summary>Unknown option '{0}'.</summary>
		UnknownOption = 2030,
		/// <summary>Unspecified error.</summary>
		Unspecified = 2999,
		/// <summary>A placeholder enumeration member that contains the same value as the last (highest) assigned enumeration value.</summary>
		LAST = 2039
	}
	/// <summary>Represents errors that occur when you run the command-line compiler jsc.exe.</summary>
	[Serializable]
	public class CmdLineException : Exception
	{
		private CmdLineError errorCode;

		private string context;

		private CultureInfo culture;

		private const int LOCALE_USER_DEFAULT = 1024;

		/// <summary>Gets a message that describes the current exception.</summary>
		/// <returns>The error message that explains the reason for the exception.</returns>
		public override string Message
		{
			get
			{
				string key = ResourceKey(errorCode);
				string text = JScriptException.Localize(key, context, culture);
				string text2 = ((int)(10000 + errorCode)).ToString(CultureInfo.InvariantCulture).Substring(1);
				return "fatal error JS" + text2 + ": " + text;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.CmdLineException" /> class, using the specified error code and culture information.</summary>
		/// <param name="errorCode">One of the enumeration values. Specifies what the error is.</param>
		/// <param name="culture">Culture-specific information.</param>
		public CmdLineException(CmdLineError errorCode, CultureInfo culture)
		{
			this.culture = culture;
			this.errorCode = errorCode;
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.CmdLineException" /> class, using the specified error code, context, and culture information.</summary>
		/// <param name="errorCode">One of the enumeration values. Specifies what the error is.</param>
		/// <param name="context">The context in which the error occurred.</param>
		/// <param name="culture">Culture-specific information.</param>
		public CmdLineException(CmdLineError errorCode, string context, CultureInfo culture)
		{
			this.culture = culture;
			this.errorCode = errorCode;
			if (context != "")
			{
				this.context = context;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.CmdLineException" /> class.</summary>
		public CmdLineException()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.CmdLineException" /> class, using the specified error message.</summary>
		/// <param name="m">The message that describes the error.</param>
		public CmdLineException(string m)
			: base(m)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.CmdLineException" /> class, using the specified error message and a reference to the inner exception that is the cause of this exception.</summary>
		/// <param name="m">The message that describes the error.</param>
		/// <param name="e">The exception that is the cause of the current exception, or null if no inner exception is specified.</param>
		public CmdLineException(string m, Exception e)
			: base(m, e)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.CmdLineException" /> class, using serialized data.</summary>
		/// <param name="s">The serialized object data about the exception that is being thrown.</param>
		/// <param name="c">Contextual information about the source or destination.</param>
		protected CmdLineException(SerializationInfo s, StreamingContext c)
			: base(s, c)
		{
			errorCode = (CmdLineError)s.GetInt32("ErrorCode");
			context = s.GetString("Context");
			int @int = s.GetInt32("LCID");
			if (@int != 1024)
			{
				culture = new CultureInfo(@int);
			}
		}

		/// <summary>Stores serialized object data about the exception that is being thrown.</summary>
		/// <param name="s">Serialized object data about the exception that is being thrown.</param>
		/// <param name="c">Contextual information about the source or destination</param>
		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo s, StreamingContext c)
		{
			base.GetObjectData(s, c);
			s.AddValue("ErrorCode", (int)errorCode);
			s.AddValue("Context", context);
			int value = 1024;
			if (culture != null)
			{
				value = culture.LCID;
			}
			s.AddValue("LCID", value);
		}

		/// <summary>Returns the key for the specified error in a resource file.</summary>
		/// <param name="errorCode">One of the enumeration values. Specifies the error to get the key for.</param>
		/// <returns>The key for <paramref name="errorCode" />.</returns>
		public string ResourceKey(CmdLineError errorCode)
		{
			return errorCode switch
			{
				CmdLineError.AssemblyNotFound => "Assembly not found", 
				CmdLineError.CannotCreateEngine => "Cannot create JScript engine", 
				CmdLineError.CompilerConstant => "Compiler constant", 
				CmdLineError.DuplicateFileAsSourceAndAssembly => "Duplicate file as source and assembly", 
				CmdLineError.DuplicateResourceFile => "Duplicate resource file", 
				CmdLineError.DuplicateResourceName => "Duplicate resource name", 
				CmdLineError.DuplicateSourceFile => "Duplicate source file", 
				CmdLineError.ErrorSavingCompiledState => "Error saving compiled state", 
				CmdLineError.IncompatibleTargets => "Incompatible targets", 
				CmdLineError.InvalidAssembly => "Invalid assembly", 
				CmdLineError.InvalidCharacters => "Invalid characters", 
				CmdLineError.InvalidCodePage => "Invalid code page", 
				CmdLineError.InvalidDefinition => "Invalid definition", 
				CmdLineError.InvalidForCompilerOptions => "Invalid for CompilerOptions", 
				CmdLineError.InvalidLocaleID => "Invalid Locale ID", 
				CmdLineError.InvalidPlatform => "Invalid platform", 
				CmdLineError.InvalidTarget => "Invalid target", 
				CmdLineError.InvalidSourceFile => "Invalid source file", 
				CmdLineError.InvalidVersion => "Invalid version", 
				CmdLineError.InvalidWarningLevel => "Invalid warning level", 
				CmdLineError.MultipleOutputNames => "Multiple output filenames", 
				CmdLineError.MultipleTargets => "Multiple targets", 
				CmdLineError.MultipleWin32Resources => "Multiple win32resources", 
				CmdLineError.MissingDefineArgument => "Missing define argument", 
				CmdLineError.MissingExtension => "Missing extension", 
				CmdLineError.MissingLibArgument => "Missing lib argument", 
				CmdLineError.MissingReference => "Missing reference", 
				CmdLineError.ManagedResourceNotFound => "Managed resource not found", 
				CmdLineError.NestedResponseFiles => "Nested response files", 
				CmdLineError.NoCodePage => "No code page", 
				CmdLineError.NoFileName => "No filename", 
				CmdLineError.NoInputSourcesSpecified => "No input sources specified", 
				CmdLineError.NoLocaleID => "No Locale ID", 
				CmdLineError.NoWarningLevel => "No warning level", 
				CmdLineError.ResourceNotFound => "Resource not found", 
				CmdLineError.SourceFileTooBig => "Source file too big", 
				CmdLineError.SourceNotFound => "Source not found", 
				CmdLineError.UnknownOption => "Unknown option", 
				_ => "No description available", 
			};
		}
	}
	/// <summary>Determines whether options that are specified to the command-line compiler jsc.exe are correctly formed, and reads the arguments if any are included.</summary>
	public class CmdLineOptionParser
	{
		/// <summary>Verifies that the specified option is correctly formed.</summary>
		/// <param name="option">The command-line option that the user specified.</param>
		/// <param name="prefix">The option name.</param>
		/// <returns>
		///   <see langword="true" /> if the option is correctly formed; otherwise, <see langword="false" />.</returns>
		public static bool IsSimpleOption(string option, string prefix)
		{
			if (string.Compare(option, prefix, StringComparison.OrdinalIgnoreCase) != 0)
			{
				return false;
			}
			return true;
		}

		/// <summary>Gets the argument from the specified command-line option. Applies to options that have only one name, such as <c>/out:&lt;filename&gt;</c>.</summary>
		/// <param name="option">The command-line option that the user specified.</param>
		/// <param name="prefix">The option name.</param>
		/// <returns>The argument, "" if the argument is not specified, or null if the option or argument is not correctly formed.</returns>
		public static string IsArgumentOption(string option, string prefix)
		{
			int length = prefix.Length;
			if (option.Length < length || string.Compare(option, 0, prefix, 0, length, StringComparison.OrdinalIgnoreCase) != 0)
			{
				return null;
			}
			if (option.Length == length)
			{
				return "";
			}
			if (':' != option[length])
			{
				return null;
			}
			return option.Substring(length + 1);
		}

		/// <summary>Gets the argument from the specified command-line option. Applies to options that can be specified by a short or long form of the option name, such as <c>/r</c> or <c>/reference</c> for <c>/r[eference]:&lt;file list&gt;</c>.</summary>
		/// <param name="option">The command-line option that the user specified.</param>
		/// <param name="shortPrefix">The short form of the option name.</param>
		/// <param name="longPrefix">The long form of the option name.</param>
		/// <returns>The argument, "" if the argument is not specified, or null if the option or argument is not correctly formed.</returns>
		public static string IsArgumentOption(string option, string shortPrefix, string longPrefix)
		{
			string text = IsArgumentOption(option, shortPrefix);
			if (text == null)
			{
				text = IsArgumentOption(option, longPrefix);
			}
			return text;
		}

		/// <summary>Gets the <c>+</c> or <c>-</c> argument from the specified command-line option. Applies to options that have only one name, such as <c>/debug[+|-]</c>.</summary>
		/// <param name="option">The command-line option that the user specified.</param>
		/// <param name="prefix">The option name.</param>
		/// <returns>
		///   <see langword="false" /> for <c>-</c>; <see langword="true" /> for <c>+</c> or if the argument is not specified; null if the option or argument is not correctly formed.</returns>
		public static object IsBooleanOption(string option, string prefix)
		{
			int length = prefix.Length;
			if (option.Length < prefix.Length || string.Compare(option, 0, prefix, 0, length, StringComparison.OrdinalIgnoreCase) != 0)
			{
				return null;
			}
			if (option.Length == length)
			{
				return true;
			}
			if (option.Length != length + 1)
			{
				return null;
			}
			if ('-' == option[length])
			{
				return false;
			}
			if ('+' == option[length])
			{
				return true;
			}
			return null;
		}

		/// <summary>Gets the <c>+</c> or <c>-</c> argument from the specified command-line option. Applies to options that can be specified by a short or long form of the option name.</summary>
		/// <param name="option">The command-line option that the user specified.</param>
		/// <param name="shortPrefix">The short form of the option name.</param>
		/// <param name="longPrefix">The long form of the option name.</param>
		/// <returns>
		///   <see langword="false" /> for <c>-</c>; <see langword="true" /> for <c>+</c> or if the argument is not specified; null if the option or argument is not correctly formed.</returns>
		public static object IsBooleanOption(string option, string shortPrefix, string longPrefix)
		{
			object obj = IsBooleanOption(option, shortPrefix);
			if (obj == null)
			{
				obj = IsBooleanOption(option, longPrefix);
			}
			return obj;
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.CmdLineOptionParser" /> class.</summary>
		public CmdLineOptionParser()
		{
		}
	}
	/// <summary>Defines methods that an external COM object must implement. This interface is used by an external COM implementation to expose its objects to JScript because JScript needs a managed <see cref="T:System.Reflection.MemberInfo" /> to bind to an external object. This interface is implemented by <see cref="T:Microsoft.JScript.COMFieldInfo" />, <see cref="T:Microsoft.JScript.COMMethodInfo" />, and <see cref="T:Microsoft.JScript.COMPropertyInfo" />.</summary>
	[Guid("98A3BF0A-1B56-4f32-ACE0-594FEB27EC48")]
	[ComVisible(true)]
	public interface MemberInfoInitializer
	{
		/// <summary>When implemented in a class, initializes the information that enables JScript to communicate with the specified external COM member.</summary>
		/// <param name="name">The name of the external COM member.</param>
		/// <param name="dispatch">Information that enables JScript to call, get, and set the external COM member.</param>
		void Initialize(string name, COMMemberInfo dispatch);

		/// <summary>When implemented in a class, gets a managed object that enables JScript to communicate with an external COM member.</summary>
		/// <returns>A managed object that enables JScript to communicate with an external COM member.</returns>
		COMMemberInfo GetCOMMemberInfo();
	}
	/// <summary>Defines methods that enable JScript to communicate with an external COM member. This interface is used by an external COM implementation to expose its objects to JScript because JScript requires a managed <see cref="T:System.Reflection.MemberInfo" /> to bind to an external object.</summary>
	[Guid("84BCEB62-16EB-4e1c-975C-FCB40D331043")]
	[ComVisible(true)]
	public interface COMMemberInfo
	{
		/// <summary>When implemented in a class, enables JScript to call an external COM member. Uses the specified binding information.</summary>
		/// <param name="invokeAttr">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">An object that performs type conversion from actual argument type to formal argument type.</param>
		/// <param name="arguments">The argument list to pass to the external COM member.</param>
		/// <param name="culture">Provides information about a specific culture or locale to format numbers, dates, and strings correctly.</param>
		/// <returns>The value of the call to the external COM member.</returns>
		object Call(BindingFlags invokeAttr, Binder binder, object[] arguments, CultureInfo culture);

		/// <summary>When implemented in a class, enables JScript to get the value of an external COM member using the specified binding information.</summary>
		/// <param name="invokeAttr">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">An object that performs type conversion from actual argument type to formal argument type.</param>
		/// <param name="index">The argument list to pass to the external COM member.</param>
		/// <param name="culture">Provides information about a specific culture or locale to format numbers, dates, and strings correctly.</param>
		/// <returns>The value of the external COM member.</returns>
		object GetValue(BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);

		/// <summary>When implemented in a class, enables JScript to set the value of an external COM member to the specified new value, using the specified binding information.</summary>
		/// <param name="value">The new value of the external COM member.</param>
		/// <param name="invokeAttr">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">An object that performs type conversion from actual argument type to formal argument type.</param>
		/// <param name="index">The argument list to pass to the external COM member.</param>
		/// <param name="culture">Provides information about a specific culture or locale to format numbers, dates, and strings correctly.</param>
		void SetValue(object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
	}
	/// <summary>Enables JScript to communicate with an external COM field. This class is used by an external COM implementation to expose its objects to JScript because JScript needs a managed <see cref="T:System.Reflection.MemberInfo" /> in order to bind to an external object.</summary>
	[Guid("CA0F511A-FAF2-4942-B9A8-17D5E46514E8")]
	[ComVisible(true)]
	public class COMFieldInfo : FieldInfo, MemberInfoInitializer
	{
		private COMMemberInfo _comObject;

		private string _name;

		/// <summary>Gets the attributes that are associated with this field.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.FieldAttributes.Public" />
		/// </returns>
		public override FieldAttributes Attributes => FieldAttributes.Public;

		/// <summary>Gets the type that declares this field.</summary>
		/// <returns>null, because the type that declares this field is an external COM object.</returns>
		public override Type DeclaringType => null;

		/// <summary>Throws an <see cref="F:Microsoft.JScript.JSError.InternalError" /> exception in all cases.</summary>
		/// <returns>Throws an <see cref="F:Microsoft.JScript.JSError.InternalError" /> exception in all cases.</returns>
		public override RuntimeFieldHandle FieldHandle
		{
			get
			{
				throw new JScriptException(JSError.InternalError);
			}
		}

		/// <summary>Gets the type of this field.</summary>
		/// <returns>The type of <see cref="T:System.Object" />.</returns>
		public override Type FieldType => typeof(object);

		/// <summary>Gets the type of member that this field is. Identifies the type of class derived from <see cref="T:System.Reflection.MemberInfo" /> that this class derives from.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MemberTypes.Field" />, because this class derives from <see cref="T:System.Reflection.FieldInfo" />.</returns>
		public override MemberTypes MemberType => MemberTypes.Field;

		/// <summary>Gets the name of the external COM field that this object represents.</summary>
		/// <returns>The name of the external COM field that this object represents.</returns>
		public override string Name => _name;

		/// <summary>Gets the class object that was used to obtain this instance through reflection.</summary>
		/// <returns>null, because this instance was not obtained through reflection.</returns>
		public override Type ReflectedType => null;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.COMFieldInfo" /> class.</summary>
		public COMFieldInfo()
		{
			_comObject = null;
			_name = null;
		}

		/// <summary>Gets the value of the external COM field by using the <see cref="T:Microsoft.JScript.COMMemberInfo" /> that was specified to the <see cref="M:Microsoft.JScript.COMFieldInfo.Initialize(System.String,Microsoft.JScript.COMMemberInfo)" /> method.</summary>
		/// <param name="obj">The argument list to pass to the external COM field. This parameter is ignored.</param>
		/// <returns>The value of the external COM field.</returns>
		public override object GetValue(object obj)
		{
			return _comObject.GetValue(BindingFlags.Default, null, new object[0], null);
		}

		/// <summary>Initializes the information that enables JScript to communicate with this external COM field.</summary>
		/// <param name="name">The name of the external COM field that this object represents.</param>
		/// <param name="dispatch">Information that enables JScript to access the external COM field.</param>
		public virtual void Initialize(string name, COMMemberInfo dispatch)
		{
			_name = name;
			_comObject = dispatch;
		}

		/// <summary>Gets a managed object that enables JScript to communicate with this external COM field.</summary>
		/// <returns>A managed object that enables JScript to communicate with this external COM field.</returns>
		public COMMemberInfo GetCOMMemberInfo()
		{
			return _comObject;
		}

		/// <summary>Sets the value of the external COM field by using the <see cref="T:Microsoft.JScript.COMMemberInfo" /> that was specified to the <see cref="M:Microsoft.JScript.COMFieldInfo.Initialize(System.String,Microsoft.JScript.COMMemberInfo)" /> method.</summary>
		/// <param name="obj">The object whose field value will be set. This parameter is ignored.</param>
		/// <param name="value">The new value of the external COM member.</param>
		/// <param name="invokeAttr">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">An object that converts the type from actual argument type to formal argument type.</param>
		/// <param name="culture">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
		{
			_comObject.SetValue(value, invokeAttr, binder, new object[0], culture);
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this field, searching only for attributes of the specified type.</summary>
		/// <param name="t">The type of attribute to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects that has zero elements.</returns>
		public override object[] GetCustomAttributes(Type t, bool inherit)
		{
			return new FieldInfo[0];
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this field.</summary>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects that has zero elements.</returns>
		public override object[] GetCustomAttributes(bool inherit)
		{
			return new FieldInfo[0];
		}

		/// <summary>Determines whether the specified attribute type is attached to this field.</summary>
		/// <param name="t">The attribute type to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>
		///   <see langword="false" /> in all cases.</returns>
		public override bool IsDefined(Type t, bool inherit)
		{
			return false;
		}
	}
	/// <summary>Enables JScript to communicate with an external COM property. This class is used by an external COM implementation to expose its objects to JScript because JScript needs a managed <see cref="T:System.Reflection.MemberInfo" /> in order to bind to an external object.</summary>
	[Guid("6A02951C-B129-4d26-AB92-B9CA19BDCA26")]
	[ComVisible(true)]
	public sealed class COMPropertyInfo : PropertyInfo, MemberInfoInitializer
	{
		private COMMemberInfo _comObject;

		private string _name;

		/// <summary>Gets the attributes that are associated with this property.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.PropertyAttributes.None" />
		/// </returns>
		public override PropertyAttributes Attributes => PropertyAttributes.None;

		/// <summary>Gets a value that indicates whether the property can be read.</summary>
		/// <returns>
		///   <see langword="true" /> in all cases.</returns>
		public override bool CanRead => true;

		/// <summary>Gets a value that indicates whether the property can be written to.</summary>
		/// <returns>
		///   <see langword="true" /> in all cases.</returns>
		public override bool CanWrite => true;

		/// <summary>Gets the type that declares this property.</summary>
		/// <returns>null, because the type that declares this property is an external COM object.</returns>
		public override Type DeclaringType => null;

		/// <summary>Gets the type of member that this property is. Identifies the type of class derived from <see cref="T:System.Reflection.MemberInfo" /> that this class derives from.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MemberTypes.Property" />, because this class derives from <see cref="T:System.Reflection.PropertyInfo" />.</returns>
		public override MemberTypes MemberType => MemberTypes.Property;

		/// <summary>Gets the name of the external COM property that this object represents.</summary>
		/// <returns>The name of the external COM property that this object represents.</returns>
		public override string Name => _name;

		/// <summary>Gets the class object that was used to obtain this instance through reflection.</summary>
		/// <returns>null, because this instance was not obtained through reflection.</returns>
		public override Type ReflectedType => null;

		/// <summary>Gets the type of this property.</summary>
		/// <returns>The type of <see cref="T:System.Object" />.</returns>
		public override Type PropertyType => typeof(object);

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.COMPropertyInfo" /> class.</summary>
		public COMPropertyInfo()
		{
			_comObject = null;
			_name = null;
		}

		/// <summary>Gets an array whose elements contain the get and set accessors of the external COM property that this object represents.</summary>
		/// <param name="nonPublic">
		///   <see langword="true" /> to include non-public accessors.</param>
		/// <returns>A two-element array of <see cref="T:System.Reflection.MethodInfo" /> objects that contains the get and set methods of this property.</returns>
		public override MethodInfo[] GetAccessors(bool nonPublic)
		{
			return new MethodInfo[2]
			{
				GetGetMethod(nonPublic),
				GetSetMethod(nonPublic)
			};
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this property, searching only for attributes of the specified type.</summary>
		/// <param name="t">The type of attribute to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects that has zero elements.</returns>
		public override object[] GetCustomAttributes(Type t, bool inherit)
		{
			return new FieldInfo[0];
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this property.</summary>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects that has zero elements.</returns>
		public override object[] GetCustomAttributes(bool inherit)
		{
			return new FieldInfo[0];
		}

		/// <summary>Returns the get accessor for this property.</summary>
		/// <param name="nonPublic">
		///   <see langword="true" /> to include non-public accessors.</param>
		/// <returns>The get accessor for this property.</returns>
		public override MethodInfo GetGetMethod(bool nonPublic)
		{
			COMGetterMethod cOMGetterMethod = new COMGetterMethod();
			cOMGetterMethod.Initialize(_name, _comObject);
			return cOMGetterMethod;
		}

		/// <summary>Returns an array of all the index parameters for the property.</summary>
		/// <returns>An array of <see cref="T:System.Reflection.ParameterInfo" /> objects that has zero elements.</returns>
		public override ParameterInfo[] GetIndexParameters()
		{
			return new ParameterInfo[0];
		}

		/// <summary>Returns the set accessor for this property.</summary>
		/// <param name="nonPublic">
		///   <see langword="true" /> to include non-public accessors.</param>
		/// <returns>The set accessor for this property.</returns>
		public override MethodInfo GetSetMethod(bool nonPublic)
		{
			COMSetterMethod cOMSetterMethod = new COMSetterMethod();
			cOMSetterMethod.Initialize(_name, _comObject);
			return cOMSetterMethod;
		}

		/// <summary>Gets the value of the external COM property by using the <see cref="T:Microsoft.JScript.COMMemberInfo" /> that was specified to the <see cref="M:Microsoft.JScript.COMPropertyInfo.Initialize(System.String,Microsoft.JScript.COMMemberInfo)" /> method.</summary>
		/// <param name="obj">The object whose property value you want to get. This parameter is ignored.</param>
		/// <param name="invokeAttr">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">An object that converts the type from actual argument type to formal argument type.</param>
		/// <param name="index">The argument list to pass to the external COM property.</param>
		/// <param name="culture">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		/// <returns>The value of the external COM property.</returns>
		public override object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)
		{
			return _comObject.GetValue(invokeAttr, binder, (index != null) ? index : new object[0], culture);
		}

		/// <summary>Initializes the information that enables JScript to communicate with this external COM property.</summary>
		/// <param name="name">The name of the external COM property that this object represents.</param>
		/// <param name="dispatch">Information that enables JScript to access the external COM property.</param>
		public void Initialize(string name, COMMemberInfo dispatch)
		{
			_name = name;
			_comObject = dispatch;
		}

		/// <summary>Gets a managed object that enables JScript to communicate with this external COM property.</summary>
		/// <returns>A managed object that enables JScript to communicate with this external COM property.</returns>
		public COMMemberInfo GetCOMMemberInfo()
		{
			return _comObject;
		}

		/// <summary>Sets the value of the external COM property by using the <see cref="T:Microsoft.JScript.COMMemberInfo" /> that was specified to the <see cref="M:Microsoft.JScript.COMPropertyInfo.Initialize(System.String,Microsoft.JScript.COMMemberInfo)" /> method.</summary>
		/// <param name="obj">The object whose property value will be set. This parameter is ignored.</param>
		/// <param name="value">The new value of the external COM member.</param>
		/// <param name="invokeAttr">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">An object that converts the type from actual argument type to formal argument type.</param>
		/// <param name="index">The argument list to pass to the external COM property.</param>
		/// <param name="culture">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)
		{
			_comObject.SetValue(value, invokeAttr, binder, (index != null) ? index : new object[0], culture);
		}

		/// <summary>Determines whether the specified attribute type is attached to this property.</summary>
		/// <param name="t">The attribute type to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>
		///   <see langword="false" /> in all cases.</returns>
		public override bool IsDefined(Type t, bool inherit)
		{
			return false;
		}
	}
	/// <summary>Enables JScript to communicate with an external COM method. This class is used by an external COM implementation to expose its objects to JScript because JScript needs a managed <see cref="T:System.Reflection.MemberInfo" /> in order to bind to an external object.</summary>
	[Guid("C7B9C313-2FD4-4384-8571-7ABC08BD17E5")]
	[ComVisible(true)]
	public class COMMethodInfo : JSMethod, MemberInfoInitializer
	{
		/// <summary>Stores an array of <see cref="T:System.Reflection.ParameterInfo" /> objects that has zero elements.</summary>
		protected static readonly ParameterInfo[] EmptyParams = new ParameterInfo[0];

		/// <summary>Stores a managed object that enables JScript to communicate with this external COM method.</summary>
		protected COMMemberInfo _comObject;

		/// <summary>Stores the name of the external COM method that this object represents.</summary>
		protected string _name;

		/// <summary>Gets the attributes that are associated with this method.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MethodAttributes.Public" />
		/// </returns>
		public override MethodAttributes Attributes => MethodAttributes.Public;

		/// <summary>Gets the type that declares this method.</summary>
		/// <returns>null, because the type that declares this method is an external COM object.</returns>
		public override Type DeclaringType => null;

		/// <summary>Gets the type of member that this method is. Identifies the type of class derived from <see cref="T:System.Reflection.MemberInfo" /> that this class derives from.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MemberTypes.Method" />, because this class derives from <see cref="T:System.Reflection.MethodInfo" />.</returns>
		public override MemberTypes MemberType => MemberTypes.Method;

		/// <summary>Throws an <see cref="F:Microsoft.JScript.JSError.InternalError" /> exception in all cases.</summary>
		/// <returns>Throws an <see cref="F:Microsoft.JScript.JSError.InternalError" /> exception in all cases.</returns>
		public override RuntimeMethodHandle MethodHandle
		{
			get
			{
				throw new JScriptException(JSError.InternalError);
			}
		}

		/// <summary>Gets the name of the external COM method that this object represents.</summary>
		/// <returns>The name of the external COM method that this object represents.</returns>
		public override string Name => _name;

		/// <summary>Gets the class object that was used to obtain this instance through reflection.</summary>
		/// <returns>null, because this instance was not obtained through reflection.</returns>
		public override Type ReflectedType => null;

		/// <summary>Gets the type of the return value of this method.</summary>
		/// <returns>null in all cases.</returns>
		public override Type ReturnType => null;

		/// <summary>Gets the custom attributes for the type of the return value of this method.</summary>
		/// <returns>null in all cases.</returns>
		public override ICustomAttributeProvider ReturnTypeCustomAttributes => null;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.COMMethodInfo" /> class.</summary>
		public COMMethodInfo()
			: base(null)
		{
			_comObject = null;
			_name = null;
		}

		/// <summary>Initializes the information that enables JScript to communicate with this external COM method.</summary>
		/// <param name="name">The name of the external COM method that this object represents.</param>
		/// <param name="dispatch">Information that enables JScript to access the external COM method.</param>
		public virtual void Initialize(string name, COMMemberInfo dispatch)
		{
			_name = name;
			_comObject = dispatch;
		}

		/// <summary>Gets a managed object that enables JScript to communicate with this external COM method.</summary>
		/// <returns>A managed object that enables JScript to communicate with this external COM method.</returns>
		public COMMemberInfo GetCOMMemberInfo()
		{
			return _comObject;
		}

		/// <summary>Calls the external COM method by using the <see cref="T:Microsoft.JScript.COMMemberInfo" /> that was specified to the <see cref="M:Microsoft.JScript.COMMethodInfo.Initialize(System.String,Microsoft.JScript.COMMemberInfo)" /> method.</summary>
		/// <param name="obj">The object to call the method on. This parameter is ignored.</param>
		/// <param name="invokeAttr">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">An object that converts the type from actual argument type to formal argument type.</param>
		/// <param name="parameters">The argument list to pass to the external COM member.</param>
		/// <param name="culture">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		/// <returns>The return value of the call to the external COM method.</returns>
		public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture)
		{
			return _comObject.Call(invokeAttr, binder, (parameters != null) ? parameters : new object[0], culture);
		}

		/// <summary>Returns the <see cref="T:System.Reflection.MethodInfo" /> object for the method on the direct or indirect base class in which this method was first declared.</summary>
		/// <returns>
		///   <see langword="this" /> in all cases.</returns>
		public override MethodInfo GetBaseDefinition()
		{
			return this;
		}

		/// <summary>Returns information about the implementation of this method.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MethodImplAttributes.Managed" /> and <see cref="F:System.Reflection.MethodImplAttributes.IL" />.</returns>
		public override MethodImplAttributes GetMethodImplementationFlags()
		{
			return MethodImplAttributes.IL;
		}

		/// <summary>Gets the parameters of this external COM method.</summary>
		/// <returns>An array of <see cref="T:System.Reflection.ParameterInfo" /> objects that has zero elements.</returns>
		public override ParameterInfo[] GetParameters()
		{
			return EmptyParams;
		}

		internal override object Construct(object[] args)
		{
			return _comObject.Call(BindingFlags.CreateInstance, null, (args != null) ? args : new object[0], null);
		}

		internal override MethodInfo GetMethodInfo(CompilerGlobals compilerGlobals)
		{
			return null;
		}

		internal override object Invoke(object obj, object thisob, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			return Invoke(thisob, options, binder, parameters, culture);
		}

		/// <summary>Returns a string that represents the current method.</summary>
		/// <returns>An empty string.</returns>
		public override string ToString()
		{
			return "";
		}
	}
	internal class COMGetterMethod : COMMethodInfo
	{
		public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture)
		{
			return _comObject.GetValue(invokeAttr, binder, (parameters != null) ? parameters : new object[0], culture);
		}
	}
	internal class COMSetterMethod : COMMethodInfo
	{
		public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture)
		{
			int num = parameters.Length - 1;
			object value = parameters[num];
			object[] array = null;
			if (num > 0)
			{
				array = new object[num];
				ArrayObject.Copy(parameters, 0, array, 0, num);
			}
			else
			{
				array = new object[0];
			}
			_comObject.SetValue(value, invokeAttr, binder, array, culture);
			return null;
		}
	}
	internal sealed class Comma : BinaryOp
	{
		internal Comma(Context context, AST operand1, AST operand2)
			: base(context, operand1, operand2)
		{
		}

		internal override object Evaluate()
		{
			operand1.Evaluate();
			return operand2.Evaluate();
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return operand2.InferType(inference_target);
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			operand1.TranslateToIL(il, Typeob.Void);
			operand2.TranslateToIL(il, rtype);
		}
	}
	internal sealed class CompilerGlobals
	{
		internal Stack BreakLabelStack = new Stack();

		internal Stack ContinueLabelStack = new Stack();

		internal bool InsideProtectedRegion;

		internal bool InsideFinally;

		internal int FinallyStackTop;

		internal ModuleBuilder module;

		internal AssemblyBuilder assemblyBuilder;

		internal TypeBuilder classwriter;

		internal TypeBuilder globalScopeClassWriter;

		internal SimpleHashtable documents = new SimpleHashtable(8u);

		internal SimpleHashtable usedNames = new SimpleHashtable(32u);

		internal Evidence compilationEvidence;

		internal static MethodInfo constructArrayMethod => Globals.TypeRefs.constructArrayMethod;

		internal static MethodInfo isMissingMethod => Globals.TypeRefs.isMissingMethod;

		internal static ConstructorInfo bitwiseBinaryConstructor => Globals.TypeRefs.bitwiseBinaryConstructor;

		internal static MethodInfo evaluateBitwiseBinaryMethod => Globals.TypeRefs.evaluateBitwiseBinaryMethod;

		internal static ConstructorInfo breakOutOfFinallyConstructor => Globals.TypeRefs.breakOutOfFinallyConstructor;

		internal static ConstructorInfo closureConstructor => Globals.TypeRefs.closureConstructor;

		internal static ConstructorInfo continueOutOfFinallyConstructor => Globals.TypeRefs.continueOutOfFinallyConstructor;

		internal static MethodInfo checkIfDoubleIsIntegerMethod => Globals.TypeRefs.checkIfDoubleIsIntegerMethod;

		internal static MethodInfo checkIfSingleIsIntegerMethod => Globals.TypeRefs.checkIfSingleIsIntegerMethod;

		internal static MethodInfo coerce2Method => Globals.TypeRefs.coerce2Method;

		internal static MethodInfo coerceTMethod => Globals.TypeRefs.coerceTMethod;

		internal static MethodInfo throwTypeMismatch => Globals.TypeRefs.throwTypeMismatch;

		internal static MethodInfo doubleToBooleanMethod => Globals.TypeRefs.doubleToBooleanMethod;

		internal static MethodInfo toBooleanMethod => Globals.TypeRefs.toBooleanMethod;

		internal static MethodInfo toForInObjectMethod => Globals.TypeRefs.toForInObjectMethod;

		internal static MethodInfo toInt32Method => Globals.TypeRefs.toInt32Method;

		internal static MethodInfo toNativeArrayMethod => Globals.TypeRefs.toNativeArrayMethod;

		internal static MethodInfo toNumberMethod => Globals.TypeRefs.toNumberMethod;

		internal static MethodInfo toObjectMethod => Globals.TypeRefs.toObjectMethod;

		internal static MethodInfo toObject2Method => Globals.TypeRefs.toObject2Method;

		internal static MethodInfo doubleToStringMethod => Globals.TypeRefs.doubleToStringMethod;

		internal static MethodInfo toStringMethod => Globals.TypeRefs.toStringMethod;

		internal static FieldInfo undefinedField => Globals.TypeRefs.undefinedField;

		internal static ConstructorInfo equalityConstructor => Globals.TypeRefs.equalityConstructor;

		internal static MethodInfo evaluateEqualityMethod => Globals.TypeRefs.evaluateEqualityMethod;

		internal static MethodInfo jScriptEqualsMethod => Globals.TypeRefs.jScriptEqualsMethod;

		internal static MethodInfo jScriptEvaluateMethod1 => Globals.TypeRefs.jScriptEvaluateMethod1;

		internal static MethodInfo jScriptEvaluateMethod2 => Globals.TypeRefs.jScriptEvaluateMethod2;

		internal static MethodInfo jScriptGetEnumeratorMethod => Globals.TypeRefs.jScriptGetEnumeratorMethod;

		internal static MethodInfo jScriptFunctionDeclarationMethod => Globals.TypeRefs.jScriptFunctionDeclarationMethod;

		internal static MethodInfo jScriptFunctionExpressionMethod => Globals.TypeRefs.jScriptFunctionExpressionMethod;

		internal static FieldInfo contextEngineField => Globals.TypeRefs.contextEngineField;

		internal static MethodInfo fastConstructArrayLiteralMethod => Globals.TypeRefs.fastConstructArrayLiteralMethod;

		internal static ConstructorInfo globalScopeConstructor => Globals.TypeRefs.globalScopeConstructor;

		internal static MethodInfo getDefaultThisObjectMethod => Globals.TypeRefs.getDefaultThisObjectMethod;

		internal static MethodInfo getFieldMethod => Globals.TypeRefs.getFieldMethod;

		internal static MethodInfo getGlobalScopeMethod => Globals.TypeRefs.getGlobalScopeMethod;

		internal static MethodInfo getMemberValueMethod => Globals.TypeRefs.getMemberValueMethod;

		internal static MethodInfo jScriptImportMethod => Globals.TypeRefs.jScriptImportMethod;

		internal static MethodInfo jScriptInMethod => Globals.TypeRefs.jScriptInMethod;

		internal static MethodInfo getEngineMethod => Globals.TypeRefs.getEngineMethod;

		internal static MethodInfo setEngineMethod => Globals.TypeRefs.setEngineMethod;

		internal static MethodInfo jScriptInstanceofMethod => Globals.TypeRefs.jScriptInstanceofMethod;

		internal static ConstructorInfo scriptExceptionConstructor => Globals.TypeRefs.scriptExceptionConstructor;

		internal static ConstructorInfo jsFunctionAttributeConstructor => Globals.TypeRefs.jsFunctionAttributeConstructor;

		internal static ConstructorInfo jsLocalFieldConstructor => Globals.TypeRefs.jsLocalFieldConstructor;

		internal static MethodInfo setMemberValue2Method => Globals.TypeRefs.setMemberValue2Method;

		internal static ConstructorInfo lateBindingConstructor2 => Globals.TypeRefs.lateBindingConstructor2;

		internal static ConstructorInfo lateBindingConstructor => Globals.TypeRefs.lateBindingConstructor;

		internal static FieldInfo objectField => Globals.TypeRefs.objectField;

		internal static MethodInfo callMethod => Globals.TypeRefs.callMethod;

		internal static MethodInfo callValueMethod => Globals.TypeRefs.callValueMethod;

		internal static MethodInfo callValue2Method => Globals.TypeRefs.callValue2Method;

		internal static MethodInfo deleteMethod => Globals.TypeRefs.deleteMethod;

		internal static MethodInfo deleteMemberMethod => Globals.TypeRefs.deleteMemberMethod;

		internal static MethodInfo getNonMissingValueMethod => Globals.TypeRefs.getNonMissingValueMethod;

		internal static MethodInfo getValue2Method => Globals.TypeRefs.getValue2Method;

		internal static MethodInfo setIndexedPropertyValueStaticMethod => Globals.TypeRefs.setIndexedPropertyValueStaticMethod;

		internal static MethodInfo setValueMethod => Globals.TypeRefs.setValueMethod;

		internal static FieldInfo missingField => Globals.TypeRefs.missingField;

		internal static MethodInfo getNamespaceMethod => Globals.TypeRefs.getNamespaceMethod;

		internal static ConstructorInfo numericBinaryConstructor => Globals.TypeRefs.numericBinaryConstructor;

		internal static MethodInfo numericbinaryDoOpMethod => Globals.TypeRefs.numericbinaryDoOpMethod;

		internal static MethodInfo evaluateNumericBinaryMethod => Globals.TypeRefs.evaluateNumericBinaryMethod;

		internal static ConstructorInfo numericUnaryConstructor => Globals.TypeRefs.numericUnaryConstructor;

		internal static MethodInfo evaluateUnaryMethod => Globals.TypeRefs.evaluateUnaryMethod;

		internal static MethodInfo constructObjectMethod => Globals.TypeRefs.constructObjectMethod;

		internal static MethodInfo jScriptPackageMethod => Globals.TypeRefs.jScriptPackageMethod;

		internal static ConstructorInfo plusConstructor => Globals.TypeRefs.plusConstructor;

		internal static MethodInfo plusDoOpMethod => Globals.TypeRefs.plusDoOpMethod;

		internal static MethodInfo evaluatePlusMethod => Globals.TypeRefs.evaluatePlusMethod;

		internal static ConstructorInfo postOrPrefixConstructor => Globals.TypeRefs.postOrPrefixConstructor;

		internal static MethodInfo evaluatePostOrPrefixOperatorMethod => Globals.TypeRefs.evaluatePostOrPrefixOperatorMethod;

		internal static ConstructorInfo referenceAttributeConstructor => Globals.TypeRefs.referenceAttributeConstructor;

		internal static MethodInfo regExpConstructMethod => Globals.TypeRefs.regExpConstructMethod;

		internal static ConstructorInfo relationalConstructor => Globals.TypeRefs.relationalConstructor;

		internal static MethodInfo evaluateRelationalMethod => Globals.TypeRefs.evaluateRelationalMethod;

		internal static MethodInfo jScriptCompareMethod => Globals.TypeRefs.jScriptCompareMethod;

		internal static ConstructorInfo returnOutOfFinallyConstructor => Globals.TypeRefs.returnOutOfFinallyConstructor;

		internal static MethodInfo doubleToInt64 => Globals.TypeRefs.doubleToInt64;

		internal static MethodInfo uncheckedDecimalToInt64Method => Globals.TypeRefs.uncheckedDecimalToInt64Method;

		internal static FieldInfo engineField => Globals.TypeRefs.engineField;

		internal static MethodInfo getParentMethod => Globals.TypeRefs.getParentMethod;

		internal static MethodInfo writeMethod => Globals.TypeRefs.writeMethod;

		internal static MethodInfo writeLineMethod => Globals.TypeRefs.writeLineMethod;

		internal static ConstructorInfo hashtableCtor => Globals.TypeRefs.hashtableCtor;

		internal static MethodInfo hashtableGetItem => Globals.TypeRefs.hashtableGetItem;

		internal static MethodInfo hashTableGetEnumerator => Globals.TypeRefs.hashTableGetEnumerator;

		internal static MethodInfo hashtableRemove => Globals.TypeRefs.hashtableRemove;

		internal static MethodInfo hashtableSetItem => Globals.TypeRefs.hashtableSetItem;

		internal static FieldInfo closureInstanceField => Globals.TypeRefs.closureInstanceField;

		internal static FieldInfo localVarsField => Globals.TypeRefs.localVarsField;

		internal static MethodInfo pushStackFrameForMethod => Globals.TypeRefs.pushStackFrameForMethod;

		internal static MethodInfo pushStackFrameForStaticMethod => Globals.TypeRefs.pushStackFrameForStaticMethod;

		internal static MethodInfo jScriptStrictEqualsMethod => Globals.TypeRefs.jScriptStrictEqualsMethod;

		internal static MethodInfo jScriptThrowMethod => Globals.TypeRefs.jScriptThrowMethod;

		internal static MethodInfo jScriptExceptionValueMethod => Globals.TypeRefs.jScriptExceptionValueMethod;

		internal static MethodInfo jScriptTypeofMethod => Globals.TypeRefs.jScriptTypeofMethod;

		internal static ConstructorInfo vsaEngineConstructor => Globals.TypeRefs.vsaEngineConstructor;

		internal static MethodInfo createVsaEngine => Globals.TypeRefs.createVsaEngine;

		internal static MethodInfo createVsaEngineWithType => Globals.TypeRefs.createVsaEngineWithType;

		internal static MethodInfo getOriginalArrayConstructorMethod => Globals.TypeRefs.getOriginalArrayConstructorMethod;

		internal static MethodInfo getOriginalObjectConstructorMethod => Globals.TypeRefs.getOriginalObjectConstructorMethod;

		internal static MethodInfo getOriginalRegExpConstructorMethod => Globals.TypeRefs.getOriginalRegExpConstructorMethod;

		internal static MethodInfo popScriptObjectMethod => Globals.TypeRefs.popScriptObjectMethod;

		internal static MethodInfo pushScriptObjectMethod => Globals.TypeRefs.pushScriptObjectMethod;

		internal static MethodInfo scriptObjectStackTopMethod => Globals.TypeRefs.scriptObjectStackTopMethod;

		internal static MethodInfo getLenientGlobalObjectMethod => Globals.TypeRefs.getLenientGlobalObjectMethod;

		internal static MethodInfo jScriptWithMethod => Globals.TypeRefs.jScriptWithMethod;

		internal static ConstructorInfo clsCompliantAttributeCtor => Globals.TypeRefs.clsCompliantAttributeCtor;

		internal static MethodInfo getEnumeratorMethod => Globals.TypeRefs.getEnumeratorMethod;

		internal static MethodInfo moveNextMethod => Globals.TypeRefs.moveNextMethod;

		internal static MethodInfo getCurrentMethod => Globals.TypeRefs.getCurrentMethod;

		internal static ConstructorInfo contextStaticAttributeCtor => Globals.TypeRefs.contextStaticAttributeCtor;

		internal static MethodInfo changeTypeMethod => Globals.TypeRefs.changeTypeMethod;

		internal static MethodInfo convertCharToStringMethod => Globals.TypeRefs.convertCharToStringMethod;

		internal static ConstructorInfo dateTimeConstructor => Globals.TypeRefs.dateTimeConstructor;

		internal static MethodInfo dateTimeToStringMethod => Globals.TypeRefs.dateTimeToStringMethod;

		internal static MethodInfo dateTimeToInt64Method => Globals.TypeRefs.dateTimeToInt64Method;

		internal static ConstructorInfo decimalConstructor => Globals.TypeRefs.decimalConstructor;

		internal static FieldInfo decimalZeroField => Globals.TypeRefs.decimalZeroField;

		internal static MethodInfo decimalCompare => Globals.TypeRefs.decimalCompare;

		internal static MethodInfo doubleToDecimalMethod => Globals.TypeRefs.doubleToDecimalMethod;

		internal static MethodInfo int32ToDecimalMethod => Globals.TypeRefs.int32ToDecimalMethod;

		internal static MethodInfo int64ToDecimalMethod => Globals.TypeRefs.int64ToDecimalMethod;

		internal static MethodInfo uint32ToDecimalMethod => Globals.TypeRefs.uint32ToDecimalMethod;

		internal static MethodInfo uint64ToDecimalMethod => Globals.TypeRefs.uint64ToDecimalMethod;

		internal static MethodInfo decimalToDoubleMethod => Globals.TypeRefs.decimalToDoubleMethod;

		internal static MethodInfo decimalToInt32Method => Globals.TypeRefs.decimalToInt32Method;

		internal static MethodInfo decimalToInt64Method => Globals.TypeRefs.decimalToInt64Method;

		internal static MethodInfo decimalToStringMethod => Globals.TypeRefs.decimalToStringMethod;

		internal static MethodInfo decimalToUInt32Method => Globals.TypeRefs.decimalToUInt32Method;

		internal static MethodInfo decimalToUInt64Method => Globals.TypeRefs.decimalToUInt64Method;

		internal static MethodInfo debugBreak => Globals.TypeRefs.debugBreak;

		internal static ConstructorInfo debuggerHiddenAttributeCtor => Globals.TypeRefs.debuggerHiddenAttributeCtor;

		internal static ConstructorInfo debuggerStepThroughAttributeCtor => Globals.TypeRefs.debuggerStepThroughAttributeCtor;

		internal static MethodInfo int32ToStringMethod => Globals.TypeRefs.int32ToStringMethod;

		internal static MethodInfo int64ToStringMethod => Globals.TypeRefs.int64ToStringMethod;

		internal static MethodInfo equalsMethod => Globals.TypeRefs.equalsMethod;

		internal static ConstructorInfo defaultMemberAttributeCtor => Globals.TypeRefs.defaultMemberAttributeCtor;

		internal static MethodInfo getFieldValueMethod => Globals.TypeRefs.getFieldValueMethod;

		internal static MethodInfo setFieldValueMethod => Globals.TypeRefs.setFieldValueMethod;

		internal static FieldInfo systemReflectionMissingField => Globals.TypeRefs.systemReflectionMissingField;

		internal static ConstructorInfo compilerGlobalScopeAttributeCtor => Globals.TypeRefs.compilerGlobalScopeAttributeCtor;

		internal static MethodInfo stringConcatArrMethod => Globals.TypeRefs.stringConcatArrMethod;

		internal static MethodInfo stringConcat4Method => Globals.TypeRefs.stringConcat4Method;

		internal static MethodInfo stringConcat3Method => Globals.TypeRefs.stringConcat3Method;

		internal static MethodInfo stringConcat2Method => Globals.TypeRefs.stringConcat2Method;

		internal static MethodInfo stringEqualsMethod => Globals.TypeRefs.stringEqualsMethod;

		internal static MethodInfo stringLengthMethod => Globals.TypeRefs.stringLengthMethod;

		internal static MethodInfo getMethodMethod => Globals.TypeRefs.getMethodMethod;

		internal static MethodInfo getTypeMethod => Globals.TypeRefs.getTypeMethod;

		internal static MethodInfo getTypeFromHandleMethod => Globals.TypeRefs.getTypeFromHandleMethod;

		internal static MethodInfo uint32ToStringMethod => Globals.TypeRefs.uint32ToStringMethod;

		internal static MethodInfo uint64ToStringMethod => Globals.TypeRefs.uint64ToStringMethod;

		internal CompilerGlobals(VsaEngine engine, string assemName, string assemblyFileName, PEFileKinds PEFileKind, bool save, bool run, bool debugOn, bool isCLSCompliant, Version version, Globals globals)
		{
			string text = null;
			string dir = null;
			if (assemblyFileName != null)
			{
				try
				{
					dir = Path.GetDirectoryName(Path.GetFullPath(assemblyFileName));
				}
				catch (Exception innerException)
				{
					throw new JSVsaException(JSVsaError.AssemblyNameInvalid, assemblyFileName, innerException);
				}
				text = Path.GetFileName(assemblyFileName);
				if (assemName == null || string.Empty == assemName)
				{
					assemName = Path.GetFileName(assemblyFileName);
					if (Path.HasExtension(assemName))
					{
						assemName = assemName.Substring(0, assemName.Length - Path.GetExtension(assemName).Length);
					}
				}
			}
			if (assemName == null || assemName == string.Empty)
			{
				assemName = "JScriptAssembly";
			}
			if (text == null)
			{
				text = ((PEFileKind != PEFileKinds.Dll) ? "JScriptModule.exe" : "JScriptModule.dll");
			}
			AssemblyName assemblyName = new AssemblyName
			{
				CodeBase = assemblyFileName
			};
			if (globals.assemblyCulture != null)
			{
				assemblyName.CultureInfo = globals.assemblyCulture;
			}
			assemblyName.Flags = AssemblyNameFlags.None;
			if ((globals.assemblyFlags & AssemblyFlags.PublicKey) != 0)
			{
				assemblyName.Flags = AssemblyNameFlags.PublicKey;
			}
			switch (globals.assemblyFlags & AssemblyFlags.CompatibilityMask)
			{
			case AssemblyFlags.NonSideBySideAppDomain:
				assemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameDomain;
				break;
			case AssemblyFlags.NonSideBySideMachine:
				assemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameMachine;
				break;
			case AssemblyFlags.NonSideBySideProcess:
				assemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess;
				break;
			default:
				assemblyName.VersionCompatibility = (AssemblyVersionCompatibility)0;
				break;
			}
			assemblyName.HashAlgorithm = globals.assemblyHashAlgorithm;
			if (globals.assemblyKeyFileName != null)
			{
				try
				{
					using FileStream fileStream = new FileStream(globals.assemblyKeyFileName, FileMode.Open, FileAccess.Read);
					StrongNameKeyPair strongNameKeyPair = new StrongNameKeyPair(fileStream);
					if (globals.assemblyDelaySign)
					{
						if (fileStream.Length == 160)
						{
							byte[] array = new byte[160];
							fileStream.Seek(0L, SeekOrigin.Begin);
							int num = fileStream.Read(array, 0, 160);
							assemblyName.SetPublicKey(array);
						}
						else
						{
							assemblyName.SetPublicKey(strongNameKeyPair.PublicKey);
						}
					}
					else
					{
						byte[] publicKey = strongNameKeyPair.PublicKey;
						assemblyName.KeyPair = strongNameKeyPair;
					}
				}
				catch
				{
					globals.assemblyKeyFileNameContext.HandleError(JSError.InvalidAssemblyKeyFile, globals.assemblyKeyFileName);
				}
			}
			else if (globals.assemblyKeyName != null)
			{
				try
				{
					StrongNameKeyPair strongNameKeyPair2 = new StrongNameKeyPair(globals.assemblyKeyName);
					byte[] publicKey2 = strongNameKeyPair2.PublicKey;
					assemblyName.KeyPair = strongNameKeyPair2;
				}
				catch
				{
					globals.assemblyKeyNameContext.HandleError(JSError.InvalidAssemblyKeyFile, globals.assemblyKeyName);
				}
			}
			assemblyName.Name = assemName;
			if (version != null)
			{
				assemblyName.Version = version;
			}
			else if (globals.assemblyVersion != null)
			{
				assemblyName.Version = globals.assemblyVersion;
			}
			AssemblyBuilderAccess access = ((!save) ? AssemblyBuilderAccess.Run : (run ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Save));
			if (engine.ReferenceLoaderAPI == LoaderAPI.ReflectionOnlyLoadFrom)
			{
				access = AssemblyBuilderAccess.ReflectionOnly;
			}
			if (globals.engine.genStartupClass)
			{
				assemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(assemblyName, access, dir, globals.engine.Evidence);
			}
			else
			{
				assemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(assemblyName, access, dir);
			}
			if (save)
			{
				module = assemblyBuilder.DefineDynamicModule("JScript Module", text, debugOn);
			}
			else
			{
				module = assemblyBuilder.DefineDynamicModule("JScript Module", debugOn);
			}
			if (isCLSCompliant)
			{
				module.SetCustomAttribute(new CustomAttributeBuilder(clsCompliantAttributeCtor, new object[1] { isCLSCompliant }));
			}
			if (debugOn)
			{
				ConstructorInfo constructor = Typeob.DebuggableAttribute.GetConstructor(new Type[2]
				{
					Typeob.Boolean,
					Typeob.Boolean
				});
				assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(constructor, new object[2]
				{
					(globals.assemblyFlags & AssemblyFlags.EnableJITcompileTracking) != 0,
					(globals.assemblyFlags & AssemblyFlags.DisableJITcompileOptimizer) != 0
				}));
			}
			compilationEvidence = globals.engine.Evidence;
			classwriter = null;
		}
	}
	internal sealed class Completion
	{
		internal int Continue;

		internal int Exit;

		internal bool Return;

		public object value;

		internal Completion()
		{
			Continue = 0;
			Exit = 0;
			Return = false;
			value = null;
		}
	}
	internal sealed class ConcatString : IConvertible
	{
		private StringBuilder buf;

		private bool isOwner;

		private int length;

		internal ConcatString(string str1, string str2)
		{
			length = str1.Length + str2.Length;
			int num = length * 2;
			if (num < 256)
			{
				num = 256;
			}
			buf = new StringBuilder(str1, num);
			buf.Append(str2);
			isOwner = true;
		}

		internal ConcatString(ConcatString str1, string str2)
		{
			length = str1.length + str2.Length;
			if (str1.isOwner)
			{
				buf = str1.buf;
				str1.isOwner = false;
			}
			else
			{
				int num = length * 2;
				if (num < 256)
				{
					num = 256;
				}
				buf = new StringBuilder(str1.ToString(), num);
			}
			buf.Append(str2);
			isOwner = true;
		}

		TypeCode IConvertible.GetTypeCode()
		{
			return TypeCode.String;
		}

		bool IConvertible.ToBoolean(IFormatProvider provider)
		{
			return ToIConvertible().ToBoolean(provider);
		}

		char IConvertible.ToChar(IFormatProvider provider)
		{
			return ToIConvertible().ToChar(provider);
		}

		sbyte IConvertible.ToSByte(IFormatProvider provider)
		{
			return ToIConvertible().ToSByte(provider);
		}

		byte IConvertible.ToByte(IFormatProvider provider)
		{
			return ToIConvertible().ToByte(provider);
		}

		short IConvertible.ToInt16(IFormatProvider provider)
		{
			return ToIConvertible().ToInt16(provider);
		}

		ushort IConvertible.ToUInt16(IFormatProvider provider)
		{
			return ToIConvertible().ToUInt16(provider);
		}

		private IConvertible ToIConvertible()
		{
			return ToString();
		}

		int IConvertible.ToInt32(IFormatProvider provider)
		{
			return ToIConvertible().ToInt32(provider);
		}

		uint IConvertible.ToUInt32(IFormatProvider provider)
		{
			return ToIConvertible().ToUInt32(provider);
		}

		long IConvertible.ToInt64(IFormatProvider provider)
		{
			return ToIConvertible().ToInt64(provider);
		}

		ulong IConvertible.ToUInt64(IFormatProvider provider)
		{
			return ToIConvertible().ToUInt64(provider);
		}

		float IConvertible.ToSingle(IFormatProvider provider)
		{
			return ToIConvertible().ToSingle(provider);
		}

		double IConvertible.ToDouble(IFormatProvider provider)
		{
			return ToIConvertible().ToDouble(provider);
		}

		decimal IConvertible.ToDecimal(IFormatProvider provider)
		{
			return ToIConvertible().ToDecimal(provider);
		}

		DateTime IConvertible.ToDateTime(IFormatProvider provider)
		{
			return ToIConvertible().ToDateTime(provider);
		}

		string IConvertible.ToString(IFormatProvider provider)
		{
			return ToIConvertible().ToString(provider);
		}

		object IConvertible.ToType(Type conversionType, IFormatProvider provider)
		{
			return ToIConvertible().ToType(conversionType, provider);
		}

		public override string ToString()
		{
			return buf.ToString(0, length);
		}
	}
	internal sealed class Conditional : AST
	{
		private AST condition;

		private AST operand1;

		private AST operand2;

		internal Conditional(Context context, AST condition, AST operand1, AST operand2)
			: base(context)
		{
			this.condition = condition;
			this.operand1 = operand1;
			this.operand2 = operand2;
		}

		internal override object Evaluate()
		{
			if (Convert.ToBoolean(condition.Evaluate()))
			{
				return operand1.Evaluate();
			}
			return operand2.Evaluate();
		}

		internal override AST PartiallyEvaluate()
		{
			condition = condition.PartiallyEvaluate();
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is FunctionScope)
			{
				FunctionScope functionScope = (FunctionScope)scriptObject;
				BitArray definedFlags = functionScope.DefinedFlags;
				operand1 = operand1.PartiallyEvaluate();
				BitArray definedFlags2 = functionScope.DefinedFlags;
				functionScope.DefinedFlags = definedFlags;
				operand2 = operand2.PartiallyEvaluate();
				BitArray definedFlags3 = functionScope.DefinedFlags;
				int length = definedFlags2.Length;
				int length2 = definedFlags3.Length;
				if (length < length2)
				{
					definedFlags2.Length = length2;
				}
				if (length2 < length)
				{
					definedFlags3.Length = length;
				}
				functionScope.DefinedFlags = definedFlags2.And(definedFlags3);
			}
			else
			{
				operand1 = operand1.PartiallyEvaluate();
				operand2 = operand2.PartiallyEvaluate();
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Label label = il.DefineLabel();
			Label label2 = il.DefineLabel();
			condition.TranslateToConditionalBranch(il, branchIfTrue: false, label, shortForm: false);
			operand1.TranslateToIL(il, rtype);
			il.Emit(OpCodes.Br, label2);
			il.MarkLabel(label);
			operand2.TranslateToIL(il, rtype);
			il.MarkLabel(label2);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			condition.TranslateToILInitializer(il);
			operand1.TranslateToILInitializer(il);
			operand2.TranslateToILInitializer(il);
		}
	}
	internal sealed class Constant : AST
	{
		internal FieldAttributes attributes;

		private Completion completion;

		internal CustomAttributeList customAttributes;

		internal JSVariableField field;

		private FieldBuilder valueField;

		private Lookup identifier;

		internal string name;

		internal AST value;

		internal Constant(Context context, Lookup identifier, TypeExpression type, AST value, FieldAttributes attributes, CustomAttributeList customAttributes)
			: base(context)
		{
			this.attributes = attributes | FieldAttributes.InitOnly;
			this.customAttributes = customAttributes;
			completion = new Completion();
			this.identifier = identifier;
			name = identifier.ToString();
			this.value = value;
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is ClassScope)
			{
				if (name == ((ClassScope)scriptObject).name)
				{
					identifier.context.HandleError(JSError.CannotUseNameOfClass);
					name += " const";
				}
				if (attributes == FieldAttributes.PrivateScope)
				{
					attributes = FieldAttributes.Public;
				}
			}
			else
			{
				if (attributes != 0)
				{
					base.context.HandleError(JSError.NotInsideClass);
				}
				attributes = FieldAttributes.Public;
			}
			FieldInfo localField = ((IActivationObject)scriptObject).GetLocalField(name);
			if (localField != null)
			{
				identifier.context.HandleError(JSError.DuplicateName, treatAsError: true);
				name += " const";
			}
			if (scriptObject is ActivationObject)
			{
				field = ((ActivationObject)scriptObject).AddNewField(this.identifier.ToString(), value, attributes);
			}
			else
			{
				field = ((StackFrame)scriptObject).AddNewField(this.identifier.ToString(), value, attributes | FieldAttributes.Static);
			}
			field.type = type;
			field.customAttributes = customAttributes;
			field.originalContext = context;
			if (field is JSLocalField)
			{
				((JSLocalField)field).debugOn = this.identifier.context.document.debugOn;
			}
		}

		internal override object Evaluate()
		{
			if (value == null)
			{
				completion.value = field.value;
			}
			else
			{
				completion.value = value.Evaluate();
			}
			return completion;
		}

		internal override AST PartiallyEvaluate()
		{
			field.attributeFlags &= ~FieldAttributes.InitOnly;
			identifier.PartiallyEvaluateAsReference();
			if (field.type != null)
			{
				field.type.PartiallyEvaluate();
			}
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			if (value != null)
			{
				value = value.PartiallyEvaluate();
				identifier.SetPartialValue(value);
				if (value is ConstantWrapper)
				{
					object obj = (field.value = value.Evaluate());
					if (field.type != null)
					{
						field.value = Convert.Coerce(obj, field.type, explicitOK: true);
					}
					if (field.IsStatic && (obj is Type || obj is ClassScope || obj is TypedArray || Convert.GetTypeCode(obj) != TypeCode.Object))
					{
						field.attributeFlags |= FieldAttributes.Literal;
						goto IL_0128;
					}
				}
				field.attributeFlags |= FieldAttributes.InitOnly;
				goto IL_0128;
			}
			value = new ConstantWrapper(null, context);
			field.attributeFlags |= FieldAttributes.InitOnly;
			goto IL_017f;
			IL_0128:
			if (field.type == null)
			{
				field.type = new TypeExpression(new ConstantWrapper(value.InferType(null), null));
			}
			goto IL_017f;
			IL_017f:
			if (field != null && field.customAttributes != null)
			{
				field.customAttributes.PartiallyEvaluate();
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if ((field.attributeFlags & FieldAttributes.Literal) != 0)
			{
				object obj = field.value;
				if (obj is Type || obj is ClassScope || obj is TypedArray)
				{
					field.attributeFlags &= ~FieldAttributes.Literal;
					identifier.TranslateToILPreSet(il);
					identifier.TranslateToILSet(il, new ConstantWrapper(obj, null));
					field.attributeFlags |= FieldAttributes.Literal;
				}
				return;
			}
			if (!field.IsStatic)
			{
				FieldBuilder fieldBuilder = (valueField = field.metaData as FieldBuilder);
				if (fieldBuilder != null)
				{
					field.metaData = ((TypeBuilder)fieldBuilder.DeclaringType).DefineField(name + " value", field.type.ToType(), FieldAttributes.Private);
				}
			}
			field.attributeFlags &= ~FieldAttributes.InitOnly;
			identifier.TranslateToILPreSet(il);
			identifier.TranslateToILSet(il, value);
			field.attributeFlags |= FieldAttributes.InitOnly;
		}

		internal void TranslateToILInitOnlyInitializers(ILGenerator il)
		{
			FieldBuilder fieldBuilder = valueField;
			if (fieldBuilder != null)
			{
				il.Emit(OpCodes.Ldarg_0);
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Ldfld, (FieldBuilder)field.metaData);
				il.Emit(OpCodes.Stfld, fieldBuilder);
				valueField = (FieldBuilder)field.metaData;
				field.metaData = fieldBuilder;
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			if (value != null)
			{
				value.TranslateToILInitializer(il);
			}
		}
	}
	internal class ConstantListItem
	{
		internal ConstantListItem prev;

		internal object term;

		internal ConstantListItem(object term, ConstantListItem prev)
		{
			this.prev = prev;
			this.term = term;
		}
	}
	internal class ConstantWrapper : AST
	{
		internal object value;

		internal bool isNumericLiteral;

		internal ConstantWrapper(object value, Context context)
			: base(context)
		{
			if (value is ConcatString)
			{
				value = value.ToString();
			}
			this.value = value;
			isNumericLiteral = false;
		}

		internal override object Evaluate()
		{
			return value;
		}

		internal override IReflect InferType(JSField inference_target)
		{
			if (value == null || value is DBNull)
			{
				return Typeob.Object;
			}
			if (value is ClassScope || value is TypedArray)
			{
				return Typeob.Type;
			}
			if (value is EnumWrapper)
			{
				return ((EnumWrapper)value).classScopeOrType;
			}
			return Globals.TypeRefs.ToReferenceContext(value.GetType());
		}

		internal bool IsAssignableTo(Type rtype)
		{
			try
			{
				Convert.CoerceT(value, rtype, explicitOK: false);
				return true;
			}
			catch
			{
				return false;
			}
		}

		internal override AST PartiallyEvaluate()
		{
			return this;
		}

		public override string ToString()
		{
			return value.ToString();
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (rtype == Typeob.Void)
			{
				return;
			}
			object obj = value;
			if (obj is EnumWrapper && rtype != Typeob.Object && rtype != Typeob.String)
			{
				obj = ((EnumWrapper)obj).value;
			}
			if (isNumericLiteral && (rtype == Typeob.Decimal || rtype == Typeob.Int64 || rtype == Typeob.UInt64 || rtype == Typeob.Single))
			{
				obj = context.GetCode();
			}
			if (!(rtype is TypeBuilder))
			{
				try
				{
					obj = Convert.CoerceT(obj, rtype);
				}
				catch
				{
				}
			}
			TranslateToIL(il, obj, rtype);
		}

		private void TranslateToIL(ILGenerator il, object val, Type rtype)
		{
			IConvertible iConvertible = Convert.GetIConvertible(val);
			switch (Convert.GetTypeCode(val, iConvertible))
			{
			case TypeCode.Empty:
				il.Emit(OpCodes.Ldnull);
				if (rtype.IsValueType)
				{
					Convert.Emit(this, il, Typeob.Object, rtype);
				}
				return;
			case TypeCode.DBNull:
				il.Emit(OpCodes.Ldsfld, Typeob.Null.GetField("Value"));
				Convert.Emit(this, il, Typeob.Null, rtype);
				return;
			case TypeCode.Boolean:
				TranslateToILInt(il, iConvertible.ToInt32(null));
				Convert.Emit(this, il, Typeob.Boolean, rtype);
				return;
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
				TranslateToILInt(il, iConvertible.ToInt32(null));
				if (!rtype.IsEnum)
				{
					if (val is EnumWrapper)
					{
						Convert.Emit(this, il, ((EnumWrapper)val).type, rtype);
					}
					else
					{
						Convert.Emit(this, il, Globals.TypeRefs.ToReferenceContext(val.GetType()), rtype);
					}
				}
				return;
			case TypeCode.UInt32:
				TranslateToILInt(il, (int)iConvertible.ToUInt32(null));
				if (!rtype.IsEnum)
				{
					if (val is EnumWrapper)
					{
						Convert.Emit(this, il, ((EnumWrapper)val).type, rtype);
					}
					else
					{
						Convert.Emit(this, il, Typeob.UInt32, rtype);
					}
				}
				return;
			case TypeCode.Int64:
			{
				long num5 = iConvertible.ToInt64(null);
				if (int.MinValue <= num5 && num5 <= int.MaxValue)
				{
					TranslateToILInt(il, (int)num5);
					il.Emit(OpCodes.Conv_I8);
				}
				else
				{
					il.Emit(OpCodes.Ldc_I8, num5);
				}
				if (!rtype.IsEnum)
				{
					if (val is EnumWrapper)
					{
						Convert.Emit(this, il, ((EnumWrapper)val).type, rtype);
					}
					else
					{
						Convert.Emit(this, il, Typeob.Int64, rtype);
					}
				}
				return;
			}
			case TypeCode.UInt64:
			{
				ulong num6 = iConvertible.ToUInt64(null);
				if (num6 <= int.MaxValue)
				{
					TranslateToILInt(il, (int)num6);
					il.Emit(OpCodes.Conv_I8);
				}
				else
				{
					il.Emit(OpCodes.Ldc_I8, (long)num6);
				}
				if (!rtype.IsEnum)
				{
					if (val is EnumWrapper)
					{
						Convert.Emit(this, il, ((EnumWrapper)val).type, rtype);
					}
					else
					{
						Convert.Emit(this, il, Typeob.UInt64, rtype);
					}
				}
				return;
			}
			case TypeCode.Single:
			{
				float num3 = iConvertible.ToSingle(null);
				if (num3 == num3 && (num3 != 0f || !float.IsNegativeInfinity(1f / num3)))
				{
					int num4 = (int)Runtime.DoubleToInt64(num3);
					if (-128 <= num4 && num4 <= 127 && num3 == (float)num4)
					{
						TranslateToILInt(il, num4);
						il.Emit(OpCodes.Conv_R4);
					}
					else
					{
						il.Emit(OpCodes.Ldc_R4, num3);
					}
				}
				else
				{
					il.Emit(OpCodes.Ldc_R4, num3);
				}
				Convert.Emit(this, il, Typeob.Single, rtype);
				return;
			}
			case TypeCode.Double:
			{
				double num = iConvertible.ToDouble(null);
				if (num == num && (num != 0.0 || !double.IsNegativeInfinity(1.0 / num)))
				{
					int num2 = (int)Runtime.DoubleToInt64(num);
					if (-128 <= num2 && num2 <= 127 && num == (double)num2)
					{
						TranslateToILInt(il, num2);
						il.Emit(OpCodes.Conv_R8);
					}
					else
					{
						il.Emit(OpCodes.Ldc_R8, num);
					}
				}
				else
				{
					il.Emit(OpCodes.Ldc_R8, num);
				}
				Convert.Emit(this, il, Typeob.Double, rtype);
				return;
			}
			case TypeCode.Decimal:
			{
				int[] bits = decimal.GetBits(iConvertible.ToDecimal(null));
				TranslateToILInt(il, bits[0]);
				TranslateToILInt(il, bits[1]);
				TranslateToILInt(il, bits[2]);
				il.Emit((bits[3] < 0) ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
				TranslateToILInt(il, (bits[3] & 0x7FFFFFFF) >> 16);
				il.Emit(OpCodes.Newobj, CompilerGlobals.decimalConstructor);
				Convert.Emit(this, il, Typeob.Decimal, rtype);
				return;
			}
			case TypeCode.DateTime:
			{
				long num5 = iConvertible.ToDateTime(null).Ticks;
				il.Emit(OpCodes.Ldc_I8, num5);
				Convert.Emit(this, il, Typeob.Int64, rtype);
				return;
			}
			case TypeCode.String:
			{
				string text = iConvertible.ToString(null);
				if (rtype == Typeob.Char && text.Length == 1)
				{
					TranslateToILInt(il, text[0]);
					return;
				}
				il.Emit(OpCodes.Ldstr, text);
				Convert.Emit(this, il, Typeob.String, rtype);
				return;
			}
			}
			if (val is Enum)
			{
				if (rtype == Typeob.String)
				{
					TranslateToIL(il, val.ToString(), rtype);
					return;
				}
				if (rtype.IsPrimitive)
				{
					TranslateToIL(il, System.Convert.ChangeType(val, Enum.GetUnderlyingType(Globals.TypeRefs.ToReferenceContext(val.GetType())), CultureInfo.InvariantCulture), rtype);
					return;
				}
				Type type = Globals.TypeRefs.ToReferenceContext(val.GetType());
				Type underlyingType = Enum.GetUnderlyingType(type);
				TranslateToIL(il, System.Convert.ChangeType(val, underlyingType, CultureInfo.InvariantCulture), underlyingType);
				il.Emit(OpCodes.Box, type);
				Convert.Emit(this, il, Typeob.Object, rtype);
			}
			else if (val is EnumWrapper)
			{
				if (rtype == Typeob.String)
				{
					TranslateToIL(il, val.ToString(), rtype);
					return;
				}
				if (rtype.IsPrimitive)
				{
					TranslateToIL(il, ((EnumWrapper)val).ToNumericValue(), rtype);
					return;
				}
				Type type2 = ((EnumWrapper)val).type;
				Type rtype2 = Globals.TypeRefs.ToReferenceContext(((EnumWrapper)val).value.GetType());
				TranslateToIL(il, ((EnumWrapper)val).value, rtype2);
				il.Emit(OpCodes.Box, type2);
				Convert.Emit(this, il, Typeob.Object, rtype);
			}
			else if (val is Type)
			{
				il.Emit(OpCodes.Ldtoken, (Type)val);
				il.Emit(OpCodes.Call, CompilerGlobals.getTypeFromHandleMethod);
				Convert.Emit(this, il, Typeob.Type, rtype);
			}
			else if (val is Namespace)
			{
				il.Emit(OpCodes.Ldstr, ((Namespace)val).Name);
				EmitILToLoadEngine(il);
				il.Emit(OpCodes.Call, CompilerGlobals.getNamespaceMethod);
				Convert.Emit(this, il, Typeob.Namespace, rtype);
			}
			else if (val is ClassScope)
			{
				il.Emit(OpCodes.Ldtoken, ((ClassScope)val).GetTypeBuilderOrEnumBuilder());
				il.Emit(OpCodes.Call, CompilerGlobals.getTypeFromHandleMethod);
				Convert.Emit(this, il, Typeob.Type, rtype);
			}
			else if (val is TypedArray)
			{
				il.Emit(OpCodes.Ldtoken, Convert.ToType((TypedArray)val));
				il.Emit(OpCodes.Call, CompilerGlobals.getTypeFromHandleMethod);
				Convert.Emit(this, il, Typeob.Type, rtype);
			}
			else if (val is NumberObject)
			{
				TranslateToIL(il, ((NumberObject)val).value, Typeob.Object);
				EmitILToLoadEngine(il);
				il.Emit(OpCodes.Call, CompilerGlobals.toObjectMethod);
				Convert.Emit(this, il, Typeob.NumberObject, rtype);
			}
			else if (val is StringObject)
			{
				il.Emit(OpCodes.Ldstr, ((StringObject)val).value);
				EmitILToLoadEngine(il);
				il.Emit(OpCodes.Call, CompilerGlobals.toObjectMethod);
				Convert.Emit(this, il, Typeob.StringObject, rtype);
			}
			else if (val is BooleanObject)
			{
				il.Emit(((BooleanObject)val).value ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
				il.Emit(OpCodes.Box, Typeob.Boolean);
				EmitILToLoadEngine(il);
				il.Emit(OpCodes.Call, CompilerGlobals.toObjectMethod);
				Convert.Emit(this, il, Typeob.BooleanObject, rtype);
			}
			else if (val is ActiveXObjectConstructor)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("ActiveXObject").GetGetMethod());
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is ArrayConstructor)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("Array").GetGetMethod());
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is BooleanConstructor)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("Boolean").GetGetMethod());
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is DateConstructor)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("Date").GetGetMethod());
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is EnumeratorConstructor)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("Enumerator").GetGetMethod());
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is ErrorConstructor)
			{
				ErrorConstructor errorConstructor = (ErrorConstructor)val;
				if (errorConstructor == ErrorConstructor.evalOb)
				{
					il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("EvalError").GetGetMethod());
				}
				else if (errorConstructor == ErrorConstructor.rangeOb)
				{
					il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("RangeError").GetGetMethod());
				}
				else if (errorConstructor == ErrorConstructor.referenceOb)
				{
					il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("ReferenceError").GetGetMethod());
				}
				else if (errorConstructor == ErrorConstructor.syntaxOb)
				{
					il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("SyntaxError").GetGetMethod());
				}
				else if (errorConstructor == ErrorConstructor.typeOb)
				{
					il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("TypeError").GetGetMethod());
				}
				else if (errorConstructor == ErrorConstructor.uriOb)
				{
					il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("URIError").GetGetMethod());
				}
				else
				{
					il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("Error").GetGetMethod());
				}
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is FunctionConstructor)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("Function").GetGetMethod());
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is MathObject)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("Math").GetGetMethod());
				Convert.Emit(this, il, Typeob.JSObject, rtype);
			}
			else if (val is NumberConstructor)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("Number").GetGetMethod());
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is ObjectConstructor)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("Object").GetGetMethod());
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is RegExpConstructor)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("RegExp").GetGetMethod());
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is StringConstructor)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("String").GetGetMethod());
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is VBArrayConstructor)
			{
				il.Emit(OpCodes.Call, Typeob.GlobalObject.GetProperty("VBArray").GetGetMethod());
				Convert.Emit(this, il, Typeob.ScriptFunction, rtype);
			}
			else if (val is IntPtr)
			{
				il.Emit(OpCodes.Ldc_I8, (long)(IntPtr)val);
				il.Emit(OpCodes.Conv_I);
				Convert.Emit(this, il, Typeob.IntPtr, rtype);
			}
			else if (val is UIntPtr)
			{
				il.Emit(OpCodes.Ldc_I8, (long)(ulong)(UIntPtr)val);
				il.Emit(OpCodes.Conv_U);
				Convert.Emit(this, il, Typeob.UIntPtr, rtype);
			}
			else if (val is Missing)
			{
				il.Emit(OpCodes.Ldsfld, CompilerGlobals.missingField);
				Convert.Emit(this, il, Typeob.Object, rtype);
			}
			else if (val is System.Reflection.Missing)
			{
				if (rtype.IsPrimitive)
				{
					TranslateToIL(il, double.NaN, rtype);
					return;
				}
				if (rtype != Typeob.Object && !rtype.IsValueType)
				{
					il.Emit(OpCodes.Ldnull);
					return;
				}
				il.Emit(OpCodes.Ldsfld, CompilerGlobals.systemReflectionMissingField);
				Convert.Emit(this, il, Typeob.Object, rtype);
			}
			else
			{
				if (val == value)
				{
					throw new JScriptException(JSError.InternalError, context);
				}
				TranslateToIL(il, value, rtype);
			}
		}

		internal static void TranslateToILInt(ILGenerator il, int i)
		{
			switch (i)
			{
			case -1:
				il.Emit(OpCodes.Ldc_I4_M1);
				return;
			case 0:
				il.Emit(OpCodes.Ldc_I4_0);
				return;
			case 1:
				il.Emit(OpCodes.Ldc_I4_1);
				return;
			case 2:
				il.Emit(OpCodes.Ldc_I4_2);
				return;
			case 3:
				il.Emit(OpCodes.Ldc_I4_3);
				return;
			case 4:
				il.Emit(OpCodes.Ldc_I4_4);
				return;
			case 5:
				il.Emit(OpCodes.Ldc_I4_5);
				return;
			case 6:
				il.Emit(OpCodes.Ldc_I4_6);
				return;
			case 7:
				il.Emit(OpCodes.Ldc_I4_7);
				return;
			case 8:
				il.Emit(OpCodes.Ldc_I4_8);
				return;
			}
			if (-128 <= i && i <= 127)
			{
				il.Emit(OpCodes.Ldc_I4_S, (sbyte)i);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4, i);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
		}
	}
	internal class ConstructorCall : AST
	{
		internal bool isOK;

		internal bool isSuperConstructorCall;

		internal ASTList arguments;

		internal ConstructorCall(Context context, ASTList arguments, bool isSuperConstructorCall)
			: base(context)
		{
			isOK = false;
			this.isSuperConstructorCall = isSuperConstructorCall;
			if (arguments == null)
			{
				this.arguments = new ASTList(context);
			}
			else
			{
				this.arguments = arguments;
			}
		}

		internal override object Evaluate()
		{
			return new Completion();
		}

		internal override AST PartiallyEvaluate()
		{
			if (!isOK)
			{
				context.HandleError(JSError.NotOKToCallSuper);
				return this;
			}
			int i = 0;
			for (int count = arguments.count; i < count; i++)
			{
				arguments[i] = arguments[i].PartiallyEvaluate();
				arguments[i].CheckIfOKToUseInSuperConstructorCall();
			}
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			if (!(scriptObject is FunctionScope))
			{
				context.HandleError(JSError.NotOKToCallSuper);
				return this;
			}
			if (!((FunctionScope)scriptObject).owner.isConstructor)
			{
				context.HandleError(JSError.NotOKToCallSuper);
			}
			((FunctionScope)scriptObject).owner.superConstructorCall = this;
			return this;
		}

		internal override AST PartiallyEvaluateAsReference()
		{
			throw new JScriptException(JSError.InternalError);
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
		}
	}
	/// <summary>Represents JScript source code. This class belongs to the compilation and run-time state category.</summary>
	public class Context
	{
		internal DocumentContext document;

		internal string source_string;

		internal int lineNumber;

		internal int startLinePos;

		internal int startPos;

		internal int endLineNumber;

		internal int endLinePos;

		internal int endPos;

		internal JSToken token;

		internal int errorReported;

		/// <summary>Gets the column number in the line where this code ends. This includes white space at the start of the line.</summary>
		/// <returns>The column number where this code ends.</returns>
		public int EndColumn => endPos - endLinePos;

		/// <summary>Gets the ending line number of this code.</summary>
		/// <returns>The ending line number of this code.</returns>
		public int EndLine => endLineNumber;

		/// <summary>Gets the position in the code string where this code ends, because all lines of code are stored in a single string.</summary>
		/// <returns>The position in the code string where this code ends.</returns>
		public int EndPosition => endPos;

		/// <summary>Gets the column number in the line where this code starts. This includes white space at the start of the line.</summary>
		/// <returns>The column number where this code starts.</returns>
		public int StartColumn => startPos - startLinePos;

		/// <summary>Gets the line number where this code starts.</summary>
		/// <returns>The line number where this code starts.</returns>
		public int StartLine => lineNumber;

		/// <summary>Gets the position in the code string where this code starts, because all lines of code are stored in a single string.</summary>
		/// <returns>The position in the code string where this code starts.</returns>
		public int StartPosition => startPos;

		internal Context(DocumentContext document, string source_string)
		{
			this.document = document;
			this.source_string = source_string;
			lineNumber = 1;
			startLinePos = 0;
			startPos = 0;
			endLineNumber = 1;
			endLinePos = 0;
			endPos = source_string?.Length ?? (-1);
			token = JSToken.None;
			errorReported = 1000000;
		}

		internal Context(DocumentContext document, string source_string, int lineNumber, int startLinePos, int startPos, int endLineNumber, int endLinePos, int endPos, JSToken token)
		{
			this.document = document;
			this.source_string = source_string;
			this.lineNumber = lineNumber;
			this.startLinePos = startLinePos;
			this.startPos = startPos;
			this.endLineNumber = endLineNumber;
			this.endLinePos = endLinePos;
			this.endPos = endPos;
			this.token = token;
			errorReported = 1000000;
		}

		internal Context Clone()
		{
			Context context = new Context(document, source_string, lineNumber, startLinePos, startPos, endLineNumber, endLinePos, endPos, token);
			context.errorReported = errorReported;
			return context;
		}

		internal Context CombineWith(Context other)
		{
			return new Context(document, source_string, lineNumber, startLinePos, startPos, other.endLineNumber, other.endLinePos, other.endPos, token);
		}

		internal void EmitLineInfo(ILGenerator ilgen)
		{
			document.EmitLineInfo(ilgen, StartLine, StartColumn, EndLine, EndColumn);
		}

		internal void EmitFirstLineInfo(ILGenerator ilgen)
		{
			document.EmitFirstLineInfo(ilgen, StartLine, StartColumn, EndLine, EndColumn);
		}

		internal bool Equals(string str)
		{
			int num = endPos - startPos;
			if (num == str.Length)
			{
				return string.CompareOrdinal(source_string, startPos, str, 0, num) == 0;
			}
			return false;
		}

		internal bool Equals(Context ctx)
		{
			if (source_string == ctx.source_string && lineNumber == ctx.lineNumber && startLinePos == ctx.startLinePos && startPos == ctx.startPos && endLineNumber == ctx.endLineNumber && endLinePos == ctx.endLinePos && endPos == ctx.endPos)
			{
				return token == ctx.token;
			}
			return false;
		}

		/// <summary>Gets the code that the context contains, discarding any white space.</summary>
		/// <returns>The code that the context contains.</returns>
		public string GetCode()
		{
			if (endPos > startPos && endPos <= source_string.Length)
			{
				return source_string.Substring(startPos, endPos - startPos);
			}
			return null;
		}

		/// <summary>Gets an individual unit of code, or a token, that the context contains.</summary>
		/// <returns>An individual unit of code, or a token, that the context contains.</returns>
		public JSToken GetToken()
		{
			return token;
		}

		internal void HandleError(JSError errorId)
		{
			HandleError(errorId, null, treatAsError: false);
		}

		internal void HandleError(JSError errorId, bool treatAsError)
		{
			HandleError(errorId, null, treatAsError);
		}

		internal void HandleError(JSError errorId, string message)
		{
			HandleError(errorId, message, treatAsError: false);
		}

		internal void HandleError(JSError errorId, string message, bool treatAsError)
		{
			if (errorId != JSError.UndeclaredVariable || !document.HasAlreadySeenErrorFor(GetCode()))
			{
				JScriptException ex = new JScriptException(errorId, this);
				if (message != null)
				{
					ex.value = message;
				}
				if (treatAsError)
				{
					ex.isError = treatAsError;
				}
				int severity = ex.Severity;
				if (severity < errorReported)
				{
					document.HandleError(ex);
					errorReported = severity;
				}
			}
		}

		internal void SetSourceContext(DocumentContext document, string source)
		{
			source_string = source;
			endPos = source.Length;
			this.document = document;
		}

		internal void UpdateWith(Context other)
		{
			endPos = other.endPos;
			endLineNumber = other.endLineNumber;
			endLinePos = other.endLinePos;
		}
	}
	internal sealed class Continue : AST
	{
		private Completion completion;

		private bool leavesFinally;

		internal Continue(Context context, int count, bool leavesFinally)
			: base(context)
		{
			completion = new Completion();
			completion.Continue = count;
			this.leavesFinally = leavesFinally;
		}

		internal override object Evaluate()
		{
			return completion;
		}

		internal override AST PartiallyEvaluate()
		{
			if (leavesFinally)
			{
				context.HandleError(JSError.BadWayToLeaveFinally);
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Label label = (Label)base.compilerGlobals.ContinueLabelStack.Peek(completion.Continue - 1);
			context.EmitLineInfo(il);
			if (leavesFinally)
			{
				ConstantWrapper.TranslateToILInt(il, base.compilerGlobals.ContinueLabelStack.Size() - completion.Continue);
				il.Emit(OpCodes.Newobj, CompilerGlobals.continueOutOfFinallyConstructor);
				il.Emit(OpCodes.Throw);
			}
			else if (base.compilerGlobals.InsideProtectedRegion)
			{
				il.Emit(OpCodes.Leave, label);
			}
			else
			{
				il.Emit(OpCodes.Br, label);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
		}
	}
	/// <summary>Represents the exception state when code execution continues out of a <see langword="finally" /> block.</summary>
	[Serializable]
	public sealed class ContinueOutOfFinally : ApplicationException
	{
		/// <summary>Stores the target of the exception.</summary>
		public int target;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.ContinueOutOfFinally" /> class.</summary>
		public ContinueOutOfFinally()
			: this(0)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.ContinueOutOfFinally" /> class, using the specified target.</summary>
		/// <param name="target">The target of the exception.</param>
		public ContinueOutOfFinally(int target)
		{
			this.target = target;
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.ContinueOutOfFinally" /> class, using the specified error message.</summary>
		/// <param name="m">The message that describes the error.</param>
		public ContinueOutOfFinally(string m)
			: base(m)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.ContinueOutOfFinally" /> class, using the specified error message and a reference to the inner exception that is the cause of this exception.</summary>
		/// <param name="m">The message that describes the error.</param>
		/// <param name="e">The exception that is the cause of the current exception.</param>
		public ContinueOutOfFinally(string m, Exception e)
			: base(m, e)
		{
		}

		private ContinueOutOfFinally(SerializationInfo s, StreamingContext c)
			: base(s, c)
		{
			target = s.GetInt32("Target");
		}

		/// <summary>Stores information about the exception in the <see cref="T:System.Runtime.Serialization.SerializationInfo" />. The stored information includes the <see cref="F:Microsoft.JScript.ContinueOutOfFinally.target" /> value.</summary>
		/// <param name="s">The serialized object data about the exception that is being thrown.</param>
		/// <param name="c">Contextual information about the source or destination.</param>
		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo s, StreamingContext c)
		{
			base.GetObjectData(s, c);
			s.AddValue("Target", target);
		}
	}
	internal enum PreferredType
	{
		Either,
		Number,
		String,
		LocaleString
	}
	/// <summary>Converts data from one type to another. This is a utility class.</summary>
	public sealed class Convert
	{
		private static bool[,] promotable = new bool[19, 19]
		{
			{
				true, true, true, true, true, true, true, true, true, true,
				true, true, true, true, true, true, true, true, true
			},
			{
				false, false, false, false, false, false, false, false, false, false,
				false, false, false, false, false, false, false, false, false
			},
			{
				true, true, true, true, true, true, true, true, true, true,
				true, true, true, true, true, true, true, true, true
			},
			{
				false, false, false, true, true, true, true, true, true, true,
				true, true, true, true, true, true, true, true, false
			},
			{
				false, false, false, false, true, false, false, false, true, true,
				true, true, true, true, true, true, true, true, false
			},
			{
				false, false, false, false, false, true, false, true, false, true,
				false, true, false, true, true, true, true, true, false
			},
			{
				false, false, false, false, true, false, true, true, true, true,
				true, true, true, true, true, true, true, true, false
			},
			{
				false, false, false, false, false, true, false, true, false, true,
				false, true, false, true, true, true, true, true, false
			},
			{
				false, false, false, false, true, false, false, false, true, true,
				true, true, true, true, true, true, true, true, false
			},
			{
				false, false, false, false, false, false, false, false, false, true,
				false, true, false, false, true, true, true, true, false
			},
			{
				false, false, false, false, false, false, false, false, false, false,
				true, true, true, false, true, true, true, true, false
			},
			{
				false, false, false, false, false, false, false, false, false, false,
				false, true, false, false, false, true, true, true, false
			},
			{
				false, false, false, false, false, false, false, false, false, false,
				false, false, true, false, false, true, true, true, false
			},
			{
				false, false, false, false, false, false, false, false, false, false,
				false, false, false, true, true, true, false, false, false
			},
			{
				false, false, false, false, false, false, false, false, false, false,
				false, false, false, false, true, true, false, false, false
			},
			{
				false, false, false, false, false, false, false, false, false, false,
				false, false, false, false, false, true, false, false, false
			},
			{
				false, false, false, false, false, false, false, false, false, false,
				false, false, false, false, false, false, true, false, false
			},
			{
				false, false, false, false, false, false, false, false, false, false,
				false, false, false, false, false, false, false, true, false
			},
			{
				false, false, false, false, false, false, false, false, false, false,
				false, false, false, false, false, false, false, false, true
			}
		};

		private static int[] rgcchSig = new int[35]
		{
			53, 34, 27, 24, 22, 20, 19, 18, 17, 17,
			16, 16, 15, 15, 14, 14, 14, 14, 14, 13,
			13, 13, 13, 13, 13, 12, 12, 12, 12, 12,
			12, 12, 12, 12, 12
		};

		/// <summary>Determines whether a variable contains an array index value.</summary>
		/// <param name="ast">The variable to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="ast" /> contains an array index value; otherwise, <see langword="false" />.</returns>
		public static bool IsBadIndex(AST ast)
		{
			if (!(ast is ConstantWrapper))
			{
				return false;
			}
			int num;
			try
			{
				num = (int)CoerceT(((ConstantWrapper)ast).value, typeof(int));
			}
			catch
			{
				return true;
			}
			return num < 0;
		}

		/// <summary>Determines whether a <see cref="T:System.Double" /> variable contains an integer value.</summary>
		/// <param name="d">The <see cref="T:System.Double" /> to test.</param>
		/// <returns>If <paramref name="d" /> contains an integer value, <paramref name="d" /> is returned. If not, an exception is thrown.</returns>
		public static double CheckIfDoubleIsInteger(double d)
		{
			if (d == Math.Round(d))
			{
				return d;
			}
			throw new JScriptException(JSError.TypeMismatch);
		}

		/// <summary>Determines whether a <see cref="T:System.Single" /> variable contains an integer value.</summary>
		/// <param name="s">The <see cref="T:System.Single" /> to test.</param>
		/// <returns>If <paramref name="s" /> contains an integer value, <paramref name="s" /> is returned. If not, an exception is thrown.</returns>
		public static float CheckIfSingleIsInteger(float s)
		{
			if ((double)s == Math.Round(s))
			{
				return s;
			}
			throw new JScriptException(JSError.TypeMismatch);
		}

		/// <summary>Converts the specified value to the specified type.</summary>
		/// <param name="value">The value to convert to a new type.</param>
		/// <param name="type">The type to convert <paramref name="value" /> to.</param>
		/// <returns>
		///   <paramref name="value" /> converted to <paramref name="type" />.</returns>
		public static object Coerce(object value, object type)
		{
			return Coerce(value, type, explicitOK: false);
		}

		internal static object Coerce(object value, object type, bool explicitOK)
		{
			if (type is TypeExpression typeExpression)
			{
				type = typeExpression.ToIReflect();
			}
			if (type is TypedArray typedArray)
			{
				IReflect elementType = typedArray.elementType;
				int rank = typedArray.rank;
				Type elementType2 = ((elementType is Type) ? ((Type)elementType) : ((elementType is ClassScope) ? ((ClassScope)elementType).GetBakedSuperType() : typeof(object)));
				if (value is ArrayObject arrayObject)
				{
					return arrayObject.ToNativeArray(elementType2);
				}
				if (value is Array array && array.Rank == rank)
				{
					type = ToType(TypedArray.ToRankString(rank), elementType2);
				}
				if (value == null || value is DBNull)
				{
					return null;
				}
			}
			if (type is ClassScope classScope)
			{
				if (classScope.HasInstance(value))
				{
					return value;
				}
				if (classScope.owner is EnumDeclaration enumDeclaration)
				{
					if (value is EnumWrapper enumWrapper)
					{
						if (enumWrapper.classScopeOrType == classScope)
						{
							return value;
						}
						throw new JScriptException(JSError.TypeMismatch);
					}
					return new DeclaredEnumValue(Coerce(value, enumDeclaration.baseType), null, classScope);
				}
				if (value == null || value is DBNull)
				{
					return null;
				}
				throw new JScriptException(JSError.TypeMismatch);
			}
			if (!(type is Type))
			{
				type = ToType(Runtime.TypeRefs, (IReflect)type);
			}
			else
			{
				if (type == typeof(Type) && value is ClassScope)
				{
					return value;
				}
				if (((Type)type).IsEnum)
				{
					if (value is EnumWrapper enumWrapper2)
					{
						if (enumWrapper2.classScopeOrType == type)
						{
							return value;
						}
						throw new JScriptException(JSError.TypeMismatch);
					}
					Type type2 = type as Type;
					return MetadataEnumValue.GetEnumValue(type2, CoerceT(value, GetUnderlyingType(type2), explicitOK));
				}
			}
			return CoerceT(value, (Type)type, explicitOK);
		}

		internal static object CoerceT(object value, Type type)
		{
			return CoerceT(value, type, explicitOK: false);
		}

		/// <summary>Converts the specified value to the specified <see cref="T:System.Type" />, optionally allowing data loss.</summary>
		/// <param name="value">The value to convert to a new type.</param>
		/// <param name="t">The type to convert <paramref name="value" /> to.</param>
		/// <param name="explicitOK">
		///   <see langword="true" /> to allow data loss; otherwise, <see langword="false" />.</param>
		/// <returns>
		///   <paramref name="value" /> converted to the type <paramref name="t" />.</returns>
		public static object CoerceT(object value, Type t, bool explicitOK)
		{
			if (t == typeof(object))
			{
				return value;
			}
			if (t == typeof(string) && value is string)
			{
				return value;
			}
			if (t.IsEnum && !(t is EnumBuilder) && !(t is TypeBuilder))
			{
				IConvertible iConvertible = GetIConvertible(value);
				TypeCode typeCode = GetTypeCode(value, iConvertible);
				if (typeCode == TypeCode.String)
				{
					return Enum.Parse(t, iConvertible.ToString(CultureInfo.InvariantCulture));
				}
				if (!explicitOK && typeCode != 0)
				{
					Type type = value.GetType();
					if (type.IsEnum)
					{
						if (type != t)
						{
							throw new JScriptException(JSError.TypeMismatch);
						}
						return value;
					}
				}
				return Enum.ToObject(t, CoerceT(value, GetUnderlyingType(t), explicitOK));
			}
			TypeCode typeCode2 = Type.GetTypeCode(t);
			if (typeCode2 != TypeCode.Object)
			{
				return Coerce2(value, typeCode2, explicitOK);
			}
			if (value is ConcatString)
			{
				value = value.ToString();
			}
			if (value == null || (value == DBNull.Value && t != typeof(object)) || value is Missing || value is System.Reflection.Missing)
			{
				if (t.IsValueType)
				{
					if (!t.IsPublic && t.Assembly == typeof(ActiveXObjectConstructor).Assembly)
					{
						throw new JScriptException(JSError.CantCreateObject);
					}
					return Activator.CreateInstance(t);
				}
				return null;
			}
			if (t.IsAssignableFrom(value.GetType()))
			{
				return value;
			}
			if (typeof(Delegate).IsAssignableFrom(t))
			{
				if (value is Closure)
				{
					return ((Closure)value).ConvertToDelegate(t);
				}
				if (value is FunctionWrapper)
				{
					return ((FunctionWrapper)value).ConvertToDelegate(t);
				}
				if (value is FunctionObject)
				{
					return value;
				}
			}
			else
			{
				if (value is ArrayObject && typeof(Array).IsAssignableFrom(t))
				{
					return ((ArrayObject)value).ToNativeArray(t.GetElementType());
				}
				if (value is Array && t == typeof(ArrayObject) && ((Array)value).Rank == 1)
				{
					if (Globals.contextEngine == null)
					{
						Globals.contextEngine = new VsaEngine(fast: true);
						Globals.contextEngine.InitVsaEngine("JS7://Microsoft.JScript.Vsa.VsaEngine", new DefaultVsaSite());
					}
					return Globals.contextEngine.GetOriginalArrayConstructor().ConstructWrapper((Array)value);
				}
				if (value is ClassScope && t == typeof(Type))
				{
					return ((ClassScope)value).GetTypeBuilderOrEnumBuilder();
				}
				if (value is TypedArray && t == typeof(Type))
				{
					return ((TypedArray)value).ToType();
				}
			}
			Type type2 = value.GetType();
			MethodInfo methodInfo = null;
			if (explicitOK)
			{
				methodInfo = t.GetMethod("op_Explicit", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[1] { type2 }, null);
				if (methodInfo != null && (methodInfo.Attributes & MethodAttributes.SpecialName) != 0)
				{
					methodInfo = new JSMethodInfo(methodInfo);
					return methodInfo.Invoke(null, BindingFlags.SuppressChangeType, null, new object[1] { value }, null);
				}
				methodInfo = GetToXXXXMethod(type2, t, explicitOK);
				if (methodInfo != null && (methodInfo.Attributes & MethodAttributes.SpecialName) != 0)
				{
					methodInfo = new JSMethodInfo(methodInfo);
					if (methodInfo.IsStatic)
					{
						return methodInfo.Invoke(null, BindingFlags.SuppressChangeType, null, new object[1] { value }, null);
					}
					return methodInfo.Invoke(value, BindingFlags.SuppressChangeType, null, new object[0], null);
				}
			}
			methodInfo = t.GetMethod("op_Implicit", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[1] { type2 }, null);
			if (methodInfo != null && (methodInfo.Attributes & MethodAttributes.SpecialName) != 0)
			{
				methodInfo = new JSMethodInfo(methodInfo);
				return methodInfo.Invoke(null, BindingFlags.SuppressChangeType, null, new object[1] { value }, null);
			}
			methodInfo = GetToXXXXMethod(type2, t, explicitOK: false);
			if (methodInfo != null && (methodInfo.Attributes & MethodAttributes.SpecialName) != 0)
			{
				methodInfo = new JSMethodInfo(methodInfo);
				if (methodInfo.IsStatic)
				{
					return methodInfo.Invoke(null, BindingFlags.SuppressChangeType, null, new object[1] { value }, null);
				}
				return methodInfo.Invoke(value, BindingFlags.SuppressChangeType, null, new object[0], null);
			}
			if (t.IsByRef)
			{
				return CoerceT(value, t.GetElementType());
			}
			Type type3 = value.GetType();
			if (type3.IsCOMObject)
			{
				return value;
			}
			throw new JScriptException(JSError.TypeMismatch);
		}

		/// <summary>Converts the specified value to the specified <see cref="T:System.TypeCode" />, optionally allowing data loss.</summary>
		/// <param name="value">The value to convert to a new type.</param>
		/// <param name="target">The type to convert <paramref name="value" /> to.</param>
		/// <param name="truncationPermitted">
		///   <see langword="true" /> to allow data loss; otherwise, <see langword="false" />.</param>
		/// <returns>
		///   <paramref name="value" /> converted to the <paramref name="target" /> type.</returns>
		public static object Coerce2(object value, TypeCode target, bool truncationPermitted)
		{
			if (truncationPermitted)
			{
				return Coerce2WithTruncationPermitted(value, target);
			}
			return Coerce2WithNoTrunctation(value, target);
		}

		private static object Coerce2WithNoTrunctation(object value, TypeCode target)
		{
			if (value is EnumWrapper)
			{
				value = ((EnumWrapper)value).value;
			}
			if (value is ConstantWrapper)
			{
				value = ((ConstantWrapper)value).value;
			}
			checked
			{
				try
				{
					IConvertible iConvertible = GetIConvertible(value);
					switch (GetTypeCode(value, iConvertible))
					{
					case TypeCode.Empty:
						switch (target)
						{
						case TypeCode.DBNull:
							return DBNull.Value;
						case TypeCode.Boolean:
							return false;
						case TypeCode.Char:
							return '\0';
						case TypeCode.SByte:
							return (sbyte)0;
						case TypeCode.Byte:
							return (byte)0;
						case TypeCode.Int16:
							return (short)0;
						case TypeCode.UInt16:
							return (ushort)0;
						case TypeCode.Int32:
							return 0;
						case TypeCode.UInt32:
							return 0u;
						case TypeCode.Int64:
							return 0L;
						case TypeCode.UInt64:
							return 0uL;
						case TypeCode.Single:
							return float.NaN;
						case TypeCode.Double:
							return double.NaN;
						case TypeCode.Decimal:
							return 0m;
						case TypeCode.DateTime:
							return new DateTime(0L);
						case TypeCode.String:
							return null;
						case (TypeCode)17:
							break;
						}
						break;
					case TypeCode.Object:
						if (!(value is System.Reflection.Missing) && (!(value is Missing) || target == TypeCode.Object))
						{
							switch (target)
							{
							case TypeCode.Boolean:
								return ToBoolean(value, explicitConversion: false);
							case TypeCode.Char:
							case TypeCode.SByte:
							case TypeCode.Byte:
							case TypeCode.Int16:
							case TypeCode.UInt16:
							case TypeCode.Int32:
							case TypeCode.UInt32:
							case TypeCode.Int64:
							case TypeCode.UInt64:
							case TypeCode.Single:
							case TypeCode.Double:
							case TypeCode.Decimal:
								return Coerce2WithNoTrunctation(ToNumber(value, iConvertible), target);
							case TypeCode.DateTime:
								if (value is DateObject)
								{
									return DatePrototype.getVarDate((DateObject)value);
								}
								return Coerce2WithNoTrunctation(ToNumber(value, iConvertible), target);
							case TypeCode.String:
								return ToString(value, iConvertible);
							case (TypeCode)17:
								break;
							}
							break;
						}
						goto case TypeCode.Empty;
					case TypeCode.DBNull:
						switch (target)
						{
						case TypeCode.DBNull:
							return DBNull.Value;
						case TypeCode.Boolean:
							return false;
						case TypeCode.Char:
							return '\0';
						case TypeCode.SByte:
							return (sbyte)0;
						case TypeCode.Byte:
							return (byte)0;
						case TypeCode.Int16:
							return (short)0;
						case TypeCode.UInt16:
							return (ushort)0;
						case TypeCode.Int32:
							return 0;
						case TypeCode.UInt32:
							return 0u;
						case TypeCode.Int64:
							return 0L;
						case TypeCode.UInt64:
							return 0uL;
						case TypeCode.Single:
							return 0f;
						case TypeCode.Double:
							return 0.0;
						case TypeCode.Decimal:
							return 0m;
						case TypeCode.DateTime:
							return new DateTime(0L);
						case TypeCode.String:
							return null;
						case (TypeCode)17:
							break;
						}
						break;
					case TypeCode.Boolean:
					{
						bool flag = iConvertible.ToBoolean(null);
						int num10 = (flag ? 1 : 0);
						switch (target)
						{
						case TypeCode.Boolean:
							return flag;
						case TypeCode.Char:
							unchecked
							{
								return (char)checked((ushort)num10);
							}
						case TypeCode.SByte:
							return (sbyte)num10;
						case TypeCode.Byte:
							return (byte)num10;
						case TypeCode.Int16:
							return (short)num10;
						case TypeCode.UInt16:
							return (ushort)num10;
						case TypeCode.Int32:
							return num10;
						case TypeCode.UInt32:
							return (uint)num10;
						case TypeCode.Int64:
							return unchecked((long)num10);
						case TypeCode.UInt64:
							return (ulong)num10;
						case TypeCode.Single:
							return (float)num10;
						case TypeCode.Double:
							return (double)num10;
						case TypeCode.Decimal:
							return (decimal)num10;
						case TypeCode.DateTime:
							return new DateTime(num10);
						case TypeCode.String:
							return flag ? "true" : "false";
						case (TypeCode)17:
							break;
						}
						break;
					}
					case TypeCode.Char:
					{
						char c = iConvertible.ToChar(null);
						ushort num8 = c;
						unchecked
						{
							switch (target)
							{
							case TypeCode.Boolean:
								return num8 != 0;
							case TypeCode.Char:
								return c;
							case TypeCode.SByte:
								return checked((sbyte)num8);
							case TypeCode.Byte:
								return checked((byte)num8);
							case TypeCode.Int16:
								return checked((short)num8);
							case TypeCode.UInt16:
								return num8;
							case TypeCode.Int32:
								return (int)num8;
							case TypeCode.UInt32:
								return (uint)num8;
							case TypeCode.Int64:
								return (long)num8;
							case TypeCode.UInt64:
								return (ulong)num8;
							case TypeCode.Single:
								return (float)(int)num8;
							case TypeCode.Double:
								return (double)(int)num8;
							case TypeCode.Decimal:
								return (decimal)num8;
							case TypeCode.DateTime:
								return new DateTime(num8);
							case TypeCode.String:
								return char.ToString(c);
							case (TypeCode)17:
								break;
							}
							break;
						}
					}
					case TypeCode.SByte:
					{
						sbyte b2 = iConvertible.ToSByte(null);
						switch (target)
						{
						case TypeCode.Boolean:
							return b2 != 0;
						case TypeCode.Char:
							unchecked
							{
								return (char)checked((ushort)b2);
							}
						case TypeCode.SByte:
							return b2;
						case TypeCode.Byte:
							return (byte)b2;
						case TypeCode.Int16:
							return unchecked((short)b2);
						case TypeCode.UInt16:
							return (ushort)b2;
						case TypeCode.Int32:
							return unchecked((int)b2);
						case TypeCode.UInt32:
							return (uint)b2;
						case TypeCode.Int64:
							return unchecked((long)b2);
						case TypeCode.UInt64:
							return (ulong)b2;
						case TypeCode.Single:
							return (float)b2;
						case TypeCode.Double:
							return (double)b2;
						case TypeCode.Decimal:
							return (decimal)b2;
						case TypeCode.DateTime:
							return new DateTime(b2);
						case TypeCode.String:
							return b2.ToString(CultureInfo.InvariantCulture);
						case (TypeCode)17:
							break;
						}
						break;
					}
					case TypeCode.Byte:
					{
						byte b = iConvertible.ToByte(null);
						unchecked
						{
							switch (target)
							{
							case TypeCode.Boolean:
								return b != 0;
							case TypeCode.Char:
								return (char)b;
							case TypeCode.SByte:
								return checked((sbyte)b);
							case TypeCode.Byte:
								return b;
							case TypeCode.Int16:
								return (short)b;
							case TypeCode.UInt16:
								return (ushort)b;
							case TypeCode.Int32:
								return (int)b;
							case TypeCode.UInt32:
								return (uint)b;
							case TypeCode.Int64:
								return (long)b;
							case TypeCode.UInt64:
								return (ulong)b;
							case TypeCode.Single:
								return (float)(int)b;
							case TypeCode.Double:
								return (double)(int)b;
							case TypeCode.Decimal:
								return (decimal)b;
							case TypeCode.DateTime:
								return new DateTime(b);
							case TypeCode.String:
								return b.ToString(CultureInfo.InvariantCulture);
							case (TypeCode)17:
								break;
							}
							break;
						}
					}
					case TypeCode.Int16:
					{
						short num9 = iConvertible.ToInt16(null);
						switch (target)
						{
						case TypeCode.Boolean:
							return num9 != 0;
						case TypeCode.Char:
							unchecked
							{
								return (char)checked((ushort)num9);
							}
						case TypeCode.SByte:
							return (sbyte)num9;
						case TypeCode.Byte:
							return (byte)num9;
						case TypeCode.Int16:
							return num9;
						case TypeCode.UInt16:
							return (ushort)num9;
						case TypeCode.Int32:
							return unchecked((int)num9);
						case TypeCode.UInt32:
							return (uint)num9;
						case TypeCode.Int64:
							return unchecked((long)num9);
						case TypeCode.UInt64:
							return (ulong)num9;
						case TypeCode.Single:
							return (float)num9;
						case TypeCode.Double:
							return (double)num9;
						case TypeCode.Decimal:
							return (decimal)num9;
						case TypeCode.DateTime:
							return new DateTime(num9);
						case TypeCode.String:
							return num9.ToString(CultureInfo.InvariantCulture);
						case (TypeCode)17:
							break;
						}
						break;
					}
					case TypeCode.UInt16:
					{
						ushort num8 = iConvertible.ToUInt16(null);
						unchecked
						{
							switch (target)
							{
							case TypeCode.Boolean:
								return num8 != 0;
							case TypeCode.Char:
								return (char)num8;
							case TypeCode.SByte:
								return checked((sbyte)num8);
							case TypeCode.Byte:
								return checked((byte)num8);
							case TypeCode.Int16:
								return checked((short)num8);
							case TypeCode.UInt16:
								return num8;
							case TypeCode.Int32:
								return (int)num8;
							case TypeCode.UInt32:
								return (uint)num8;
							case TypeCode.Int64:
								return (long)num8;
							case TypeCode.UInt64:
								return (ulong)num8;
							case TypeCode.Single:
								return (float)(int)num8;
							case TypeCode.Double:
								return (double)(int)num8;
							case TypeCode.Decimal:
								return (decimal)num8;
							case TypeCode.DateTime:
								return new DateTime(num8);
							case TypeCode.String:
								return num8.ToString(CultureInfo.InvariantCulture);
							case (TypeCode)17:
								break;
							}
							break;
						}
					}
					case TypeCode.Int32:
					{
						int num7 = iConvertible.ToInt32(null);
						switch (target)
						{
						case TypeCode.Boolean:
							return num7 != 0;
						case TypeCode.Char:
							unchecked
							{
								return (char)checked((ushort)num7);
							}
						case TypeCode.SByte:
							return (sbyte)num7;
						case TypeCode.Byte:
							return (byte)num7;
						case TypeCode.Int16:
							return (short)num7;
						case TypeCode.UInt16:
							return (ushort)num7;
						case TypeCode.Int32:
							return num7;
						case TypeCode.UInt32:
							return (uint)num7;
						case TypeCode.Int64:
							return unchecked((long)num7);
						case TypeCode.UInt64:
							return (ulong)num7;
						case TypeCode.Single:
							return (float)num7;
						case TypeCode.Double:
							return (double)num7;
						case TypeCode.Decimal:
							return (decimal)num7;
						case TypeCode.DateTime:
							return new DateTime(num7);
						case TypeCode.String:
							return num7.ToString(CultureInfo.InvariantCulture);
						case (TypeCode)17:
							break;
						}
						break;
					}
					case TypeCode.UInt32:
					{
						uint num6 = iConvertible.ToUInt32(null);
						switch (target)
						{
						case TypeCode.Boolean:
							return num6 != 0;
						case TypeCode.Char:
							unchecked
							{
								return (char)checked((ushort)num6);
							}
						case TypeCode.SByte:
							return (sbyte)num6;
						case TypeCode.Byte:
							return (byte)num6;
						case TypeCode.Int16:
							return (short)num6;
						case TypeCode.UInt16:
							return (ushort)num6;
						case TypeCode.Int32:
							return (int)num6;
						case TypeCode.UInt32:
							return num6;
						case TypeCode.Int64:
							return unchecked((long)num6);
						case TypeCode.UInt64:
							return unchecked((ulong)num6);
						case TypeCode.Single:
							return (float)num6;
						case TypeCode.Double:
							return (double)num6;
						case TypeCode.Decimal:
							return (decimal)num6;
						case TypeCode.DateTime:
							return new DateTime(num6);
						case TypeCode.String:
							return num6.ToString(CultureInfo.InvariantCulture);
						case (TypeCode)17:
							break;
						}
						break;
					}
					case TypeCode.Int64:
					{
						long num5 = iConvertible.ToInt64(null);
						switch (target)
						{
						case TypeCode.Boolean:
							return num5 != 0;
						case TypeCode.Char:
							unchecked
							{
								return (char)checked((ushort)num5);
							}
						case TypeCode.SByte:
							return (sbyte)num5;
						case TypeCode.Byte:
							return (byte)num5;
						case TypeCode.Int16:
							return (short)num5;
						case TypeCode.UInt16:
							return (ushort)num5;
						case TypeCode.Int32:
							return (int)num5;
						case TypeCode.UInt32:
							return (uint)num5;
						case TypeCode.Int64:
							return num5;
						case TypeCode.UInt64:
							return (ulong)num5;
						case TypeCode.Single:
							return (float)num5;
						case TypeCode.Double:
							return (double)num5;
						case TypeCode.Decimal:
							return (decimal)num5;
						case TypeCode.DateTime:
							return new DateTime(num5);
						case TypeCode.String:
							return num5.ToString(CultureInfo.InvariantCulture);
						case (TypeCode)17:
							break;
						}
						break;
					}
					case TypeCode.UInt64:
					{
						ulong num4 = iConvertible.ToUInt64(null);
						switch (target)
						{
						case TypeCode.Boolean:
							return num4 != 0;
						case TypeCode.Char:
							unchecked
							{
								return (char)checked((ushort)num4);
							}
						case TypeCode.SByte:
							return (sbyte)num4;
						case TypeCode.Byte:
							return (byte)num4;
						case TypeCode.Int16:
							return (short)num4;
						case TypeCode.UInt16:
							return (ushort)num4;
						case TypeCode.Int32:
							return (int)num4;
						case TypeCode.UInt32:
							return (uint)num4;
						case TypeCode.Int64:
							return (long)num4;
						case TypeCode.UInt64:
							return num4;
						case TypeCode.Single:
							return (float)num4;
						case TypeCode.Double:
							return (double)num4;
						case TypeCode.Decimal:
							return (decimal)num4;
						case TypeCode.DateTime:
							return new DateTime((long)num4);
						case TypeCode.String:
							return num4.ToString(CultureInfo.InvariantCulture);
						case (TypeCode)17:
							break;
						}
						break;
					}
					case TypeCode.Single:
					{
						float num3 = iConvertible.ToSingle(null);
						switch (target)
						{
						case TypeCode.Boolean:
							if (num3 != num3)
							{
								return false;
							}
							return num3 != 0f;
						case TypeCode.Single:
							return num3;
						case TypeCode.Double:
							return (double)num3;
						case TypeCode.Decimal:
							return (decimal)num3;
						case TypeCode.String:
							return ToString(num3);
						default:
							if (Math.Round(num3) == (double)num3)
							{
								switch (target)
								{
								case TypeCode.Char:
									unchecked
									{
										return (char)checked((ushort)num3);
									}
								case TypeCode.SByte:
									return (sbyte)num3;
								case TypeCode.Byte:
									return (byte)num3;
								case TypeCode.Int16:
									return (short)num3;
								case TypeCode.UInt16:
									return (ushort)num3;
								case TypeCode.Int32:
									return (int)num3;
								case TypeCode.UInt32:
									return (uint)num3;
								case TypeCode.Int64:
									return (long)num3;
								case TypeCode.UInt64:
									return (ulong)num3;
								case TypeCode.DateTime:
									return new DateTime((long)num3);
								case TypeCode.Single:
								case TypeCode.Double:
								case TypeCode.Decimal:
									break;
								}
							}
							break;
						}
						break;
					}
					case TypeCode.Double:
					{
						double num2 = iConvertible.ToDouble(null);
						switch (target)
						{
						case TypeCode.Boolean:
							return ToBoolean(num2);
						case TypeCode.Single:
							return (float)num2;
						case TypeCode.Double:
							return num2;
						case TypeCode.Decimal:
							return (decimal)num2;
						case TypeCode.String:
							return ToString(num2);
						default:
							if (Math.Round(num2) == num2)
							{
								switch (target)
								{
								case TypeCode.Char:
									unchecked
									{
										return (char)checked((ushort)num2);
									}
								case TypeCode.SByte:
									return (sbyte)num2;
								case TypeCode.Byte:
									return (byte)num2;
								case TypeCode.Int16:
									return (short)num2;
								case TypeCode.UInt16:
									return (ushort)num2;
								case TypeCode.Int32:
									return (int)num2;
								case TypeCode.UInt32:
									return (uint)num2;
								case TypeCode.Int64:
									return (long)num2;
								case TypeCode.UInt64:
									return (ulong)num2;
								case TypeCode.DateTime:
									return new DateTime((long)num2);
								case TypeCode.Single:
								case TypeCode.Double:
								case TypeCode.Decimal:
									break;
								}
							}
							break;
						}
						break;
					}
					case TypeCode.Decimal:
					{
						decimal num = iConvertible.ToDecimal(null);
						switch (target)
						{
						case TypeCode.Boolean:
							return num != 0m;
						case TypeCode.Char:
							return unchecked((char)decimal.ToUInt16(num));
						case TypeCode.SByte:
							return decimal.ToSByte(num);
						case TypeCode.Byte:
							return decimal.ToByte(num);
						case TypeCode.Int16:
							return decimal.ToInt16(num);
						case TypeCode.UInt16:
							return decimal.ToUInt16(num);
						case TypeCode.Int32:
							return decimal.ToInt32(num);
						case TypeCode.UInt32:
							return decimal.ToUInt32(num);
						case TypeCode.Int64:
							return decimal.ToInt64(num);
						case TypeCode.UInt64:
							return decimal.ToUInt64(num);
						case TypeCode.Single:
							return decimal.ToSingle(num);
						case TypeCode.Double:
							return decimal.ToDouble(num);
						case TypeCode.Decimal:
							return num;
						case TypeCode.DateTime:
							return new DateTime(decimal.ToInt64(num));
						case TypeCode.String:
							return num.ToString(CultureInfo.InvariantCulture);
						case (TypeCode)17:
							break;
						}
						break;
					}
					case TypeCode.DateTime:
					{
						DateTime dateTime = iConvertible.ToDateTime(null);
						switch (target)
						{
						case TypeCode.Boolean:
						case TypeCode.Char:
						case TypeCode.SByte:
						case TypeCode.Byte:
						case TypeCode.Int16:
						case TypeCode.UInt16:
						case TypeCode.Int32:
						case TypeCode.UInt32:
						case TypeCode.Int64:
						case TypeCode.UInt64:
						case TypeCode.Single:
						case TypeCode.Double:
						case TypeCode.Decimal:
							return Coerce2WithNoTrunctation(dateTime.Ticks, target);
						case TypeCode.DateTime:
							return dateTime;
						case TypeCode.String:
							return dateTime.ToString(CultureInfo.InvariantCulture);
						case (TypeCode)17:
							break;
						}
						break;
					}
					case TypeCode.String:
					{
						string text = iConvertible.ToString(null);
						switch (target)
						{
						case TypeCode.Boolean:
							return ToBoolean(text, explicitConversion: false);
						case TypeCode.Char:
							if (text.Length == 1)
							{
								return text[0];
							}
							throw new JScriptException(JSError.TypeMismatch);
						case TypeCode.SByte:
						case TypeCode.Byte:
						case TypeCode.Int16:
						case TypeCode.UInt16:
						case TypeCode.Int32:
						case TypeCode.UInt32:
						case TypeCode.Double:
							return Coerce2WithNoTrunctation(ToNumber(text), target);
						case TypeCode.Single:
							try
							{
								return float.Parse(text, CultureInfo.InvariantCulture);
							}
							catch
							{
							}
							goto case TypeCode.SByte;
						case TypeCode.Int64:
							try
							{
								return long.Parse(text, CultureInfo.InvariantCulture);
							}
							catch
							{
							}
							goto case TypeCode.SByte;
						case TypeCode.UInt64:
							try
							{
								return ulong.Parse(text, CultureInfo.InvariantCulture);
							}
							catch
							{
							}
							goto case TypeCode.SByte;
						case TypeCode.Decimal:
							try
							{
								return decimal.Parse(text, CultureInfo.InvariantCulture);
							}
							catch
							{
							}
							goto case TypeCode.SByte;
						case TypeCode.DateTime:
							try
							{
								return DateTime.Parse(text, CultureInfo.InvariantCulture);
							}
							catch
							{
								return DatePrototype.getVarDate(DateConstructor.ob.CreateInstance(DatePrototype.ParseDate(text)));
							}
						case TypeCode.String:
							return text;
						case (TypeCode)17:
							break;
						}
						break;
					}
					case (TypeCode)17:
						break;
					}
				}
				catch (OverflowException)
				{
				}
				throw new JScriptException(JSError.TypeMismatch);
			}
		}

		private static object Coerce2WithTruncationPermitted(object value, TypeCode target)
		{
			if (value is EnumWrapper)
			{
				value = ((EnumWrapper)value).value;
			}
			if (value is ConstantWrapper)
			{
				value = ((ConstantWrapper)value).value;
			}
			IConvertible iConvertible = GetIConvertible(value);
			switch (GetTypeCode(value, iConvertible))
			{
			case TypeCode.Empty:
				switch (target)
				{
				case TypeCode.DBNull:
					return DBNull.Value;
				case TypeCode.Boolean:
					return false;
				case TypeCode.Char:
					return '\0';
				case TypeCode.SByte:
					return (sbyte)0;
				case TypeCode.Byte:
					return (byte)0;
				case TypeCode.Int16:
					return (short)0;
				case TypeCode.UInt16:
					return (ushort)0;
				case TypeCode.Int32:
					return 0;
				case TypeCode.UInt32:
					return 0u;
				case TypeCode.Int64:
					return 0L;
				case TypeCode.UInt64:
					return 0uL;
				case TypeCode.Single:
					return float.NaN;
				case TypeCode.Double:
					return double.NaN;
				case TypeCode.Decimal:
					return 0m;
				case TypeCode.DateTime:
					return new DateTime(0L);
				case TypeCode.String:
					return "undefined";
				}
				break;
			case TypeCode.Object:
				if (!(value is System.Reflection.Missing) && (!(value is Missing) || target == TypeCode.Object))
				{
					switch (target)
					{
					case TypeCode.Boolean:
						return ToBoolean(value, iConvertible);
					case TypeCode.Char:
					case TypeCode.SByte:
					case TypeCode.Byte:
					case TypeCode.Int16:
					case TypeCode.UInt16:
					case TypeCode.Int32:
					case TypeCode.UInt32:
					case TypeCode.Int64:
					case TypeCode.UInt64:
					case TypeCode.Single:
					case TypeCode.Double:
					case TypeCode.Decimal:
						return Coerce2WithTruncationPermitted(ToNumber(value, iConvertible), target);
					case TypeCode.DateTime:
						if (value is DateObject)
						{
							return DatePrototype.getVarDate((DateObject)value);
						}
						return Coerce2WithTruncationPermitted(ToNumber(value, iConvertible), target);
					case TypeCode.String:
						return ToString(value, iConvertible);
					}
					break;
				}
				goto case TypeCode.Empty;
			case TypeCode.DBNull:
				switch (target)
				{
				case TypeCode.DBNull:
					return DBNull.Value;
				case TypeCode.Boolean:
					return false;
				case TypeCode.Char:
					return '\0';
				case TypeCode.SByte:
					return (sbyte)0;
				case TypeCode.Byte:
					return (byte)0;
				case TypeCode.Int16:
					return (short)0;
				case TypeCode.UInt16:
					return (ushort)0;
				case TypeCode.Int32:
					return 0;
				case TypeCode.UInt32:
					return 0u;
				case TypeCode.Int64:
					return 0L;
				case TypeCode.UInt64:
					return 0uL;
				case TypeCode.Single:
					return 0f;
				case TypeCode.Double:
					return 0.0;
				case TypeCode.Decimal:
					return 0m;
				case TypeCode.DateTime:
					return new DateTime(0L);
				case TypeCode.String:
					return "null";
				}
				break;
			case TypeCode.Boolean:
			{
				bool flag = iConvertible.ToBoolean(null);
				int num10 = (flag ? 1 : 0);
				switch (target)
				{
				case TypeCode.Boolean:
					return flag;
				case TypeCode.Char:
					return (char)num10;
				case TypeCode.SByte:
					return (sbyte)num10;
				case TypeCode.Byte:
					return (byte)num10;
				case TypeCode.Int16:
					return (short)num10;
				case TypeCode.UInt16:
					return (ushort)num10;
				case TypeCode.Int32:
					return num10;
				case TypeCode.UInt32:
					return (uint)num10;
				case TypeCode.Int64:
					return (long)num10;
				case TypeCode.UInt64:
					return (ulong)num10;
				case TypeCode.Single:
					return (float)num10;
				case TypeCode.Double:
					return (double)num10;
				case TypeCode.Decimal:
					return (decimal)num10;
				case TypeCode.DateTime:
					return new DateTime(num10);
				case TypeCode.String:
					if (!flag)
					{
						return "false";
					}
					return "true";
				}
				break;
			}
			case TypeCode.Char:
			{
				char c = iConvertible.ToChar(null);
				ushort num8 = c;
				switch (target)
				{
				case TypeCode.Boolean:
					return num8 != 0;
				case TypeCode.Char:
					return c;
				case TypeCode.SByte:
					return (sbyte)num8;
				case TypeCode.Byte:
					return (byte)num8;
				case TypeCode.Int16:
					return (short)num8;
				case TypeCode.UInt16:
					return num8;
				case TypeCode.Int32:
					return (int)num8;
				case TypeCode.UInt32:
					return (uint)num8;
				case TypeCode.Int64:
					return (long)num8;
				case TypeCode.UInt64:
					return (ulong)num8;
				case TypeCode.Single:
					return (float)(int)num8;
				case TypeCode.Double:
					return (double)(int)num8;
				case TypeCode.Decimal:
					return (decimal)num8;
				case TypeCode.DateTime:
					return new DateTime(num8);
				case TypeCode.String:
					return char.ToString(c);
				}
				break;
			}
			case TypeCode.SByte:
			{
				sbyte b2 = iConvertible.ToSByte(null);
				switch (target)
				{
				case TypeCode.Boolean:
					return b2 != 0;
				case TypeCode.Char:
					return (char)b2;
				case TypeCode.SByte:
					return b2;
				case TypeCode.Byte:
					return (byte)b2;
				case TypeCode.Int16:
					return (short)b2;
				case TypeCode.UInt16:
					return (ushort)b2;
				case TypeCode.Int32:
					return (int)b2;
				case TypeCode.UInt32:
					return (uint)b2;
				case TypeCode.Int64:
					return (long)b2;
				case TypeCode.UInt64:
					return (ulong)b2;
				case TypeCode.Single:
					return (float)b2;
				case TypeCode.Double:
					return (double)b2;
				case TypeCode.Decimal:
					return (decimal)b2;
				case TypeCode.DateTime:
					return new DateTime(b2);
				case TypeCode.String:
					return b2.ToString(CultureInfo.InvariantCulture);
				}
				break;
			}
			case TypeCode.Byte:
			{
				byte b = iConvertible.ToByte(null);
				switch (target)
				{
				case TypeCode.Boolean:
					return b != 0;
				case TypeCode.Char:
					return (char)b;
				case TypeCode.SByte:
					return (sbyte)b;
				case TypeCode.Byte:
					return b;
				case TypeCode.Int16:
					return (short)b;
				case TypeCode.UInt16:
					return (ushort)b;
				case TypeCode.Int32:
					return (int)b;
				case TypeCode.UInt32:
					return (uint)b;
				case TypeCode.Int64:
					return (long)b;
				case TypeCode.UInt64:
					return (ulong)b;
				case TypeCode.Single:
					return (float)(int)b;
				case TypeCode.Double:
					return (double)(int)b;
				case TypeCode.Decimal:
					return (decimal)b;
				case TypeCode.DateTime:
					return new DateTime(b);
				case TypeCode.String:
					return b.ToString(CultureInfo.InvariantCulture);
				}
				break;
			}
			case TypeCode.Int16:
			{
				short num9 = iConvertible.ToInt16(null);
				switch (target)
				{
				case TypeCode.Boolean:
					return num9 != 0;
				case TypeCode.Char:
					return (char)num9;
				case TypeCode.SByte:
					return (sbyte)num9;
				case TypeCode.Byte:
					return (byte)num9;
				case TypeCode.Int16:
					return num9;
				case TypeCode.UInt16:
					return (ushort)num9;
				case TypeCode.Int32:
					return (int)num9;
				case TypeCode.UInt32:
					return (uint)num9;
				case TypeCode.Int64:
					return (long)num9;
				case TypeCode.UInt64:
					return (ulong)num9;
				case TypeCode.Single:
					return (float)num9;
				case TypeCode.Double:
					return (double)num9;
				case TypeCode.Decimal:
					return (decimal)num9;
				case TypeCode.DateTime:
					return new DateTime(num9);
				case TypeCode.String:
					return num9.ToString(CultureInfo.InvariantCulture);
				}
				break;
			}
			case TypeCode.UInt16:
			{
				ushort num8 = iConvertible.ToUInt16(null);
				switch (target)
				{
				case TypeCode.Boolean:
					return num8 != 0;
				case TypeCode.Char:
					return (char)num8;
				case TypeCode.SByte:
					return (sbyte)num8;
				case TypeCode.Byte:
					return (byte)num8;
				case TypeCode.Int16:
					return (short)num8;
				case TypeCode.UInt16:
					return num8;
				case TypeCode.Int32:
					return (int)num8;
				case TypeCode.UInt32:
					return (uint)num8;
				case TypeCode.Int64:
					return (long)num8;
				case TypeCode.UInt64:
					return (ulong)num8;
				case TypeCode.Single:
					return (float)(int)num8;
				case TypeCode.Double:
					return (double)(int)num8;
				case TypeCode.Decimal:
					return (decimal)num8;
				case TypeCode.DateTime:
					return new DateTime(num8);
				case TypeCode.String:
					return num8.ToString(CultureInfo.InvariantCulture);
				}
				break;
			}
			case TypeCode.Int32:
			{
				int num7 = iConvertible.ToInt32(null);
				switch (target)
				{
				case TypeCode.Boolean:
					return num7 != 0;
				case TypeCode.Char:
					return (char)num7;
				case TypeCode.SByte:
					return (sbyte)num7;
				case TypeCode.Byte:
					return (byte)num7;
				case TypeCode.Int16:
					return (short)num7;
				case TypeCode.UInt16:
					return (ushort)num7;
				case TypeCode.Int32:
					return num7;
				case TypeCode.UInt32:
					return (uint)num7;
				case TypeCode.Int64:
					return (long)num7;
				case TypeCode.UInt64:
					return (ulong)num7;
				case TypeCode.Single:
					return (float)num7;
				case TypeCode.Double:
					return (double)num7;
				case TypeCode.Decimal:
					return (decimal)num7;
				case TypeCode.DateTime:
					return new DateTime(num7);
				case TypeCode.String:
					return num7.ToString(CultureInfo.InvariantCulture);
				}
				break;
			}
			case TypeCode.UInt32:
			{
				uint num6 = iConvertible.ToUInt32(null);
				switch (target)
				{
				case TypeCode.Boolean:
					return num6 != 0;
				case TypeCode.Char:
					return (char)num6;
				case TypeCode.SByte:
					return (sbyte)num6;
				case TypeCode.Byte:
					return (byte)num6;
				case TypeCode.Int16:
					return (short)num6;
				case TypeCode.UInt16:
					return (ushort)num6;
				case TypeCode.Int32:
					return (int)num6;
				case TypeCode.UInt32:
					return num6;
				case TypeCode.Int64:
					return (long)num6;
				case TypeCode.UInt64:
					return (ulong)num6;
				case TypeCode.Single:
					return (float)num6;
				case TypeCode.Double:
					return (double)num6;
				case TypeCode.Decimal:
					return (decimal)num6;
				case TypeCode.DateTime:
					return new DateTime(num6);
				case TypeCode.String:
					return num6.ToString(CultureInfo.InvariantCulture);
				}
				break;
			}
			case TypeCode.Int64:
			{
				long num3 = iConvertible.ToInt64(null);
				switch (target)
				{
				case TypeCode.Boolean:
					return num3 != 0;
				case TypeCode.Char:
					return (char)num3;
				case TypeCode.SByte:
					return (sbyte)num3;
				case TypeCode.Byte:
					return (byte)num3;
				case TypeCode.Int16:
					return (short)num3;
				case TypeCode.UInt16:
					return (ushort)num3;
				case TypeCode.Int32:
					return (int)num3;
				case TypeCode.UInt32:
					return (uint)num3;
				case TypeCode.Int64:
					return num3;
				case TypeCode.UInt64:
					return (ulong)num3;
				case TypeCode.Single:
					return (float)num3;
				case TypeCode.Double:
					return (double)num3;
				case TypeCode.Decimal:
					return (decimal)num3;
				case TypeCode.DateTime:
					return new DateTime(num3);
				case TypeCode.String:
					return num3.ToString(CultureInfo.InvariantCulture);
				}
				break;
			}
			case TypeCode.UInt64:
			{
				ulong num5 = iConvertible.ToUInt64(null);
				switch (target)
				{
				case TypeCode.Boolean:
					return num5 != 0;
				case TypeCode.Char:
					return (char)num5;
				case TypeCode.SByte:
					return (sbyte)num5;
				case TypeCode.Byte:
					return (byte)num5;
				case TypeCode.Int16:
					return (short)num5;
				case TypeCode.UInt16:
					return (ushort)num5;
				case TypeCode.Int32:
					return (int)num5;
				case TypeCode.UInt32:
					return (uint)num5;
				case TypeCode.Int64:
					return (long)num5;
				case TypeCode.UInt64:
					return num5;
				case TypeCode.Single:
					return (float)num5;
				case TypeCode.Double:
					return (double)num5;
				case TypeCode.Decimal:
					return (decimal)num5;
				case TypeCode.DateTime:
					return new DateTime((long)num5);
				case TypeCode.String:
					return num5.ToString(CultureInfo.InvariantCulture);
				}
				break;
			}
			case TypeCode.Single:
			{
				float num4 = iConvertible.ToSingle(null);
				switch (target)
				{
				case TypeCode.Boolean:
					if (num4 != num4)
					{
						return false;
					}
					return num4 != 0f;
				case TypeCode.Single:
					return num4;
				case TypeCode.Double:
					return (double)num4;
				case TypeCode.Decimal:
					return (decimal)num4;
				case TypeCode.String:
					return ToString(num4);
				}
				long num3 = Runtime.DoubleToInt64(num4);
				switch (target)
				{
				case TypeCode.Char:
					return (char)num3;
				case TypeCode.SByte:
					return (sbyte)num3;
				case TypeCode.Byte:
					return (byte)num3;
				case TypeCode.Int16:
					return (short)num3;
				case TypeCode.UInt16:
					return (ushort)num3;
				case TypeCode.Int32:
					return (int)num3;
				case TypeCode.UInt32:
					return (uint)num3;
				case TypeCode.Int64:
					return num3;
				case TypeCode.UInt64:
					return (ulong)num3;
				case TypeCode.DateTime:
					return new DateTime(num3);
				}
				break;
			}
			case TypeCode.Double:
			{
				double num2 = iConvertible.ToDouble(null);
				switch (target)
				{
				case TypeCode.Boolean:
					return ToBoolean(num2);
				case TypeCode.Single:
					return (float)num2;
				case TypeCode.Double:
					return num2;
				case TypeCode.Decimal:
					return (decimal)num2;
				case TypeCode.String:
					return ToString(num2);
				}
				long num3 = Runtime.DoubleToInt64(num2);
				switch (target)
				{
				case TypeCode.Char:
					return (char)num3;
				case TypeCode.SByte:
					return (sbyte)num3;
				case TypeCode.Byte:
					return (byte)num3;
				case TypeCode.Int16:
					return (short)num3;
				case TypeCode.UInt16:
					return (ushort)num3;
				case TypeCode.Int32:
					return (int)num3;
				case TypeCode.UInt32:
					return (uint)num3;
				case TypeCode.Int64:
					return num3;
				case TypeCode.UInt64:
					return (ulong)num3;
				case TypeCode.DateTime:
					return new DateTime(num3);
				}
				break;
			}
			case TypeCode.Decimal:
			{
				decimal num = iConvertible.ToDecimal(null);
				switch (target)
				{
				case TypeCode.Boolean:
					return num != 0m;
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
					return Coerce2WithTruncationPermitted(Runtime.UncheckedDecimalToInt64(num), target);
				case TypeCode.Single:
					return decimal.ToSingle(num);
				case TypeCode.Double:
					return decimal.ToDouble(num);
				case TypeCode.Decimal:
					return num;
				case TypeCode.DateTime:
					return new DateTime(Runtime.UncheckedDecimalToInt64(num));
				case TypeCode.String:
					return num.ToString(CultureInfo.InvariantCulture);
				}
				break;
			}
			case TypeCode.DateTime:
			{
				DateTime dateTime = iConvertible.ToDateTime(null);
				switch (target)
				{
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					return Coerce2WithTruncationPermitted(dateTime.Ticks, target);
				case TypeCode.DateTime:
					return dateTime;
				case TypeCode.String:
					return dateTime.ToString(CultureInfo.InvariantCulture);
				}
				break;
			}
			case TypeCode.String:
			{
				string text = iConvertible.ToString(null);
				switch (target)
				{
				case TypeCode.Boolean:
					return ToBoolean(text, explicitConversion: false);
				case TypeCode.Char:
					if (text.Length == 1)
					{
						return text[0];
					}
					throw new JScriptException(JSError.TypeMismatch);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Double:
					return Coerce2WithTruncationPermitted(ToNumber(text), target);
				case TypeCode.Single:
					try
					{
						return float.Parse(text, CultureInfo.InvariantCulture);
					}
					catch
					{
					}
					goto case TypeCode.SByte;
				case TypeCode.Int64:
					try
					{
						return long.Parse(text, CultureInfo.InvariantCulture);
					}
					catch
					{
						try
						{
							return (long)ulong.Parse(text, CultureInfo.InvariantCulture);
						}
						catch
						{
						}
					}
					goto case TypeCode.SByte;
				case TypeCode.UInt64:
					try
					{
						return ulong.Parse(text, CultureInfo.InvariantCulture);
					}
					catch
					{
					}
					goto case TypeCode.SByte;
				case TypeCode.Decimal:
					try
					{
						return decimal.Parse(text, CultureInfo.InvariantCulture);
					}
					catch
					{
					}
					goto case TypeCode.SByte;
				case TypeCode.DateTime:
					return DateTime.Parse(text, CultureInfo.InvariantCulture);
				case TypeCode.String:
					return text;
				}
				break;
			}
			}
			throw new JScriptException(JSError.TypeMismatch);
		}

		internal static void Emit(AST ast, ILGenerator il, Type source_type, Type target_type)
		{
			Emit(ast, il, source_type, target_type, truncationPermitted: false);
		}

		internal static void Emit(AST ast, ILGenerator il, Type source_type, Type target_type, bool truncationPermitted)
		{
			if (source_type == target_type)
			{
				return;
			}
			if (target_type == Typeob.Void)
			{
				il.Emit(OpCodes.Pop);
				return;
			}
			if (target_type.IsEnum)
			{
				if (source_type == Typeob.String || source_type == Typeob.Object)
				{
					il.Emit(OpCodes.Ldtoken, target_type);
					il.Emit(OpCodes.Call, CompilerGlobals.getTypeFromHandleMethod);
					ConstantWrapper.TranslateToILInt(il, truncationPermitted ? 1 : 0);
					il.Emit(OpCodes.Call, CompilerGlobals.coerceTMethod);
					EmitUnbox(il, target_type, Type.GetTypeCode(GetUnderlyingType(target_type)));
				}
				else
				{
					Emit(ast, il, source_type, GetUnderlyingType(target_type));
				}
				return;
			}
			if (source_type.IsEnum)
			{
				if (target_type.IsPrimitive)
				{
					Emit(ast, il, GetUnderlyingType(source_type), target_type);
					return;
				}
				if (target_type == Typeob.Object || target_type == Typeob.Enum)
				{
					il.Emit(OpCodes.Box, source_type);
					return;
				}
				if (target_type == Typeob.String)
				{
					il.Emit(OpCodes.Box, source_type);
					ConstantWrapper.TranslateToILInt(il, 0);
					il.Emit(OpCodes.Call, CompilerGlobals.toStringMethod);
					return;
				}
			}
			while (source_type is TypeBuilder)
			{
				source_type = source_type.BaseType;
				if (source_type == null)
				{
					source_type = Typeob.Object;
				}
				if (source_type == target_type)
				{
					return;
				}
			}
			if (source_type.IsArray && target_type.IsArray)
			{
				return;
			}
			TypeCode typeCode = Type.GetTypeCode(source_type);
			TypeCode typeCode2 = ((target_type is TypeBuilder) ? TypeCode.Object : Type.GetTypeCode(target_type));
			switch (typeCode)
			{
			case TypeCode.Empty:
				return;
			case TypeCode.Object:
				if (source_type == Typeob.Void)
				{
					il.Emit(OpCodes.Ldnull);
					source_type = Typeob.Object;
				}
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (target_type.IsArray || target_type == Typeob.Array)
					{
						if (source_type == Typeob.ArrayObject || source_type == Typeob.Object)
						{
							if (target_type.IsArray)
							{
								il.Emit(OpCodes.Ldtoken, target_type.GetElementType());
							}
							else
							{
								il.Emit(OpCodes.Ldtoken, Typeob.Object);
							}
							il.Emit(OpCodes.Call, CompilerGlobals.toNativeArrayMethod);
						}
						il.Emit(OpCodes.Castclass, target_type);
					}
					else if (target_type is TypeBuilder)
					{
						il.Emit(OpCodes.Castclass, target_type);
					}
					else if (target_type == Typeob.Enum && source_type.BaseType == Typeob.Enum)
					{
						il.Emit(OpCodes.Box, source_type);
					}
					else if (target_type == Typeob.Object || target_type.IsAssignableFrom(source_type))
					{
						if (source_type.IsValueType)
						{
							il.Emit(OpCodes.Box, source_type);
						}
					}
					else if (Typeob.JSObject.IsAssignableFrom(target_type))
					{
						if (source_type.IsValueType)
						{
							il.Emit(OpCodes.Box, source_type);
						}
						ast.EmitILToLoadEngine(il);
						il.Emit(OpCodes.Call, CompilerGlobals.toObject2Method);
						il.Emit(OpCodes.Castclass, target_type);
					}
					else if (!EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						if (target_type.IsValueType || target_type.IsArray)
						{
							il.Emit(OpCodes.Ldtoken, target_type);
							il.Emit(OpCodes.Call, CompilerGlobals.getTypeFromHandleMethod);
							ConstantWrapper.TranslateToILInt(il, truncationPermitted ? 1 : 0);
							il.Emit(OpCodes.Call, CompilerGlobals.coerceTMethod);
						}
						if (target_type.IsValueType)
						{
							EmitUnbox(il, target_type, typeCode2);
						}
						else
						{
							il.Emit(OpCodes.Castclass, target_type);
						}
					}
					break;
				case TypeCode.Boolean:
					if (source_type.IsValueType)
					{
						il.Emit(OpCodes.Box, source_type);
					}
					ConstantWrapper.TranslateToILInt(il, truncationPermitted ? 1 : 0);
					il.Emit(OpCodes.Call, CompilerGlobals.toBooleanMethod);
					break;
				case TypeCode.Single:
					if (source_type.IsValueType)
					{
						il.Emit(OpCodes.Box, source_type);
					}
					il.Emit(OpCodes.Call, CompilerGlobals.toNumberMethod);
					il.Emit(OpCodes.Conv_R4);
					break;
				case TypeCode.Double:
					if (source_type.IsValueType)
					{
						il.Emit(OpCodes.Box, source_type);
					}
					il.Emit(OpCodes.Call, CompilerGlobals.toNumberMethod);
					break;
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Decimal:
				case TypeCode.DateTime:
					if (source_type.IsValueType)
					{
						il.Emit(OpCodes.Box, source_type);
					}
					if (truncationPermitted && typeCode2 == TypeCode.Int32)
					{
						il.Emit(OpCodes.Call, CompilerGlobals.toInt32Method);
						break;
					}
					ConstantWrapper.TranslateToILInt(il, (int)typeCode2);
					ConstantWrapper.TranslateToILInt(il, truncationPermitted ? 1 : 0);
					il.Emit(OpCodes.Call, CompilerGlobals.coerce2Method);
					if (target_type.IsValueType)
					{
						EmitUnbox(il, target_type, typeCode2);
					}
					break;
				case TypeCode.String:
					if (source_type.IsValueType)
					{
						il.Emit(OpCodes.Box, source_type);
					}
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Castclass, Typeob.String);
						break;
					}
					ConstantWrapper.TranslateToILInt(il, 1);
					il.Emit(OpCodes.Call, CompilerGlobals.toStringMethod);
					break;
				case TypeCode.DBNull:
				case (TypeCode)17:
					break;
				}
				return;
			case TypeCode.DBNull:
				if (source_type.IsValueType)
				{
					il.Emit(OpCodes.Box, source_type);
				}
				if (typeCode2 == TypeCode.Object || (typeCode2 == TypeCode.String && !truncationPermitted))
				{
					if (target_type == Typeob.Object)
					{
						return;
					}
					if (!target_type.IsValueType)
					{
						il.Emit(OpCodes.Pop);
						il.Emit(OpCodes.Ldnull);
						return;
					}
				}
				if (target_type.IsValueType)
				{
					il.Emit(OpCodes.Ldtoken, target_type);
					il.Emit(OpCodes.Call, CompilerGlobals.getTypeFromHandleMethod);
					ConstantWrapper.TranslateToILInt(il, truncationPermitted ? 1 : 0);
					il.Emit(OpCodes.Call, CompilerGlobals.coerceTMethod);
					EmitUnbox(il, target_type, typeCode2);
				}
				else
				{
					ConstantWrapper.TranslateToILInt(il, (int)typeCode2);
					ConstantWrapper.TranslateToILInt(il, truncationPermitted ? 1 : 0);
					il.Emit(OpCodes.Call, CompilerGlobals.coerce2Method);
				}
				return;
			case TypeCode.Boolean:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
					return;
				case TypeCode.Int64:
				case TypeCode.UInt64:
					il.Emit(OpCodes.Conv_U8);
					return;
				case TypeCode.Single:
					il.Emit(OpCodes.Conv_R4);
					return;
				case TypeCode.Double:
					il.Emit(OpCodes.Conv_R8);
					return;
				case TypeCode.Decimal:
					il.Emit(OpCodes.Call, CompilerGlobals.int32ToDecimalMethod);
					return;
				case TypeCode.DateTime:
					il.Emit(OpCodes.Conv_I8);
					il.Emit(OpCodes.Newobj, CompilerGlobals.dateTimeConstructor);
					return;
				case TypeCode.String:
				{
					Label label = il.DefineLabel();
					Label label2 = il.DefineLabel();
					il.Emit(OpCodes.Brfalse, label);
					il.Emit(OpCodes.Ldstr, "true");
					il.Emit(OpCodes.Br, label2);
					il.MarkLabel(label);
					il.Emit(OpCodes.Ldstr, "false");
					il.MarkLabel(label2);
					return;
				}
				}
				break;
			case TypeCode.SByte:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.SByte:
				case TypeCode.Int16:
				case TypeCode.Int32:
					return;
				case TypeCode.Byte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U1);
					}
					return;
				case TypeCode.Char:
				case TypeCode.UInt16:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U2);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U2);
					}
					return;
				case TypeCode.UInt32:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U4);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U4);
					}
					return;
				case TypeCode.Int64:
					il.Emit(OpCodes.Conv_I8);
					return;
				case TypeCode.UInt64:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I8);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U8);
					}
					return;
				case TypeCode.Single:
				case TypeCode.Double:
					il.Emit(OpCodes.Conv_R8);
					return;
				case TypeCode.Boolean:
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					return;
				case TypeCode.Decimal:
					il.Emit(OpCodes.Call, CompilerGlobals.int32ToDecimalMethod);
					return;
				case TypeCode.DateTime:
					il.Emit(OpCodes.Conv_I8);
					il.Emit(OpCodes.Newobj, CompilerGlobals.dateTimeConstructor);
					return;
				case TypeCode.String:
					EmitLdloca(il, Typeob.Int32);
					il.Emit(OpCodes.Call, CompilerGlobals.int32ToStringMethod);
					return;
				}
				break;
			case TypeCode.Byte:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.SByte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I1_Un);
					}
					return;
				case TypeCode.Char:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
					return;
				case TypeCode.Int64:
				case TypeCode.UInt64:
					il.Emit(OpCodes.Conv_U8);
					return;
				case TypeCode.Single:
				case TypeCode.Double:
					il.Emit(OpCodes.Conv_R_Un);
					return;
				case TypeCode.Boolean:
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					return;
				case TypeCode.Decimal:
					il.Emit(OpCodes.Call, CompilerGlobals.uint32ToDecimalMethod);
					return;
				case TypeCode.DateTime:
					il.Emit(OpCodes.Conv_I8);
					il.Emit(OpCodes.Newobj, CompilerGlobals.dateTimeConstructor);
					return;
				case TypeCode.String:
					EmitLdloca(il, Typeob.UInt32);
					il.Emit(OpCodes.Call, CompilerGlobals.uint32ToStringMethod);
					return;
				}
				break;
			case TypeCode.Int16:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.SByte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I1);
					}
					return;
				case TypeCode.Int16:
				case TypeCode.Int32:
					return;
				case TypeCode.Byte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U1);
					}
					return;
				case TypeCode.Char:
				case TypeCode.UInt16:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U2);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U2);
					}
					return;
				case TypeCode.UInt32:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U4);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U4);
					}
					return;
				case TypeCode.Int64:
					il.Emit(OpCodes.Conv_I8);
					return;
				case TypeCode.UInt64:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I8);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U8);
					}
					return;
				case TypeCode.Single:
				case TypeCode.Double:
					il.Emit(OpCodes.Conv_R8);
					return;
				case TypeCode.Boolean:
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					return;
				case TypeCode.Decimal:
					il.Emit(OpCodes.Call, CompilerGlobals.int32ToDecimalMethod);
					return;
				case TypeCode.DateTime:
					il.Emit(OpCodes.Conv_I8);
					il.Emit(OpCodes.Newobj, CompilerGlobals.dateTimeConstructor);
					return;
				case TypeCode.String:
					EmitLdloca(il, Typeob.Int32);
					il.Emit(OpCodes.Call, CompilerGlobals.int32ToStringMethod);
					return;
				}
				break;
			case TypeCode.Char:
			case TypeCode.UInt16:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.SByte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I1);
					}
					return;
				case TypeCode.Byte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U1);
					}
					return;
				case TypeCode.Int16:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I2);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I2);
					}
					return;
				case TypeCode.Char:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
					return;
				case TypeCode.Int64:
					il.Emit(OpCodes.Conv_I8);
					return;
				case TypeCode.UInt64:
					il.Emit(OpCodes.Conv_U8);
					return;
				case TypeCode.Single:
				case TypeCode.Double:
					il.Emit(OpCodes.Conv_R_Un);
					return;
				case TypeCode.Boolean:
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					return;
				case TypeCode.Decimal:
					il.Emit(OpCodes.Call, CompilerGlobals.uint32ToDecimalMethod);
					return;
				case TypeCode.DateTime:
					il.Emit(OpCodes.Conv_I8);
					il.Emit(OpCodes.Newobj, CompilerGlobals.dateTimeConstructor);
					return;
				case TypeCode.String:
					if (typeCode == TypeCode.Char)
					{
						il.Emit(OpCodes.Call, CompilerGlobals.convertCharToStringMethod);
						return;
					}
					EmitLdloca(il, Typeob.UInt32);
					il.Emit(OpCodes.Call, CompilerGlobals.uint32ToStringMethod);
					return;
				}
				break;
			case TypeCode.Int32:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.SByte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I1);
					}
					return;
				case TypeCode.Int16:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I2);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I2);
					}
					return;
				case TypeCode.Int32:
					return;
				case TypeCode.Byte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U1);
					}
					return;
				case TypeCode.Char:
				case TypeCode.UInt16:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U2);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U2);
					}
					return;
				case TypeCode.UInt32:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U4);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U4);
					}
					return;
				case TypeCode.Int64:
					il.Emit(OpCodes.Conv_I8);
					return;
				case TypeCode.UInt64:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U8);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U8);
					}
					return;
				case TypeCode.Single:
				case TypeCode.Double:
					il.Emit(OpCodes.Conv_R8);
					return;
				case TypeCode.Boolean:
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					return;
				case TypeCode.Decimal:
					il.Emit(OpCodes.Call, CompilerGlobals.int32ToDecimalMethod);
					return;
				case TypeCode.DateTime:
					il.Emit(OpCodes.Conv_I8);
					il.Emit(OpCodes.Newobj, CompilerGlobals.dateTimeConstructor);
					return;
				case TypeCode.String:
					EmitLdloca(il, Typeob.Int32);
					il.Emit(OpCodes.Call, CompilerGlobals.int32ToStringMethod);
					return;
				}
				break;
			case TypeCode.UInt32:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.SByte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I1);
					}
					return;
				case TypeCode.Byte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U1);
					}
					return;
				case TypeCode.Int16:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I2);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I2);
					}
					return;
				case TypeCode.Char:
				case TypeCode.UInt16:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U2);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U2);
					}
					return;
				case TypeCode.Int32:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I4);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I4_Un);
					}
					return;
				case TypeCode.UInt32:
					return;
				case TypeCode.Int64:
					il.Emit(OpCodes.Conv_I8);
					return;
				case TypeCode.UInt64:
					il.Emit(OpCodes.Conv_U8);
					return;
				case TypeCode.Single:
				case TypeCode.Double:
					il.Emit(OpCodes.Conv_R_Un);
					return;
				case TypeCode.Boolean:
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					return;
				case TypeCode.Decimal:
					il.Emit(OpCodes.Call, CompilerGlobals.uint32ToDecimalMethod);
					return;
				case TypeCode.DateTime:
					il.Emit(OpCodes.Conv_I8);
					il.Emit(OpCodes.Newobj, CompilerGlobals.dateTimeConstructor);
					return;
				case TypeCode.String:
					EmitLdloca(il, Typeob.UInt32);
					il.Emit(OpCodes.Call, CompilerGlobals.uint32ToStringMethod);
					return;
				}
				break;
			case TypeCode.Int64:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.SByte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I1);
					}
					return;
				case TypeCode.Int16:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I2);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I2);
					}
					return;
				case TypeCode.Int32:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I4);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I4);
					}
					return;
				case TypeCode.Byte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U1);
					}
					return;
				case TypeCode.Char:
				case TypeCode.UInt16:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U2);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U2);
					}
					return;
				case TypeCode.UInt32:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U4);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U4);
					}
					return;
				case TypeCode.Int64:
					return;
				case TypeCode.UInt64:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U8);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U8);
					}
					return;
				case TypeCode.Single:
				case TypeCode.Double:
					il.Emit(OpCodes.Conv_R8);
					return;
				case TypeCode.Boolean:
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Conv_I8);
					il.Emit(OpCodes.Ceq);
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					return;
				case TypeCode.Decimal:
					il.Emit(OpCodes.Call, CompilerGlobals.int64ToDecimalMethod);
					return;
				case TypeCode.DateTime:
					il.Emit(OpCodes.Newobj, CompilerGlobals.dateTimeConstructor);
					return;
				case TypeCode.String:
					EmitLdloca(il, Typeob.Int64);
					il.Emit(OpCodes.Call, CompilerGlobals.int64ToStringMethod);
					return;
				}
				break;
			case TypeCode.UInt64:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.SByte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I1);
					}
					return;
				case TypeCode.Byte:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U1);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U1);
					}
					return;
				case TypeCode.Int16:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I2);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I2);
					}
					return;
				case TypeCode.Char:
				case TypeCode.UInt16:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U2);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U2);
					}
					return;
				case TypeCode.Int32:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I4);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I4);
					}
					return;
				case TypeCode.UInt32:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_U4);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_U4);
					}
					return;
				case TypeCode.Int64:
					if (truncationPermitted)
					{
						il.Emit(OpCodes.Conv_I8);
					}
					else
					{
						il.Emit(OpCodes.Conv_Ovf_I8_Un);
					}
					return;
				case TypeCode.UInt64:
					return;
				case TypeCode.Single:
				case TypeCode.Double:
					il.Emit(OpCodes.Conv_R_Un);
					return;
				case TypeCode.Boolean:
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Conv_I8);
					il.Emit(OpCodes.Ceq);
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					return;
				case TypeCode.Decimal:
					il.Emit(OpCodes.Call, CompilerGlobals.uint64ToDecimalMethod);
					return;
				case TypeCode.DateTime:
					il.Emit(OpCodes.Newobj, CompilerGlobals.dateTimeConstructor);
					return;
				case TypeCode.String:
					EmitLdloca(il, Typeob.UInt64);
					il.Emit(OpCodes.Call, CompilerGlobals.uint64ToStringMethod);
					return;
				}
				break;
			case TypeCode.Single:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.SByte:
					if (truncationPermitted)
					{
						EmitSingleToIntegerTruncatedConversion(il, OpCodes.Conv_I1);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfSingleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_I1);
					return;
				case TypeCode.Int16:
					if (truncationPermitted)
					{
						EmitSingleToIntegerTruncatedConversion(il, OpCodes.Conv_I2);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfSingleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_I2);
					return;
				case TypeCode.Int32:
					if (truncationPermitted)
					{
						EmitSingleToIntegerTruncatedConversion(il, OpCodes.Conv_I4);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfSingleIsIntegerMethod);
					il.Emit(OpCodes.Conv_I4);
					return;
				case TypeCode.Byte:
					if (truncationPermitted)
					{
						EmitSingleToIntegerTruncatedConversion(il, OpCodes.Conv_U1);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfSingleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_U1);
					return;
				case TypeCode.Char:
				case TypeCode.UInt16:
					if (truncationPermitted)
					{
						EmitSingleToIntegerTruncatedConversion(il, OpCodes.Conv_U2);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfSingleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_U2);
					return;
				case TypeCode.UInt32:
					if (truncationPermitted)
					{
						EmitSingleToIntegerTruncatedConversion(il, OpCodes.Conv_Ovf_U4);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfSingleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_U4);
					return;
				case TypeCode.Int64:
					if (truncationPermitted)
					{
						EmitSingleToIntegerTruncatedConversion(il, OpCodes.Conv_I8);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfSingleIsIntegerMethod);
					il.Emit(OpCodes.Conv_I8);
					return;
				case TypeCode.UInt64:
					if (truncationPermitted)
					{
						EmitSingleToIntegerTruncatedConversion(il, OpCodes.Conv_U8);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfSingleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_U8);
					return;
				case TypeCode.Single:
				case TypeCode.Double:
					return;
				case TypeCode.DateTime:
					if (truncationPermitted)
					{
						EmitSingleToIntegerTruncatedConversion(il, OpCodes.Conv_I8);
					}
					else
					{
						il.Emit(OpCodes.Call, CompilerGlobals.checkIfSingleIsIntegerMethod);
						il.Emit(OpCodes.Conv_Ovf_I8);
					}
					il.Emit(OpCodes.Newobj, CompilerGlobals.dateTimeConstructor);
					return;
				case TypeCode.Boolean:
				case TypeCode.Decimal:
				case TypeCode.String:
					il.Emit(OpCodes.Conv_R8);
					Emit(ast, il, Typeob.Double, target_type);
					return;
				}
				break;
			case TypeCode.Double:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.SByte:
					if (truncationPermitted)
					{
						EmitDoubleToIntegerTruncatedConversion(il, OpCodes.Conv_I1);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfDoubleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_I1);
					return;
				case TypeCode.Int16:
					if (truncationPermitted)
					{
						EmitDoubleToIntegerTruncatedConversion(il, OpCodes.Conv_I2);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfDoubleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_I2);
					return;
				case TypeCode.Int32:
					if (truncationPermitted)
					{
						EmitDoubleToIntegerTruncatedConversion(il, OpCodes.Conv_I4);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfDoubleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_I4);
					return;
				case TypeCode.Byte:
					if (truncationPermitted)
					{
						EmitDoubleToIntegerTruncatedConversion(il, OpCodes.Conv_U1);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfDoubleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_U1);
					return;
				case TypeCode.Char:
				case TypeCode.UInt16:
					if (truncationPermitted)
					{
						EmitDoubleToIntegerTruncatedConversion(il, OpCodes.Conv_U2);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfDoubleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_U2);
					return;
				case TypeCode.UInt32:
					if (truncationPermitted)
					{
						EmitDoubleToIntegerTruncatedConversion(il, OpCodes.Conv_U4);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfDoubleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_U4);
					return;
				case TypeCode.Int64:
					if (truncationPermitted)
					{
						EmitDoubleToIntegerTruncatedConversion(il, OpCodes.Conv_I8);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfDoubleIsIntegerMethod);
					il.Emit(OpCodes.Conv_I8);
					return;
				case TypeCode.UInt64:
					if (truncationPermitted)
					{
						EmitDoubleToIntegerTruncatedConversion(il, OpCodes.Conv_U8);
						return;
					}
					il.Emit(OpCodes.Call, CompilerGlobals.checkIfDoubleIsIntegerMethod);
					il.Emit(OpCodes.Conv_Ovf_U8);
					return;
				case TypeCode.Single:
				case TypeCode.Double:
					return;
				case TypeCode.Boolean:
					il.Emit(OpCodes.Call, CompilerGlobals.doubleToBooleanMethod);
					return;
				case TypeCode.Decimal:
					il.Emit(OpCodes.Call, CompilerGlobals.doubleToDecimalMethod);
					return;
				case TypeCode.DateTime:
					if (truncationPermitted)
					{
						EmitDoubleToIntegerTruncatedConversion(il, OpCodes.Conv_I8);
					}
					else
					{
						il.Emit(OpCodes.Call, CompilerGlobals.checkIfSingleIsIntegerMethod);
						il.Emit(OpCodes.Conv_Ovf_I8);
					}
					il.Emit(OpCodes.Newobj, CompilerGlobals.dateTimeConstructor);
					return;
				case TypeCode.String:
					il.Emit(OpCodes.Call, CompilerGlobals.doubleToStringMethod);
					return;
				}
				break;
			case TypeCode.Decimal:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
					if (truncationPermitted)
					{
						EmitDecimalToIntegerTruncatedConversion(il, OpCodes.Conv_I4);
					}
					else
					{
						il.Emit(OpCodes.Call, CompilerGlobals.decimalToInt32Method);
					}
					Emit(ast, il, Typeob.Int32, target_type, truncationPermitted);
					return;
				case TypeCode.UInt32:
					if (truncationPermitted)
					{
						EmitDecimalToIntegerTruncatedConversion(il, OpCodes.Conv_U4);
					}
					else
					{
						il.Emit(OpCodes.Call, CompilerGlobals.decimalToUInt32Method);
					}
					return;
				case TypeCode.Boolean:
					il.Emit(OpCodes.Ldsfld, CompilerGlobals.decimalZeroField);
					il.Emit(OpCodes.Call, CompilerGlobals.decimalCompare);
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					return;
				case TypeCode.Single:
				case TypeCode.Double:
					il.Emit(OpCodes.Call, CompilerGlobals.decimalToDoubleMethod);
					Emit(ast, il, Typeob.Double, target_type, truncationPermitted);
					return;
				case TypeCode.Int64:
					if (truncationPermitted)
					{
						EmitDecimalToIntegerTruncatedConversion(il, OpCodes.Conv_I8);
					}
					else
					{
						il.Emit(OpCodes.Call, CompilerGlobals.decimalToInt64Method);
					}
					return;
				case TypeCode.UInt64:
					if (truncationPermitted)
					{
						EmitDecimalToIntegerTruncatedConversion(il, OpCodes.Conv_U8);
					}
					else
					{
						il.Emit(OpCodes.Call, CompilerGlobals.decimalToUInt64Method);
					}
					return;
				case TypeCode.Decimal:
					return;
				case TypeCode.DateTime:
					if (truncationPermitted)
					{
						EmitDecimalToIntegerTruncatedConversion(il, OpCodes.Conv_I8);
					}
					else
					{
						il.Emit(OpCodes.Call, CompilerGlobals.decimalToInt64Method);
					}
					Emit(ast, il, Typeob.Int64, target_type);
					return;
				case TypeCode.String:
					EmitLdloca(il, source_type);
					il.Emit(OpCodes.Call, CompilerGlobals.decimalToStringMethod);
					return;
				}
				break;
			case TypeCode.DateTime:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						il.Emit(OpCodes.Box, source_type);
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					EmitLdloca(il, source_type);
					il.Emit(OpCodes.Call, CompilerGlobals.dateTimeToInt64Method);
					Emit(ast, il, Typeob.Int64, target_type, truncationPermitted);
					return;
				case TypeCode.DateTime:
					return;
				case TypeCode.String:
					EmitLdloca(il, source_type);
					il.Emit(OpCodes.Call, CompilerGlobals.dateTimeToStringMethod);
					return;
				}
				break;
			case TypeCode.String:
				switch (typeCode2)
				{
				case TypeCode.Object:
					if (!(target_type != Typeob.Object) || target_type is TypeBuilder || !EmittedCallToConversionMethod(ast, il, source_type, target_type))
					{
						Emit(ast, il, Typeob.Object, target_type);
					}
					return;
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
				case TypeCode.DateTime:
					if (truncationPermitted && typeCode2 == TypeCode.Int32)
					{
						il.Emit(OpCodes.Call, CompilerGlobals.toInt32Method);
						return;
					}
					ConstantWrapper.TranslateToILInt(il, (int)typeCode2);
					ConstantWrapper.TranslateToILInt(il, truncationPermitted ? 1 : 0);
					il.Emit(OpCodes.Call, CompilerGlobals.coerce2Method);
					if (target_type.IsValueType)
					{
						EmitUnbox(il, target_type, typeCode2);
					}
					return;
				case TypeCode.String:
					return;
				}
				break;
			}
			Emit(ast, il, source_type, Typeob.Object);
			il.Emit(OpCodes.Call, CompilerGlobals.throwTypeMismatch);
			LocalBuilder local = il.DeclareLocal(target_type);
			il.Emit(OpCodes.Ldloc, local);
		}

		internal static void EmitSingleToIntegerTruncatedConversion(ILGenerator il, OpCode opConversion)
		{
			il.Emit(OpCodes.Conv_R8);
			EmitDoubleToIntegerTruncatedConversion(il, opConversion);
		}

		internal static void EmitDoubleToIntegerTruncatedConversion(ILGenerator il, OpCode opConversion)
		{
			il.Emit(OpCodes.Call, CompilerGlobals.doubleToInt64);
			if (!opConversion.Equals(OpCodes.Conv_I8))
			{
				il.Emit(opConversion);
			}
		}

		internal static void EmitDecimalToIntegerTruncatedConversion(ILGenerator il, OpCode opConversion)
		{
			il.Emit(OpCodes.Call, CompilerGlobals.uncheckedDecimalToInt64Method);
			if (!opConversion.Equals(OpCodes.Conv_I8))
			{
				il.Emit(opConversion);
			}
		}

		internal static void EmitUnbox(ILGenerator il, Type target_type, TypeCode target)
		{
			il.Emit(OpCodes.Unbox, target_type);
			switch (target)
			{
			case TypeCode.Boolean:
			case TypeCode.Byte:
				il.Emit(OpCodes.Ldind_U1);
				break;
			case TypeCode.Char:
			case TypeCode.UInt16:
				il.Emit(OpCodes.Ldind_U2);
				break;
			case TypeCode.SByte:
				il.Emit(OpCodes.Ldind_I1);
				break;
			case TypeCode.Int16:
				il.Emit(OpCodes.Ldind_I2);
				break;
			case TypeCode.Int32:
				il.Emit(OpCodes.Ldind_I4);
				break;
			case TypeCode.UInt32:
				il.Emit(OpCodes.Ldind_U4);
				break;
			case TypeCode.Int64:
			case TypeCode.UInt64:
				il.Emit(OpCodes.Ldind_I8);
				break;
			case TypeCode.Single:
				il.Emit(OpCodes.Ldind_R4);
				break;
			case TypeCode.Double:
				il.Emit(OpCodes.Ldind_R8);
				break;
			default:
				il.Emit(OpCodes.Ldobj, target_type);
				break;
			}
		}

		private static bool EmittedCallToConversionMethod(AST ast, ILGenerator il, Type source_type, Type target_type)
		{
			MethodInfo method = target_type.GetMethod("op_Explicit", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[1] { source_type }, null);
			if (method != null)
			{
				il.Emit(OpCodes.Call, method);
				Emit(ast, il, method.ReturnType, target_type);
				return true;
			}
			method = GetToXXXXMethod(source_type, target_type, explicitOK: true);
			if (method != null)
			{
				il.Emit(OpCodes.Call, method);
				return true;
			}
			method = target_type.GetMethod("op_Implicit", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[1] { source_type }, null);
			if (method != null)
			{
				il.Emit(OpCodes.Call, method);
				Emit(ast, il, method.ReturnType, target_type);
				return true;
			}
			method = GetToXXXXMethod(source_type, target_type, explicitOK: false);
			if (method != null)
			{
				il.Emit(OpCodes.Call, method);
				return true;
			}
			return false;
		}

		internal static void EmitLdarg(ILGenerator il, short argNum)
		{
			switch (argNum)
			{
			case 0:
				il.Emit(OpCodes.Ldarg_0);
				return;
			case 1:
				il.Emit(OpCodes.Ldarg_1);
				return;
			case 2:
				il.Emit(OpCodes.Ldarg_2);
				return;
			case 3:
				il.Emit(OpCodes.Ldarg_3);
				return;
			}
			if (argNum < 256)
			{
				il.Emit(OpCodes.Ldarg_S, (byte)argNum);
			}
			else
			{
				il.Emit(OpCodes.Ldarg, argNum);
			}
		}

		internal static void EmitLdloca(ILGenerator il, Type source_type)
		{
			LocalBuilder local = il.DeclareLocal(source_type);
			il.Emit(OpCodes.Stloc, local);
			il.Emit(OpCodes.Ldloca, local);
		}

		private static IReflect GetArrayElementType(IReflect ir)
		{
			if (ir is TypedArray)
			{
				return ((TypedArray)ir).elementType;
			}
			if (ir is Type && ((Type)ir).IsArray)
			{
				return ((Type)ir).GetElementType();
			}
			if (ir is ArrayObject || ir == Typeob.ArrayObject)
			{
				return Typeob.Object;
			}
			return null;
		}

		internal static int GetArrayRank(IReflect ir)
		{
			if (ir == Typeob.ArrayObject || ir is ArrayObject)
			{
				return 1;
			}
			if (ir is TypedArray)
			{
				return ((TypedArray)ir).rank;
			}
			if (ir is Type && ((Type)ir).IsArray)
			{
				return ((Type)ir).GetArrayRank();
			}
			return -1;
		}

		internal static IConvertible GetIConvertible(object ob)
		{
			return ob as IConvertible;
		}

		private static MethodInfo GetToXXXXMethod(IReflect ir, Type desiredType, bool explicitOK)
		{
			if (ir is TypeBuilder || ir is EnumBuilder)
			{
				return null;
			}
			MemberInfo[] member = ir.GetMember(explicitOK ? "op_Explicit" : "op_Implicit", BindingFlags.Static | BindingFlags.Public);
			if (member != null)
			{
				MemberInfo[] array = member;
				foreach (MemberInfo memberInfo in array)
				{
					if (memberInfo is MethodInfo && ((MethodInfo)memberInfo).ReturnType == desiredType)
					{
						return (MethodInfo)memberInfo;
					}
				}
			}
			return null;
		}

		internal static TypeCode GetTypeCode(object ob, IConvertible ic)
		{
			if (ob == null)
			{
				return TypeCode.Empty;
			}
			return ic?.GetTypeCode() ?? TypeCode.Object;
		}

		internal static TypeCode GetTypeCode(object ob)
		{
			return GetTypeCode(ob, GetIConvertible(ob));
		}

		internal static Type GetUnderlyingType(Type type)
		{
			if (type is TypeBuilder)
			{
				return type.UnderlyingSystemType;
			}
			return Enum.GetUnderlyingType(type);
		}

		internal static bool IsArray(IReflect ir)
		{
			if (ir != Typeob.Array && ir != Typeob.ArrayObject && !(ir is TypedArray) && !(ir is ArrayObject))
			{
				if (ir is Type)
				{
					return ((Type)ir).IsArray;
				}
				return false;
			}
			return true;
		}

		private static bool IsArrayElementTypeKnown(IReflect ir)
		{
			if (ir != Typeob.ArrayObject && !(ir is TypedArray) && !(ir is ArrayObject))
			{
				if (ir is Type)
				{
					return ((Type)ir).IsArray;
				}
				return false;
			}
			return true;
		}

		internal static bool IsArrayRankKnown(IReflect ir)
		{
			if (ir != Typeob.ArrayObject && !(ir is TypedArray) && !(ir is ArrayObject))
			{
				if (ir is Type)
				{
					return ((Type)ir).IsArray;
				}
				return false;
			}
			return true;
		}

		internal static bool IsArrayType(IReflect ir)
		{
			if (!(ir is TypedArray) && ir != Typeob.Array && ir != Typeob.ArrayObject)
			{
				if (ir is Type)
				{
					return ((Type)ir).IsArray;
				}
				return false;
			}
			return true;
		}

		internal static bool IsJScriptArray(IReflect ir)
		{
			if (!(ir is ArrayObject))
			{
				return ir == Typeob.ArrayObject;
			}
			return true;
		}

		internal static bool IsPrimitiveSignedNumericType(Type t)
		{
			switch (Type.GetTypeCode(t))
			{
			case TypeCode.SByte:
			case TypeCode.Int16:
			case TypeCode.Int32:
			case TypeCode.Int64:
			case TypeCode.Single:
			case TypeCode.Double:
				return true;
			default:
				return false;
			}
		}

		internal static bool IsPrimitiveSignedIntegerType(Type t)
		{
			switch (Type.GetTypeCode(t))
			{
			case TypeCode.SByte:
			case TypeCode.Int16:
			case TypeCode.Int32:
			case TypeCode.Int64:
				return true;
			default:
				return false;
			}
		}

		internal static bool IsPrimitiveUnsignedIntegerType(Type t)
		{
			switch (Type.GetTypeCode(t))
			{
			case TypeCode.Byte:
			case TypeCode.UInt16:
			case TypeCode.UInt32:
			case TypeCode.UInt64:
				return true;
			default:
				return false;
			}
		}

		internal static bool IsPrimitiveIntegerType(Type t)
		{
			TypeCode typeCode = Type.GetTypeCode(t);
			if ((uint)(typeCode - 5) <= 7u)
			{
				return true;
			}
			return false;
		}

		internal static bool IsPrimitiveNumericTypeCode(TypeCode tc)
		{
			if ((uint)(tc - 5) <= 9u)
			{
				return true;
			}
			return false;
		}

		internal static bool IsPrimitiveNumericType(IReflect ir)
		{
			Type type = ir as Type;
			if (type == null)
			{
				return false;
			}
			return IsPrimitiveNumericTypeCode(Type.GetTypeCode(type));
		}

		internal static bool IsPrimitiveNumericTypeFitForDouble(IReflect ir)
		{
			Type type = ir as Type;
			if (type == null)
			{
				return false;
			}
			TypeCode typeCode = Type.GetTypeCode(type);
			if ((uint)(typeCode - 5) <= 5u || (uint)(typeCode - 13) <= 1u)
			{
				return true;
			}
			return false;
		}

		private static bool IsPromotableTo(Type source_type, Type target_type)
		{
			TypeCode typeCode = Type.GetTypeCode(source_type);
			TypeCode typeCode2 = Type.GetTypeCode(target_type);
			if (promotable[(int)typeCode, (int)typeCode2])
			{
				return true;
			}
			if ((typeCode == TypeCode.Object || typeCode == TypeCode.String) && typeCode2 == TypeCode.Object)
			{
				if (target_type.IsAssignableFrom(source_type))
				{
					return true;
				}
				if (target_type == Typeob.BooleanObject && source_type == Typeob.Boolean)
				{
					return true;
				}
				if (target_type == Typeob.StringObject && source_type == Typeob.String)
				{
					return true;
				}
				if (target_type == Typeob.NumberObject && IsPromotableTo(source_type, Typeob.Double))
				{
					return true;
				}
				if (target_type == Typeob.Array || source_type == Typeob.Array || target_type.IsArray || source_type.IsArray)
				{
					return IsPromotableToArray(source_type, target_type);
				}
			}
			if (source_type == Typeob.BooleanObject && target_type == Typeob.Boolean)
			{
				return true;
			}
			if (source_type == Typeob.StringObject && target_type == Typeob.String)
			{
				return true;
			}
			if (source_type == Typeob.DateObject && target_type == Typeob.DateTime)
			{
				return true;
			}
			if (source_type == Typeob.NumberObject)
			{
				return IsPrimitiveNumericType(target_type);
			}
			if (source_type.IsEnum)
			{
				if (!target_type.IsEnum)
				{
					return IsPromotableTo(GetUnderlyingType(source_type), target_type);
				}
				return false;
			}
			if (target_type.IsEnum)
			{
				if (!source_type.IsEnum)
				{
					return IsPromotableTo(source_type, GetUnderlyingType(target_type));
				}
				return false;
			}
			MethodInfo method = target_type.GetMethod("op_Implicit", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[1] { source_type }, null);
			if (method != null && (method.Attributes & MethodAttributes.SpecialName) != 0)
			{
				return true;
			}
			method = GetToXXXXMethod(source_type, target_type, explicitOK: false);
			if (method != null && (method.Attributes & MethodAttributes.SpecialName) != 0)
			{
				return true;
			}
			return false;
		}

		internal static bool IsPromotableTo(IReflect source_ir, IReflect target_ir)
		{
			if (source_ir is TypedArray || target_ir is TypedArray || source_ir is ArrayObject || target_ir is ArrayObject || source_ir == Typeob.ArrayObject || target_ir == Typeob.ArrayObject)
			{
				return IsPromotableToArray(source_ir, target_ir);
			}
			if (target_ir is ClassScope)
			{
				if (((ClassScope)target_ir).owner is EnumDeclaration)
				{
					if (IsPrimitiveNumericType(source_ir))
					{
						return IsPromotableTo(source_ir, ((EnumDeclaration)((ClassScope)target_ir).owner).baseType.ToType());
					}
					if (source_ir == Typeob.String)
					{
						return true;
					}
					if (source_ir == target_ir)
					{
						return true;
					}
					return false;
				}
				if (source_ir is ClassScope)
				{
					return ((ClassScope)source_ir).IsSameOrDerivedFrom((ClassScope)target_ir);
				}
				return false;
			}
			Type type;
			if (!(target_ir is Type))
			{
				type = ((!(target_ir is ScriptFunction)) ? Globals.TypeRefs.ToReferenceContext(target_ir.GetType()) : Typeob.ScriptFunction);
			}
			else
			{
				if (target_ir == Typeob.Object)
				{
					if (source_ir is Type)
					{
						return !((Type)source_ir).IsByRef;
					}
					return true;
				}
				type = (Type)target_ir;
			}
			if (source_ir is ClassScope)
			{
				return ((ClassScope)source_ir).IsPromotableTo(type);
			}
			return IsPromotableTo((source_ir is Type) ? ((Type)source_ir) : Globals.TypeRefs.ToReferenceContext(source_ir.GetType()), type);
		}

		private static bool IsPromotableToArray(IReflect source_ir, IReflect target_ir)
		{
			if (!IsArray(source_ir))
			{
				return false;
			}
			if (target_ir == Typeob.Object)
			{
				return true;
			}
			if (!IsArray(target_ir))
			{
				if (target_ir is Type)
				{
					Type type = (Type)target_ir;
					if (type.IsInterface && type.IsAssignableFrom(Typeob.Array))
					{
						if (!(source_ir is TypedArray))
						{
							if (source_ir is Type)
							{
								return ((Type)source_ir).IsArray;
							}
							return false;
						}
						return true;
					}
				}
				return false;
			}
			if (IsJScriptArray(source_ir) && !IsJScriptArray(target_ir))
			{
				return false;
			}
			if (target_ir == Typeob.Array)
			{
				return !IsJScriptArray(source_ir);
			}
			if (source_ir == Typeob.Array)
			{
				return false;
			}
			if (GetArrayRank(source_ir) == 1 && IsJScriptArray(target_ir))
			{
				return true;
			}
			if (GetArrayRank(source_ir) != GetArrayRank(target_ir))
			{
				return false;
			}
			IReflect arrayElementType = GetArrayElementType(source_ir);
			IReflect arrayElementType2 = GetArrayElementType(target_ir);
			if (arrayElementType == null || arrayElementType2 == null)
			{
				return false;
			}
			if ((arrayElementType is Type && ((Type)arrayElementType).IsValueType) || (arrayElementType2 is Type && ((Type)arrayElementType2).IsValueType))
			{
				return arrayElementType == arrayElementType2;
			}
			return IsPromotableTo(arrayElementType, arrayElementType2);
		}

		private static bool IsWhiteSpace(char c)
		{
			switch (c)
			{
			default:
				if (c != ' ' && c != '\u00a0')
				{
					if (c >= '\u0080')
					{
						return char.IsWhiteSpace(c);
					}
					return false;
				}
				goto case '\t';
			case '\t':
			case '\n':
			case '\v':
			case '\f':
			case '\r':
				return true;
			}
		}

		private static bool IsWhiteSpaceTrailer(char[] s, int i, int max)
		{
			while (i < max)
			{
				if (!IsWhiteSpace(s[i]))
				{
					return false;
				}
				i++;
			}
			return true;
		}

		internal static object LiteralToNumber(string str)
		{
			return LiteralToNumber(str, null);
		}

		internal static object LiteralToNumber(string str, Context context)
		{
			uint num = 10u;
			if (str[0] == '0' && str.Length > 1)
			{
				num = ((str[1] != 'x' && str[1] != 'X') ? 8u : 16u);
			}
			object obj = parseRadix(str.ToCharArray(), num, (num == 16) ? 2 : 0, 1, ignoreTrailers: false);
			if (obj != null)
			{
				if (num == 8 && context != null && obj is int && (int)obj > 7)
				{
					context.HandleError(JSError.OctalLiteralsAreDeprecated);
				}
				return obj;
			}
			context.HandleError(JSError.BadOctalLiteral);
			return parseRadix(str.ToCharArray(), 10u, 0, 1, ignoreTrailers: false);
		}

		internal static bool NeedsWrapper(TypeCode code)
		{
			if ((uint)(code - 3) <= 12u || code == TypeCode.String)
			{
				return true;
			}
			return false;
		}

		private static double DoubleParse(string str)
		{
			try
			{
				return double.Parse(str, NumberStyles.Float, CultureInfo.InvariantCulture);
			}
			catch (OverflowException)
			{
				int i = 0;
				int length;
				for (length = str.Length; i < length && IsWhiteSpace(str[i]); i++)
				{
				}
				if (i < length && str[i] == '-')
				{
					return double.NegativeInfinity;
				}
				return double.PositiveInfinity;
			}
		}

		private static object parseRadix(char[] s, uint rdx, int i, int sign, bool ignoreTrailers)
		{
			int num = s.Length;
			if (i >= num)
			{
				return null;
			}
			ulong num2 = ulong.MaxValue / (ulong)rdx;
			int num3 = RadixDigit(s[i], rdx);
			if (num3 < 0)
			{
				return null;
			}
			ulong num4 = (ulong)num3;
			int num5 = i;
			while (true)
			{
				if (++i != num)
				{
					num3 = RadixDigit(s[i], rdx);
					if (num3 >= 0)
					{
						if (num4 > num2)
						{
							break;
						}
						ulong num6 = num4 * rdx;
						ulong num7 = num6 + (ulong)num3;
						if (num6 > num7)
						{
							break;
						}
						num4 = num7;
						continue;
					}
					if (!ignoreTrailers && !IsWhiteSpaceTrailer(s, i, num))
					{
						return null;
					}
				}
				if (sign < 0)
				{
					if (num4 <= 2147483648u)
					{
						return (int)(0L - num4);
					}
					if (num4 < 9223372036854775808uL)
					{
						return (long)(0L - num4);
					}
					if (num4 == 9223372036854775808uL)
					{
						return long.MinValue;
					}
					return 0.0 - (double)num4;
				}
				if (num4 <= int.MaxValue)
				{
					return (int)num4;
				}
				if (num4 <= long.MaxValue)
				{
					return (long)num4;
				}
				return num4;
			}
			if (rdx == 10)
			{
				try
				{
					double num8 = DoubleParse(new string(s, num5, num - num5));
					if (num8 == num8)
					{
						return (double)sign * num8;
					}
					if (!ignoreTrailers)
					{
						return null;
					}
				}
				catch
				{
				}
			}
			double num9 = (double)num4 * (double)rdx + (double)num3;
			while (true)
			{
				if (++i == num)
				{
					return (double)sign * num9;
				}
				num3 = RadixDigit(s[i], rdx);
				if (num3 < 0)
				{
					break;
				}
				num9 = num9 * (double)rdx + (double)num3;
			}
			if (ignoreTrailers || IsWhiteSpaceTrailer(s, i, num))
			{
				return (double)sign * num9;
			}
			return null;
		}

		private static int RadixDigit(char c, uint r)
		{
			int num;
			if (c >= '0' && c <= '9')
			{
				num = c - 48;
			}
			else if (c >= 'A' && c <= 'Z')
			{
				num = 10 + c - 65;
			}
			else
			{
				if (c < 'a' || c > 'z')
				{
					return -1;
				}
				num = 10 + c - 97;
			}
			if (num >= r)
			{
				return -1;
			}
			return num;
		}

		/// <summary>Throws a <see cref="T:Microsoft.JScript.JScriptException" /> exception in all cases.</summary>
		/// <param name="val">The source code that caused the exception.</param>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public static void ThrowTypeMismatch(object val)
		{
			throw new JScriptException(JSError.TypeMismatch, new Context(new DocumentContext("", null), val.ToString()));
		}

		/// <summary>Converts the specified <see cref="T:System.Double" /> to a <see cref="T:System.Boolean" />.</summary>
		/// <param name="d">The value to convert.</param>
		/// <returns>
		///   <see langword="false" /> if <paramref name="d" /> is 0; otherwise, <see langword="true" />.</returns>
		public static bool ToBoolean(double d)
		{
			if (d == d)
			{
				return d != 0.0;
			}
			return false;
		}

		/// <summary>Converts the specified <see cref="T:System.Object" /> to a <see cref="T:System.Boolean" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>
		///   <paramref name="value" /> converted to a <see cref="T:System.Boolean" />.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public static bool ToBoolean(object value)
		{
			if (value is bool)
			{
				return (bool)value;
			}
			return ToBoolean(value, GetIConvertible(value));
		}

		/// <summary>Converts the specified <see cref="T:System.Object" /> value to a <see cref="T:System.Boolean" /> structure, optionally allowing data loss.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="explicitConversion">
		///   <see langword="true" /> to allow data loss; otherwise, <see langword="false" />.</param>
		/// <returns>
		///   <paramref name="value" /> converted to a <see cref="T:System.Boolean" />.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public static bool ToBoolean(object value, bool explicitConversion)
		{
			if (value is bool)
			{
				return (bool)value;
			}
			if (!explicitConversion && value is BooleanObject)
			{
				return ((BooleanObject)value).value;
			}
			return ToBoolean(value, GetIConvertible(value));
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static bool ToBoolean(object value, IConvertible ic)
		{
			switch (GetTypeCode(value, ic))
			{
			case TypeCode.Empty:
				return false;
			case TypeCode.Object:
			{
				if (value is Missing || value is System.Reflection.Missing)
				{
					return false;
				}
				Type type = value.GetType();
				MethodInfo method = type.GetMethod("op_True", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[1] { type }, null);
				if (method != null && (method.Attributes & MethodAttributes.SpecialName) != 0 && method.ReturnType == typeof(bool))
				{
					method = new JSMethodInfo(method);
					return (bool)method.Invoke(null, BindingFlags.SuppressChangeType, null, new object[1] { value }, null);
				}
				return true;
			}
			case TypeCode.DBNull:
				return false;
			case TypeCode.Boolean:
				return ic.ToBoolean(null);
			case TypeCode.Char:
				return ic.ToChar(null) != '\0';
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
				return ic.ToInt32(null) != 0;
			case TypeCode.UInt32:
			case TypeCode.Int64:
				return ic.ToInt64(null) != 0;
			case TypeCode.UInt64:
				return ic.ToUInt64(null) != 0;
			case TypeCode.Single:
			case TypeCode.Double:
			{
				double num = ic.ToDouble(null);
				if (num != num)
				{
					return false;
				}
				return num != 0.0;
			}
			case TypeCode.Decimal:
				return ic.ToDecimal(null) != 0m;
			case TypeCode.DateTime:
				return true;
			case TypeCode.String:
				return ic.ToString(null).Length != 0;
			default:
				return false;
			}
		}

		internal static char ToChar(object value)
		{
			return (char)ToUint32(value);
		}

		private static char ToDigit(int digit)
		{
			if (digit >= 10)
			{
				return (char)(97 + digit - 10);
			}
			return (char)(48 + digit);
		}

		/// <summary>Converts the specified value to an <see cref="T:System.Object" /> that represents a collection of <see cref="T:Microsoft.JScript.AST" /> objects.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>
		///   <paramref name="value" /> converted to an <see cref="T:System.Object" />.</returns>
		public static object ToForInObject(object value, VsaEngine engine)
		{
			if (value is ScriptObject)
			{
				return value;
			}
			IConvertible iConvertible = GetIConvertible(value);
			switch (GetTypeCode(value, iConvertible))
			{
			case TypeCode.Boolean:
				return engine.Globals.globalObject.originalBoolean.ConstructImplicitWrapper(iConvertible.ToBoolean(null));
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.Decimal:
				return engine.Globals.globalObject.originalNumber.ConstructImplicitWrapper(value);
			case TypeCode.String:
				return engine.Globals.globalObject.originalString.ConstructImplicitWrapper(iConvertible.ToString(null));
			case TypeCode.DateTime:
				return value;
			case TypeCode.Object:
				return value;
			default:
				return engine.Globals.globalObject.originalObject.ConstructObject();
			}
		}

		internal static double ToInteger(double number)
		{
			if (number != number)
			{
				return 0.0;
			}
			return (double)Math.Sign(number) * Math.Floor(Math.Abs(number));
		}

		internal static double ToInteger(object value)
		{
			if (value is double)
			{
				return ToInteger((double)value);
			}
			if (value is int)
			{
				return (int)value;
			}
			return ToInteger(value, GetIConvertible(value));
		}

		internal static double ToInteger(object value, IConvertible ic)
		{
			switch (GetTypeCode(value, ic))
			{
			case TypeCode.Empty:
				return 0.0;
			case TypeCode.DBNull:
				return 0.0;
			case TypeCode.Boolean:
				return ic.ToBoolean(null) ? 1 : 0;
			case TypeCode.Char:
				return (int)ic.ToChar(null);
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
				return ic.ToDouble(null);
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.Decimal:
				return ToInteger(ic.ToDouble(null));
			case TypeCode.Object:
			case TypeCode.DateTime:
			{
				object obj = ToPrimitive(value, PreferredType.Number, ref ic);
				if (obj != value)
				{
					return ToInteger(ToNumber(obj, ic));
				}
				return double.NaN;
			}
			case TypeCode.String:
				return ToInteger(ToNumber(ic.ToString(null)));
			default:
				return 0.0;
			}
		}

		/// <summary>Converts the specified value to an <see cref="T:System.Int32" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>
		///   <paramref name="value" /> converted to an <see cref="T:System.Int32" />.</returns>
		public static int ToInt32(object value)
		{
			if (value is double)
			{
				return (int)Runtime.DoubleToInt64((double)value);
			}
			if (value is int)
			{
				return (int)value;
			}
			return ToInt32(value, GetIConvertible(value));
		}

		internal static int ToInt32(object value, IConvertible ic)
		{
			switch (GetTypeCode(value, ic))
			{
			case TypeCode.Empty:
				return 0;
			case TypeCode.DBNull:
				return 0;
			case TypeCode.Boolean:
				if (!ic.ToBoolean(null))
				{
					return 0;
				}
				return 1;
			case TypeCode.Char:
				return ic.ToChar(null);
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
				return ic.ToInt32(null);
			case TypeCode.UInt32:
			case TypeCode.Int64:
				return (int)ic.ToInt64(null);
			case TypeCode.UInt64:
				return (int)ic.ToUInt64(null);
			case TypeCode.Single:
			case TypeCode.Double:
				return (int)Runtime.DoubleToInt64(ic.ToDouble(null));
			case TypeCode.Decimal:
				return (int)Runtime.UncheckedDecimalToInt64(ic.ToDecimal(null));
			case TypeCode.Object:
			case TypeCode.DateTime:
			{
				object obj = ToPrimitive(value, PreferredType.Number, ref ic);
				if (obj != value)
				{
					return ToInt32(obj, ic);
				}
				return 0;
			}
			case TypeCode.String:
				return (int)Runtime.DoubleToInt64(ToNumber(ic.ToString(null)));
			default:
				return 0;
			}
		}

		internal static IReflect ToIReflect(Type t, VsaEngine engine)
		{
			GlobalObject globalObject = engine.Globals.globalObject;
			object obj = t;
			if (t == Typeob.ArrayObject)
			{
				obj = globalObject.originalArray.Construct();
			}
			else if (t == Typeob.BooleanObject)
			{
				obj = globalObject.originalBoolean.Construct();
			}
			else if (t == Typeob.DateObject)
			{
				obj = globalObject.originalDate.Construct(new object[0]);
			}
			else if (t == Typeob.EnumeratorObject)
			{
				obj = globalObject.originalEnumerator.Construct(new object[0]);
			}
			else if (t == Typeob.ErrorObject)
			{
				obj = globalObject.originalError.Construct(new object[0]);
			}
			else if (t == Typeob.EvalErrorObject)
			{
				obj = globalObject.originalEvalError.Construct(new object[0]);
			}
			else if (t == Typeob.JSObject)
			{
				obj = globalObject.originalObject.Construct(new object[0]);
			}
			else if (t == Typeob.NumberObject)
			{
				obj = globalObject.originalNumber.Construct();
			}
			else if (t == Typeob.RangeErrorObject)
			{
				obj = globalObject.originalRangeError.Construct(new object[0]);
			}
			else if (t == Typeob.ReferenceErrorObject)
			{
				obj = globalObject.originalReferenceError.Construct(new object[0]);
			}
			else if (t == Typeob.RegExpObject)
			{
				obj = globalObject.originalRegExp.Construct(new object[0]);
			}
			else if (t == Typeob.ScriptFunction)
			{
				obj = FunctionPrototype.ob;
			}
			else if (t == Typeob.StringObject)
			{
				obj = globalObject.originalString.Construct();
			}
			else if (t == Typeob.SyntaxErrorObject)
			{
				obj = globalObject.originalSyntaxError.Construct(new object[0]);
			}
			else if (t == Typeob.TypeErrorObject)
			{
				obj = globalObject.originalTypeError.Construct(new object[0]);
			}
			else if (t == Typeob.URIErrorObject)
			{
				obj = globalObject.originalURIError.Construct(new object[0]);
			}
			else if (t == Typeob.VBArrayObject)
			{
				obj = globalObject.originalVBArray.Construct();
			}
			else if (t == Typeob.ArgumentsObject)
			{
				obj = globalObject.originalObject.Construct(new object[0]);
			}
			return (IReflect)obj;
		}

		/// <summary>Converts the specified <see cref="T:System.Object" /> to a <see cref="T:System.Double" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>
		///   <paramref name="value" /> converted to a <see cref="T:System.Double" />.</returns>
		public static double ToNumber(object value)
		{
			if (value is int)
			{
				return (int)value;
			}
			if (value is double)
			{
				return (double)value;
			}
			return ToNumber(value, GetIConvertible(value));
		}

		internal static double ToNumber(object value, IConvertible ic)
		{
			switch (GetTypeCode(value, ic))
			{
			case TypeCode.Empty:
				return double.NaN;
			case TypeCode.DBNull:
				return 0.0;
			case TypeCode.Boolean:
				return ic.ToBoolean(null) ? 1 : 0;
			case TypeCode.Char:
				return (int)ic.ToChar(null);
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
				return ic.ToInt32(null);
			case TypeCode.UInt32:
			case TypeCode.Int64:
				return ic.ToInt64(null);
			case TypeCode.UInt64:
				return ic.ToUInt64(null);
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.Decimal:
				return ic.ToDouble(null);
			case TypeCode.Object:
			case TypeCode.DateTime:
			{
				object obj = ToPrimitive(value, PreferredType.Number, ref ic);
				if (obj != value)
				{
					return ToNumber(obj, ic);
				}
				return double.NaN;
			}
			case TypeCode.String:
				return ToNumber(ic.ToString(null));
			default:
				return 0.0;
			}
		}

		/// <summary>Converts the specified <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</summary>
		/// <param name="str">The value to convert.</param>
		/// <returns>
		///   <paramref name="str" /> converted to a <see cref="T:System.Double" />.</returns>
		public static double ToNumber(string str)
		{
			return ToNumber(str, hexOK: true, octalOK: false, Missing.Value);
		}

		internal static double ToNumber(string str, bool hexOK, bool octalOK, object radix)
		{
			if (!octalOK)
			{
				try
				{
					double num = DoubleParse(str);
					if (num != 0.0)
					{
						return num;
					}
					int i = 0;
					int length;
					for (length = str.Length; i < length && IsWhiteSpace(str[i]); i++)
					{
					}
					if (i < length && str[i] == '-')
					{
						return -0.0;
					}
					return 0.0;
				}
				catch
				{
					int length2 = str.Length;
					int num2 = length2 - 1;
					int j;
					for (j = 0; j < length2 && IsWhiteSpace(str[j]); j++)
					{
					}
					if (!hexOK)
					{
						if (length2 - j >= 8 && string.CompareOrdinal(str, j, "Infinity", 0, 8) == 0)
						{
							return double.PositiveInfinity;
						}
						if (length2 - j >= 9 && string.CompareOrdinal(str, j, "-Infinity", 0, 8) == 0)
						{
							return double.NegativeInfinity;
						}
						if (length2 - j >= 9 && string.CompareOrdinal(str, j, "+Infinity", 0, 8) == 0)
						{
							return double.PositiveInfinity;
						}
						while (num2 >= j)
						{
							char c = str[num2];
							if (!JSScanner.IsDigit(c))
							{
								break;
							}
							num2--;
						}
						while (num2 >= j)
						{
							char c = str[num2];
							if (JSScanner.IsDigit(c))
							{
								break;
							}
							num2--;
						}
						if (num2 < length2 - 1)
						{
							return ToNumber(str.Substring(j, num2 - j + 1), hexOK, octalOK, radix);
						}
						return double.NaN;
					}
					while (num2 >= j && IsWhiteSpace(str[num2]))
					{
						num2--;
					}
					if (j > num2)
					{
						return 0.0;
					}
					if (num2 < length2 - 1)
					{
						return ToNumber(str.Substring(j, num2 - j + 1), hexOK, octalOK, radix);
					}
				}
			}
			int length3 = str.Length;
			int k;
			for (k = 0; k < length3 && IsWhiteSpace(str[k]); k++)
			{
			}
			if (k >= length3)
			{
				if (hexOK && octalOK)
				{
					return double.NaN;
				}
				return 0.0;
			}
			int num3 = 1;
			bool flag = false;
			if (str[k] == '-')
			{
				num3 = -1;
				k++;
				flag = true;
			}
			else if (str[k] == '+')
			{
				k++;
				flag = true;
			}
			for (; k < length3 && IsWhiteSpace(str[k]); k++)
			{
			}
			bool flag2 = radix == null || radix is Missing;
			if (k + 8 <= length3 && flag2 && !octalOK && str.Substring(k, 8).Equals("Infinity"))
			{
				if (num3 <= 0)
				{
					return double.NegativeInfinity;
				}
				return double.PositiveInfinity;
			}
			int num4 = 10;
			if (!flag2)
			{
				num4 = ToInt32(radix);
			}
			switch (num4)
			{
			case 0:
				flag2 = true;
				num4 = 10;
				break;
			default:
				return double.NaN;
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
			case 14:
			case 15:
			case 16:
			case 17:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27:
			case 28:
			case 29:
			case 30:
			case 31:
			case 32:
			case 33:
			case 34:
			case 35:
			case 36:
				break;
			}
			if (k < length3 - 2 && str[k] == '0')
			{
				if (str[k + 1] == 'x' || str[k + 1] == 'X')
				{
					if (!hexOK)
					{
						return 0.0;
					}
					if (flag && !octalOK)
					{
						return double.NaN;
					}
					if (flag2)
					{
						num4 = 16;
						k += 2;
					}
					else if (num4 == 16)
					{
						k += 2;
					}
				}
				else if (octalOK && flag2)
				{
					num4 = 8;
				}
			}
			if (k < length3)
			{
				return ToNumber(parseRadix(str.ToCharArray(), (uint)num4, k, num3, hexOK && octalOK));
			}
			return double.NaN;
		}

		internal static string ToLocaleString(object value)
		{
			return ToString(value, PreferredType.LocaleString, explicitOK: true);
		}

		/// <summary>Converts the specified <see cref="T:Microsoft.JScript.ArrayObject" /> to a typed <see cref="T:System.Array" />.</summary>
		/// <param name="value">The <see cref="T:Microsoft.JScript.ArrayObject" /> to convert.</param>
		/// <param name="handle">The type of the elements in the array.</param>
		/// <returns>
		///   <paramref name="value" /> converted to an <see cref="T:System.Array" /> if this is possible; otherwise, <paramref name="value" />.</returns>
		public static object ToNativeArray(object value, RuntimeTypeHandle handle)
		{
			if (value is ArrayObject)
			{
				Type typeFromHandle = Type.GetTypeFromHandle(handle);
				return ((ArrayObject)value).ToNativeArray(typeFromHandle);
			}
			return value;
		}

		/// <summary>Converts the specified value to an <see cref="T:System.Object" />. Throws an error if it cannot perform the conversion.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>
		///   <paramref name="value" /> converted to an <see cref="T:System.Object" />.</returns>
		public static object ToObject(object value, VsaEngine engine)
		{
			if (value is ScriptObject)
			{
				return value;
			}
			if (value is string arg)
			{
				return engine.Globals.globalObject.originalString.ConstructImplicitWrapper(arg);
			}
			IConvertible iConvertible = GetIConvertible(value);
			switch (GetTypeCode(value, iConvertible))
			{
			case TypeCode.Boolean:
				return engine.Globals.globalObject.originalBoolean.ConstructImplicitWrapper(iConvertible.ToBoolean(null));
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.Decimal:
				return engine.Globals.globalObject.originalNumber.ConstructImplicitWrapper(value);
			case TypeCode.String:
				return engine.Globals.globalObject.originalString.ConstructImplicitWrapper(iConvertible.ToString(null));
			case TypeCode.DateTime:
				return iConvertible.ToDateTime(null);
			case TypeCode.Object:
				if (value is Array)
				{
					return engine.Globals.globalObject.originalArray.ConstructImplicitWrapper((Array)value);
				}
				return value;
			default:
				throw new JScriptException(JSError.NeedObject);
			}
		}

		/// <summary>Converts the specified value to an <see cref="T:System.Object" />. Returns null if it cannot perform the conversion.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>
		///   <paramref name="value" /> converted to an <see cref="T:System.Object" />.</returns>
		public static object ToObject2(object value, VsaEngine engine)
		{
			if (value is ScriptObject)
			{
				return value;
			}
			IConvertible iConvertible = GetIConvertible(value);
			switch (GetTypeCode(value, iConvertible))
			{
			case TypeCode.Boolean:
				return engine.Globals.globalObject.originalBoolean.ConstructImplicitWrapper(iConvertible.ToBoolean(null));
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.Decimal:
				return engine.Globals.globalObject.originalNumber.ConstructImplicitWrapper(value);
			case TypeCode.String:
				return engine.Globals.globalObject.originalString.ConstructImplicitWrapper(iConvertible.ToString(null));
			case TypeCode.DateTime:
				return iConvertible.ToDateTime(null);
			case TypeCode.Object:
				if (value is Array)
				{
					return engine.Globals.globalObject.originalArray.ConstructImplicitWrapper((Array)value);
				}
				return value;
			default:
				return null;
			}
		}

		internal static object ToObject3(object value, VsaEngine engine)
		{
			if (value is ScriptObject)
			{
				return value;
			}
			IConvertible iConvertible = GetIConvertible(value);
			switch (GetTypeCode(value, iConvertible))
			{
			case TypeCode.Boolean:
				return engine.Globals.globalObject.originalBoolean.ConstructWrapper(iConvertible.ToBoolean(null));
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.Decimal:
				return engine.Globals.globalObject.originalNumber.ConstructWrapper(value);
			case TypeCode.String:
				return engine.Globals.globalObject.originalString.ConstructWrapper(iConvertible.ToString(null));
			case TypeCode.DateTime:
				return iConvertible.ToDateTime(null);
			case TypeCode.Object:
				if (value is Array)
				{
					return engine.Globals.globalObject.originalArray.ConstructWrapper((Array)value);
				}
				return value;
			default:
				return null;
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static object ToPrimitive(object value, PreferredType preferredType)
		{
			IConvertible iConvertible = GetIConvertible(value);
			TypeCode typeCode = GetTypeCode(value, iConvertible);
			return ToPrimitive(value, preferredType, iConvertible, typeCode);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static object ToPrimitive(object value, PreferredType preferredType, ref IConvertible ic)
		{
			TypeCode typeCode = GetTypeCode(value, ic);
			if (typeCode == TypeCode.Object || typeCode == TypeCode.DateTime)
			{
				object obj = ToPrimitive(value, preferredType, ic, typeCode);
				if (obj != value)
				{
					value = obj;
					ic = GetIConvertible(value);
				}
			}
			return value;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		private static object ToPrimitive(object value, PreferredType preferredType, IConvertible ic, TypeCode tcode)
		{
			switch (tcode)
			{
			case TypeCode.Object:
			{
				if (value is Array array && array.Rank == 1)
				{
					value = new ArrayWrapper(ArrayPrototype.ob, array, implicitWrapper: true);
				}
				if (value is ScriptObject)
				{
					object defaultValue = ((ScriptObject)value).GetDefaultValue(preferredType);
					if (GetTypeCode(defaultValue) != TypeCode.Object)
					{
						return defaultValue;
					}
					if ((value == defaultValue && preferredType == PreferredType.String) || preferredType == PreferredType.LocaleString)
					{
						if (value is JSObject)
						{
							ScriptObject parent = ((JSObject)value).GetParent();
							if (parent is ClassScope)
							{
								return ((ClassScope)parent).GetFullName();
							}
							return "[object Object]";
						}
						return value.ToString();
					}
					throw new JScriptException(JSError.TypeMismatch);
				}
				if (value is Missing || value is System.Reflection.Missing)
				{
					return null;
				}
				IReflect reflect = ((!(value is IReflect) || value is Type) ? value.GetType() : ((IReflect)value));
				MethodInfo methodInfo = null;
				if (preferredType == PreferredType.String || preferredType == PreferredType.LocaleString)
				{
					methodInfo = GetToXXXXMethod(reflect, typeof(string), explicitOK: true);
				}
				else
				{
					methodInfo = GetToXXXXMethod(reflect, typeof(double), explicitOK: true);
					if (methodInfo == null)
					{
						methodInfo = GetToXXXXMethod(reflect, typeof(long), explicitOK: true);
					}
					if (methodInfo == null)
					{
						methodInfo = GetToXXXXMethod(reflect, typeof(ulong), explicitOK: true);
					}
				}
				if (methodInfo != null)
				{
					methodInfo = new JSMethodInfo(methodInfo);
					return methodInfo.Invoke(null, BindingFlags.SuppressChangeType, null, new object[1] { value }, null);
				}
				try
				{
					try
					{
						MemberInfo memberInfo = LateBinding.SelectMember(JSBinder.GetDefaultMembers(Runtime.TypeRefs, reflect));
						if (memberInfo != null)
						{
							switch (memberInfo.MemberType)
							{
							case MemberTypes.Field:
								return ((FieldInfo)memberInfo).GetValue(value);
							case MemberTypes.Method:
								return ((MethodInfo)memberInfo).Invoke(value, new object[0]);
							case MemberTypes.Property:
								return JSProperty.GetValue((PropertyInfo)memberInfo, value, null);
							case MemberTypes.Event:
								return null;
							case MemberTypes.NestedType:
								return memberInfo;
							}
						}
						if (value == reflect)
						{
							Type type = value.GetType();
							TypeReflector typeReflectorFor = TypeReflector.GetTypeReflectorFor(type);
							if (typeReflectorFor.Is__ComObject() && (!VsaEngine.executeForJSEE || !(value is IDebuggerObject)))
							{
								reflect = type;
							}
						}
						if (VsaEngine.executeForJSEE && reflect is IDebuggerObject debuggerObject)
						{
							if (debuggerObject.IsScriptObject())
							{
								return reflect.InvokeMember("< JScript-" + preferredType.ToString() + " >", BindingFlags.InvokeMethod | BindingFlags.GetField | BindingFlags.GetProperty | BindingFlags.ExactBinding | BindingFlags.SuppressChangeType, null, value, new object[0], null, null, new string[0]);
							}
							throw new JScriptException(JSError.NonSupportedInDebugger);
						}
						return reflect.InvokeMember(string.Empty, BindingFlags.InvokeMethod | BindingFlags.GetField | BindingFlags.GetProperty | BindingFlags.ExactBinding | BindingFlags.SuppressChangeType, null, value, new object[0], null, null, new string[0]);
					}
					catch (TargetInvocationException ex)
					{
						throw ex.InnerException;
					}
				}
				catch (ArgumentException)
				{
				}
				catch (IndexOutOfRangeException)
				{
				}
				catch (MissingMemberException)
				{
				}
				catch (SecurityException)
				{
				}
				catch (TargetParameterCountException)
				{
				}
				catch (COMException ex7)
				{
					if (ex7.ErrorCode != -2147352573)
					{
						throw ex7;
					}
				}
				if (preferredType != PreferredType.Number)
				{
					if (value.GetType().IsCOMObject)
					{
						return "ActiveXObject";
					}
					if (value is char[])
					{
						return new string((char[])value);
					}
					return value.ToString();
				}
				return value;
			}
			case TypeCode.DateTime:
				return DateConstructor.ob.Construct(ic.ToDateTime(null)).GetDefaultValue(preferredType);
			default:
				return value;
			}
		}

		internal static string ToString(object value)
		{
			return ToString(value, PreferredType.String, explicitOK: true);
		}

		/// <summary>Converts the specified <see cref="T:System.Object" /> to a <see cref="T:System.String" />, optionally allowing data loss.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="explicitOK">
		///   <see langword="true" /> to allow data loss; otherwise, <see langword="false" />.</param>
		/// <returns>
		///   <paramref name="value" /> converted to a <see cref="T:System.String" />.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public static string ToString(object value, bool explicitOK)
		{
			return ToString(value, PreferredType.String, explicitOK);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static string ToString(object value, IConvertible ic)
		{
			return ToString(value, PreferredType.String, ic, explicitOK: true);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static string ToString(object value, PreferredType pref, bool explicitOK)
		{
			if (value is string result)
			{
				return result;
			}
			if (value is StringObject stringObject && stringObject.noExpando)
			{
				return stringObject.value;
			}
			return ToString(value, pref, GetIConvertible(value), explicitOK);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static string ToString(object value, PreferredType pref, IConvertible ic, bool explicitOK)
		{
			if (value is Enum @enum)
			{
				return @enum.ToString("G");
			}
			if (value is EnumWrapper enumWrapper)
			{
				return enumWrapper.ToString();
			}
			TypeCode typeCode = GetTypeCode(value, ic);
			if (pref == PreferredType.LocaleString)
			{
				switch (typeCode)
				{
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Single:
				case TypeCode.Double:
				{
					double num = ic.ToDouble(null);
					return num.ToString((num <= -1E+15 || num >= 1E+15) ? "g" : "n", NumberFormatInfo.CurrentInfo);
				}
				case TypeCode.Int64:
					return ic.ToInt64(null).ToString("n", NumberFormatInfo.CurrentInfo);
				case TypeCode.UInt64:
					return ic.ToUInt64(null).ToString("n", NumberFormatInfo.CurrentInfo);
				case TypeCode.Decimal:
					return ic.ToDecimal(null).ToString("n", NumberFormatInfo.CurrentInfo);
				}
			}
			switch (typeCode)
			{
			case TypeCode.Empty:
				if (!explicitOK)
				{
					return null;
				}
				return "undefined";
			case TypeCode.Object:
				return ToString(ToPrimitive(value, pref, ref ic), ic);
			case TypeCode.DBNull:
				if (!explicitOK)
				{
					return null;
				}
				return "null";
			case TypeCode.Boolean:
				if (!ic.ToBoolean(null))
				{
					return "false";
				}
				return "true";
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Decimal:
			case TypeCode.String:
				return ic.ToString(null);
			case TypeCode.DateTime:
				return ToString(DateConstructor.ob.Construct(ic.ToDateTime(null)));
			case TypeCode.Single:
			case TypeCode.Double:
				return ToString(ic.ToDouble(null));
			default:
				return null;
			}
		}

		/// <summary>Converts the specified <see cref="T:System.Boolean" /> to a <see cref="T:System.String" />.</summary>
		/// <param name="b">The value to convert.</param>
		/// <returns>
		///   <paramref name="b" /> converted to a <see cref="T:System.String" />.</returns>
		public static string ToString(bool b)
		{
			if (!b)
			{
				return "false";
			}
			return "true";
		}

		/// <summary>Converts the specified <see cref="T:System.Double" /> to a <see cref="T:System.String" />.</summary>
		/// <param name="d">The value to convert.</param>
		/// <returns>
		///   <paramref name="d" /> converted to a <see cref="T:System.String" />.</returns>
		public static string ToString(double d)
		{
			long num = (long)d;
			if ((double)num == d)
			{
				return num.ToString(CultureInfo.InvariantCulture);
			}
			if (d != d)
			{
				return "NaN";
			}
			if (double.IsPositiveInfinity(d))
			{
				return "Infinity";
			}
			if (double.IsNegativeInfinity(d))
			{
				return "-Infinity";
			}
			double num2 = ((d < 0.0) ? (0.0 - d) : d);
			int num3 = 15;
			string text = num2.ToString("e14", CultureInfo.InvariantCulture);
			if (DoubleParse(text) != num2)
			{
				text = num2.ToString("e15", CultureInfo.InvariantCulture);
				num3 = 16;
				if (DoubleParse(text) != num2)
				{
					text = num2.ToString("e16", CultureInfo.InvariantCulture);
					num3 = 17;
					if (DoubleParse(text) != num2)
					{
						text = num2.ToString("e17", CultureInfo.InvariantCulture);
						num3 = 18;
					}
				}
			}
			int num4 = int.Parse(text.Substring(num3 + 2, text.Length - (num3 + 2)), CultureInfo.InvariantCulture);
			while (text[num3] == '0')
			{
				num3--;
			}
			int num5 = num4 + 1;
			if (num3 <= num5 && num5 <= 21)
			{
				StringBuilder stringBuilder = new StringBuilder(num5 + 1);
				if (d < 0.0)
				{
					stringBuilder.Append('-');
				}
				stringBuilder.Append(text[0]);
				if (num3 > 1)
				{
					stringBuilder.Append(text, 2, num3 - 1);
				}
				if (num4 - num3 >= 0)
				{
					stringBuilder.Append('0', num5 - num3);
				}
				return stringBuilder.ToString();
			}
			if (0 < num5 && num5 <= 21)
			{
				StringBuilder stringBuilder2 = new StringBuilder(num3 + 2);
				if (d < 0.0)
				{
					stringBuilder2.Append('-');
				}
				stringBuilder2.Append(text[0]);
				if (num5 > 1)
				{
					stringBuilder2.Append(text, 2, num5 - 1);
				}
				stringBuilder2.Append('.');
				stringBuilder2.Append(text, num5 + 1, num3 - num5);
				return stringBuilder2.ToString();
			}
			if (-6 < num5 && num5 <= 0)
			{
				StringBuilder stringBuilder3 = new StringBuilder(2 - num5);
				if (d < 0.0)
				{
					stringBuilder3.Append("-0.");
				}
				else
				{
					stringBuilder3.Append("0.");
				}
				if (num5 < 0)
				{
					stringBuilder3.Append('0', -num5);
				}
				stringBuilder3.Append(text[0]);
				stringBuilder3.Append(text, 2, num3 - 1);
				return stringBuilder3.ToString();
			}
			StringBuilder stringBuilder4 = new StringBuilder(28);
			if (d < 0.0)
			{
				stringBuilder4.Append('-');
			}
			stringBuilder4.Append(text.Substring(0, (num3 == 1) ? 1 : (num3 + 1)));
			stringBuilder4.Append('e');
			if (num4 >= 0)
			{
				stringBuilder4.Append('+');
			}
			stringBuilder4.Append(num4);
			return stringBuilder4.ToString();
		}

		internal static string ToString(object value, int radix)
		{
			if (radix == 10 || radix < 2 || radix > 36)
			{
				return ToString(value);
			}
			double num = ToNumber(value);
			if (num == 0.0)
			{
				return "0";
			}
			if (double.IsNaN(num))
			{
				return "NaN";
			}
			if (double.IsPositiveInfinity(num))
			{
				return "Infinity";
			}
			if (double.IsNegativeInfinity(num))
			{
				return "-Infinity";
			}
			StringBuilder stringBuilder = new StringBuilder();
			if (num < 0.0)
			{
				stringBuilder.Append('-');
				num = 0.0 - num;
			}
			int num2 = rgcchSig[radix - 2];
			if (num < 8.6736173798840355E-19 || num >= 2.305843009213694E+18)
			{
				int num3 = (int)Math.Log(num, radix) + 1;
				double num4 = Math.Pow(radix, num3);
				if (double.IsPositiveInfinity(num4))
				{
					num4 = Math.Pow(radix, --num3);
				}
				else if (num4 == 0.0)
				{
					num4 = Math.Pow(radix, ++num3);
				}
				num /= num4;
				while (num < 1.0)
				{
					num *= (double)radix;
					num3--;
				}
				int num5 = (int)num;
				stringBuilder.Append(ToDigit(num5));
				num2--;
				num -= (double)num5;
				if (num != 0.0)
				{
					stringBuilder.Append('.');
					while (num != 0.0 && num2-- > 0)
					{
						num *= (double)radix;
						num5 = (int)num;
						if (num5 >= radix)
						{
							num5 = radix - 1;
						}
						stringBuilder.Append(ToDigit(num5));
						num -= (double)num5;
					}
				}
				stringBuilder.Append((num3 >= 0) ? "(e+" : "(e");
				stringBuilder.Append(num3.ToString(CultureInfo.InvariantCulture));
				stringBuilder.Append(')');
			}
			else
			{
				int num6;
				if (num >= 1.0)
				{
					num6 = 1;
					double num7 = 1.0;
					double num8;
					while ((num8 = num7 * (double)radix) <= num)
					{
						num6++;
						num7 = num8;
					}
					for (int i = 0; i < num6; i++)
					{
						int num9 = (int)(num / num7);
						if (num9 >= radix)
						{
							num9 = radix - 1;
						}
						stringBuilder.Append(ToDigit(num9));
						num -= (double)num9 * num7;
						num7 /= (double)radix;
					}
				}
				else
				{
					stringBuilder.Append('0');
					num6 = 0;
				}
				if (num != 0.0 && num6 < num2)
				{
					stringBuilder.Append('.');
					while (num != 0.0 && num6 < num2)
					{
						num *= (double)radix;
						int num9 = (int)num;
						if (num9 >= radix)
						{
							num9 = radix - 1;
						}
						stringBuilder.Append(ToDigit(num9));
						num -= (double)num9;
						if (num9 != 0 || num6 != 0)
						{
							num6++;
						}
					}
				}
			}
			return stringBuilder.ToString();
		}

		internal static Type ToType(IReflect ir)
		{
			return ToType(Globals.TypeRefs, ir);
		}

		internal static Type ToType(TypeReferences typeRefs, IReflect ir)
		{
			if (ir is Type)
			{
				return (Type)ir;
			}
			if (ir is ClassScope)
			{
				return ((ClassScope)ir).GetTypeBuilderOrEnumBuilder();
			}
			if (ir is TypedArray)
			{
				return typeRefs.ToReferenceContext(((TypedArray)ir).ToType());
			}
			if (ir is ScriptFunction)
			{
				return typeRefs.ScriptFunction;
			}
			return typeRefs.ToReferenceContext(ir.GetType());
		}

		internal static Type ToType(string descriptor, Type elementType)
		{
			Module module = elementType.Module;
			if (module is ModuleBuilder)
			{
				return module.GetType(elementType.FullName + descriptor);
			}
			return module.Assembly.GetType(elementType.FullName + descriptor);
		}

		internal static string ToTypeName(IReflect ir)
		{
			if (ir is ClassScope)
			{
				return ((ClassScope)ir).GetName();
			}
			if (ir is JSObject)
			{
				return ((JSObject)ir).GetClassName();
			}
			if (ir is GlobalScope)
			{
				return "Global Object";
			}
			return ir.ToString();
		}

		internal static uint ToUint32(object value)
		{
			if (value is uint)
			{
				return (uint)value;
			}
			return ToUint32(value, GetIConvertible(value));
		}

		internal static uint ToUint32(object value, IConvertible ic)
		{
			switch (GetTypeCode(value, ic))
			{
			case TypeCode.Empty:
				return 0u;
			case TypeCode.DBNull:
				return 0u;
			case TypeCode.Boolean:
				if (!ic.ToBoolean(null))
				{
					return 0u;
				}
				return 1u;
			case TypeCode.Char:
				return ic.ToChar(null);
			case TypeCode.Byte:
			case TypeCode.UInt16:
			case TypeCode.UInt32:
				return ic.ToUInt32(null);
			case TypeCode.UInt64:
				return (uint)ic.ToUInt64(null);
			case TypeCode.SByte:
			case TypeCode.Int16:
			case TypeCode.Int32:
			case TypeCode.Int64:
				return (uint)ic.ToInt64(null);
			case TypeCode.Single:
			case TypeCode.Double:
				return (uint)Runtime.DoubleToInt64(ic.ToDouble(null));
			case TypeCode.Decimal:
				return (uint)Runtime.UncheckedDecimalToInt64(ic.ToDecimal(null));
			case TypeCode.Object:
			case TypeCode.DateTime:
			{
				object obj = ToPrimitive(value, PreferredType.Number, ref ic);
				if (obj != value)
				{
					return ToUint32(obj, ic);
				}
				return 0u;
			}
			case TypeCode.String:
				return (uint)Runtime.DoubleToInt64(ToNumber(ic.ToString(null)));
			default:
				return 0u;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Convert" /> class.</summary>
		public Convert()
		{
		}
	}
	internal sealed class CustomAttribute : AST
	{
		private AST ctor;

		private ASTList args;

		private AST target;

		internal object type;

		private ArrayList positionalArgValues;

		private ArrayList namedArgFields;

		private ArrayList namedArgFieldValues;

		private ArrayList namedArgProperties;

		private ArrayList namedArgPropertyValues;

		internal bool raiseToPropertyLevel;

		internal CustomAttribute(Context context, AST func, ASTList args)
			: base(context)
		{
			ctor = func;
			this.args = args;
			target = null;
			type = null;
			positionalArgValues = new ArrayList();
			namedArgFields = new ArrayList();
			namedArgFieldValues = new ArrayList();
			namedArgProperties = new ArrayList();
			namedArgPropertyValues = new ArrayList();
			raiseToPropertyLevel = false;
		}

		private bool CheckIfTargetOK(object caType)
		{
			if (caType == null)
			{
				return false;
			}
			AttributeTargets attributeTargets = (AttributeTargets)0;
			Type type = caType as Type;
			if (type != null)
			{
				object[] customAttributes = GetCustomAttributes(type, typeof(AttributeUsageAttribute), inherit: true);
				attributeTargets = ((AttributeUsageAttribute)customAttributes[0]).ValidOn;
			}
			else
			{
				attributeTargets = ((ClassScope)caType).owner.validOn;
			}
			object obj = target;
			if (obj is Class @class)
			{
				if (@class.isInterface)
				{
					if ((attributeTargets & AttributeTargets.Interface) != 0)
					{
						return true;
					}
				}
				else if (@class is EnumDeclaration)
				{
					if ((attributeTargets & AttributeTargets.Enum) != 0)
					{
						return true;
					}
				}
				else
				{
					if ((attributeTargets & AttributeTargets.Class) != 0)
					{
						if (type == typeof(AttributeUsageAttribute))
						{
							if (positionalArgValues.Count > 0)
							{
								object obj2 = positionalArgValues[0];
								if (obj2 is AttributeTargets)
								{
									@class.validOn = (AttributeTargets)obj2;
								}
							}
							int i = 0;
							for (int count = namedArgProperties.Count; i < count; i++)
							{
								PropertyInfo propertyInfo = namedArgProperties[i] as PropertyInfo;
								if (propertyInfo.Name == "AllowMultiple")
								{
									@class.allowMultiple = (bool)namedArgPropertyValues[i];
								}
							}
						}
						return true;
					}
					if (type.FullName == "System.NonSerializedAttribute")
					{
						@class.attributes &= ~TypeAttributes.Serializable;
						return false;
					}
				}
				context.HandleError(JSError.InvalidCustomAttributeTarget, GetTypeName(caType));
				return false;
			}
			if (obj is FunctionDeclaration functionDeclaration)
			{
				if ((attributeTargets & AttributeTargets.Property) != 0 && functionDeclaration.enclosingProperty != null)
				{
					if (functionDeclaration.enclosingProperty.getter == null || ((JSFieldMethod)functionDeclaration.enclosingProperty.getter).func == functionDeclaration.func)
					{
						raiseToPropertyLevel = true;
						return true;
					}
					context.HandleError(JSError.PropertyLevelAttributesMustBeOnGetter);
					return false;
				}
				if ((attributeTargets & AttributeTargets.Method) != 0 && functionDeclaration.isMethod)
				{
					return true;
				}
				if ((attributeTargets & AttributeTargets.Constructor) != 0 && functionDeclaration.func.isConstructor)
				{
					return true;
				}
				context.HandleError(JSError.InvalidCustomAttributeTarget, GetTypeName(caType));
				return false;
			}
			if (obj is VariableDeclaration || obj is Constant)
			{
				if ((attributeTargets & AttributeTargets.Field) != 0)
				{
					return true;
				}
				context.HandleError(JSError.InvalidCustomAttributeTarget, GetTypeName(caType));
				return false;
			}
			if (obj is AssemblyCustomAttributeList && (attributeTargets & AttributeTargets.Assembly) != 0)
			{
				return true;
			}
			if (obj == null && (attributeTargets & AttributeTargets.Parameter) != 0)
			{
				return true;
			}
			context.HandleError(JSError.InvalidCustomAttributeTarget, GetTypeName(caType));
			return false;
		}

		private static ushort DaysSince2000()
		{
			return (ushort)(DateTime.Now - new DateTime(2000, 1, 1)).Days;
		}

		internal override object Evaluate()
		{
			ConstructorInfo constructorInfo = (ConstructorInfo)((Binding)ctor).member;
			ParameterInfo[] parameters = constructorInfo.GetParameters();
			int num = parameters.Length;
			for (int i = positionalArgValues.Count; i < num; i++)
			{
				positionalArgValues.Add(Convert.CoerceT(null, parameters[i].ParameterType));
			}
			object[] array = new object[num];
			positionalArgValues.CopyTo(0, array, 0, num);
			object obj = constructorInfo.Invoke(BindingFlags.ExactBinding, null, array, null);
			int j = 0;
			for (int count = namedArgProperties.Count; j < count; j++)
			{
				JSProperty jSProperty = namedArgProperties[j] as JSProperty;
				if (jSProperty != null)
				{
					jSProperty.SetValue(obj, Convert.Coerce(namedArgPropertyValues[j], jSProperty.PropertyIR()), null);
				}
				else
				{
					((PropertyInfo)namedArgProperties[j]).SetValue(obj, namedArgPropertyValues[j], null);
				}
			}
			int k = 0;
			for (int count2 = namedArgFields.Count; k < count2; k++)
			{
				JSVariableField jSVariableField = namedArgFields[k] as JSVariableField;
				if (jSVariableField != null)
				{
					jSVariableField.SetValue(obj, Convert.Coerce(namedArgFieldValues[k], jSVariableField.GetInferredType(null)));
				}
				else
				{
					((FieldInfo)namedArgFields[k]).SetValue(obj, namedArgFieldValues[k]);
				}
			}
			return obj;
		}

		internal CLSComplianceSpec GetCLSComplianceValue()
		{
			if (!(bool)positionalArgValues[0])
			{
				return CLSComplianceSpec.NonCLSCompliant;
			}
			return CLSComplianceSpec.CLSCompliant;
		}

		private void ConvertClassScopesAndEnumWrappers(ArrayList vals)
		{
			int i = 0;
			for (int count = vals.Count; i < count; i++)
			{
				if (vals[i] is ClassScope classScope)
				{
					vals[i] = classScope.GetTypeBuilder();
				}
				else if (vals[i] is EnumWrapper enumWrapper)
				{
					vals[i] = enumWrapper.ToNumericValue();
				}
			}
		}

		private void ConvertFieldAndPropertyInfos(ArrayList vals)
		{
			int i = 0;
			for (int count = vals.Count; i < count; i++)
			{
				JSField jSField = vals[i] as JSField;
				if (jSField != null)
				{
					vals[i] = jSField.GetMetaData();
					continue;
				}
				JSProperty jSProperty = vals[i] as JSProperty;
				if (jSProperty != null)
				{
					vals[i] = jSProperty.metaData;
				}
			}
		}

		internal CustomAttributeBuilder GetCustomAttribute()
		{
			ConstructorInfo constructorInfo = (ConstructorInfo)((Binding)ctor).member;
			ParameterInfo[] parameters = constructorInfo.GetParameters();
			int num = parameters.Length;
			if (constructorInfo is JSConstructor)
			{
				constructorInfo = ((JSConstructor)constructorInfo).GetConstructorInfo(base.compilerGlobals);
			}
			ConvertClassScopesAndEnumWrappers(positionalArgValues);
			ConvertClassScopesAndEnumWrappers(namedArgPropertyValues);
			ConvertClassScopesAndEnumWrappers(namedArgFieldValues);
			ConvertFieldAndPropertyInfos(namedArgProperties);
			ConvertFieldAndPropertyInfos(namedArgFields);
			for (int i = positionalArgValues.Count; i < num; i++)
			{
				positionalArgValues.Add(Convert.CoerceT(null, parameters[i].ParameterType));
			}
			object[] array = new object[num];
			positionalArgValues.CopyTo(0, array, 0, num);
			PropertyInfo[] array2 = new PropertyInfo[namedArgProperties.Count];
			namedArgProperties.CopyTo(array2);
			object[] array3 = new object[namedArgPropertyValues.Count];
			namedArgPropertyValues.CopyTo(array3);
			FieldInfo[] array4 = new FieldInfo[namedArgFields.Count];
			namedArgFields.CopyTo(array4);
			object[] array5 = new object[namedArgFieldValues.Count];
			namedArgFieldValues.CopyTo(array5);
			return new CustomAttributeBuilder(constructorInfo, array, array2, array3, array4, array5);
		}

		internal object GetTypeIfAttributeHasToBeUnique()
		{
			Type type = this.type as Type;
			if (type != null)
			{
				object[] customAttributes = GetCustomAttributes(type, typeof(AttributeUsageAttribute), inherit: false);
				if (customAttributes.Length != 0 && !((AttributeUsageAttribute)customAttributes[0]).AllowMultiple)
				{
					return type;
				}
				return null;
			}
			if (!((ClassScope)this.type).owner.allowMultiple)
			{
				return this.type;
			}
			return null;
		}

		private static string GetTypeName(object t)
		{
			Type type = t as Type;
			if (type != null)
			{
				return type.FullName;
			}
			return ((ClassScope)t).GetFullName();
		}

		internal bool IsExpandoAttribute()
		{
			if (ctor is Lookup lookup)
			{
				return lookup.Name == "expando";
			}
			return false;
		}

		internal override AST PartiallyEvaluate()
		{
			ctor = ctor.PartiallyEvaluateAsCallable();
			ASTList aSTList = new ASTList(args.context);
			ASTList aSTList2 = new ASTList(args.context);
			int i = 0;
			for (int count = args.count; i < count; i++)
			{
				AST aST = args[i];
				if (aST is Assign assign)
				{
					assign.rhside = assign.rhside.PartiallyEvaluate();
					aSTList2.Append(assign);
				}
				else
				{
					aSTList.Append(aST.PartiallyEvaluate());
				}
			}
			int count2 = aSTList.count;
			IReflect[] array = new IReflect[count2];
			for (int j = 0; j < count2; j++)
			{
				AST aST2 = aSTList[j];
				if (aST2 is ConstantWrapper)
				{
					object obj = aST2.Evaluate();
					if ((array[j] = TypeOfArgument(obj)) != null)
					{
						positionalArgValues.Add(obj);
						continue;
					}
				}
				else if (aST2 is ArrayLiteral && ((ArrayLiteral)aST2).IsOkToUseInCustomAttribute())
				{
					array[j] = Typeob.ArrayObject;
					positionalArgValues.Add(aST2.Evaluate());
					continue;
				}
				aST2.context.HandleError(JSError.InvalidCustomAttributeArgument);
				return null;
			}
			this.type = ctor.ResolveCustomAttribute(aSTList, array, target);
			if (this.type == null)
			{
				return null;
			}
			if (Convert.IsPromotableTo((IReflect)this.type, Typeob.CodeAccessSecurityAttribute))
			{
				context.HandleError(JSError.CannotUseStaticSecurityAttribute);
				return null;
			}
			ConstructorInfo constructorInfo = (ConstructorInfo)((Binding)ctor).member;
			ParameterInfo[] parameters = constructorInfo.GetParameters();
			int num = 0;
			int count3 = positionalArgValues.Count;
			ParameterInfo[] array2 = parameters;
			foreach (ParameterInfo parameterInfo in array2)
			{
				IReflect reflect;
				if (!(parameterInfo is ParameterDeclaration))
				{
					IReflect parameterType = parameterInfo.ParameterType;
					reflect = parameterType;
				}
				else
				{
					reflect = ((ParameterDeclaration)parameterInfo).ParameterIReflect;
				}
				IReflect reflect2 = reflect;
				if (num < count3)
				{
					object obj2 = positionalArgValues[num];
					positionalArgValues[num] = Convert.Coerce(obj2, reflect2, obj2 is ArrayObject);
					num++;
				}
				else
				{
					object value = ((TypeReferences.GetDefaultParameterValue(parameterInfo) != System.Convert.DBNull) ? TypeReferences.GetDefaultParameterValue(parameterInfo) : Convert.Coerce(null, reflect2));
					positionalArgValues.Add(value);
				}
			}
			int l = 0;
			for (int count4 = aSTList2.count; l < count4; l++)
			{
				Assign assign2 = (Assign)aSTList2[l];
				if (assign2.lhside is Lookup && (assign2.rhside is ConstantWrapper || (assign2.rhside is ArrayLiteral && ((ArrayLiteral)assign2.rhside).IsOkToUseInCustomAttribute())))
				{
					object obj3 = assign2.rhside.Evaluate();
					IReflect reflect3 = null;
					if (obj3 is ArrayObject || ((reflect3 = TypeOfArgument(obj3)) != null && reflect3 != Typeob.Object))
					{
						string name = ((Lookup)assign2.lhside).Name;
						MemberInfo[] member = ((IReflect)this.type).GetMember(name, BindingFlags.Instance | BindingFlags.Public);
						if (member == null || member.Length == 0)
						{
							assign2.context.HandleError(JSError.NoSuchMember);
							return null;
						}
						if (member.Length == 1)
						{
							MemberInfo memberInfo = member[0];
							if (memberInfo is FieldInfo)
							{
								FieldInfo fieldInfo = (FieldInfo)memberInfo;
								if (!fieldInfo.IsLiteral && !fieldInfo.IsInitOnly)
								{
									try
									{
										IReflect reflect4;
										if (!(fieldInfo is JSVariableField))
										{
											IReflect parameterType = fieldInfo.FieldType;
											reflect4 = parameterType;
										}
										else
										{
											reflect4 = ((JSVariableField)fieldInfo).GetInferredType(null);
										}
										IReflect reflect5 = reflect4;
										obj3 = Convert.Coerce(obj3, reflect5, obj3 is ArrayObject);
										namedArgFields.Add(memberInfo);
										namedArgFieldValues.Add(obj3);
									}
									catch (JScriptException)
									{
										assign2.rhside.context.HandleError(JSError.TypeMismatch);
										return null;
									}
									continue;
								}
							}
							else if (memberInfo is PropertyInfo)
							{
								PropertyInfo prop = (PropertyInfo)memberInfo;
								MethodInfo setMethod = JSProperty.GetSetMethod(prop, nonPublic: false);
								if (setMethod != null)
								{
									ParameterInfo[] parameters2 = setMethod.GetParameters();
									if (parameters2 != null && parameters2.Length == 1)
									{
										try
										{
											IReflect reflect6;
											if (!(parameters2[0] is ParameterDeclaration))
											{
												IReflect parameterType = parameters2[0].ParameterType;
												reflect6 = parameterType;
											}
											else
											{
												reflect6 = ((ParameterDeclaration)parameters2[0]).ParameterIReflect;
											}
											IReflect reflect7 = reflect6;
											obj3 = Convert.Coerce(obj3, reflect7, obj3 is ArrayObject);
											namedArgProperties.Add(memberInfo);
											namedArgPropertyValues.Add(obj3);
										}
										catch (JScriptException)
										{
											assign2.rhside.context.HandleError(JSError.TypeMismatch);
											return null;
										}
										continue;
									}
								}
							}
						}
					}
				}
				assign2.context.HandleError(JSError.InvalidCustomAttributeArgument);
				return null;
			}
			if (!CheckIfTargetOK(this.type))
			{
				return null;
			}
			try
			{
				Type type = this.type as Type;
				if (type != null)
				{
					if (target is AssemblyCustomAttributeList)
					{
						if (type.FullName == "System.Reflection.AssemblyAlgorithmIdAttribute")
						{
							if (positionalArgValues.Count > 0)
							{
								base.Engine.Globals.assemblyHashAlgorithm = (AssemblyHashAlgorithm)Convert.CoerceT(positionalArgValues[0], typeof(AssemblyHashAlgorithm));
							}
							return null;
						}
						if (type.FullName == "System.Reflection.AssemblyCultureAttribute")
						{
							if (positionalArgValues.Count > 0)
							{
								string text = Convert.ToString(positionalArgValues[0]);
								if (base.Engine.PEFileKind != PEFileKinds.Dll && text.Length > 0)
								{
									context.HandleError(JSError.ExecutablesCannotBeLocalized);
									return null;
								}
								base.Engine.Globals.assemblyCulture = new CultureInfo(text);
							}
							return null;
						}
						if (type.FullName == "System.Reflection.AssemblyDelaySignAttribute")
						{
							if (positionalArgValues.Count > 0)
							{
								base.Engine.Globals.assemblyDelaySign = Convert.ToBoolean(positionalArgValues[0], explicitConversion: false);
							}
							return null;
						}
						if (type.FullName == "System.Reflection.AssemblyFlagsAttribute")
						{
							if (positionalArgValues.Count > 0)
							{
								base.Engine.Globals.assemblyFlags = (AssemblyFlags)(uint)Convert.CoerceT(positionalArgValues[0], typeof(uint));
							}
							return null;
						}
						if (type.FullName == "System.Reflection.AssemblyKeyFileAttribute")
						{
							if (positionalArgValues.Count > 0)
							{
								base.Engine.Globals.assemblyKeyFileName = Convert.ToString(positionalArgValues[0]);
								base.Engine.Globals.assemblyKeyFileNameContext = context;
								if (base.Engine.Globals.assemblyKeyFileName != null && base.Engine.Globals.assemblyKeyFileName.Length == 0)
								{
									base.Engine.Globals.assemblyKeyFileName = null;
									base.Engine.Globals.assemblyKeyFileNameContext = null;
								}
							}
							return null;
						}
						if (type.FullName == "System.Reflection.AssemblyKeyNameAttribute")
						{
							if (positionalArgValues.Count > 0)
							{
								base.Engine.Globals.assemblyKeyName = Convert.ToString(positionalArgValues[0]);
								base.Engine.Globals.assemblyKeyNameContext = context;
								if (base.Engine.Globals.assemblyKeyName != null && base.Engine.Globals.assemblyKeyName.Length == 0)
								{
									base.Engine.Globals.assemblyKeyName = null;
									base.Engine.Globals.assemblyKeyNameContext = null;
								}
							}
							return null;
						}
						if (type.FullName == "System.Reflection.AssemblyVersionAttribute")
						{
							if (positionalArgValues.Count > 0)
							{
								base.Engine.Globals.assemblyVersion = ParseVersion(Convert.ToString(positionalArgValues[0]));
							}
							return null;
						}
						if (type.FullName == "System.CLSCompliantAttribute")
						{
							base.Engine.isCLSCompliant = args == null || args.count == 0 || Convert.ToBoolean(positionalArgValues[0], explicitConversion: false);
							return this;
						}
						return this;
					}
					return this;
				}
				return this;
			}
			catch (ArgumentException)
			{
				context.HandleError(JSError.InvalidCall);
				return this;
			}
		}

		private Version ParseVersion(string vString)
		{
			ushort major = 1;
			ushort minor = 0;
			ushort build = 0;
			ushort revision = 0;
			try
			{
				int length = vString.Length;
				int num = vString.IndexOf('.', 0);
				if (num < 0)
				{
					throw new Exception();
				}
				major = ushort.Parse(vString.Substring(0, num), CultureInfo.InvariantCulture);
				int num2 = vString.IndexOf('.', num + 1);
				if (num2 < num + 1)
				{
					minor = ushort.Parse(vString.Substring(num + 1, length - num - 1), CultureInfo.InvariantCulture);
				}
				else
				{
					minor = ushort.Parse(vString.Substring(num + 1, num2 - num - 1), CultureInfo.InvariantCulture);
					if (vString[num2 + 1] == '*')
					{
						build = DaysSince2000();
						revision = SecondsSinceMidnight();
					}
					else
					{
						int num3 = vString.IndexOf('.', num2 + 1);
						if (num3 < num2 + 1)
						{
							build = ushort.Parse(vString.Substring(num2 + 1, length - num2 - 1), CultureInfo.InvariantCulture);
						}
						else
						{
							build = ushort.Parse(vString.Substring(num2 + 1, num3 - num2 - 1), CultureInfo.InvariantCulture);
							revision = ((vString[num3 + 1] != '*') ? ushort.Parse(vString.Substring(num3 + 1, length - num3 - 1), CultureInfo.InvariantCulture) : SecondsSinceMidnight());
						}
					}
				}
			}
			catch
			{
				args[0].context.HandleError(JSError.NotValidVersionString);
			}
			return new Version(major, minor, build, revision);
		}

		private static ushort SecondsSinceMidnight()
		{
			TimeSpan timeSpan = DateTime.Now - DateTime.Today;
			return (ushort)((timeSpan.Hours * 60 * 60 + timeSpan.Minutes * 60 + timeSpan.Seconds) / 2);
		}

		internal void SetTarget(AST target)
		{
			this.target = target;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
		}

		internal static IReflect TypeOfArgument(object argument)
		{
			if (argument is Enum)
			{
				return argument.GetType();
			}
			if (argument is EnumWrapper)
			{
				return ((EnumWrapper)argument).classScopeOrType;
			}
			switch (Convert.GetTypeCode(argument))
			{
			case TypeCode.Empty:
			case TypeCode.DBNull:
				return Typeob.Object;
			case TypeCode.Boolean:
				return Typeob.Boolean;
			case TypeCode.Char:
				return Typeob.Char;
			case TypeCode.Byte:
				return Typeob.Byte;
			case TypeCode.UInt16:
				return Typeob.UInt16;
			case TypeCode.UInt32:
				return Typeob.UInt32;
			case TypeCode.UInt64:
				return Typeob.UInt64;
			case TypeCode.SByte:
				return Typeob.SByte;
			case TypeCode.Int16:
				return Typeob.Int16;
			case TypeCode.Int32:
				return Typeob.Int32;
			case TypeCode.Int64:
				return Typeob.Int64;
			case TypeCode.Single:
				return Typeob.Single;
			case TypeCode.Double:
				return Typeob.Double;
			case TypeCode.Object:
				if (argument is Type)
				{
					return Typeob.Type;
				}
				if (argument is ClassScope)
				{
					return Typeob.Type;
				}
				break;
			case TypeCode.String:
				return Typeob.String;
			}
			return null;
		}

		private static object GetCustomAttributeValue(CustomAttributeTypedArgument arg)
		{
			Type argumentType = arg.ArgumentType;
			if (argumentType.IsEnum)
			{
				return Enum.ToObject(Type.GetType(argumentType.FullName), arg.Value);
			}
			return arg.Value;
		}

		internal static object[] GetCustomAttributes(Assembly target, Type caType, bool inherit)
		{
			if (!target.ReflectionOnly)
			{
				return target.GetCustomAttributes(caType, inherit);
			}
			return ExtractCustomAttribute(CustomAttributeData.GetCustomAttributes(target), caType);
		}

		internal static object[] GetCustomAttributes(Module target, Type caType, bool inherit)
		{
			if (!target.Assembly.ReflectionOnly)
			{
				return target.GetCustomAttributes(caType, inherit);
			}
			return ExtractCustomAttribute(CustomAttributeData.GetCustomAttributes(target), caType);
		}

		internal static object[] GetCustomAttributes(MemberInfo target, Type caType, bool inherit)
		{
			Type type = target.GetType();
			if (type.Assembly == typeof(CustomAttribute).Assembly || !target.Module.Assembly.ReflectionOnly)
			{
				return target.GetCustomAttributes(caType, inherit);
			}
			return ExtractCustomAttribute(CustomAttributeData.GetCustomAttributes(target), caType);
		}

		internal static object[] GetCustomAttributes(ParameterInfo target, Type caType, bool inherit)
		{
			Type type = target.GetType();
			if (type.Assembly == typeof(CustomAttribute).Assembly || !target.Member.Module.Assembly.ReflectionOnly)
			{
				return target.GetCustomAttributes(caType, inherit);
			}
			return ExtractCustomAttribute(CustomAttributeData.GetCustomAttributes(target), caType);
		}

		private static object[] ExtractCustomAttribute(IList<CustomAttributeData> attributes, Type caType)
		{
			Type type = Globals.TypeRefs.ToReferenceContext(caType);
			foreach (CustomAttributeData attribute in attributes)
			{
				if (!(attribute.Constructor.DeclaringType == type))
				{
					continue;
				}
				ArrayList arrayList = new ArrayList();
				foreach (CustomAttributeTypedArgument constructorArgument in attribute.ConstructorArguments)
				{
					arrayList.Add(GetCustomAttributeValue(constructorArgument));
				}
				object obj = Activator.CreateInstance(caType, arrayList.ToArray());
				foreach (CustomAttributeNamedArgument namedArgument in attribute.NamedArguments)
				{
					caType.InvokeMember(namedArgument.MemberInfo.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetField | BindingFlags.SetProperty, null, obj, new object[1] { GetCustomAttributeValue(namedArgument.TypedValue) }, null, CultureInfo.InvariantCulture, null);
				}
				return new object[1] { obj };
			}
			return new object[0];
		}

		internal static bool IsDefined(MemberInfo target, Type caType, bool inherit)
		{
			Type type = target.GetType();
			if (type.Assembly == typeof(CustomAttribute).Assembly || !target.Module.Assembly.ReflectionOnly)
			{
				return target.IsDefined(caType, inherit);
			}
			return CheckForCustomAttribute(CustomAttributeData.GetCustomAttributes(target), caType);
		}

		internal static bool IsDefined(ParameterInfo target, Type caType, bool inherit)
		{
			Type type = target.GetType();
			if (type.Assembly == typeof(CustomAttribute).Assembly || !target.Member.Module.Assembly.ReflectionOnly)
			{
				return target.IsDefined(caType, inherit);
			}
			return CheckForCustomAttribute(CustomAttributeData.GetCustomAttributes(target), caType);
		}

		private static bool CheckForCustomAttribute(IList<CustomAttributeData> attributes, Type caType)
		{
			Type type = Globals.TypeRefs.ToReferenceContext(caType);
			foreach (CustomAttributeData attribute in attributes)
			{
				if (attribute.Constructor.DeclaringType == type)
				{
					return true;
				}
			}
			return false;
		}
	}
	internal sealed class CustomAttributeList : AST
	{
		private ArrayList list;

		private ArrayList customAttributes;

		private bool alreadyPartiallyEvaluated;

		internal CustomAttributeList(Context context)
			: base(context)
		{
			list = new ArrayList();
			customAttributes = null;
			alreadyPartiallyEvaluated = false;
		}

		internal void Append(CustomAttribute elem)
		{
			list.Add(elem);
			context.UpdateWith(elem.context);
		}

		internal bool ContainsExpandoAttribute()
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				CustomAttribute customAttribute = (CustomAttribute)list[i];
				if (customAttribute != null && customAttribute.IsExpandoAttribute())
				{
					return true;
				}
			}
			return false;
		}

		internal CustomAttribute GetAttribute(Type attributeClass)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				CustomAttribute customAttribute = (CustomAttribute)list[i];
				if (customAttribute != null)
				{
					object type = customAttribute.type;
					if (type is Type && (Type)type == attributeClass)
					{
						return (CustomAttribute)list[i];
					}
				}
			}
			return null;
		}

		internal override object Evaluate()
		{
			return Evaluate(getForProperty: false);
		}

		internal object Evaluate(bool getForProperty)
		{
			int count = list.Count;
			ArrayList arrayList = new ArrayList(count);
			for (int i = 0; i < count; i++)
			{
				CustomAttribute customAttribute = (CustomAttribute)list[i];
				if (customAttribute == null)
				{
					continue;
				}
				if (customAttribute.raiseToPropertyLevel)
				{
					if (!getForProperty)
					{
						continue;
					}
				}
				else if (getForProperty)
				{
					continue;
				}
				arrayList.Add(customAttribute.Evaluate());
			}
			object[] array = new object[arrayList.Count];
			arrayList.CopyTo(array);
			return array;
		}

		internal CustomAttributeBuilder[] GetCustomAttributeBuilders(bool getForProperty)
		{
			customAttributes = new ArrayList(list.Count);
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				CustomAttribute customAttribute = (CustomAttribute)list[i];
				if (customAttribute == null)
				{
					continue;
				}
				if (customAttribute.raiseToPropertyLevel)
				{
					if (!getForProperty)
					{
						continue;
					}
				}
				else if (getForProperty)
				{
					continue;
				}
				CustomAttributeBuilder customAttribute2 = customAttribute.GetCustomAttribute();
				if (customAttribute2 != null)
				{
					customAttributes.Add(customAttribute2);
				}
			}
			CustomAttributeBuilder[] array = new CustomAttributeBuilder[customAttributes.Count];
			customAttributes.CopyTo(array);
			return array;
		}

		internal override AST PartiallyEvaluate()
		{
			if (alreadyPartiallyEvaluated)
			{
				return this;
			}
			alreadyPartiallyEvaluated = true;
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				list[i] = ((CustomAttribute)list[i]).PartiallyEvaluate();
			}
			int j = 0;
			for (int count2 = list.Count; j < count2; j++)
			{
				CustomAttribute customAttribute = (CustomAttribute)list[j];
				if (customAttribute == null)
				{
					continue;
				}
				object typeIfAttributeHasToBeUnique = customAttribute.GetTypeIfAttributeHasToBeUnique();
				if (typeIfAttributeHasToBeUnique == null)
				{
					continue;
				}
				for (int k = j + 1; k < count2; k++)
				{
					CustomAttribute customAttribute2 = (CustomAttribute)list[k];
					if (customAttribute2 != null && typeIfAttributeHasToBeUnique == customAttribute2.type)
					{
						customAttribute2.context.HandleError(JSError.CustomAttributeUsedMoreThanOnce);
						list[k] = null;
					}
				}
			}
			return this;
		}

		internal void Remove(CustomAttribute elem)
		{
			list.Remove(elem);
		}

		internal void SetTarget(AST target)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				((CustomAttribute)list[i]).SetTarget(target);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public class DateConstructor : ScriptFunction
	{
		internal static readonly DateConstructor ob = new DateConstructor();

		private DatePrototype originalPrototype;

		internal DateConstructor()
			: base(FunctionPrototype.ob, "Date", 7)
		{
			originalPrototype = DatePrototype.ob;
			DatePrototype._constructor = this;
			proto = DatePrototype.ob;
		}

		internal DateConstructor(LenientFunctionPrototype parent, LenientDatePrototype prototypeProp)
			: base(parent, "Date", 7)
		{
			originalPrototype = prototypeProp;
			prototypeProp.constructor = this;
			proto = prototypeProp;
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			return Invoke();
		}

		internal DateObject Construct(DateTime dt)
		{
			return new DateObject(originalPrototype, (double)dt.ToUniversalTime().Ticks / 10000.0 - 62135596800000.0);
		}

		internal override object Construct(object[] args)
		{
			return CreateInstance(args);
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>An instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new DateObject CreateInstance(params object[] args)
		{
			if (args.Length == 0)
			{
				return new DateObject(originalPrototype, (double)DateTime.Now.ToUniversalTime().Ticks / 10000.0 - 62135596800000.0);
			}
			if (args.Length == 1)
			{
				object value = args[0];
				IConvertible ic = Convert.GetIConvertible(value);
				TypeCode typeCode = Convert.GetTypeCode(value, ic);
				if (typeCode == TypeCode.DateTime)
				{
					return new DateObject(originalPrototype, (double)ic.ToDateTime(null).ToUniversalTime().Ticks / 10000.0 - 62135596800000.0);
				}
				object value2 = Convert.ToPrimitive(value, PreferredType.Either, ref ic);
				if (Convert.GetTypeCode(value2, ic) == TypeCode.String)
				{
					return new DateObject(originalPrototype, parse(ic.ToString(null)));
				}
				double num = Convert.ToNumber(value2, ic);
				if (-8.64E+15 <= num && num <= 8.64E+15)
				{
					return new DateObject(originalPrototype, num);
				}
				return new DateObject(originalPrototype, double.NaN);
			}
			double num2 = Convert.ToNumber(args[0]);
			double month = Convert.ToNumber(args[1]);
			double date = ((args.Length > 2) ? Convert.ToNumber(args[2]) : 1.0);
			double hour = ((args.Length > 3) ? Convert.ToNumber(args[3]) : 0.0);
			double min = ((args.Length > 4) ? Convert.ToNumber(args[4]) : 0.0);
			double sec = ((args.Length > 5) ? Convert.ToNumber(args[5]) : 0.0);
			double ms = ((args.Length > 6) ? Convert.ToNumber(args[6]) : 0.0);
			int num3 = (int)Runtime.DoubleToInt64(num2);
			if (!double.IsNaN(num2) && 0 <= num3 && num3 <= 99)
			{
				num2 = num3 + 1900;
			}
			double day = DatePrototype.MakeDay(num2, month, date);
			double time = DatePrototype.MakeTime(hour, min, sec, ms);
			return new DateObject(originalPrototype, DatePrototype.TimeClip(DatePrototype.UTC(DatePrototype.MakeDate(day, time))));
		}

		/// <summary>Returns the number of milliseconds that have elapsed since January 1, 1970.</summary>
		/// <returns>The number of milliseconds that have elapsed since January 1, 1970.</returns>
		public string Invoke()
		{
			return DatePrototype.DateToString((double)DateTime.Now.ToUniversalTime().Ticks / 10000.0 - 62135596800000.0);
		}

		/// <summary>Converts the specified string representation of a date and time to its <see cref="T:System.Double" /> equivalent.</summary>
		/// <param name="str">A string that contains a date and time to convert.</param>
		/// <returns>A <see cref="T:System.Double" /> equivalent of the date and time that is contained in <paramref name="str" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Date_parse)]
		public static double parse(string str)
		{
			return DatePrototype.ParseDate(str);
		}

		/// <summary>Converts the specified date and time to its <see cref="T:System.Double" /> equivalent.</summary>
		/// <param name="year">The year of the date and time to convert.</param>
		/// <param name="month">The month of the date and time to convert.</param>
		/// <param name="date">The date of the date and time to convert.</param>
		/// <param name="hours">The hours of the date and time to convert.</param>
		/// <param name="minutes">The minutes of the date and time to convert.</param>
		/// <param name="seconds">The seconds of the date and time to convert.</param>
		/// <param name="ms">The milliseconds of the date and time to convert.</param>
		/// <returns>A <see cref="T:System.Double" /> equivalent of the specified date and time.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Date_UTC)]
		public static double UTC(object year, object month, object date, object hours, object minutes, object seconds, object ms)
		{
			if (year is Missing)
			{
				return (double)DateTime.Now.ToUniversalTime().Ticks / 10000.0 - 62135596800000.0;
			}
			double num = Convert.ToNumber(year);
			double month2 = ((month is Missing) ? 0.0 : Convert.ToNumber(month));
			double date2 = ((date is Missing) ? 1.0 : Convert.ToNumber(date));
			double hour = ((hours is Missing) ? 0.0 : Convert.ToNumber(hours));
			double min = ((minutes is Missing) ? 0.0 : Convert.ToNumber(minutes));
			double sec = ((seconds is Missing) ? 0.0 : Convert.ToNumber(seconds));
			double ms2 = ((ms is Missing) ? 0.0 : Convert.ToNumber(ms));
			int num2 = (int)Runtime.DoubleToInt64(num);
			if (!double.IsNaN(num) && 0 <= num2 && num2 <= 99)
			{
				num = num2 + 1900;
			}
			double day = DatePrototype.MakeDay(num, month2, date2);
			double time = DatePrototype.MakeTime(hour, min, sec, ms2);
			return DatePrototype.TimeClip(DatePrototype.MakeDate(day, time));
		}
	}
	/// <summary>Represents a date object. This class belongs to the built-in object model category.</summary>
	public class DateObject : JSObject
	{
		internal double value;

		internal DateObject(ScriptObject parent, double value)
			: base(parent)
		{
			this.value = ((value != value || value > 9.2233720368547758E+18 || value < -9.2233720368547758E+18) ? double.NaN : Math.Round(value));
			noExpando = false;
		}

		internal override string GetClassName()
		{
			return "Date";
		}

		internal override object GetDefaultValue(PreferredType preferred_type)
		{
			if (GetParent() is LenientDatePrototype)
			{
				return base.GetDefaultValue(preferred_type);
			}
			switch (preferred_type)
			{
			case PreferredType.Either:
			case PreferredType.String:
				if (!noExpando)
				{
					object obj2 = base.NameTable["toString"];
					if (obj2 != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return DatePrototype.toString(this);
			case PreferredType.LocaleString:
				if (!noExpando)
				{
					object obj3 = base.NameTable["toLocaleString"];
					if (obj3 != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return DatePrototype.toLocaleString(this);
			default:
				if (!noExpando)
				{
					object obj = base.NameTable["valueOf"];
					if (obj == null && preferred_type == PreferredType.Either)
					{
						obj = base.NameTable["toString"];
					}
					if (obj != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return value;
			}
		}
	}
	internal enum Ps
	{
		Initial,
		Minutes,
		Seconds,
		AddOffset,
		SubOffset,
		Date,
		Year
	}
	internal enum Tk
	{
		Dummy,
		BcAd,
		AmPm,
		Zone,
		Day,
		Month
	}
	/// <summary>Provides static methods and properties for <see cref="T:Microsoft.JScript.DateObject" /> objects. All methods of this class are called by passing in a reference to the object that is requesting access to the method. This class belongs to the built-in object model category.</summary>
	public class DatePrototype : DateObject
	{
		internal static readonly DatePrototype ob;

		internal static DateConstructor _constructor;

		private const double HoursPerDay = 24.0;

		private const double MinutesPerHour = 60.0;

		private const double SecondsPerMinute = 60.0;

		private const double msPerSecond = 1000.0;

		private const double msPerMinute = 60000.0;

		private const double msPerHour = 3600000.0;

		private const double msPerDay = 86400000.0;

		internal const double msTo1970 = 62135596800000.0;

		internal const double ticksPerMillisecond = 10000.0;

		internal const double maxDate = 8.64E+15;

		internal const double minDate = -8.64E+15;

		private static readonly int[] daysToMonthEnd;

		private static readonly int[] leapDaysToMonthEnd;

		private static readonly double localStandardTZA;

		private static readonly double localDaylightTZA;

		private static readonly bool useDST;

		private static readonly string[] WeekDayName;

		private static readonly string[] MonthName;

		private static readonly string[] Strings;

		private static readonly Tk[] Tokens;

		private static readonly int[] Values;

		/// <summary>Gets a reference to a prototype-based object that is using this prototype.</summary>
		/// <returns>A reference to a prototype-based object.</returns>
		public static DateConstructor constructor => _constructor;

		internal DatePrototype(ObjectPrototype parent)
			: base(parent, 0.0)
		{
			noExpando = true;
		}

		private static double Day(double time)
		{
			return Math.Floor(time / 86400000.0);
		}

		private static double TimeWithinDay(double time)
		{
			double num = time % 86400000.0;
			if (num < 0.0)
			{
				num += 86400000.0;
			}
			return num;
		}

		private static int DaysInYear(double year)
		{
			if (year % 4.0 != 0.0)
			{
				return 365;
			}
			if (year % 100.0 != 0.0)
			{
				return 366;
			}
			if (year % 400.0 != 0.0)
			{
				return 365;
			}
			return 366;
		}

		private static double DayFromYear(double year)
		{
			return 365.0 * (year - 1970.0) + Math.Floor((year - 1969.0) / 4.0) - Math.Floor((year - 1901.0) / 100.0) + Math.Floor((year - 1601.0) / 400.0);
		}

		private static double TimeFromYear(double year)
		{
			return 86400000.0 * DayFromYear(year);
		}

		private static double YearFromTime(double time)
		{
			double num = Math.Floor(time / 86400000.0);
			double num2 = 1970.0 + Math.Floor((400.0 * num + 398.0) / 146097.0);
			double num3 = DayFromYear(num2);
			if (num < num3)
			{
				num2 -= 1.0;
			}
			return num2;
		}

		private static bool InLeapYear(double year)
		{
			if (year % 4.0 != 0.0)
			{
				return false;
			}
			if (year % 100.0 != 0.0)
			{
				return true;
			}
			if (year % 400.0 != 0.0)
			{
				return false;
			}
			return true;
		}

		private static int MonthFromTime(double time)
		{
			int i = 0;
			int num = DayWithinYear(time) + 1;
			if (InLeapYear(YearFromTime(time)))
			{
				for (; num > leapDaysToMonthEnd[i]; i++)
				{
				}
			}
			else
			{
				for (; num > daysToMonthEnd[i]; i++)
				{
				}
			}
			return i;
		}

		private static int DayWithinYear(double time)
		{
			return (int)(Day(time) - DayFromYear(YearFromTime(time)));
		}

		private static int DateFromTime(double time)
		{
			int i = 0;
			int num = DayWithinYear(time) + 1;
			if (num <= 31)
			{
				return num;
			}
			if (InLeapYear(YearFromTime(time)))
			{
				for (; num > leapDaysToMonthEnd[i]; i++)
				{
				}
				return num - leapDaysToMonthEnd[i - 1];
			}
			for (; num > daysToMonthEnd[i]; i++)
			{
			}
			return num - daysToMonthEnd[i - 1];
		}

		private static int WeekDay(double time)
		{
			double num = (Day(time) + 4.0) % 7.0;
			if (num < 0.0)
			{
				num += 7.0;
			}
			return (int)num;
		}

		private static bool DaylightSavingsTime(double localTime)
		{
			if (!useDST)
			{
				return false;
			}
			double num = (localTime + 62135596800000.0) * 10000.0;
			if (-9.2233720368547758E+18 <= num && num <= 9.2233720368547758E+18)
			{
				try
				{
					DateTime time = new DateTime((long)num);
					return TimeZone.CurrentTimeZone.IsDaylightSavingTime(time);
				}
				catch (ArgumentOutOfRangeException)
				{
				}
			}
			int num2 = MonthFromTime(localTime);
			switch (num2)
			{
			default:
				return false;
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
				return true;
			case 3:
			case 9:
			{
				int num3 = DateFromTime(localTime);
				if (num2 == 3)
				{
					if (num3 > 7)
					{
						return true;
					}
					int num4 = WeekDay(localTime);
					if (num4 > 0)
					{
						return num3 > num4;
					}
					return HourFromTime(localTime) > 1;
				}
				if (num3 < 25)
				{
					return true;
				}
				int num5 = WeekDay(localTime);
				if (num5 > 0)
				{
					return num3 - num5 < 25;
				}
				return HourFromTime(localTime) < 1;
			}
			}
		}

		static DatePrototype()
		{
			ob = new DatePrototype(ObjectPrototype.ob);
			daysToMonthEnd = new int[12]
			{
				31, 59, 90, 120, 151, 181, 212, 243, 273, 304,
				334, 365
			};
			leapDaysToMonthEnd = new int[12]
			{
				31, 60, 91, 121, 152, 182, 213, 244, 274, 305,
				335, 366
			};
			WeekDayName = new string[7] { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
			MonthName = new string[12]
			{
				"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct",
				"Nov", "Dec"
			};
			Strings = new string[37]
			{
				"bc", "b.c", "ad", "a.d", "am", "a.m", "pm", "p.m", "est", "edt",
				"cst", "cdt", "mst", "mdt", "pst", "pdt", "gmt", "utc", "sunday", "monday",
				"tuesday", "wednesday", "thursday", "friday", "saturday", "january", "february", "march", "april", "may",
				"june", "july", "august", "september", "october", "november", "december"
			};
			Tokens = new Tk[37]
			{
				Tk.BcAd,
				Tk.BcAd,
				Tk.BcAd,
				Tk.BcAd,
				Tk.AmPm,
				Tk.AmPm,
				Tk.AmPm,
				Tk.AmPm,
				Tk.Zone,
				Tk.Zone,
				Tk.Zone,
				Tk.Zone,
				Tk.Zone,
				Tk.Zone,
				Tk.Zone,
				Tk.Zone,
				Tk.Zone,
				Tk.Zone,
				Tk.Day,
				Tk.Day,
				Tk.Day,
				Tk.Day,
				Tk.Day,
				Tk.Day,
				Tk.Day,
				Tk.Month,
				Tk.Month,
				Tk.Month,
				Tk.Month,
				Tk.Month,
				Tk.Month,
				Tk.Month,
				Tk.Month,
				Tk.Month,
				Tk.Month,
				Tk.Month,
				Tk.Month
			};
			Values = new int[37]
			{
				-1, -1, 1, 1, -1, -1, 1, 1, -300, -240,
				-360, -300, -420, -360, -480, -420, 0, 0, 0, 1,
				2, 3, 4, 5, 6, 0, 1, 2, 3, 4,
				5, 6, 7, 8, 9, 10, 11
			};
			DateTime dateTime = new DateTime(DateTime.Now.Year, 1, 1);
			double num = (double)(dateTime.Ticks - dateTime.ToUniversalTime().Ticks) / 10000.0;
			DateTime dateTime2 = new DateTime(DateTime.Now.Year, 7, 1);
			double num2 = (double)(dateTime2.Ticks - dateTime2.ToUniversalTime().Ticks) / 10000.0;
			if (num < num2)
			{
				localStandardTZA = num;
				localDaylightTZA = num2;
			}
			else
			{
				localStandardTZA = num2;
				localDaylightTZA = num;
			}
			useDST = localStandardTZA != localDaylightTZA;
		}

		private static double LocalTime(double utcTime)
		{
			return utcTime + (DaylightSavingsTime(utcTime + localStandardTZA) ? localDaylightTZA : localStandardTZA);
		}

		internal static double UTC(double localTime)
		{
			return localTime - (DaylightSavingsTime(localTime) ? localDaylightTZA : localStandardTZA);
		}

		private static int HourFromTime(double time)
		{
			double num = Math.Floor(time / 3600000.0) % 24.0;
			if (num < 0.0)
			{
				num += 24.0;
			}
			return (int)num;
		}

		private static int MinFromTime(double time)
		{
			double num = Math.Floor(time / 60000.0) % 60.0;
			if (num < 0.0)
			{
				num += 60.0;
			}
			return (int)num;
		}

		private static int SecFromTime(double time)
		{
			double num = Math.Floor(time / 1000.0) % 60.0;
			if (num < 0.0)
			{
				num += 60.0;
			}
			return (int)num;
		}

		private static int msFromTime(double time)
		{
			double num = time % 1000.0;
			if (num < 0.0)
			{
				num += 1000.0;
			}
			return (int)num;
		}

		internal static double MakeTime(double hour, double min, double sec, double ms)
		{
			if (double.IsInfinity(hour) || double.IsInfinity(min) || double.IsInfinity(sec) || double.IsInfinity(ms) || hour != hour || min != min || sec != sec || ms != ms)
			{
				return double.NaN;
			}
			hour = (int)Runtime.DoubleToInt64(hour);
			min = (int)Runtime.DoubleToInt64(min);
			sec = (int)Runtime.DoubleToInt64(sec);
			ms = (int)Runtime.DoubleToInt64(ms);
			return hour * 3600000.0 + min * 60000.0 + sec * 1000.0 + ms;
		}

		internal static double MakeDay(double year, double month, double date)
		{
			if (double.IsInfinity(year) || double.IsInfinity(month) || double.IsInfinity(date) || year != year || month != month || date != date)
			{
				return double.NaN;
			}
			year = (int)Runtime.DoubleToInt64(year);
			month = (int)Runtime.DoubleToInt64(month);
			date = (int)Runtime.DoubleToInt64(date);
			year += Math.Floor(month / 12.0);
			month %= 12.0;
			if (month < 0.0)
			{
				month += 12.0;
			}
			double num = 0.0;
			if (month > 0.0)
			{
				num = ((!InLeapYear((int)Runtime.DoubleToInt64(year))) ? ((double)daysToMonthEnd[(int)(month - 1.0)]) : ((double)leapDaysToMonthEnd[(int)(month - 1.0)]));
			}
			return DayFromYear(year) - 1.0 + num + date;
		}

		internal static double MakeDate(double day, double time)
		{
			if (double.IsInfinity(day) || double.IsInfinity(time))
			{
				return double.NaN;
			}
			return day * 86400000.0 + time;
		}

		internal static double TimeClip(double time)
		{
			if (double.IsInfinity(time))
			{
				return double.NaN;
			}
			if (-8.64E+15 <= time && time <= 8.64E+15)
			{
				return (long)time;
			}
			return double.NaN;
		}

		internal static string DateToLocaleDateString(double time)
		{
			if (double.IsNaN(time))
			{
				return "NaN";
			}
			StringBuilder stringBuilder = new StringBuilder();
			int num = MonthFromTime(time) + 1;
			if (num < 10)
			{
				stringBuilder.Append("0");
			}
			stringBuilder.Append(num);
			stringBuilder.Append("/");
			int num2 = DateFromTime(time);
			if (num2 < 10)
			{
				stringBuilder.Append("0");
			}
			stringBuilder.Append(num2);
			stringBuilder.Append("/");
			stringBuilder.Append(YearString(time));
			return stringBuilder.ToString();
		}

		internal static string DateToLocaleString(double time)
		{
			if (double.IsNaN(time))
			{
				return "NaN";
			}
			StringBuilder stringBuilder = new StringBuilder();
			int num = MonthFromTime(time) + 1;
			if (num < 10)
			{
				stringBuilder.Append("0");
			}
			stringBuilder.Append(num);
			stringBuilder.Append("/");
			int num2 = DateFromTime(time);
			if (num2 < 10)
			{
				stringBuilder.Append("0");
			}
			stringBuilder.Append(num2);
			stringBuilder.Append("/");
			stringBuilder.Append(YearString(time));
			stringBuilder.Append(" ");
			AppendTime(time, stringBuilder);
			return stringBuilder.ToString();
		}

		internal static string DateToLocaleTimeString(double time)
		{
			if (double.IsNaN(time))
			{
				return "NaN";
			}
			StringBuilder stringBuilder = new StringBuilder();
			AppendTime(time, stringBuilder);
			return stringBuilder.ToString();
		}

		private static void AppendTime(double time, StringBuilder sb)
		{
			int num = HourFromTime(time);
			if (num < 10)
			{
				sb.Append("0");
			}
			sb.Append(num);
			sb.Append(":");
			int num2 = MinFromTime(time);
			if (num2 < 10)
			{
				sb.Append("0");
			}
			sb.Append(num2);
			sb.Append(":");
			int num3 = SecFromTime(time);
			if (num3 < 10)
			{
				sb.Append("0");
			}
			sb.Append(num3);
		}

		private static string TimeZoneID(double utcTime)
		{
			int num = (int)(localStandardTZA / 3600000.0);
			if (DaylightSavingsTime(utcTime + localStandardTZA))
			{
				switch (num)
				{
				case -5:
					return "EDT";
				case -6:
					return "CDT";
				case -7:
					return "MDT";
				case -8:
					return "PDT";
				}
			}
			else
			{
				switch (num)
				{
				case -5:
					return "EST";
				case -6:
					return "CST";
				case -7:
					return "MST";
				case -8:
					return "PST";
				}
			}
			return ((num >= 0) ? "UTC+" : "UTC") + num.ToString(CultureInfo.InvariantCulture);
		}

		private static string YearString(double time)
		{
			double num = YearFromTime(time);
			if (num > 0.0)
			{
				return num.ToString(CultureInfo.InvariantCulture);
			}
			return (1.0 - num).ToString(CultureInfo.InvariantCulture) + " B.C.";
		}

		internal static string DateToDateString(double utcTime)
		{
			if (double.IsNaN(utcTime))
			{
				return "NaN";
			}
			StringBuilder stringBuilder = new StringBuilder();
			double time = LocalTime(utcTime);
			stringBuilder.Append(WeekDayName[WeekDay(time)]);
			stringBuilder.Append(" ");
			int num = MonthFromTime(time);
			stringBuilder.Append(MonthName[num]);
			stringBuilder.Append(" ");
			stringBuilder.Append(DateFromTime(time));
			stringBuilder.Append(" ");
			stringBuilder.Append(YearString(time));
			return stringBuilder.ToString();
		}

		internal static string DateToString(double utcTime)
		{
			if (double.IsNaN(utcTime))
			{
				return "NaN";
			}
			StringBuilder stringBuilder = new StringBuilder();
			double time = LocalTime(utcTime);
			stringBuilder.Append(WeekDayName[WeekDay(time)]);
			stringBuilder.Append(" ");
			int num = MonthFromTime(time);
			stringBuilder.Append(MonthName[num]);
			stringBuilder.Append(" ");
			stringBuilder.Append(DateFromTime(time));
			stringBuilder.Append(" ");
			AppendTime(time, stringBuilder);
			stringBuilder.Append(" ");
			stringBuilder.Append(TimeZoneID(utcTime));
			stringBuilder.Append(" ");
			stringBuilder.Append(YearString(time));
			return stringBuilder.ToString();
		}

		internal static string DateToTimeString(double utcTime)
		{
			if (double.IsNaN(utcTime))
			{
				return "NaN";
			}
			StringBuilder stringBuilder = new StringBuilder();
			double time = LocalTime(utcTime);
			AppendTime(time, stringBuilder);
			stringBuilder.Append(" ");
			stringBuilder.Append(TimeZoneID(utcTime));
			return stringBuilder.ToString();
		}

		internal static string UTCDateToString(double utcTime)
		{
			if (double.IsNaN(utcTime))
			{
				return "NaN";
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(WeekDayName[WeekDay(utcTime)]);
			stringBuilder.Append(", ");
			stringBuilder.Append(DateFromTime(utcTime));
			stringBuilder.Append(" ");
			stringBuilder.Append(MonthName[MonthFromTime(utcTime)]);
			stringBuilder.Append(" ");
			stringBuilder.Append(YearString(utcTime));
			stringBuilder.Append(" ");
			AppendTime(utcTime, stringBuilder);
			stringBuilder.Append(" UTC");
			return stringBuilder.ToString();
		}

		private static bool NotSpecified(object value)
		{
			if (value != null)
			{
				return value is Missing;
			}
			return true;
		}

		private static bool isASCII(char ch)
		{
			return ch < '\u0080';
		}

		private static bool isalpha(char ch)
		{
			if ('A' > ch || ch > 'Z')
			{
				if ('a' <= ch)
				{
					return ch <= 'z';
				}
				return false;
			}
			return true;
		}

		private static bool isdigit(char ch)
		{
			if ('0' <= ch)
			{
				return ch <= '9';
			}
			return false;
		}

		internal static double ParseDate(string str)
		{
			long num = 2147483648L;
			int num2 = 0;
			int num3 = 0;
			Ps ps = Ps.Initial;
			long num4 = num;
			long num5 = num;
			long num6 = num;
			long num7 = num;
			long num8 = num;
			long num9 = num;
			str = str.ToLowerInvariant();
			int num10 = 0;
			int length = str.Length;
			while (num10 < length)
			{
				char c = str[num10++];
				if (c <= ' ')
				{
					continue;
				}
				switch (c)
				{
				case '(':
				{
					int num11 = 1;
					while (num10 < length)
					{
						switch (str[num10++])
						{
						case '(':
							num11++;
							continue;
						case ')':
							break;
						default:
							continue;
						}
						if (--num11 <= 0)
						{
							break;
						}
					}
					continue;
				}
				case '+':
					if (num != num4)
					{
						ps = Ps.AddOffset;
					}
					continue;
				case '-':
					if (num != num4)
					{
						ps = Ps.SubOffset;
					}
					continue;
				case ',':
				case '/':
				case ':':
					continue;
				}
				if (isalpha(c))
				{
					int num12 = num10 - 1;
					while (num10 < length)
					{
						c = str[num10++];
						if (!isalpha(c) && '.' != c)
						{
							break;
						}
					}
					int num13 = num10 - num12 - ((num10 < length) ? 1 : 0);
					if ('.' == str[num10 - ((num10 >= length) ? 1 : 2)])
					{
						num13--;
					}
					while (c == ' ' && num10 < length)
					{
						c = str[num10++];
					}
					if (1 == num13)
					{
						if (num != num8)
						{
							return double.NaN;
						}
						char c2 = str[num12];
						if (c2 <= 'm')
						{
							if (c2 == 'j' || c2 < 'a')
							{
								return double.NaN;
							}
							num8 = -(c2 - 97 + ((c2 < 'j') ? 1 : 0)) * 60;
						}
						else if (c2 <= 'y')
						{
							num8 = (long)(c2 - 109) * 60L;
						}
						else
						{
							if (c2 != 'z')
							{
								return double.NaN;
							}
							num8 = 0L;
						}
						ps = (('+' != c) ? (('-' == c) ? Ps.SubOffset : Ps.Initial) : Ps.AddOffset);
						continue;
					}
					for (int num14 = Strings.Length - 1; num14 >= 0; num14--)
					{
						string text = Strings[num14];
						if (text.Length >= num13)
						{
							if (string.CompareOrdinal(str, num12, text, 0, num13) == 0)
							{
								switch (Tokens[num14])
								{
								case Tk.BcAd:
									if (num3 != 0)
									{
										return double.NaN;
									}
									num3 = Values[num14];
									break;
								case Tk.AmPm:
									if (num2 != 0)
									{
										return double.NaN;
									}
									num2 = Values[num14];
									break;
								case Tk.Month:
									if (num != num5)
									{
										return double.NaN;
									}
									num5 = Values[num14];
									break;
								case Tk.Zone:
									if (num != num8)
									{
										return double.NaN;
									}
									num8 = Values[num14];
									if ('+' == c)
									{
										ps = Ps.AddOffset;
										num10++;
									}
									else if ('-' == c)
									{
										ps = Ps.SubOffset;
										num10++;
									}
									else
									{
										ps = Ps.Initial;
									}
									break;
								}
								break;
							}
							if (num14 == 0)
							{
								return double.NaN;
							}
						}
					}
					if (num10 < length)
					{
						num10--;
					}
					continue;
				}
				if (!isdigit(c))
				{
					return double.NaN;
				}
				int num15 = 0;
				int num16 = num10;
				do
				{
					num15 = num15 * 10 + c - 48;
					if (num10 >= length)
					{
						break;
					}
					c = str[num10++];
				}
				while (isdigit(c));
				if (num10 - num16 > 6)
				{
					return double.NaN;
				}
				while (c == ' ' && num10 < length)
				{
					c = str[num10++];
				}
				switch (ps)
				{
				case Ps.AddOffset:
					if (num != num9)
					{
						return double.NaN;
					}
					num9 = ((num15 < 24) ? (num15 * 60) : (num15 % 100 + num15 / 100 * 60));
					ps = Ps.Initial;
					if (num10 < length)
					{
						num10--;
					}
					continue;
				case Ps.SubOffset:
					if (num != num9)
					{
						return double.NaN;
					}
					num9 = ((num15 < 24) ? (-num15 * 60) : (-(num15 % 100 + num15 / 100 * 60)));
					ps = Ps.Initial;
					if (num10 < length)
					{
						num10--;
					}
					continue;
				case Ps.Minutes:
					if (num15 >= 60)
					{
						return double.NaN;
					}
					num7 += num15 * 60;
					if (c == ':')
					{
						ps = Ps.Seconds;
						continue;
					}
					ps = Ps.Initial;
					if (num10 < length)
					{
						num10--;
					}
					continue;
				case Ps.Seconds:
					if (num15 >= 60)
					{
						return double.NaN;
					}
					num7 += num15;
					ps = Ps.Initial;
					if (num10 < length)
					{
						num10--;
					}
					continue;
				case Ps.Date:
					if (num != num6)
					{
						return double.NaN;
					}
					num6 = num15;
					if ('/' == c || '-' == c)
					{
						ps = Ps.Year;
						continue;
					}
					ps = Ps.Initial;
					if (num10 < length)
					{
						num10--;
					}
					continue;
				case Ps.Year:
					if (num != num4)
					{
						return double.NaN;
					}
					num4 = num15;
					ps = Ps.Initial;
					if (num10 < length)
					{
						num10--;
					}
					continue;
				}
				if (num15 >= 70)
				{
					if (num != num4)
					{
						return double.NaN;
					}
					num4 = num15;
					if (num10 < length)
					{
						num10--;
					}
					continue;
				}
				switch (c)
				{
				case ':':
					if (num != num7)
					{
						return double.NaN;
					}
					if (num15 >= 24)
					{
						return double.NaN;
					}
					num7 = num15 * 3600;
					ps = Ps.Minutes;
					break;
				case '-':
				case '/':
					if (num != num5)
					{
						return double.NaN;
					}
					num5 = num15 - 1;
					ps = Ps.Date;
					break;
				default:
					if (num != num6)
					{
						return double.NaN;
					}
					num6 = num15;
					if (num10 < length)
					{
						num10--;
					}
					break;
				}
			}
			if (num == num4 || num == num5 || num == num6)
			{
				return double.NaN;
			}
			if (num3 != 0)
			{
				if (num3 < 0)
				{
					num4 = -num4 + 1;
				}
			}
			else if (num4 < 100)
			{
				num4 += 1900;
			}
			if (num2 != 0)
			{
				if (num == num7)
				{
					return double.NaN;
				}
				if (num7 >= 43200 && num7 < 46800)
				{
					if (num2 < 0)
					{
						num7 -= 43200;
					}
				}
				else if (num2 > 0)
				{
					if (num7 >= 43200)
					{
						return double.NaN;
					}
					num7 += 43200;
				}
			}
			else if (num == num7)
			{
				num7 = 0L;
			}
			bool flag = false;
			if (num != num8)
			{
				num7 -= num8 * 60;
				flag = true;
			}
			if (num != num9)
			{
				num7 -= num9 * 60;
			}
			double num17 = MakeDate(MakeDay(num4, num5, num6), num7 * 1000);
			if (!flag)
			{
				num17 = UTC(num17);
			}
			return num17;
		}

		/// <summary>Gets the date value of the specified <see cref="T:Microsoft.JScript.DateObject" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The date value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getDate)]
		public static double getDate(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return DateFromTime(LocalTime(num));
		}

		/// <summary>Gets the day-of-the-week value of the specified <see cref="T:Microsoft.JScript.DateObject" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The day-of-the-week value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getDay)]
		public static double getDay(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return WeekDay(LocalTime(num));
		}

		/// <summary>Gets the year value of the specified <see cref="T:Microsoft.JScript.DateObject" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The year value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getFullYear)]
		public static double getFullYear(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return YearFromTime(LocalTime(num));
		}

		/// <summary>Gets the hour value of the specified <see cref="T:Microsoft.JScript.DateObject" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The hour value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getHours)]
		public static double getHours(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return HourFromTime(LocalTime(num));
		}

		/// <summary>Gets the millisecond value of the specified <see cref="T:Microsoft.JScript.DateObject" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The millisecond value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getMilliseconds)]
		public static double getMilliseconds(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return msFromTime(LocalTime(num));
		}

		/// <summary>Gets the minutes value of the specified <see cref="T:Microsoft.JScript.DateObject" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The minutes value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getMinutes)]
		public static double getMinutes(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return MinFromTime(LocalTime(num));
		}

		/// <summary>Gets the month value of the specified <see cref="T:Microsoft.JScript.DateObject" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The month value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getMonth)]
		public static double getMonth(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return MonthFromTime(LocalTime(num));
		}

		/// <summary>Gets the seconds value of the specified <see cref="T:Microsoft.JScript.DateObject" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The seconds value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getSeconds)]
		public static double getSeconds(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return SecFromTime(LocalTime(num));
		}

		/// <summary>Gets the time value of the specified <see cref="T:Microsoft.JScript.DateObject" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The time value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getTime)]
		public static double getTime(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			return ((DateObject)thisob).value;
		}

		/// <summary>Gets the offset of the specified <see cref="T:Microsoft.JScript.DateObject" /> from Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The difference between <paramref name="thisob" /> and Coordinated Universal Time (UTC).</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getTimezoneOffset)]
		public static double getTimezoneOffset(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return (num - LocalTime(num)) / 60000.0;
		}

		/// <summary>Gets the date value of the specified <see cref="T:Microsoft.JScript.DateObject" />, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The date value of <paramref name="thisob" />, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getUTCDate)]
		public static double getUTCDate(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return DateFromTime(num);
		}

		/// <summary>Gets the day-of-the-week value of the specified <see cref="T:Microsoft.JScript.DateObject" />, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The day-of-the-week value of <paramref name="thisob" />, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getUTCDay)]
		public static double getUTCDay(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return WeekDay(num);
		}

		/// <summary>Gets the year value of the specified <see cref="T:Microsoft.JScript.DateObject" />, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The year value of <paramref name="thisob" />, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getUTCFullYear)]
		public static double getUTCFullYear(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return YearFromTime(num);
		}

		/// <summary>Gets the hour value of the specified <see cref="T:Microsoft.JScript.DateObject" />, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The hour value of <paramref name="thisob" />, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getUTCHours)]
		public static double getUTCHours(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return HourFromTime(num);
		}

		/// <summary>Gets the millisecond value of the specified <see cref="T:Microsoft.JScript.DateObject" />, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The millisecond value of <paramref name="thisob" />, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getUTCMilliseconds)]
		public static double getUTCMilliseconds(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return msFromTime(num);
		}

		/// <summary>Gets the minutes value of the specified <see cref="T:Microsoft.JScript.DateObject" />, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The minutes value of <paramref name="thisob" />, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getUTCMinutes)]
		public static double getUTCMinutes(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return MinFromTime(num);
		}

		/// <summary>Gets the month value of the specified <see cref="T:Microsoft.JScript.DateObject" />, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The month value of <paramref name="thisob" />, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getUTCMonth)]
		public static double getUTCMonth(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return MonthFromTime(num);
		}

		/// <summary>Gets the seconds value of the specified <see cref="T:Microsoft.JScript.DateObject" />, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The seconds value of <paramref name="thisob" />, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getUTCSeconds)]
		public static double getUTCSeconds(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			return SecFromTime(num);
		}

		/// <summary>Returns the specified <see cref="T:Microsoft.JScript.DateObject" /> as a <see cref="T:System.DateTime" /> object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The value of <paramref name="thisob" />, expressed as a <see cref="T:System.DateTime" /> object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getVarDate)]
		public static object getVarDate(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return null;
			}
			long num2;
			try
			{
				num2 = checked((long)(LocalTime(num) + 62135596800000.0) * 10000);
			}
			catch (OverflowException)
			{
				return null;
			}
			if (num2 < DateTime.MinValue.Ticks || num2 > DateTime.MaxValue.Ticks)
			{
				return null;
			}
			DateTime dateTime;
			try
			{
				dateTime = new DateTime(num2);
			}
			catch (ArgumentOutOfRangeException)
			{
				return null;
			}
			return dateTime;
		}

		/// <summary>Gets the year value of the specified <see cref="T:Microsoft.JScript.DateObject" />, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The year value of <paramref name="thisob" />, expressed in UTC.</returns>
		[NotRecommended("getYear")]
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_getYear)]
		public static double getYear(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double num = ((DateObject)thisob).value;
			if (num != num)
			{
				return num;
			}
			double num2 = YearFromTime(LocalTime(num));
			if (1900.0 <= num2 && num2 <= 1999.0)
			{
				return num2 - 1900.0;
			}
			return num2;
		}

		/// <summary>Sets the date value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified date value.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="ddate">The date value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setDate)]
		public static double setDate(object thisob, double ddate)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = LocalTime(((DateObject)thisob).value);
			double day = MakeDay(YearFromTime(time), MonthFromTime(time), ddate);
			time = TimeClip(UTC(MakeDate(day, TimeWithinDay(time))));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the year value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified year value.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dyear">The year value to set for <paramref name="thisob" />.</param>
		/// <param name="month">The month value to set for <paramref name="thisob" />.</param>
		/// <param name="date">The date value to set for <paramref name="thisob" />.</param>
		/// <returns>The year value that is set for <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setFullYear)]
		public static double setFullYear(object thisob, double dyear, object month, object date)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = LocalTime(((DateObject)thisob).value);
			double month2 = (NotSpecified(month) ? ((double)MonthFromTime(time)) : Convert.ToNumber(month));
			double date2 = (NotSpecified(date) ? ((double)DateFromTime(time)) : Convert.ToNumber(date));
			double day = MakeDay(dyear, month2, date2);
			time = TimeClip(UTC(MakeDate(day, TimeWithinDay(time))));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the hour value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified hour value.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dhour">The hour value to set for <paramref name="thisob" />.</param>
		/// <param name="min">The minutes value to set for <paramref name="thisob" />.</param>
		/// <param name="sec">The seconds value to set for <paramref name="thisob" />.</param>
		/// <param name="msec">The milliseconds value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setHours)]
		public static double setHours(object thisob, double dhour, object min, object sec, object msec)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = LocalTime(((DateObject)thisob).value);
			double min2 = (NotSpecified(min) ? ((double)MinFromTime(time)) : Convert.ToNumber(min));
			double sec2 = (NotSpecified(sec) ? ((double)SecFromTime(time)) : Convert.ToNumber(sec));
			double ms = (NotSpecified(msec) ? ((double)msFromTime(time)) : Convert.ToNumber(msec));
			time = TimeClip(UTC(MakeDate(Day(time), MakeTime(dhour, min2, sec2, ms))));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the minutes value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified minutes value.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dmin">The minutes value to set for <paramref name="thisob" />.</param>
		/// <param name="sec">The seconds value to set for <paramref name="thisob" />.</param>
		/// <param name="msec">The milliseconds value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setMinutes)]
		public static double setMinutes(object thisob, double dmin, object sec, object msec)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = LocalTime(((DateObject)thisob).value);
			double sec2 = (NotSpecified(sec) ? ((double)SecFromTime(time)) : Convert.ToNumber(sec));
			double ms = (NotSpecified(msec) ? ((double)msFromTime(time)) : Convert.ToNumber(msec));
			time = TimeClip(UTC(MakeDate(Day(time), MakeTime(HourFromTime(time), dmin, sec2, ms))));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the millisecond value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified millisecond value.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dmsec">The millisecond value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setMilliseconds)]
		public static double setMilliseconds(object thisob, double dmsec)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = LocalTime(((DateObject)thisob).value);
			time = TimeClip(UTC(MakeDate(Day(time), MakeTime(HourFromTime(time), MinFromTime(time), SecFromTime(time), dmsec))));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the month value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified month value.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dmonth">The month value to set for <paramref name="thisob" />.</param>
		/// <param name="date">The date value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setMonth)]
		public static double setMonth(object thisob, double dmonth, object date)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = LocalTime(((DateObject)thisob).value);
			double date2 = (NotSpecified(date) ? ((double)DateFromTime(time)) : Convert.ToNumber(date));
			double day = MakeDay(YearFromTime(time), dmonth, date2);
			time = TimeClip(UTC(MakeDate(day, TimeWithinDay(time))));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the seconds value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified seconds value.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dsec">The seconds value to set for <paramref name="thisob" />.</param>
		/// <param name="msec">The milliseconds value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setSeconds)]
		public static double setSeconds(object thisob, double dsec, object msec)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = LocalTime(((DateObject)thisob).value);
			double ms = (NotSpecified(msec) ? ((double)msFromTime(time)) : Convert.ToNumber(msec));
			time = TimeClip(UTC(MakeDate(Day(time), MakeTime(HourFromTime(time), MinFromTime(time), dsec, ms))));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the time value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified time value.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="time">The time value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setTime)]
		public static double setTime(object thisob, double time)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			time = TimeClip(time);
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the date value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified date value, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="ddate">The date value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setUTCDate)]
		public static double setUTCDate(object thisob, double ddate)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = ((DateObject)thisob).value;
			double day = MakeDay(YearFromTime(time), MonthFromTime(time), ddate);
			time = TimeClip(MakeDate(day, TimeWithinDay(time)));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the year value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified year value, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dyear">The year value to set for <paramref name="thisob" />.</param>
		/// <param name="month">The month value to set for <paramref name="thisob" />.</param>
		/// <param name="date">The date value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setUTCFullYear)]
		public static double setUTCFullYear(object thisob, double dyear, object month, object date)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = ((DateObject)thisob).value;
			double month2 = (NotSpecified(month) ? ((double)MonthFromTime(time)) : Convert.ToNumber(month));
			double date2 = (NotSpecified(date) ? ((double)DateFromTime(time)) : Convert.ToNumber(date));
			double day = MakeDay(dyear, month2, date2);
			time = TimeClip(MakeDate(day, TimeWithinDay(time)));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the hour value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified hour value, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dhour">The hour value to set for <paramref name="thisob" />.</param>
		/// <param name="min">The minutes value to set for <paramref name="thisob" />.</param>
		/// <param name="sec">The seconds value to set for <paramref name="thisob" />.</param>
		/// <param name="msec">The milliseconds value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setUTCHours)]
		public static double setUTCHours(object thisob, double dhour, object min, object sec, object msec)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = ((DateObject)thisob).value;
			double min2 = (NotSpecified(min) ? ((double)MinFromTime(time)) : Convert.ToNumber(min));
			double sec2 = (NotSpecified(sec) ? ((double)SecFromTime(time)) : Convert.ToNumber(sec));
			double ms = (NotSpecified(msec) ? ((double)msFromTime(time)) : Convert.ToNumber(msec));
			time = TimeClip(MakeDate(Day(time), MakeTime(dhour, min2, sec2, ms)));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the minutes value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified minutes value, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dmin">The minutes value to set for <paramref name="thisob" />.</param>
		/// <param name="sec">The seconds value to set for <paramref name="thisob" />.</param>
		/// <param name="msec">The milliseconds value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setUTCMinutes)]
		public static double setUTCMinutes(object thisob, double dmin, object sec, object msec)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = ((DateObject)thisob).value;
			double sec2 = (NotSpecified(sec) ? ((double)SecFromTime(time)) : Convert.ToNumber(sec));
			double ms = (NotSpecified(msec) ? ((double)msFromTime(time)) : Convert.ToNumber(msec));
			time = TimeClip(MakeDate(Day(time), MakeTime(HourFromTime(time), dmin, sec2, ms)));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the millisecond value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified millisecond value, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dmsec">The millisecond value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setUTCMilliseconds)]
		public static double setUTCMilliseconds(object thisob, double dmsec)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = ((DateObject)thisob).value;
			time = TimeClip(MakeDate(Day(time), MakeTime(HourFromTime(time), MinFromTime(time), SecFromTime(time), dmsec)));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the month value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified month value, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dmonth">The month value to set for <paramref name="thisob" />.</param>
		/// <param name="date">The date value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setUTCMonth)]
		public static double setUTCMonth(object thisob, double dmonth, object date)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = ((DateObject)thisob).value;
			double date2 = (NotSpecified(date) ? ((double)DateFromTime(time)) : Convert.ToNumber(date));
			double day = MakeDay(YearFromTime(time), dmonth, date2);
			time = TimeClip(MakeDate(day, TimeWithinDay(time)));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the seconds value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified seconds value, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dsec">The seconds value to set for <paramref name="thisob" />.</param>
		/// <param name="msec">The milliseconds value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set, expressed in UTC.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setUTCSeconds)]
		public static double setUTCSeconds(object thisob, double dsec, object msec)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = ((DateObject)thisob).value;
			double ms = (NotSpecified(msec) ? ((double)msFromTime(time)) : Convert.ToNumber(msec));
			time = TimeClip(MakeDate(Day(time), MakeTime(HourFromTime(time), MinFromTime(time), dsec, ms)));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Sets the year value of a <see cref="T:Microsoft.JScript.DateObject" /> to the specified year value.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dyear">The year value to set for <paramref name="thisob" />.</param>
		/// <returns>The new value of <paramref name="thisob" /> after the value is set.</returns>
		[NotRecommended("setYear")]
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_setYear)]
		public static double setYear(object thisob, double dyear)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double time = LocalTime(((DateObject)thisob).value);
			if (double.IsNaN(dyear))
			{
				((DateObject)thisob).value = dyear;
				return dyear;
			}
			dyear = Convert.ToInteger(dyear);
			if (0.0 <= dyear && dyear <= 99.0)
			{
				dyear += 1900.0;
			}
			double day = MakeDay(dyear, MonthFromTime(time), DateFromTime(time));
			time = TimeClip(UTC(MakeDate(day, TimeWithinDay(time))));
			((DateObject)thisob).value = time;
			return time;
		}

		/// <summary>Creates a string representation of the specified <see cref="T:Microsoft.JScript.DateObject" /> that contains the day of the week, the month, the date, and the year.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_toDateString)]
		public static string toDateString(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double utcTime = ((DateObject)thisob).value;
			return DateToDateString(utcTime);
		}

		/// <summary>Creates a string representation of the specified <see cref="T:Microsoft.JScript.DateObject" /> that contains the day of the week, the month, the date, the year, and the time, expressed in Coordinated Universal Time (UTC). Use <see cref="M:Microsoft.JScript.DatePrototype.toUTCString(System.Object)" /> instead, when you can.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[NotRecommended("toGMTString")]
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_toGMTString)]
		public static string toGMTString(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double utcTime = ((DateObject)thisob).value;
			return UTCDateToString(utcTime);
		}

		/// <summary>Creates a string representation of the specified <see cref="T:Microsoft.JScript.DateObject" /> that contains the date but not the time.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_toLocaleDateString)]
		public static string toLocaleDateString(object thisob)
		{
			object varDate = getVarDate(thisob);
			if (varDate != null)
			{
				return ((DateTime)varDate).ToLongDateString();
			}
			return DateToDateString(((DateObject)thisob).value);
		}

		/// <summary>Creates a string representation of the specified <see cref="T:Microsoft.JScript.DateObject" /> that contains the date and time.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_toLocaleString)]
		public static string toLocaleString(object thisob)
		{
			object varDate = getVarDate(thisob);
			if (varDate != null)
			{
				return ((DateTime)varDate).ToLongDateString() + " " + ((DateTime)varDate).ToLongTimeString();
			}
			return DateToString(((DateObject)thisob).value);
		}

		/// <summary>Creates a string representation of the specified <see cref="T:Microsoft.JScript.DateObject" /> that contains the time but not the date.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_toLocaleTimeString)]
		public static string toLocaleTimeString(object thisob)
		{
			object varDate = getVarDate(thisob);
			if (varDate != null)
			{
				return ((DateTime)varDate).ToLongTimeString();
			}
			return DateToTimeString(((DateObject)thisob).value);
		}

		/// <summary>Creates a string representation of the specified <see cref="T:Microsoft.JScript.DateObject" /> that contains the day of the week, the month, the date, the time, the time zone, and the year.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_toString)]
		public static string toString(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double utcTime = ((DateObject)thisob).value;
			return DateToString(utcTime);
		}

		/// <summary>Creates a string representation of the specified <see cref="T:Microsoft.JScript.DateObject" /> that contains the time and the time zone.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_toTimeString)]
		public static string toTimeString(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double utcTime = ((DateObject)thisob).value;
			return DateToTimeString(utcTime);
		}

		/// <summary>Creates a string representation of the specified <see cref="T:Microsoft.JScript.DateObject" /> that contains the day of the week, the month, the date, the year, and the time, expressed in Coordinated Universal Time (UTC).</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_toUTCString)]
		public static string toUTCString(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			double utcTime = ((DateObject)thisob).value;
			return UTCDateToString(utcTime);
		}

		/// <summary>Returns the value of the specified <see cref="T:Microsoft.JScript.DateObject" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Date_valueOf)]
		public static double valueOf(object thisob)
		{
			if (!(thisob is DateObject))
			{
				throw new JScriptException(JSError.DateExpected);
			}
			return ((DateObject)thisob).value;
		}
	}
	internal static class Debug
	{
		[Conditional("ASSERTION")]
		public static void Assert(bool condition)
		{
			if (!condition)
			{
				throw new AssertException("Assertion fired");
			}
		}

		[Conditional("ASSERTION")]
		public static void Assert(bool condition, string message)
		{
			if (!condition)
			{
				throw new AssertException(message);
			}
		}

		[Conditional("ASSERTION")]
		public static void NotImplemented(string message)
		{
			throw new AssertException("Method Not Yet Implemented");
		}

		[Conditional("ASSERTION")]
		public static void PostCondition(bool condition)
		{
			if (!condition)
			{
				throw new PostConditionException("PostCondition missed");
			}
		}

		[Conditional("ASSERTION")]
		public static void PostCondition(bool condition, string message)
		{
			if (!condition)
			{
				throw new PostConditionException(message);
			}
		}

		[Conditional("ASSERTION")]
		public static void PreCondition(bool condition)
		{
			if (!condition)
			{
				throw new PreConditionException("PreCondition missed");
			}
		}

		[Conditional("ASSERTION")]
		public static void PreCondition(bool condition, string message)
		{
			if (!condition)
			{
				throw new PreConditionException(message);
			}
		}

		[Conditional("LOGGING")]
		public static void Print(string str)
		{
			ScriptStream.Out.WriteLine(str);
		}

		[Conditional("LOGGING")]
		internal static void PrintLine(string message)
		{
			ScriptStream.Out.WriteLine(message);
		}

		[Conditional("LOGGING")]
		public static void PrintStack()
		{
			ScriptStream.PrintStackTrace();
		}

		[Conditional("LOGGING")]
		public static void PrintStack(Exception e)
		{
			ScriptStream.PrintStackTrace(e);
		}
	}
	internal class AssertException : Exception
	{
		internal AssertException(string message)
			: base(message)
		{
		}
	}
	internal class PreConditionException : AssertException
	{
		internal PreConditionException(string message)
			: base(message)
		{
		}
	}
	internal class PostConditionException : AssertException
	{
		internal PostConditionException(string message)
			: base(message)
		{
		}
	}
	/// <summary>This class is used by the JScript parser to represent a breakpoint in a debugger.</summary>
	public class DebugBreak : AST
	{
		internal DebugBreak(Context context)
			: base(context)
		{
		}

		internal override object Evaluate()
		{
			Debugger.Break();
			return new Completion();
		}

		internal override AST PartiallyEvaluate()
		{
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			context.EmitLineInfo(il);
			il.Emit(OpCodes.Call, CompilerGlobals.debugBreak);
			if (context.document.debugOn)
			{
				il.Emit(OpCodes.Nop);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
		}
	}
	internal class DebugArrayFieldEnumerator
	{
		private ScriptObjectPropertyEnumerator enumerator;

		private int count;

		private ArrayObject arrayObject;

		internal DebugArrayFieldEnumerator(ScriptObjectPropertyEnumerator enumerator, ArrayObject arrayObject)
		{
			this.enumerator = enumerator;
			this.arrayObject = arrayObject;
			EnsureCount();
		}

		internal DynamicFieldInfo[] Next(int count)
		{
			try
			{
				ArrayList arrayList = new ArrayList();
				while (count > 0 && enumerator.MoveNext())
				{
					string name = (string)enumerator.Current;
					arrayList.Add(new DynamicFieldInfo(name, arrayObject.GetMemberValue(name)));
					count--;
				}
				DynamicFieldInfo[] array = new DynamicFieldInfo[arrayList.Count];
				arrayList.CopyTo(array);
				return array;
			}
			catch
			{
				return new DynamicFieldInfo[0];
			}
		}

		internal int GetCount()
		{
			return count;
		}

		internal void Skip(int count)
		{
			while (count > 0 && enumerator.MoveNext())
			{
				count--;
			}
		}

		internal void Reset()
		{
			enumerator.Reset();
		}

		internal void EnsureCount()
		{
			enumerator.Reset();
			count = 0;
			while (enumerator.MoveNext())
			{
				count++;
			}
			enumerator.Reset();
		}
	}
	/// <summary>Defines a set of utility methods that convert data from one type to another. Includes methods that convert values to <see cref="T:System.String" /> objects so that they can be displayed by the debugger.</summary>
	[Guid("AA51516D-C0F2-49fe-9D38-61D20456904C")]
	[ComVisible(true)]
	public interface IDebugConvert
	{
		/// <summary>When implemented in a class, converts the specified value to the specified <see cref="T:System.TypeCode" />, optionally allowing data loss.</summary>
		/// <param name="value">The value to convert to a new type.</param>
		/// <param name="typeCode">The type to convert <paramref name="value" /> to.</param>
		/// <param name="truncationPermitted">
		///   <see langword="true" /> to allow data loss; otherwise, <see langword="false" />.</param>
		/// <returns>
		///   <paramref name="value" /> converted to the <paramref name="typeCode" /> type.</returns>
		object ToPrimitive(object value, TypeCode typeCode, bool truncationPermitted);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.Byte" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		string ByteToString(byte value, int radix);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.SByte" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		string SByteToString(sbyte value, int radix);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.Int16" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		string Int16ToString(short value, int radix);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.UInt16" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		string UInt16ToString(ushort value, int radix);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.Int32" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		string Int32ToString(int value, int radix);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.UInt32" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		string UInt32ToString(uint value, int radix);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.Int64" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		string Int64ToString(long value, int radix);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.UInt64" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		string UInt64ToString(ulong value, int radix);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.Single" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The string representation of <paramref name="value" />.</returns>
		string SingleToString(float value);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.Double" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The string representation of <paramref name="value" />.</returns>
		string DoubleToString(double value);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.Boolean" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The literal string "true" or the literal string "false".</returns>
		string BooleanToString(bool value);

		/// <summary>When implemented in a class, creates a string representation of the specified <see cref="T:System.Double" />. The string representation contains the day of the week, the month, the date, the time, the time zone, and the year.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The string representation of <paramref name="value" />.</returns>
		string DoubleToDateString(double value);

		/// <summary>When implemented in a class, converts the specified regular expression information to a <see cref="T:System.String" />.</summary>
		/// <param name="source">The regular expression pattern to match.</param>
		/// <param name="ignoreCase">
		///   <see langword="true" /> to use case-insensitive matching; otherwise, <see langword="false" />.</param>
		/// <param name="global">
		///   <see langword="true" /> to use a global match; otherwise, <see langword="false" />.</param>
		/// <param name="multiline">
		///   <see langword="true" /> to use a multiline match; otherwise, <see langword="false" />.</param>
		/// <returns>The string representation of the regular expression information.</returns>
		string RegexpToString(string source, bool ignoreCase, bool global, bool multiline);

		/// <summary>When implemented in a class, converts the specified <see cref="T:System.String" /> to a <see cref="T:System.String" /> that contains escape characters for non-printable characters.</summary>
		/// <param name="source">The value to convert.</param>
		/// <returns>The string representation of <paramref name="source" /> that contains escape characters.</returns>
		string StringToPrintable(string source);

		/// <summary>When implemented in a class, creates a managed object that has the specified primitive value.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>
		///   <paramref name="value" /> converted to a managed <see cref="T:System.Object" />.</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		object GetManagedObject(object value);

		/// <summary>When implemented in a class, creates a managed object that has the specified primitive <see cref="T:System.Int64" /> value.</summary>
		/// <param name="i">The value to convert.</param>
		/// <returns>
		///   <paramref name="i" /> converted to an <see cref="T:System.Object" />.</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		object GetManagedInt64Object(long i);

		/// <summary>When implemented in a class, creates a managed object that has the specified primitive <see cref="T:System.UInt64" /> value.</summary>
		/// <param name="i">The value to convert.</param>
		/// <returns>
		///   <paramref name="i" /> converted to an <see cref="T:System.Object" />.</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		object GetManagedUInt64Object(ulong i);

		/// <summary>When implemented in a class, creates a managed object that has the specified primitive <see cref="T:System.Char" /> value.</summary>
		/// <param name="i">The value to convert.</param>
		/// <returns>
		///   <paramref name="i" /> converted to a <see cref="T:System.Char" /> and then an <see cref="T:System.Object" />.</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		object GetManagedCharObject(ushort i);

		/// <summary>When implemented in a class, gets an error message that is created from the specified <see cref="P:System.Exception.HResult" /> and the <see cref="T:System.Globalization.CultureInfo" /> of the specified <see cref="T:Microsoft.JScript.Vsa.IJSVsaEngine" />.</summary>
		/// <param name="hr">The HRESULT error code.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>A localized string that contains information about the error.</returns>
		string GetErrorMessageForHR(int hr, IJSVsaEngine engine);
	}
	/// <summary>Defines utility methods that convert data from one type to another. Includes methods that convert values to <see cref="T:System.String" /> objects so that they can be displayed by the debugger.</summary>
	[Guid("B370D709-72BD-4696-9825-C4EBADBF98CB")]
	[ComVisible(true)]
	public interface IDebugConvert2
	{
		/// <summary>When implemented in a class, converts the specified <see cref="T:System.Decimal" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The string representation of <paramref name="value" />.</returns>
		string DecimalToString(decimal value);
	}
	/// <summary>Converts data from one type to another. Includes methods that convert values to <see cref="T:System.String" /> objects so that they can be displayed by the debugger.</summary>
	[Guid("432D76CE-8C9E-4eed-ADDD-91737F27A8CB")]
	[ComVisible(true)]
	public class DebugConvert : IDebugConvert, IDebugConvert2
	{
		/// <summary>Converts the specified value to the specified <see cref="T:System.TypeCode" />, optionally allowing data loss.</summary>
		/// <param name="value">The value to convert to a new type.</param>
		/// <param name="typeCode">The type to convert <paramref name="value" /> to.</param>
		/// <param name="truncationPermitted">
		///   <see langword="true" /> to allow data loss; otherwise, <see langword="false" />.</param>
		/// <returns>
		///   <paramref name="value" /> converted to the <paramref name="typeCode" /> type.</returns>
		public object ToPrimitive(object value, TypeCode typeCode, bool truncationPermitted)
		{
			return Convert.Coerce2(value, typeCode, truncationPermitted);
		}

		/// <summary>Converts the specified <see cref="T:System.Byte" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		public string ByteToString(byte value, int radix)
		{
			return System.Convert.ToString(value, radix);
		}

		/// <summary>Converts the specified <see cref="T:System.SByte" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		public string SByteToString(sbyte value, int radix)
		{
			if (radix == 10)
			{
				return value.ToString(CultureInfo.InvariantCulture);
			}
			return System.Convert.ToString((byte)value, radix);
		}

		/// <summary>Converts the specified <see cref="T:System.Int16" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		public string Int16ToString(short value, int radix)
		{
			return System.Convert.ToString((short)Convert.ToInteger(value), radix);
		}

		/// <summary>Converts the specified <see cref="T:System.UInt16" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		public string UInt16ToString(ushort value, int radix)
		{
			if (radix == 10)
			{
				return value.ToString(CultureInfo.InvariantCulture);
			}
			return System.Convert.ToString((short)Convert.ToInteger((int)value), radix);
		}

		/// <summary>Converts the specified <see cref="T:System.Int32" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		public string Int32ToString(int value, int radix)
		{
			return System.Convert.ToString((int)Convert.ToInteger(value), radix);
		}

		/// <summary>Converts the specified <see cref="T:System.UInt32" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		public string UInt32ToString(uint value, int radix)
		{
			if (radix == 10)
			{
				return value.ToString(CultureInfo.InvariantCulture);
			}
			return System.Convert.ToString((int)Convert.ToInteger(value), radix);
		}

		/// <summary>Converts the specified <see cref="T:System.Int64" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		public string Int64ToString(long value, int radix)
		{
			return System.Convert.ToString((long)Convert.ToInteger(value), radix);
		}

		/// <summary>Converts the specified <see cref="T:System.UInt64" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <param name="radix">The base of the return value. The base must be 2, 8, 10, or 16.</param>
		/// <returns>The string representation of <paramref name="value" /> in base <paramref name="radix" />.</returns>
		public string UInt64ToString(ulong value, int radix)
		{
			if (radix == 10)
			{
				return value.ToString(CultureInfo.InvariantCulture);
			}
			return System.Convert.ToString((long)Convert.ToInteger(value), radix);
		}

		/// <summary>Converts the specified <see cref="T:System.Single" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The string representation of <paramref name="value" />.</returns>
		public string SingleToString(float value)
		{
			return Convert.ToString(value);
		}

		/// <summary>Converts the specified <see cref="T:System.Double" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The string representation of <paramref name="value" />.</returns>
		public string DoubleToString(double value)
		{
			return Convert.ToString(value);
		}

		/// <summary>Converts the specified <see cref="T:System.Boolean" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The literal string "true" or the literal string "false".</returns>
		public string BooleanToString(bool value)
		{
			return Convert.ToString(value);
		}

		/// <summary>Creates a string representation of the specified <see cref="T:System.Double" />. The string representation contains the day of the week, the month, the date, the time, the time zone, and the year.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The string representation of <paramref name="value" />.</returns>
		public string DoubleToDateString(double value)
		{
			return DatePrototype.DateToString(value);
		}

		/// <summary>Converts the specified regular expression information to a <see cref="T:System.String" />.</summary>
		/// <param name="source">The regular expression pattern to match.</param>
		/// <param name="ignoreCase">
		///   <see langword="true" /> to use case-insensitive matching; otherwise, <see langword="false" />.</param>
		/// <param name="global">
		///   <see langword="true" /> to use a global match; otherwise, <see langword="false" />.</param>
		/// <param name="multiline">
		///   <see langword="true" /> to use a multiline match; otherwise, <see langword="false" />.</param>
		/// <returns>The string representation of the regular expression information.</returns>
		public string RegexpToString(string source, bool ignoreCase, bool global, bool multiline)
		{
			object obj = RegExpConstructor.ob.Construct(source, ignoreCase, global, multiline);
			return obj.ToString();
		}

		/// <summary>Converts the specified <see cref="T:System.Decimal" /> value to a <see cref="T:System.String" />.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>The string representation of <paramref name="value" />.</returns>
		public string DecimalToString(decimal value)
		{
			return value.ToString(CultureInfo.InvariantCulture);
		}

		/// <summary>Converts the specified <see cref="T:System.String" /> to a <see cref="T:System.String" /> that contains escape characters for non-printable characters.</summary>
		/// <param name="source">The value to convert.</param>
		/// <returns>The string representation of <paramref name="source" /> that contains escape characters.</returns>
		public string StringToPrintable(string source)
		{
			int length = source.Length;
			StringBuilder stringBuilder = new StringBuilder(length);
			for (int i = 0; i < length; i++)
			{
				switch (source[i])
				{
				case '\0':
					stringBuilder.Append("\\0");
					continue;
				case '\b':
					stringBuilder.Append("\\b");
					continue;
				case '\t':
					stringBuilder.Append("\\t");
					continue;
				case '\n':
					stringBuilder.Append("\\n");
					continue;
				case '\v':
					stringBuilder.Append("\\v");
					continue;
				case '\f':
					stringBuilder.Append("\\f");
					continue;
				case '\r':
					stringBuilder.Append("\\r");
					continue;
				case '"':
					stringBuilder.Append("\"");
					continue;
				case '\\':
					stringBuilder.Append("\\\\");
					continue;
				}
				if (char.GetUnicodeCategory(source[i]) != UnicodeCategory.Control)
				{
					stringBuilder.Append(source[i]);
					continue;
				}
				stringBuilder.Append("\\u");
				int num = source[i];
				char[] array = new char[4];
				for (int j = 0; j < 4; j++)
				{
					int num2 = num % 16;
					if (num2 <= 9)
					{
						array[3 - j] = (char)(48 + num2);
					}
					else
					{
						array[3 - j] = (char)(65 + num2 - 10);
					}
					num /= 16;
				}
				stringBuilder.Append(array);
			}
			return stringBuilder.ToString();
		}

		/// <summary>Creates a managed object that has the specified primitive value.</summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>
		///   <paramref name="value" /> converted to a managed <see cref="T:System.Object" />.</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		public object GetManagedObject(object value)
		{
			return value;
		}

		/// <summary>Creates a managed object that has the specified primitive <see cref="T:System.Int64" /> value.</summary>
		/// <param name="i">The value to convert.</param>
		/// <returns>
		///   <paramref name="i" /> converted to an <see cref="T:System.Object" />.</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		public object GetManagedInt64Object(long i)
		{
			return i;
		}

		/// <summary>Creates a managed object that has the specified primitive <see cref="T:System.UInt64" /> value.</summary>
		/// <param name="i">The value to convert.</param>
		/// <returns>
		///   <paramref name="i" /> converted to an <see cref="T:System.Object" />.</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		public object GetManagedUInt64Object(ulong i)
		{
			return i;
		}

		/// <summary>Creates a managed object that has the specified primitive <see cref="T:System.Char" /> value.</summary>
		/// <param name="i">The value to convert.</param>
		/// <returns>
		///   <paramref name="i" /> converted to a <see cref="T:System.Char" /> and then an <see cref="T:System.Object" />.</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		public object GetManagedCharObject(ushort i)
		{
			return (char)i;
		}

		/// <summary>Gets an error message that is created from the specified <see cref="P:System.Exception.HResult" /> and the <see cref="T:System.Globalization.CultureInfo" /> of the specified <see cref="T:Microsoft.JScript.Vsa.IJSVsaEngine" />.</summary>
		/// <param name="hr">The HRESULT error code.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>A localized string that contains information about the error.</returns>
		public string GetErrorMessageForHR(int hr, IJSVsaEngine engine)
		{
			CultureInfo culture = null;
			if (engine is VsaEngine vsaEngine)
			{
				culture = vsaEngine.ErrorCultureInfo;
			}
			if ((hr & 0xFFFF0000u) == 2148139008u && Enum.IsDefined(typeof(JSError), hr & 0xFFFF))
			{
				return JScriptException.Localize((hr & 0xFFFF).ToString(CultureInfo.InvariantCulture), culture);
			}
			return JScriptException.Localize(6011.ToString(CultureInfo.InvariantCulture), "0x" + hr.ToString("X", CultureInfo.InvariantCulture), culture);
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.DebugConvert" /> class.</summary>
		public DebugConvert()
		{
		}
	}
	/// <summary>Defines methods that provide information about debugger objects. This interface is implemented by debugger objects that represent a type in the debugger target.</summary>
	[Guid("613CC05D-05F4-4969-B369-5AEEF56E32D0")]
	[ComVisible(true)]
	public interface IDebugType
	{
		/// <summary>When implemented in a class, determines whether the specified object is an instance of the current type.</summary>
		/// <param name="o">The object to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="o" /> is an instance of the current type; otherwise, <see langword="false" />.</returns>
		bool HasInstance([MarshalAs(UnmanagedType.Interface)] object o);
	}
	/// <summary>Defines methods that provide information about debugger objects. This interface is implemented by all <see cref="T:System.Reflection.IReflect" /> objects that are implemented by the debugger. Currently, this interface serves only to flag these objects as such to the scripting engine.</summary>
	[Guid("8E93D770-6168-4b68-B896-A71B74C7076A")]
	[ComVisible(true)]
	public interface IDebuggerObject
	{
		/// <summary>When implemented in a class, determines whether the current object is a true COM object or a proxy to a managed object.</summary>
		/// <returns>
		///   <see langword="true" /> if the current object is a COM object; <see langword="false" /> if the current object is a proxy to a managed object.</returns>
		bool IsCOMObject();

		/// <summary>When implemented in a class, determines whether the current object is equal to the specified object.</summary>
		/// <param name="o">The object to test for equality.</param>
		/// <returns>
		///   <see langword="true" /> if the current object is the same as <paramref name="o" />; otherwise, <see langword="false" />.</returns>
		bool IsEqual(IDebuggerObject o);

		/// <summary>When implemented in a class, determines whether the current object has a member that has the specified name and that is enumerable.</summary>
		/// <param name="name">The name of the member to search for.</param>
		/// <returns>
		///   <see langword="true" /> if the current object has an enumerable member named <paramref name="name" />; otherwise, <see langword="false" />.</returns>
		bool HasEnumerableMember(string name);

		/// <summary>When implemented in a class, determines whether the current object is a proxy to a managed JScript function.</summary>
		/// <returns>
		///   <see langword="true" /> if the current object is a proxy to a managed JScript function; otherwise, <see langword="false" />.</returns>
		bool IsScriptFunction();

		/// <summary>When implemented in a class, determines whether the current object is a proxy to a managed JScript object.</summary>
		/// <returns>
		///   <see langword="true" /> if the current object is a proxy to a managed JScript object; otherwise, <see langword="false" />.</returns>
		bool IsScriptObject();
	}
	/// <summary>Represents field information. This class is used to return fields of expando classes and script arrays to the debugger.</summary>
	public sealed class DynamicFieldInfo
	{
		/// <summary>The name of the field.</summary>
		public string name;

		/// <summary>The value of the field.</summary>
		public object value;

		/// <summary>The type of the field.</summary>
		public string fieldTypeName;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.DynamicFieldInfo" /> class, using the specified name and value.</summary>
		/// <param name="name">The name of the field.</param>
		/// <param name="value">The value of the field.</param>
		public DynamicFieldInfo(string name, object value)
		{
			this.name = name;
			this.value = value;
			fieldTypeName = "";
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.DynamicFieldInfo" /> class, using the specified name, value, and type.</summary>
		/// <param name="name">The name of the field.</param>
		/// <param name="value">The value of the field.</param>
		/// <param name="fieldTypeName">The type of the field.</param>
		public DynamicFieldInfo(string name, object value, string fieldTypeName)
		{
			this.name = name;
			this.value = value;
			this.fieldTypeName = fieldTypeName;
		}
	}
	internal static class DebuggingHelper
	{
		public static DynamicFieldInfo[] GetHashTableFields(SimpleHashtable h)
		{
			DynamicFieldInfo[] array = null;
			try
			{
				int count = h.count;
				array = new DynamicFieldInfo[count];
				IDictionaryEnumerator enumerator = h.GetEnumerator();
				for (int i = 0; i < count; i++)
				{
					if (enumerator.MoveNext())
					{
						array[i] = new DynamicFieldInfo((string)enumerator.Key, enumerator.Value);
						continue;
					}
					return array;
				}
				return array;
			}
			catch
			{
				return new DynamicFieldInfo[0];
			}
		}

		public static DynamicFieldInfo[] GetExpandoObjectFields(object o, bool hideNamespaces)
		{
			if (!(o is IReflect reflect))
			{
				return new DynamicFieldInfo[0];
			}
			try
			{
				FieldInfo[] fields = reflect.GetFields(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
				ArrayList arrayList = new ArrayList();
				FieldInfo[] array = fields;
				foreach (FieldInfo fieldInfo in array)
				{
					bool flag = false;
					foreach (object item in arrayList)
					{
						if (fieldInfo.Name == ((DynamicFieldInfo)item).name)
						{
							flag = true;
						}
					}
					if (!flag)
					{
						object value = fieldInfo.GetValue(o);
						if (!hideNamespaces || !(value is Namespace))
						{
							arrayList.Add(new DynamicFieldInfo(fieldInfo.Name, value, fieldInfo.FieldType.Name));
						}
					}
				}
				return (DynamicFieldInfo[])arrayList.ToArray(typeof(DynamicFieldInfo));
			}
			catch
			{
				return new DynamicFieldInfo[0];
			}
		}

		public static object CallMethod(string name, object thisob, object[] arguments, VsaEngine engine)
		{
			if (engine == null)
			{
				engine = VsaEngine.CreateEngine();
			}
			LateBinding lateBinding = new LateBinding(name, thisob, checkForDebugger: true);
			return lateBinding.Call(arguments, construct: false, brackets: false, engine);
		}

		public static object CallStaticMethod(string name, string typename, object[] arguments, VsaEngine engine)
		{
			if (engine == null)
			{
				engine = VsaEngine.CreateEngine();
			}
			object type = GetType(typename);
			LateBinding lateBinding = new LateBinding(name, type, checkForDebugger: true);
			return lateBinding.Call(arguments, construct: false, brackets: false, engine);
		}

		public static object CallConstructor(string typename, object[] arguments, VsaEngine engine)
		{
			if (engine == null)
			{
				engine = VsaEngine.CreateEngine();
			}
			object type = GetType(typename);
			return LateBinding.CallValue(null, type, arguments, construct: true, brackets: false, engine);
		}

		private static Type GetTypeInCurrentAppDomain(string typename)
		{
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			Assembly[] array = assemblies;
			foreach (Assembly assembly in array)
			{
				if (!(assembly is AssemblyBuilder))
				{
					Type type = assembly.GetType(typename);
					if (type != null)
					{
						return type;
					}
				}
			}
			return null;
		}

		private static Type GetType(string typename)
		{
			string[] array = typename.Split('.');
			if (array != null && array.Length != 0)
			{
				string text = array[0];
				Type type = GetTypeInCurrentAppDomain(text);
				int i;
				for (i = 1; i < array.Length; i++)
				{
					if (!(type == null))
					{
						break;
					}
					text = text + "." + array[i];
					type = GetTypeInCurrentAppDomain(text);
				}
				for (int j = i; j < array.Length; j++)
				{
					if (!(type != null))
					{
						break;
					}
					type = type.GetNestedType(array[j], BindingFlags.Public | BindingFlags.NonPublic);
				}
				return type;
			}
			return null;
		}

		public static void SetIndexedPropertyValue(string name, object thisob, object[] arguments, object value, VsaEngine engine)
		{
			LateBinding lateBinding = new LateBinding(name, thisob, checkForDebugger: true);
			lateBinding.SetIndexedPropertyValue(arguments, value);
		}

		public static void SetStaticIndexedPropertyValue(string name, string typename, object[] arguments, object value, VsaEngine engine)
		{
			object type = GetType(typename);
			LateBinding lateBinding = new LateBinding(name, type, checkForDebugger: true);
			lateBinding.SetIndexedPropertyValue(arguments, value);
		}

		public static void SetDefaultIndexedPropertyValue(object thisob, object[] arguments, VsaEngine engine, string[] namedParameters)
		{
			object value = null;
			object[] array = null;
			int num = arguments.Length;
			if (num > 0)
			{
				value = arguments[num - 1];
			}
			int i = 0;
			int num2 = num - 1;
			if (namedParameters != null && namedParameters.Length != 0 && namedParameters[0] == "this")
			{
				num2--;
				i = 1;
			}
			array = new object[num2];
			ArrayObject.Copy(arguments, i, array, 0, num2);
			LateBinding lateBinding = new LateBinding(null, thisob, checkForDebugger: true);
			lateBinding.SetIndexedPropertyValue(array, value);
		}

		public static object GetDefaultIndexedPropertyValue(object thisob, object[] arguments, VsaEngine engine, string[] namedParameters)
		{
			if (engine == null)
			{
				engine = VsaEngine.CreateEngine();
			}
			object[] array = null;
			int num = ((arguments != null) ? arguments.Length : 0);
			if (namedParameters != null && namedParameters.Length != 0 && namedParameters[0] == "this" && num > 0)
			{
				array = new object[num - 1];
				ArrayObject.Copy(arguments, 1, array, 0, num - 1);
			}
			else
			{
				array = arguments;
			}
			LateBinding lateBinding = new LateBinding(null, thisob, checkForDebugger: true);
			return lateBinding.Call(array, construct: false, brackets: false, engine);
		}

		public static object InvokeCOMObject(string name, object obj, object[] arguments, BindingFlags invokeAttr)
		{
			Type type = obj.GetType();
			return type.InvokeMember(name, invokeAttr, JSBinder.ob, obj, arguments, null, null, null);
		}

		public static void Print(string message, VsaEngine engine)
		{
			if (engine != null && engine.doPrint)
			{
				ScriptStream.Out.Write(message);
			}
		}

		public static object GetClosureInstance(VsaEngine engine)
		{
			if (engine == null)
			{
				return null;
			}
			if (engine.ScriptObjectStackTop() is StackFrame stackFrame)
			{
				return stackFrame.closureInstance;
			}
			return null;
		}

		public static object InvokeMethodInfo(MethodInfo m, object[] arguments, bool construct, object thisob, VsaEngine engine)
		{
			if (engine == null)
			{
				engine = VsaEngine.CreateEngine();
			}
			return LateBinding.CallOneOfTheMembers(new MemberInfo[1] { m }, arguments, construct, thisob, JSBinder.ob, null, null, engine);
		}

		public static VsaEngine CreateEngine()
		{
			return VsaEngine.CreateEngineForDebugger();
		}

		public static object ToNativeArray(string elementTypename, object arrayObject)
		{
			Type type = GetType(elementTypename);
			if (type != null)
			{
				if (arrayObject is ArrayObject arrayObject2)
				{
					return arrayObject2.ToNativeArray(type);
				}
				throw new JScriptException(JSError.TypeMismatch);
			}
			throw new JScriptException(JSError.TypeMismatch);
		}

		public static object[] CreateArray(int length)
		{
			object[] array = new object[length];
			for (int i = 0; i < length; i++)
			{
				array[i] = new object();
			}
			return array;
		}

		public static string[] CreateStringArray(string s)
		{
			return new string[1] { s };
		}

		public static object StringToObject(string s)
		{
			return s;
		}

		public static object BooleanToObject(bool i)
		{
			return i;
		}

		public static object SByteToObject(sbyte i)
		{
			return i;
		}

		public static object ByteToObject(byte i)
		{
			return i;
		}

		public static object Int16ToObject(short i)
		{
			return i;
		}

		public static object UInt16ToObject(ushort i)
		{
			return i;
		}

		public static object Int32ToObject(int i)
		{
			return i;
		}

		public static object UInt32ToObject(uint i)
		{
			return i;
		}

		public static object Int64ToObject(long i)
		{
			return i;
		}

		public static object UInt64ToObject(ulong i)
		{
			return i;
		}

		public static object SingleToObject(float i)
		{
			return i;
		}

		public static object DoubleToObject(double i)
		{
			return i;
		}
	}
	internal sealed class Delete : UnaryOp
	{
		internal Delete(Context context, AST operand)
			: base(context, operand)
		{
		}

		internal override void CheckIfOKToUseInSuperConstructorCall()
		{
			context.HandleError(JSError.NotAllowedInSuperConstructorCall);
		}

		internal override object Evaluate()
		{
			try
			{
				return operand.Delete();
			}
			catch (JScriptException)
			{
				return true;
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return Typeob.Boolean;
		}

		internal override AST PartiallyEvaluate()
		{
			operand = operand.PartiallyEvaluate();
			if (operand is Binding)
			{
				((Binding)operand).CheckIfDeletable();
			}
			else if (operand is Call)
			{
				((Call)operand).MakeDeletable();
			}
			else
			{
				operand.context.HandleError(JSError.NotDeletable);
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			operand.TranslateToILDelete(il, rtype);
		}
	}
	/// <summary>Represents a source code file that is written in the JScript language.</summary>
	public class DocumentContext
	{
		internal string documentName;

		internal ISymbolDocumentWriter documentWriter;

		internal int startLine;

		internal int startCol;

		internal int lastLineInSource;

		internal VsaItem sourceItem;

		internal VsaEngine engine;

		internal bool debugOn;

		private CompilerGlobals _compilerGlobals;

		private SimpleHashtable reportedVariables;

		private bool checkForFirst;

		private int firstStartLine;

		private int firstStartCol;

		private int firstEndLine;

		private int firstEndCol;

		internal static readonly Guid language = new Guid("3a12d0b6-c26c-11d0-b442-00a0244a1dd2");

		internal static readonly Guid vendor = new Guid("994b45c4-e6e9-11d2-903f-00c04fa302a1");

		internal CompilerGlobals compilerGlobals
		{
			get
			{
				if (_compilerGlobals == null)
				{
					_compilerGlobals = engine.CompilerGlobals;
				}
				return _compilerGlobals;
			}
		}

		internal DocumentContext(string name, VsaEngine engine)
		{
			documentName = name;
			documentWriter = null;
			startLine = 0;
			startCol = 0;
			lastLineInSource = 0;
			sourceItem = null;
			this.engine = engine;
			debugOn = engine?.GenerateDebugInfo ?? false;
			_compilerGlobals = null;
			reportedVariables = null;
			checkForFirst = false;
		}

		internal DocumentContext(VsaItem sourceItem)
		{
			if (sourceItem.codebase != null)
			{
				documentName = sourceItem.codebase;
			}
			else
			{
				string rootMoniker = sourceItem.engine.RootMoniker;
				documentName = rootMoniker + (rootMoniker.EndsWith("/", StringComparison.Ordinal) ? "" : "/") + sourceItem.Name;
			}
			documentWriter = null;
			startLine = 0;
			startCol = 0;
			lastLineInSource = 0;
			this.sourceItem = sourceItem;
			engine = sourceItem.engine;
			debugOn = engine != null && engine.GenerateDebugInfo;
			_compilerGlobals = null;
			checkForFirst = false;
		}

		internal DocumentContext(string documentName, int startLine, int startCol, int lastLineInSource, VsaItem sourceItem)
		{
			this.documentName = documentName;
			documentWriter = null;
			this.startLine = startLine;
			this.startCol = startCol;
			this.lastLineInSource = lastLineInSource;
			this.sourceItem = sourceItem;
			engine = sourceItem.engine;
			debugOn = engine != null && engine.GenerateDebugInfo;
			_compilerGlobals = null;
			checkForFirst = false;
		}

		internal void EmitLineInfo(ILGenerator ilgen, int line, int column, int endLine, int endColumn)
		{
			if (!debugOn)
			{
				return;
			}
			if (checkForFirst && line == firstStartLine && column == firstStartCol && endLine == firstEndLine && endColumn == firstEndCol)
			{
				checkForFirst = false;
				return;
			}
			if (documentWriter == null)
			{
				documentWriter = GetSymDocument(documentName);
			}
			ilgen.MarkSequencePoint(documentWriter, startLine + line - lastLineInSource, startCol + column + 1, startLine - lastLineInSource + endLine, startCol + endColumn + 1);
		}

		internal void EmitFirstLineInfo(ILGenerator ilgen, int line, int column, int endLine, int endColumn)
		{
			EmitLineInfo(ilgen, line, column, endLine, endColumn);
			checkForFirst = true;
			firstStartLine = line;
			firstStartCol = column;
			firstEndLine = endLine;
			firstEndCol = endColumn;
		}

		private ISymbolDocumentWriter GetSymDocument(string documentName)
		{
			SimpleHashtable documents = compilerGlobals.documents;
			object obj = documents[documentName];
			if (obj == null)
			{
				obj = (documents[documentName] = _compilerGlobals.module.DefineDocument(this.documentName, language, vendor, Guid.Empty));
			}
			return (ISymbolDocumentWriter)obj;
		}

		internal void HandleError(JScriptException error)
		{
			if (sourceItem == null)
			{
				if (error.Severity == 0)
				{
					throw error;
				}
			}
			else if (!sourceItem.engine.OnCompilerError(error))
			{
				throw new EndOfFile();
			}
		}

		internal bool HasAlreadySeenErrorFor(string varName)
		{
			if (reportedVariables == null)
			{
				reportedVariables = new SimpleHashtable(8u);
			}
			else if (reportedVariables[varName] != null)
			{
				return true;
			}
			reportedVariables[varName] = varName;
			return false;
		}
	}
	internal sealed class DoWhile : AST
	{
		private AST body;

		private AST condition;

		private Completion completion;

		internal DoWhile(Context context, AST body, AST condition)
			: base(context)
		{
			this.body = body;
			this.condition = condition;
			completion = new Completion();
		}

		internal override object Evaluate()
		{
			this.completion.Continue = 0;
			this.completion.Exit = 0;
			this.completion.value = null;
			do
			{
				Completion completion = (Completion)body.Evaluate();
				if (completion.value != null)
				{
					this.completion.value = completion.value;
				}
				if (completion.Continue > 1)
				{
					this.completion.Continue = completion.Continue - 1;
					break;
				}
				if (completion.Exit > 0)
				{
					this.completion.Exit = completion.Exit - 1;
					break;
				}
				if (completion.Return)
				{
					return completion;
				}
			}
			while (Convert.ToBoolean(condition.Evaluate()));
			return this.completion;
		}

		internal override AST PartiallyEvaluate()
		{
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is FunctionScope)
			{
				FunctionScope functionScope = (FunctionScope)scriptObject;
				BitArray definedFlags = functionScope.DefinedFlags;
				body = body.PartiallyEvaluate();
				functionScope.DefinedFlags = definedFlags;
				condition = condition.PartiallyEvaluate();
				functionScope.DefinedFlags = definedFlags;
			}
			else
			{
				body = body.PartiallyEvaluate();
				condition = condition.PartiallyEvaluate();
			}
			IReflect reflect = condition.InferType(null);
			if (reflect is FunctionPrototype || reflect == Typeob.ScriptFunction)
			{
				context.HandleError(JSError.SuspectLoopCondition);
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Label label = il.DefineLabel();
			Label label2 = il.DefineLabel();
			Label label3 = il.DefineLabel();
			base.compilerGlobals.BreakLabelStack.Push(label3);
			base.compilerGlobals.ContinueLabelStack.Push(label2);
			il.MarkLabel(label);
			body.TranslateToIL(il, Typeob.Void);
			il.MarkLabel(label2);
			context.EmitLineInfo(il);
			condition.TranslateToConditionalBranch(il, branchIfTrue: true, label, shortForm: false);
			il.MarkLabel(label3);
			base.compilerGlobals.BreakLabelStack.Pop();
			base.compilerGlobals.ContinueLabelStack.Pop();
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			body.TranslateToILInitializer(il);
			condition.TranslateToILInitializer(il);
		}

		internal override Context GetFirstExecutableContext()
		{
			return body.GetFirstExecutableContext();
		}
	}
	/// <summary>Represents the value of a variable that has not been instantiated.</summary>
	public sealed class Empty
	{
		/// <summary>Specifies the value of a variable that has not been instantiated.</summary>
		public static readonly Empty Value;

		private Empty()
		{
		}
	}
	internal sealed class EmptyLiteral : ConstantWrapper
	{
		internal EmptyLiteral(Context context)
			: base(null, context)
		{
		}
	}
	internal sealed class EnumDeclaration : Class
	{
		internal TypeExpression baseType;

		internal EnumDeclaration(Context context, IdentifierLiteral id, TypeExpression baseType, Block body, FieldAttributes attributes, CustomAttributeList customAttributes)
			: base(context, id, new TypeExpression(new ConstantWrapper(Typeob.Enum, null)), new TypeExpression[0], body, attributes, isAbstract: false, isFinal: false, isStatic: true, isInterface: false, customAttributes)
		{
			this.baseType = ((baseType != null) ? baseType : new TypeExpression(new ConstantWrapper(Typeob.Int32, null)));
			needsEngine = false;
			base.attributes &= TypeAttributes.VisibilityMask;
			TypeExpression type = new TypeExpression(new ConstantWrapper(classob, base.context));
			AST aST = new ConstantWrapper(-1, null);
			AST operand = new ConstantWrapper(1, null);
			JSMemberField[] array = fields;
			foreach (FieldInfo fieldInfo in array)
			{
				JSVariableField jSVariableField = (JSVariableField)fieldInfo;
				jSVariableField.attributeFlags = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal;
				jSVariableField.type = type;
				aST = (AST)((jSVariableField.value != null) ? ((AST)jSVariableField.value) : (jSVariableField.value = new Plus(aST.context, aST, operand)));
				jSVariableField.value = new DeclaredEnumValue(jSVariableField.value, jSVariableField.Name, classob);
			}
		}

		internal override AST PartiallyEvaluate()
		{
			if (!(classob.GetParent() is GlobalScope))
			{
				return this;
			}
			baseType.PartiallyEvaluate();
			IReflect reflect = baseType.ToIReflect();
			Type type = null;
			if (!(reflect is Type) || !Convert.IsPrimitiveIntegerType(type = (Type)reflect))
			{
				baseType.context.HandleError(JSError.InvalidBaseTypeForEnum);
				baseType = new TypeExpression(new ConstantWrapper(Typeob.Int32, null));
				type = Typeob.Int32;
			}
			if (customAttributes != null)
			{
				customAttributes.PartiallyEvaluate();
			}
			if (NeedsToBeCheckedForCLSCompliance())
			{
				if (!TypeExpression.TypeIsCLSCompliant(reflect))
				{
					baseType.context.HandleError(JSError.NonCLSCompliantType);
				}
				CheckMemberNamesForCLSCompliance();
			}
			ScriptObject parent = enclosingScope;
			while (!(parent is GlobalScope) && !(parent is PackageScope))
			{
				parent = parent.GetParent();
			}
			classob.SetParent(new WithObject(parent, Typeob.Enum, isSuperType: true));
			base.Globals.ScopeStack.Push(classob);
			try
			{
				JSMemberField[] array = fields;
				foreach (FieldInfo fieldInfo in array)
				{
					JSMemberField jSMemberField = (JSMemberField)fieldInfo;
					((DeclaredEnumValue)jSMemberField.value).CoerceToBaseType(type, jSMemberField.originalContext);
				}
			}
			finally
			{
				base.Globals.ScopeStack.Pop();
			}
			return this;
		}

		internal override Type GetTypeBuilderOrEnumBuilder()
		{
			if (classob.classwriter != null)
			{
				return classob.classwriter;
			}
			PartiallyEvaluate();
			if (enclosingScope is ClassScope classScope)
			{
				TypeBuilder typeBuilder = ((TypeBuilder)classScope.classwriter).DefineNestedType(name, attributes | TypeAttributes.Sealed, Typeob.Enum, null);
				classob.classwriter = typeBuilder;
				Type type = baseType.ToType();
				FieldBuilder fieldBuilder = typeBuilder.DefineField("value__", type, FieldAttributes.Private | FieldAttributes.SpecialName);
				if (customAttributes != null)
				{
					CustomAttributeBuilder[] customAttributeBuilders = customAttributes.GetCustomAttributeBuilders(getForProperty: false);
					for (int i = 0; i < customAttributeBuilders.Length; i++)
					{
						typeBuilder.SetCustomAttribute(customAttributeBuilders[i]);
					}
				}
				JSMemberField[] array = fields;
				foreach (FieldInfo fieldInfo in array)
				{
					((FieldBuilder)(((JSMemberField)fieldInfo).metaData = typeBuilder.DefineField(fieldInfo.Name, typeBuilder, FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal))).SetConstant(((EnumWrapper)fieldInfo.GetValue(null)).ToNumericValue());
				}
				return typeBuilder;
			}
			EnumBuilder enumBuilder = base.compilerGlobals.module.DefineEnum(name, attributes, baseType.ToType());
			classob.classwriter = enumBuilder;
			if (customAttributes != null)
			{
				CustomAttributeBuilder[] customAttributeBuilders2 = customAttributes.GetCustomAttributeBuilders(getForProperty: false);
				for (int k = 0; k < customAttributeBuilders2.Length; k++)
				{
					enumBuilder.SetCustomAttribute(customAttributeBuilders2[k]);
				}
			}
			JSMemberField[] array2 = fields;
			foreach (FieldInfo fieldInfo2 in array2)
			{
				((JSMemberField)fieldInfo2).metaData = enumBuilder.DefineLiteral(fieldInfo2.Name, ((EnumWrapper)fieldInfo2.GetValue(null)).ToNumericValue());
			}
			return enumBuilder;
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public sealed class EnumeratorConstructor : ScriptFunction
	{
		internal static readonly EnumeratorConstructor ob = new EnumeratorConstructor();

		private EnumeratorPrototype originalPrototype;

		internal EnumeratorConstructor()
			: base(FunctionPrototype.ob, "Enumerator", 1)
		{
			originalPrototype = EnumeratorPrototype.ob;
			EnumeratorPrototype._constructor = this;
			proto = EnumeratorPrototype.ob;
		}

		internal EnumeratorConstructor(LenientFunctionPrototype parent, LenientEnumeratorPrototype prototypeProp)
			: base(parent, "Enumerator", 1)
		{
			originalPrototype = prototypeProp;
			prototypeProp.constructor = this;
			proto = prototypeProp;
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			return null;
		}

		internal override object Construct(object[] args)
		{
			return CreateInstance(args);
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>The instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new EnumeratorObject CreateInstance(params object[] args)
		{
			if (args.Length != 0)
			{
				object obj = args[0];
				if (obj is IEnumerable)
				{
					return new EnumeratorObject(originalPrototype, (IEnumerable)obj);
				}
				throw new JScriptException(JSError.NotCollection);
			}
			return new EnumeratorObject(originalPrototype, null);
		}

		/// <summary>Returns null in all cases.</summary>
		/// <returns>null.</returns>
		public object Invoke()
		{
			return null;
		}
	}
	/// <summary>Represents an enumerator object. This class belongs to the built-in object model category.</summary>
	public class EnumeratorObject : JSObject
	{
		private IEnumerable collection;

		/// <summary>Contains the enumerator that is represented by the <see cref="T:Microsoft.JScript.EnumeratorObject" /> class.</summary>
		protected IEnumerator enumerator;

		private object obj;

		internal EnumeratorObject(EnumeratorPrototype parent)
			: base(parent)
		{
			enumerator = null;
			collection = null;
			noExpando = false;
		}

		internal EnumeratorObject(EnumeratorPrototype parent, IEnumerable collection)
			: base(parent)
		{
			this.collection = collection;
			if (collection != null)
			{
				enumerator = collection.GetEnumerator();
			}
			LoadObject();
			noExpando = false;
		}

		internal virtual bool atEnd()
		{
			if (enumerator != null)
			{
				return obj == null;
			}
			return true;
		}

		internal virtual object item()
		{
			if (enumerator != null)
			{
				return obj;
			}
			return null;
		}

		/// <summary>Advances the enumerator to the next element of the collection and stores a reference to the current element of the collection.</summary>
		protected void LoadObject()
		{
			if (enumerator != null && enumerator.MoveNext())
			{
				obj = enumerator.Current;
			}
			else
			{
				obj = null;
			}
		}

		internal virtual void moveFirst()
		{
			if (collection != null)
			{
				enumerator = collection.GetEnumerator();
			}
			LoadObject();
		}

		internal virtual void moveNext()
		{
			if (enumerator != null)
			{
				LoadObject();
			}
		}
	}
	/// <summary>Provides static methods and properties for <see cref="T:Microsoft.JScript.EnumeratorObject" /> objects. All methods of this class are called by passing in a reference to the object that is requesting access to the method. This class belongs to the built-in object model category.</summary>
	public class EnumeratorPrototype : JSObject
	{
		internal static readonly EnumeratorPrototype ob = new EnumeratorPrototype(ObjectPrototype.ob);

		internal static EnumeratorConstructor _constructor;

		/// <summary>Gets a reference to a prototype-based object that is using this prototype.</summary>
		/// <returns>A reference to a prototype-based object.</returns>
		public static EnumeratorConstructor constructor => _constructor;

		internal EnumeratorPrototype(ObjectPrototype parent)
			: base(parent)
		{
		}

		/// <summary>Determines whether the enumerator has passed the last item of the collection.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>
		///   <see langword="true" /> if the enumerator has passed the last item of the collection; otherwise, <see langword="false" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Enumerator_atEnd)]
		public static bool atEnd(object thisob)
		{
			if (thisob is EnumeratorObject)
			{
				return ((EnumeratorObject)thisob).atEnd();
			}
			throw new JScriptException(JSError.EnumeratorExpected);
		}

		/// <summary>Gets the current element in the collection.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The current element in the collection.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Enumerator_item)]
		public static object item(object thisob)
		{
			if (thisob is EnumeratorObject)
			{
				return ((EnumeratorObject)thisob).item();
			}
			throw new JScriptException(JSError.EnumeratorExpected);
		}

		/// <summary>Moves the enumerator to its initial position, which is before the first element in the collection.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Enumerator_moveFirst)]
		public static void moveFirst(object thisob)
		{
			if (thisob is EnumeratorObject)
			{
				((EnumeratorObject)thisob).moveFirst();
				return;
			}
			throw new JScriptException(JSError.EnumeratorExpected);
		}

		/// <summary>Advances the enumerator to the next element of the collection.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Enumerator_moveNext)]
		public static void moveNext(object thisob)
		{
			if (thisob is EnumeratorObject)
			{
				((EnumeratorObject)thisob).moveNext();
				return;
			}
			throw new JScriptException(JSError.EnumeratorExpected);
		}
	}
	internal abstract class EnumWrapper : IConvertible
	{
		internal abstract object value { get; }

		internal abstract Type type { get; }

		internal abstract string name { get; }

		internal virtual IReflect classScopeOrType => type;

		TypeCode IConvertible.GetTypeCode()
		{
			return Convert.GetTypeCode(value);
		}

		bool IConvertible.ToBoolean(IFormatProvider provider)
		{
			return ((IConvertible)value).ToBoolean(provider);
		}

		char IConvertible.ToChar(IFormatProvider provider)
		{
			return ((IConvertible)value).ToChar(provider);
		}

		sbyte IConvertible.ToSByte(IFormatProvider provider)
		{
			return ((IConvertible)value).ToSByte(provider);
		}

		byte IConvertible.ToByte(IFormatProvider provider)
		{
			return ((IConvertible)value).ToByte(provider);
		}

		short IConvertible.ToInt16(IFormatProvider provider)
		{
			return ((IConvertible)value).ToInt16(provider);
		}

		ushort IConvertible.ToUInt16(IFormatProvider provider)
		{
			return ((IConvertible)value).ToUInt16(provider);
		}

		int IConvertible.ToInt32(IFormatProvider provider)
		{
			return ((IConvertible)value).ToInt32(provider);
		}

		uint IConvertible.ToUInt32(IFormatProvider provider)
		{
			return ((IConvertible)value).ToUInt32(provider);
		}

		long IConvertible.ToInt64(IFormatProvider provider)
		{
			return ((IConvertible)value).ToInt64(provider);
		}

		ulong IConvertible.ToUInt64(IFormatProvider provider)
		{
			return ((IConvertible)value).ToUInt64(provider);
		}

		float IConvertible.ToSingle(IFormatProvider provider)
		{
			return ((IConvertible)value).ToSingle(provider);
		}

		double IConvertible.ToDouble(IFormatProvider provider)
		{
			return ((IConvertible)value).ToDouble(provider);
		}

		decimal IConvertible.ToDecimal(IFormatProvider provider)
		{
			return ((IConvertible)value).ToDecimal(provider);
		}

		DateTime IConvertible.ToDateTime(IFormatProvider provider)
		{
			return ((IConvertible)value).ToDateTime(provider);
		}

		string IConvertible.ToString(IFormatProvider provider)
		{
			return ((IConvertible)value).ToString(provider);
		}

		object IConvertible.ToType(Type conversionType, IFormatProvider provider)
		{
			return ((IConvertible)value).ToType(conversionType, provider);
		}

		internal object ToNumericValue()
		{
			return value;
		}

		public override string ToString()
		{
			if (name != null)
			{
				return name;
			}
			FieldInfo[] fields = type.GetFields(BindingFlags.Static | BindingFlags.Public);
			FieldInfo[] array = fields;
			foreach (FieldInfo fieldInfo in array)
			{
				if (StrictEquality.JScriptStrictEquals(value, fieldInfo.GetValue(null)))
				{
					return fieldInfo.Name;
				}
			}
			return Convert.ToString(value);
		}
	}
	internal sealed class DeclaredEnumValue : EnumWrapper
	{
		private string _name;

		internal ClassScope _classScope;

		internal object _value;

		internal override object value => _value;

		internal override Type type => _classScope.GetTypeBuilderOrEnumBuilder();

		internal override string name => _name;

		internal override IReflect classScopeOrType => _classScope;

		internal DeclaredEnumValue(object value, string name, ClassScope classScope)
		{
			_name = name;
			_classScope = classScope;
			_value = value;
		}

		internal void CoerceToBaseType(Type bt, Context errCtx)
		{
			object obj = 0;
			AST aST = ((AST)value).PartiallyEvaluate();
			if (aST is ConstantWrapper)
			{
				obj = ((ConstantWrapper)aST).Evaluate();
			}
			else
			{
				aST.context.HandleError(JSError.NotConst);
			}
			try
			{
				_value = Convert.CoerceT(obj, bt);
			}
			catch
			{
				errCtx.HandleError(JSError.TypeMismatch);
				_value = Convert.CoerceT(0, bt);
			}
		}
	}
	internal sealed class MetadataEnumValue : EnumWrapper
	{
		private Type _type;

		private object _value;

		internal override object value => _value;

		internal override Type type => _type;

		internal override string name
		{
			get
			{
				string text = Enum.GetName(_type, _value);
				if (text == null)
				{
					text = _value.ToString();
				}
				return text;
			}
		}

		internal static object GetEnumValue(Type type, object value)
		{
			if (!type.Assembly.ReflectionOnly)
			{
				return Enum.ToObject(type, value);
			}
			return new MetadataEnumValue(type, value);
		}

		private MetadataEnumValue(Type type, object value)
		{
			_type = type;
			_value = value;
		}
	}
	/// <summary>Performs comparison operations. This class belongs to the abstract syntax tree category.</summary>
	public class Equality : BinaryOp
	{
		private object metaData;

		internal Equality(Context context, AST operand1, AST operand2, JSToken operatorTok)
			: base(context, operand1, operand2, operatorTok)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Equality" /> class.</summary>
		/// <param name="operatorTok">One of the <see cref="T:Microsoft.JScript.JSToken" /> enumeration values. Specifies the comparison to perform.</param>
		public Equality(int operatorTok)
			: base(null, null, null, (JSToken)operatorTok)
		{
		}

		internal override object Evaluate()
		{
			bool flag = EvaluateEquality(operand1.Evaluate(), operand2.Evaluate(), VsaEngine.executeForJSEE);
			if (operatorTok == JSToken.Equal)
			{
				return flag;
			}
			return !flag;
		}

		/// <summary>Performs a comparison operation.</summary>
		/// <param name="v1">The first operand.</param>
		/// <param name="v2">The second operand.</param>
		/// <returns>The result of the operation.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public bool EvaluateEquality(object v1, object v2)
		{
			return EvaluateEquality(v1, v2, checkForDebuggerObjects: false);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		private bool EvaluateEquality(object v1, object v2, bool checkForDebuggerObjects)
		{
			if (v1 is string && v2 is string)
			{
				return v1.Equals(v2);
			}
			if (v1 is int && v2 is int)
			{
				return (int)v1 == (int)v2;
			}
			if (v1 is double && v2 is double)
			{
				return (double)v1 == (double)v2;
			}
			if ((v2 == null || v2 is DBNull || v2 is Missing) && !checkForDebuggerObjects)
			{
				if (v1 != null && !(v1 is DBNull))
				{
					return v1 is Missing;
				}
				return true;
			}
			IConvertible iConvertible = Convert.GetIConvertible(v1);
			IConvertible iConvertible2 = Convert.GetIConvertible(v2);
			TypeCode typeCode = Convert.GetTypeCode(v1, iConvertible);
			TypeCode typeCode2 = Convert.GetTypeCode(v2, iConvertible2);
			switch (typeCode)
			{
			case TypeCode.Object:
			{
				if (typeCode2 == TypeCode.Empty || typeCode2 == TypeCode.DBNull)
				{
					break;
				}
				MethodInfo operator2 = GetOperator(v1.GetType(), v2.GetType());
				if (operator2 != null)
				{
					bool flag2 = (bool)operator2.Invoke(null, BindingFlags.Default, JSBinder.ob, new object[2] { v1, v2 }, null);
					if (operatorTok == JSToken.NotEqual)
					{
						return !flag2;
					}
					return flag2;
				}
				break;
			}
			default:
			{
				if (typeCode2 != TypeCode.Object)
				{
					break;
				}
				MethodInfo @operator = GetOperator(v1.GetType(), v2.GetType());
				if (@operator != null)
				{
					bool flag = (bool)@operator.Invoke(null, BindingFlags.Default, JSBinder.ob, new object[2] { v1, v2 }, null);
					if (operatorTok == JSToken.NotEqual)
					{
						return !flag;
					}
					return flag;
				}
				break;
			}
			case TypeCode.Empty:
			case TypeCode.DBNull:
				break;
			}
			return JScriptEquals(v1, v2, iConvertible, iConvertible2, typeCode, typeCode2, checkForDebuggerObjects);
		}

		/// <summary>Performs a comparison operation.</summary>
		/// <param name="v1">The first operand.</param>
		/// <param name="v2">The second operand.</param>
		/// <returns>The result of the operation.</returns>
		public static bool JScriptEquals(object v1, object v2)
		{
			if (v1 is string && v2 is string)
			{
				return v1.Equals(v2);
			}
			if (v1 is int && v2 is int)
			{
				return (int)v1 == (int)v2;
			}
			if (v1 is double && v2 is double)
			{
				return (double)v1 == (double)v2;
			}
			if (v2 == null || v2 is DBNull || v2 is Missing)
			{
				if (v1 != null && !(v1 is DBNull))
				{
					return v1 is Missing;
				}
				return true;
			}
			IConvertible iConvertible = Convert.GetIConvertible(v1);
			IConvertible iConvertible2 = Convert.GetIConvertible(v2);
			TypeCode typeCode = Convert.GetTypeCode(v1, iConvertible);
			TypeCode typeCode2 = Convert.GetTypeCode(v2, iConvertible2);
			return JScriptEquals(v1, v2, iConvertible, iConvertible2, typeCode, typeCode2, checkForDebuggerObjects: false);
		}

		private static bool JScriptEquals(object v1, object v2, IConvertible ic1, IConvertible ic2, TypeCode t1, TypeCode t2, bool checkForDebuggerObjects)
		{
			if (StrictEquality.JScriptStrictEquals(v1, v2, ic1, ic2, t1, t2, checkForDebuggerObjects))
			{
				return true;
			}
			if (t2 == TypeCode.Boolean)
			{
				v2 = (ic2.ToBoolean(null) ? 1 : 0);
				ic2 = Convert.GetIConvertible(v2);
				return JScriptEquals(v1, v2, ic1, ic2, t1, TypeCode.Int32, checkForDebuggerObjects: false);
			}
			switch (t1)
			{
			case TypeCode.Empty:
				switch (t2)
				{
				case TypeCode.Object:
					return v2 is Missing;
				default:
					return false;
				case TypeCode.Empty:
				case TypeCode.DBNull:
					return true;
				}
			case TypeCode.Object:
				switch (t2)
				{
				case TypeCode.Empty:
				case TypeCode.DBNull:
					return v1 is Missing;
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
				case TypeCode.String:
				{
					IConvertible ic5 = ic1;
					object obj3 = Convert.ToPrimitive(v1, PreferredType.Either, ref ic5);
					if (ic5 != null && obj3 != v1)
					{
						return JScriptEquals(obj3, v2, ic5, ic2, ic5.GetTypeCode(), t2, checkForDebuggerObjects: false);
					}
					return false;
				}
				default:
					return false;
				}
			case TypeCode.DBNull:
				switch (t2)
				{
				case TypeCode.Object:
					return v2 is Missing;
				default:
					return false;
				case TypeCode.Empty:
				case TypeCode.DBNull:
					return true;
				}
			case TypeCode.Boolean:
				v1 = (ic1.ToBoolean(null) ? 1 : 0);
				ic1 = Convert.GetIConvertible(v1);
				return JScriptEquals(v1, v2, ic1, ic2, TypeCode.Int32, t2, checkForDebuggerObjects: false);
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.Decimal:
				switch (t2)
				{
				case TypeCode.Object:
				{
					IConvertible ic6 = ic2;
					object obj4 = Convert.ToPrimitive(v2, PreferredType.Either, ref ic6);
					if (ic6 != null && obj4 != v2)
					{
						return JScriptEquals(v1, obj4, ic1, ic6, t1, ic6.GetTypeCode(), checkForDebuggerObjects: false);
					}
					return false;
				}
				case TypeCode.String:
					if (v1 is Enum)
					{
						return Convert.ToString(v1).Equals(ic2.ToString(null));
					}
					v2 = Convert.ToNumber(v2, ic2);
					ic2 = Convert.GetIConvertible(v2);
					return StrictEquality.JScriptStrictEquals(v1, v2, ic1, ic2, t1, TypeCode.Double, checkForDebuggerObjects: false);
				default:
					return false;
				}
			case TypeCode.DateTime:
				if (t2 == TypeCode.Object)
				{
					IConvertible ic4 = ic2;
					object obj2 = Convert.ToPrimitive(v2, PreferredType.Either, ref ic4);
					if (obj2 != null && obj2 != v2)
					{
						return StrictEquality.JScriptStrictEquals(v1, obj2, ic1, ic4, t1, ic4.GetTypeCode(), checkForDebuggerObjects: false);
					}
				}
				return false;
			case TypeCode.String:
				switch (t2)
				{
				case TypeCode.Object:
				{
					IConvertible ic3 = ic2;
					object obj = Convert.ToPrimitive(v2, PreferredType.Either, ref ic3);
					if (ic3 != null && obj != v2)
					{
						return JScriptEquals(v1, obj, ic1, ic3, t1, ic3.GetTypeCode(), checkForDebuggerObjects: false);
					}
					return false;
				}
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					if (v2 is Enum)
					{
						return Convert.ToString(v2).Equals(ic1.ToString(null));
					}
					v1 = Convert.ToNumber(v1, ic1);
					ic1 = Convert.GetIConvertible(v1);
					return StrictEquality.JScriptStrictEquals(v1, v2, ic1, ic2, TypeCode.Double, t2, checkForDebuggerObjects: false);
				default:
					return false;
				}
			default:
				return false;
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return Typeob.Boolean;
		}

		internal override void TranslateToConditionalBranch(ILGenerator il, bool branchIfTrue, Label label, bool shortForm)
		{
			if (metaData == null)
			{
				Type type = type1;
				Type type2 = base.type2;
				Type type3 = Typeob.Object;
				bool flag = true;
				if (type.IsPrimitive && type2.IsPrimitive)
				{
					type3 = Typeob.Double;
					if (type == Typeob.Single || type2 == Typeob.Single)
					{
						type3 = Typeob.Single;
					}
					else if (Convert.IsPromotableTo(type, type2))
					{
						type3 = type2;
					}
					else if (Convert.IsPromotableTo(type2, type))
					{
						type3 = type;
					}
				}
				else if (type == Typeob.String && (type2 == Typeob.String || type2 == Typeob.Empty || type2 == Typeob.Null))
				{
					type3 = Typeob.String;
					if (type2 != Typeob.String)
					{
						flag = false;
						branchIfTrue = !branchIfTrue;
					}
				}
				else if ((type == Typeob.Empty || type == Typeob.Null) && type2 == Typeob.String)
				{
					type3 = Typeob.String;
					flag = false;
					branchIfTrue = !branchIfTrue;
				}
				if (type3 == Typeob.SByte || type3 == Typeob.Int16)
				{
					type3 = Typeob.Int32;
				}
				else if (type3 == Typeob.Byte || type3 == Typeob.UInt16)
				{
					type3 = Typeob.UInt32;
				}
				if (flag)
				{
					operand1.TranslateToIL(il, type3);
					operand2.TranslateToIL(il, type3);
					if (type3 == Typeob.Object)
					{
						il.Emit(OpCodes.Call, CompilerGlobals.jScriptEqualsMethod);
					}
					else if (type3 == Typeob.String)
					{
						il.Emit(OpCodes.Call, CompilerGlobals.stringEqualsMethod);
					}
				}
				else if (type == Typeob.String)
				{
					operand1.TranslateToIL(il, type3);
				}
				else if (type2 == Typeob.String)
				{
					operand2.TranslateToIL(il, type3);
				}
				if (branchIfTrue)
				{
					if (operatorTok == JSToken.Equal)
					{
						if (type3 == Typeob.String || type3 == Typeob.Object)
						{
							il.Emit(shortForm ? OpCodes.Brtrue_S : OpCodes.Brtrue, label);
						}
						else
						{
							il.Emit(shortForm ? OpCodes.Beq_S : OpCodes.Beq, label);
						}
					}
					else if (type3 == Typeob.String || type3 == Typeob.Object)
					{
						il.Emit(shortForm ? OpCodes.Brfalse_S : OpCodes.Brfalse, label);
					}
					else
					{
						il.Emit(shortForm ? OpCodes.Bne_Un_S : OpCodes.Bne_Un, label);
					}
				}
				else if (operatorTok == JSToken.Equal)
				{
					if (type3 == Typeob.String || type3 == Typeob.Object)
					{
						il.Emit(shortForm ? OpCodes.Brfalse_S : OpCodes.Brfalse, label);
					}
					else
					{
						il.Emit(shortForm ? OpCodes.Bne_Un_S : OpCodes.Bne_Un, label);
					}
				}
				else if (type3 == Typeob.String || type3 == Typeob.Object)
				{
					il.Emit(shortForm ? OpCodes.Brtrue_S : OpCodes.Brtrue, label);
				}
				else
				{
					il.Emit(shortForm ? OpCodes.Beq_S : OpCodes.Beq, label);
				}
				return;
			}
			if (metaData is MethodInfo)
			{
				MethodInfo methodInfo = (MethodInfo)metaData;
				ParameterInfo[] parameters = methodInfo.GetParameters();
				operand1.TranslateToIL(il, parameters[0].ParameterType);
				operand2.TranslateToIL(il, parameters[1].ParameterType);
				il.Emit(OpCodes.Call, methodInfo);
				if (branchIfTrue)
				{
					il.Emit(shortForm ? OpCodes.Brtrue_S : OpCodes.Brtrue, label);
				}
				else
				{
					il.Emit(shortForm ? OpCodes.Brfalse_S : OpCodes.Brfalse, label);
				}
				return;
			}
			il.Emit(OpCodes.Ldloc, (LocalBuilder)metaData);
			operand1.TranslateToIL(il, Typeob.Object);
			operand2.TranslateToIL(il, Typeob.Object);
			il.Emit(OpCodes.Call, CompilerGlobals.evaluateEqualityMethod);
			if (branchIfTrue)
			{
				if (operatorTok == JSToken.Equal)
				{
					il.Emit(shortForm ? OpCodes.Brtrue_S : OpCodes.Brtrue, label);
				}
				else
				{
					il.Emit(shortForm ? OpCodes.Brfalse_S : OpCodes.Brfalse, label);
				}
			}
			else if (operatorTok == JSToken.Equal)
			{
				il.Emit(shortForm ? OpCodes.Brfalse_S : OpCodes.Brfalse, label);
			}
			else
			{
				il.Emit(shortForm ? OpCodes.Brtrue_S : OpCodes.Brtrue, label);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Label label = il.DefineLabel();
			Label label2 = il.DefineLabel();
			TranslateToConditionalBranch(il, branchIfTrue: true, label, shortForm: true);
			il.Emit(OpCodes.Ldc_I4_0);
			il.Emit(OpCodes.Br_S, label2);
			il.MarkLabel(label);
			il.Emit(OpCodes.Ldc_I4_1);
			il.MarkLabel(label2);
			Convert.Emit(this, il, Typeob.Boolean, rtype);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			operand1.TranslateToILInitializer(il);
			operand2.TranslateToILInitializer(il);
			MethodInfo @operator = GetOperator(operand1.InferType(null), operand2.InferType(null));
			if (@operator != null)
			{
				metaData = @operator;
				return;
			}
			if (operand1 is ConstantWrapper)
			{
				object obj = operand1.Evaluate();
				if (obj == null)
				{
					type1 = Typeob.Empty;
				}
				else if (obj is DBNull)
				{
					type1 = Typeob.Null;
				}
			}
			if (operand2 is ConstantWrapper)
			{
				object obj2 = operand2.Evaluate();
				if (obj2 == null)
				{
					type2 = Typeob.Empty;
				}
				else if (obj2 is DBNull)
				{
					type2 = Typeob.Null;
				}
			}
			if (!(type1 == Typeob.Empty) && !(type1 == Typeob.Null) && !(type2 == Typeob.Empty) && !(type2 == Typeob.Null) && ((!type1.IsPrimitive && !(type1 == Typeob.String) && !Typeob.JSObject.IsAssignableFrom(type1)) || (!type2.IsPrimitive && !(type2 == Typeob.String) && !Typeob.JSObject.IsAssignableFrom(type2))))
			{
				metaData = il.DeclareLocal(Typeob.Equality);
				ConstantWrapper.TranslateToILInt(il, (int)operatorTok);
				il.Emit(OpCodes.Newobj, CompilerGlobals.equalityConstructor);
				il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
			}
		}
	}
	/// <summary>Specifies the JScript error types.</summary>
	public enum ErrorType
	{
		/// <summary>Any error other than one of the other error types. This is the default value.</summary>
		OtherError,
		/// <summary>An eval Method (Visual Studio - JScript) error. Corresponds to the <see cref="T:Microsoft.JScript.EvalErrorObject" /> object.</summary>
		EvalError,
		/// <summary>A range error. Corresponds to the <see cref="T:Microsoft.JScript.RangeErrorObject" /> object.</summary>
		RangeError,
		/// <summary>A reference error. Corresponds to the <see cref="T:Microsoft.JScript.ReferenceErrorObject" /> object.</summary>
		ReferenceError,
		/// <summary>A syntax error. Corresponds to the <see cref="T:Microsoft.JScript.SyntaxErrorObject" /> object.</summary>
		SyntaxError,
		/// <summary>A type error. Corresponds to the <see cref="T:Microsoft.JScript.TypeErrorObject" /> object.</summary>
		TypeError,
		/// <summary>A Uniform Resource Identifier (URI) error. Corresponds to the <see cref="T:Microsoft.JScript.URIErrorObject" /> object.</summary>
		URIError
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public sealed class ErrorConstructor : ScriptFunction
	{
		internal static readonly ErrorConstructor ob = new ErrorConstructor();

		internal static readonly ErrorConstructor evalOb = new ErrorConstructor("EvalError", ErrorType.EvalError);

		internal static readonly ErrorConstructor rangeOb = new ErrorConstructor("RangeError", ErrorType.RangeError);

		internal static readonly ErrorConstructor referenceOb = new ErrorConstructor("ReferenceError", ErrorType.ReferenceError);

		internal static readonly ErrorConstructor syntaxOb = new ErrorConstructor("SyntaxError", ErrorType.SyntaxError);

		internal static readonly ErrorConstructor typeOb = new ErrorConstructor("TypeError", ErrorType.TypeError);

		internal static readonly ErrorConstructor uriOb = new ErrorConstructor("URIError", ErrorType.URIError);

		private ErrorPrototype originalPrototype;

		private ErrorType type;

		private GlobalObject globalObject;

		internal ErrorConstructor()
			: base(ErrorPrototype.ob, "Error", 2)
		{
			originalPrototype = ErrorPrototype.ob;
			ErrorPrototype.ob._constructor = this;
			proto = ErrorPrototype.ob;
			type = ErrorType.OtherError;
			globalObject = GlobalObject.commonInstance;
		}

		internal ErrorConstructor(LenientFunctionPrototype parent, LenientErrorPrototype prototypeProp, GlobalObject globalObject)
			: base(parent, "Error", 2)
		{
			originalPrototype = prototypeProp;
			prototypeProp.constructor = this;
			proto = prototypeProp;
			type = ErrorType.OtherError;
			this.globalObject = globalObject;
			noExpando = false;
		}

		internal ErrorConstructor(string subtypeName, ErrorType type)
			: base(ob.parent, subtypeName, 2)
		{
			originalPrototype = new ErrorPrototype(ob.originalPrototype, subtypeName);
			originalPrototype._constructor = this;
			proto = originalPrototype;
			this.type = type;
			globalObject = GlobalObject.commonInstance;
		}

		internal ErrorConstructor(string subtypeName, ErrorType type, ErrorConstructor error, GlobalObject globalObject)
			: base(error.parent, subtypeName, 2)
		{
			originalPrototype = new LenientErrorPrototype((LenientFunctionPrototype)error.parent, error.originalPrototype, subtypeName);
			noExpando = false;
			originalPrototype._constructor = this;
			proto = originalPrototype;
			this.type = type;
			this.globalObject = globalObject;
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			return Construct(args);
		}

		internal override object Construct(object[] args)
		{
			return CreateInstance(args);
		}

		internal ErrorObject Construct(object e)
		{
			if (!(e is JScriptException) || this != globalObject.originalError)
			{
				return type switch
				{
					ErrorType.EvalError => new EvalErrorObject(originalPrototype, e), 
					ErrorType.RangeError => new RangeErrorObject(originalPrototype, e), 
					ErrorType.ReferenceError => new ReferenceErrorObject(originalPrototype, e), 
					ErrorType.SyntaxError => new SyntaxErrorObject(originalPrototype, e), 
					ErrorType.TypeError => new TypeErrorObject(originalPrototype, e), 
					ErrorType.URIError => new URIErrorObject(originalPrototype, e), 
					_ => new ErrorObject(originalPrototype, e), 
				};
			}
			return ((JScriptException)e).GetErrorType() switch
			{
				ErrorType.EvalError => globalObject.originalEvalError.Construct(e), 
				ErrorType.RangeError => globalObject.originalRangeError.Construct(e), 
				ErrorType.ReferenceError => globalObject.originalReferenceError.Construct(e), 
				ErrorType.SyntaxError => globalObject.originalSyntaxError.Construct(e), 
				ErrorType.TypeError => globalObject.originalTypeError.Construct(e), 
				ErrorType.URIError => globalObject.originalURIError.Construct(e), 
				_ => new ErrorObject(originalPrototype, e), 
			};
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>The instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new ErrorObject CreateInstance(params object[] args)
		{
			return type switch
			{
				ErrorType.EvalError => new EvalErrorObject(originalPrototype, args), 
				ErrorType.RangeError => new RangeErrorObject(originalPrototype, args), 
				ErrorType.ReferenceError => new ReferenceErrorObject(originalPrototype, args), 
				ErrorType.SyntaxError => new SyntaxErrorObject(originalPrototype, args), 
				ErrorType.TypeError => new TypeErrorObject(originalPrototype, args), 
				ErrorType.URIError => new URIErrorObject(originalPrototype, args), 
				_ => new ErrorObject(originalPrototype, args), 
			};
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>The instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public object Invoke(params object[] args)
		{
			return CreateInstance(args);
		}
	}
	/// <summary>Represents an error object. This class belongs to the built-in object model category.</summary>
	public class ErrorObject : JSObject
	{
		/// <summary>Specifies the message that explains the reason for the error.</summary>
		public object message;

		/// <summary>Specifies a number or code for the error.</summary>
		public object number;

		/// <summary>Specifies the message that explains the reason for the error.</summary>
		public object description;

		internal object exception;

		internal string Message => Convert.ToString(message);

		internal ErrorObject(ErrorPrototype parent, object[] args)
			: base(parent)
		{
			exception = null;
			description = "";
			number = 0;
			if (args.Length == 1)
			{
				if (args[0] == null || Convert.IsPrimitiveNumericType(args[0].GetType()))
				{
					number = Convert.ToNumber(args[0]);
				}
				else
				{
					description = Convert.ToString(args[0]);
				}
			}
			else if (args.Length > 1)
			{
				number = Convert.ToNumber(args[0]);
				description = Convert.ToString(args[1]);
			}
			message = description;
			noExpando = false;
		}

		internal ErrorObject(ErrorPrototype parent, object e)
			: base(parent)
		{
			exception = e;
			number = -2146823266;
			if (e is Exception)
			{
				if (e is JScriptException)
				{
					number = ((JScriptException)e).Number;
				}
				else if (e is ExternalException)
				{
					number = ((ExternalException)e).ErrorCode;
				}
				description = ((Exception)e).Message;
				if (((string)description).Length == 0)
				{
					description = e.GetType().FullName;
				}
			}
			message = description;
			noExpando = false;
		}

		internal override string GetClassName()
		{
			return "Error";
		}

		/// <summary>Converts an <see cref="T:Microsoft.JScript.ErrorObject" /> to an <see cref="T:System.Exception" />, explicitly.</summary>
		/// <param name="err">The object to convert.</param>
		/// <returns>The converted <see cref="T:Microsoft.JScript.ErrorObject" />.</returns>
		public static explicit operator Exception(ErrorObject err)
		{
			return err.exception as Exception;
		}

		/// <summary>Converts an <see cref="T:Microsoft.JScript.ErrorObject" /> to an <see cref="T:System.Exception" />, implicitly.</summary>
		/// <param name="err">The object to convert.</param>
		/// <returns>The converted <see cref="T:Microsoft.JScript.ErrorObject" />.</returns>
		public static Exception ToException(ErrorObject err)
		{
			return (Exception)err;
		}
	}
	/// <summary>Provides static methods and properties for <see cref="T:Microsoft.JScript.ErrorObject" /> objects. All methods of this class are called by passing in a reference to the object that is requesting access to the method. This class belongs to the built-in object model category.</summary>
	public class ErrorPrototype : JSObject
	{
		/// <summary>Specifies the name of the type of the error. Possible values include Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, and URIError.</summary>
		public readonly string name;

		internal static readonly ErrorPrototype ob = new ErrorPrototype(ObjectPrototype.ob, "Error");

		internal ErrorConstructor _constructor;

		/// <summary>Gets a reference to a prototype-based object that is using this prototype.</summary>
		/// <returns>A reference to a prototype-based object.</returns>
		public ErrorConstructor constructor => _constructor;

		internal ErrorPrototype(ScriptObject parent, string name)
			: base(parent)
		{
			this.name = name;
		}

		/// <summary>Creates a string representation of the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" /> that contains the name of the type of the error object, and an error message if there is one.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Error_toString)]
		public static string toString(object thisob)
		{
			if (thisob is ErrorObject)
			{
				string message = ((ErrorObject)thisob).Message;
				if (message.Length == 0)
				{
					return LateBinding.GetMemberValue(thisob, "name").ToString();
				}
				return LateBinding.GetMemberValue(thisob, "name").ToString() + ": " + message;
			}
			return thisob.ToString();
		}
	}
	/// <summary>Evaluates JScript code. This class belongs to the abstract syntax tree category.</summary>
	public sealed class Eval : AST
	{
		private AST operand;

		private AST unsafeOption;

		private FunctionScope enclosingFunctionScope;

		internal Eval(Context context, AST operand, AST unsafeOption)
			: base(context)
		{
			this.operand = operand;
			this.unsafeOption = unsafeOption;
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			((IActivationObject)scriptObject).GetGlobalScope().evilScript = true;
			if (scriptObject is ActivationObject)
			{
				((ActivationObject)scriptObject).isKnownAtCompileTime = base.Engine.doFast;
			}
			if (scriptObject is FunctionScope)
			{
				enclosingFunctionScope = (FunctionScope)scriptObject;
				enclosingFunctionScope.mustSaveStackLocals = true;
				for (ScriptObject parent = enclosingFunctionScope.GetParent(); parent != null; parent = parent.GetParent())
				{
					if (parent is FunctionScope functionScope)
					{
						functionScope.mustSaveStackLocals = true;
						functionScope.closuresMightEscape = true;
					}
				}
			}
			else
			{
				enclosingFunctionScope = null;
			}
		}

		internal override void CheckIfOKToUseInSuperConstructorCall()
		{
			context.HandleError(JSError.NotAllowedInSuperConstructorCall);
		}

		internal override object Evaluate()
		{
			if (VsaEngine.executeForJSEE)
			{
				throw new JScriptException(JSError.NonSupportedInDebugger);
			}
			object obj = operand.Evaluate();
			object obj2 = null;
			if (unsafeOption != null)
			{
				obj2 = unsafeOption.Evaluate();
			}
			base.Globals.CallContextStack.Push(new CallContext(context, null, new object[2] { obj, obj2 }));
			try
			{
				return JScriptEvaluate(obj, obj2, base.Engine);
			}
			catch (JScriptException ex)
			{
				if (ex.context == null)
				{
					ex.context = context;
				}
				throw ex;
			}
			catch (Exception e)
			{
				throw new JScriptException(e, context);
			}
			finally
			{
				base.Globals.CallContextStack.Pop();
			}
		}

		/// <summary>Evaluates the specified JScript code by using the specified engine.</summary>
		/// <param name="source">The code to evaluate.</param>
		/// <param name="engine">A reference to the scripting engine to use to evaluate <paramref name="source" />.</param>
		/// <returns>The result of the evaluation. If <paramref name="source" /> is not a string, return value is <paramref name="source" />.</returns>
		public static object JScriptEvaluate(object source, VsaEngine engine)
		{
			if (Convert.GetTypeCode(source) != TypeCode.String)
			{
				return source;
			}
			return DoEvaluate(source, engine, isUnsafe: true);
		}

		/// <summary>Evaluates the specified JScript code by using the specified engine and safety option.</summary>
		/// <param name="source">The code to evaluate.</param>
		/// <param name="unsafeOption">The string literal <c>unsafe</c> to enable unsafe evaluation; otherwise, <see langword="false" />.</param>
		/// <param name="engine">A reference to the scripting engine to use to evaluate <paramref name="source" />.</param>
		/// <returns>The result of the evaluation. If <paramref name="source" /> is not a string, return value is <paramref name="source" />.</returns>
		public static object JScriptEvaluate(object source, object unsafeOption, VsaEngine engine)
		{
			if (Convert.GetTypeCode(source) != TypeCode.String)
			{
				return source;
			}
			bool isUnsafe = false;
			if (Convert.GetTypeCode(unsafeOption) == TypeCode.String && ((IConvertible)unsafeOption).ToString() == "unsafe")
			{
				isUnsafe = true;
			}
			return DoEvaluate(source, engine, isUnsafe);
		}

		private static object DoEvaluate(object source, VsaEngine engine, bool isUnsafe)
		{
			if (engine.doFast)
			{
				engine.PushScriptObject(new BlockScope(engine.ScriptObjectStackTop()));
			}
			try
			{
				Context context = new Context(new DocumentContext("eval code", engine), ((IConvertible)source).ToString());
				JSParser jSParser = new JSParser(context);
				return ((Completion)jSParser.ParseEvalBody().PartiallyEvaluate().Evaluate()).value;
			}
			finally
			{
				if (engine.doFast)
				{
					engine.PopScriptObject();
				}
			}
		}

		internal override AST PartiallyEvaluate()
		{
			VsaEngine engine = base.Engine;
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			ClassScope classScope = ClassScope.ScopeOfClassMemberInitializer(scriptObject);
			if (classScope != null)
			{
				if (classScope.inStaticInitializerCode)
				{
					classScope.staticInitializerUsesEval = true;
				}
				else
				{
					classScope.instanceInitializerUsesEval = true;
				}
			}
			if (engine.doFast)
			{
				engine.PushScriptObject(new BlockScope(scriptObject));
			}
			else
			{
				while (scriptObject is WithObject || scriptObject is BlockScope)
				{
					if (scriptObject is BlockScope)
					{
						((BlockScope)scriptObject).isKnownAtCompileTime = false;
					}
					scriptObject = scriptObject.GetParent();
				}
			}
			try
			{
				operand = operand.PartiallyEvaluate();
				if (unsafeOption != null)
				{
					unsafeOption = unsafeOption.PartiallyEvaluate();
				}
				if (enclosingFunctionScope != null && enclosingFunctionScope.owner == null)
				{
					context.HandleError(JSError.NotYetImplemented);
				}
				return this;
			}
			finally
			{
				if (engine.doFast)
				{
					base.Engine.PopScriptObject();
				}
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (enclosingFunctionScope != null && enclosingFunctionScope.owner != null)
			{
				enclosingFunctionScope.owner.TranslateToILToSaveLocals(il);
			}
			operand.TranslateToIL(il, Typeob.Object);
			MethodInfo methodInfo = null;
			if (unsafeOption is ConstantWrapper constantWrapper && constantWrapper.value is string text && text == "unsafe")
			{
				methodInfo = CompilerGlobals.jScriptEvaluateMethod1;
			}
			if (methodInfo == null)
			{
				methodInfo = CompilerGlobals.jScriptEvaluateMethod2;
				if (unsafeOption == null)
				{
					il.Emit(OpCodes.Ldnull);
				}
				else
				{
					unsafeOption.TranslateToIL(il, Typeob.Object);
				}
			}
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, methodInfo);
			Convert.Emit(this, il, Typeob.Object, rtype);
			if (enclosingFunctionScope != null && enclosingFunctionScope.owner != null)
			{
				enclosingFunctionScope.owner.TranslateToILToRestoreLocals(il);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			operand.TranslateToILInitializer(il);
			if (unsafeOption != null)
			{
				unsafeOption.TranslateToILInitializer(il);
			}
		}
	}
	/// <summary>Represents an error that occurs when the <see langword="eval" /> method is used. For more information, see eval Method (Visual Studio - JScript).</summary>
	public sealed class EvalErrorObject : ErrorObject
	{
		internal EvalErrorObject(ErrorPrototype parent, object[] args)
			: base(parent, args)
		{
		}

		internal EvalErrorObject(ErrorPrototype parent, object e)
			: base(parent, e)
		{
		}
	}
	/// <summary>Indicates that a class or method is an expando class or method.</summary>
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited = true)]
	public class Expando : Attribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Expando" /> attribute class.</summary>
		public Expando()
		{
		}
	}
	internal sealed class Expression : AST
	{
		internal AST operand;

		private Completion completion;

		internal Expression(Context context, AST operand)
			: base(context)
		{
			this.operand = operand;
			completion = new Completion();
		}

		internal override object Evaluate()
		{
			completion.value = operand.Evaluate();
			return completion;
		}

		internal override AST PartiallyEvaluate()
		{
			operand = operand.PartiallyEvaluate();
			if (operand is ConstantWrapper)
			{
				operand.context.HandleError(JSError.UselessExpression);
			}
			else if (operand is Binding)
			{
				((Binding)operand).CheckIfUseless();
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			context.EmitLineInfo(il);
			operand.TranslateToIL(il, rtype);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			operand.TranslateToILInitializer(il);
		}
	}
	/// <summary>Represents a field accessor.</summary>
	public abstract class FieldAccessor
	{
		private static SimpleHashtable accessorFor = new SimpleHashtable(32u);

		private static int count = 0;

		/// <summary>When overridden in a derived class, gets the value of the field for the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The value of the field for <paramref name="thisob" />.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public abstract object GetValue(object thisob);

		/// <summary>When overridden in a derived class, sets the specified value of the field for the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="value">The value to set for the field.</param>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public abstract void SetValue(object thisob, object value);

		internal static FieldAccessor GetAccessorFor(FieldInfo field)
		{
			if (accessorFor[field] is FieldAccessor result)
			{
				return result;
			}
			lock (accessorFor)
			{
				if (accessorFor[field] is FieldAccessor result2)
				{
					return result2;
				}
				FieldAccessor fieldAccessor = SpitAndInstantiateClassFor(field);
				accessorFor[field] = fieldAccessor;
				return fieldAccessor;
			}
		}

		[ReflectionPermission(SecurityAction.Assert, Unrestricted = true)]
		private static FieldAccessor SpitAndInstantiateClassFor(FieldInfo field)
		{
			Type fieldType = field.FieldType;
			TypeBuilder typeBuilder = Runtime.ThunkModuleBuilder.DefineType("accessor" + count++, TypeAttributes.Public, typeof(FieldAccessor));
			MethodBuilder methodBuilder = typeBuilder.DefineMethod("GetValue", MethodAttributes.Public | MethodAttributes.Virtual, typeof(object), new Type[1] { typeof(object) });
			methodBuilder.SetCustomAttribute(new CustomAttributeBuilder(Runtime.TypeRefs.debuggerStepThroughAttributeCtor, new object[0]));
			methodBuilder.SetCustomAttribute(new CustomAttributeBuilder(Runtime.TypeRefs.debuggerHiddenAttributeCtor, new object[0]));
			ILGenerator iLGenerator = methodBuilder.GetILGenerator();
			if (field.IsLiteral)
			{
				new ConstantWrapper(TypeReferences.GetConstantValue(field), null).TranslateToIL(iLGenerator, fieldType);
			}
			else if (field.IsStatic)
			{
				iLGenerator.Emit(OpCodes.Ldsfld, field);
			}
			else
			{
				iLGenerator.Emit(OpCodes.Ldarg_1);
				iLGenerator.Emit(OpCodes.Ldfld, field);
			}
			if (fieldType.IsValueType)
			{
				iLGenerator.Emit(OpCodes.Box, fieldType);
			}
			iLGenerator.Emit(OpCodes.Ret);
			methodBuilder = typeBuilder.DefineMethod("SetValue", MethodAttributes.Public | MethodAttributes.Virtual, typeof(void), new Type[2]
			{
				typeof(object),
				typeof(object)
			});
			methodBuilder.SetCustomAttribute(new CustomAttributeBuilder(Runtime.TypeRefs.debuggerStepThroughAttributeCtor, new object[0]));
			methodBuilder.SetCustomAttribute(new CustomAttributeBuilder(Runtime.TypeRefs.debuggerHiddenAttributeCtor, new object[0]));
			iLGenerator = methodBuilder.GetILGenerator();
			if (!field.IsLiteral)
			{
				if (!field.IsStatic)
				{
					iLGenerator.Emit(OpCodes.Ldarg_1);
				}
				iLGenerator.Emit(OpCodes.Ldarg_2);
				if (fieldType.IsValueType)
				{
					Convert.EmitUnbox(iLGenerator, fieldType, Type.GetTypeCode(fieldType));
				}
				if (field.IsStatic)
				{
					iLGenerator.Emit(OpCodes.Stsfld, field);
				}
				else
				{
					iLGenerator.Emit(OpCodes.Stfld, field);
				}
			}
			iLGenerator.Emit(OpCodes.Ret);
			Type type = typeBuilder.CreateType();
			return (FieldAccessor)Activator.CreateInstance(type);
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.FieldAccessor" /> class.</summary>
		protected FieldAccessor()
		{
		}
	}
	internal sealed class For : AST
	{
		private AST initializer;

		private AST condition;

		private AST incrementer;

		private AST body;

		private Completion completion;

		internal For(Context context, AST initializer, AST condition, AST incrementer, AST body)
			: base(context)
		{
			this.initializer = initializer;
			this.condition = condition;
			this.incrementer = incrementer;
			this.body = body;
			completion = new Completion();
		}

		internal override object Evaluate()
		{
			this.completion.Continue = 0;
			this.completion.Exit = 0;
			this.completion.value = null;
			initializer.Evaluate();
			while (Convert.ToBoolean(condition.Evaluate()))
			{
				Completion completion = (Completion)body.Evaluate();
				if (completion.value != null)
				{
					this.completion.value = completion.value;
				}
				if (completion.Continue > 1)
				{
					this.completion.Continue = completion.Continue - 1;
					break;
				}
				if (completion.Exit > 0)
				{
					this.completion.Exit = completion.Exit - 1;
					break;
				}
				if (completion.Return)
				{
					return completion;
				}
				incrementer.Evaluate();
			}
			return this.completion;
		}

		internal override AST PartiallyEvaluate()
		{
			initializer = initializer.PartiallyEvaluate();
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is FunctionScope)
			{
				FunctionScope functionScope = (FunctionScope)scriptObject;
				BitArray definedFlags = functionScope.DefinedFlags;
				condition = condition.PartiallyEvaluate();
				body = body.PartiallyEvaluate();
				functionScope.DefinedFlags = definedFlags;
				incrementer = incrementer.PartiallyEvaluate();
				functionScope.DefinedFlags = definedFlags;
			}
			else
			{
				condition = condition.PartiallyEvaluate();
				body = body.PartiallyEvaluate();
				incrementer = incrementer.PartiallyEvaluate();
			}
			IReflect reflect = condition.InferType(null);
			if (reflect is FunctionPrototype || reflect == Typeob.ScriptFunction)
			{
				context.HandleError(JSError.SuspectLoopCondition);
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Label label = il.DefineLabel();
			Label label2 = il.DefineLabel();
			Label label3 = il.DefineLabel();
			Label label4 = il.DefineLabel();
			bool flag = false;
			base.compilerGlobals.BreakLabelStack.Push(label4);
			base.compilerGlobals.ContinueLabelStack.Push(label2);
			if (!(initializer is EmptyLiteral))
			{
				initializer.context.EmitLineInfo(il);
				initializer.TranslateToIL(il, Typeob.Void);
			}
			il.MarkLabel(label);
			if (!(condition is ConstantWrapper) || !(condition.Evaluate() is bool) || !(bool)condition.Evaluate())
			{
				condition.context.EmitLineInfo(il);
				condition.TranslateToConditionalBranch(il, branchIfTrue: false, label4, shortForm: false);
			}
			else if (condition.context.StartPosition + 1 == condition.context.EndPosition)
			{
				flag = true;
			}
			body.TranslateToIL(il, Typeob.Void);
			il.MarkLabel(label2);
			if (!(incrementer is EmptyLiteral))
			{
				incrementer.context.EmitLineInfo(il);
				incrementer.TranslateToIL(il, Typeob.Void);
			}
			else if (flag)
			{
				context.EmitLineInfo(il);
			}
			il.Emit(OpCodes.Br, label);
			il.MarkLabel(label4);
			base.compilerGlobals.BreakLabelStack.Pop();
			base.compilerGlobals.ContinueLabelStack.Pop();
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			initializer.TranslateToILInitializer(il);
			condition.TranslateToILInitializer(il);
			incrementer.TranslateToILInitializer(il);
			body.TranslateToILInitializer(il);
		}
	}
	/// <summary>Represents the JScript <see langword="for...in" /> statement. This class belongs to the abstract syntax tree category.</summary>
	public sealed class ForIn : AST
	{
		private AST var;

		private AST initializer;

		private AST collection;

		private AST body;

		private Completion completion;

		private Context inExpressionContext;

		internal ForIn(Context context, AST var, AST initializer, AST collection, AST body)
			: base(context)
		{
			if (var != null)
			{
				this.var = var;
				inExpressionContext = this.var.context.Clone();
			}
			else
			{
				VariableDeclaration variableDeclaration = (VariableDeclaration)initializer;
				this.var = variableDeclaration.identifier;
				if (variableDeclaration.initializer == null)
				{
					variableDeclaration.initializer = new ConstantWrapper(null, null);
				}
				inExpressionContext = initializer.context.Clone();
			}
			this.initializer = initializer;
			this.collection = collection;
			inExpressionContext.UpdateWith(this.collection.context);
			this.body = body;
			completion = new Completion();
		}

		internal override object Evaluate()
		{
			AST aST = var;
			if (initializer != null)
			{
				initializer.Evaluate();
			}
			this.completion.Continue = 0;
			this.completion.Exit = 0;
			this.completion.value = null;
			object obj = Convert.ToForInObject(collection.Evaluate(), base.Engine);
			bool flag = obj is ScriptObject;
			IEnumerator enumerator = null;
			try
			{
				enumerator = JScriptGetEnumerator(obj);
			}
			catch (JScriptException ex)
			{
				ex.context = collection.context;
				throw ex;
			}
			while (enumerator.MoveNext())
			{
				aST.SetValue(enumerator.Current);
				Completion completion = (Completion)body.Evaluate();
				this.completion.value = completion.value;
				if (completion.Continue > 1)
				{
					this.completion.Continue = completion.Continue - 1;
					break;
				}
				if (completion.Exit > 0)
				{
					this.completion.Exit = completion.Exit - 1;
					break;
				}
				if (completion.Return)
				{
					return completion;
				}
			}
			return this.completion;
		}

		/// <summary>Returns an enumerator that iterates through the specified collection.</summary>
		/// <param name="coll">The collection for which to get an enumerator.</param>
		/// <returns>An enumerator that iterates through <paramref name="coll" />.</returns>
		public static IEnumerator JScriptGetEnumerator(object coll)
		{
			if (coll is IEnumerator)
			{
				return (IEnumerator)coll;
			}
			if (coll is ScriptObject)
			{
				return new ScriptObjectPropertyEnumerator((ScriptObject)coll);
			}
			if (coll is Array)
			{
				Array array = (Array)coll;
				return new RangeEnumerator(array.GetLowerBound(0), array.GetUpperBound(0));
			}
			if (coll is IEnumerable)
			{
				IEnumerator enumerator = ((IEnumerable)coll).GetEnumerator();
				if (enumerator != null)
				{
					return enumerator;
				}
				return new ScriptObjectPropertyEnumerator(new JSObject());
			}
			throw new JScriptException(JSError.NotCollection);
		}

		internal override AST PartiallyEvaluate()
		{
			var = var.PartiallyEvaluateAsReference();
			var.SetPartialValue(new ConstantWrapper(null, null));
			if (initializer != null)
			{
				initializer = initializer.PartiallyEvaluate();
			}
			collection = collection.PartiallyEvaluate();
			IReflect reflect = collection.InferType(null);
			if ((reflect is ClassScope && ((ClassScope)reflect).noExpando && !((ClassScope)reflect).ImplementsInterface(Typeob.IEnumerable)) || (reflect != Typeob.Object && reflect is Type && !Typeob.ScriptObject.IsAssignableFrom((Type)reflect) && !Typeob.IEnumerable.IsAssignableFrom((Type)reflect) && !Typeob.IConvertible.IsAssignableFrom((Type)reflect) && !Typeob.IEnumerator.IsAssignableFrom((Type)reflect)))
			{
				collection.context.HandleError(JSError.NotCollection);
			}
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is FunctionScope)
			{
				FunctionScope functionScope = (FunctionScope)scriptObject;
				BitArray definedFlags = functionScope.DefinedFlags;
				body = body.PartiallyEvaluate();
				functionScope.DefinedFlags = definedFlags;
			}
			else
			{
				body = body.PartiallyEvaluate();
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Label label = il.DefineLabel();
			Label label2 = il.DefineLabel();
			Label label3 = il.DefineLabel();
			base.compilerGlobals.BreakLabelStack.Push(label2);
			base.compilerGlobals.ContinueLabelStack.Push(label);
			if (initializer != null)
			{
				initializer.TranslateToIL(il, Typeob.Void);
			}
			inExpressionContext.EmitLineInfo(il);
			collection.TranslateToIL(il, Typeob.Object);
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.toForInObjectMethod);
			il.Emit(OpCodes.Call, CompilerGlobals.jScriptGetEnumeratorMethod);
			LocalBuilder local = il.DeclareLocal(Typeob.IEnumerator);
			il.Emit(OpCodes.Stloc, local);
			il.Emit(OpCodes.Br, label);
			il.MarkLabel(label3);
			body.TranslateToIL(il, Typeob.Void);
			il.MarkLabel(label);
			context.EmitLineInfo(il);
			il.Emit(OpCodes.Ldloc, local);
			il.Emit(OpCodes.Callvirt, CompilerGlobals.moveNextMethod);
			il.Emit(OpCodes.Brfalse, label2);
			il.Emit(OpCodes.Ldloc, local);
			il.Emit(OpCodes.Callvirt, CompilerGlobals.getCurrentMethod);
			Type type = Convert.ToType(var.InferType(null));
			LocalBuilder local2 = il.DeclareLocal(type);
			Convert.Emit(this, il, Typeob.Object, type);
			il.Emit(OpCodes.Stloc, local2);
			var.TranslateToILPreSet(il);
			il.Emit(OpCodes.Ldloc, local2);
			var.TranslateToILSet(il);
			il.Emit(OpCodes.Br, label3);
			il.MarkLabel(label2);
			base.compilerGlobals.BreakLabelStack.Pop();
			base.compilerGlobals.ContinueLabelStack.Pop();
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			var.TranslateToILInitializer(il);
			if (initializer != null)
			{
				initializer.TranslateToILInitializer(il);
			}
			collection.TranslateToILInitializer(il);
			body.TranslateToILInitializer(il);
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public sealed class FunctionConstructor : ScriptFunction
	{
		internal static readonly FunctionConstructor ob = new FunctionConstructor();

		internal FunctionPrototype originalPrototype;

		internal FunctionConstructor()
			: base(FunctionPrototype.ob, "Function", 1)
		{
			originalPrototype = FunctionPrototype.ob;
			FunctionPrototype._constructor = this;
			proto = FunctionPrototype.ob;
		}

		internal FunctionConstructor(LenientFunctionPrototype prototypeProp)
			: base(prototypeProp, "Function", 1)
		{
			originalPrototype = prototypeProp;
			prototypeProp.constructor = this;
			proto = prototypeProp;
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			return Construct(args, engine);
		}

		internal override object Construct(object[] args)
		{
			return Construct(args, engine);
		}

		internal ScriptFunction Construct(object[] args, VsaEngine engine)
		{
			StringBuilder stringBuilder = new StringBuilder("function anonymous(");
			int i = 0;
			for (int num = args.Length - 2; i < num; i++)
			{
				stringBuilder.Append(Convert.ToString(args[i]));
				stringBuilder.Append(", ");
			}
			if (args.Length > 1)
			{
				stringBuilder.Append(Convert.ToString(args[args.Length - 2]));
			}
			stringBuilder.Append(") {\n");
			if (args.Length != 0)
			{
				stringBuilder.Append(Convert.ToString(args[args.Length - 1]));
			}
			stringBuilder.Append("\n}");
			Context context = new Context(new DocumentContext("anonymous", engine), stringBuilder.ToString());
			JSParser jSParser = new JSParser(context);
			engine.PushScriptObject(((IActivationObject)engine.ScriptObjectStackTop()).GetGlobalScope());
			try
			{
				return (ScriptFunction)jSParser.ParseFunctionExpression().PartiallyEvaluate().Evaluate();
			}
			finally
			{
				engine.PopScriptObject();
			}
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>The instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new ScriptFunction CreateInstance(params object[] args)
		{
			return Construct(args, engine);
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>The instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public ScriptFunction Invoke(params object[] args)
		{
			return Construct(args, engine);
		}
	}
	/// <summary>Represents a function declaration. This class belongs to the abstract syntax tree category.</summary>
	public sealed class FunctionDeclaration : AST
	{
		internal FunctionObject func;

		private Member declaringObject;

		private TypeExpression ifaceId;

		private string name;

		internal bool isMethod;

		private bool inFastScope;

		private JSVariableField field;

		internal JSProperty enclosingProperty;

		private Completion completion = new Completion();

		internal FunctionDeclaration(Context context, AST ifaceId, IdentifierLiteral id, ParameterDeclaration[] formal_parameters, TypeExpression return_type, Block body, FunctionScope own_scope, FieldAttributes attributes, bool isMethod, bool isGetter, bool isSetter, bool isAbstract, bool isFinal, CustomAttributeList customAttributes)
			: base(context)
		{
			MethodAttributes methodAttributes = MethodAttributes.PrivateScope;
			methodAttributes = (((attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Public) ? MethodAttributes.Public : (((attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Private) ? MethodAttributes.Private : (((attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Assembly) ? MethodAttributes.Assembly : (((attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Family) ? MethodAttributes.Family : (((attributes & FieldAttributes.FieldAccessMask) != FieldAttributes.FamORAssem) ? MethodAttributes.Public : MethodAttributes.FamORAssem)))));
			methodAttributes = (((attributes & FieldAttributes.Static) == 0 && isMethod) ? (methodAttributes | (MethodAttributes.Virtual | MethodAttributes.VtableLayoutMask)) : (methodAttributes | MethodAttributes.Static));
			if (isAbstract)
			{
				methodAttributes |= MethodAttributes.Abstract;
			}
			if (isFinal)
			{
				methodAttributes |= MethodAttributes.Final;
			}
			name = id.ToString();
			this.isMethod = isMethod;
			if (ifaceId != null)
			{
				if (isMethod)
				{
					this.ifaceId = new TypeExpression(ifaceId);
					methodAttributes &= ~MethodAttributes.MemberAccessMask;
					methodAttributes |= MethodAttributes.Private | MethodAttributes.Final;
				}
				else
				{
					declaringObject = new Member(ifaceId.context, ifaceId, id);
					name = declaringObject.ToString();
				}
			}
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			if (attributes == FieldAttributes.PrivateScope && !isAbstract && !isFinal)
			{
				if (scriptObject is ClassScope)
				{
					attributes |= FieldAttributes.Public;
				}
			}
			else if (!(scriptObject is ClassScope))
			{
				base.context.HandleError(JSError.NotInsideClass);
				attributes = FieldAttributes.PrivateScope;
				methodAttributes = MethodAttributes.Public;
			}
			if (scriptObject is ActivationObject)
			{
				inFastScope = ((ActivationObject)scriptObject).fast;
				string text = name;
				if (isGetter)
				{
					methodAttributes |= MethodAttributes.SpecialName;
					name = "get_" + name;
					if (return_type == null)
					{
						return_type = new TypeExpression(new ConstantWrapper(Typeob.Object, context));
					}
				}
				else if (isSetter)
				{
					methodAttributes |= MethodAttributes.SpecialName;
					name = "set_" + name;
					return_type = new TypeExpression(new ConstantWrapper(Typeob.Void, context));
				}
				attributes &= FieldAttributes.FieldAccessMask;
				MethodAttributes methodAttributes2 = methodAttributes & MethodAttributes.MemberAccessMask;
				if ((methodAttributes & MethodAttributes.Virtual) != 0 && (methodAttributes & MethodAttributes.Final) == 0 && (methodAttributes2 == MethodAttributes.Private || methodAttributes2 == MethodAttributes.Assembly || methodAttributes2 == MethodAttributes.FamANDAssem))
				{
					methodAttributes |= MethodAttributes.CheckAccessOnOverride;
				}
				func = new FunctionObject(name, formal_parameters, return_type, body, own_scope, scriptObject, base.context, methodAttributes, customAttributes, this.isMethod);
				if (declaringObject != null)
				{
					return;
				}
				string text2 = name;
				if (this.ifaceId != null)
				{
					text2 = ifaceId.ToString() + "." + text2;
				}
				JSVariableField jSVariableField = (JSVariableField)((ActivationObject)scriptObject).name_table[text2];
				if (jSVariableField != null && (!(jSVariableField is JSMemberField) || !(((JSMemberField)jSVariableField).value is FunctionObject) || func.isExpandoMethod))
				{
					if (text != name)
					{
						jSVariableField.originalContext.HandleError(JSError.ClashWithProperty);
					}
					else
					{
						id.context.HandleError(JSError.DuplicateName, func.isExpandoMethod);
						if (jSVariableField.value is FunctionObject)
						{
							((FunctionObject)jSVariableField.value).suppressIL = true;
						}
					}
				}
				if (this.isMethod)
				{
					if (!(jSVariableField is JSMemberField) || !(((JSMemberField)jSVariableField).value is FunctionObject) || text != name)
					{
						field = ((ActivationObject)scriptObject).AddNewField(text2, func, attributes | FieldAttributes.Literal);
						if (text == name)
						{
							field.type = new TypeExpression(new ConstantWrapper(Typeob.FunctionWrapper, base.context));
						}
					}
					else
					{
						field = ((JSMemberField)jSVariableField).AddOverload(func, attributes | FieldAttributes.Literal);
					}
				}
				else if (scriptObject is FunctionScope)
				{
					if (inFastScope)
					{
						attributes |= FieldAttributes.Literal;
					}
					field = ((FunctionScope)scriptObject).AddNewField(name, attributes, func);
					if (field is JSLocalField)
					{
						JSLocalField jSLocalField = (JSLocalField)field;
						if (inFastScope)
						{
							jSLocalField.type = new TypeExpression(new ConstantWrapper(Typeob.ScriptFunction, base.context));
							jSLocalField.attributeFlags |= FieldAttributes.Literal;
						}
						jSLocalField.debugOn = base.context.document.debugOn;
						jSLocalField.isDefined = true;
					}
				}
				else if (inFastScope)
				{
					field = ((ActivationObject)scriptObject).AddNewField(name, func, attributes | FieldAttributes.Literal);
					field.type = new TypeExpression(new ConstantWrapper(Typeob.ScriptFunction, base.context));
				}
				else
				{
					field = ((ActivationObject)scriptObject).AddNewField(name, func, attributes | FieldAttributes.Static);
				}
				field.originalContext = context;
				if (!(text != name))
				{
					return;
				}
				string key = text;
				if (this.ifaceId != null)
				{
					key = ifaceId.ToString() + "." + text;
				}
				FieldInfo fieldInfo = (FieldInfo)((ClassScope)scriptObject).name_table[key];
				if (fieldInfo != null)
				{
					if (fieldInfo.IsLiteral)
					{
						object value = ((JSVariableField)fieldInfo).value;
						if (value is JSProperty)
						{
							enclosingProperty = (JSProperty)value;
						}
					}
					if (enclosingProperty == null)
					{
						id.context.HandleError(JSError.DuplicateName, treatAsError: true);
					}
				}
				if (enclosingProperty == null)
				{
					enclosingProperty = new JSProperty(text);
					fieldInfo = ((ActivationObject)scriptObject).AddNewField(key, enclosingProperty, attributes | FieldAttributes.Literal);
					((JSMemberField)fieldInfo).originalContext = base.context;
				}
				else if ((isGetter && enclosingProperty.getter != null) || (isSetter && enclosingProperty.setter != null))
				{
					id.context.HandleError(JSError.DuplicateName, treatAsError: true);
				}
				if (isGetter)
				{
					enclosingProperty.getter = new JSFieldMethod(field, scriptObject);
				}
				else
				{
					enclosingProperty.setter = new JSFieldMethod(field, scriptObject);
				}
			}
			else
			{
				inFastScope = false;
				func = new FunctionObject(name, formal_parameters, return_type, body, own_scope, scriptObject, base.context, MethodAttributes.Public, null, isMethod: false);
				field = ((StackFrame)scriptObject).AddNewField(name, new Closure(func), attributes | FieldAttributes.Static);
			}
		}

		internal override object Evaluate()
		{
			if (declaringObject != null)
			{
				declaringObject.SetValue(func);
			}
			return completion;
		}

		/// <summary>Creates a new closure function, using the specified information.</summary>
		/// <param name="handle">A handle to the type of the function.</param>
		/// <param name="name">The name of the function.</param>
		/// <param name="method_name">The name of the function.</param>
		/// <param name="formal_parameters">The parameters of the function.</param>
		/// <param name="fields">The fields of the function.</param>
		/// <param name="must_save_stack_locals">
		///   <see langword="true" /> to save local stack variables. This is important for a nested function that accesses one of its local variables or for an <see langword="eval" /> statement.</param>
		/// <param name="hasArgumentsObject">
		///   <see langword="true" /> if the function has a parameter array.</param>
		/// <param name="text">The text of the function declaration.</param>
		/// <param name="declaringObject">Gets the type that declares this method.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>A new closure function that represents the function declaration.</returns>
		public static Closure JScriptFunctionDeclaration(RuntimeTypeHandle handle, string name, string method_name, string[] formal_parameters, JSLocalField[] fields, bool must_save_stack_locals, bool hasArgumentsObject, string text, object declaringObject, VsaEngine engine)
		{
			Type typeFromHandle = Type.GetTypeFromHandle(handle);
			FunctionObject functionObject = new FunctionObject(typeFromHandle, name, method_name, formal_parameters, fields, must_save_stack_locals, hasArgumentsObject, text, engine);
			return new Closure(functionObject, declaringObject);
		}

		internal override Context GetFirstExecutableContext()
		{
			return null;
		}

		internal override AST PartiallyEvaluate()
		{
			if (ifaceId != null)
			{
				ifaceId.PartiallyEvaluate();
				func.implementedIface = ifaceId.ToIReflect();
				Type type = func.implementedIface as Type;
				ClassScope classScope = func.implementedIface as ClassScope;
				if ((type != null && !type.IsInterface) || (classScope != null && !classScope.owner.isInterface))
				{
					ifaceId.context.HandleError(JSError.NeedInterface);
					func.implementedIface = null;
				}
				if ((func.attributes & MethodAttributes.Abstract) != 0)
				{
					func.funcContext.HandleError(JSError.AbstractCannotBePrivate);
				}
			}
			else if (declaringObject != null)
			{
				declaringObject.PartiallyEvaluateAsCallable();
			}
			func.PartiallyEvaluate();
			if (inFastScope && func.isExpandoMethod && field != null && field.type != null)
			{
				field.type.expression = new ConstantWrapper(Typeob.ScriptFunction, null);
			}
			if ((func.attributes & MethodAttributes.Abstract) != 0 && !((ClassScope)func.enclosing_scope).owner.isAbstract)
			{
				((ClassScope)func.enclosing_scope).owner.attributes |= TypeAttributes.Abstract;
				((ClassScope)func.enclosing_scope).owner.context.HandleError(JSError.CannotBeAbstract, name);
			}
			if (enclosingProperty != null && !enclosingProperty.GetterAndSetterAreConsistent())
			{
				context.HandleError(JSError.GetAndSetAreInconsistent);
			}
			return this;
		}

		private void TranslateToILClosure(ILGenerator il)
		{
			if (!func.isStatic)
			{
				il.Emit(OpCodes.Ldarg_0);
			}
			il.Emit(OpCodes.Ldtoken, (func.classwriter != null) ? func.classwriter : base.compilerGlobals.classwriter);
			il.Emit(OpCodes.Ldstr, name);
			il.Emit(OpCodes.Ldstr, func.GetName());
			int num = func.formal_parameters.Length;
			ConstantWrapper.TranslateToILInt(il, num);
			il.Emit(OpCodes.Newarr, Typeob.String);
			for (int i = 0; i < num; i++)
			{
				il.Emit(OpCodes.Dup);
				ConstantWrapper.TranslateToILInt(il, i);
				il.Emit(OpCodes.Ldstr, func.formal_parameters[i]);
				il.Emit(OpCodes.Stelem_Ref);
			}
			num = func.fields.Length;
			ConstantWrapper.TranslateToILInt(il, num);
			il.Emit(OpCodes.Newarr, Typeob.JSLocalField);
			for (int j = 0; j < num; j++)
			{
				JSLocalField jSLocalField = func.fields[j];
				il.Emit(OpCodes.Dup);
				ConstantWrapper.TranslateToILInt(il, j);
				il.Emit(OpCodes.Ldstr, jSLocalField.Name);
				il.Emit(OpCodes.Ldtoken, jSLocalField.FieldType);
				ConstantWrapper.TranslateToILInt(il, jSLocalField.slotNumber);
				il.Emit(OpCodes.Newobj, CompilerGlobals.jsLocalFieldConstructor);
				il.Emit(OpCodes.Stelem_Ref);
			}
			if (func.must_save_stack_locals)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			if (func.hasArgumentsObject)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			il.Emit(OpCodes.Ldstr, func.ToString());
			if (!func.isStatic)
			{
				il.Emit(OpCodes.Ldarg_0);
			}
			else
			{
				il.Emit(OpCodes.Ldnull);
			}
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.jScriptFunctionDeclarationMethod);
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			if (func.suppressIL)
			{
				return;
			}
			func.TranslateToIL(base.compilerGlobals);
			if (declaringObject != null)
			{
				declaringObject.TranslateToILInitializer(il);
				declaringObject.TranslateToILPreSet(il);
				TranslateToILClosure(il);
				declaringObject.TranslateToILSet(il);
				return;
			}
			object metaData = field.metaData;
			if (func.isMethod)
			{
				if (metaData is FunctionDeclaration)
				{
					field.metaData = null;
				}
				else
				{
					TranslateToILSourceTextProvider();
				}
			}
			else if (metaData != null)
			{
				TranslateToILClosure(il);
				if (metaData is LocalBuilder)
				{
					il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
				}
				else if (func.isStatic)
				{
					il.Emit(OpCodes.Stsfld, (FieldInfo)metaData);
				}
				else
				{
					il.Emit(OpCodes.Stfld, (FieldInfo)metaData);
				}
			}
		}

		private void TranslateToILSourceTextProvider()
		{
			if (!base.Engine.doFast && string.Compare(name, field.Name, StringComparison.Ordinal) == 0)
			{
				StringBuilder stringBuilder = new StringBuilder(func.ToString());
				JSMemberField nextOverload = ((JSMemberField)field).nextOverload;
				while (nextOverload != null)
				{
					nextOverload.metaData = this;
					stringBuilder.Append('\n');
					stringBuilder.Append(nextOverload.value.ToString());
					nextOverload = nextOverload.nextOverload;
				}
				MethodAttributes attributes = MethodAttributes.Public | MethodAttributes.Static;
				MethodBuilder methodBuilder = ((ClassScope)func.enclosing_scope).GetTypeBuilder().DefineMethod(name + " source", attributes, Typeob.String, new Type[0]);
				ILGenerator iLGenerator = methodBuilder.GetILGenerator();
				iLGenerator.Emit(OpCodes.Ldstr, stringBuilder.ToString());
				iLGenerator.Emit(OpCodes.Ret);
			}
		}
	}
	/// <summary>Represents a function object. This class belongs to the abstract syntax tree category.</summary>
	public sealed class FunctionExpression : AST
	{
		private FunctionObject func;

		private string name;

		private JSVariableField field;

		private LocalBuilder func_local;

		private static int uniqueNumber;

		internal FunctionExpression(Context context, AST id, ParameterDeclaration[] formal_parameters, TypeExpression return_type, Block body, FunctionScope own_scope, FieldAttributes attributes)
			: base(context)
		{
			if (attributes != 0)
			{
				base.context.HandleError(JSError.SyntaxError);
				attributes = FieldAttributes.PrivateScope;
			}
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			name = id.ToString();
			if (name.Length == 0)
			{
				name = "anonymous " + uniqueNumber++.ToString(CultureInfo.InvariantCulture);
			}
			else
			{
				AddNameTo(scriptObject);
			}
			func = new FunctionObject(name, formal_parameters, return_type, body, own_scope, scriptObject, base.context, MethodAttributes.Public | MethodAttributes.Static);
		}

		private void AddNameTo(ScriptObject enclosingScope)
		{
			while (enclosingScope is WithObject)
			{
				enclosingScope = enclosingScope.GetParent();
			}
			FieldInfo localField = ((IActivationObject)enclosingScope).GetLocalField(name);
			if (!(localField != null))
			{
				localField = ((!(enclosingScope is ActivationObject)) ? ((StackFrame)enclosingScope).AddNewField(name, null, FieldAttributes.Public) : ((!(enclosingScope is FunctionScope)) ? ((ActivationObject)enclosingScope).AddNewField(name, null, FieldAttributes.Public | FieldAttributes.Static) : ((ActivationObject)enclosingScope).AddNewField(name, null, FieldAttributes.Public)));
				JSLocalField jSLocalField = localField as JSLocalField;
				if (jSLocalField != null)
				{
					jSLocalField.debugOn = context.document.debugOn;
					jSLocalField.isDefined = true;
				}
				field = (JSVariableField)localField;
			}
		}

		internal override object Evaluate()
		{
			if (VsaEngine.executeForJSEE)
			{
				throw new JScriptException(JSError.NonSupportedInDebugger);
			}
			ScriptObject parent = base.Globals.ScopeStack.Peek();
			func.own_scope.SetParent(parent);
			Closure closure = new Closure(func);
			if (field != null)
			{
				field.value = closure;
			}
			return closure;
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return Typeob.ScriptFunction;
		}

		/// <summary>Creates a new function object, using the specified information.</summary>
		/// <param name="handle">A handle to the type of the function.</param>
		/// <param name="name">The name of the function.</param>
		/// <param name="method_name">The name of the function.</param>
		/// <param name="formal_params">The parameters of the function.</param>
		/// <param name="fields">The fields of the function.</param>
		/// <param name="must_save_stack_locals">
		///   <see langword="true" /> to save local stack variables. This is important for a nested function that accesses one of its local variables, or for an <see langword="eval" /> statement.</param>
		/// <param name="hasArgumentsObject">
		///   <see langword="true" /> if the function has a parameter array.</param>
		/// <param name="text">The text of the function declaration.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>A new function object.</returns>
		public static FunctionObject JScriptFunctionExpression(RuntimeTypeHandle handle, string name, string method_name, string[] formal_params, JSLocalField[] fields, bool must_save_stack_locals, bool hasArgumentsObject, string text, VsaEngine engine)
		{
			Type typeFromHandle = Type.GetTypeFromHandle(handle);
			return new FunctionObject(typeFromHandle, name, method_name, formal_params, fields, must_save_stack_locals, hasArgumentsObject, text, engine);
		}

		internal override AST PartiallyEvaluate()
		{
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			if (ClassScope.ScopeOfClassMemberInitializer(scriptObject) != null)
			{
				context.HandleError(JSError.MemberInitializerCannotContainFuncExpr);
				return this;
			}
			ScriptObject scriptObject2 = scriptObject;
			while (scriptObject2 is WithObject || scriptObject2 is BlockScope)
			{
				scriptObject2 = scriptObject2.GetParent();
			}
			if (scriptObject2 is FunctionScope functionScope)
			{
				functionScope.closuresMightEscape = true;
			}
			if (scriptObject2 != scriptObject)
			{
				func.own_scope.SetParent(new WithObject(new JSObject(), func.own_scope.GetGlobalScope()));
			}
			func.PartiallyEvaluate();
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (rtype == Typeob.Void)
			{
				return;
			}
			il.Emit(OpCodes.Ldloc, func_local);
			il.Emit(OpCodes.Newobj, CompilerGlobals.closureConstructor);
			Convert.Emit(this, il, Typeob.Closure, rtype);
			if (field != null)
			{
				il.Emit(OpCodes.Dup);
				object metaData = field.GetMetaData();
				if (metaData is LocalBuilder)
				{
					il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
				}
				else
				{
					il.Emit(OpCodes.Stsfld, (FieldInfo)metaData);
				}
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			func.TranslateToIL(base.compilerGlobals);
			func_local = il.DeclareLocal(Typeob.FunctionObject);
			il.Emit(OpCodes.Ldtoken, func.classwriter);
			il.Emit(OpCodes.Ldstr, name);
			il.Emit(OpCodes.Ldstr, func.GetName());
			int num = func.formal_parameters.Length;
			ConstantWrapper.TranslateToILInt(il, num);
			il.Emit(OpCodes.Newarr, Typeob.String);
			for (int i = 0; i < num; i++)
			{
				il.Emit(OpCodes.Dup);
				ConstantWrapper.TranslateToILInt(il, i);
				il.Emit(OpCodes.Ldstr, func.formal_parameters[i]);
				il.Emit(OpCodes.Stelem_Ref);
			}
			num = func.fields.Length;
			ConstantWrapper.TranslateToILInt(il, num);
			il.Emit(OpCodes.Newarr, Typeob.JSLocalField);
			for (int j = 0; j < num; j++)
			{
				JSLocalField jSLocalField = func.fields[j];
				il.Emit(OpCodes.Dup);
				ConstantWrapper.TranslateToILInt(il, j);
				il.Emit(OpCodes.Ldstr, jSLocalField.Name);
				il.Emit(OpCodes.Ldtoken, jSLocalField.FieldType);
				ConstantWrapper.TranslateToILInt(il, jSLocalField.slotNumber);
				il.Emit(OpCodes.Newobj, CompilerGlobals.jsLocalFieldConstructor);
				il.Emit(OpCodes.Stelem_Ref);
			}
			if (func.must_save_stack_locals)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			if (func.hasArgumentsObject)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			il.Emit(OpCodes.Ldstr, func.ToString());
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.jScriptFunctionExpressionMethod);
			il.Emit(OpCodes.Stloc, func_local);
		}
	}
	/// <summary>Represents a function object.</summary>
	public sealed class FunctionObject : ScriptFunction
	{
		internal ParameterDeclaration[] parameter_declarations;

		internal string[] formal_parameters;

		internal TypeExpression return_type_expr;

		private Block body;

		private MethodInfo method;

		private ParameterInfo[] parameterInfos;

		internal Context funcContext;

		private int argumentsSlotNumber;

		internal JSLocalField[] fields;

		internal FunctionScope own_scope;

		internal ScriptObject enclosing_scope;

		internal bool must_save_stack_locals;

		internal bool hasArgumentsObject;

		internal IReflect implementedIface;

		internal MethodInfo implementedIfaceMethod;

		internal bool isMethod;

		internal bool isExpandoMethod;

		internal bool isConstructor;

		internal bool isImplicitCtor;

		internal bool isStatic;

		internal bool noVersionSafeAttributeSpecified;

		internal bool suppressIL;

		internal string text;

		private MethodBuilder mb;

		private ConstructorBuilder cb;

		internal TypeBuilder classwriter;

		internal MethodAttributes attributes;

		internal Globals globals;

		private ConstructorInfo superConstructor;

		internal ConstructorCall superConstructorCall;

		internal CustomAttributeList customAttributes;

		private CLSComplianceSpec clsCompliance;

		private LocalBuilder engineLocal;

		private bool partiallyEvaluated;

		internal Label returnLabel;

		internal bool Must_save_stack_locals
		{
			get
			{
				if (!partiallyEvaluated)
				{
					PartiallyEvaluate();
				}
				return must_save_stack_locals;
			}
		}

		internal FunctionObject(string name, ParameterDeclaration[] parameter_declarations, TypeExpression return_type_expr, Block body, FunctionScope own_scope, ScriptObject enclosing_scope, Context funcContext, MethodAttributes attributes)
			: this(name, parameter_declarations, return_type_expr, body, own_scope, enclosing_scope, funcContext, attributes, null, isMethod: false)
		{
		}

		internal FunctionObject(string name, ParameterDeclaration[] parameter_declarations, TypeExpression return_type_expr, Block body, FunctionScope own_scope, ScriptObject enclosing_scope, Context funcContext, MethodAttributes attributes, CustomAttributeList customAttributes, bool isMethod)
			: base(body.Globals.globalObject.originalFunction.originalPrototype, name, parameter_declarations.Length)
		{
			this.parameter_declarations = parameter_declarations;
			int num = parameter_declarations.Length;
			formal_parameters = new string[num];
			for (int i = 0; i < num; i++)
			{
				formal_parameters[i] = parameter_declarations[i].identifier;
			}
			argumentsSlotNumber = 0;
			this.return_type_expr = return_type_expr;
			if (this.return_type_expr != null)
			{
				own_scope.AddReturnValueField();
			}
			this.body = body;
			method = null;
			parameterInfos = null;
			this.funcContext = funcContext;
			this.own_scope = own_scope;
			this.own_scope.owner = this;
			if ((!(enclosing_scope is ActivationObject) || !((ActivationObject)enclosing_scope).fast) && !isMethod)
			{
				argumentsSlotNumber = this.own_scope.GetNextSlotNumber();
				JSLocalField jSLocalField = (JSLocalField)this.own_scope.AddNewField("arguments", null, FieldAttributes.PrivateScope);
				jSLocalField.type = new TypeExpression(new ConstantWrapper(Typeob.Object, funcContext));
				jSLocalField.isDefined = true;
				hasArgumentsObject = true;
			}
			else
			{
				hasArgumentsObject = false;
			}
			implementedIface = null;
			implementedIfaceMethod = null;
			this.isMethod = isMethod;
			isExpandoMethod = customAttributes?.ContainsExpandoAttribute() ?? false;
			isStatic = (this.own_scope.isStatic = (attributes & MethodAttributes.Static) != 0);
			suppressIL = false;
			noVersionSafeAttributeSpecified = true;
			fields = this.own_scope.GetLocalFields();
			this.enclosing_scope = enclosing_scope;
			must_save_stack_locals = false;
			text = null;
			mb = null;
			cb = null;
			this.attributes = attributes;
			if (!isStatic)
			{
				this.attributes |= MethodAttributes.HideBySig;
			}
			globals = body.Globals;
			superConstructor = null;
			superConstructorCall = null;
			this.customAttributes = customAttributes;
			noExpando = false;
			clsCompliance = CLSComplianceSpec.NotAttributed;
			engineLocal = null;
			partiallyEvaluated = false;
		}

		internal FunctionObject(Type t, string name, string method_name, string[] formal_parameters, JSLocalField[] fields, bool must_save_stack_locals, bool hasArgumentsObject, string text, VsaEngine engine)
			: base(engine.Globals.globalObject.originalFunction.originalPrototype, name, formal_parameters.Length)
		{
			base.engine = engine;
			this.formal_parameters = formal_parameters;
			argumentsSlotNumber = 0;
			body = null;
			TypeReflector typeReflectorFor = TypeReflector.GetTypeReflectorFor(Globals.TypeRefs.ToReferenceContext(t));
			method = typeReflectorFor.GetMethod(method_name, BindingFlags.Static | BindingFlags.Public);
			parameterInfos = method.GetParameters();
			if (!CustomAttribute.IsDefined(method, typeof(JSFunctionAttribute), inherit: false))
			{
				isMethod = true;
			}
			else
			{
				object[] array = CustomAttribute.GetCustomAttributes(method, typeof(JSFunctionAttribute), inherit: false);
				JSFunctionAttributeEnum attributeValue = ((JSFunctionAttribute)array[0]).attributeValue;
				isExpandoMethod = (attributeValue & JSFunctionAttributeEnum.IsExpandoMethod) != 0;
			}
			funcContext = null;
			own_scope = null;
			this.fields = fields;
			this.must_save_stack_locals = must_save_stack_locals;
			this.hasArgumentsObject = hasArgumentsObject;
			this.text = text;
			attributes = MethodAttributes.Public;
			globals = engine.Globals;
			superConstructor = null;
			superConstructorCall = null;
			enclosing_scope = globals.ScopeStack.Peek();
			noExpando = false;
			clsCompliance = CLSComplianceSpec.NotAttributed;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object Call(object[] args, object thisob)
		{
			return Call(args, thisob, null, null);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object Call(object[] args, object thisob, Binder binder, CultureInfo culture)
		{
			if (body == null)
			{
				return Call(args, thisob, enclosing_scope, new Closure(this), binder, culture);
			}
			StackFrame stackFrame = new StackFrame((thisob is JSObject) ? ((JSObject)thisob) : enclosing_scope, fields, new object[fields.Length], thisob);
			if (isConstructor)
			{
				stackFrame.closureInstance = thisob;
				if (superConstructor != null)
				{
					if (superConstructorCall == null)
					{
						if (superConstructor is JSConstructor)
						{
							superConstructor.Invoke(thisob, new object[0]);
						}
					}
					else
					{
						ASTList arguments = superConstructorCall.arguments;
						int count = arguments.count;
						object[] array = new object[count];
						for (int i = 0; i < count; i++)
						{
							array[i] = arguments[i].Evaluate();
						}
						superConstructor.Invoke(thisob, BindingFlags.Default, binder, array, culture);
					}
				}
				globals.ScopeStack.GuardedPush((thisob is JSObject) ? ((JSObject)thisob) : enclosing_scope);
				try
				{
					((ClassScope)enclosing_scope).owner.body.EvaluateInstanceVariableInitializers();
				}
				finally
				{
					globals.ScopeStack.Pop();
				}
			}
			else if (isMethod && !isStatic)
			{
				if (!((ClassScope)enclosing_scope).HasInstance(thisob))
				{
					throw new JScriptException(JSError.TypeMismatch);
				}
				stackFrame.closureInstance = thisob;
			}
			globals.ScopeStack.GuardedPush(stackFrame);
			try
			{
				own_scope.CloseNestedFunctions(stackFrame);
				ConvertArguments(args, stackFrame.localVars, 0, args.Length, formal_parameters.Length, binder, culture);
				Completion completion = (Completion)body.Evaluate();
				if (completion.Return)
				{
					return completion.value;
				}
				return null;
			}
			finally
			{
				globals.ScopeStack.Pop();
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object Call(object[] args, object thisob, ScriptObject enclosing_scope, Closure calleeClosure, Binder binder, CultureInfo culture)
		{
			if (body != null)
			{
				return CallASTFunc(args, thisob, enclosing_scope, calleeClosure, binder, culture);
			}
			object caller = calleeClosure.caller;
			calleeClosure.caller = globals.caller;
			globals.caller = calleeClosure;
			object arguments = calleeClosure.arguments;
			ScriptObject scriptObject = globals.ScopeStack.Peek();
			ArgumentsObject caller2 = ((scriptObject is StackFrame) ? ((StackFrame)scriptObject).caller_arguments : null);
			StackFrame stackFrame = new StackFrame(enclosing_scope, fields, must_save_stack_locals ? new object[fields.Length] : null, thisob);
			globals.ScopeStack.GuardedPush(stackFrame);
			ArgumentsObject argumentsObject = (ArgumentsObject)(calleeClosure.arguments = (stackFrame.caller_arguments = new ArgumentsObject(globals.globalObject.originalObjectPrototype, args, this, calleeClosure, stackFrame, caller2)));
			try
			{
				int num = formal_parameters.Length;
				int num2 = args.Length;
				if (hasArgumentsObject)
				{
					object[] array = new object[num + 3];
					array[0] = thisob;
					array[1] = engine;
					array[2] = argumentsObject;
					ConvertArguments(args, array, 3, num2, num, binder, culture);
					return method.Invoke(thisob, BindingFlags.SuppressChangeType, null, array, null);
				}
				if (!isMethod)
				{
					object[] array2 = new object[num + 2];
					array2[0] = thisob;
					array2[1] = engine;
					ConvertArguments(args, array2, 2, num2, num, binder, culture);
					return method.Invoke(thisob, BindingFlags.SuppressChangeType, null, array2, null);
				}
				if (num == num2)
				{
					ConvertArguments(args, args, 0, num2, num, binder, culture);
					return method.Invoke(thisob, BindingFlags.SuppressChangeType, null, args, null);
				}
				object[] array3 = new object[num];
				ConvertArguments(args, array3, 0, num2, num, binder, culture);
				return method.Invoke(thisob, BindingFlags.SuppressChangeType, null, array3, null);
			}
			catch (TargetInvocationException ex)
			{
				throw ex.InnerException;
			}
			finally
			{
				globals.ScopeStack.Pop();
				calleeClosure.arguments = arguments;
				globals.caller = calleeClosure.caller;
				calleeClosure.caller = caller;
			}
		}

		private object CallASTFunc(object[] args, object thisob, ScriptObject enclosing_scope, Closure calleeClosure, Binder binder, CultureInfo culture)
		{
			object caller = calleeClosure.caller;
			calleeClosure.caller = globals.caller;
			globals.caller = calleeClosure;
			object arguments = calleeClosure.arguments;
			ScriptObject scriptObject = globals.ScopeStack.Peek();
			ArgumentsObject caller2 = ((scriptObject is StackFrame) ? ((StackFrame)scriptObject).caller_arguments : null);
			StackFrame stackFrame = new StackFrame(enclosing_scope, fields, new object[fields.Length], thisob);
			if (isMethod && !isStatic)
			{
				stackFrame.closureInstance = thisob;
			}
			globals.ScopeStack.GuardedPush(stackFrame);
			try
			{
				own_scope.CloseNestedFunctions(stackFrame);
				ArgumentsObject argumentsObject = null;
				if (hasArgumentsObject)
				{
					argumentsObject = new ArgumentsObject(globals.globalObject.originalObjectPrototype, args, this, calleeClosure, stackFrame, caller2);
					stackFrame.localVars[argumentsSlotNumber] = argumentsObject;
				}
				stackFrame.caller_arguments = argumentsObject;
				calleeClosure.arguments = argumentsObject;
				ConvertArguments(args, stackFrame.localVars, 0, args.Length, formal_parameters.Length, binder, culture);
				Completion completion = (Completion)body.Evaluate();
				if (completion.Return)
				{
					return completion.value;
				}
				return null;
			}
			finally
			{
				globals.ScopeStack.Pop();
				calleeClosure.arguments = arguments;
				globals.caller = calleeClosure.caller;
				calleeClosure.caller = caller;
			}
		}

		internal void CheckCLSCompliance(bool classIsCLSCompliant)
		{
			if (classIsCLSCompliant)
			{
				if (clsCompliance == CLSComplianceSpec.NonCLSCompliant)
				{
					return;
				}
				int i = 0;
				for (int num = parameter_declarations.Length; i < num; i++)
				{
					IReflect parameterIReflect = parameter_declarations[i].ParameterIReflect;
					if (parameterIReflect != null && !TypeExpression.TypeIsCLSCompliant(parameterIReflect))
					{
						clsCompliance = CLSComplianceSpec.NonCLSCompliant;
						funcContext.HandleError(JSError.NonCLSCompliantMember);
						return;
					}
				}
				if (return_type_expr != null && !return_type_expr.IsCLSCompliant())
				{
					clsCompliance = CLSComplianceSpec.NonCLSCompliant;
					funcContext.HandleError(JSError.NonCLSCompliantMember);
				}
			}
			else if (clsCompliance == CLSComplianceSpec.CLSCompliant)
			{
				funcContext.HandleError(JSError.MemberTypeCLSCompliantMismatch);
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal object Construct(JSObject thisob, object[] args)
		{
			JSObject jSObject = new JSObject(null, checkSubType: false);
			jSObject.SetParent(GetPrototypeForConstructedObject());
			jSObject.outer_class_instance = thisob;
			object obj = Call(args, jSObject);
			if (obj is ScriptObject)
			{
				return obj;
			}
			return jSObject;
		}

		private void ConvertArguments(object[] args, object[] newargs, int offset, int length, int n, Binder binder, CultureInfo culture)
		{
			ParameterInfo[] array = parameterInfos;
			if (array != null)
			{
				int num = 0;
				int num2 = offset;
				while (num < n)
				{
					Type parameterType = array[num2].ParameterType;
					if (num == n - 1 && CustomAttribute.IsDefined(array[num2], typeof(ParamArrayAttribute), inherit: false))
					{
						int num3 = length - num;
						if (num3 < 0)
						{
							num3 = 0;
						}
						newargs[num2] = CopyToNewParamArray(parameterType.GetElementType(), num3, args, num, binder, culture);
						break;
					}
					object obj = ((num < length) ? args[num] : null);
					if (parameterType == Typeob.Object)
					{
						newargs[num2] = obj;
					}
					else if (binder != null)
					{
						newargs[num2] = binder.ChangeType(obj, parameterType, culture);
					}
					else
					{
						newargs[num2] = Convert.CoerceT(obj, parameterType);
					}
					num++;
					num2++;
				}
				return;
			}
			ParameterDeclaration[] array2 = parameter_declarations;
			int num4 = 0;
			int num5 = offset;
			while (num4 < n)
			{
				IReflect parameterIReflect = array2[num4].ParameterIReflect;
				if (num4 == n - 1 && CustomAttribute.IsDefined(array2[num5], typeof(ParamArrayAttribute), inherit: false))
				{
					int num6 = length - num4;
					if (num6 < 0)
					{
						num6 = 0;
					}
					newargs[num5] = CopyToNewParamArray(((TypedArray)parameterIReflect).elementType, num6, args, num4);
					break;
				}
				object obj2 = ((num4 < length) ? args[num4] : null);
				if (parameterIReflect == Typeob.Object)
				{
					newargs[num5] = obj2;
				}
				else if (parameterIReflect is ClassScope)
				{
					newargs[num5] = Convert.Coerce(obj2, parameterIReflect);
				}
				else if (binder != null)
				{
					newargs[num5] = binder.ChangeType(obj2, Convert.ToType(parameterIReflect), culture);
				}
				else
				{
					newargs[num5] = Convert.CoerceT(obj2, Convert.ToType(parameterIReflect));
				}
				num4++;
				num5++;
			}
		}

		private static object[] CopyToNewParamArray(IReflect ir, int n, object[] args, int offset)
		{
			object[] array = new object[n];
			for (int i = 0; i < n; i++)
			{
				array[i] = Convert.Coerce(args[i + offset], ir);
			}
			return array;
		}

		private static Array CopyToNewParamArray(Type t, int n, object[] args, int offset, Binder binder, CultureInfo culture)
		{
			Array array = Array.CreateInstance(t, n);
			for (int i = 0; i < n; i++)
			{
				array.SetValue(binder.ChangeType(args[i + offset], t, culture), i);
			}
			return array;
		}

		internal void EmitLastLineInfo(ILGenerator il)
		{
			if (!isImplicitCtor)
			{
				int endLine = body.context.EndLine;
				int endColumn = body.context.EndColumn;
				body.context.document.EmitLineInfo(il, endLine, endColumn, endLine, endColumn + 1);
			}
		}

		internal string GetName()
		{
			return name;
		}

		internal override int GetNumberOfFormalParameters()
		{
			return formal_parameters.Length;
		}

		internal ConstructorInfo GetConstructorInfo(CompilerGlobals compilerGlobals)
		{
			return (ConstructorInfo)GetMethodBase(compilerGlobals);
		}

		internal MethodInfo GetMethodInfo(CompilerGlobals compilerGlobals)
		{
			return (MethodInfo)GetMethodBase(compilerGlobals);
		}

		internal MethodBase GetMethodBase(CompilerGlobals compilerGlobals)
		{
			if (mb != null)
			{
				return mb;
			}
			if (cb != null)
			{
				return cb;
			}
			JSFunctionAttributeEnum jSFunctionAttributeEnum = JSFunctionAttributeEnum.None;
			int num = 3;
			if (isMethod)
			{
				if (isConstructor && ((ClassScope)enclosing_scope).outerClassField != null)
				{
					num = 1;
					jSFunctionAttributeEnum |= JSFunctionAttributeEnum.IsInstanceNestedClassConstructor;
				}
				else
				{
					num = 0;
				}
			}
			else if (!hasArgumentsObject)
			{
				num = 2;
			}
			int num2 = formal_parameters.Length + num;
			Type[] array = new Type[num2];
			Type returnType = Convert.ToType(ReturnType(null));
			if (num > 0)
			{
				if (isConstructor)
				{
					array[num2 - 1] = ((ClassScope)enclosing_scope).outerClassField.FieldType;
				}
				else
				{
					array[0] = Typeob.Object;
				}
				jSFunctionAttributeEnum |= JSFunctionAttributeEnum.HasThisObject;
			}
			if (num > 1)
			{
				array[1] = Typeob.VsaEngine;
				jSFunctionAttributeEnum |= JSFunctionAttributeEnum.HasEngine;
			}
			if (num > 2)
			{
				array[2] = Typeob.Object;
				jSFunctionAttributeEnum |= JSFunctionAttributeEnum.HasArguments;
			}
			if (must_save_stack_locals)
			{
				jSFunctionAttributeEnum |= JSFunctionAttributeEnum.HasStackFrame;
			}
			if (isExpandoMethod)
			{
				jSFunctionAttributeEnum |= JSFunctionAttributeEnum.IsExpandoMethod;
			}
			if (isConstructor)
			{
				for (int i = 0; i < num2 - num; i++)
				{
					array[i] = parameter_declarations[i].ParameterType;
				}
			}
			else
			{
				for (int j = num; j < num2; j++)
				{
					array[j] = parameter_declarations[j - num].ParameterType;
				}
			}
			if (enclosing_scope is ClassScope)
			{
				if (isConstructor)
				{
					cb = ((ClassScope)enclosing_scope).GetTypeBuilder().DefineConstructor(attributes & MethodAttributes.MemberAccessMask, CallingConventions.Standard, array);
				}
				else
				{
					string text = name;
					if (implementedIfaceMethod != null)
					{
						JSMethod jSMethod = implementedIfaceMethod as JSMethod;
						if (jSMethod != null)
						{
							implementedIfaceMethod = jSMethod.GetMethodInfo(compilerGlobals);
						}
						text = implementedIfaceMethod.DeclaringType.FullName + "." + text;
					}
					TypeBuilder typeBuilder = ((ClassScope)enclosing_scope).GetTypeBuilder();
					if (mb != null)
					{
						return mb;
					}
					mb = typeBuilder.DefineMethod(text, attributes, returnType, array);
					if (implementedIfaceMethod != null)
					{
						((ClassScope)enclosing_scope).GetTypeBuilder().DefineMethodOverride(mb, implementedIfaceMethod);
					}
				}
			}
			else
			{
				if (enclosing_scope is FunctionScope)
				{
					if (((FunctionScope)enclosing_scope).owner != null)
					{
						name = ((FunctionScope)enclosing_scope).owner.name + "." + name;
						jSFunctionAttributeEnum |= JSFunctionAttributeEnum.IsNested;
					}
					else
					{
						for (ScriptObject scriptObject = enclosing_scope; scriptObject != null; scriptObject = scriptObject.GetParent())
						{
							if (scriptObject is FunctionScope && ((FunctionScope)scriptObject).owner != null)
							{
								name = ((FunctionScope)scriptObject).owner.name + "." + name;
								jSFunctionAttributeEnum |= JSFunctionAttributeEnum.IsNested;
								break;
							}
						}
					}
				}
				if (compilerGlobals.usedNames[name] != null)
				{
					name = name + ":" + compilerGlobals.usedNames.count.ToString(CultureInfo.InvariantCulture);
				}
				compilerGlobals.usedNames[name] = this;
				ScriptObject scriptObject2 = enclosing_scope;
				while (scriptObject2 != null && !(scriptObject2 is ClassScope))
				{
					scriptObject2 = scriptObject2.GetParent();
				}
				classwriter = ((scriptObject2 == null) ? compilerGlobals.globalScopeClassWriter : compilerGlobals.classwriter);
				mb = classwriter.DefineMethod(name, attributes, returnType, array);
			}
			if (num > 0)
			{
				if (mb != null)
				{
					mb.DefineParameter(1, ParameterAttributes.None, "this");
				}
				else
				{
					ParameterBuilder parameterBuilder = cb.DefineParameter(num2, ParameterAttributes.None, "this");
					parameterBuilder.SetConstant(null);
					num = 0;
					num2--;
				}
			}
			if (num > 1)
			{
				mb.DefineParameter(2, ParameterAttributes.None, "vsa Engine");
			}
			if (num > 2)
			{
				mb.DefineParameter(3, ParameterAttributes.None, "arguments");
			}
			for (int k = num; k < num2; k++)
			{
				ParameterBuilder parameterBuilder2 = ((mb != null) ? mb.DefineParameter(k + 1, ParameterAttributes.None, parameter_declarations[k - num].identifier) : cb.DefineParameter(k + 1, ParameterAttributes.None, parameter_declarations[k - num].identifier));
				CustomAttributeList customAttributeList = parameter_declarations[k - num].customAttributes;
				if (customAttributeList != null)
				{
					CustomAttributeBuilder[] customAttributeBuilders = customAttributeList.GetCustomAttributeBuilders(getForProperty: false);
					for (int l = 0; l < customAttributeBuilders.Length; l++)
					{
						parameterBuilder2.SetCustomAttribute(customAttributeBuilders[l]);
					}
				}
			}
			if (jSFunctionAttributeEnum > JSFunctionAttributeEnum.None)
			{
				CustomAttributeBuilder customAttribute = new CustomAttributeBuilder(CompilerGlobals.jsFunctionAttributeConstructor, new object[1] { jSFunctionAttributeEnum });
				if (mb != null)
				{
					mb.SetCustomAttribute(customAttribute);
				}
				else
				{
					cb.SetCustomAttribute(customAttribute);
				}
			}
			if (customAttributes != null)
			{
				CustomAttributeBuilder[] customAttributeBuilders2 = customAttributes.GetCustomAttributeBuilders(getForProperty: false);
				for (int m = 0; m < customAttributeBuilders2.Length; m++)
				{
					if (mb != null)
					{
						mb.SetCustomAttribute(customAttributeBuilders2[m]);
					}
					else
					{
						cb.SetCustomAttribute(customAttributeBuilders2[m]);
					}
				}
			}
			if (clsCompliance == CLSComplianceSpec.CLSCompliant)
			{
				if (mb != null)
				{
					mb.SetCustomAttribute(new CustomAttributeBuilder(CompilerGlobals.clsCompliantAttributeCtor, new object[1] { true }));
				}
				else
				{
					cb.SetCustomAttribute(new CustomAttributeBuilder(CompilerGlobals.clsCompliantAttributeCtor, new object[1] { true }));
				}
			}
			else if (clsCompliance == CLSComplianceSpec.NonCLSCompliant)
			{
				if (mb != null)
				{
					mb.SetCustomAttribute(new CustomAttributeBuilder(CompilerGlobals.clsCompliantAttributeCtor, new object[1] { false }));
				}
				else
				{
					cb.SetCustomAttribute(new CustomAttributeBuilder(CompilerGlobals.clsCompliantAttributeCtor, new object[1] { false }));
				}
			}
			if (mb != null)
			{
				mb.InitLocals = true;
				return mb;
			}
			cb.InitLocals = true;
			return cb;
		}

		private static bool IsPresentIn(FieldInfo field, FieldInfo[] fields)
		{
			int i = 0;
			for (int num = fields.Length; i < num; i++)
			{
				if (field == fields[i])
				{
					return true;
				}
			}
			return false;
		}

		internal void PartiallyEvaluate()
		{
			if (partiallyEvaluated)
			{
				return;
			}
			if (enclosing_scope is ClassScope classScope)
			{
				classScope.owner.PartiallyEvaluate();
			}
			if (partiallyEvaluated)
			{
				return;
			}
			partiallyEvaluated = true;
			clsCompliance = CLSComplianceSpec.NotAttributed;
			if (customAttributes != null)
			{
				customAttributes.PartiallyEvaluate();
				CustomAttribute attribute = customAttributes.GetAttribute(Typeob.CLSCompliantAttribute);
				if (attribute != null)
				{
					clsCompliance = attribute.GetCLSComplianceValue();
					customAttributes.Remove(attribute);
				}
				attribute = customAttributes.GetAttribute(Typeob.Override);
				if (attribute != null)
				{
					if (isStatic)
					{
						attribute.context.HandleError(JSError.StaticMethodsCannotOverride);
					}
					else
					{
						attributes &= ~MethodAttributes.VtableLayoutMask;
					}
					noVersionSafeAttributeSpecified = false;
					customAttributes.Remove(attribute);
				}
				attribute = customAttributes.GetAttribute(Typeob.Hide);
				if (attribute != null)
				{
					if (!noVersionSafeAttributeSpecified)
					{
						attribute.context.HandleError(JSError.OverrideAndHideUsedTogether);
						attributes |= MethodAttributes.VtableLayoutMask;
						noVersionSafeAttributeSpecified = true;
					}
					else
					{
						if (isStatic)
						{
							attribute.context.HandleError(JSError.StaticMethodsCannotHide);
						}
						noVersionSafeAttributeSpecified = false;
					}
					customAttributes.Remove(attribute);
				}
				CustomAttribute attribute2 = customAttributes.GetAttribute(Typeob.Expando);
				if (attribute2 != null)
				{
					if (!noVersionSafeAttributeSpecified && (attributes & MethodAttributes.VtableLayoutMask) == 0)
					{
						attribute2.context.HandleError(JSError.ExpandoPrecludesOverride);
						attributes |= MethodAttributes.VtableLayoutMask;
						noVersionSafeAttributeSpecified = true;
					}
					if (isConstructor)
					{
						attribute2.context.HandleError(JSError.NotValidForConstructor);
					}
					else if ((attributes & MethodAttributes.Abstract) != 0)
					{
						attribute2.context.HandleError(JSError.ExpandoPrecludesAbstract);
					}
					else if ((attributes & MethodAttributes.Static) != 0)
					{
						attribute2.context.HandleError(JSError.ExpandoPrecludesStatic);
					}
					else if ((attributes & MethodAttributes.MemberAccessMask) != MethodAttributes.Public)
					{
						attribute2.context.HandleError(JSError.ExpandoMustBePublic);
					}
					else
					{
						own_scope.isMethod = false;
						isMethod = false;
						isExpandoMethod = true;
						isStatic = true;
						attributes &= ~MethodAttributes.Virtual;
						attributes &= ~MethodAttributes.VtableLayoutMask;
						attributes |= MethodAttributes.Static;
					}
				}
			}
			int i = 0;
			for (int num = parameter_declarations.Length; i < num; i++)
			{
				parameter_declarations[i].PartiallyEvaluate();
				JSLocalField jSLocalField = (JSLocalField)own_scope.name_table[formal_parameters[i]];
				jSLocalField.type = parameter_declarations[i].type;
				if (jSLocalField.type == null)
				{
					jSLocalField.type = new TypeExpression(new ConstantWrapper(Typeob.Object, parameter_declarations[i].context));
				}
				jSLocalField.isDefined = true;
			}
			if (return_type_expr != null)
			{
				return_type_expr.PartiallyEvaluate();
				own_scope.returnVar.type = return_type_expr;
				if (own_scope.returnVar.type.ToIReflect() == Typeob.Void)
				{
					own_scope.returnVar.type = null;
					own_scope.returnVar = null;
				}
			}
			globals.ScopeStack.Push(own_scope);
			if (!own_scope.isKnownAtCompileTime)
			{
				int j = 0;
				for (int num2 = fields.Length; j < num2; j++)
				{
					fields[j].SetInferredType(Typeob.Object, null);
				}
			}
			if (!isConstructor)
			{
				body.PartiallyEvaluate();
			}
			else
			{
				body.MarkSuperOKIfIsFirstStatement();
				body.PartiallyEvaluate();
				ClassScope classScope2 = (ClassScope)enclosing_scope;
				int num3 = ((superConstructorCall != null) ? superConstructorCall.arguments.count : 0);
				Type[] array = ((num3 == 0) ? Type.EmptyTypes : new Type[num3]);
				IReflect[] array2 = new IReflect[num3];
				for (int k = 0; k < num3; k++)
				{
					array2[k] = superConstructorCall.arguments[k].InferType(null);
				}
				Context context = ((superConstructorCall == null) ? funcContext : superConstructorCall.context);
				try
				{
					if (superConstructorCall != null && !superConstructorCall.isSuperConstructorCall)
					{
						MemberInfo[] constructors = classScope2.constructors;
						superConstructor = JSBinder.SelectConstructor(constructors, array2);
					}
					else
					{
						superConstructor = classScope2.owner.GetSuperConstructor(array2);
					}
					if (superConstructor == null)
					{
						context.HandleError(JSError.SuperClassConstructorNotAccessible);
					}
					else
					{
						ConstructorInfo constructorInfo = superConstructor;
						if (!constructorInfo.IsPublic && !constructorInfo.IsFamily && !constructorInfo.IsFamilyOrAssembly && (!(superConstructor is JSConstructor) || !((JSConstructor)superConstructor).IsAccessibleFrom(enclosing_scope)))
						{
							context.HandleError(JSError.SuperClassConstructorNotAccessible);
							superConstructor = null;
						}
						else if (num3 > 0 && !Binding.CheckParameters(constructorInfo.GetParameters(), array2, superConstructorCall.arguments, superConstructorCall.context))
						{
							superConstructor = null;
						}
					}
				}
				catch (AmbiguousMatchException)
				{
					context.HandleError(JSError.AmbiguousConstructorCall);
				}
			}
			own_scope.HandleUnitializedVariables();
			globals.ScopeStack.Pop();
			must_save_stack_locals = own_scope.mustSaveStackLocals;
			fields = own_scope.GetLocalFields();
		}

		internal IReflect ReturnType(JSField inference_target)
		{
			if (!partiallyEvaluated)
			{
				PartiallyEvaluate();
			}
			if (own_scope.returnVar == null)
			{
				return Typeob.Void;
			}
			if (return_type_expr != null)
			{
				return return_type_expr.ToIReflect();
			}
			return own_scope.returnVar.GetInferredType(inference_target);
		}

		/// <summary>Returns a string representation of this function object.</summary>
		/// <returns>A string representation of this function object that contains the text of the function.</returns>
		public override string ToString()
		{
			if (text != null)
			{
				return text;
			}
			return funcContext.GetCode();
		}

		internal void TranslateBodyToIL(ILGenerator il, CompilerGlobals compilerGlobals)
		{
			returnLabel = il.DefineLabel();
			if (body.Engine.GenerateDebugInfo)
			{
				for (ScriptObject scriptObject = enclosing_scope.GetParent(); scriptObject != null; scriptObject = scriptObject.GetParent())
				{
					if (scriptObject is PackageScope)
					{
						il.UsingNamespace(((PackageScope)scriptObject).name);
					}
					else if (scriptObject is WrappedNamespace && !((WrappedNamespace)scriptObject).name.Equals(""))
					{
						il.UsingNamespace(((WrappedNamespace)scriptObject).name);
					}
				}
			}
			int startLine = body.context.StartLine;
			int startColumn = body.context.StartColumn;
			body.context.document.EmitLineInfo(il, startLine, startColumn, startLine, startColumn + 1);
			if (body.context.document.debugOn)
			{
				il.Emit(OpCodes.Nop);
			}
			int num = fields.Length;
			for (int i = 0; i < num; i++)
			{
				if (!fields[i].IsLiteral || fields[i].value is FunctionObject)
				{
					Type fieldType = fields[i].FieldType;
					LocalBuilder localBuilder = il.DeclareLocal(fieldType);
					if (fields[i].debugOn)
					{
						localBuilder.SetLocalSymInfo(fields[i].debuggerName);
					}
					fields[i].metaData = localBuilder;
				}
			}
			globals.ScopeStack.Push(own_scope);
			try
			{
				if (must_save_stack_locals)
				{
					TranslateToMethodWithStackFrame(il, compilerGlobals, staticInitializer: true);
					return;
				}
				body.TranslateToILInitializer(il);
				body.TranslateToIL(il, Typeob.Void);
				il.MarkLabel(returnLabel);
			}
			finally
			{
				globals.ScopeStack.Pop();
			}
		}

		internal void TranslateToIL(CompilerGlobals compilerGlobals)
		{
			if (suppressIL)
			{
				return;
			}
			globals.ScopeStack.Push(own_scope);
			try
			{
				if (mb == null && cb == null)
				{
					GetMethodBase(compilerGlobals);
				}
				int num = (((attributes & MethodAttributes.Static) != MethodAttributes.Static) ? 1 : 0);
				int num2 = 3;
				if (isMethod)
				{
					num2 = 0;
				}
				else if (!hasArgumentsObject)
				{
					num2 = 2;
				}
				ILGenerator iLGenerator = ((mb != null) ? mb.GetILGenerator() : cb.GetILGenerator());
				returnLabel = iLGenerator.DefineLabel();
				if (body.Engine.GenerateDebugInfo)
				{
					for (ScriptObject scriptObject = enclosing_scope.GetParent(); scriptObject != null; scriptObject = scriptObject.GetParent())
					{
						if (scriptObject is PackageScope)
						{
							iLGenerator.UsingNamespace(((PackageScope)scriptObject).name);
						}
						else if (scriptObject is WrappedNamespace && !((WrappedNamespace)scriptObject).name.Equals(""))
						{
							iLGenerator.UsingNamespace(((WrappedNamespace)scriptObject).name);
						}
					}
				}
				if (!isImplicitCtor && body != null)
				{
					int startLine = body.context.StartLine;
					int startColumn = body.context.StartColumn;
					body.context.document.EmitLineInfo(iLGenerator, startLine, startColumn, startLine, startColumn + 1);
					if (body.context.document.debugOn)
					{
						iLGenerator.Emit(OpCodes.Nop);
					}
				}
				int num3 = fields.Length;
				for (int i = 0; i < num3; i++)
				{
					int num4 = (IsNestedFunctionField(fields[i]) ? (-1) : Array.IndexOf(formal_parameters, fields[i].Name));
					if (num4 >= 0)
					{
						fields[i].metaData = (short)(num4 + num2 + num);
					}
					else if (hasArgumentsObject && fields[i].Name.Equals("arguments"))
					{
						fields[i].metaData = (short)(2 + num);
					}
					else if (!fields[i].IsLiteral || fields[i].value is FunctionObject)
					{
						Type fieldType = fields[i].FieldType;
						LocalBuilder localBuilder = iLGenerator.DeclareLocal(fieldType);
						if (fields[i].debugOn)
						{
							localBuilder.SetLocalSymInfo(fields[i].debuggerName);
						}
						fields[i].metaData = localBuilder;
					}
					else if (own_scope.mustSaveStackLocals)
					{
						LocalBuilder metaData = iLGenerator.DeclareLocal(fields[i].FieldType);
						fields[i].metaData = metaData;
					}
				}
				if (isConstructor)
				{
					int callerParameterCount = formal_parameters.Length + 1;
					ClassScope classScope = (ClassScope)enclosing_scope;
					if (superConstructor == null)
					{
						classScope.owner.EmitInitialCalls(iLGenerator, null, null, null, 0);
					}
					else
					{
						ParameterInfo[] parameters = superConstructor.GetParameters();
						if (superConstructorCall != null)
						{
							classScope.owner.EmitInitialCalls(iLGenerator, superConstructor, parameters, superConstructorCall.arguments, callerParameterCount);
						}
						else
						{
							classScope.owner.EmitInitialCalls(iLGenerator, superConstructor, parameters, null, callerParameterCount);
						}
					}
				}
				if ((isMethod || isConstructor) && must_save_stack_locals)
				{
					TranslateToMethodWithStackFrame(iLGenerator, compilerGlobals, staticInitializer: false);
					return;
				}
				TranslateToILToCopyOuterScopeLocals(iLGenerator, copyToNested: true, null);
				bool insideProtectedRegion = compilerGlobals.InsideProtectedRegion;
				compilerGlobals.InsideProtectedRegion = false;
				bool insideFinally = compilerGlobals.InsideFinally;
				int finallyStackTop = compilerGlobals.FinallyStackTop;
				compilerGlobals.InsideFinally = false;
				body.TranslateToILInitializer(iLGenerator);
				body.TranslateToIL(iLGenerator, Typeob.Void);
				compilerGlobals.InsideProtectedRegion = insideProtectedRegion;
				compilerGlobals.InsideFinally = insideFinally;
				compilerGlobals.FinallyStackTop = finallyStackTop;
				iLGenerator.MarkLabel(returnLabel);
				if (body.context.document.debugOn)
				{
					EmitLastLineInfo(iLGenerator);
					iLGenerator.Emit(OpCodes.Nop);
				}
				TranslateToILToSaveLocals(iLGenerator);
				if (own_scope.returnVar != null)
				{
					iLGenerator.Emit(OpCodes.Ldloc, (LocalBuilder)own_scope.returnVar.GetMetaData());
				}
				iLGenerator.Emit(OpCodes.Ret);
			}
			finally
			{
				globals.ScopeStack.Pop();
			}
		}

		private bool IsNestedFunctionField(JSLocalField field)
		{
			if (field.value != null)
			{
				return field.value is FunctionObject;
			}
			return false;
		}

		internal void TranslateToILToLoadEngine(ILGenerator il)
		{
			TranslateToILToLoadEngine(il, allocateLocal: false);
		}

		private void TranslateToILToLoadEngine(ILGenerator il, bool allocateLocal)
		{
			if (isMethod)
			{
				if (isStatic)
				{
					if (body.Engine.doCRS)
					{
						il.Emit(OpCodes.Ldsfld, CompilerGlobals.contextEngineField);
						return;
					}
					if (engineLocal == null)
					{
						if (allocateLocal)
						{
							engineLocal = il.DeclareLocal(Typeob.VsaEngine);
						}
						if (body.Engine.PEFileKind == PEFileKinds.Dll)
						{
							il.Emit(OpCodes.Ldtoken, ((ClassScope)own_scope.GetParent()).GetTypeBuilder());
							il.Emit(OpCodes.Call, CompilerGlobals.createVsaEngineWithType);
						}
						else
						{
							il.Emit(OpCodes.Call, CompilerGlobals.createVsaEngine);
						}
						if (!allocateLocal)
						{
							return;
						}
						il.Emit(OpCodes.Stloc, engineLocal);
					}
					il.Emit(OpCodes.Ldloc, engineLocal);
				}
				else
				{
					il.Emit(OpCodes.Ldarg_0);
					il.Emit(OpCodes.Callvirt, CompilerGlobals.getEngineMethod);
				}
			}
			else
			{
				il.Emit(OpCodes.Ldarg_1);
			}
		}

		private void TranslateToMethodWithStackFrame(ILGenerator il, CompilerGlobals compilerGlobals, bool staticInitializer)
		{
			if (isStatic)
			{
				il.Emit(OpCodes.Ldtoken, ((ClassScope)own_scope.GetParent()).GetTypeBuilder());
			}
			else
			{
				il.Emit(OpCodes.Ldarg_0);
			}
			int num = fields.Length;
			ConstantWrapper.TranslateToILInt(il, num);
			il.Emit(OpCodes.Newarr, Typeob.JSLocalField);
			for (int i = 0; i < num; i++)
			{
				JSLocalField jSLocalField = fields[i];
				il.Emit(OpCodes.Dup);
				ConstantWrapper.TranslateToILInt(il, i);
				il.Emit(OpCodes.Ldstr, jSLocalField.Name);
				il.Emit(OpCodes.Ldtoken, jSLocalField.FieldType);
				ConstantWrapper.TranslateToILInt(il, jSLocalField.slotNumber);
				il.Emit(OpCodes.Newobj, CompilerGlobals.jsLocalFieldConstructor);
				il.Emit(OpCodes.Stelem_Ref);
			}
			TranslateToILToLoadEngine(il, allocateLocal: true);
			if (isStatic)
			{
				il.Emit(OpCodes.Call, CompilerGlobals.pushStackFrameForStaticMethod);
			}
			else
			{
				il.Emit(OpCodes.Call, CompilerGlobals.pushStackFrameForMethod);
			}
			bool insideProtectedRegion = compilerGlobals.InsideProtectedRegion;
			compilerGlobals.InsideProtectedRegion = true;
			il.BeginExceptionBlock();
			body.TranslateToILInitializer(il);
			body.TranslateToIL(il, Typeob.Void);
			il.MarkLabel(returnLabel);
			TranslateToILToSaveLocals(il);
			Label label = il.DefineLabel();
			il.Emit(OpCodes.Leave, label);
			il.BeginFinallyBlock();
			TranslateToILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.popScriptObjectMethod);
			il.Emit(OpCodes.Pop);
			il.EndExceptionBlock();
			il.MarkLabel(label);
			if (!staticInitializer)
			{
				if (body.context.document.debugOn)
				{
					EmitLastLineInfo(il);
					il.Emit(OpCodes.Nop);
				}
				if (own_scope.returnVar != null)
				{
					il.Emit(OpCodes.Ldloc, (LocalBuilder)own_scope.returnVar.GetMetaData());
				}
				il.Emit(OpCodes.Ret);
			}
			compilerGlobals.InsideProtectedRegion = insideProtectedRegion;
		}

		internal void TranslateToILToRestoreLocals(ILGenerator il)
		{
			TranslateToILToRestoreLocals(il, null);
		}

		internal void TranslateToILToRestoreLocals(ILGenerator il, JSLocalField[] notToBeRestored)
		{
			TranslateToILToCopyOuterScopeLocals(il, copyToNested: true, notToBeRestored);
			if (!must_save_stack_locals)
			{
				return;
			}
			int num = (((attributes & MethodAttributes.Static) != MethodAttributes.Static) ? 1 : 0);
			int num2 = 3;
			if (isMethod)
			{
				num2 = 0;
			}
			else if (!hasArgumentsObject)
			{
				num2 = 2;
			}
			int num3 = fields.Length;
			TranslateToILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
			ScriptObject scriptObject = globals.ScopeStack.Peek();
			while (scriptObject is WithObject || scriptObject is BlockScope)
			{
				il.Emit(OpCodes.Call, CompilerGlobals.getParentMethod);
				scriptObject = scriptObject.GetParent();
			}
			il.Emit(OpCodes.Castclass, Typeob.StackFrame);
			il.Emit(OpCodes.Ldfld, CompilerGlobals.localVarsField);
			for (int i = 0; i < num3; i++)
			{
				if (notToBeRestored != null)
				{
					if (IsPresentIn(fields[i], notToBeRestored))
					{
						continue;
					}
				}
				if (!fields[i].IsLiteral)
				{
					il.Emit(OpCodes.Dup);
					int num4 = Array.IndexOf(formal_parameters, fields[i].Name);
					ConstantWrapper.TranslateToILInt(il, fields[i].slotNumber);
					il.Emit(OpCodes.Ldelem_Ref);
					Convert.Emit(body, il, Typeob.Object, fields[i].FieldType);
					if (num4 >= 0 || (fields[i].Name.Equals("arguments") && hasArgumentsObject))
					{
						il.Emit(OpCodes.Starg, (short)(num4 + num2 + num));
					}
					else
					{
						il.Emit(OpCodes.Stloc, (LocalBuilder)fields[i].metaData);
					}
				}
			}
			il.Emit(OpCodes.Pop);
		}

		internal void TranslateToILToSaveLocals(ILGenerator il)
		{
			TranslateToILToCopyOuterScopeLocals(il, copyToNested: false, null);
			if (!must_save_stack_locals)
			{
				return;
			}
			int num = (((attributes & MethodAttributes.Static) != MethodAttributes.Static) ? 1 : 0);
			int num2 = 3;
			if (isMethod)
			{
				num2 = 0;
			}
			else if (!hasArgumentsObject)
			{
				num2 = 2;
			}
			int num3 = fields.Length;
			TranslateToILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
			ScriptObject scriptObject = globals.ScopeStack.Peek();
			while (scriptObject is WithObject || scriptObject is BlockScope)
			{
				il.Emit(OpCodes.Call, CompilerGlobals.getParentMethod);
				scriptObject = scriptObject.GetParent();
			}
			il.Emit(OpCodes.Castclass, Typeob.StackFrame);
			il.Emit(OpCodes.Ldfld, CompilerGlobals.localVarsField);
			for (int i = 0; i < num3; i++)
			{
				JSLocalField jSLocalField = fields[i];
				if (!jSLocalField.IsLiteral || jSLocalField.value is FunctionObject)
				{
					il.Emit(OpCodes.Dup);
					ConstantWrapper.TranslateToILInt(il, jSLocalField.slotNumber);
					int num4 = Array.IndexOf(formal_parameters, jSLocalField.Name);
					if (num4 >= 0 || (jSLocalField.Name.Equals("arguments") && hasArgumentsObject))
					{
						Convert.EmitLdarg(il, (short)(num4 + num2 + num));
					}
					else
					{
						il.Emit(OpCodes.Ldloc, (LocalBuilder)jSLocalField.metaData);
					}
					Convert.Emit(body, il, jSLocalField.FieldType, Typeob.Object);
					il.Emit(OpCodes.Stelem_Ref);
				}
			}
			il.Emit(OpCodes.Pop);
		}

		private void TranslateToILToCopyOuterScopeLocals(ILGenerator il, bool copyToNested, JSLocalField[] notToBeRestored)
		{
			if (own_scope.ProvidesOuterScopeLocals == null || own_scope.ProvidesOuterScopeLocals.count == 0)
			{
				return;
			}
			TranslateToILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
			ScriptObject scriptObject = globals.ScopeStack.Peek();
			while (scriptObject is WithObject || scriptObject is BlockScope)
			{
				il.Emit(OpCodes.Call, CompilerGlobals.getParentMethod);
				scriptObject = scriptObject.GetParent();
			}
			for (scriptObject = enclosing_scope; scriptObject != null; scriptObject = scriptObject.GetParent())
			{
				il.Emit(OpCodes.Call, CompilerGlobals.getParentMethod);
				if (scriptObject is FunctionScope && ((FunctionScope)scriptObject).owner != null && own_scope.ProvidesOuterScopeLocals[scriptObject] != null)
				{
					il.Emit(OpCodes.Dup);
					il.Emit(OpCodes.Castclass, Typeob.StackFrame);
					il.Emit(OpCodes.Ldfld, CompilerGlobals.localVarsField);
					if (copyToNested)
					{
						((FunctionScope)scriptObject).owner.TranslateToILToCopyLocalsToNestedScope(il, own_scope, notToBeRestored);
					}
					else
					{
						((FunctionScope)scriptObject).owner.TranslateToILToCopyLocalsFromNestedScope(il, own_scope);
					}
				}
				else if (scriptObject is GlobalScope || scriptObject is ClassScope)
				{
					break;
				}
			}
			il.Emit(OpCodes.Pop);
		}

		private void TranslateToILToCopyLocalsToNestedScope(ILGenerator il, FunctionScope nestedScope, JSLocalField[] notToBeRestored)
		{
			int num = (((attributes & MethodAttributes.Static) != MethodAttributes.Static) ? 1 : 0);
			int num2 = fields.Length;
			for (int i = 0; i < num2; i++)
			{
				JSLocalField outerLocalField = nestedScope.GetOuterLocalField(fields[i].Name);
				if (outerLocalField == null || outerLocalField.outerField != fields[i])
				{
					continue;
				}
				if (notToBeRestored != null)
				{
					if (IsPresentIn(outerLocalField, notToBeRestored))
					{
						continue;
					}
				}
				il.Emit(OpCodes.Dup);
				ConstantWrapper.TranslateToILInt(il, fields[i].slotNumber);
				il.Emit(OpCodes.Ldelem_Ref);
				Convert.Emit(body, il, Typeob.Object, fields[i].FieldType);
				il.Emit(OpCodes.Stloc, (LocalBuilder)outerLocalField.metaData);
			}
			il.Emit(OpCodes.Pop);
		}

		private void TranslateToILToCopyLocalsFromNestedScope(ILGenerator il, FunctionScope nestedScope)
		{
			int num = (((attributes & MethodAttributes.Static) != MethodAttributes.Static) ? 1 : 0);
			int num2 = fields.Length;
			for (int i = 0; i < num2; i++)
			{
				JSLocalField outerLocalField = nestedScope.GetOuterLocalField(fields[i].Name);
				if (!(outerLocalField == null) && !(outerLocalField.outerField != fields[i]))
				{
					il.Emit(OpCodes.Dup);
					ConstantWrapper.TranslateToILInt(il, fields[i].slotNumber);
					il.Emit(OpCodes.Ldloc, (LocalBuilder)outerLocalField.metaData);
					Convert.Emit(body, il, fields[i].FieldType, Typeob.Object);
					il.Emit(OpCodes.Stelem_Ref);
				}
			}
			il.Emit(OpCodes.Pop);
		}
	}
	/// <summary>Provides static methods and properties for <see cref="T:Microsoft.JScript.FunctionObject" /> objects. All methods of this class are called by passing in a reference to the object that is requesting access to the method. This class belongs to the built-in object model category.</summary>
	public class FunctionPrototype : ScriptFunction
	{
		internal static readonly FunctionPrototype ob = new FunctionPrototype(ObjectPrototype.CommonInstance());

		internal static FunctionConstructor _constructor;

		/// <summary>Gets a reference to a prototype-based object that is using this prototype.</summary>
		/// <returns>A reference to a prototype-based object.</returns>
		public static FunctionConstructor constructor => _constructor;

		internal FunctionPrototype(ScriptObject parent)
			: base(parent)
		{
		}

		internal override object Call(object[] args, object thisob)
		{
			return null;
		}

		/// <summary>Calls the function that this object represents, converting the specified argument object to an array of arguments if it has to.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="thisarg">The current default scope. Either the contained object of a <see langword="with" /> statement scope, or the global scope.</param>
		/// <param name="argArray">The arguments to pass to the function, as an <see cref="T:Microsoft.JScript.ArgumentsObject" /> or an <see cref="T:Microsoft.JScript.ArrayObject" />.</param>
		/// <returns>The return value of the call to the function that this object represents.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Function_apply)]
		public static object apply(object thisob, object thisarg, object argArray)
		{
			if (!(thisob is ScriptFunction))
			{
				throw new JScriptException(JSError.FunctionExpected);
			}
			if (thisarg is Missing)
			{
				thisarg = ((IActivationObject)((ScriptFunction)thisob).engine.ScriptObjectStackTop()).GetDefaultThisObject();
			}
			if (argArray is Missing)
			{
				return ((ScriptFunction)thisob).Call(new object[0], thisarg);
			}
			if (argArray is ArgumentsObject)
			{
				return ((ScriptFunction)thisob).Call(((ArgumentsObject)argArray).ToArray(), thisarg);
			}
			if (argArray is ArrayObject)
			{
				return ((ScriptFunction)thisob).Call(((ArrayObject)argArray).ToArray(), thisarg);
			}
			throw new JScriptException(JSError.InvalidCall);
		}

		/// <summary>Calls the function that this object represents.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="thisarg">The current default scope. Either the contained object of a <see langword="with" /> statement scope, or the global scope.</param>
		/// <param name="args">The arguments to pass to the function as an array.</param>
		/// <returns>The return value of the call to the function that this object represents.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasVarArgs, JSBuiltin.Function_call)]
		public static object call(object thisob, object thisarg, params object[] args)
		{
			if (!(thisob is ScriptFunction))
			{
				throw new JScriptException(JSError.FunctionExpected);
			}
			if (thisarg is Missing)
			{
				thisarg = ((IActivationObject)((ScriptFunction)thisob).engine.ScriptObjectStackTop()).GetDefaultThisObject();
			}
			return ((ScriptFunction)thisob).Call(args, thisarg);
		}

		/// <summary>Creates a string representation of the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" /> that contains the name of the function.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Function_toString)]
		public static string toString(object thisob)
		{
			if (thisob is ScriptFunction)
			{
				return thisob.ToString();
			}
			throw new JScriptException(JSError.FunctionExpected);
		}
	}
	internal sealed class FunctionScope : ActivationObject
	{
		internal bool isMethod;

		internal bool isStatic;

		internal bool mustSaveStackLocals;

		internal JSLocalField returnVar;

		internal FunctionObject owner;

		internal ArrayList nested_functions;

		private ArrayList fields_for_nested_functions;

		internal SimpleHashtable ProvidesOuterScopeLocals;

		internal bool closuresMightEscape;

		internal BitArray DefinedFlags
		{
			get
			{
				int count = field_table.Count;
				BitArray bitArray = new BitArray(count);
				for (int i = 0; i < count; i++)
				{
					JSLocalField jSLocalField = (JSLocalField)field_table[i];
					if (jSLocalField.isDefined)
					{
						bitArray[i] = true;
					}
				}
				return bitArray;
			}
			set
			{
				int count = value.Count;
				for (int i = 0; i < count; i++)
				{
					JSLocalField jSLocalField = (JSLocalField)field_table[i];
					jSLocalField.isDefined = value[i];
				}
			}
		}

		internal FunctionScope(ScriptObject parent)
			: this(parent, isMethod: false)
		{
		}

		internal FunctionScope(ScriptObject parent, bool isMethod)
			: base(parent)
		{
			isKnownAtCompileTime = true;
			this.isMethod = isMethod;
			mustSaveStackLocals = false;
			if (parent != null && parent is ActivationObject)
			{
				fast = ((ActivationObject)parent).fast;
			}
			else
			{
				fast = false;
			}
			returnVar = null;
			owner = null;
			isStatic = false;
			nested_functions = null;
			fields_for_nested_functions = null;
			if (parent is FunctionScope)
			{
				ProvidesOuterScopeLocals = new SimpleHashtable(16u);
			}
			else
			{
				ProvidesOuterScopeLocals = null;
			}
			closuresMightEscape = false;
		}

		internal JSVariableField AddNewField(string name, FieldAttributes attributeFlags, FunctionObject func)
		{
			if (nested_functions == null)
			{
				nested_functions = new ArrayList();
				fields_for_nested_functions = new ArrayList();
			}
			nested_functions.Add(func);
			JSVariableField jSVariableField = AddNewField(name, func, attributeFlags);
			fields_for_nested_functions.Add(jSVariableField);
			return jSVariableField;
		}

		protected override JSVariableField CreateField(string name, FieldAttributes attributeFlags, object value)
		{
			if ((attributeFlags & FieldAttributes.Static) != 0)
			{
				return new JSGlobalField(this, name, value, attributeFlags);
			}
			return new JSLocalField(name, this, field_table.Count, value);
		}

		internal void AddOuterScopeField(string name, JSLocalField field)
		{
			name_table[name] = field;
			field_table.Add(field);
		}

		internal void AddReturnValueField()
		{
			if (name_table["return value"] == null)
			{
				returnVar = new JSLocalField("return value", this, field_table.Count, Missing.Value);
				name_table["return value"] = returnVar;
				field_table.Add(returnVar);
			}
		}

		internal void CloseNestedFunctions(StackFrame sf)
		{
			if (nested_functions != null)
			{
				IEnumerator enumerator = nested_functions.GetEnumerator();
				IEnumerator enumerator2 = fields_for_nested_functions.GetEnumerator();
				while (enumerator.MoveNext() && enumerator2.MoveNext())
				{
					FieldInfo fieldInfo = (FieldInfo)enumerator2.Current;
					FunctionObject functionObject = (FunctionObject)enumerator.Current;
					functionObject.enclosing_scope = sf;
					fieldInfo.SetValue(sf, new Closure(functionObject));
				}
			}
		}

		internal JSLocalField[] GetLocalFields()
		{
			int count = field_table.Count;
			JSLocalField[] array = new JSLocalField[field_table.Count];
			for (int i = 0; i < count; i++)
			{
				array[i] = (JSLocalField)field_table[i];
			}
			return array;
		}

		public override MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
		{
			FieldInfo fieldInfo = (FieldInfo)name_table[name];
			if (fieldInfo != null)
			{
				return new MemberInfo[1] { fieldInfo };
			}
			bool flag = false;
			ScriptObject scriptObject = parent;
			while (scriptObject is FunctionScope)
			{
				FunctionScope functionScope = (FunctionScope)scriptObject;
				flag = functionScope.isMethod && !functionScope.isStatic;
				JSLocalField jSLocalField = (JSLocalField)functionScope.name_table[name];
				if (jSLocalField == null)
				{
					scriptObject = scriptObject.GetParent();
					continue;
				}
				if (jSLocalField.IsLiteral && !(jSLocalField.value is FunctionObject))
				{
					return new MemberInfo[1] { jSLocalField };
				}
				JSLocalField jSLocalField2 = new JSLocalField(jSLocalField.Name, this, field_table.Count, Missing.Value);
				jSLocalField2.outerField = jSLocalField;
				jSLocalField2.debugOn = jSLocalField.debugOn;
				if (!jSLocalField2.debugOn && owner.funcContext.document.debugOn && functionScope.owner.funcContext.document.debugOn)
				{
					jSLocalField2.debugOn = Array.IndexOf(functionScope.owner.formal_parameters, jSLocalField.Name) >= 0;
				}
				jSLocalField2.isDefined = jSLocalField.isDefined;
				jSLocalField2.debuggerName = "outer." + jSLocalField2.Name;
				if (jSLocalField.IsLiteral)
				{
					jSLocalField2.attributeFlags |= FieldAttributes.Literal;
					jSLocalField2.value = jSLocalField.value;
				}
				AddOuterScopeField(name, jSLocalField2);
				if (ProvidesOuterScopeLocals[scriptObject] == null)
				{
					ProvidesOuterScopeLocals[scriptObject] = scriptObject;
				}
				((FunctionScope)scriptObject).mustSaveStackLocals = true;
				return new MemberInfo[1] { jSLocalField2 };
			}
			if (scriptObject is ClassScope && flag)
			{
				MemberInfo[] member = scriptObject.GetMember(name, bindingAttr & ~BindingFlags.DeclaredOnly);
				int num = member.Length;
				bool flag2 = false;
				for (int i = 0; i < num; i++)
				{
					MemberInfo memberInfo = member[i];
					switch (memberInfo.MemberType)
					{
					case MemberTypes.Field:
						fieldInfo = (FieldInfo)memberInfo;
						if (fieldInfo.IsLiteral)
						{
							JSMemberField jSMemberField = fieldInfo as JSMemberField;
							if (jSMemberField != null && jSMemberField.value is ClassScope && !((ClassScope)jSMemberField.value).owner.IsStatic)
							{
								flag2 = true;
							}
						}
						if (!fieldInfo.IsStatic && !fieldInfo.IsLiteral)
						{
							member[i] = new JSClosureField(fieldInfo);
							flag2 = true;
						}
						break;
					case MemberTypes.Method:
					{
						MethodInfo methodInfo3 = (MethodInfo)memberInfo;
						if (!methodInfo3.IsStatic)
						{
							member[i] = new JSClosureMethod(methodInfo3);
							flag2 = true;
						}
						break;
					}
					case MemberTypes.Property:
					{
						PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
						MethodInfo methodInfo = JSProperty.GetGetMethod(propertyInfo, (bindingAttr & BindingFlags.NonPublic) != 0);
						MethodInfo methodInfo2 = JSProperty.GetSetMethod(propertyInfo, (bindingAttr & BindingFlags.NonPublic) != 0);
						bool flag3 = false;
						if (methodInfo != null && !methodInfo.IsStatic)
						{
							flag3 = true;
							methodInfo = new JSClosureMethod(methodInfo);
						}
						if (methodInfo2 != null && !methodInfo2.IsStatic)
						{
							flag3 = true;
							methodInfo2 = new JSClosureMethod(methodInfo2);
						}
						if (flag3)
						{
							member[i] = new JSClosureProperty(propertyInfo, methodInfo, methodInfo2);
							flag2 = true;
						}
						break;
					}
					}
				}
				if (flag2)
				{
					GiveOuterFunctionsTheBadNews();
				}
				if (num > 0)
				{
					return member;
				}
			}
			if ((bindingAttr & BindingFlags.DeclaredOnly) != 0)
			{
				return new MemberInfo[0];
			}
			return scriptObject.GetMember(name, bindingAttr);
		}

		internal override string GetName()
		{
			string text = null;
			if (parent != null)
			{
				text = ((ActivationObject)parent).GetName();
			}
			if (text != null)
			{
				return text + "." + owner.name;
			}
			return owner.name;
		}

		internal int GetNextSlotNumber()
		{
			return field_table.Count;
		}

		internal JSLocalField GetOuterLocalField(string name)
		{
			FieldInfo fieldInfo = (FieldInfo)name_table[name];
			if (fieldInfo != null && fieldInfo is JSLocalField && ((JSLocalField)fieldInfo).outerField != null)
			{
				return (JSLocalField)fieldInfo;
			}
			return null;
		}

		private void GiveOuterFunctionsTheBadNews()
		{
			FunctionScope functionScope = (FunctionScope)parent;
			functionScope.mustSaveStackLocals = true;
			while (!functionScope.isMethod)
			{
				functionScope = (FunctionScope)functionScope.GetParent();
				functionScope.mustSaveStackLocals = true;
			}
		}

		internal void HandleUnitializedVariables()
		{
			int i = 0;
			for (int count = field_table.Count; i < count; i++)
			{
				JSLocalField jSLocalField = (JSLocalField)field_table[i];
				if (jSLocalField.isUsedBeforeDefinition)
				{
					jSLocalField.SetInferredType(Typeob.Object, null);
				}
			}
		}

		internal override void SetMemberValue(string name, object value)
		{
			FieldInfo fieldInfo = (FieldInfo)name_table[name];
			if (fieldInfo != null)
			{
				fieldInfo.SetValue(this, value);
			}
			else
			{
				parent.SetMemberValue(name, value);
			}
		}

		internal void SetMemberValue(string name, object value, StackFrame sf)
		{
			FieldInfo fieldInfo = (FieldInfo)name_table[name];
			if (fieldInfo != null)
			{
				fieldInfo.SetValue(sf, value);
			}
			else
			{
				parent.SetMemberValue(name, value);
			}
		}
	}
	/// <summary>Binds the members of a function to an object.</summary>
	public sealed class FunctionWrapper : ScriptFunction
	{
		private object obj;

		private MemberInfo[] members;

		internal FunctionWrapper(string name, object obj, MemberInfo[] members)
			: base(FunctionPrototype.ob, name, 0)
		{
			this.obj = obj;
			this.members = members;
			foreach (MemberInfo memberInfo in members)
			{
				if (memberInfo is MethodInfo)
				{
					ilength = ((MethodInfo)memberInfo).GetParameters().Length;
					break;
				}
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object Call(object[] args, object thisob)
		{
			return Call(args, thisob, null, null);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object Call(object[] args, object thisob, Binder binder, CultureInfo culture)
		{
			MethodInfo methodInfo = members[0] as MethodInfo;
			if (thisob is GlobalScope || thisob == null || (methodInfo != null && (methodInfo.Attributes & MethodAttributes.Static) != 0))
			{
				thisob = obj;
			}
			else if (!obj.GetType().IsInstanceOfType(thisob) && !(obj is ClassScope))
			{
				if (members.Length == 1)
				{
					JSWrappedMethod jSWrappedMethod = members[0] as JSWrappedMethod;
					if (jSWrappedMethod != null && jSWrappedMethod.DeclaringType == Typeob.Object)
					{
						return LateBinding.CallOneOfTheMembers(new MemberInfo[1] { jSWrappedMethod.method }, args, construct: false, thisob, binder, culture, null, engine);
					}
				}
				throw new JScriptException(JSError.TypeMismatch);
			}
			return LateBinding.CallOneOfTheMembers(members, args, construct: false, thisob, binder, culture, null, engine);
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		internal Delegate ConvertToDelegate(Type delegateType)
		{
			return Delegate.CreateDelegate(delegateType, obj, name);
		}

		/// <summary>Creates a string representation of the function.</summary>
		/// <returns>A string representation of the function that contains the function source, the function members, and the function name.</returns>
		public override string ToString()
		{
			Type declaringType = members[0].DeclaringType;
			MethodInfo methodInfo = ((declaringType == null) ? null : declaringType.GetMethod(name + " source"));
			if (methodInfo == null)
			{
				StringBuilder stringBuilder = new StringBuilder();
				bool flag = true;
				MemberInfo[] array = members;
				foreach (MemberInfo memberInfo in array)
				{
					if (memberInfo is MethodInfo || (memberInfo is PropertyInfo && JSProperty.GetGetMethod((PropertyInfo)memberInfo, nonPublic: false) != null))
					{
						if (!flag)
						{
							stringBuilder.Append("\n");
						}
						else
						{
							flag = false;
						}
						stringBuilder.Append(memberInfo.ToString());
					}
				}
				if (stringBuilder.Length > 0)
				{
					return stringBuilder.ToString();
				}
				return "function " + name + "() {\n    [native code]\n}";
			}
			return (string)methodInfo.Invoke(null, null);
		}
	}
	/// <summary>Stores constants, data type information, utility functions, and references to prototype-based objects. This class belongs to the built-in object model category.</summary>
	public class GlobalObject
	{
		private enum URISetType
		{
			None,
			Reserved,
			Unescaped
		}

		internal static readonly GlobalObject commonInstance = new GlobalObject();

		/// <summary>Represents positive infinity. This field is constant.</summary>
		public const double Infinity = double.PositiveInfinity;

		/// <summary>Represents a value that is not a number (NaN). This field is constant.</summary>
		public const double NaN = double.NaN;

		/// <summary>Represents a value that is null.</summary>
		public static readonly Empty undefined = null;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ActiveXObjectConstructor" /> object.</summary>
		protected ActiveXObjectConstructor originalActiveXObjectField;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ArrayConstructor" /> object.</summary>
		protected ArrayConstructor originalArrayField;

		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.BooleanConstructor" /> object.</summary>
		protected BooleanConstructor originalBooleanField;

		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.DateConstructor" /> object.</summary>
		protected DateConstructor originalDateField;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.EnumeratorConstructor" /> object.</summary>
		protected EnumeratorConstructor originalEnumeratorField;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object.</summary>
		protected ErrorConstructor originalErrorField;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as an <see cref="F:Microsoft.JScript.ErrorType.EvalError" />.</summary>
		protected ErrorConstructor originalEvalErrorField;

		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.FunctionConstructor" /> object.</summary>
		protected FunctionConstructor originalFunctionField;

		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.NumberConstructor" /> object.</summary>
		protected NumberConstructor originalNumberField;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ObjectConstructor" /> object.</summary>
		protected ObjectConstructor originalObjectField;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ObjectPrototype" /> object.</summary>
		protected ObjectPrototype originalObjectPrototypeField;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.RangeError" />.</summary>
		protected ErrorConstructor originalRangeErrorField;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.ReferenceError" />.</summary>
		protected ErrorConstructor originalReferenceErrorField;

		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.RegExpConstructor" /> object.</summary>
		protected RegExpConstructor originalRegExpField;

		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.StringConstructor" /> object.</summary>
		protected StringConstructor originalStringField;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.SyntaxError" />.</summary>
		protected ErrorConstructor originalSyntaxErrorField;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.TypeError" />.</summary>
		protected ErrorConstructor originalTypeErrorField;

		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.VBArrayConstructor" /> object.</summary>
		protected VBArrayConstructor originalVBArrayField;

		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.URIError" />.</summary>
		protected ErrorConstructor originalURIErrorField;

		/// <summary>Gets a reference to an <see cref="T:Microsoft.JScript.ActiveXObjectConstructor" /> object.</summary>
		/// <returns>A reference to an <see cref="T:Microsoft.JScript.ActiveXObjectConstructor" /> object.</returns>
		public static ActiveXObjectConstructor ActiveXObject => ActiveXObjectConstructor.ob;

		/// <summary>Gets a reference to an <see cref="T:Microsoft.JScript.ArrayConstructor" /> object.</summary>
		/// <returns>A reference to an <see cref="T:Microsoft.JScript.ArrayConstructor" /> object.</returns>
		public static ArrayConstructor Array => ArrayConstructor.ob;

		/// <summary>Gets a reference to a <see cref="T:Microsoft.JScript.BooleanConstructor" /> object.</summary>
		/// <returns>A reference to a <see cref="T:Microsoft.JScript.BooleanConstructor" /> object.</returns>
		public static BooleanConstructor Boolean => BooleanConstructor.ob;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="boolean" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="boolean" /> data type.</returns>
		public static Type boolean => Typeob.Boolean;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="byte" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="byte" /> data type.</returns>
		public static Type @byte => Typeob.Byte;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="char" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="char" /> data type.</returns>
		public static Type @char => Typeob.Char;

		/// <summary>Gets a reference to a <see cref="T:Microsoft.JScript.DateConstructor" /> object.</summary>
		/// <returns>A reference to a <see cref="T:Microsoft.JScript.DateConstructor" /> object.</returns>
		public static DateConstructor Date => DateConstructor.ob;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="decimal" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="decimal" /> data type.</returns>
		public static Type @decimal => Typeob.Decimal;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="double" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="double" /> data type.</returns>
		public static Type @double => Typeob.Double;

		/// <summary>Gets a reference to an <see cref="T:Microsoft.JScript.EnumeratorConstructor" /> object.</summary>
		/// <returns>A reference to an <see cref="T:Microsoft.JScript.EnumeratorConstructor" /> object.</returns>
		public static EnumeratorConstructor Enumerator => EnumeratorConstructor.ob;

		/// <summary>Gets a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object.</summary>
		/// <returns>A reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object.</returns>
		public static ErrorConstructor Error => ErrorConstructor.ob;

		/// <summary>Gets a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as an <see cref="F:Microsoft.JScript.ErrorType.EvalError" />.</summary>
		/// <returns>A reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as an <see cref="F:Microsoft.JScript.ErrorType.EvalError" />.</returns>
		public static ErrorConstructor EvalError => ErrorConstructor.evalOb;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="float" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="float" /> data type.</returns>
		public static Type @float => Typeob.Single;

		/// <summary>Gets a reference to a <see cref="T:Microsoft.JScript.FunctionConstructor" /> object.</summary>
		/// <returns>A reference to a <see cref="T:Microsoft.JScript.FunctionConstructor" /> object.</returns>
		public static FunctionConstructor Function => FunctionConstructor.ob;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="int" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="int" /> data type.</returns>
		public static Type @int => Typeob.Int32;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="long" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="long" /> data type.</returns>
		public static Type @long => Typeob.Int64;

		/// <summary>Gets a reference to a <see cref="T:Microsoft.JScript.MathObject" /> object.</summary>
		/// <returns>A reference to a <see cref="T:Microsoft.JScript.MathObject" /> object.</returns>
		public static MathObject Math
		{
			get
			{
				if (MathObject.ob == null)
				{
					MathObject.ob = new MathObject(ObjectPrototype.ob);
				}
				return MathObject.ob;
			}
		}

		/// <summary>Gets a reference to a <see cref="T:Microsoft.JScript.NumberConstructor" /> object.</summary>
		/// <returns>A reference to a <see cref="T:Microsoft.JScript.NumberConstructor" /> object.</returns>
		public static NumberConstructor Number => NumberConstructor.ob;

		/// <summary>Gets a reference to an <see cref="T:Microsoft.JScript.ObjectConstructor" /> object.</summary>
		/// <returns>A reference to an <see cref="T:Microsoft.JScript.ObjectConstructor" /> object.</returns>
		public static ObjectConstructor Object => ObjectConstructor.ob;

		internal virtual ActiveXObjectConstructor originalActiveXObject
		{
			get
			{
				if (originalActiveXObjectField == null)
				{
					originalActiveXObjectField = ActiveXObjectConstructor.ob;
				}
				return originalActiveXObjectField;
			}
		}

		internal virtual ArrayConstructor originalArray
		{
			get
			{
				if (originalArrayField == null)
				{
					originalArrayField = ArrayConstructor.ob;
				}
				return originalArrayField;
			}
		}

		internal virtual BooleanConstructor originalBoolean
		{
			get
			{
				if (originalBooleanField == null)
				{
					originalBooleanField = BooleanConstructor.ob;
				}
				return originalBooleanField;
			}
		}

		internal virtual DateConstructor originalDate
		{
			get
			{
				if (originalDateField == null)
				{
					originalDateField = DateConstructor.ob;
				}
				return originalDateField;
			}
		}

		internal virtual EnumeratorConstructor originalEnumerator
		{
			get
			{
				if (originalEnumeratorField == null)
				{
					originalEnumeratorField = EnumeratorConstructor.ob;
				}
				return originalEnumeratorField;
			}
		}

		internal virtual ErrorConstructor originalError
		{
			get
			{
				if (originalErrorField == null)
				{
					originalErrorField = ErrorConstructor.ob;
				}
				return originalErrorField;
			}
		}

		internal virtual ErrorConstructor originalEvalError
		{
			get
			{
				if (originalEvalErrorField == null)
				{
					originalEvalErrorField = ErrorConstructor.evalOb;
				}
				return originalEvalErrorField;
			}
		}

		internal virtual FunctionConstructor originalFunction
		{
			get
			{
				if (originalFunctionField == null)
				{
					originalFunctionField = FunctionConstructor.ob;
				}
				return originalFunctionField;
			}
		}

		internal virtual NumberConstructor originalNumber
		{
			get
			{
				if (originalNumberField == null)
				{
					originalNumberField = NumberConstructor.ob;
				}
				return originalNumberField;
			}
		}

		internal virtual ObjectConstructor originalObject
		{
			get
			{
				if (originalObjectField == null)
				{
					originalObjectField = ObjectConstructor.ob;
				}
				return originalObjectField;
			}
		}

		internal virtual ObjectPrototype originalObjectPrototype
		{
			get
			{
				if (originalObjectPrototypeField == null)
				{
					originalObjectPrototypeField = ObjectPrototype.ob;
				}
				return originalObjectPrototypeField;
			}
		}

		internal virtual ErrorConstructor originalRangeError
		{
			get
			{
				if (originalRangeErrorField == null)
				{
					originalRangeErrorField = ErrorConstructor.rangeOb;
				}
				return originalRangeErrorField;
			}
		}

		internal virtual ErrorConstructor originalReferenceError
		{
			get
			{
				if (originalReferenceErrorField == null)
				{
					originalReferenceErrorField = ErrorConstructor.referenceOb;
				}
				return originalReferenceErrorField;
			}
		}

		internal virtual RegExpConstructor originalRegExp
		{
			get
			{
				if (originalRegExpField == null)
				{
					originalRegExpField = RegExpConstructor.ob;
				}
				return originalRegExpField;
			}
		}

		internal virtual StringConstructor originalString
		{
			get
			{
				if (originalStringField == null)
				{
					originalStringField = StringConstructor.ob;
				}
				return originalStringField;
			}
		}

		internal virtual ErrorConstructor originalSyntaxError
		{
			get
			{
				if (originalSyntaxErrorField == null)
				{
					originalSyntaxErrorField = ErrorConstructor.syntaxOb;
				}
				return originalSyntaxErrorField;
			}
		}

		internal virtual ErrorConstructor originalTypeError
		{
			get
			{
				if (originalTypeErrorField == null)
				{
					originalTypeErrorField = ErrorConstructor.typeOb;
				}
				return originalTypeErrorField;
			}
		}

		internal virtual ErrorConstructor originalURIError
		{
			get
			{
				if (originalURIErrorField == null)
				{
					originalURIErrorField = ErrorConstructor.uriOb;
				}
				return originalURIErrorField;
			}
		}

		internal virtual VBArrayConstructor originalVBArray
		{
			get
			{
				if (originalVBArrayField == null)
				{
					originalVBArrayField = VBArrayConstructor.ob;
				}
				return originalVBArrayField;
			}
		}

		/// <summary>Gets a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.RangeError" />.</summary>
		/// <returns>A reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.RangeError" />.</returns>
		public static ErrorConstructor RangeError => ErrorConstructor.rangeOb;

		/// <summary>Gets a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.ReferenceError" />.</summary>
		/// <returns>A reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.ReferenceError" />.</returns>
		public static ErrorConstructor ReferenceError => ErrorConstructor.referenceOb;

		/// <summary>Gets a reference to a <see cref="T:Microsoft.JScript.RegExpConstructor" /> object.</summary>
		/// <returns>A reference to a <see cref="T:Microsoft.JScript.RegExpConstructor" /> object.</returns>
		public static RegExpConstructor RegExp => RegExpConstructor.ob;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="sbyte" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="sbyte" /> data type.</returns>
		public static Type @sbyte => Typeob.SByte;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="short" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="short" /> data type.</returns>
		public static Type @short => Typeob.Int16;

		/// <summary>Gets a reference to a <see cref="T:Microsoft.JScript.StringConstructor" /> object.</summary>
		/// <returns>A reference to a <see cref="T:Microsoft.JScript.StringConstructor" /> object.</returns>
		public static StringConstructor String => StringConstructor.ob;

		/// <summary>Gets a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.SyntaxError" />.</summary>
		/// <returns>A reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.SyntaxError" />.</returns>
		public static ErrorConstructor SyntaxError => ErrorConstructor.syntaxOb;

		/// <summary>Gets a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.TypeError" />.</summary>
		/// <returns>A reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.TypeError" />.</returns>
		public static ErrorConstructor TypeError => ErrorConstructor.typeOb;

		/// <summary>Gets a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.URIError" />.</summary>
		/// <returns>A reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object. The object is initialized as a <see cref="F:Microsoft.JScript.ErrorType.URIError" />.</returns>
		public static ErrorConstructor URIError => ErrorConstructor.uriOb;

		/// <summary>Gets a reference to a <see cref="T:Microsoft.JScript.VBArrayConstructor" /> object.</summary>
		/// <returns>A reference to a <see cref="T:Microsoft.JScript.VBArrayConstructor" /> object.</returns>
		public static VBArrayConstructor VBArray => VBArrayConstructor.ob;

		/// <summary>Gets the managed type that corresponds to the return value of a function that does not return a value.</summary>
		/// <returns>The managed type that corresponds to the return value of a function that does not return a value.</returns>
		public static Type @void => Typeob.Void;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="uint" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="uint" /> data type.</returns>
		public static Type @uint => Typeob.UInt32;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="ulong" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="ulong" /> data type.</returns>
		public static Type @ulong => Typeob.UInt64;

		/// <summary>Gets the managed type that corresponds to the JScript <see langword="ushort" /> data type.</summary>
		/// <returns>The managed type that corresponds to the JScript <see langword="ushort" /> data type.</returns>
		public static Type @ushort => Typeob.UInt16;

		internal GlobalObject()
		{
			originalActiveXObjectField = null;
			originalArrayField = null;
			originalBooleanField = null;
			originalDateField = null;
			originalEnumeratorField = null;
			originalEvalErrorField = null;
			originalErrorField = null;
			originalFunctionField = null;
			originalNumberField = null;
			originalObjectField = null;
			originalObjectPrototypeField = null;
			originalRangeErrorField = null;
			originalReferenceErrorField = null;
			originalRegExpField = null;
			originalStringField = null;
			originalSyntaxErrorField = null;
			originalTypeErrorField = null;
			originalVBArrayField = null;
			originalURIErrorField = null;
		}

		private static void AppendInHex(StringBuilder bs, int value)
		{
			bs.Append('%');
			int num = (value >> 4) & 0xF;
			bs.Append((char)((num >= 10) ? (num - 10 + 65) : (num + 48)));
			num = value & 0xF;
			bs.Append((char)((num >= 10) ? (num - 10 + 65) : (num + 48)));
		}

		/// <summary>Calls the garbage collector.</summary>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_CollectGarbage)]
		public static void CollectGarbage()
		{
			GC.Collect();
		}

		private static string Decode(object encodedURI, URISetType flags)
		{
			string text = Convert.ToString(encodedURI);
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < text.Length; i++)
			{
				char c = text[i];
				if (c != '%')
				{
					stringBuilder.Append(c);
					continue;
				}
				int num = i;
				if (i + 2 >= text.Length)
				{
					throw new JScriptException(JSError.URIDecodeError);
				}
				byte b = HexValue(text[i + 1], text[i + 2]);
				i += 2;
				char c2;
				if ((b & 0x80) == 0)
				{
					c2 = (char)b;
				}
				else
				{
					int j;
					for (j = 1; ((uint)(b << j) & 0x80u) != 0; j++)
					{
					}
					if (j == 1 || j > 4 || i + (j - 1) * 3 >= text.Length)
					{
						throw new JScriptException(JSError.URIDecodeError);
					}
					int num2 = b & (255 >> j + 1);
					while (j > 1)
					{
						if (text[i + 1] != '%')
						{
							throw new JScriptException(JSError.URIDecodeError);
						}
						b = HexValue(text[i + 2], text[i + 3]);
						i += 3;
						if ((b & 0xC0) != 128)
						{
							throw new JScriptException(JSError.URIDecodeError);
						}
						num2 = (num2 << 6) | (b & 0x3F);
						j--;
					}
					if (num2 >= 55296 && num2 < 57344)
					{
						throw new JScriptException(JSError.URIDecodeError);
					}
					if (num2 >= 65536)
					{
						if (num2 > 1114111)
						{
							throw new JScriptException(JSError.URIDecodeError);
						}
						stringBuilder.Append((char)(((num2 - 65536 >> 10) & 0x3FF) + 55296));
						stringBuilder.Append((char)(((num2 - 65536) & 0x3FF) + 56320));
						continue;
					}
					c2 = (char)num2;
				}
				if (InURISet(c2, flags))
				{
					stringBuilder.Append(text, num, i - num + 1);
				}
				else
				{
					stringBuilder.Append(c2);
				}
			}
			return stringBuilder.ToString();
		}

		/// <summary>Decodes the specified Uniform Resource Identifier (URI), accounting for reserved characters.</summary>
		/// <param name="encodedURI">The URI to decode.</param>
		/// <returns>The decoded version of <paramref name="encodedURI" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_decodeURI)]
		public static string decodeURI(object encodedURI)
		{
			return Decode(encodedURI, URISetType.Reserved);
		}

		/// <summary>Decodes the specified Uniform Resource Identifier (URI).</summary>
		/// <param name="encodedURI">The URI to decode.</param>
		/// <returns>The decoded version of <paramref name="encodedURI" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_decodeURIComponent)]
		public static string decodeURIComponent(object encodedURI)
		{
			return Decode(encodedURI, URISetType.None);
		}

		private static string Encode(object uri, URISetType flags)
		{
			string text = Convert.ToString(uri);
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < text.Length; i++)
			{
				char c = text[i];
				if (InURISet(c, flags))
				{
					stringBuilder.Append(c);
					continue;
				}
				int num = c;
				if (num >= 0 && num <= 127)
				{
					AppendInHex(stringBuilder, num);
					continue;
				}
				if (num >= 128 && num <= 2047)
				{
					AppendInHex(stringBuilder, (num >> 6) | 0xC0);
					AppendInHex(stringBuilder, (num & 0x3F) | 0x80);
					continue;
				}
				if (num < 55296 || num > 57343)
				{
					AppendInHex(stringBuilder, (num >> 12) | 0xE0);
					AppendInHex(stringBuilder, ((num >> 6) & 0x3F) | 0x80);
					AppendInHex(stringBuilder, (num & 0x3F) | 0x80);
					continue;
				}
				if (num >= 56320 && num <= 57343)
				{
					throw new JScriptException(JSError.URIEncodeError);
				}
				if (++i >= text.Length)
				{
					throw new JScriptException(JSError.URIEncodeError);
				}
				int num2 = text[i];
				if (num2 < 56320 || num2 > 57343)
				{
					throw new JScriptException(JSError.URIEncodeError);
				}
				num = (num - 55296 << 10) + num2 + 9216;
				AppendInHex(stringBuilder, (num >> 18) | 0xF0);
				AppendInHex(stringBuilder, ((num >> 12) & 0x3F) | 0x80);
				AppendInHex(stringBuilder, ((num >> 6) & 0x3F) | 0x80);
				AppendInHex(stringBuilder, (num & 0x3F) | 0x80);
			}
			return stringBuilder.ToString();
		}

		/// <summary>Encodes the specified Uniform Resource Identifier (URI), accounting for reserved characters.</summary>
		/// <param name="uri">The URI to encode.</param>
		/// <returns>The encoded version of <paramref name="uri" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_encodeURI)]
		public static string encodeURI(object uri)
		{
			return Encode(uri, (URISetType)3);
		}

		/// <summary>Encodes the specified Uniform Resource Identifier (URI).</summary>
		/// <param name="uriComponent">The URI to encode.</param>
		/// <returns>The encoded version of <paramref name="uriComponent" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_encodeURIComponent)]
		public static string encodeURIComponent(object uriComponent)
		{
			return Encode(uriComponent, URISetType.Unescaped);
		}

		/// <summary>Converts the specified string to use the % character to escape reserved characters (@, *, _, +, -, ., /) and express them in Unicode notation.</summary>
		/// <param name="string">The string to convert.</param>
		/// <returns>A new copy of <paramref name="string" /> in which the reserved characters are escaped by the % character and expressed in Unicode.</returns>
		[NotRecommended("escape")]
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_escape)]
		public static string escape(object @string)
		{
			string text = Convert.ToString(@string);
			string text2 = "0123456789ABCDEF";
			int length = text.Length;
			StringBuilder stringBuilder = new StringBuilder(length * 2);
			int num = -1;
			while (++num < length)
			{
				char c = text[num];
				int num2 = c;
				if ((65 > num2 || num2 > 90) && (97 > num2 || num2 > 122) && (48 > num2 || num2 > 57) && c != '@' && c != '*' && c != '_' && c != '+' && c != '-' && c != '.' && c != '/')
				{
					stringBuilder.Append('%');
					if (num2 < 256)
					{
						stringBuilder.Append(text2[num2 / 16]);
						c = text2[num2 % 16];
					}
					else
					{
						stringBuilder.Append('u');
						stringBuilder.Append(text2[(num2 >> 12) % 16]);
						stringBuilder.Append(text2[(num2 >> 8) % 16]);
						stringBuilder.Append(text2[(num2 >> 4) % 16]);
						c = text2[num2 % 16];
					}
				}
				stringBuilder.Append(c);
			}
			return stringBuilder.ToString();
		}

		/// <summary>Throws an <see cref="F:Microsoft.JScript.JSError.IllegalEval" /> exception in all cases.</summary>
		/// <param name="x">The expression to evaluate.</param>
		/// <returns>Throws an <see cref="F:Microsoft.JScript.JSError.IllegalEval" /> exception in all cases.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_eval)]
		public static object eval(object x)
		{
			throw new JScriptException(JSError.IllegalEval);
		}

		/// <summary>Creates a managed object from an unmanaged object by using either the moniker or the ProgID.</summary>
		/// <param name="moniker">The moniker of the object.</param>
		/// <param name="progId">The ProgID of the object.</param>
		/// <returns>The managed object.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_GetObject)]
		[SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public static object GetObject(object moniker, object progId)
		{
			moniker = Convert.ToPrimitive(moniker, PreferredType.Either);
			if (!(progId is Missing))
			{
				progId = Convert.ToPrimitive(progId, PreferredType.Either);
			}
			string text = ((Convert.GetTypeCode(moniker) == TypeCode.String) ? moniker.ToString() : null);
			string text2 = ((Convert.GetTypeCode(progId) == TypeCode.String) ? progId.ToString() : null);
			if (text == null || (text.Length == 0 && text2 == null))
			{
				throw new JScriptException(JSError.TypeMismatch);
			}
			if (text2 == null && !(progId is Missing))
			{
				throw new JScriptException(JSError.TypeMismatch);
			}
			if (text2 != null && text2.Length == 0)
			{
				throw new JScriptException(JSError.InvalidCall);
			}
			if (text2 == null || text2.Length == 0)
			{
				return Marshal.BindToMoniker(text);
			}
			if (text == null || text.Length == 0)
			{
				return Marshal.GetActiveObject(text2);
			}
			Type typeFromProgID = Type.GetTypeFromProgID(text2);
			object obj = Activator.CreateInstance(typeFromProgID);
			if (obj is UCOMIPersistFile)
			{
				((UCOMIPersistFile)obj).Load(text, 0);
				return obj;
			}
			throw new JScriptException(JSError.FileNotFound);
		}

		internal static int HexDigit(char c)
		{
			if (c >= '0' && c <= '9')
			{
				return c - 48;
			}
			if (c >= 'A' && c <= 'F')
			{
				return 10 + c - 65;
			}
			if (c >= 'a' && c <= 'f')
			{
				return 10 + c - 97;
			}
			return -1;
		}

		private static byte HexValue(char ch1, char ch2)
		{
			int num;
			int num2;
			if ((num = HexDigit(ch1)) < 0 || (num2 = HexDigit(ch2)) < 0)
			{
				throw new JScriptException(JSError.URIDecodeError);
			}
			return (byte)((num << 4) | num2);
		}

		private static bool InURISet(char ch, URISetType flags)
		{
			if ((flags & URISetType.Unescaped) != 0)
			{
				if ((ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'))
				{
					return true;
				}
				switch (ch)
				{
				case '!':
				case '\'':
				case '(':
				case ')':
				case '*':
				case '-':
				case '.':
				case '_':
				case '~':
					return true;
				}
			}
			if ((flags & URISetType.Reserved) != 0)
			{
				switch (ch)
				{
				case '#':
				case '$':
				case '&':
				case '+':
				case ',':
				case '/':
				case ':':
				case ';':
				case '=':
				case '?':
				case '@':
					return true;
				}
			}
			return false;
		}

		/// <summary>Determines whether the specified number can be converted to a JScript number.</summary>
		/// <param name="num">The number to check.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="num" /> can be converted to a JScript number; otherwise, <see langword="false" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_isNaN)]
		public static bool isNaN(object num)
		{
			double num2 = Convert.ToNumber(num);
			return num2 != num2;
		}

		/// <summary>Determines whether the specified number represents infinity.</summary>
		/// <param name="number">The number to check.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="number" /> is not <see cref="F:System.Double.NaN" />, not <see cref="F:System.Double.PositiveInfinity" />, and not <see cref="F:System.Double.NegativeInfinity" />; otherwise, <see langword="false" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_isFinite)]
		public static bool isFinite(double number)
		{
			if (!double.IsInfinity(number))
			{
				return !double.IsNaN(number);
			}
			return false;
		}

		/// <summary>Converts the specified string to its <see cref="T:System.Double" /> equivalent.</summary>
		/// <param name="string">The string to convert.</param>
		/// <returns>A value equivalent to the value that is contained in <paramref name="string" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_parseFloat)]
		public static double parseFloat(object @string)
		{
			string str = Convert.ToString(@string);
			return Convert.ToNumber(str, hexOK: false, octalOK: false, Missing.Value);
		}

		/// <summary>Converts the specified string to its <see cref="T:System.Double" /> equivalent, using the specified base.</summary>
		/// <param name="string">The string to convert.</param>
		/// <param name="radix">A number between 2 and 36 that represents the base of the number system that <paramref name="string" /> is expressed in. The default is 10.</param>
		/// <returns>A value that is equivalent to the value that is contained in <paramref name="string" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_parseInt)]
		public static double parseInt(object @string, object radix)
		{
			string str = Convert.ToString(@string);
			return Convert.ToNumber(str, hexOK: true, octalOK: true, radix);
		}

		/// <summary>Gets the name of the scripting engine.</summary>
		/// <returns>The string literal "JScript".</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_ScriptEngine)]
		public static string ScriptEngine()
		{
			return "JScript";
		}

		/// <summary>Gets the build number of the scripting engine.</summary>
		/// <returns>The build number of the scripting engine.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_ScriptEngineBuildVersion)]
		public static int ScriptEngineBuildVersion()
		{
			return 9037;
		}

		/// <summary>Gets the major version number of the scripting engine.</summary>
		/// <returns>The major version number of the scripting engine.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_ScriptEngineMajorVersion)]
		public static int ScriptEngineMajorVersion()
		{
			return 14;
		}

		/// <summary>Gets the minor version number of the scripting engine.</summary>
		/// <returns>The minor version number of the scripting engine.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_ScriptEngineMinorVersion)]
		public static int ScriptEngineMinorVersion()
		{
			return 0;
		}

		/// <summary>Converts % escaped characters (@, *, _, +, -, ., /) in the specified string to their original form. The escaped characters are expressed in Unicode notation.</summary>
		/// <param name="string">The string to convert.</param>
		/// <returns>A new copy of <paramref name="string" /> in which the escaped characters are converted to their original form.</returns>
		[NotRecommended("unescape")]
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Global_unescape)]
		public static string unescape(object @string)
		{
			string text = Convert.ToString(@string);
			int length = text.Length;
			StringBuilder stringBuilder = new StringBuilder(length);
			int num = -1;
			while (++num < length)
			{
				char c = text[num];
				if (c == '%')
				{
					int num4;
					int num5;
					int num2;
					int num3;
					if (num + 5 < length && text[num + 1] == 'u' && (num2 = HexDigit(text[num + 2])) != -1 && (num3 = HexDigit(text[num + 3])) != -1 && (num4 = HexDigit(text[num + 4])) != -1 && (num5 = HexDigit(text[num + 5])) != -1)
					{
						c = (char)((num2 << 12) + (num3 << 8) + (num4 << 4) + num5);
						num += 5;
					}
					else if (num + 2 < length && (num2 = HexDigit(text[num + 1])) != -1 && (num3 = HexDigit(text[num + 2])) != -1)
					{
						c = (char)((num2 << 4) + num3);
						num += 2;
					}
				}
				stringBuilder.Append(c);
			}
			return stringBuilder.ToString();
		}
	}
	/// <summary>Stores references to all globally available types and manages the stack. This class belongs to the compilation and run-time state category.</summary>
	public sealed class Globals
	{
		[ThreadStatic]
		private static TypeReferences _typeRefs;

		private Stack callContextStack;

		private Stack scopeStack;

		internal object caller;

		private SimpleHashtable regExpTable;

		internal GlobalObject globalObject;

		internal VsaEngine engine;

		internal bool assemblyDelaySign;

		internal CultureInfo assemblyCulture;

		internal AssemblyFlags assemblyFlags = (AssemblyFlags)49152;

		internal AssemblyHashAlgorithm assemblyHashAlgorithm = AssemblyHashAlgorithm.SHA1;

		internal string assemblyKeyFileName;

		internal Context assemblyKeyFileNameContext;

		internal string assemblyKeyName;

		internal Context assemblyKeyNameContext;

		internal Version assemblyVersion;

		internal AssemblyVersionCompatibility assemblyVersionCompatibility;

		private static SimpleHashtable BuiltinFunctionTable;

		/// <summary>Stores a global reference to the single scripting engine that is running in the current context.</summary>
		[ContextStatic]
		public static VsaEngine contextEngine;

		internal static TypeReferences TypeRefs
		{
			get
			{
				TypeReferences typeReferences = _typeRefs;
				if (typeReferences == null)
				{
					typeReferences = (_typeRefs = Runtime.TypeRefs);
				}
				return typeReferences;
			}
			set
			{
				_typeRefs = value;
			}
		}

		internal Stack CallContextStack
		{
			get
			{
				if (callContextStack == null)
				{
					callContextStack = new Stack();
				}
				return callContextStack;
			}
		}

		internal SimpleHashtable RegExpTable
		{
			get
			{
				if (regExpTable == null)
				{
					regExpTable = new SimpleHashtable(8u);
				}
				return regExpTable;
			}
		}

		internal Stack ScopeStack
		{
			get
			{
				if (scopeStack == null)
				{
					scopeStack = new Stack();
					scopeStack.Push(engine.GetGlobalScope().GetObject());
				}
				return scopeStack;
			}
		}

		internal Globals(bool fast, VsaEngine engine)
		{
			this.engine = engine;
			callContextStack = null;
			scopeStack = null;
			caller = DBNull.Value;
			regExpTable = null;
			if (fast)
			{
				globalObject = GlobalObject.commonInstance;
			}
			else
			{
				globalObject = new LenientGlobalObject(engine);
			}
		}

		internal static BuiltinFunction BuiltinFunctionFor(object obj, MethodInfo meth)
		{
			if (BuiltinFunctionTable == null)
			{
				BuiltinFunctionTable = new SimpleHashtable(64u);
			}
			BuiltinFunction builtinFunction = (BuiltinFunction)BuiltinFunctionTable[meth];
			if (builtinFunction != null)
			{
				return builtinFunction;
			}
			builtinFunction = new BuiltinFunction(obj, meth);
			lock (BuiltinFunctionTable)
			{
				BuiltinFunctionTable[meth] = builtinFunction;
				return builtinFunction;
			}
		}

		/// <summary>Provides global access to the <see cref="M:Microsoft.JScript.ArrayConstructor.CreateInstance(System.Object[])" /> method.</summary>
		/// <param name="args">The values to populate the array with.</param>
		/// <returns>A new instance of a JScript <see cref="T:Microsoft.JScript.ArrayObject" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public static ArrayObject ConstructArray(params object[] args)
		{
			return (ArrayObject)ArrayConstructor.ob.Construct(args);
		}

		/// <summary>Provides global access to the <see cref="M:Microsoft.JScript.ArrayConstructor.ConstructArray(System.Object[])" /> method.</summary>
		/// <param name="args">The values to populate the array with.</param>
		/// <returns>A new instance of a JScript <see cref="T:Microsoft.JScript.ArrayObject" />.</returns>
		public static ArrayObject ConstructArrayLiteral(object[] args)
		{
			return ArrayConstructor.ob.ConstructArray(args);
		}
	}
	internal enum AssemblyFlags
	{
		PublicKey = 1,
		CompatibilityMask = 112,
		SideBySideCompatible = 0,
		NonSideBySideAppDomain = 16,
		NonSideBySideProcess = 32,
		NonSideBySideMachine = 48,
		EnableJITcompileTracking = 32768,
		DisableJITcompileOptimizer = 16384
	}
	/// <summary>Represents the global scope.</summary>
	[ComVisible(true)]
	public class GlobalScope : ActivationObject, IExpando, IReflect
	{
		private ArrayList componentScopes;

		internal GlobalObject globalObject;

		private bool recursive;

		internal bool evilScript;

		internal object thisObject;

		internal bool isComponentScope;

		private TypeReflector globalObjectTR;

		private TypeReflector typeReflector;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.GlobalScope" /> class.</summary>
		/// <param name="parent">A reference to the parent object.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		public GlobalScope(GlobalScope parent, VsaEngine engine)
			: this(parent, engine, parent != null)
		{
		}

		internal GlobalScope(GlobalScope parent, VsaEngine engine, bool isComponentScope)
			: base(parent)
		{
			componentScopes = null;
			recursive = false;
			this.isComponentScope = isComponentScope;
			if (parent == null)
			{
				globalObject = engine.Globals.globalObject;
				globalObjectTR = TypeReflector.GetTypeReflectorFor(Globals.TypeRefs.ToReferenceContext(globalObject.GetType()));
				fast = !(globalObject is LenientGlobalObject);
			}
			else
			{
				globalObject = null;
				globalObjectTR = null;
				fast = parent.fast;
				if (isComponentScope)
				{
					((GlobalScope)base.parent).AddComponentScope(this);
				}
			}
			base.engine = engine;
			isKnownAtCompileTime = fast;
			evilScript = true;
			thisObject = this;
			typeReflector = TypeReflector.GetTypeReflectorFor(Globals.TypeRefs.ToReferenceContext(GetType()));
			if (isComponentScope)
			{
				engine.Scopes.Add(this);
			}
		}

		internal void AddComponentScope(GlobalScope component)
		{
			if (componentScopes == null)
			{
				componentScopes = new ArrayList();
			}
			componentScopes.Add(component);
			component.thisObject = thisObject;
		}

		/// <summary>Adds the specified field to the global scope.</summary>
		/// <param name="name">The name of the field to add.</param>
		/// <returns>The new field, if it is successfully added.</returns>
		public FieldInfo AddField(string name)
		{
			if (fast)
			{
				return null;
			}
			if (isComponentScope)
			{
				return ((GlobalScope)parent).AddField(name);
			}
			FieldInfo fieldInfo = (FieldInfo)name_table[name];
			if (fieldInfo == null)
			{
				fieldInfo = new JSExpandoField(name);
				name_table[name] = fieldInfo;
				field_table.Add(fieldInfo);
			}
			return fieldInfo;
		}

		/// <summary>Adds the specified method to the global scope. This method is not implemented in JScript.</summary>
		/// <param name="name">The name of the method to add.</param>
		/// <param name="method">The delegate to the method.</param>
		/// <returns>null in all cases.</returns>
		MethodInfo IExpando.AddMethod(string name, Delegate method)
		{
			return null;
		}

		internal override JSVariableField AddNewField(string name, object value, FieldAttributes attributeFlags)
		{
			if (!isComponentScope)
			{
				return base.AddNewField(name, value, attributeFlags);
			}
			return ((GlobalScope)parent).AddNewField(name, value, attributeFlags);
		}

		/// <summary>Adds the specified property to the global scope. This method is not implemented in JScript.</summary>
		/// <param name="name">The name of the property to add.</param>
		/// <returns>null in all cases.</returns>
		PropertyInfo IExpando.AddProperty(string name)
		{
			return null;
		}

		internal override bool DeleteMember(string name)
		{
			if (isComponentScope)
			{
				return parent.DeleteMember(name);
			}
			FieldInfo fieldInfo = (FieldInfo)name_table[name];
			if (fieldInfo != null)
			{
				if (fieldInfo is JSExpandoField)
				{
					fieldInfo.SetValue(this, Missing.Value);
					name_table.Remove(name);
					field_table.Remove(fieldInfo);
					return true;
				}
				return false;
			}
			return false;
		}

		/// <summary>Gets the current default scope, which is either the contained object of a <see langword="with" /> statement scope, or the global scope.</summary>
		/// <returns>This object.</returns>
		public override object GetDefaultThisObject()
		{
			return this;
		}

		internal override object GetDefaultValue(PreferredType preferred_type)
		{
			if (preferred_type == PreferredType.String || preferred_type == PreferredType.LocaleString)
			{
				return "";
			}
			return double.NaN;
		}

		/// <summary>Gets a field that has the specified name by searching the scope hierarchy. This method searches only the scope that is specified by the lexical level.</summary>
		/// <param name="name">The name of the field to search for.</param>
		/// <param name="lexLevel">The lexical level to search.</param>
		/// <returns>A field that has the specified name.</returns>
		public override FieldInfo GetField(string name, int lexLevel)
		{
			return GetField(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
		}

		internal JSField[] GetFields()
		{
			int count = field_table.Count;
			JSField[] array = new JSField[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = (JSField)field_table[i];
			}
			return array;
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.FieldInfo" /> objects that correspond to all fields of the global scope.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all fields of the global scope.</returns>
		public override FieldInfo[] GetFields(BindingFlags bindingAttr)
		{
			return base.GetFields(bindingAttr | BindingFlags.DeclaredOnly);
		}

		/// <summary>Gets the global scope by returning a reference to this object.</summary>
		/// <returns>This object.</returns>
		public override GlobalScope GetGlobalScope()
		{
			return this;
		}

		/// <summary>Gets the local declaration of a field that has the specified name. This is used at compile time for error checking.</summary>
		/// <param name="name">The name of the field.</param>
		/// <returns>The local declaration of the field.</returns>
		public override FieldInfo GetLocalField(string name)
		{
			return GetField(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.MemberInfo" /> objects that correspond to all members that match a specified name.</summary>
		/// <param name="name">The name of the member to search for.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that match the <paramref name="name" /> argument.</returns>
		public override MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
		{
			return GetMember(name, bindingAttr, calledFromParent: false);
		}

		private MemberInfo[] GetMember(string name, BindingFlags bindingAttr, bool calledFromParent)
		{
			if (recursive)
			{
				return new MemberInfo[0];
			}
			MemberInfo[] array = null;
			if (!isComponentScope)
			{
				MemberInfo[] member = base.GetMember(name, bindingAttr | BindingFlags.DeclaredOnly);
				if (member.Length != 0)
				{
					return member;
				}
				if (componentScopes != null)
				{
					int i = 0;
					for (int count = componentScopes.Count; i < count; i++)
					{
						GlobalScope globalScope = (GlobalScope)componentScopes[i];
						array = globalScope.GetMember(name, bindingAttr | BindingFlags.DeclaredOnly, calledFromParent: true);
						if (array.Length != 0)
						{
							return array;
						}
					}
				}
				if (globalObject != null)
				{
					array = globalObjectTR.GetMember(name, (bindingAttr & ~BindingFlags.NonPublic) | BindingFlags.Static);
				}
				if (array != null && array.Length != 0)
				{
					return ScriptObject.WrapMembers(array, globalObject);
				}
			}
			else
			{
				array = typeReflector.GetMember(name, (bindingAttr & ~BindingFlags.NonPublic) | BindingFlags.Static);
				int num = array.Length;
				if (num > 0)
				{
					int num2 = 0;
					MemberInfo[] array2 = new MemberInfo[num];
					for (int j = 0; j < num; j++)
					{
						MemberInfo memberInfo = (array2[j] = array[j]);
						if (memberInfo.DeclaringType.IsAssignableFrom(Typeob.GlobalScope))
						{
							array2[j] = null;
							num2++;
						}
						else
						{
							if (!(memberInfo is FieldInfo))
							{
								continue;
							}
							FieldInfo fieldInfo = (FieldInfo)memberInfo;
							if (fieldInfo.IsStatic && fieldInfo.FieldType == Typeob.Type)
							{
								Type type = (Type)fieldInfo.GetValue(null);
								if (type != null)
								{
									array2[j] = type;
								}
							}
						}
					}
					if (num2 == 0)
					{
						return array;
					}
					if (num2 == num)
					{
						return new MemberInfo[0];
					}
					MemberInfo[] array3 = new MemberInfo[num - num2];
					int num3 = 0;
					MemberInfo[] array4 = array2;
					foreach (MemberInfo memberInfo2 in array4)
					{
						if (memberInfo2 != null)
						{
							array3[num3++] = memberInfo2;
						}
					}
					return array3;
				}
			}
			if (parent != null && !calledFromParent && ((bindingAttr & BindingFlags.DeclaredOnly) == 0 || isComponentScope))
			{
				recursive = true;
				try
				{
					array = parent.GetMember(name, bindingAttr);
				}
				finally
				{
					recursive = false;
				}
				if (array != null && array.Length != 0)
				{
					return array;
				}
			}
			return new MemberInfo[0];
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.MemberInfo" /> objects that correspond to all members of the global scope.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all members of the global scope.</returns>
		public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
		{
			if (recursive)
			{
				return new MemberInfo[0];
			}
			MemberInfoList memberInfoList = new MemberInfoList();
			if (isComponentScope)
			{
				MemberInfo[] members = Globals.TypeRefs.ToReferenceContext(GetType()).GetMembers(bindingAttr | BindingFlags.DeclaredOnly);
				if (members != null)
				{
					MemberInfo[] array = members;
					foreach (MemberInfo elem in array)
					{
						memberInfoList.Add(elem);
					}
				}
			}
			else
			{
				if (componentScopes != null)
				{
					int j = 0;
					for (int count = componentScopes.Count; j < count; j++)
					{
						GlobalScope globalScope = (GlobalScope)componentScopes[j];
						recursive = true;
						MemberInfo[] array2 = null;
						try
						{
							array2 = globalScope.GetMembers(bindingAttr);
						}
						finally
						{
							recursive = false;
						}
						if (array2 != null)
						{
							MemberInfo[] array3 = array2;
							foreach (MemberInfo elem2 in array3)
							{
								memberInfoList.Add(elem2);
							}
						}
					}
				}
				IEnumerator enumerator = field_table.GetEnumerator();
				while (enumerator.MoveNext())
				{
					FieldInfo elem3 = (FieldInfo)enumerator.Current;
					memberInfoList.Add(elem3);
				}
			}
			if (parent != null && (isComponentScope || (bindingAttr & BindingFlags.DeclaredOnly) == 0))
			{
				recursive = true;
				MemberInfo[] array4 = null;
				try
				{
					array4 = parent.GetMembers(bindingAttr);
				}
				finally
				{
					recursive = false;
				}
				if (array4 != null)
				{
					MemberInfo[] array5 = array4;
					foreach (MemberInfo elem4 in array5)
					{
						memberInfoList.Add(elem4);
					}
				}
			}
			return memberInfoList.ToArray();
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.MethodInfo" /> objects that correspond to all methods of the global scope.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all methods of the global scope.</returns>
		public override MethodInfo[] GetMethods(BindingFlags bindingAttr)
		{
			return base.GetMethods(bindingAttr | BindingFlags.DeclaredOnly);
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.PropertyInfo" /> objects that correspond to all properties of the global scope.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all properties of the global scope.</returns>
		public override PropertyInfo[] GetProperties(BindingFlags bindingAttr)
		{
			return base.GetProperties(bindingAttr | BindingFlags.DeclaredOnly);
		}

		internal override void GetPropertyEnumerator(ArrayList enums, ArrayList objects)
		{
			FieldInfo[] fields = GetFields(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
			if (fields.Length != 0)
			{
				enums.Add(fields.GetEnumerator());
				objects.Add(this);
			}
			GetParent()?.GetPropertyEnumerator(enums, objects);
		}

		internal void SetFast()
		{
			fast = true;
			isKnownAtCompileTime = true;
			if (globalObject != null)
			{
				globalObject = GlobalObject.commonInstance;
				globalObjectTR = TypeReflector.GetTypeReflectorFor(Globals.TypeRefs.ToReferenceContext(globalObject.GetType()));
			}
		}

		/// <summary>Removes the specified member from the global scope.</summary>
		/// <param name="m">The name of the member to remove.</param>
		void IExpando.RemoveMember(MemberInfo m)
		{
			DeleteMember(m.Name);
		}

		internal override void SetMemberValue(string name, object value)
		{
			MemberInfo[] member = GetMember(name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
			if (member.Length == 0)
			{
				if (VsaEngine.executeForJSEE)
				{
					throw new JScriptException(JSError.UndefinedIdentifier, new Context(new DocumentContext("", null), name));
				}
				FieldInfo fieldInfo = AddField(name);
				if (fieldInfo != null)
				{
					fieldInfo.SetValue(this, value);
				}
			}
			else
			{
				MemberInfo memberInfo = LateBinding.SelectMember(member);
				if (memberInfo == null)
				{
					throw new JScriptException(JSError.AssignmentToReadOnly);
				}
				LateBinding.SetMemberValue(this, name, value, memberInfo, member);
			}
		}
	}
	/// <summary>Defines methods for resolving scope. This interface is implemented by all objects that take part in a scope hierarchy.</summary>
	public interface IActivationObject
	{
		/// <summary>When implemented in a class, gets the current default scope. Either the contained object of a <see langword="with" /> statement scope, or the global scope.</summary>
		/// <returns>The current default scope.</returns>
		object GetDefaultThisObject();

		/// <summary>When implemented in a class, gets the global scope by searching the scope hierarchy until it finds a scope that includes static variables, for example, a module scope.</summary>
		/// <returns>The global scope.</returns>
		GlobalScope GetGlobalScope();

		/// <summary>When implemented in a class, gets the local declaration of a field that has the specified name. This is used at compile time for error checking.</summary>
		/// <param name="name">The name of the field.</param>
		/// <returns>The local declaration of the field.</returns>
		FieldInfo GetLocalField(string name);

		/// <summary>When implemented in a class, gets the value of the specified member by searching the scope hierarchy. This method searches only the scope that is specified by the lexical level.</summary>
		/// <param name="name">The name of the member to search for.</param>
		/// <param name="lexlevel">The lexical level to search.</param>
		/// <returns>The value of the member <paramref name="name" />.</returns>
		object GetMemberValue(string name, int lexlevel);

		/// <summary>When implemented in a class, returns a field that has the specified name by searching the scope hierarchy. This method searches only the scope that is specified by the lexical level.</summary>
		/// <param name="name">The name of the field to search for.</param>
		/// <param name="lexLevel">The lexical level to search.</param>
		/// <returns>A <see cref="T:System.Reflection.FieldInfo" /> object that has the specified name.</returns>
		FieldInfo GetField(string name, int lexLevel);
	}
	internal sealed class IdentifierLiteral : AST
	{
		private string identifier;

		internal IdentifierLiteral(string identifier, Context context)
			: base(context)
		{
			this.identifier = identifier;
		}

		internal override object Evaluate()
		{
			throw new JScriptException(JSError.InternalError, context);
		}

		internal override AST PartiallyEvaluate()
		{
			throw new JScriptException(JSError.InternalError, context);
		}

		public override string ToString()
		{
			return identifier;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			throw new JScriptException(JSError.InternalError, context);
		}
	}
	internal sealed class If : AST
	{
		private AST condition;

		private AST operand1;

		private AST operand2;

		private Completion completion;

		internal If(Context context, AST condition, AST true_branch, AST false_branch)
			: base(context)
		{
			this.condition = condition;
			operand1 = true_branch;
			operand2 = false_branch;
			completion = new Completion();
		}

		internal override object Evaluate()
		{
			if (operand1 == null && operand2 == null)
			{
				return this.completion;
			}
			Completion completion = null;
			completion = ((condition != null) ? (Convert.ToBoolean(condition.Evaluate()) ? ((Completion)operand1.Evaluate()) : ((operand2 == null) ? new Completion() : ((Completion)operand2.Evaluate()))) : ((operand1 == null) ? ((Completion)operand2.Evaluate()) : ((Completion)operand1.Evaluate())));
			this.completion.value = completion.value;
			if (completion.Continue > 1)
			{
				this.completion.Continue = completion.Continue - 1;
			}
			else
			{
				this.completion.Continue = 0;
			}
			if (completion.Exit > 0)
			{
				this.completion.Exit = completion.Exit - 1;
			}
			else
			{
				this.completion.Exit = 0;
			}
			if (completion.Return)
			{
				return completion;
			}
			return this.completion;
		}

		internal override bool HasReturn()
		{
			if (operand1 != null)
			{
				if (!operand1.HasReturn())
				{
					return false;
				}
				if (operand2 != null)
				{
					return operand2.HasReturn();
				}
				return false;
			}
			if (operand2 != null)
			{
				return operand2.HasReturn();
			}
			return false;
		}

		internal override AST PartiallyEvaluate()
		{
			condition = condition.PartiallyEvaluate();
			if (condition is ConstantWrapper)
			{
				if (Convert.ToBoolean(condition.Evaluate()))
				{
					operand2 = null;
				}
				else
				{
					operand1 = null;
				}
				condition = null;
			}
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is FunctionScope)
			{
				FunctionScope functionScope = (FunctionScope)scriptObject;
				BitArray bitArray = functionScope.DefinedFlags;
				BitArray bitArray2 = bitArray;
				if (operand1 != null)
				{
					operand1 = operand1.PartiallyEvaluate();
					bitArray2 = functionScope.DefinedFlags;
					functionScope.DefinedFlags = bitArray;
				}
				if (operand2 != null)
				{
					operand2 = operand2.PartiallyEvaluate();
					BitArray definedFlags = functionScope.DefinedFlags;
					int length = bitArray2.Length;
					int length2 = definedFlags.Length;
					if (length < length2)
					{
						bitArray2.Length = length2;
					}
					if (length2 < length)
					{
						definedFlags.Length = length;
					}
					bitArray = bitArray2.And(definedFlags);
				}
				functionScope.DefinedFlags = bitArray;
			}
			else
			{
				if (operand1 != null)
				{
					operand1 = operand1.PartiallyEvaluate();
				}
				if (operand2 != null)
				{
					operand2 = operand2.PartiallyEvaluate();
				}
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (operand1 == null && operand2 == null)
			{
				return;
			}
			Label label = il.DefineLabel();
			Label label2 = il.DefineLabel();
			base.compilerGlobals.BreakLabelStack.Push(label2);
			base.compilerGlobals.ContinueLabelStack.Push(label2);
			if (condition != null)
			{
				context.EmitLineInfo(il);
				if (operand2 != null)
				{
					condition.TranslateToConditionalBranch(il, branchIfTrue: false, label, shortForm: false);
				}
				else
				{
					condition.TranslateToConditionalBranch(il, branchIfTrue: false, label2, shortForm: false);
				}
				if (operand1 != null)
				{
					operand1.TranslateToIL(il, Typeob.Void);
				}
				if (operand2 != null)
				{
					if (operand1 != null && !operand1.HasReturn())
					{
						il.Emit(OpCodes.Br, label2);
					}
					il.MarkLabel(label);
					operand2.TranslateToIL(il, Typeob.Void);
				}
			}
			else if (operand1 != null)
			{
				operand1.TranslateToIL(il, Typeob.Void);
			}
			else
			{
				operand2.TranslateToIL(il, Typeob.Void);
			}
			il.MarkLabel(label2);
			base.compilerGlobals.BreakLabelStack.Pop();
			base.compilerGlobals.ContinueLabelStack.Pop();
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			if (condition != null)
			{
				condition.TranslateToILInitializer(il);
			}
			if (operand1 != null)
			{
				operand1.TranslateToILInitializer(il);
			}
			if (operand2 != null)
			{
				operand2.TranslateToILInitializer(il);
			}
		}
	}
	/// <summary>Imports namespaces for use in code. This class belongs to the abstract syntax tree category.</summary>
	public sealed class Import : AST
	{
		private string name;

		internal Import(Context context, AST name)
			: base(context)
		{
			if (name != null)
			{
				WrappedNamespace wrappedNamespace = name.EvaluateAsWrappedNamespace(giveErrorIfNameInUse: true);
				base.Engine.SetEnclosingContext(wrappedNamespace);
				this.name = wrappedNamespace.name;
			}
		}

		internal override object Evaluate()
		{
			return new Completion();
		}

		internal override AST PartiallyEvaluate()
		{
			return this;
		}

		/// <summary>Imports the specified namespace for use by the specified scripting engine.</summary>
		/// <param name="name">The namespace to import.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		public static void JScriptImport(string name, VsaEngine engine)
		{
			int num = name.IndexOf('.');
			string text = ((num > 0) ? name.Substring(0, num) : name);
			GlobalScope globalScope = ((IActivationObject)engine.ScriptObjectStackTop()).GetGlobalScope();
			FieldInfo localField = globalScope.GetLocalField(text);
			if (localField == null)
			{
				localField = globalScope.AddNewField(text, Namespace.GetNamespace(text, engine), FieldAttributes.Public | FieldAttributes.Literal);
			}
			engine.SetEnclosingContext(new WrappedNamespace(name, engine, AddReferences: false));
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			il.Emit(OpCodes.Ldstr, name);
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.jScriptImportMethod);
		}
	}
	/// <summary>Determines whether an object is contained in another object. This class belongs to the abstract syntax tree category.</summary>
	public sealed class In : BinaryOp
	{
		internal In(Context context, AST operand1, AST operand2)
			: base(context, operand1, operand2)
		{
		}

		internal override object Evaluate()
		{
			object v = operand1.Evaluate();
			object v2 = operand2.Evaluate();
			try
			{
				return JScriptIn(v, v2);
			}
			catch (JScriptException ex)
			{
				if (ex.context == null)
				{
					ex.context = operand2.context;
				}
				throw ex;
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return Typeob.Boolean;
		}

		/// <summary>Determines whether the first specified object is contained in the second specified object.</summary>
		/// <param name="v1">The object to search for.</param>
		/// <param name="v2">The object to search in.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="v1" /> is contained in <paramref name="v2" />; otherwise, <see langword="false" />.</returns>
		public static bool JScriptIn(object v1, object v2)
		{
			bool flag = false;
			if (v2 is ScriptObject)
			{
				return !(((ScriptObject)v2).GetMemberValue(Convert.ToString(v1)) is Missing);
			}
			if (v2 is Array)
			{
				Array array = (Array)v2;
				double num = Convert.ToNumber(v1);
				int num2 = (int)num;
				if (num == (double)num2 && array.GetLowerBound(0) <= num2)
				{
					return num2 <= array.GetUpperBound(0);
				}
				return false;
			}
			if (v2 is IEnumerable)
			{
				if (v1 == null)
				{
					return false;
				}
				if (v2 is IDictionary)
				{
					return ((IDictionary)v2).Contains(v1);
				}
				if (v2 is IExpando)
				{
					MemberInfo[] member = ((IReflect)v2).GetMember(Convert.ToString(v1), BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
					return member.Length != 0;
				}
				IEnumerator enumerator = ((IEnumerable)v2).GetEnumerator();
				while (!flag && enumerator.MoveNext())
				{
					if (v1.Equals(enumerator.Current))
					{
						return true;
					}
				}
			}
			else if (v2 is IEnumerator)
			{
				if (v1 == null)
				{
					return false;
				}
				IEnumerator enumerator2 = (IEnumerator)v2;
				while (!flag && enumerator2.MoveNext())
				{
					if (v1.Equals(enumerator2.Current))
					{
						return true;
					}
				}
			}
			else if (v2 is IDebuggerObject)
			{
				return ((IDebuggerObject)v2).HasEnumerableMember(Convert.ToString(v1));
			}
			throw new JScriptException(JSError.ObjectExpected);
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			operand1.TranslateToIL(il, Typeob.Object);
			operand2.TranslateToIL(il, Typeob.Object);
			il.Emit(OpCodes.Call, CompilerGlobals.jScriptInMethod);
			Convert.Emit(this, il, Typeob.Boolean, rtype);
		}
	}
	/// <summary>Defines methods that get and set references to the scripting engine.</summary>
	public interface INeedEngine
	{
		/// <summary>When implemented in a class, gets a reference to the scripting engine.</summary>
		/// <returns>A reference to the scripting engine.</returns>
		VsaEngine GetEngine();

		/// <summary>When implemented in a class, sets a reference to the scripting engine.</summary>
		/// <param name="engine">A reference to the scripting engine.</param>
		void SetEngine(VsaEngine engine);
	}
	/// <summary>Determines whether an object can be coerced to the type of another object. This class belongs to the abstract syntax tree category.</summary>
	public sealed class Instanceof : BinaryOp
	{
		internal Instanceof(Context context, AST operand1, AST operand2)
			: base(context, operand1, operand2)
		{
		}

		internal override object Evaluate()
		{
			object v = operand1.Evaluate();
			object v2 = operand2.Evaluate();
			try
			{
				return JScriptInstanceof(v, v2);
			}
			catch (JScriptException ex)
			{
				if (ex.context == null)
				{
					ex.context = operand2.context;
				}
				throw ex;
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return Typeob.Boolean;
		}

		/// <summary>Determines whether the first specified object can be coerced to the type of the second specified object.</summary>
		/// <param name="v1">The object to coerce to the type of object <paramref name="v2" />.</param>
		/// <param name="v2">The object that has the desired type.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="v1" /> can be coerced to the type of object v2; otherwise, <see langword="false" />.</returns>
		public static bool JScriptInstanceof(object v1, object v2)
		{
			if (v2 is ClassScope)
			{
				return ((ClassScope)v2).HasInstance(v1);
			}
			if (v2 is ScriptFunction)
			{
				return ((ScriptFunction)v2).HasInstance(v1);
			}
			if (v1 == null)
			{
				return false;
			}
			if (v2 is Type)
			{
				Type type = v1.GetType();
				if (v1 is IConvertible)
				{
					try
					{
						Convert.CoerceT(v1, (Type)v2);
						return true;
					}
					catch (JScriptException)
					{
						return false;
					}
				}
				return ((Type)v2).IsAssignableFrom(type);
			}
			if (v2 is IDebugType)
			{
				return ((IDebugType)v2).HasInstance(v1);
			}
			throw new JScriptException(JSError.NeedType);
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			operand1.TranslateToIL(il, Typeob.Object);
			object obj = null;
			if (operand2 is ConstantWrapper && (obj = operand2.Evaluate()) is Type && !((Type)obj).IsValueType)
			{
				il.Emit(OpCodes.Isinst, (Type)obj);
				il.Emit(OpCodes.Ldnull);
				il.Emit(OpCodes.Cgt_Un);
			}
			else if (obj is ClassScope)
			{
				il.Emit(OpCodes.Isinst, ((ClassScope)obj).GetTypeBuilderOrEnumBuilder());
				il.Emit(OpCodes.Ldnull);
				il.Emit(OpCodes.Cgt_Un);
			}
			else
			{
				operand2.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.jScriptInstanceofMethod);
			}
			Convert.Emit(this, il, Typeob.Boolean, rtype);
		}
	}
	/// <summary>Defines methods for accessing the object that a member is defined on.</summary>
	public interface IWrappedMember
	{
		/// <summary>When implemented in a class, returns the object that a member is defined on.</summary>
		/// <returns>The object that a member is defined on.</returns>
		object GetWrappedObject();
	}
	/// <summary>Provides services for authoring JScript code in an editor.</summary>
	[Guid("0E4EFFC0-2387-11d3-B372-00105A98B7CE")]
	[ComVisible(true)]
	public class JSAuthor : IAuthorServices
	{
		/// <summary>Gets an object that is used to colorize text when JScript code is being authored in an editor.</summary>
		/// <returns>An object that is used to colorize text.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual IColorizeText GetColorizer()
		{
			return new JSColorizer();
		}

		/// <summary>Gets an object that is used to add IntelliSense to text when JScript code is being authored in an editor.</summary>
		/// <returns>An object that is used to add IntelliSense to text.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual IParseText GetCodeSense()
		{
			return new JSCodeSense();
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JSAuthor" /> class.</summary>
		public JSAuthor()
		{
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	internal class JSColorizer : IColorizeText
	{
		private JSScanner _scanner;

		private SourceState _state;

		internal JSColorizer()
		{
			_scanner = new JSScanner();
			_scanner.SetAuthoringMode(mode: true);
			_state = SourceState.STATE_COLOR_NORMAL;
		}

		public virtual ITokenEnumerator Colorize(string sourceCode, SourceState state)
		{
			TokenColorInfoList tokenColorInfoList = new TokenColorInfoList();
			_state = SourceState.STATE_COLOR_NORMAL;
			if (sourceCode.Length > 0)
			{
				Context context = new Context(null, sourceCode);
				_scanner.SetSource(context);
				try
				{
					if (SourceState.STATE_COLOR_COMMENT == state)
					{
						int num = _scanner.SkipMultiLineComment();
						if (num > sourceCode.Length)
						{
							_state = SourceState.STATE_COLOR_COMMENT;
							num = sourceCode.Length;
						}
						tokenColorInfoList.Add(context);
						if (num == sourceCode.Length)
						{
							return tokenColorInfoList;
						}
					}
					_scanner.GetNextToken();
					JSToken jSToken = JSToken.None;
					while (context.GetToken() != 0)
					{
						tokenColorInfoList.Add(context);
						jSToken = context.GetToken();
						_scanner.GetNextToken();
					}
					if (JSToken.UnterminatedComment == jSToken)
					{
						_state = SourceState.STATE_COLOR_COMMENT;
						return tokenColorInfoList;
					}
					return tokenColorInfoList;
				}
				catch (ScannerException)
				{
					return tokenColorInfoList;
				}
			}
			return tokenColorInfoList;
		}

		public virtual SourceState GetStateForText(string sourceCode, SourceState state)
		{
			if (sourceCode != null)
			{
				_state = SourceState.STATE_COLOR_NORMAL;
				Context context = new Context(null, sourceCode);
				_scanner.SetSource(context);
				if (SourceState.STATE_COLOR_COMMENT == state)
				{
					int num = _scanner.SkipMultiLineComment();
					if (num > sourceCode.Length)
					{
						_state = SourceState.STATE_COLOR_COMMENT;
						return _state;
					}
				}
				_scanner.GetNextToken();
				JSToken jSToken = JSToken.None;
				while (context.GetToken() != 0)
				{
					jSToken = context.GetToken();
					_scanner.GetNextToken();
				}
				if (JSToken.UnterminatedComment == jSToken)
				{
					_state = SourceState.STATE_COLOR_COMMENT;
				}
			}
			return _state;
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	internal class TokenColorInfoList : ITokenEnumerator
	{
		private TokenColorInfo _head;

		private TokenColorInfo _current;

		private bool _atEnd;

		internal TokenColorInfoList()
		{
			_head = null;
			_current = null;
			_atEnd = true;
		}

		internal void Add(Context token)
		{
			TokenColorInfo tokenColorInfo = null;
			if (_head == null)
			{
				tokenColorInfo = (_head = new TokenColorInfo(token));
			}
			else
			{
				tokenColorInfo = _head.Clone();
				_head._next = tokenColorInfo;
				_head.UpdateToken(token);
				_head = tokenColorInfo;
			}
			_current = _head;
			_atEnd = false;
		}

		public virtual ITokenColorInfo GetNext()
		{
			if (_atEnd)
			{
				return null;
			}
			ITokenColorInfo current = _current;
			_current = _current._next;
			_atEnd = _current == _head;
			return current;
		}

		public virtual void Reset()
		{
			_current = _head;
			if (_current != null)
			{
				_atEnd = false;
			}
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	internal class TokenColorInfo : ITokenColorInfo
	{
		private Context _token;

		private TokenColor _color;

		internal TokenColorInfo _next;

		public TokenColor Color => _color;

		public int EndPosition => _token.EndPosition;

		public int StartPosition => _token.StartPosition;

		internal TokenColorInfo(Context token)
		{
			_token = token.Clone();
			_color = ColorFromToken(_token);
			_next = this;
		}

		internal static TokenColor ColorFromToken(Context context)
		{
			JSToken token = context.GetToken();
			if (JSScanner.IsKeyword(token))
			{
				return TokenColor.COLOR_KEYWORD;
			}
			if (JSToken.Identifier == token)
			{
				if (context.Equals("eval"))
				{
					return TokenColor.COLOR_KEYWORD;
				}
				return TokenColor.COLOR_IDENTIFIER;
			}
			if (JSToken.StringLiteral == token)
			{
				return TokenColor.COLOR_STRING;
			}
			if (JSToken.NumericLiteral == token || JSToken.IntegerLiteral == token)
			{
				return TokenColor.COLOR_NUMBER;
			}
			if (JSToken.Comment == token || JSToken.UnterminatedComment == token)
			{
				return TokenColor.COLOR_COMMENT;
			}
			if (JSScanner.IsOperator(token))
			{
				return TokenColor.COLOR_OPERATOR;
			}
			return TokenColor.COLOR_TEXT;
		}

		internal TokenColorInfo Clone()
		{
			return (TokenColorInfo)MemberwiseClone();
		}

		internal void UpdateToken(Context token)
		{
			_token = token.Clone();
			_color = ColorFromToken(_token);
		}
	}
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	internal class JSCodeSense : IJSVsaSite, IParseText
	{
		private VsaEngine _engine;

		private IJSVsaCodeItem _codeBlock;

		private IErrorHandler _errorHandler;

		internal JSCodeSense()
		{
			_engine = new VsaEngine(fast: true);
			_engine.InitVsaEngine("JSC://Microsoft.JScript.Vsa.VsaEngine", this);
			_codeBlock = (IJSVsaCodeItem)_engine.Items.CreateItem("Code", JSVsaItemType.Code, JSVsaItemFlag.None);
			_errorHandler = null;
		}

		public virtual void GetCompiledState(out byte[] pe, out byte[] debugInfo)
		{
			pe = null;
			debugInfo = null;
		}

		public virtual object GetGlobalInstance(string Name)
		{
			return null;
		}

		public virtual object GetEventSourceInstance(string ItemName, string EventSourceName)
		{
			return null;
		}

		public virtual bool OnCompilerError(IJSVsaError error)
		{
			if (error is IVsaFullErrorInfo)
			{
				return _errorHandler.OnCompilerError((IVsaFullErrorInfo)error);
			}
			return true;
		}

		public virtual void Parse(string code, IErrorHandler errorHandler)
		{
			_engine.Reset();
			_errorHandler = errorHandler;
			_codeBlock.SourceText = code;
			_engine.CheckForErrors();
		}

		public virtual void Notify(string notification, object value)
		{
		}
	}
	[Serializable]
	internal sealed class JSBinder : Binder
	{
		internal static readonly JSBinder ob = new JSBinder();

		internal static object[] ArrangeNamedArguments(MethodBase method, object[] args, string[] namedParameters)
		{
			ParameterInfo[] parameters = method.GetParameters();
			int num = parameters.Length;
			if (num == 0)
			{
				throw new JScriptException(JSError.MissingNameParameter);
			}
			object[] array = new object[num];
			int num2 = args.Length;
			int num3 = namedParameters.Length;
			int num4 = num2 - num3;
			ArrayObject.Copy(args, num3, array, 0, num4);
			for (int i = 0; i < num3; i++)
			{
				string text = namedParameters[i];
				if (text == null || text.Equals(""))
				{
					throw new JScriptException(JSError.MustProvideNameForNamedParameter);
				}
				int j;
				for (j = num4; j < num; j++)
				{
					if (text.Equals(parameters[j].Name))
					{
						if (array[j] is Empty)
						{
							throw new JScriptException(JSError.DuplicateNamedParameter);
						}
						array[j] = args[i];
						break;
					}
				}
				if (j == num)
				{
					throw new JScriptException(JSError.MissingNameParameter);
				}
			}
			if (method is JSMethod)
			{
				return array;
			}
			for (int k = 0; k < num; k++)
			{
				if (array[k] == null || array[k] == Missing.Value)
				{
					object defaultParameterValue = TypeReferences.GetDefaultParameterValue(parameters[k]);
					if (defaultParameterValue == System.Convert.DBNull)
					{
						throw new ArgumentException(parameters[k].Name);
					}
					array[k] = defaultParameterValue;
				}
			}
			return array;
		}

		public override FieldInfo BindToField(BindingFlags bindAttr, FieldInfo[] match, object value, CultureInfo locale)
		{
			if (value == null)
			{
				value = DBNull.Value;
			}
			int num = int.MaxValue;
			int num2 = 0;
			FieldInfo result = null;
			Type type = value.GetType();
			int i = 0;
			for (int num3 = match.Length; i < num3; i++)
			{
				FieldInfo fieldInfo = match[i];
				int num4 = TypeDistance(Runtime.TypeRefs, fieldInfo.FieldType, type);
				if (num4 < num)
				{
					num = num4;
					result = fieldInfo;
					num2 = 0;
				}
				else if (num4 == num)
				{
					num2++;
				}
			}
			if (num2 > 0)
			{
				throw new AmbiguousMatchException();
			}
			return result;
		}

		public override MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, ref object[] args, ParameterModifier[] modifiers, CultureInfo locale, string[] namedParameters, out object state)
		{
			state = null;
			return SelectMethodBase(Runtime.TypeRefs, match, ref args, modifiers, namedParameters);
		}

		public override object ChangeType(object value, Type target_type, CultureInfo locale)
		{
			return Convert.CoerceT(value, target_type);
		}

		internal static MemberInfo[] GetDefaultMembers(IReflect ir)
		{
			return GetDefaultMembers(Globals.TypeRefs, ir);
		}

		internal static MemberInfo[] GetDefaultMembers(TypeReferences typeRefs, IReflect ir)
		{
			while (ir is ClassScope)
			{
				ClassScope classScope = (ClassScope)ir;
				classScope.owner.IsExpando();
				if (classScope.itemProp != null)
				{
					return new MemberInfo[1] { classScope.itemProp };
				}
				ir = classScope.GetParent();
				if (ir is WithObject)
				{
					ir = (IReflect)((WithObject)ir).contained_object;
				}
			}
			if (ir is Type)
			{
				return GetDefaultMembers((Type)ir);
			}
			if (ir is JSObject)
			{
				return typeRefs.ScriptObject.GetDefaultMembers();
			}
			return null;
		}

		internal static MemberInfo[] GetDefaultMembers(Type t)
		{
			while (t != typeof(object) && t != null)
			{
				MemberInfo[] defaultMembers = t.GetDefaultMembers();
				if (defaultMembers != null && defaultMembers.Length != 0)
				{
					return defaultMembers;
				}
				t = t.BaseType;
			}
			return null;
		}

		internal static MethodInfo GetDefaultPropertyForArrayIndex(Type t, int index, Type elementType, bool getSetter)
		{
			try
			{
				MemberInfo[] defaultMembers = GetDefaultMembers(Runtime.TypeRefs, t);
				int num = 0;
				if (defaultMembers == null || (num = defaultMembers.Length) == 0)
				{
					return null;
				}
				for (int i = 0; i < num; i++)
				{
					MemberInfo memberInfo = defaultMembers[i];
					MemberTypes memberType = memberInfo.MemberType;
					MethodInfo methodInfo = null;
					if (memberType != MemberTypes.Method)
					{
						if (memberType != MemberTypes.Property)
						{
							continue;
						}
						methodInfo = ((PropertyInfo)memberInfo).GetGetMethod();
					}
					else
					{
						methodInfo = (MethodInfo)memberInfo;
					}
					if (!(methodInfo != null))
					{
						continue;
					}
					ParameterInfo[] parameters = methodInfo.GetParameters();
					if (parameters == null || parameters.Length == 0)
					{
						Type returnType = methodInfo.ReturnType;
						if (typeof(Array).IsAssignableFrom(returnType) || typeof(IList).IsAssignableFrom(returnType))
						{
							return methodInfo;
						}
					}
					else
					{
						if (parameters.Length != 1 || memberType != MemberTypes.Property)
						{
							continue;
						}
						PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
						if (!(elementType == null) && !propertyInfo.PropertyType.IsAssignableFrom(elementType))
						{
							continue;
						}
						try
						{
							Convert.CoerceT(index, parameters[0].ParameterType);
							if (getSetter)
							{
								return propertyInfo.GetSetMethod();
							}
							return methodInfo;
						}
						catch (JScriptException)
						{
						}
					}
				}
			}
			catch (InvalidOperationException)
			{
			}
			return null;
		}

		internal static MemberInfo[] GetInterfaceMembers(string name, Type t)
		{
			BindingFlags bindingAttr = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public;
			MemberInfo[] member = t.GetMember(name, bindingAttr);
			Type[] interfaces = t.GetInterfaces();
			if (interfaces == null || interfaces.Length == 0)
			{
				return member;
			}
			ArrayList arrayList = new ArrayList(interfaces);
			MemberInfoList memberInfoList = new MemberInfoList();
			memberInfoList.AddRange(member);
			for (int i = 0; i < arrayList.Count; i++)
			{
				Type type = (Type)arrayList[i];
				member = type.GetMember(name, bindingAttr);
				if (member != null)
				{
					memberInfoList.AddRange(member);
				}
				Type[] interfaces2 = type.GetInterfaces();
				foreach (Type value in interfaces2)
				{
					if (arrayList.IndexOf(value) == -1)
					{
						arrayList.Add(value);
					}
				}
			}
			return memberInfoList.ToArray();
		}

		private static bool FormalParamTypeIsObject(ParameterInfo par)
		{
			if (par is ParameterDeclaration parameterDeclaration)
			{
				return parameterDeclaration.ParameterIReflect == Typeob.Object;
			}
			return par.ParameterType == Typeob.Object;
		}

		public override void ReorderArgumentArray(ref object[] args, object state)
		{
		}

		internal static MemberInfo Select(TypeReferences typeRefs, MemberInfo[] match, int matches, IReflect[] argIRs, MemberTypes memberType)
		{
			int num = 0;
			ParameterInfo[][] array = new ParameterInfo[matches][];
			bool flag = memberType == MemberTypes.Method;
			for (int i = 0; i < matches; i++)
			{
				MemberInfo memberInfo = match[i];
				if (memberInfo is PropertyInfo && flag)
				{
					memberInfo = ((PropertyInfo)memberInfo).GetGetMethod(nonPublic: true);
				}
				if (!(memberInfo == null) && memberInfo.MemberType == memberType)
				{
					if (memberInfo is PropertyInfo)
					{
						array[i] = ((PropertyInfo)memberInfo).GetIndexParameters();
					}
					else
					{
						array[i] = ((MethodBase)memberInfo).GetParameters();
					}
					num++;
				}
			}
			int num2 = SelectBest(typeRefs, match, matches, argIRs, array, null, num, argIRs.Length);
			if (num2 < 0)
			{
				return null;
			}
			return match[num2];
		}

		internal static MemberInfo Select(TypeReferences typeRefs, MemberInfo[] match, int matches, ref object[] args, string[] namedParameters, MemberTypes memberType)
		{
			bool flag = false;
			if (namedParameters != null && namedParameters.Length != 0)
			{
				if (args.Length < namedParameters.Length)
				{
					throw new JScriptException(JSError.MoreNamedParametersThanArguments);
				}
				flag = true;
			}
			int num = 0;
			ParameterInfo[][] array = new ParameterInfo[matches][];
			object[][] array2 = new object[matches][];
			bool flag2 = memberType == MemberTypes.Method;
			for (int i = 0; i < matches; i++)
			{
				MemberInfo memberInfo = match[i];
				if (flag2 && memberInfo.MemberType == MemberTypes.Property)
				{
					memberInfo = ((PropertyInfo)memberInfo).GetGetMethod(nonPublic: true);
				}
				if (memberInfo.MemberType == memberType)
				{
					if (memberType == MemberTypes.Property)
					{
						array[i] = ((PropertyInfo)memberInfo).GetIndexParameters();
					}
					else
					{
						array[i] = ((MethodBase)memberInfo).GetParameters();
					}
					if (flag)
					{
						array2[i] = ArrangeNamedArguments((MethodBase)memberInfo, args, namedParameters);
					}
					else
					{
						array2[i] = args;
					}
					num++;
				}
			}
			int num2 = SelectBest(typeRefs, match, matches, null, array, array2, num, args.Length);
			if (num2 < 0)
			{
				return null;
			}
			args = array2[num2];
			MemberInfo memberInfo2 = match[num2];
			if (flag2 && memberInfo2.MemberType == MemberTypes.Property)
			{
				memberInfo2 = ((PropertyInfo)memberInfo2).GetGetMethod(nonPublic: true);
			}
			return memberInfo2;
		}

		private static int SelectBest(TypeReferences typeRefs, MemberInfo[] match, int matches, IReflect[] argIRs, ParameterInfo[][] fparams, object[][] aparams, int candidates, int parameters)
		{
			switch (candidates)
			{
			case 0:
				return -1;
			case 1:
			{
				for (int i = 0; i < matches; i++)
				{
					if (fparams[i] != null)
					{
						return i;
					}
				}
				break;
			}
			}
			bool[] array = new bool[matches];
			int[] array2 = new int[matches];
			for (int j = 0; j < matches; j++)
			{
				ParameterInfo[] array3 = fparams[j];
				if (array3 == null)
				{
					continue;
				}
				int num = array3.Length;
				int num2 = ((argIRs == null) ? aparams[j].Length : argIRs.Length);
				if (num2 > num && (num == 0 || !CustomAttribute.IsDefined(array3[num - 1], typeof(ParamArrayAttribute), inherit: false)))
				{
					fparams[j] = null;
					candidates--;
					continue;
				}
				for (int k = parameters; k < num; k++)
				{
					ParameterInfo parameterInfo = array3[k];
					if (k == num - 1 && CustomAttribute.IsDefined(parameterInfo, typeof(ParamArrayAttribute), inherit: false))
					{
						break;
					}
					object defaultParameterValue = TypeReferences.GetDefaultParameterValue(parameterInfo);
					if (defaultParameterValue is DBNull)
					{
						array2[j] = 50;
					}
				}
			}
			int num3 = 0;
			while (candidates > 1)
			{
				int num4 = 0;
				int num5 = int.MaxValue;
				bool flag = false;
				for (int l = 0; l < matches; l++)
				{
					int num6 = 0;
					ParameterInfo[] array4 = fparams[l];
					if (array4 == null)
					{
						continue;
					}
					IReflect reflect = typeRefs.Missing;
					if (argIRs == null)
					{
						if (aparams[l].Length > num3)
						{
							object obj = aparams[l][num3];
							if (obj == null)
							{
								obj = DBNull.Value;
							}
							reflect = typeRefs.ToReferenceContext(obj.GetType());
						}
					}
					else if (num3 < parameters)
					{
						reflect = argIRs[num3];
					}
					int num7 = array4.Length;
					if (num7 - 1 > num3)
					{
						num4++;
					}
					IReflect reflect2 = typeRefs.Missing;
					if (num7 > 0 && num3 >= num7 - 1 && CustomAttribute.IsDefined(array4[num7 - 1], typeof(ParamArrayAttribute), inherit: false) && !(reflect is TypedArray) && reflect != typeRefs.ArrayObject && (!(reflect is Type) || !((Type)reflect).IsArray))
					{
						ParameterInfo parameterInfo2 = array4[num7 - 1];
						if (parameterInfo2 is ParameterDeclaration)
						{
							reflect2 = ((ParameterDeclaration)parameterInfo2).ParameterIReflect;
							reflect2 = ((TypedArray)reflect2).elementType;
						}
						else
						{
							reflect2 = parameterInfo2.ParameterType.GetElementType();
						}
						if (num3 == num7 - 1)
						{
							array2[l]++;
						}
					}
					else if (num3 < num7)
					{
						ParameterInfo parameterInfo3 = array4[num3];
						IReflect reflect3;
						if (!(parameterInfo3 is ParameterDeclaration))
						{
							IReflect parameterType = parameterInfo3.ParameterType;
							reflect3 = parameterType;
						}
						else
						{
							reflect3 = ((ParameterDeclaration)parameterInfo3).ParameterIReflect;
						}
						reflect2 = reflect3;
						if (reflect == typeRefs.Missing)
						{
							object defaultParameterValue2 = TypeReferences.GetDefaultParameterValue(parameterInfo3);
							if (!(defaultParameterValue2 is DBNull))
							{
								reflect = reflect2;
								num6 = 1;
							}
						}
					}
					int num8 = TypeDistance(typeRefs, reflect2, reflect) + array2[l] + num6;
					if (num8 == num5)
					{
						if (num3 == num7 - 1 && array[l])
						{
							candidates--;
							fparams[l] = null;
						}
						flag = flag && array[l];
						continue;
					}
					if (num8 > num5)
					{
						if (flag && num3 < num7 && FormalParamTypeIsObject(fparams[l][num3]))
						{
							num5 = num8;
						}
						else if (num3 <= num7 - 1 || reflect != typeRefs.Missing || !CustomAttribute.IsDefined(array4[num7 - 1], typeof(ParamArrayAttribute), inherit: false))
						{
							array[l] = true;
						}
						continue;
					}
					if (candidates == 1 && !array[l])
					{
						return l;
					}
					flag = array[l];
					for (int m = 0; m < l; m++)
					{
						if (fparams[m] != null && !array[m])
						{
							bool flag2 = fparams[m].Length <= num3;
							if ((!flag2 || parameters > num3) && (flag2 || !flag || !FormalParamTypeIsObject(fparams[m][num3])))
							{
								array[m] = true;
							}
						}
					}
					num5 = num8;
				}
				if (num3 >= parameters - 1 && num4 < 1)
				{
					break;
				}
				num3++;
			}
			int num9 = -1;
			for (int n = 0; n < matches; n++)
			{
				if (candidates <= 0)
				{
					break;
				}
				ParameterInfo[] array5 = fparams[n];
				if (array5 == null)
				{
					continue;
				}
				if (array[n])
				{
					candidates--;
					fparams[n] = null;
					continue;
				}
				int num10 = array5.Length;
				if (num9 == -1)
				{
					num9 = n;
				}
				else
				{
					if (!Class.ParametersMatch(array5, fparams[num9]))
					{
						continue;
					}
					MemberInfo memberInfo = match[num9];
					JSWrappedMethod jSWrappedMethod = match[num9] as JSWrappedMethod;
					if (jSWrappedMethod != null)
					{
						memberInfo = jSWrappedMethod.method;
					}
					if (memberInfo is JSFieldMethod || memberInfo is JSConstructor || memberInfo is JSProperty)
					{
						candidates--;
						fparams[n] = null;
						continue;
					}
					Type declaringType = match[num9].DeclaringType;
					Type declaringType2 = match[n].DeclaringType;
					if (declaringType != declaringType2)
					{
						if (declaringType2.IsAssignableFrom(declaringType))
						{
							candidates--;
							fparams[n] = null;
						}
						else if (declaringType.IsAssignableFrom(declaringType2))
						{
							fparams[num9] = null;
							num9 = n;
							candidates--;
						}
					}
				}
			}
			if (candidates != 1)
			{
				throw new AmbiguousMatchException();
			}
			return num9;
		}

		internal static Type HandleCoClassAttribute(Type t)
		{
			object[] customAttributes = CustomAttribute.GetCustomAttributes(t, typeof(CoClassAttribute), inherit: false);
			if (customAttributes != null && customAttributes.Length == 1)
			{
				t = ((CoClassAttribute)customAttributes[0]).CoClass;
				if (!t.IsPublic)
				{
					throw new JScriptException(JSError.NotAccessible, new Context(new DocumentContext("", null), t.ToString()));
				}
			}
			return t;
		}

		internal static ConstructorInfo SelectConstructor(MemberInfo[] match, ref object[] args, string[] namedParameters)
		{
			return SelectConstructor(Globals.TypeRefs, match, ref args, namedParameters);
		}

		internal static ConstructorInfo SelectConstructor(TypeReferences typeRefs, MemberInfo[] match, ref object[] args, string[] namedParameters)
		{
			if (match == null)
			{
				return null;
			}
			int num = match.Length;
			switch (num)
			{
			case 0:
				return null;
			case 1:
			{
				Type type = match[0] as Type;
				if (type != null)
				{
					if (type.IsInterface && type.IsImport)
					{
						type = HandleCoClassAttribute(type);
					}
					MemberInfo[] constructors = type.GetConstructors();
					match = constructors;
					num = match.Length;
				}
				break;
			}
			}
			if (num == 1)
			{
				return match[0] as ConstructorInfo;
			}
			return (ConstructorInfo)Select(typeRefs, match, num, ref args, namedParameters, MemberTypes.Constructor);
		}

		internal static ConstructorInfo SelectConstructor(MemberInfo[] match, IReflect[] argIRs)
		{
			return SelectConstructor(Globals.TypeRefs, match, argIRs);
		}

		internal static ConstructorInfo SelectConstructor(TypeReferences typeRefs, MemberInfo[] match, IReflect[] argIRs)
		{
			if (match == null)
			{
				return null;
			}
			int num = match.Length;
			if (num == 1)
			{
				object obj = match[0];
				if (obj is JSGlobalField)
				{
					obj = ((JSGlobalField)obj).GetValue(null);
				}
				Type type = obj as Type;
				if (type != null)
				{
					if (type.IsInterface && type.IsImport)
					{
						type = HandleCoClassAttribute(type);
					}
					MemberInfo[] constructors = type.GetConstructors();
					match = constructors;
				}
				num = match.Length;
			}
			return num switch
			{
				0 => null, 
				1 => match[0] as ConstructorInfo, 
				_ => (ConstructorInfo)Select(typeRefs, match, num, argIRs, MemberTypes.Constructor), 
			};
		}

		internal static MemberInfo SelectCallableMember(MemberInfo[] match, IReflect[] argIRs)
		{
			if (match == null)
			{
				return null;
			}
			int num = match.Length;
			object result;
			switch (num)
			{
			case 0:
				return null;
			default:
				result = Select(Globals.TypeRefs, match, num, argIRs, MemberTypes.Method);
				break;
			case 1:
				result = match[0];
				break;
			}
			return (MemberInfo)result;
		}

		internal static MethodInfo SelectMethod(MemberInfo[] match, ref object[] args, string[] namedParameters)
		{
			return SelectMethod(Globals.TypeRefs, match, ref args, namedParameters);
		}

		internal static MethodInfo SelectMethod(TypeReferences typeRefs, MemberInfo[] match, ref object[] args, string[] namedParameters)
		{
			if (match == null)
			{
				return null;
			}
			int num = match.Length;
			object obj;
			switch (num)
			{
			case 0:
				return null;
			default:
				obj = Select(typeRefs, match, num, ref args, namedParameters, MemberTypes.Method);
				break;
			case 1:
				obj = match[0];
				break;
			}
			MemberInfo memberInfo = (MemberInfo)obj;
			if (memberInfo != null && memberInfo.MemberType == MemberTypes.Property)
			{
				memberInfo = ((PropertyInfo)memberInfo).GetGetMethod(nonPublic: true);
			}
			return memberInfo as MethodInfo;
		}

		internal static MethodInfo SelectMethod(MemberInfo[] match, IReflect[] argIRs)
		{
			return SelectMethod(Globals.TypeRefs, match, argIRs);
		}

		internal static MethodInfo SelectMethod(TypeReferences typeRefs, MemberInfo[] match, IReflect[] argIRs)
		{
			if (match == null)
			{
				return null;
			}
			int num = match.Length;
			object obj;
			switch (num)
			{
			case 0:
				return null;
			default:
				obj = Select(typeRefs, match, num, argIRs, MemberTypes.Method);
				break;
			case 1:
				obj = match[0];
				break;
			}
			MemberInfo memberInfo = (MemberInfo)obj;
			if (memberInfo != null && memberInfo.MemberType == MemberTypes.Property)
			{
				return ((PropertyInfo)memberInfo).GetGetMethod(nonPublic: true);
			}
			return memberInfo as MethodInfo;
		}

		public override MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers)
		{
			if (match == null)
			{
				return null;
			}
			int num = match.Length;
			switch (num)
			{
			case 0:
				return null;
			case 1:
				return match[0];
			default:
			{
				MemberInfo[] array;
				IReflect[] argIRs;
				if (match[0].MemberType == MemberTypes.Constructor)
				{
					TypeReferences typeRefs = Runtime.TypeRefs;
					array = match;
					MemberInfo[] match2 = array;
					argIRs = types;
					return (ConstructorInfo)Select(typeRefs, match2, num, argIRs, MemberTypes.Constructor);
				}
				TypeReferences typeRefs2 = Runtime.TypeRefs;
				array = match;
				MemberInfo[] match3 = array;
				argIRs = types;
				return (MethodInfo)Select(typeRefs2, match3, num, argIRs, MemberTypes.Method);
			}
			}
		}

		private static MethodBase SelectMethodBase(TypeReferences typeRefs, MethodBase[] match, ref object[] args, ParameterModifier[] modifiers, string[] namedParameters)
		{
			if (match == null)
			{
				return null;
			}
			int num = match.Length;
			switch (num)
			{
			case 0:
				return null;
			case 1:
				return match[0];
			default:
			{
				MemberInfo[] match2 = match;
				MethodBase methodBase = (MethodBase)Select(typeRefs, match2, num, ref args, namedParameters, MemberTypes.Method);
				if (methodBase == null)
				{
					match2 = match;
					methodBase = (MethodBase)Select(typeRefs, match2, num, ref args, namedParameters, MemberTypes.Constructor);
				}
				return methodBase;
			}
			}
		}

		internal static MethodInfo SelectOperator(MethodInfo op1, MethodInfo op2, Type t1, Type t2)
		{
			ParameterInfo[] array = null;
			if (op1 == null || (op1.Attributes & MethodAttributes.SpecialName) == 0 || (array = op1.GetParameters()).Length != 2)
			{
				op1 = null;
			}
			ParameterInfo[] array2 = null;
			if (op2 == null || (op2.Attributes & MethodAttributes.SpecialName) == 0 || (array2 = op2.GetParameters()).Length != 2)
			{
				op2 = null;
			}
			if (op1 == null)
			{
				return op2;
			}
			if (op2 == null)
			{
				return op1;
			}
			int num = TypeDistance(Globals.TypeRefs, array[0].ParameterType, t1) + TypeDistance(Globals.TypeRefs, array[1].ParameterType, t2);
			int num2 = TypeDistance(Globals.TypeRefs, array2[0].ParameterType, t1) + TypeDistance(Globals.TypeRefs, array2[1].ParameterType, t2);
			if (num <= num2)
			{
				return op1;
			}
			return op2;
		}

		internal static PropertyInfo SelectProperty(MemberInfo[] match, object[] args)
		{
			return SelectProperty(Globals.TypeRefs, match, args);
		}

		internal static PropertyInfo SelectProperty(TypeReferences typeRefs, MemberInfo[] match, object[] args)
		{
			if (match == null)
			{
				return null;
			}
			int num = match.Length;
			switch (num)
			{
			case 0:
				return null;
			case 1:
				return match[0] as PropertyInfo;
			default:
			{
				int num2 = 0;
				PropertyInfo propertyInfo = null;
				ParameterInfo[][] array = new ParameterInfo[num][];
				object[][] array2 = new object[num][];
				for (int i = 0; i < num; i++)
				{
					MemberInfo memberInfo = match[i];
					if (memberInfo.MemberType == MemberTypes.Property)
					{
						MethodInfo getMethod = (propertyInfo = (PropertyInfo)memberInfo).GetGetMethod(nonPublic: true);
						if (getMethod == null)
						{
							array[i] = propertyInfo.GetIndexParameters();
						}
						else
						{
							array[i] = getMethod.GetParameters();
						}
						array2[i] = args;
						num2++;
					}
				}
				if (num2 <= 1)
				{
					return propertyInfo;
				}
				int num3 = SelectBest(typeRefs, match, num, null, array, array2, num2, args.Length);
				if (num3 < 0)
				{
					return null;
				}
				return (PropertyInfo)match[num3];
			}
			}
		}

		public override PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type rtype, Type[] types, ParameterModifier[] modifiers)
		{
			if (match == null)
			{
				return null;
			}
			int num = match.Length;
			switch (num)
			{
			case 0:
				return null;
			case 1:
				return match[0];
			default:
			{
				int num2 = 0;
				PropertyInfo propertyInfo = null;
				int num3 = int.MaxValue;
				ParameterInfo[][] array = new ParameterInfo[num][];
				for (int i = 0; i < num; i++)
				{
					propertyInfo = match[i];
					if (rtype != null)
					{
						int num4 = TypeDistance(Globals.TypeRefs, propertyInfo.PropertyType, rtype);
						if (num4 > num3)
						{
							continue;
						}
						if (num4 < num3)
						{
							for (int j = 0; j < i; j++)
							{
								if (array[j] != null)
								{
									array[j] = null;
									num2--;
								}
							}
						}
					}
					array[i] = propertyInfo.GetIndexParameters();
					num2++;
				}
				if (num2 <= 1)
				{
					return propertyInfo;
				}
				int num5 = SelectBest(Globals.TypeRefs, match, num, types, array, null, num2, types.Length);
				if (num5 < 0)
				{
					return null;
				}
				return match[num5];
			}
			}
		}

		internal static PropertyInfo SelectProperty(MemberInfo[] match, IReflect[] argIRs)
		{
			return SelectProperty(Globals.TypeRefs, match, argIRs);
		}

		internal static PropertyInfo SelectProperty(TypeReferences typeRefs, MemberInfo[] match, IReflect[] argIRs)
		{
			if (match == null)
			{
				return null;
			}
			int num = match.Length;
			return num switch
			{
				0 => null, 
				1 => match[0] as PropertyInfo, 
				_ => (PropertyInfo)Select(typeRefs, match, num, argIRs, MemberTypes.Property), 
			};
		}

		private static int TypeDistance(TypeReferences typeRefs, IReflect formal, IReflect actual)
		{
			if (formal is TypedArray)
			{
				if (actual is TypedArray)
				{
					TypedArray typedArray = (TypedArray)formal;
					TypedArray typedArray2 = (TypedArray)actual;
					if (typedArray.rank == typedArray2.rank)
					{
						if (TypeDistance(typeRefs, typedArray.elementType, typedArray2.elementType) != 0)
						{
							return 100;
						}
						return 0;
					}
				}
				else if (actual is Type)
				{
					TypedArray typedArray3 = (TypedArray)formal;
					Type type = (Type)actual;
					if (type.IsArray && typedArray3.rank == type.GetArrayRank())
					{
						if (TypeDistance(typeRefs, typedArray3.elementType, type.GetElementType()) != 0)
						{
							return 100;
						}
						return 0;
					}
					if (type == typeRefs.Array || type == typeRefs.ArrayObject)
					{
						return 30;
					}
				}
				return 100;
			}
			if (actual is TypedArray)
			{
				if (formal is Type)
				{
					Type type2 = (Type)formal;
					TypedArray typedArray4 = (TypedArray)actual;
					if (type2.IsArray && type2.GetArrayRank() == typedArray4.rank)
					{
						if (TypeDistance(typeRefs, type2.GetElementType(), typedArray4.elementType) != 0)
						{
							return 100;
						}
						return 0;
					}
					if (type2 == typeRefs.Array)
					{
						return 30;
					}
					if (type2 == typeRefs.Object)
					{
						return 50;
					}
				}
				return 100;
			}
			if (formal is ClassScope)
			{
				if (actual is ClassScope)
				{
					if (!((ClassScope)actual).IsSameOrDerivedFrom((ClassScope)formal))
					{
						return 100;
					}
					return 0;
				}
				return 100;
			}
			if (actual is ClassScope)
			{
				if (formal is Type)
				{
					if (!((ClassScope)actual).IsPromotableTo((Type)formal))
					{
						return 100;
					}
					return 0;
				}
				return 100;
			}
			return TypeDistance(typeRefs, Convert.ToType(typeRefs, formal), Convert.ToType(typeRefs, actual));
		}

		private static int TypeDistance(TypeReferences typeRefs, Type formal, Type actual)
		{
			TypeCode typeCode = Type.GetTypeCode(actual);
			TypeCode typeCode2 = Type.GetTypeCode(formal);
			if (actual.IsEnum)
			{
				typeCode = TypeCode.Object;
			}
			if (formal.IsEnum)
			{
				typeCode2 = TypeCode.Object;
			}
			switch (typeCode)
			{
			case TypeCode.DBNull:
				if (!(formal == typeRefs.Object))
				{
					return 1;
				}
				return 0;
			case TypeCode.Boolean:
				return typeCode2 switch
				{
					TypeCode.Boolean => 0, 
					TypeCode.Byte => 1, 
					TypeCode.UInt16 => 2, 
					TypeCode.UInt32 => 3, 
					TypeCode.UInt64 => 4, 
					TypeCode.SByte => 5, 
					TypeCode.Int16 => 6, 
					TypeCode.Int32 => 7, 
					TypeCode.Int64 => 8, 
					TypeCode.Single => 9, 
					TypeCode.Double => 10, 
					TypeCode.Decimal => 11, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 12), 
					TypeCode.String => 13, 
					_ => 100, 
				};
			case TypeCode.Char:
				return typeCode2 switch
				{
					TypeCode.Char => 0, 
					TypeCode.UInt16 => 1, 
					TypeCode.UInt32 => 2, 
					TypeCode.Int32 => 3, 
					TypeCode.UInt64 => 4, 
					TypeCode.Int64 => 5, 
					TypeCode.Single => 6, 
					TypeCode.Double => 7, 
					TypeCode.Decimal => 8, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 9), 
					TypeCode.String => 10, 
					TypeCode.Int16 => 11, 
					TypeCode.Byte => 12, 
					TypeCode.SByte => 13, 
					TypeCode.Boolean => 14, 
					_ => 100, 
				};
			case TypeCode.SByte:
				return typeCode2 switch
				{
					TypeCode.SByte => 0, 
					TypeCode.Int16 => 1, 
					TypeCode.Int32 => 2, 
					TypeCode.Int64 => 3, 
					TypeCode.Single => 4, 
					TypeCode.Double => 5, 
					TypeCode.Decimal => 6, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 7), 
					TypeCode.String => 8, 
					TypeCode.Byte => 9, 
					TypeCode.UInt16 => 10, 
					TypeCode.UInt32 => 12, 
					TypeCode.UInt64 => 13, 
					TypeCode.Boolean => 14, 
					_ => 100, 
				};
			case TypeCode.Byte:
				return typeCode2 switch
				{
					TypeCode.Byte => 0, 
					TypeCode.UInt16 => 1, 
					TypeCode.Int16 => 3, 
					TypeCode.UInt32 => 4, 
					TypeCode.Int32 => 5, 
					TypeCode.UInt64 => 6, 
					TypeCode.Int64 => 7, 
					TypeCode.Single => 8, 
					TypeCode.Double => 9, 
					TypeCode.Decimal => 10, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 11), 
					TypeCode.String => 12, 
					TypeCode.SByte => 13, 
					TypeCode.Boolean => 14, 
					_ => 100, 
				};
			case TypeCode.Int16:
				return typeCode2 switch
				{
					TypeCode.Int16 => 0, 
					TypeCode.Int32 => 1, 
					TypeCode.Int64 => 2, 
					TypeCode.Single => 3, 
					TypeCode.Double => 4, 
					TypeCode.Decimal => 5, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 6), 
					TypeCode.String => 7, 
					TypeCode.UInt16 => 8, 
					TypeCode.UInt32 => 10, 
					TypeCode.UInt64 => 11, 
					TypeCode.SByte => 12, 
					TypeCode.Byte => 13, 
					TypeCode.Boolean => 14, 
					_ => 100, 
				};
			case TypeCode.UInt16:
				return typeCode2 switch
				{
					TypeCode.UInt16 => 0, 
					TypeCode.UInt32 => 1, 
					TypeCode.UInt64 => 2, 
					TypeCode.Int32 => 4, 
					TypeCode.Int64 => 5, 
					TypeCode.Single => 6, 
					TypeCode.Double => 7, 
					TypeCode.Decimal => 8, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 9), 
					TypeCode.String => 10, 
					TypeCode.Int16 => 11, 
					TypeCode.Byte => 12, 
					TypeCode.SByte => 13, 
					TypeCode.Boolean => 14, 
					_ => 100, 
				};
			case TypeCode.Int32:
				return typeCode2 switch
				{
					TypeCode.Int32 => 0, 
					TypeCode.Int64 => 1, 
					TypeCode.Double => 2, 
					TypeCode.Decimal => 3, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 4), 
					TypeCode.String => 5, 
					TypeCode.UInt64 => 6, 
					TypeCode.UInt32 => 7, 
					TypeCode.Single => 8, 
					TypeCode.Int16 => 9, 
					TypeCode.UInt16 => 10, 
					TypeCode.SByte => 12, 
					TypeCode.Byte => 13, 
					TypeCode.Boolean => 14, 
					_ => 100, 
				};
			case TypeCode.UInt32:
				return typeCode2 switch
				{
					TypeCode.UInt32 => 0, 
					TypeCode.UInt64 => 1, 
					TypeCode.Int64 => 2, 
					TypeCode.Double => 3, 
					TypeCode.Decimal => 4, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 5), 
					TypeCode.String => 6, 
					TypeCode.Int32 => 7, 
					TypeCode.Single => 8, 
					TypeCode.UInt16 => 9, 
					TypeCode.Int16 => 11, 
					TypeCode.Byte => 12, 
					TypeCode.SByte => 13, 
					TypeCode.Boolean => 14, 
					_ => 100, 
				};
			case TypeCode.Int64:
				return typeCode2 switch
				{
					TypeCode.Int64 => 0, 
					TypeCode.Decimal => 1, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 2), 
					TypeCode.String => 3, 
					TypeCode.Double => 4, 
					TypeCode.Single => 5, 
					TypeCode.Int32 => 6, 
					TypeCode.Int16 => 7, 
					TypeCode.SByte => 8, 
					TypeCode.UInt64 => 9, 
					TypeCode.UInt32 => 10, 
					TypeCode.UInt16 => 11, 
					TypeCode.Byte => 13, 
					TypeCode.Boolean => 14, 
					_ => 100, 
				};
			case TypeCode.UInt64:
				return typeCode2 switch
				{
					TypeCode.UInt64 => 0, 
					TypeCode.Decimal => 1, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 2), 
					TypeCode.String => 3, 
					TypeCode.Int64 => 4, 
					TypeCode.Double => 5, 
					TypeCode.Single => 6, 
					TypeCode.UInt32 => 7, 
					TypeCode.UInt16 => 8, 
					TypeCode.Byte => 10, 
					TypeCode.Int32 => 11, 
					TypeCode.Int16 => 12, 
					TypeCode.SByte => 13, 
					TypeCode.Boolean => 14, 
					_ => 100, 
				};
			case TypeCode.Single:
				return typeCode2 switch
				{
					TypeCode.Single => 0, 
					TypeCode.Double => 1, 
					TypeCode.Decimal => 2, 
					TypeCode.Int64 => 3, 
					TypeCode.UInt64 => 4, 
					TypeCode.Int32 => 5, 
					TypeCode.UInt32 => 6, 
					TypeCode.Int16 => 7, 
					TypeCode.UInt16 => 8, 
					TypeCode.SByte => 10, 
					TypeCode.Byte => 11, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 12), 
					TypeCode.String => 13, 
					TypeCode.Boolean => 14, 
					_ => 100, 
				};
			case TypeCode.Double:
				return typeCode2 switch
				{
					TypeCode.Double => 0, 
					TypeCode.Decimal => 1, 
					TypeCode.Single => 2, 
					TypeCode.Int64 => 3, 
					TypeCode.UInt64 => 4, 
					TypeCode.Int32 => 5, 
					TypeCode.UInt32 => 6, 
					TypeCode.Int16 => 7, 
					TypeCode.UInt16 => 8, 
					TypeCode.SByte => 10, 
					TypeCode.Byte => 11, 
					TypeCode.Object => TypeDistance(typeRefs, formal, actual, 12), 
					TypeCode.String => 13, 
					TypeCode.Boolean => 14, 
					_ => 100, 
				};
			case TypeCode.Decimal:
				switch (typeCode2)
				{
				case TypeCode.Decimal:
					return 0;
				case TypeCode.Double:
					return 1;
				case TypeCode.Single:
					return 2;
				case TypeCode.Int64:
					return 3;
				case TypeCode.UInt64:
					return 4;
				case TypeCode.Int32:
					return 5;
				case TypeCode.UInt32:
					return 6;
				case TypeCode.Int16:
					return 7;
				case TypeCode.UInt16:
					return 8;
				case TypeCode.SByte:
					return 10;
				case TypeCode.Byte:
					return 11;
				case TypeCode.Object:
					if (!(formal == typeRefs.Object))
					{
						return 100;
					}
					return 12;
				case TypeCode.String:
					return 13;
				case TypeCode.Boolean:
					return 14;
				default:
					return 100;
				}
			case TypeCode.DateTime:
				switch (typeCode2)
				{
				case TypeCode.DateTime:
					return 0;
				case TypeCode.Object:
					if (!(formal == typeRefs.Object))
					{
						return 100;
					}
					return 1;
				case TypeCode.String:
					return 3;
				case TypeCode.Double:
					return 4;
				case TypeCode.Decimal:
					return 5;
				case TypeCode.UInt64:
					return 6;
				case TypeCode.Int64:
					return 7;
				case TypeCode.UInt32:
					return 8;
				case TypeCode.Int32:
					return 9;
				default:
					return 100;
				}
			case TypeCode.String:
				switch (typeCode2)
				{
				case TypeCode.String:
					return 0;
				case TypeCode.Object:
					if (!(formal == typeRefs.Object))
					{
						return 100;
					}
					return 1;
				case TypeCode.Char:
					return 2;
				default:
					return 100;
				}
			case TypeCode.Object:
			{
				if (formal == actual)
				{
					return 0;
				}
				if (formal == typeRefs.Missing)
				{
					return 200;
				}
				if (!formal.IsAssignableFrom(actual))
				{
					if (typeRefs.Array.IsAssignableFrom(formal) && (actual == typeRefs.Array || typeRefs.ArrayObject.IsAssignableFrom(actual)))
					{
						return 10;
					}
					if (typeCode2 == TypeCode.String)
					{
						return 20;
					}
					if (actual == typeRefs.ScriptFunction && typeRefs.Delegate.IsAssignableFrom(formal))
					{
						return 19;
					}
					return 100;
				}
				Type[] interfaces = actual.GetInterfaces();
				int num = interfaces.Length;
				int i;
				for (i = 0; i < num; i++)
				{
					if (formal == interfaces[i])
					{
						return i + 1;
					}
				}
				i = 0;
				while (actual != typeRefs.Object && actual != null)
				{
					if (formal == actual)
					{
						return i + num + 1;
					}
					actual = actual.BaseType;
					i++;
				}
				return i + num + 1;
			}
			default:
				return 0;
			}
		}

		private static int TypeDistance(TypeReferences typeRefs, Type formal, Type actual, int distFromObject)
		{
			if (formal == typeRefs.Object)
			{
				return distFromObject;
			}
			if (formal.IsEnum)
			{
				return TypeDistance(typeRefs, Enum.GetUnderlyingType(formal), actual) + 10;
			}
			return 100;
		}
	}
	internal sealed class JSClosureField : JSVariableField
	{
		internal FieldInfo field;

		public override Type DeclaringType => field.DeclaringType;

		public override Type FieldType => field.FieldType;

		internal JSClosureField(FieldInfo field)
			: base(field.Name, null, field.Attributes | FieldAttributes.Static)
		{
			if (field is JSFieldInfo)
			{
				field = ((JSFieldInfo)field).field;
			}
			this.field = field;
		}

		internal override IReflect GetInferredType(JSField inference_target)
		{
			if (field is JSMemberField)
			{
				return ((JSMemberField)field).GetInferredType(inference_target);
			}
			return field.FieldType;
		}

		internal override object GetMetaData()
		{
			if (field is JSField)
			{
				return ((JSField)field).GetMetaData();
			}
			return field;
		}

		public override object GetValue(object obj)
		{
			if (obj is StackFrame)
			{
				return field.GetValue(((StackFrame)((StackFrame)obj).engine.ScriptObjectStackTop()).closureInstance);
			}
			throw new JScriptException(JSError.InternalError);
		}

		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo locale)
		{
			if (obj is StackFrame)
			{
				field.SetValue(((StackFrame)((StackFrame)obj).engine.ScriptObjectStackTop()).closureInstance, value, invokeAttr, binder, locale);
				return;
			}
			throw new JScriptException(JSError.InternalError);
		}
	}
	internal sealed class JSClosureMethod : JSMethod
	{
		internal MethodInfo method;

		public override MethodAttributes Attributes => (method.Attributes & ~MethodAttributes.Virtual) | MethodAttributes.Static;

		public override Type DeclaringType => method.DeclaringType;

		public override string Name => method.Name;

		public override Type ReturnType => method.ReturnType;

		internal JSClosureMethod(MethodInfo method)
			: base(null)
		{
			this.method = method;
		}

		internal override object Construct(object[] args)
		{
			throw new JScriptException(JSError.InternalError);
		}

		public override ParameterInfo[] GetParameters()
		{
			return method.GetParameters();
		}

		internal override MethodInfo GetMethodInfo(CompilerGlobals compilerGlobals)
		{
			if (method is JSMethod)
			{
				return ((JSMethod)method).GetMethodInfo(compilerGlobals);
			}
			return method;
		}

		internal override object Invoke(object obj, object thisob, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			if (obj is StackFrame)
			{
				return method.Invoke(((StackFrame)((StackFrame)obj).engine.ScriptObjectStackTop()).closureInstance, options, binder, parameters, culture);
			}
			throw new JScriptException(JSError.InternalError);
		}
	}
	internal class JSClosureProperty : JSWrappedProperty
	{
		private MethodInfo getMeth;

		private MethodInfo setMeth;

		internal JSClosureProperty(PropertyInfo property, MethodInfo getMeth, MethodInfo setMeth)
			: base(property, null)
		{
			this.getMeth = getMeth;
			this.setMeth = setMeth;
		}

		public override object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)
		{
			if (getMeth == null)
			{
				throw new MissingMethodException();
			}
			return getMeth.Invoke(obj, invokeAttr, binder, index, culture);
		}

		public override MethodInfo GetGetMethod(bool nonPublic)
		{
			if (nonPublic || (getMeth != null && getMeth.IsPublic))
			{
				return getMeth;
			}
			return null;
		}

		public override MethodInfo GetSetMethod(bool nonPublic)
		{
			if (nonPublic || (setMeth != null && setMeth.IsPublic))
			{
				return setMeth;
			}
			return null;
		}

		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)
		{
			if (setMeth == null)
			{
				throw new MissingMethodException();
			}
			int num = ((index != null) ? index.Length : 0);
			object[] array = new object[num + 1];
			array[0] = value;
			if (num > 0)
			{
				ArrayObject.Copy(index, 0, array, 1, num);
			}
			setMeth.Invoke(obj, invokeAttr, binder, array, culture);
		}
	}
	/// <summary>Provides access to instances of the JScript code generator and code compiler.</summary>
	[DesignerCategory("code")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public sealed class JScriptCodeProvider : CodeDomProvider
	{
		private JSCodeGenerator generator;

		/// <summary>Gets the file name extension for JScript code files.</summary>
		/// <returns>The string literal "js".</returns>
		public override string FileExtension => "js";

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JScriptCodeProvider" /> class.</summary>
		public JScriptCodeProvider()
		{
			generator = new JSCodeGenerator();
		}

		/// <summary>Returns an instance of the JScript code generator.</summary>
		/// <returns>An instance of the JScript code generator.</returns>
		public override ICodeGenerator CreateGenerator()
		{
			return generator;
		}

		/// <summary>Returns an instance of the JScript code compiler.</summary>
		/// <returns>An instance of the JScript code compiler.</returns>
		public override ICodeCompiler CreateCompiler()
		{
			return generator;
		}
	}
	[DesignerCategory("code")]
	internal sealed class JSCodeGenerator : CodeCompiler
	{
		private const int MaxLineLength = 80;

		private const GeneratorSupport LanguageSupport = GeneratorSupport.ArraysOfArrays | GeneratorSupport.EntryPointMethod | GeneratorSupport.MultidimensionalArrays | GeneratorSupport.StaticConstructors | GeneratorSupport.TryCatchStatements | GeneratorSupport.DeclareEnums | GeneratorSupport.DeclareInterfaces | GeneratorSupport.AssemblyAttributes | GeneratorSupport.PublicStaticMembers;

		private bool forLoopHack;

		private bool isArgumentList = true;

		private static Hashtable keywords;

		private string mainClassName;

		private string mainMethodName;

		private static Regex outputReg;

		protected override string CompilerName => "jsc.exe";

		protected override string FileExtension => ".js";

		protected override string NullToken => "null";

		static JSCodeGenerator()
		{
			outputReg = new Regex("(([^(]+)(\\(([0-9]+),([0-9]+)\\))[ \\t]*:[ \\t]+)?(fatal )?(error|warning)[ \\t]+([A-Z]+[0-9]+)[ \\t]*:[ \\t]*(.*)");
			keywords = new Hashtable(150);
			object value = new object();
			keywords["abstract"] = value;
			keywords["assert"] = value;
			keywords["boolean"] = value;
			keywords["break"] = value;
			keywords["byte"] = value;
			keywords["case"] = value;
			keywords["catch"] = value;
			keywords["char"] = value;
			keywords["class"] = value;
			keywords["const"] = value;
			keywords["continue"] = value;
			keywords["debugger"] = value;
			keywords["decimal"] = value;
			keywords["default"] = value;
			keywords["delete"] = value;
			keywords["do"] = value;
			keywords["double"] = value;
			keywords["else"] = value;
			keywords["ensure"] = value;
			keywords["enum"] = value;
			keywords["event"] = value;
			keywords["export"] = value;
			keywords["extends"] = value;
			keywords["false"] = value;
			keywords["final"] = value;
			keywords["finally"] = value;
			keywords["float"] = value;
			keywords["for"] = value;
			keywords["function"] = value;
			keywords["get"] = value;
			keywords["goto"] = value;
			keywords["if"] = value;
			keywords["implements"] = value;
			keywords["import"] = value;
			keywords["in"] = value;
			keywords["instanceof"] = value;
			keywords["int"] = value;
			keywords["invariant"] = value;
			keywords["interface"] = value;
			keywords["internal"] = value;
			keywords["long"] = value;
			keywords["namespace"] = value;
			keywords["native"] = value;
			keywords["new"] = value;
			keywords["null"] = value;
			keywords["package"] = value;
			keywords["private"] = value;
			keywords["protected"] = value;
			keywords["public"] = value;
			keywords["require"] = value;
			keywords["return"] = value;
			keywords["sbyte"] = value;
			keywords["scope"] = value;
			keywords["set"] = value;
			keywords["short"] = value;
			keywords["static"] = value;
			keywords["super"] = value;
			keywords["switch"] = value;
			keywords["synchronized"] = value;
			keywords["this"] = value;
			keywords["throw"] = value;
			keywords["throws"] = value;
			keywords["transient"] = value;
			keywords["true"] = value;
			keywords["try"] = value;
			keywords["typeof"] = value;
			keywords["use"] = value;
			keywords["uint"] = value;
			keywords["ulong"] = value;
			keywords["ushort"] = value;
			keywords["var"] = value;
			keywords["void"] = value;
			keywords["volatile"] = value;
			keywords["while"] = value;
			keywords["with"] = value;
		}

		protected override string CmdArgsFromParameters(CompilerParameters options)
		{
			StringBuilder stringBuilder = new StringBuilder(128);
			string text = ((Path.DirectorySeparatorChar == '/') ? "-" : "/");
			stringBuilder.Append(text + "utf8output ");
			object value = new object();
			Hashtable hashtable = new Hashtable(20);
			StringEnumerator enumerator = options.ReferencedAssemblies.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					string current = enumerator.Current;
					if (hashtable[current] == null)
					{
						hashtable[current] = value;
						stringBuilder.Append(text + "r:");
						stringBuilder.Append("\"");
						stringBuilder.Append(current);
						stringBuilder.Append("\" ");
					}
				}
			}
			finally
			{
				if (enumerator is IDisposable disposable)
				{
					disposable.Dispose();
				}
			}
			stringBuilder.Append(text + "out:");
			stringBuilder.Append("\"");
			stringBuilder.Append(options.OutputAssembly);
			stringBuilder.Append("\" ");
			if (options.IncludeDebugInformation)
			{
				stringBuilder.Append(text + "d:DEBUG ");
				stringBuilder.Append(text + "debug+ ");
			}
			else
			{
				stringBuilder.Append(text + "debug- ");
			}
			if (options.TreatWarningsAsErrors)
			{
				stringBuilder.Append(text + "warnaserror ");
			}
			if (options.WarningLevel >= 0)
			{
				stringBuilder.Append(text + "w:" + options.WarningLevel.ToString(CultureInfo.InvariantCulture) + " ");
			}
			if (options.Win32Resource != null)
			{
				stringBuilder.Append(text + "win32res:\"" + options.Win32Resource + "\" ");
			}
			return stringBuilder.ToString();
		}

		protected override string CreateEscapedIdentifier(string name)
		{
			if (IsKeyword(name))
			{
				return "\\" + name;
			}
			return name;
		}

		protected override string CreateValidIdentifier(string name)
		{
			if (IsKeyword(name))
			{
				return "$" + name;
			}
			return name;
		}

		protected override CompilerResults FromFileBatch(CompilerParameters options, string[] fileNames)
		{
			string text = options.TempFiles.AddExtension("out");
			CompilerResults compilerResults = new CompilerResults(options.TempFiles);
			if (options.OutputAssembly == null || options.OutputAssembly.Length == 0)
			{
				options.OutputAssembly = compilerResults.TempFiles.AddExtension("dll", !options.GenerateInMemory);
			}
			string partialCmdLine = null;
			if (options.IncludeDebugInformation)
			{
				compilerResults.TempFiles.AddExtension("pdb");
				partialCmdLine = CmdArgsFromParameters(options);
			}
			compilerResults.NativeCompilerReturnValue = 0;
			try
			{
				JSInProcCompiler jSInProcCompiler = new JSInProcCompiler();
				compilerResults.NativeCompilerReturnValue = jSInProcCompiler.Compile(options, partialCmdLine, fileNames, text);
			}
			catch
			{
				compilerResults.NativeCompilerReturnValue = 10;
			}
			try
			{
				StreamReader streamReader = new StreamReader(text);
				try
				{
					for (string text2 = streamReader.ReadLine(); text2 != null; text2 = streamReader.ReadLine())
					{
						compilerResults.Output.Add(text2);
						ProcessCompilerOutputLine(compilerResults, text2);
					}
				}
				finally
				{
					streamReader.Close();
				}
			}
			catch (Exception ex)
			{
				compilerResults.Output.Add(JScriptException.Localize("No error output", CultureInfo.CurrentUICulture));
				compilerResults.Output.Add(ex.ToString());
			}
			if (compilerResults.NativeCompilerReturnValue == 0 && options.GenerateInMemory)
			{
				FileStream fileStream = new FileStream(options.OutputAssembly, FileMode.Open, FileAccess.Read, FileShare.Read);
				try
				{
					int num = (int)fileStream.Length;
					byte[] array = new byte[num];
					fileStream.Read(array, 0, num);
					compilerResults.CompiledAssembly = Assembly.Load(array, null, options.Evidence);
				}
				finally
				{
					fileStream.Close();
				}
			}
			else
			{
				compilerResults.PathToAssembly = Path.GetFullPath(options.OutputAssembly);
			}
			compilerResults.Evidence = options.Evidence;
			return compilerResults;
		}

		protected override void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e)
		{
			OutputIdentifier(e.ParameterName);
		}

		protected override void GenerateArrayCreateExpression(CodeArrayCreateExpression e)
		{
			CodeExpressionCollection initializers = e.Initializers;
			if (initializers.Count > 0)
			{
				base.Output.Write("[");
				base.Indent++;
				OutputExpressionList(initializers);
				base.Indent--;
				base.Output.Write("]");
				return;
			}
			base.Output.Write("new ");
			base.Output.Write(GetBaseTypeOutput(e.CreateType.BaseType));
			base.Output.Write("[");
			if (e.SizeExpression != null)
			{
				GenerateExpression(e.SizeExpression);
			}
			else
			{
				base.Output.Write(e.Size.ToString(CultureInfo.InvariantCulture));
			}
			base.Output.Write("]");
		}

		protected override void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e)
		{
			GenerateExpression(e.TargetObject);
			base.Output.Write("[");
			bool flag = true;
			foreach (CodeExpression index in e.Indices)
			{
				if (flag)
				{
					flag = false;
				}
				else
				{
					base.Output.Write(", ");
				}
				GenerateExpression(index);
			}
			base.Output.Write("]");
		}

		private void GenerateAssemblyAttributes(CodeAttributeDeclarationCollection attributes)
		{
			if (attributes.Count == 0)
			{
				return;
			}
			IEnumerator enumerator = attributes.GetEnumerator();
			while (enumerator.MoveNext())
			{
				base.Output.Write("[");
				base.Output.Write("assembly: ");
				CodeAttributeDeclaration codeAttributeDeclaration = (CodeAttributeDeclaration)enumerator.Current;
				base.Output.Write(GetBaseTypeOutput(codeAttributeDeclaration.Name));
				base.Output.Write("(");
				bool flag = true;
				foreach (CodeAttributeArgument argument in codeAttributeDeclaration.Arguments)
				{
					if (flag)
					{
						flag = false;
					}
					else
					{
						base.Output.Write(", ");
					}
					OutputAttributeArgument(argument);
				}
				base.Output.Write(")");
				base.Output.Write("]");
				base.Output.WriteLine();
			}
		}

		protected override void GenerateAssignStatement(CodeAssignStatement e)
		{
			GenerateExpression(e.Left);
			base.Output.Write(" = ");
			GenerateExpression(e.Right);
			if (!forLoopHack)
			{
				base.Output.WriteLine(";");
			}
		}

		protected override void GenerateAttachEventStatement(CodeAttachEventStatement e)
		{
			GenerateExpression(e.Event.TargetObject);
			base.Output.Write(".add_");
			base.Output.Write(e.Event.EventName);
			base.Output.Write("(");
			GenerateExpression(e.Listener);
			base.Output.WriteLine(");");
		}

		protected override void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
		{
		}

		protected override void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
		{
		}

		protected override void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e)
		{
			base.Output.Write("super");
		}

		private string GetBaseTypeOutput(string baseType)
		{
			if (baseType.Length == 0)
			{
				return "void";
			}
			if (string.Compare(baseType, "System.Byte", StringComparison.Ordinal) == 0)
			{
				return "byte";
			}
			if (string.Compare(baseType, "System.Int16", StringComparison.Ordinal) == 0)
			{
				return "short";
			}
			if (string.Compare(baseType, "System.Int32", StringComparison.Ordinal) == 0)
			{
				return "int";
			}
			if (string.Compare(baseType, "System.Int64", StringComparison.Ordinal) == 0)
			{
				return "long";
			}
			if (string.Compare(baseType, "System.SByte", StringComparison.Ordinal) == 0)
			{
				return "sbyte";
			}
			if (string.Compare(baseType, "System.UInt16", StringComparison.Ordinal) == 0)
			{
				return "ushort";
			}
			if (string.Compare(baseType, "System.UInt32", StringComparison.Ordinal) == 0)
			{
				return "uint";
			}
			if (string.Compare(baseType, "System.UInt64", StringComparison.Ordinal) == 0)
			{
				return "ulong";
			}
			if (string.Compare(baseType, "System.Decimal", StringComparison.Ordinal) == 0)
			{
				return "decimal";
			}
			if (string.Compare(baseType, "System.Single", StringComparison.Ordinal) == 0)
			{
				return "float";
			}
			if (string.Compare(baseType, "System.Double", StringComparison.Ordinal) == 0)
			{
				return "double";
			}
			if (string.Compare(baseType, "System.Boolean", StringComparison.Ordinal) == 0)
			{
				return "boolean";
			}
			if (string.Compare(baseType, "System.Char", StringComparison.Ordinal) == 0)
			{
				return "char";
			}
			baseType = baseType.Replace('+', '.');
			return CreateEscapedIdentifier(baseType);
		}

		protected override void GenerateCastExpression(CodeCastExpression e)
		{
			OutputType(e.TargetType);
			base.Output.Write("(");
			GenerateExpression(e.Expression);
			base.Output.Write(")");
		}

		protected override void GenerateComment(CodeComment e)
		{
			string text = e.Text;
			StringBuilder stringBuilder = new StringBuilder(text.Length * 2);
			string text2 = (e.DocComment ? "///" : "//");
			stringBuilder.Append(text2);
			for (int i = 0; i < text.Length; i++)
			{
				switch (text[i])
				{
				case '\r':
					if (i < text.Length - 1 && text[i + 1] == '\n')
					{
						stringBuilder.Append("\r\n" + text2);
						i++;
					}
					else
					{
						stringBuilder.Append("\r" + text2);
					}
					break;
				case '\n':
					stringBuilder.Append("\n" + text2);
					break;
				case '\u2028':
					stringBuilder.Append("\u2028" + text2);
					break;
				case '\u2029':
					stringBuilder.Append("\u2029" + text2);
					break;
				default:
					stringBuilder.Append(text[i]);
					break;
				case '@':
					break;
				}
			}
			base.Output.WriteLine(stringBuilder.ToString());
		}

		protected override void GenerateCompileUnitStart(CodeCompileUnit e)
		{
			base.Output.WriteLine("//------------------------------------------------------------------------------");
			base.Output.WriteLine("/// <autogenerated>");
			base.Output.WriteLine("///     This code was generated by a tool.");
			base.Output.WriteLine("///     Runtime Version: " + Environment.Version.ToString());
			base.Output.WriteLine("///");
			base.Output.WriteLine("///     Changes to this file may cause incorrect behavior and will be lost if ");
			base.Output.WriteLine("///     the code is regenerated.");
			base.Output.WriteLine("/// </autogenerated>");
			base.Output.WriteLine("//------------------------------------------------------------------------------");
			base.Output.WriteLine("");
			if (e.AssemblyCustomAttributes.Count > 0)
			{
				GenerateAssemblyAttributes(e.AssemblyCustomAttributes);
				base.Output.WriteLine("");
			}
		}

		protected override void GenerateConditionStatement(CodeConditionStatement e)
		{
			base.Output.Write("if (");
			base.Indent += 2;
			GenerateExpression(e.Condition);
			base.Indent -= 2;
			base.Output.Write(")");
			OutputStartingBrace();
			base.Indent++;
			GenerateStatements(e.TrueStatements);
			base.Indent--;
			if (e.FalseStatements.Count > 0)
			{
				base.Output.Write("}");
				if (base.Options.ElseOnClosing)
				{
					base.Output.Write(" ");
				}
				else
				{
					base.Output.WriteLine("");
				}
				base.Output.Write("else");
				OutputStartingBrace();
				base.Indent++;
				GenerateStatements(e.FalseStatements);
				base.Indent--;
			}
			base.Output.WriteLine("}");
		}

		protected override void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c)
		{
			if (base.IsCurrentClass || base.IsCurrentStruct)
			{
				OutputMemberAccessModifier(e.Attributes);
				if (e.CustomAttributes.Count > 0)
				{
					OutputAttributeDeclarations(e.CustomAttributes);
				}
				base.Output.Write("function ");
				OutputIdentifier(base.CurrentTypeName);
				base.Output.Write("(");
				OutputParameters(e.Parameters);
				base.Output.Write(")");
				CodeExpressionCollection baseConstructorArgs = e.BaseConstructorArgs;
				CodeExpressionCollection chainedConstructorArgs = e.ChainedConstructorArgs;
				OutputStartingBrace();
				base.Indent++;
				if (baseConstructorArgs.Count > 0)
				{
					base.Output.Write("super(");
					OutputExpressionList(baseConstructorArgs);
					base.Output.WriteLine(");");
				}
				if (chainedConstructorArgs.Count > 0)
				{
					base.Output.Write("this(");
					OutputExpressionList(chainedConstructorArgs);
					base.Output.WriteLine(");");
				}
				GenerateStatements(e.Statements);
				base.Output.WriteLine();
				base.Indent--;
				base.Output.WriteLine("}");
			}
		}

		protected override void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e)
		{
			bool flag = e.DelegateType != null;
			if (flag)
			{
				OutputType(e.DelegateType);
				base.Output.Write("(");
			}
			GenerateExpression(e.TargetObject);
			base.Output.Write(".");
			OutputIdentifier(e.MethodName);
			if (flag)
			{
				base.Output.Write(")");
			}
		}

		protected override void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e)
		{
			if (e.TargetObject != null)
			{
				GenerateExpression(e.TargetObject);
			}
			base.Output.Write("(");
			OutputExpressionList(e.Parameters);
			base.Output.Write(")");
		}

		protected override void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c)
		{
			base.Output.Write("public static ");
			if (e.CustomAttributes.Count > 0)
			{
				OutputAttributeDeclarations(e.CustomAttributes);
			}
			base.Output.Write("function Main()");
			OutputStartingBrace();
			base.Indent++;
			GenerateStatements(e.Statements);
			base.Indent--;
			base.Output.WriteLine("}");
			mainClassName = base.CurrentTypeName;
			mainMethodName = "Main";
		}

		protected override void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c)
		{
			throw new Exception(JScriptException.Localize("No event declarations", CultureInfo.CurrentUICulture));
		}

		protected override void GenerateEventReferenceExpression(CodeEventReferenceExpression e)
		{
			throw new Exception(JScriptException.Localize("No event references", CultureInfo.CurrentUICulture));
		}

		protected override void GenerateExpressionStatement(CodeExpressionStatement e)
		{
			GenerateExpression(e.Expression);
			if (!forLoopHack)
			{
				base.Output.WriteLine(";");
			}
		}

		protected override void GenerateField(CodeMemberField e)
		{
			if (base.IsCurrentDelegate || base.IsCurrentInterface)
			{
				throw new Exception(JScriptException.Localize("Only methods on interfaces", CultureInfo.CurrentUICulture));
			}
			if (base.IsCurrentEnum)
			{
				OutputIdentifier(e.Name);
				if (e.InitExpression != null)
				{
					base.Output.Write(" = ");
					GenerateExpression(e.InitExpression);
				}
				base.Output.WriteLine(",");
				return;
			}
			OutputMemberAccessModifier(e.Attributes);
			if ((e.Attributes & MemberAttributes.ScopeMask) == MemberAttributes.Static)
			{
				base.Output.Write("static ");
			}
			if (e.CustomAttributes.Count > 0)
			{
				OutputAttributeDeclarations(e.CustomAttributes);
				base.Output.WriteLine("");
			}
			if ((e.Attributes & MemberAttributes.Const) == MemberAttributes.Const)
			{
				if ((e.Attributes & MemberAttributes.ScopeMask) != MemberAttributes.Static)
				{
					base.Output.Write("static ");
				}
				base.Output.Write("const ");
			}
			else
			{
				base.Output.Write("var ");
			}
			OutputTypeNamePair(e.Type, e.Name);
			if (e.InitExpression != null)
			{
				base.Output.Write(" = ");
				GenerateExpression(e.InitExpression);
			}
			base.Output.WriteLine(";");
		}

		protected override void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e)
		{
			if (e.TargetObject != null)
			{
				GenerateExpression(e.TargetObject);
				base.Output.Write(".");
			}
			OutputIdentifier(e.FieldName);
		}

		protected override void GenerateGotoStatement(CodeGotoStatement e)
		{
			throw new Exception(JScriptException.Localize("No goto statements", CultureInfo.CurrentUICulture));
		}

		protected override void GenerateIndexerExpression(CodeIndexerExpression e)
		{
			GenerateExpression(e.TargetObject);
			base.Output.Write("[");
			bool flag = true;
			foreach (CodeExpression index in e.Indices)
			{
				if (flag)
				{
					flag = false;
				}
				else
				{
					base.Output.Write(", ");
				}
				GenerateExpression(index);
			}
			base.Output.Write("]");
		}

		protected override void GenerateIterationStatement(CodeIterationStatement e)
		{
			forLoopHack = true;
			base.Output.Write("for (");
			GenerateStatement(e.InitStatement);
			base.Output.Write("; ");
			GenerateExpression(e.TestExpression);
			base.Output.Write("; ");
			GenerateStatement(e.IncrementStatement);
			base.Output.Write(")");
			OutputStartingBrace();
			forLoopHack = false;
			base.Indent++;
			GenerateStatements(e.Statements);
			base.Indent--;
			base.Output.WriteLine("}");
		}

		protected override void GenerateLabeledStatement(CodeLabeledStatement e)
		{
			throw new Exception(JScriptException.Localize("No goto statements", CultureInfo.CurrentUICulture));
		}

		protected override void GenerateLinePragmaStart(CodeLinePragma e)
		{
			base.Output.WriteLine("");
			base.Output.WriteLine("//@cc_on");
			base.Output.Write("//@set @position(file=\"");
			base.Output.Write(Regex.Replace(e.FileName, "\\\\", "\\\\"));
			base.Output.Write("\";line=");
			base.Output.Write(e.LineNumber.ToString(CultureInfo.InvariantCulture));
			base.Output.WriteLine(")");
		}

		protected override void GenerateLinePragmaEnd(CodeLinePragma e)
		{
			base.Output.WriteLine("");
			base.Output.WriteLine("//@set @position(end)");
		}

		protected override void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c)
		{
			if (!base.IsCurrentInterface)
			{
				if (e.PrivateImplementationType == null)
				{
					OutputMemberAccessModifier(e.Attributes);
					OutputMemberVTableModifier(e.Attributes);
					OutputMemberScopeModifier(e.Attributes);
				}
			}
			else
			{
				OutputMemberVTableModifier(e.Attributes);
			}
			if (e.CustomAttributes.Count > 0)
			{
				OutputAttributeDeclarations(e.CustomAttributes);
			}
			base.Output.Write("function ");
			if (e.PrivateImplementationType != null && !base.IsCurrentInterface)
			{
				base.Output.Write(e.PrivateImplementationType.BaseType);
				base.Output.Write(".");
			}
			OutputIdentifier(e.Name);
			base.Output.Write("(");
			isArgumentList = false;
			try
			{
				OutputParameters(e.Parameters);
			}
			finally
			{
				isArgumentList = true;
			}
			base.Output.Write(")");
			if (e.ReturnType.BaseType.Length > 0 && string.Compare(e.ReturnType.BaseType, typeof(void).FullName, StringComparison.Ordinal) != 0)
			{
				base.Output.Write(" : ");
				OutputType(e.ReturnType);
			}
			if (!base.IsCurrentInterface && (e.Attributes & MemberAttributes.ScopeMask) != MemberAttributes.Abstract)
			{
				OutputStartingBrace();
				base.Indent++;
				GenerateStatements(e.Statements);
				base.Indent--;
				base.Output.WriteLine("}");
			}
			else
			{
				base.Output.WriteLine(";");
			}
		}

		protected override void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e)
		{
			GenerateMethodReferenceExpression(e.Method);
			base.Output.Write("(");
			OutputExpressionList(e.Parameters);
			base.Output.Write(")");
		}

		protected override void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e)
		{
			if (e.TargetObject != null)
			{
				if (e.TargetObject is CodeBinaryOperatorExpression)
				{
					base.Output.Write("(");
					GenerateExpression(e.TargetObject);
					base.Output.Write(")");
				}
				else
				{
					GenerateExpression(e.TargetObject);
				}
				base.Output.Write(".");
			}
			OutputIdentifier(e.MethodName);
		}

		protected override void GenerateMethodReturnStatement(CodeMethodReturnStatement e)
		{
			base.Output.Write("return");
			if (e.Expression != null)
			{
				base.Output.Write(" ");
				GenerateExpression(e.Expression);
			}
			base.Output.WriteLine(";");
		}

		protected override void GenerateNamespace(CodeNamespace e)
		{
			base.Output.WriteLine("//@cc_on");
			base.Output.WriteLine("//@set @debug(off)");
			base.Output.WriteLine("");
			GenerateNamespaceImports(e);
			base.Output.WriteLine("");
			GenerateCommentStatements(e.Comments);
			GenerateNamespaceStart(e);
			GenerateTypes(e);
			GenerateNamespaceEnd(e);
		}

		protected override void GenerateNamespaceEnd(CodeNamespace e)
		{
			if (e.Name != null && e.Name.Length > 0)
			{
				base.Indent--;
				base.Output.WriteLine("}");
			}
			if (mainClassName != null)
			{
				if (e.Name != null)
				{
					OutputIdentifier(e.Name);
					base.Output.Write(".");
				}
				OutputIdentifier(mainClassName);
				base.Output.Write(".");
				OutputIdentifier(mainMethodName);
				base.Output.WriteLine("();");
				mainClassName = null;
			}
		}

		protected override void GenerateNamespaceImport(CodeNamespaceImport e)
		{
			base.Output.Write("import ");
			OutputIdentifier(e.Namespace);
			base.Output.WriteLine(";");
		}

		protected override void GenerateNamespaceStart(CodeNamespace e)
		{
			if (e.Name != null && e.Name.Length > 0)
			{
				base.Output.Write("package ");
				OutputIdentifier(e.Name);
				OutputStartingBrace();
				base.Indent++;
			}
		}

		protected override void GenerateObjectCreateExpression(CodeObjectCreateExpression e)
		{
			base.Output.Write("new ");
			OutputType(e.CreateType);
			base.Output.Write("(");
			OutputExpressionList(e.Parameters);
			base.Output.Write(")");
		}

		protected override void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
		{
			if (e.CustomAttributes.Count > 0)
			{
				CodeAttributeDeclaration codeAttributeDeclaration = e.CustomAttributes[0];
				if (!(codeAttributeDeclaration.Name == "ParamArrayAttribute"))
				{
					throw new Exception(JScriptException.Localize("No parameter attributes", CultureInfo.CurrentUICulture));
				}
				base.Output.Write("... ");
			}
			OutputDirection(e.Direction);
			OutputTypeNamePair(e.Type, e.Name);
		}

		protected override void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c)
		{
			if (!base.IsCurrentClass && !base.IsCurrentStruct && !base.IsCurrentInterface)
			{
				return;
			}
			if (e.HasGet)
			{
				if (!base.IsCurrentInterface)
				{
					if (e.PrivateImplementationType == null)
					{
						OutputMemberAccessModifier(e.Attributes);
						OutputMemberVTableModifier(e.Attributes);
						OutputMemberScopeModifier(e.Attributes);
					}
				}
				else
				{
					OutputMemberVTableModifier(e.Attributes);
				}
				if (e.CustomAttributes.Count > 0)
				{
					if (base.IsCurrentInterface)
					{
						base.Output.Write("public ");
					}
					OutputAttributeDeclarations(e.CustomAttributes);
					base.Output.WriteLine("");
				}
				base.Output.Write("function get ");
				if (e.PrivateImplementationType != null && !base.IsCurrentInterface)
				{
					base.Output.Write(e.PrivateImplementationType.BaseType);
					base.Output.Write(".");
				}
				OutputIdentifier(e.Name);
				if (e.Parameters.Count > 0)
				{
					throw new Exception(JScriptException.Localize("No indexer declarations", CultureInfo.CurrentUICulture));
				}
				base.Output.Write("() : ");
				OutputType(e.Type);
				if (base.IsCurrentInterface || (e.Attributes & MemberAttributes.ScopeMask) == MemberAttributes.Abstract)
				{
					base.Output.WriteLine(";");
				}
				else
				{
					OutputStartingBrace();
					base.Indent++;
					GenerateStatements(e.GetStatements);
					base.Indent--;
					base.Output.WriteLine("}");
				}
			}
			if (!e.HasSet)
			{
				return;
			}
			if (!base.IsCurrentInterface)
			{
				if (e.PrivateImplementationType == null)
				{
					OutputMemberAccessModifier(e.Attributes);
					OutputMemberVTableModifier(e.Attributes);
					OutputMemberScopeModifier(e.Attributes);
				}
			}
			else
			{
				OutputMemberVTableModifier(e.Attributes);
			}
			if (e.CustomAttributes.Count > 0 && !e.HasGet)
			{
				if (base.IsCurrentInterface)
				{
					base.Output.Write("public ");
				}
				OutputAttributeDeclarations(e.CustomAttributes);
				base.Output.WriteLine("");
			}
			base.Output.Write("function set ");
			if (e.PrivateImplementationType != null && !base.IsCurrentInterface)
			{
				base.Output.Write(e.PrivateImplementationType.BaseType);
				base.Output.Write(".");
			}
			OutputIdentifier(e.Name);
			base.Output.Write("(");
			OutputTypeNamePair(e.Type, "value");
			if (e.Parameters.Count > 0)
			{
				throw new Exception(JScriptException.Localize("No indexer declarations", CultureInfo.CurrentUICulture));
			}
			base.Output.Write(")");
			if (base.IsCurrentInterface || (e.Attributes & MemberAttributes.ScopeMask) == MemberAttributes.Abstract)
			{
				base.Output.WriteLine(";");
				return;
			}
			OutputStartingBrace();
			base.Indent++;
			GenerateStatements(e.SetStatements);
			base.Indent--;
			base.Output.WriteLine("}");
		}

		protected override void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e)
		{
			if (e.TargetObject != null)
			{
				GenerateExpression(e.TargetObject);
				base.Output.Write(".");
			}
			OutputIdentifier(e.PropertyName);
		}

		protected override void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e)
		{
			base.Output.Write("value");
		}

		protected override void GenerateRemoveEventStatement(CodeRemoveEventStatement e)
		{
			GenerateExpression(e.Event.TargetObject);
			base.Output.Write(".remove_");
			base.Output.Write(e.Event.EventName);
			base.Output.Write("(");
			GenerateExpression(e.Listener);
			base.Output.WriteLine(");");
		}

		protected override void GenerateSingleFloatValue(float s)
		{
			base.Output.Write("float(");
			base.Output.Write(s.ToString(CultureInfo.InvariantCulture));
			base.Output.Write(")");
		}

		protected override void GenerateSnippetExpression(CodeSnippetExpression e)
		{
			base.Output.Write(e.Value);
		}

		protected override void GenerateSnippetMember(CodeSnippetTypeMember e)
		{
			base.Output.Write(e.Text);
		}

		protected override void GenerateSnippetStatement(CodeSnippetStatement e)
		{
			base.Output.WriteLine(e.Value);
		}

		protected override void GenerateThisReferenceExpression(CodeThisReferenceExpression e)
		{
			base.Output.Write("this");
		}

		protected override void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e)
		{
			base.Output.Write("throw");
			if (e.ToThrow != null)
			{
				base.Output.Write(" ");
				GenerateExpression(e.ToThrow);
			}
			base.Output.WriteLine(";");
		}

		protected override void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e)
		{
			base.Output.Write("try");
			OutputStartingBrace();
			base.Indent++;
			GenerateStatements(e.TryStatements);
			base.Indent--;
			CodeCatchClauseCollection catchClauses = e.CatchClauses;
			if (catchClauses.Count > 0)
			{
				IEnumerator enumerator = catchClauses.GetEnumerator();
				while (enumerator.MoveNext())
				{
					base.Output.Write("}");
					if (base.Options.ElseOnClosing)
					{
						base.Output.Write(" ");
					}
					else
					{
						base.Output.WriteLine("");
					}
					CodeCatchClause codeCatchClause = (CodeCatchClause)enumerator.Current;
					base.Output.Write("catch (");
					OutputIdentifier(codeCatchClause.LocalName);
					base.Output.Write(" : ");
					OutputType(codeCatchClause.CatchExceptionType);
					base.Output.Write(")");
					OutputStartingBrace();
					base.Indent++;
					GenerateStatements(codeCatchClause.Statements);
					base.Indent--;
				}
			}
			CodeStatementCollection finallyStatements = e.FinallyStatements;
			if (finallyStatements.Count > 0)
			{
				base.Output.Write("}");
				if (base.Options.ElseOnClosing)
				{
					base.Output.Write(" ");
				}
				else
				{
					base.Output.WriteLine("");
				}
				base.Output.Write("finally");
				OutputStartingBrace();
				base.Indent++;
				GenerateStatements(finallyStatements);
				base.Indent--;
			}
			base.Output.WriteLine("}");
		}

		protected override void GenerateTypeConstructor(CodeTypeConstructor e)
		{
			if (base.IsCurrentClass || base.IsCurrentStruct)
			{
				base.Output.Write("static ");
				OutputIdentifier(base.CurrentTypeName);
				OutputStartingBrace();
				base.Indent++;
				GenerateStatements(e.Statements);
				base.Indent--;
				base.Output.WriteLine("}");
			}
		}

		protected override void GenerateTypeEnd(CodeTypeDeclaration e)
		{
			if (!base.IsCurrentDelegate)
			{
				base.Indent--;
				base.Output.WriteLine("}");
			}
		}

		protected override void GenerateTypeOfExpression(CodeTypeOfExpression e)
		{
			OutputType(e.Type);
		}

		protected override string GetTypeOutput(CodeTypeReference typeRef)
		{
			string text = ((typeRef.ArrayElementType == null) ? GetBaseTypeOutput(typeRef.BaseType) : GetTypeOutput(typeRef.ArrayElementType));
			if (typeRef.ArrayRank > 0)
			{
				char[] array = new char[typeRef.ArrayRank + 1];
				array[0] = '[';
				array[typeRef.ArrayRank] = ']';
				for (int i = 1; i < typeRef.ArrayRank; i++)
				{
					array[i] = ',';
				}
				text += new string(array);
			}
			return text;
		}

		protected override void GenerateTypeStart(CodeTypeDeclaration e)
		{
			if (base.IsCurrentDelegate)
			{
				throw new Exception(JScriptException.Localize("No delegate declarations", CultureInfo.CurrentUICulture));
			}
			OutputTypeVisibility(e.TypeAttributes);
			if (e.CustomAttributes.Count > 0)
			{
				OutputAttributeDeclarations(e.CustomAttributes);
				base.Output.WriteLine("");
			}
			OutputTypeAttributes(e.TypeAttributes, base.IsCurrentStruct, base.IsCurrentEnum);
			OutputIdentifier(e.Name);
			if (base.IsCurrentEnum)
			{
				if (e.BaseTypes.Count > 1)
				{
					throw new Exception(JScriptException.Localize("Too many base types", CultureInfo.CurrentUICulture));
				}
				if (e.BaseTypes.Count == 1)
				{
					base.Output.Write(" : ");
					OutputType(e.BaseTypes[0]);
				}
			}
			else
			{
				bool flag = true;
				bool flag2 = false;
				foreach (CodeTypeReference baseType in e.BaseTypes)
				{
					if (flag)
					{
						base.Output.Write(" extends ");
						flag = false;
						flag2 = true;
					}
					else if (flag2)
					{
						base.Output.Write(" implements ");
						flag2 = false;
					}
					else
					{
						base.Output.Write(", ");
					}
					OutputType(baseType);
				}
			}
			OutputStartingBrace();
			base.Indent++;
		}

		protected override void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e)
		{
			base.Output.Write("var ");
			OutputTypeNamePair(e.Type, e.Name);
			if (e.InitExpression != null)
			{
				base.Output.Write(" = ");
				GenerateExpression(e.InitExpression);
			}
			base.Output.WriteLine(";");
		}

		protected override void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e)
		{
			OutputIdentifier(e.VariableName);
		}

		private bool IsKeyword(string value)
		{
			return keywords.ContainsKey(value);
		}

		protected override bool IsValidIdentifier(string value)
		{
			if (value == null || value.Length == 0)
			{
				return false;
			}
			VsaEngine vsaEngine = VsaEngine.CreateEngine();
			return vsaEngine.IsValidIdentifier(value);
		}

		protected override void OutputAttributeDeclarations(CodeAttributeDeclarationCollection attributes)
		{
			if (attributes.Count == 0)
			{
				return;
			}
			GenerateAttributeDeclarationsStart(attributes);
			IEnumerator enumerator = attributes.GetEnumerator();
			while (enumerator.MoveNext())
			{
				CodeAttributeDeclaration codeAttributeDeclaration = (CodeAttributeDeclaration)enumerator.Current;
				base.Output.Write(GetBaseTypeOutput(codeAttributeDeclaration.Name));
				base.Output.Write("(");
				bool flag = true;
				foreach (CodeAttributeArgument argument in codeAttributeDeclaration.Arguments)
				{
					if (flag)
					{
						flag = false;
					}
					else
					{
						base.Output.Write(", ");
					}
					OutputAttributeArgument(argument);
				}
				base.Output.Write(") ");
			}
			GenerateAttributeDeclarationsEnd(attributes);
		}

		protected override void OutputDirection(FieldDirection dir)
		{
			if (dir != 0 && (uint)(dir - 1) <= 1u)
			{
				if (!isArgumentList)
				{
					throw new Exception(JScriptException.Localize("No parameter direction", CultureInfo.CurrentUICulture));
				}
				base.Output.Write("&");
			}
		}

		protected override void OutputIdentifier(string ident)
		{
			base.Output.Write(CreateEscapedIdentifier(ident));
		}

		protected override void OutputMemberAccessModifier(MemberAttributes attributes)
		{
			switch (attributes & MemberAttributes.AccessMask)
			{
			case MemberAttributes.Assembly:
				base.Output.Write("internal ");
				break;
			case MemberAttributes.FamilyAndAssembly:
				base.Output.Write("internal ");
				break;
			case MemberAttributes.Family:
				base.Output.Write("protected ");
				break;
			case MemberAttributes.FamilyOrAssembly:
				base.Output.Write("protected internal ");
				break;
			case MemberAttributes.Public:
				base.Output.Write("public ");
				break;
			default:
				base.Output.Write("private ");
				break;
			}
		}

		protected override void OutputMemberScopeModifier(MemberAttributes attributes)
		{
			switch (attributes & MemberAttributes.ScopeMask)
			{
			case MemberAttributes.Abstract:
				base.Output.Write("abstract ");
				break;
			case MemberAttributes.Final:
				base.Output.Write("final ");
				break;
			case MemberAttributes.Static:
				base.Output.Write("static ");
				break;
			case MemberAttributes.Override:
				base.Output.Write("override ");
				break;
			}
		}

		private void OutputMemberVTableModifier(MemberAttributes attributes)
		{
			MemberAttributes memberAttributes = attributes & MemberAttributes.VTableMask;
			if (memberAttributes == MemberAttributes.New)
			{
				base.Output.Write("hide ");
			}
		}

		protected override void OutputParameters(CodeParameterDeclarationExpressionCollection parameters)
		{
			bool flag = true;
			IEnumerator enumerator = parameters.GetEnumerator();
			while (enumerator.MoveNext())
			{
				CodeParameterDeclarationExpression e = (CodeParameterDeclarationExpression)enumerator.Current;
				if (flag)
				{
					flag = false;
				}
				else
				{
					base.Output.Write(", ");
				}
				GenerateExpression(e);
			}
		}

		private void OutputStartingBrace()
		{
			if (base.Options.BracingStyle == "C")
			{
				base.Output.WriteLine("");
				base.Output.WriteLine("{");
			}
			else
			{
				base.Output.WriteLine(" {");
			}
		}

		protected override void OutputType(CodeTypeReference typeRef)
		{
			base.Output.Write(GetTypeOutput(typeRef));
		}

		protected override void OutputTypeAttributes(TypeAttributes attributes, bool isStruct, bool isEnum)
		{
			if (isEnum)
			{
				base.Output.Write("enum ");
				return;
			}
			switch (attributes & TypeAttributes.ClassSemanticsMask)
			{
			case TypeAttributes.NotPublic:
				if ((attributes & TypeAttributes.Sealed) == TypeAttributes.Sealed)
				{
					base.Output.Write("final ");
				}
				if ((attributes & TypeAttributes.Abstract) == TypeAttributes.Abstract)
				{
					base.Output.Write("abstract ");
				}
				base.Output.Write("class ");
				break;
			case TypeAttributes.ClassSemanticsMask:
				base.Output.Write("interface ");
				break;
			}
		}

		protected override void OutputTypeNamePair(CodeTypeReference typeRef, string name)
		{
			OutputIdentifier(name);
			base.Output.Write(" : ");
			OutputType(typeRef);
		}

		private void OutputTypeVisibility(TypeAttributes attributes)
		{
			switch (attributes & TypeAttributes.VisibilityMask)
			{
			case TypeAttributes.NestedAssembly:
			case TypeAttributes.NestedFamANDAssem:
				base.Output.Write("internal static ");
				break;
			case TypeAttributes.NestedFamily:
				base.Output.Write("protected static ");
				break;
			case TypeAttributes.VisibilityMask:
				base.Output.Write("protected internal static ");
				break;
			case TypeAttributes.NotPublic:
				base.Output.Write("internal ");
				break;
			case TypeAttributes.NestedPrivate:
				base.Output.Write("private static ");
				break;
			case TypeAttributes.NestedPublic:
				base.Output.Write("public static ");
				break;
			default:
				base.Output.Write("public ");
				break;
			}
		}

		protected override void ProcessCompilerOutputLine(CompilerResults results, string line)
		{
			Match match = outputReg.Match(line);
			if (match.Success)
			{
				CompilerError compilerError = new CompilerError();
				if (match.Groups[1].Success)
				{
					compilerError.FileName = match.Groups[2].Value;
					compilerError.Line = int.Parse(match.Groups[4].Value, CultureInfo.InvariantCulture);
					compilerError.Column = int.Parse(match.Groups[5].Value, CultureInfo.InvariantCulture);
				}
				if (string.Compare(match.Groups[7].Value, "warning", StringComparison.OrdinalIgnoreCase) == 0)
				{
					compilerError.IsWarning = true;
				}
				compilerError.ErrorNumber = match.Groups[8].Value;
				compilerError.ErrorText = match.Groups[9].Value;
				results.Errors.Add(compilerError);
			}
		}

		protected override string QuoteSnippetString(string value)
		{
			return QuoteSnippetStringCStyle(value);
		}

		private string QuoteSnippetStringCStyle(string value)
		{
			char[] array = value.ToCharArray();
			StringBuilder stringBuilder = new StringBuilder(value.Length + 5);
			stringBuilder.Append("\"");
			int num = 80;
			for (int i = 0; i < array.Length; i++)
			{
				switch (array[i])
				{
				case '\r':
					stringBuilder.Append("\\r");
					break;
				case '\t':
					stringBuilder.Append("\\t");
					break;
				case '"':
					stringBuilder.Append("\\\"");
					break;
				case '\'':
					stringBuilder.Append("\\'");
					break;
				case '\\':
					stringBuilder.Append("\\\\");
					break;
				case '\0':
					stringBuilder.Append("\\0");
					break;
				case '\n':
					stringBuilder.Append("\\n");
					break;
				case '\u2028':
					stringBuilder.Append("\\u2028");
					break;
				case '\u2029':
					stringBuilder.Append("\\u2029");
					break;
				default:
					stringBuilder.Append(array[i]);
					break;
				}
				if (i >= num && i + 1 < array.Length && (!IsSurrogateStart(array[i]) || !IsSurrogateEnd(array[i + 1])))
				{
					num = i + 80;
					stringBuilder.Append("\" + \r\n\"");
				}
			}
			stringBuilder.Append("\"");
			return stringBuilder.ToString();
		}

		private bool IsSurrogateStart(char c)
		{
			if ('\ud800' <= c)
			{
				return c <= '\udbff';
			}
			return false;
		}

		private bool IsSurrogateEnd(char c)
		{
			if ('\udc00' <= c)
			{
				return c <= '\udfff';
			}
			return false;
		}

		protected override void GeneratePrimitiveExpression(CodePrimitiveExpression e)
		{
			if (e.Value == null)
			{
				base.Output.Write("undefined");
			}
			else if (e.Value is DBNull)
			{
				base.Output.Write("null");
			}
			else if (e.Value is char)
			{
				GeneratePrimitiveChar((char)e.Value);
			}
			else
			{
				base.GeneratePrimitiveExpression(e);
			}
		}

		private void GeneratePrimitiveChar(char c)
		{
			base.Output.Write('\'');
			switch (c)
			{
			case '\r':
				base.Output.Write("\\r");
				break;
			case '\t':
				base.Output.Write("\\t");
				break;
			case '"':
				base.Output.Write("\\\"");
				break;
			case '\'':
				base.Output.Write("\\'");
				break;
			case '\\':
				base.Output.Write("\\\\");
				break;
			case '\0':
				base.Output.Write("\\0");
				break;
			case '\n':
				base.Output.Write("\\n");
				break;
			case '\u2028':
				base.Output.Write("\\u2028");
				break;
			case '\u2029':
				base.Output.Write("\\u2029");
				break;
			default:
				base.Output.Write(c);
				break;
			}
			base.Output.Write('\'');
		}

		protected override bool Supports(GeneratorSupport support)
		{
			return (support & (GeneratorSupport.ArraysOfArrays | GeneratorSupport.EntryPointMethod | GeneratorSupport.MultidimensionalArrays | GeneratorSupport.StaticConstructors | GeneratorSupport.TryCatchStatements | GeneratorSupport.DeclareEnums | GeneratorSupport.DeclareInterfaces | GeneratorSupport.AssemblyAttributes | GeneratorSupport.PublicStaticMembers)) == support;
		}
	}
	/// <summary>Wraps a <see cref="T:Microsoft.JScript.FunctionObject" />.</summary>
	public sealed class JSConstructor : ConstructorInfo
	{
		internal FunctionObject cons;

		/// <summary>Gets the attributes that are associated with this constructor.</summary>
		/// <returns>A bitwise combination of the enumeration values.</returns>
		public override MethodAttributes Attributes => cons.attributes;

		/// <summary>Gets the name of this constructor.</summary>
		/// <returns>The name of this constructor.</returns>
		public override string Name => cons.name;

		/// <summary>Gets the type that declares this constructor.</summary>
		/// <returns>The <see langword="Type" /> object for the class that declares this member.</returns>
		public override Type DeclaringType => Convert.ToType(cons.enclosing_scope);

		/// <summary>Gets the type of member that this method is. Identifies the type of class derived from <see cref="T:System.Reflection.MemberInfo" /> that this class derives from.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MemberTypes.Constructor" />, because this class derives from <see cref="T:System.Reflection.ConstructorInfo" />.</returns>
		public override MemberTypes MemberType => MemberTypes.Constructor;

		/// <summary>Gets a handle to the internal metadata representation of this constructor.</summary>
		/// <returns>A handle to the internal metadata representation of this constructor.</returns>
		public override RuntimeMethodHandle MethodHandle => GetConstructorInfo(null).MethodHandle;

		/// <summary>Gets the class object that was used to obtain this instance through reflection.</summary>
		/// <returns>The <see langword="Type" /> object for the class that declares this member.</returns>
		public override Type ReflectedType => DeclaringType;

		internal JSConstructor(FunctionObject cons)
		{
			this.cons = cons;
		}

		internal object Construct(object thisob, object[] args)
		{
			return LateBinding.CallValue(cons, args, construct: true, brackets: false, cons.engine, thisob, JSBinder.ob, null, null);
		}

		internal string GetClassFullName()
		{
			return ((ClassScope)cons.enclosing_scope).GetFullName();
		}

		internal ClassScope GetClassScope()
		{
			return (ClassScope)cons.enclosing_scope;
		}

		internal ConstructorInfo GetConstructorInfo(CompilerGlobals compilerGlobals)
		{
			return cons.GetConstructorInfo(compilerGlobals);
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this constructor, searching only for attributes of the specified type.</summary>
		/// <param name="t">The type of attribute to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of <see cref="T:System.Object" /> objects that has zero elements.</returns>
		public override object[] GetCustomAttributes(Type t, bool inherit)
		{
			return new object[0];
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this constructor.</summary>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of custom attributes that are attached to this method, or, if there are none, an array that has zero elements.</returns>
		public override object[] GetCustomAttributes(bool inherit)
		{
			if (cons != null)
			{
				CustomAttributeList customAttributes = cons.customAttributes;
				if (customAttributes != null)
				{
					return (object[])customAttributes.Evaluate(getForProperty: false);
				}
			}
			return new object[0];
		}

		/// <summary>Returns information about the implementation of this method.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MethodImplAttributes.Managed" /> and <see cref="F:System.Reflection.MethodImplAttributes.IL" />.</returns>
		public override MethodImplAttributes GetMethodImplementationFlags()
		{
			return MethodImplAttributes.IL;
		}

		internal PackageScope GetPackage()
		{
			return ((ClassScope)cons.enclosing_scope).GetPackage();
		}

		/// <summary>Gets the parameters of this constructor.</summary>
		/// <returns>An array that contains information that matches the signature of this constructor.</returns>
		public override ParameterInfo[] GetParameters()
		{
			return cons.parameter_declarations;
		}

		/// <summary>Invokes the constructor, using the specified culture and binding information.</summary>
		/// <param name="options">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">An object that converts the type from actual argument type to formal argument type.</param>
		/// <param name="parameters">The argument list to pass to the constructor.</param>
		/// <param name="culture">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		/// <returns>An instance of the class associated with the constructor.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public override object Invoke(BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			return LateBinding.CallValue(cons, parameters, construct: true, brackets: false, cons.engine, null, binder, culture, null);
		}

		/// <summary>Invokes the constructor on the specified object, using the specified culture and binding information.</summary>
		/// <param name="obj">The object to call the constructor on.</param>
		/// <param name="options">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">An object that converts the type from actual argument type to formal argument type.</param>
		/// <param name="parameters">The argument list to pass to the constructor.</param>
		/// <param name="culture">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		/// <returns>An instance of the class associated with the constructor.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public override object Invoke(object obj, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			return cons.Call(parameters, obj, binder, culture);
		}

		internal bool IsAccessibleFrom(ScriptObject scope)
		{
			while (scope != null && !(scope is ClassScope))
			{
				scope = scope.GetParent();
			}
			ClassScope classScope = (ClassScope)cons.enclosing_scope;
			if (base.IsPrivate)
			{
				if (scope == null)
				{
					return false;
				}
				if (scope != classScope)
				{
					return ((ClassScope)scope).IsNestedIn(classScope, isStatic: false);
				}
				return true;
			}
			if (base.IsFamily)
			{
				if (scope == null)
				{
					return false;
				}
				if (!((ClassScope)scope).IsSameOrDerivedFrom(classScope))
				{
					return ((ClassScope)scope).IsNestedIn(classScope, isStatic: false);
				}
				return true;
			}
			if (base.IsFamilyOrAssembly && scope != null && (((ClassScope)scope).IsSameOrDerivedFrom(classScope) || ((ClassScope)scope).IsNestedIn(classScope, isStatic: false)))
			{
				return true;
			}
			if (scope == null)
			{
				return classScope.GetPackage() == null;
			}
			return classScope.GetPackage() == ((ClassScope)scope).GetPackage();
		}

		/// <summary>Determines whether the specified attribute type is attached to this constructor.</summary>
		/// <param name="type">The attribute type to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>
		///   <see langword="false" /> in all cases.</returns>
		public override bool IsDefined(Type type, bool inherit)
		{
			return false;
		}

		internal Type OuterClassType()
		{
			FieldInfo outerClassField = ((ClassScope)cons.enclosing_scope).outerClassField;
			if (!(outerClassField == null))
			{
				return outerClassField.FieldType;
			}
			return null;
		}
	}
	/// <summary>The exception that is thrown by JScript to notify a common language runtime (CLR) host or program that an error occurred. A <see cref="T:Microsoft.JScript.JScriptException" /> usually takes a <see cref="T:Microsoft.JScript.JSError" /> enumeration value.</summary>
	[Serializable]
	public class JScriptException : ApplicationException, IVsaFullErrorInfo, IJSVsaError
	{
		internal object value;

		[NonSerialized]
		internal Context context;

		internal bool isError;

		internal static readonly string ContextStringDelimiter = ";;";

		private int code;

		/// <summary>Gets the name of the source code file that contains the error.</summary>
		/// <returns>The name of the source code file, or the string literal "no source" if the <see cref="T:Microsoft.JScript.Context" /> is <see langword="null" />.</returns>
		public string SourceMoniker
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (context != null)
				{
					return context.document.documentName;
				}
				return "no source";
			}
		}

		/// <summary>Gets the column in the code in which the error occurs.</summary>
		/// <returns>The column in the code in which the error occurs, or 0 if the <see cref="T:Microsoft.JScript.Context" /> is null.</returns>
		public int StartColumn
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				return Column;
			}
		}

		/// <summary>Gets the column in the code in which the error occurs.</summary>
		/// <returns>The column in the code in which the error occurs, or 0 if the <see cref="T:Microsoft.JScript.Context" /> is <see langword="null" />.</returns>
		public int Column
		{
			get
			{
				if (context != null)
				{
					return context.StartColumn + context.document.startCol + 1;
				}
				return 0;
			}
		}

		/// <summary>Gets a message that describes the error.</summary>
		/// <returns>A message that describes the error.</returns>
		string IJSVsaError.Description
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				return Description;
			}
		}

		/// <summary>Gets a message that describes the error.</summary>
		/// <returns>A message that describes the error.</returns>
		public string Description => Message;

		/// <summary>Gets the line of code in which the error ends.</summary>
		/// <returns>The line of code in which the error ends, or 0 if the <see cref="T:Microsoft.JScript.Context" /> is <see langword="null" />.</returns>
		public int EndLine
		{
			get
			{
				if (context != null)
				{
					return context.EndLine + context.document.startLine - context.document.lastLineInSource;
				}
				return 0;
			}
		}

		/// <summary>Gets the column in the code in which the error ends.</summary>
		/// <returns>The column in the code in which the error ends, or 0 if the <see cref="T:Microsoft.JScript.Context" /> is <see langword="null" />.</returns>
		public int EndColumn
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (context != null)
				{
					return context.EndColumn + context.document.startCol + 1;
				}
				return 0;
			}
		}

		/// <summary>Gets the <see cref="P:System.Exception.HResult" /> code of the error.</summary>
		/// <returns>The <see cref="P:System.Exception.HResult" /> code of the error.</returns>
		int IJSVsaError.Number
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				return Number;
			}
		}

		/// <summary>Gets the <see cref="P:System.Exception.HResult" /> code of the error.</summary>
		/// <returns>The <see cref="P:System.Exception.HResult" /> code of the error.</returns>
		public int Number => ErrorNumber;

		/// <summary>Gets the <see cref="P:System.Exception.HResult" /> code of the error.</summary>
		/// <returns>The <see cref="P:System.Exception.HResult" /> code of the error.</returns>
		public int ErrorNumber => base.HResult;

		/// <summary>Gets the line of code in which the error occurs.</summary>
		/// <returns>The line of code in which the error occurs, or 0 if the <see cref="T:Microsoft.JScript.Context" /> is <see langword="null" />.</returns>
		public int Line
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (context != null)
				{
					return context.StartLine + context.document.startLine - context.document.lastLineInSource;
				}
				return 0;
			}
		}

		/// <summary>Gets the text of the code in which the error occurs.</summary>
		/// <returns>The text of the code, or an empty string if the <see cref="T:Microsoft.JScript.Context" /> is <see langword="null" />.</returns>
		public string LineText
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (context != null)
				{
					return context.source_string;
				}
				return "";
			}
		}

		/// <summary>Gets a message that describes the error.</summary>
		/// <returns>A message that describes the error.</returns>
		public override string Message
		{
			get
			{
				if (value is Exception)
				{
					Exception ex = (Exception)value;
					string message = ex.Message;
					if (message != null && message.Length > 0)
					{
						return message;
					}
					return ex.ToString();
				}
				string text = (base.HResult & 0xFFFF).ToString(CultureInfo.InvariantCulture);
				CultureInfo culture = null;
				if (context != null && context.document != null)
				{
					VsaEngine engine = context.document.engine;
					if (engine != null)
					{
						culture = engine.ErrorCultureInfo;
					}
				}
				if (value is ErrorObject)
				{
					string message2 = ((ErrorObject)value).Message;
					if (message2 != null && message2.Length > 0)
					{
						return message2;
					}
					return Localize("No description available", culture) + ": " + text;
				}
				if (value is string)
				{
					switch (base.HResult & 0xFFFF)
					{
					case 13:
					case 1111:
					case 1121:
					case 1128:
					case 1134:
					case 1151:
					case 1158:
					case 1170:
					case 1172:
					case 1176:
					case 1212:
					case 1231:
					case 1241:
					case 1246:
					case 1259:
					case 1262:
					case 1267:
					case 1268:
					case 1269:
						return Localize(text, (string)value, culture);
					default:
						return (string)value;
					}
				}
				if (context != null)
				{
					switch (base.HResult & 0xFFFF)
					{
					case 1111:
					case 1123:
					case 1135:
					case 1136:
					case 1137:
					case 1141:
					case 1149:
					case 1150:
					case 1164:
					case 1187:
					case 1210:
					case 1243:
					case 1244:
					case 1245:
					case 5007:
					case 5009:
					case 5040:
						return Localize(text, context.GetCode(), culture);
					}
				}
				return Localize((base.HResult & 0xFFFF).ToString(CultureInfo.InvariantCulture), culture);
			}
		}

		/// <summary>Gets a number between 0 (most severe) and 4 (least severe) that indicates the severity of the error. 0 is the default.</summary>
		/// <returns>A number between 0 and 4.</returns>
		public int Severity
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				int hResult = base.HResult;
				if ((hResult & 0xFFFF0000u) != 2148139008u)
				{
					return 0;
				}
				if (!isError)
				{
					switch (hResult & 0xFFFF)
					{
					case 1149:
						return 4;
					case 1150:
						return 4;
					case 1215:
						return 1;
					case 5040:
						return 1;
					case 1242:
						return 1;
					case 1190:
						return 3;
					case 1156:
						return 1;
					case 1121:
						return 2;
					case 1176:
						return 1;
					case 1111:
						return 1;
					case 1101:
						return 1;
					case 1142:
						return 1;
					case 1170:
						return 1;
					case 1108:
						return 1;
					case 1137:
						return 2;
					case 1173:
						return 1;
					case 1164:
						return 1;
					case 1141:
						return 1;
					case 1186:
						return 2;
					case 1260:
						return 1;
					case 1261:
						return 4;
					case 1223:
						return 1;
					case 1255:
						return 3;
					case 1206:
						return 1;
					case 1247:
						return 1;
					case 1207:
						return 1;
					case 1204:
						return 1;
					case 1148:
						return 1;
					case 1135:
						return 3;
					case 1205:
						return 1;
					case 1169:
						return 1;
					case 1136:
						return 3;
					case 1187:
						return 3;
					case 1267:
						return 1;
					}
				}
				return 0;
			}
		}

		/// <summary>Gets the source code item that caused the error.</summary>
		/// <returns>The source code item; or throws a <see cref="T:Microsoft.JScript.NoContextException" /> if the <see cref="T:Microsoft.JScript.Context" /> is <see langword="null" />.</returns>
		public IJSVsaItem SourceItem
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (context != null)
				{
					return context.document.sourceItem;
				}
				throw new NoContextException();
			}
		}

		/// <summary>Gets the stack trace information at the time of the error.</summary>
		/// <returns>The stack trace information.</returns>
		public override string StackTrace
		{
			get
			{
				if (this.context == null)
				{
					return Message + Environment.NewLine + base.StackTrace;
				}
				StringBuilder stringBuilder = new StringBuilder();
				Context context = this.context;
				string documentName = context.document.documentName;
				if (documentName != null && documentName.Length > 0)
				{
					stringBuilder.Append(documentName + ": ");
				}
				CultureInfo culture = null;
				if (this.context != null && this.context.document != null)
				{
					VsaEngine engine = this.context.document.engine;
					if (engine != null)
					{
						culture = engine.ErrorCultureInfo;
					}
				}
				stringBuilder.Append(Localize("Line", culture));
				stringBuilder.Append(' ');
				stringBuilder.Append(context.StartLine);
				stringBuilder.Append(" - ");
				stringBuilder.Append(Localize("Error", culture));
				stringBuilder.Append(": ");
				stringBuilder.Append(Message);
				stringBuilder.Append(Environment.NewLine);
				if (context.document.engine != null)
				{
					Stack callContextStack = context.document.engine.Globals.CallContextStack;
					int i = 0;
					for (int num = callContextStack.Size(); i < num; i++)
					{
						CallContext callContext = (CallContext)callContextStack.Peek(i);
						stringBuilder.Append("    ");
						stringBuilder.Append(Localize("at call to", culture));
						stringBuilder.Append(callContext.FunctionName());
						stringBuilder.Append(' ');
						stringBuilder.Append(Localize("in line", culture));
						stringBuilder.Append(": ");
						stringBuilder.Append(callContext.sourceContext.EndLine);
					}
				}
				return stringBuilder.ToString();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JScriptException" /> class.</summary>
		public JScriptException()
			: this(JSError.NoError)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JScriptException" /> class, using the specified error message.</summary>
		/// <param name="m">The message that describes the error.</param>
		public JScriptException(string m)
			: this(m, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JScriptException" /> class, using the specified error message and a reference to the inner exception that is the cause of this exception.</summary>
		/// <param name="m">The message that describes the error.</param>
		/// <param name="e">The exception that is the cause of the current exception.</param>
		public JScriptException(string m, Exception e)
			: this(m, e, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JScriptException" /> class, using the specified <see cref="T:Microsoft.JScript.JSError" />.</summary>
		/// <param name="errorNumber">One of the enumeration values. The value specifies the error.</param>
		public JScriptException(JSError errorNumber)
			: this(errorNumber, null)
		{
		}

		internal JScriptException(JSError errorNumber, Context context)
		{
			value = Missing.Value;
			this.context = context;
			code = (base.HResult = (int)(2148139008L + (long)errorNumber));
		}

		internal JScriptException(object value, Context context)
		{
			this.value = value;
			this.context = context;
			code = (base.HResult = -2146823266);
		}

		internal JScriptException(Exception e, Context context)
			: this(null, e, context)
		{
		}

		internal JScriptException(string m, Exception e, Context context)
			: base(m, e)
		{
			value = e;
			this.context = context;
			if (e is StackOverflowException)
			{
				code = (base.HResult = -2146828260);
				value = Missing.Value;
				return;
			}
			if (e is OutOfMemoryException)
			{
				code = (base.HResult = -2146828281);
				value = Missing.Value;
				return;
			}
			if (e is ExternalException)
			{
				code = (base.HResult = ((ExternalException)e).ErrorCode);
				if ((base.HResult & 0xFFFF0000u) == 2148139008u && Enum.IsDefined(typeof(JSError), base.HResult & 0xFFFF))
				{
					value = Missing.Value;
				}
				return;
			}
			int hRForException = Marshal.GetHRForException(e);
			if ((hRForException & 0xFFFF0000u) == 2148139008u && Enum.IsDefined(typeof(JSError), hRForException & 0xFFFF))
			{
				code = (base.HResult = hRForException);
				value = Missing.Value;
			}
			else
			{
				code = (base.HResult = -2146823266);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JScriptException" /> class, using the specified serialized data.</summary>
		/// <param name="info">The serialized object data about the exception that is being thrown.</param>
		/// <param name="context">Contextual information about the source or destination.</param>
		protected JScriptException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			code = (base.HResult = info.GetInt32("Code"));
			value = Missing.Value;
			isError = info.GetBoolean("IsError");
		}

		internal ErrorType GetErrorType()
		{
			int hResult = base.HResult;
			if ((hResult & 0xFFFF0000u) != 2148139008u)
			{
				return ErrorType.OtherError;
			}
			return (hResult & 0xFFFF) switch
			{
				1192 => ErrorType.SyntaxError, 
				1184 => ErrorType.ReferenceError, 
				1183 => ErrorType.ReferenceError, 
				5029 => ErrorType.RangeError, 
				5030 => ErrorType.RangeError, 
				1249 => ErrorType.SyntaxError, 
				5040 => ErrorType.ReferenceError, 
				1019 => ErrorType.SyntaxError, 
				1020 => ErrorType.SyntaxError, 
				1023 => ErrorType.SyntaxError, 
				1025 => ErrorType.SyntaxError, 
				1018 => ErrorType.SyntaxError, 
				1103 => ErrorType.SyntaxError, 
				1199 => ErrorType.SyntaxError, 
				1200 => ErrorType.SyntaxError, 
				1198 => ErrorType.SyntaxError, 
				5010 => ErrorType.TypeError, 
				1214 => ErrorType.TypeError, 
				1119 => ErrorType.SyntaxError, 
				1182 => ErrorType.TypeError, 
				5000 => ErrorType.ReferenceError, 
				1106 => ErrorType.SyntaxError, 
				1105 => ErrorType.SyntaxError, 
				1104 => ErrorType.SyntaxError, 
				1030 => ErrorType.SyntaxError, 
				1120 => ErrorType.SyntaxError, 
				1177 => ErrorType.SyntaxError, 
				1109 => ErrorType.SyntaxError, 
				1233 => ErrorType.SyntaxError, 
				5006 => ErrorType.TypeError, 
				1176 => ErrorType.TypeError, 
				1203 => ErrorType.ReferenceError, 
				1027 => ErrorType.SyntaxError, 
				1251 => ErrorType.TypeError, 
				5036 => ErrorType.ReferenceError, 
				5015 => ErrorType.TypeError, 
				1107 => ErrorType.SyntaxError, 
				1248 => ErrorType.SyntaxError, 
				1195 => ErrorType.SyntaxError, 
				5026 => ErrorType.RangeError, 
				5002 => ErrorType.TypeError, 
				5008 => ErrorType.ReferenceError, 
				1014 => ErrorType.SyntaxError, 
				5033 => ErrorType.EvalError, 
				1208 => ErrorType.TypeError, 
				1243 => ErrorType.ReferenceError, 
				1213 => ErrorType.TypeError, 
				5 => ErrorType.TypeError, 
				1143 => ErrorType.TypeError, 
				1144 => ErrorType.TypeError, 
				1146 => ErrorType.TypeError, 
				1235 => ErrorType.SyntaxError, 
				1034 => ErrorType.SyntaxError, 
				1114 => ErrorType.SyntaxError, 
				5023 => ErrorType.TypeError, 
				1152 => ErrorType.SyntaxError, 
				1137 => ErrorType.SyntaxError, 
				1270 => ErrorType.SyntaxError, 
				1160 => ErrorType.SyntaxError, 
				5037 => ErrorType.ReferenceError, 
				5038 => ErrorType.ReferenceError, 
				1115 => ErrorType.SyntaxError, 
				5035 => ErrorType.ReferenceError, 
				5042 => ErrorType.ReferenceError, 
				5031 => ErrorType.TypeError, 
				1110 => ErrorType.ReferenceError, 
				1129 => ErrorType.TypeError, 
				1210 => ErrorType.ReferenceError, 
				1112 => ErrorType.TypeError, 
				1237 => ErrorType.ReferenceError, 
				1032 => ErrorType.SyntaxError, 
				1033 => ErrorType.SyntaxError, 
				1029 => ErrorType.SyntaxError, 
				1003 => ErrorType.SyntaxError, 
				1100 => ErrorType.SyntaxError, 
				1191 => ErrorType.SyntaxError, 
				1016 => ErrorType.SyntaxError, 
				5032 => ErrorType.TypeError, 
				1011 => ErrorType.SyntaxError, 
				1010 => ErrorType.SyntaxError, 
				1026 => ErrorType.SyntaxError, 
				1005 => ErrorType.SyntaxError, 
				1008 => ErrorType.SyntaxError, 
				1028 => ErrorType.SyntaxError, 
				1245 => ErrorType.ReferenceError, 
				1007 => ErrorType.SyntaxError, 
				1194 => ErrorType.SyntaxError, 
				1009 => ErrorType.SyntaxError, 
				1006 => ErrorType.SyntaxError, 
				1193 => ErrorType.SyntaxError, 
				1004 => ErrorType.SyntaxError, 
				1151 => ErrorType.ReferenceError, 
				1246 => ErrorType.ReferenceError, 
				1158 => ErrorType.TypeError, 
				1123 => ErrorType.ReferenceError, 
				1252 => ErrorType.ReferenceError, 
				451 => ErrorType.TypeError, 
				1031 => ErrorType.SyntaxError, 
				1113 => ErrorType.SyntaxError, 
				1024 => ErrorType.SyntaxError, 
				5001 => ErrorType.TypeError, 
				5007 => ErrorType.TypeError, 
				438 => ErrorType.TypeError, 
				1161 => ErrorType.SyntaxError, 
				1234 => ErrorType.SyntaxError, 
				1165 => ErrorType.SyntaxError, 
				1240 => ErrorType.SyntaxError, 
				5027 => ErrorType.RangeError, 
				1238 => ErrorType.ReferenceError, 
				5016 => ErrorType.TypeError, 
				5017 => ErrorType.SyntaxError, 
				1223 => ErrorType.SyntaxError, 
				1159 => ErrorType.SyntaxError, 
				1244 => ErrorType.ReferenceError, 
				5005 => ErrorType.TypeError, 
				1185 => ErrorType.ReferenceError, 
				1002 => ErrorType.SyntaxError, 
				1204 => ErrorType.TypeError, 
				1197 => ErrorType.SyntaxError, 
				1134 => ErrorType.ReferenceError, 
				13 => ErrorType.TypeError, 
				1135 => ErrorType.ReferenceError, 
				5009 => ErrorType.ReferenceError, 
				1196 => ErrorType.SyntaxError, 
				1133 => ErrorType.SyntaxError, 
				1015 => ErrorType.SyntaxError, 
				5024 => ErrorType.URIError, 
				5025 => ErrorType.URIError, 
				5013 => ErrorType.TypeError, 
				5041 => ErrorType.ReferenceError, 
				1118 => ErrorType.SyntaxError, 
				1224 => ErrorType.SyntaxError, 
				1226 => ErrorType.SyntaxError, 
				1227 => ErrorType.SyntaxError, 
				1228 => ErrorType.SyntaxError, 
				1230 => ErrorType.SyntaxError, 
				1232 => ErrorType.SyntaxError, 
				1256 => ErrorType.SyntaxError, 
				1269 => ErrorType.SyntaxError, 
				_ => ErrorType.OtherError, 
			};
		}

		/// <summary>Stores information about the exception, including <c>IsError</c> and <c>Code</c> values, in the <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</summary>
		/// <param name="info">The serialized object data about the exception that is being thrown.</param>
		/// <param name="context">Contextual information about the source or destination.</param>
		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			base.GetObjectData(info, context);
			info.AddValue("IsError", isError);
			info.AddValue("Code", code);
		}

		internal static string Localize(string key, CultureInfo culture)
		{
			return Localize(key, null, culture);
		}

		internal static string Localize(string key, string context, CultureInfo culture)
		{
			try
			{
				ResourceManager resourceManager = new ResourceManager("Microsoft.JScript", typeof(JScriptException).Module.Assembly);
				string @string = resourceManager.GetString(key, culture);
				if (@string != null)
				{
					int num = @string.IndexOf(ContextStringDelimiter);
					if (num == -1)
					{
						return @string;
					}
					if (context == null)
					{
						return @string.Substring(0, num);
					}
					return string.Format(culture, @string.Substring(num + 2), new object[1] { context });
				}
				return key;
			}
			catch (MissingManifestResourceException)
			{
				return key;
			}
		}
	}
	/// <summary>The exception that is thrown when there is no code <see cref="T:Microsoft.JScript.Context" /> associated with a <see cref="T:Microsoft.JScript.JScriptException" />.</summary>
	[Serializable]
	public class NoContextException : ApplicationException
	{
		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.NoContextException" /> class.</summary>
		public NoContextException()
			: base(JScriptException.Localize("No Source Context available", CultureInfo.CurrentUICulture))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.NoContextException" /> class, using the specified error message.</summary>
		/// <param name="m">The message that describes the error.</param>
		public NoContextException(string m)
			: base(m)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.NoContextException" /> class, using the specified error message and a reference to the inner exception that is the cause of this exception.</summary>
		/// <param name="m">The message that describes the error.</param>
		/// <param name="e">The exception that is the cause of the current exception.</param>
		public NoContextException(string m, Exception e)
			: base(m, e)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.NoContextException" /> class, using the specified serialized data.</summary>
		/// <param name="s">The serialized object data about the exception that is being thrown.</param>
		/// <param name="c">Contextual information about the source or destination.</param>
		protected NoContextException(SerializationInfo s, StreamingContext c)
			: base(s, c)
		{
		}
	}
	/// <summary>Specifies the JScript error messages. This class belongs to the compilation and run-time state category.</summary>
	[Guid("268CA962-2FEF-3152-BA46-E18658B7FA4F")]
	[ComVisible(true)]
	public enum JSError
	{
		/// <summary>No error. This is the default (0) value for the enumeration.</summary>
		NoError = 0,
		/// <summary>Invalid procedure call or argument.</summary>
		InvalidCall = 5,
		/// <summary>Out of memory.</summary>
		OutOfMemory = 7,
		/// <summary>Type mismatch.</summary>
		TypeMismatch = 13,
		/// <summary>Out of stack space.</summary>
		OutOfStack = 28,
		/// <summary>An internal error has been thrown.</summary>
		InternalError = 51,
		/// <summary>File not found.</summary>
		FileNotFound = 53,
		/// <summary>An object is required.</summary>
		NeedObject = 424,
		/// <summary>Cannot create object.</summary>
		CantCreateObject = 429,
		/// <summary>Object does not support this property or method.</summary>
		OLENoPropOrMethod = 438,
		/// <summary>The object does not support this action.</summary>
		ActionNotSupported = 445,
		/// <summary>This object is not a collection.</summary>
		NotCollection = 451,
		/// <summary>Discovered syntax error.</summary>
		SyntaxError = 1002,
		/// <summary>Expected ":".</summary>
		NoColon = 1003,
		/// <summary>Expected ";".</summary>
		NoSemicolon = 1004,
		/// <summary>Expected "(".</summary>
		NoLeftParen = 1005,
		/// <summary>Expected ")".</summary>
		NoRightParen = 1006,
		/// <summary>Expected "]".</summary>
		NoRightBracket = 1007,
		/// <summary>Expected "{".</summary>
		NoLeftCurly = 1008,
		/// <summary>Expected "}".</summary>
		NoRightCurly = 1009,
		/// <summary>Expected identifier.</summary>
		NoIdentifier = 1010,
		/// <summary>Expected "=".</summary>
		NoEqual = 1011,
		/// <summary>Invalid character.</summary>
		IllegalChar = 1014,
		/// <summary>String constant not terminated.</summary>
		UnterminatedString = 1015,
		/// <summary>Comment not terminated.</summary>
		NoCommentEnd = 1016,
		/// <summary>Return statement cannot appear outside the function.</summary>
		BadReturn = 1018,
		/// <summary>Cannot have <see langword="break" /> outside the loop.</summary>
		BadBreak = 1019,
		/// <summary>Cannot have <see langword="continue" /> outside the loop.</summary>
		BadContinue = 1020,
		/// <summary>Expected hexadecimal digit.</summary>
		BadHexDigit = 1023,
		/// <summary>Expected <see langword="while" />.</summary>
		NoWhile = 1024,
		/// <summary>There is already a label that has that name.</summary>
		BadLabel = 1025,
		/// <summary>Label not found.</summary>
		NoLabel = 1026,
		/// <summary>
		///   <see langword="default" /> can appear only once in a <see langword="switch" /> statement.</summary>
		DupDefault = 1027,
		/// <summary>Expected identifier or <see langword="string" />.</summary>
		NoMemberIdentifier = 1028,
		/// <summary>Expected <see langword="@end" />.</summary>
		NoCcEnd = 1029,
		/// <summary>Conditional compilation is turned off.</summary>
		CcOff = 1030,
		/// <summary>Expected constant.</summary>
		NotConst = 1031,
		/// <summary>Expected <see langword="@" />.</summary>
		NoAt = 1032,
		/// <summary>Expected <see langword="catch" />.</summary>
		NoCatch = 1033,
		/// <summary>Unmatched <see langword="else" />; no <see langword="if" /> defined.</summary>
		InvalidElse = 1034,
		/// <summary>Expected ",".</summary>
		NoComma = 1100,
		/// <summary>Visibility modifier already defined.</summary>
		DupVisibility = 1101,
		/// <summary>Invalid visibility modifier.</summary>
		IllegalVisibility = 1102,
		/// <summary>Missing <see langword="case" /> or <see langword="default" /> statement.</summary>
		BadSwitch = 1103,
		/// <summary>Unmatched <see langword="@end" />; no <see langword="@if" /> defined.</summary>
		CcInvalidEnd = 1104,
		/// <summary>Unmatched <see langword="@else" />; no <see langword="@if" /> defined.</summary>
		CcInvalidElse = 1105,
		/// <summary>Unmatched <see langword="@elif" />; no <see langword="@if" /> defined.</summary>
		CcInvalidElif = 1106,
		/// <summary>Expecting more source characters.</summary>
		ErrEOF = 1107,
		/// <summary>Incompatible visibility modifier.</summary>
		IncompatibleVisibility = 1108,
		/// <summary>Class definition not allowed in this context.</summary>
		ClassNotAllowed = 1109,
		/// <summary>An expression must be a compile-time constant.</summary>
		NeedCompileTimeConstant = 1110,
		/// <summary>Identifier already in use.</summary>
		DuplicateName = 1111,
		/// <summary>A type name is expected.</summary>
		NeedType = 1112,
		/// <summary>Valid only inside a class definition.</summary>
		NotInsideClass = 1113,
		/// <summary>An unknown position directive was discovered.</summary>
		InvalidPositionDirective = 1114,
		/// <summary>Directive cannot be followed by other code on the same line.</summary>
		MustBeEOL = 1115,
		/// <summary>Wrong debugger directive or wrong position for the directive.</summary>
		WrongDirective = 1118,
		/// <summary>Position directive must be ended before a new one can be started.</summary>
		CannotNestPositionDirective = 1119,
		/// <summary>Circular definition.</summary>
		CircularDefinition = 1120,
		/// <summary>The specified type is deprecated.</summary>
		Deprecated = 1121,
		/// <summary>It is not valid to use <see langword="this" /> in the current context.</summary>
		IllegalUseOfThis = 1122,
		/// <summary>The object or member is not accessible from this scope.</summary>
		NotAccessible = 1123,
		/// <summary>Only a constructor function can have the same name as the class it appears in.</summary>
		CannotUseNameOfClass = 1124,
		/// <summary>The class must provide an implementation of the method.</summary>
		MustImplementMethod = 1128,
		/// <summary>An interface name is expected.</summary>
		NeedInterface = 1129,
		/// <summary>Catch clause will never be reached.</summary>
		UnreachableCatch = 1133,
		/// <summary>Type cannot be extended.</summary>
		TypeCannotBeExtended = 1134,
		/// <summary>Variable has not been declared.</summary>
		UndeclaredVariable = 1135,
		/// <summary>Uninitialized variables are dangerous and slow to use. Did you intend to leave it uninitialized?</summary>
		VariableLeftUninitialized = 1136,
		/// <summary>You cannot use a reserved word as an identifier.</summary>
		KeywordUsedAsIdentifier = 1137,
		/// <summary>Object or member is not allowed in a call to the base class constructor.</summary>
		NotAllowedInSuperConstructorCall = 1140,
		/// <summary>You cannot call this method directly. If possible, use property accessors instead.</summary>
		NotMeantToBeCalledDirectly = 1141,
		/// <summary>The <see langword="get" /> and <see langword="set" /> methods of this property do not match each other.</summary>
		GetAndSetAreInconsistent = 1142,
		/// <summary>A custom attribute class must derive from <see cref="T:System.Attribute" />.</summary>
		InvalidCustomAttribute = 1143,
		/// <summary>Only primitive types are allowed in a custom attribute constructor arguments list.</summary>
		InvalidCustomAttributeArgument = 1144,
		/// <summary>Unknown custom attribute class or constructor.</summary>
		InvalidCustomAttributeClassOrCtor = 1146,
		/// <summary>There are too many actual parameters. The excess parameters will be ignored.</summary>
		TooManyParameters = 1148,
		/// <summary>The <see cref="T:Microsoft.JScript.With" /> statement has made the use of this name ambiguous.</summary>
		AmbiguousBindingBecauseOfWith = 1149,
		/// <summary>The presence of <see cref="T:Microsoft.JScript.Eval" /> has made the use of this name ambiguous.</summary>
		AmbiguousBindingBecauseOfEval = 1150,
		/// <summary>Objects of this type do not have such a member.</summary>
		NoSuchMember = 1151,
		/// <summary>Cannot define the property Item on an <see cref="T:Microsoft.JScript.Expando" /> class. This Item is reserved for the <see cref="T:Microsoft.JScript.Expando" /> fields.</summary>
		ItemNotAllowedOnExpandoClass = 1152,
		/// <summary>Cannot define a property named <c>Item</c> on an <see cref="T:Microsoft.JScript.Expando" /> class.</summary>
		MethodNotAllowedOnExpandoClass = 1153,
		/// <summary>Cannot create the <see cref="T:Microsoft.JScript.Expando" /> class because a property named <c>Item</c> is already defined in the class hierarchy.</summary>
		MethodClashOnExpandoSuperClass = 1155,
		/// <summary>A base class is already marked <see cref="T:Microsoft.JScript.Expando" />; current specification will be ignored.</summary>
		BaseClassIsExpandoAlready = 1156,
		/// <summary>An abstract method cannot be private.</summary>
		AbstractCannotBePrivate = 1157,
		/// <summary>Objects of this type are not indexable.</summary>
		NotIndexable = 1158,
		/// <summary>Static initializer must specify the <see langword="static" /> keyword.</summary>
		StaticMissingInStaticInit = 1159,
		/// <summary>The list of attributes does not apply to the current context.</summary>
		MissingConstructForAttributes = 1160,
		/// <summary>Only classes are allowed inside a <see langword="package" />.</summary>
		OnlyClassesAllowed = 1161,
		/// <summary>
		///   <see cref="T:Microsoft.JScript.Expando" /> classes should not implement <see cref="T:System.Collections.IEnumerable" />. The interface is implicitly defined on <see cref="T:Microsoft.JScript.Expando" /> classes.</summary>
		ExpandoClassShouldNotImpleEnumerable = 1162,
		/// <summary>The specified member is not CLS compliant.</summary>
		NonCLSCompliantMember = 1163,
		/// <summary>The object or member cannot be deleted.</summary>
		NotDeletable = 1164,
		/// <summary>Package name expected.</summary>
		PackageExpected = 1165,
		/// <summary>Expression has no effect.</summary>
		UselessExpression = 1169,
		/// <summary>
		///   <see langword="base" /> class already contains a member by this name.</summary>
		HidesParentMember = 1170,
		/// <summary>Cannot change visibility specification of a base method.</summary>
		CannotChangeVisibility = 1171,
		/// <summary>Method hides <see langword="abstract" /> in a <see langword="base" /> class.</summary>
		HidesAbstractInBase = 1172,
		/// <summary>A method matches a method in a base class. Must specify <see langword="override" /> or <see langword="hide" />.</summary>
		NewNotSpecifiedInMethodDeclaration = 1173,
		/// <summary>A method in a base class that is <see langword="final" /> or not <see langword="virtual" /><see langword="override" /> is ignored. Specify <see langword="hide" />.</summary>
		MethodInBaseIsNotVirtual = 1174,
		/// <summary>There is no member in a base class to <see langword="hide" />.</summary>
		NoMethodInBaseToNew = 1175,
		/// <summary>Method in base has a different return type.</summary>
		DifferentReturnTypeFromBase = 1176,
		/// <summary>The name of the field conflicts with the name of the property.</summary>
		ClashWithProperty = 1177,
		/// <summary>Cannot use <see langword="override" /> and <see langword="hide" /> together in a member declaration.</summary>
		OverrideAndHideUsedTogether = 1178,
		/// <summary>Must specify either "fast" or "versionSafe" language option.</summary>
		InvalidLanguageOption = 1179,
		/// <summary>There is no member in a base class to <see langword="override" />.</summary>
		NoMethodInBaseToOverride = 1180,
		/// <summary>Not valid for a constructor.</summary>
		NotValidForConstructor = 1181,
		/// <summary>Cannot return a value from a void function or constructor.</summary>
		CannotReturnValueFromVoidFunction = 1182,
		/// <summary>More than one method or property matches this parameter list.</summary>
		AmbiguousMatch = 1183,
		/// <summary>More than one constructor matches this parameter list.</summary>
		AmbiguousConstructorCall = 1184,
		/// <summary>Base class constructor is not accessible from this scope.</summary>
		SuperClassConstructorNotAccessible = 1185,
		/// <summary>Octal literals are deprecated.</summary>
		OctalLiteralsAreDeprecated = 1186,
		/// <summary>Variable might not be initialized.</summary>
		VariableMightBeUnitialized = 1187,
		/// <summary>It is not valid to call a base class constructor from this location.</summary>
		NotOKToCallSuper = 1188,
		/// <summary>It is not valid to use the base class in this way.</summary>
		IllegalUseOfSuper = 1189,
		/// <summary>It is slow and potentially confusing to leave a <see langword="finally" /> block this way.</summary>
		BadWayToLeaveFinally = 1190,
		/// <summary>Expected "," or invalid type declaration; write "&lt;Identifier&gt; : &lt;Type&gt;" not "&lt;Type&gt; &lt;Identifier&gt;".</summary>
		NoCommaOrTypeDefinitionError = 1191,
		/// <summary>An abstract function cannot have a body.</summary>
		AbstractWithBody = 1192,
		/// <summary>Expected "," or ")".</summary>
		NoRightParenOrComma = 1193,
		/// <summary>Expected "," or "]".</summary>
		NoRightBracketOrComma = 1194,
		/// <summary>Expected expression.</summary>
		ExpressionExpected = 1195,
		/// <summary>Unexpected ";".</summary>
		UnexpectedSemicolon = 1196,
		/// <summary>Too many errors. The file might not be a JScript file.</summary>
		TooManyTokensSkipped = 1197,
		/// <summary>Possible invalid variable declaration, <see langword="var" /> missing, or unrecognized syntax error.</summary>
		BadVariableDeclaration = 1198,
		/// <summary>Possible invalid function declaration, function missing, or unrecognized syntax error.</summary>
		BadFunctionDeclaration = 1199,
		/// <summary>Invalid property declaration. The <see langword="get" /> accessor must not have arguments and the <see langword="set" /> accessor must have one argument.</summary>
		BadPropertyDeclaration = 1200,
		/// <summary>Expression does not have an address.</summary>
		DoesNotHaveAnAddress = 1203,
		/// <summary>Not all required parameters have been supplied.</summary>
		TooFewParameters = 1204,
		/// <summary>An assignment creates an <see cref="T:Microsoft.JScript.Expando" /> property that is immediately thrown away.</summary>
		UselessAssignment = 1205,
		/// <summary>
		///   <see langword="If" /> condition cannot contain an assignment.</summary>
		SuspectAssignment = 1206,
		/// <summary>Empty statement found in <see langword="if" /> statement.</summary>
		SuspectSemicolon = 1207,
		/// <summary>The specified conversion or coercion is not possible.</summary>
		ImpossibleConversion = 1208,
		/// <summary>
		///   <see langword="final" /> and <see langword="abstract" /> cannot be used together.</summary>
		FinalPrecludesAbstract = 1209,
		/// <summary>An instance is expected.</summary>
		NeedInstance = 1210,
		/// <summary>Cannot be abstract unless class is marked as abstract.</summary>
		CannotBeAbstract = 1212,
		/// <summary>
		///   <see langword="enum" /> base type must be a primitive integral type.</summary>
		InvalidBaseTypeForEnum = 1213,
		/// <summary>It is not possible to construct an instance of an abstract class.</summary>
		CannotInstantiateAbstractClass = 1214,
		/// <summary>Assigning a JScript array to a <see cref="T:System.Array" /> may cause the array to be copied.</summary>
		ArrayMayBeCopied = 1215,
		/// <summary>Static methods cannot be abstract.</summary>
		AbstractCannotBeStatic = 1216,
		/// <summary>Static methods cannot be <see langword="final" />.</summary>
		StaticIsAlreadyFinal = 1217,
		/// <summary>Static methods cannot override base class methods.</summary>
		StaticMethodsCannotOverride = 1218,
		/// <summary>Static methods cannot hide base class methods.</summary>
		StaticMethodsCannotHide = 1219,
		/// <summary>
		///   <see cref="T:Microsoft.JScript.Expando" /> methods cannot override base class methods.</summary>
		ExpandoPrecludesOverride = 1220,
		/// <summary>A variable argument list must be of an array type.</summary>
		IllegalParamArrayAttribute = 1221,
		/// <summary>
		///   <see cref="T:Microsoft.JScript.Expando" /> methods cannot be abstract.</summary>
		ExpandoPrecludesAbstract = 1222,
		/// <summary>A function without a body should be <see langword="abstract" />.</summary>
		ShouldBeAbstract = 1223,
		/// <summary>This modifier cannot be used on an interface member.</summary>
		BadModifierInInterface = 1224,
		/// <summary>Variables cannot be declared in an interface.</summary>
		VarIllegalInInterface = 1226,
		/// <summary>Interfaces cannot be declared in an <see langword="interface" />.</summary>
		InterfaceIllegalInInterface = 1227,
		/// <summary>
		///   <see langword="enum" /> member declarations should not use the <see langword="var" /> keyword.</summary>
		NoVarInEnum = 1228,
		/// <summary>The <see langword="import" /> statement is not valid in this context.</summary>
		InvalidImport = 1229,
		/// <summary>
		///   <see langword="enum" /> definition not allowed in this context.</summary>
		EnumNotAllowed = 1230,
		/// <summary>This attribute is not valid for this type of declaration.</summary>
		InvalidCustomAttributeTarget = 1231,
		/// <summary>Package definition is not allowed in this context.</summary>
		PackageInWrongContext = 1232,
		/// <summary>A constructor cannot have a return type.</summary>
		ConstructorMayNotHaveReturnType = 1233,
		/// <summary>Only classes and packages are allowed inside a library.</summary>
		OnlyClassesAndPackagesAllowed = 1234,
		/// <summary>Invalid debug directive.</summary>
		InvalidDebugDirective = 1235,
		/// <summary>This type of attribute must be unique.</summary>
		CustomAttributeUsedMoreThanOnce = 1236,
		/// <summary>A non-static nested type can be extended only by a non-static type nested in the same class.</summary>
		NestedInstanceTypeCannotBeExtendedByStatic = 1237,
		/// <summary>An attribute that targets the property must be specified on the <see langword="get" /> accessor, if the <see langword="get" /> accessor is present.</summary>
		PropertyLevelAttributesMustBeOnGetter = 1238,
		/// <summary>A <see langword="throw" /> statement must have an argument unless it is inside the <see langword="catch" /> block of a <see langword="try" /> statement.</summary>
		BadThrow = 1239,
		/// <summary>A variable argument list must be the last argument.</summary>
		ParamListNotLast = 1240,
		/// <summary>Type could not be found. An assembly reference might be missing.</summary>
		NoSuchType = 1241,
		/// <summary>Malformed octal literal treated as decimal literal.</summary>
		BadOctalLiteral = 1242,
		/// <summary>A non-static member is not accessible from a <see langword="static" /> scope.</summary>
		InstanceNotAccessibleFromStatic = 1243,
		/// <summary>A static member must be accessed by the class name.</summary>
		StaticRequiresTypeName = 1244,
		/// <summary>A non-static member cannot be accessed with the class name.</summary>
		NonStaticWithTypeName = 1245,
		/// <summary>Type does not have such a <see langword="static" /> member.</summary>
		NoSuchStaticMember = 1246,
		/// <summary>Loop condition cannot contain a function call.</summary>
		SuspectLoopCondition = 1247,
		/// <summary>Expected assembly.</summary>
		ExpectedAssembly = 1248,
		/// <summary>Assembly custom attributes cannot be part of another construct.</summary>
		AssemblyAttributesMustBeGlobal = 1249,
		/// <summary>
		///   <see cref="T:Microsoft.JScript.Expando" /> methods cannot be static.</summary>
		ExpandoPrecludesStatic = 1250,
		/// <summary>This method has the same name, parameter types, and return type as another method in this class.</summary>
		DuplicateMethod = 1251,
		/// <summary>Class members used as constructors should be marked as <see cref="T:Microsoft.JScript.Expando" /> functions.</summary>
		NotAnExpandoFunction = 1252,
		/// <summary>Not a valid version string.</summary>
		NotValidVersionString = 1253,
		/// <summary>Executables cannot be localized; <see cref="P:System.Reflection.AssemblyCultureAttribute.Culture" /> should always be empty.</summary>
		ExecutablesCannotBeLocalized = 1254,
		/// <summary>The plus operator is a slow way to concatenate strings. Consider using <see cref="T:System.Text.StringBuilder" /> instead.</summary>
		StringConcatIsSlow = 1255,
		/// <summary>Conditional compilation directives and variables cannot be used in the debugger.</summary>
		CcInvalidInDebugger = 1256,
		/// <summary>
		///   <see cref="T:Microsoft.JScript.Expando" /> methods must be public.</summary>
		ExpandoMustBePublic = 1257,
		/// <summary>Delegates should not be explicitly constructed; simply use the method name.</summary>
		DelegatesShouldNotBeExplicitlyConstructed = 1258,
		/// <summary>A referenced assembly depends on another assembly that is not referenced or could not be found.</summary>
		ImplicitlyReferencedAssemblyNotFound = 1259,
		/// <summary>This conversion may fail at runtime.</summary>
		PossibleBadConversion = 1260,
		/// <summary>Converting a string to a number or Boolean is slow and may fail at run time.</summary>
		PossibleBadConversionFromString = 1261,
		/// <summary>This is not a valid .resources file.</summary>
		InvalidResource = 1262,
		/// <summary>The address of operator can be used only in a list of arguments.</summary>
		WrongUseOfAddressOf = 1263,
		/// <summary>The specified type is not CLS compliant.</summary>
		NonCLSCompliantType = 1264,
		/// <summary>Class member cannot be marked Common Language Specification (CLS) compliant because the class is not marked CLS compliant.</summary>
		MemberTypeCLSCompliantMismatch = 1265,
		/// <summary>Type cannot be marked CLS compliant because the assembly is not marked as CLS compliant.</summary>
		TypeAssemblyCLSCompliantMismatch = 1266,
		/// <summary>The assembly referenced is incompatible.</summary>
		IncompatibleAssemblyReference = 1267,
		/// <summary>An invalid assembly key file has been used.</summary>
		InvalidAssemblyKeyFile = 1268,
		/// <summary>The fully qualified type name is too long. It must be less than 1,024 characters.</summary>
		TypeNameTooLong = 1269,
		/// <summary>A member initializer cannot contain a function expression.</summary>
		MemberInitializerCannotContainFuncExpr = 1270,
		/// <summary>Cannot assign to <see langword="this" />.</summary>
		CantAssignThis = 5000,
		/// <summary>Expected a number.</summary>
		NumberExpected = 5001,
		/// <summary>A function was expected.</summary>
		FunctionExpected = 5002,
		/// <summary>Cannot assign to a function result.</summary>
		CannotAssignToFunctionResult = 5003,
		/// <summary>String expected.</summary>
		StringExpected = 5005,
		/// <summary>Date object expected.</summary>
		DateExpected = 5006,
		/// <summary>Expected an object.</summary>
		ObjectExpected = 5007,
		/// <summary>Invalid assignment.</summary>
		IllegalAssignment = 5008,
		/// <summary>Undefined identifier.</summary>
		UndefinedIdentifier = 5009,
		/// <summary>No Boolean value found.</summary>
		BooleanExpected = 5010,
		/// <summary>A VBArray is expected.</summary>
		VBArrayExpected = 5013,
		/// <summary>Enumerator object expected.</summary>
		EnumeratorExpected = 5015,
		/// <summary>
		///   <see cref="T:Microsoft.JScript.RegExpObject" /> object expected.</summary>
		RegExpExpected = 5016,
		/// <summary>Syntax error in regular expression.</summary>
		RegExpSyntax = 5017,
		/// <summary>Exception thrown and not caught.</summary>
		UncaughtException = 5022,
		/// <summary>This function does not have a valid prototype object.</summary>
		InvalidPrototype = 5023,
		/// <summary>The URI to be encoded contains an invalid character.</summary>
		URIEncodeError = 5024,
		/// <summary>The URI to be decoded is not a valid encoding.</summary>
		URIDecodeError = 5025,
		/// <summary>The number of fractional digits is out of range.</summary>
		FractionOutOfRange = 5026,
		/// <summary>The precision is out of range.</summary>
		PrecisionOutOfRange = 5027,
		/// <summary>Array length must be a finite positive integer.</summary>
		ArrayLengthConstructIncorrect = 5029,
		/// <summary>Array length must be assigned a finite positive number.</summary>
		ArrayLengthAssignIncorrect = 5030,
		/// <summary>A "|" is not an array object. Array object expected.</summary>
		NeedArrayObject = 5031,
		/// <summary>No such constructor.</summary>
		NoConstructor = 5032,
		/// <summary>An <see cref="T:Microsoft.JScript.Eval" /> cannot be called by an alias.</summary>
		IllegalEval = 5033,
		/// <summary>Not yet implemented.</summary>
		NotYetImplemented = 5034,
		/// <summary>Cannot provide null or empty named parameter name.</summary>
		MustProvideNameForNamedParameter = 5035,
		/// <summary>Duplicate named parameter.</summary>
		DuplicateNamedParameter = 5036,
		/// <summary>The specified named parameter name is not one of the formal parameters.</summary>
		MissingNameParameter = 5037,
		/// <summary>Too few arguments specified. The number of named parameter names cannot exceed the number of arguments passed in.</summary>
		MoreNamedParametersThanArguments = 5038,
		/// <summary>The expression cannot be evaluated in the debugger.</summary>
		NonSupportedInDebugger = 5039,
		/// <summary>Cannot assign to read-only field or property.</summary>
		AssignmentToReadOnly = 5040,
		/// <summary>The property is write-only.</summary>
		WriteOnlyProperty = 5041,
		/// <summary>The number of indices does not match the dimension of the array.</summary>
		IncorrectNumberOfIndices = 5042,
		/// <summary>Methods with <see langword="ref" /> parameters cannot be called in the debugger.</summary>
		RefParamsNonSupportedInDebugger = 5043,
		/// <summary>The <see cref="M:System.Security.CodeAccessPermission.Deny" />, <see cref="M:System.Security.CodeAccessPermission.PermitOnly" />, and <see cref="M:System.Security.CodeAccessPermission.Assert" /> security methods cannot be called using late binding.</summary>
		CannotCallSecurityMethodLateBound = 5044,
		/// <summary>JScript does not support static security attributes.</summary>
		CannotUseStaticSecurityAttribute = 5045,
		/// <summary>A target threw a non-CLS exception.</summary>
		NonClsException = 5046,
		/// <summary>Function evaluation was aborted.</summary>
		FuncEvalAborted = 6000,
		/// <summary>Function evaluation timed out.</summary>
		FuncEvalTimedout = 6001,
		/// <summary>Function evaluation failed. The thread is suspended.</summary>
		FuncEvalThreadSuspended = 6002,
		/// <summary>Function evaluation failed. The thread is sleeping, waiting for an object, or waiting for another thread to finish.</summary>
		FuncEvalThreadSleepWaitJoin = 6003,
		/// <summary>Function evaluation failed. The thread can contain incorrect data.</summary>
		FuncEvalBadThreadState = 6004,
		/// <summary>Function evaluation failed and the thread has not started.</summary>
		FuncEvalBadThreadNotStarted = 6005,
		/// <summary>Function evaluation aborted. To turn on property evaluation, click Options on the Tools menu and then select the Debugging in the tree view.</summary>
		NoFuncEvalAllowed = 6006,
		/// <summary>Function evaluation cannot be done when stopped at this point in the program.</summary>
		FuncEvalBadLocation = 6007,
		/// <summary>Cannot call a Web method in the debugger.</summary>
		FuncEvalWebMethod = 6008,
		/// <summary>A static variable is not available.</summary>
		StaticVarNotAvailable = 6009,
		/// <summary>The type object for this type is not available.</summary>
		TypeObjectNotAvailable = 6010,
		/// <summary>Exception from HRESULT.</summary>
		ExceptionFromHResult = 6011,
		/// <summary>The expression causes side effects and will not be evaluated.</summary>
		SideEffectsDisallowed = 6012
	}
	internal sealed class JSExpandoField : JSField
	{
		private object value;

		private string name;

		public override FieldAttributes Attributes => FieldAttributes.Public | FieldAttributes.Static;

		public override string Name => name;

		internal JSExpandoField(string name)
			: this(name, null)
		{
		}

		internal JSExpandoField(string name, object value)
		{
			this.value = value;
			this.name = name;
		}

		public override object GetValue(object obj)
		{
			return value;
		}

		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo locale)
		{
			this.value = value;
		}
	}
	internal sealed class JSExpandoIndexerMethod : JSMethod
	{
		private ClassScope classScope;

		private bool isGetter;

		private MethodInfo token;

		private ParameterInfo[] GetterParams;

		private ParameterInfo[] SetterParams;

		public override MethodAttributes Attributes => MethodAttributes.Public;

		public override Type DeclaringType => classScope.GetTypeBuilderOrEnumBuilder();

		public override string Name
		{
			get
			{
				if (isGetter)
				{
					return "get_Item";
				}
				return "set_Item";
			}
		}

		public override Type ReturnType
		{
			get
			{
				if (isGetter)
				{
					return Typeob.Object;
				}
				return Typeob.Void;
			}
		}

		internal JSExpandoIndexerMethod(ClassScope classScope, bool isGetter)
			: base(null)
		{
			this.isGetter = isGetter;
			this.classScope = classScope;
			GetterParams = new ParameterInfo[1]
			{
				new ParameterDeclaration(Typeob.String, "field")
			};
			SetterParams = new ParameterInfo[2]
			{
				new ParameterDeclaration(Typeob.String, "field"),
				new ParameterDeclaration(Typeob.Object, "value")
			};
		}

		internal override object Construct(object[] args)
		{
			throw new JScriptException(JSError.InvalidCall);
		}

		public override ParameterInfo[] GetParameters()
		{
			if (isGetter)
			{
				return GetterParams;
			}
			return SetterParams;
		}

		internal override MethodInfo GetMethodInfo(CompilerGlobals compilerGlobals)
		{
			if (isGetter)
			{
				if (token == null)
				{
					token = classScope.owner.GetExpandoIndexerGetter();
				}
			}
			else if (token == null)
			{
				token = classScope.owner.GetExpandoIndexerSetter();
			}
			return token;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object Invoke(object obj, object thisob, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			throw new JScriptException(JSError.InvalidCall);
		}
	}
	/// <summary>Supports all fields in JScript. This is the base class for all fields that are defined by JScript. This class belongs to the name binding category.</summary>
	public abstract class JSField : FieldInfo
	{
		/// <summary>Gets the attributes that are associated with this field.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.FieldAttributes.PrivateScope" />
		/// </returns>
		public override FieldAttributes Attributes => FieldAttributes.PrivateScope;

		/// <summary>Gets the type that declares this field.</summary>
		/// <returns>null in all cases.</returns>
		public override Type DeclaringType => null;

		/// <summary>Gets a handle to the internal metadata representation of this field.</summary>
		/// <returns>A handle to the internal metadata representation of this field.</returns>
		public override RuntimeFieldHandle FieldHandle => ((FieldInfo)GetMetaData()).FieldHandle;

		/// <summary>Gets the type of this field.</summary>
		/// <returns>The type of <see cref="T:System.Object" />.</returns>
		public override Type FieldType => Typeob.Object;

		/// <summary>Gets the type of member that this field is. Identifies the type of class derived from <see cref="T:System.Reflection.MemberInfo" /> that this class derives from.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MemberTypes.Field" />, because this class derives from <see cref="T:System.Reflection.FieldInfo" />.</returns>
		public override MemberTypes MemberType => MemberTypes.Field;

		/// <summary>Gets the name of this field.</summary>
		/// <returns>The name of this field.</returns>
		public override string Name => "";

		/// <summary>Gets the class object that was used to obtain this instance through reflection.</summary>
		/// <returns>The type that declares this method.</returns>
		public override Type ReflectedType => DeclaringType;

		/// <summary>Returns an array that contains the custom attributes that are attached to this field, searching only for attributes of the specified type.</summary>
		/// <param name="t">The type of attribute to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects that has zero elements.</returns>
		public override object[] GetCustomAttributes(Type t, bool inherit)
		{
			return new FieldInfo[0];
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this field.</summary>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects that has zero elements.</returns>
		public override object[] GetCustomAttributes(bool inherit)
		{
			return new FieldInfo[0];
		}

		internal virtual object GetMetaData()
		{
			throw new JScriptException(JSError.InternalError);
		}

		internal virtual string GetClassFullName()
		{
			throw new JScriptException(JSError.InternalError);
		}

		internal virtual PackageScope GetPackage()
		{
			throw new JScriptException(JSError.InternalError);
		}

		/// <summary>Determines whether the specified attribute type is attached to this field.</summary>
		/// <param name="type">The attribute type to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>
		///   <see langword="false" /> in all cases.</returns>
		public override bool IsDefined(Type type, bool inherit)
		{
			return false;
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JSField" /> class.</summary>
		protected JSField()
		{
		}
	}
	/// <summary>Wraps a <see cref="T:System.Reflection.FieldInfo" /> object.</summary>
	public sealed class JSFieldInfo : FieldInfo
	{
		internal FieldInfo field;

		private FieldAttributes attributes;

		private Type declaringType;

		private Type fieldType;

		private FieldAccessor fieldAccessor;

		/// <summary>Gets the attributes that are associated with this field.</summary>
		/// <returns>A bitwise combination of the enumeration values.</returns>
		public override FieldAttributes Attributes => attributes;

		/// <summary>Gets the type that declares this field.</summary>
		/// <returns>The <see langword="Type" /> object for the class that declares this member.</returns>
		public override Type DeclaringType
		{
			get
			{
				Type type = declaringType;
				if (type == null)
				{
					type = (declaringType = field.DeclaringType);
				}
				return type;
			}
		}

		/// <summary>Gets a handle to the internal metadata representation of this field.</summary>
		/// <returns>A handle to the internal metadata representation of this field.</returns>
		public override RuntimeFieldHandle FieldHandle => field.FieldHandle;

		/// <summary>Gets the type of this field.</summary>
		/// <returns>The type of this field.</returns>
		public override Type FieldType
		{
			get
			{
				Type type = fieldType;
				if (type == null)
				{
					type = (fieldType = field.FieldType);
				}
				return type;
			}
		}

		/// <summary>Gets the type of member that this field is. Identifies the type of class derived from <see cref="T:System.Reflection.MemberInfo" /> that this class derives from.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MemberTypes.Field" />, because this class derives from <see cref="T:System.Reflection.FieldInfo" />.</returns>
		public override MemberTypes MemberType => MemberTypes.Field;

		/// <summary>Gets the name of this field.</summary>
		/// <returns>The name of this field.</returns>
		public override string Name => field.Name;

		/// <summary>Gets the class object that was used to obtain this instance through reflection.</summary>
		/// <returns>The <see langword="Type" /> object that was used to obtain this method.</returns>
		public override Type ReflectedType => field.ReflectedType;

		internal JSFieldInfo(FieldInfo field)
		{
			this.field = field;
			attributes = field.Attributes;
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this field, searching only for attributes of the specified type.</summary>
		/// <param name="t">The type of attribute to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects that has zero elements.</returns>
		public override object[] GetCustomAttributes(Type t, bool inherit)
		{
			return new FieldInfo[0];
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this field.</summary>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects that has zero elements.</returns>
		public override object[] GetCustomAttributes(bool inherit)
		{
			return new FieldInfo[0];
		}

		/// <summary>Gets the value of the field.</summary>
		/// <param name="obj">The object whose field value will be returned.</param>
		/// <returns>The value of the field.</returns>
		public override object GetValue(object obj)
		{
			FieldAccessor fieldAccessor = this.fieldAccessor;
			if (fieldAccessor == null)
			{
				fieldAccessor = (this.fieldAccessor = FieldAccessor.GetAccessorFor(TypeReferences.ToExecutionContext(field)));
			}
			return fieldAccessor.GetValue(obj);
		}

		/// <summary>Determines whether the specified attribute type is attached to this field.</summary>
		/// <param name="type">The attribute type to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>
		///   <see langword="false" /> in all cases.</returns>
		public override bool IsDefined(Type type, bool inherit)
		{
			return false;
		}

		/// <summary>Sets the value of the field, using the specified value.</summary>
		/// <param name="obj">The object whose field value will be set.</param>
		/// <param name="value">The value to assign to the field.</param>
		public new void SetValue(object obj, object value)
		{
			if ((attributes & FieldAttributes.InitOnly) != 0)
			{
				throw new JScriptException(JSError.AssignmentToReadOnly);
			}
			SetValue(obj, value, BindingFlags.SetField, null, null);
		}

		/// <summary>Sets the value of the field, using the specified value, culture, and binding information.</summary>
		/// <param name="obj">The object whose field value will be set.</param>
		/// <param name="value">The value to assign to the field.</param>
		/// <param name="invokeAttr">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">A set of properties that enables the binding, coercion of argument types, and invocation of members through reflection.</param>
		/// <param name="culture">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
		{
			FieldAccessor fieldAccessor = this.fieldAccessor;
			if (fieldAccessor == null)
			{
				fieldAccessor = (this.fieldAccessor = FieldAccessor.GetAccessorFor(field));
			}
			fieldAccessor.SetValue(obj, value);
		}
	}
	internal sealed class JSFieldMethod : JSMethod
	{
		internal FieldInfo field;

		internal FunctionObject func;

		private static readonly ParameterInfo[] EmptyParams = new ParameterInfo[0];

		public override MethodAttributes Attributes
		{
			get
			{
				if (func != null)
				{
					return func.attributes;
				}
				if (field.IsPublic)
				{
					return MethodAttributes.Public;
				}
				if (field.IsFamily)
				{
					return MethodAttributes.Family;
				}
				if (field.IsAssembly)
				{
					return MethodAttributes.Assembly;
				}
				return MethodAttributes.Private;
			}
		}

		public override Type DeclaringType
		{
			get
			{
				if (func != null)
				{
					return Convert.ToType(func.enclosing_scope);
				}
				return Typeob.Object;
			}
		}

		public override string Name => field.Name;

		public override Type ReturnType
		{
			get
			{
				if (func != null)
				{
					return Convert.ToType(func.ReturnType(null));
				}
				return Typeob.Object;
			}
		}

		internal JSFieldMethod(FieldInfo field, object obj)
			: base(obj)
		{
			this.field = field;
			func = null;
			if (field.IsLiteral)
			{
				object obj2 = ((field is JSVariableField) ? ((JSVariableField)field).value : field.GetValue(null));
				if (obj2 is FunctionObject)
				{
					func = (FunctionObject)obj2;
				}
			}
		}

		internal override object Construct(object[] args)
		{
			return LateBinding.CallValue(field.GetValue(obj), args, construct: true, brackets: false, ((ScriptObject)obj).engine, null, JSBinder.ob, null, null);
		}

		internal ScriptObject EnclosingScope()
		{
			if (func != null)
			{
				return func.enclosing_scope;
			}
			return null;
		}

		public override object[] GetCustomAttributes(bool inherit)
		{
			if (func != null)
			{
				CustomAttributeList customAttributes = func.customAttributes;
				if (customAttributes != null)
				{
					return (object[])customAttributes.Evaluate(inherit);
				}
			}
			return new object[0];
		}

		public override ParameterInfo[] GetParameters()
		{
			if (func != null)
			{
				return func.parameter_declarations;
			}
			return EmptyParams;
		}

		internal override MethodInfo GetMethodInfo(CompilerGlobals compilerGlobals)
		{
			return func.GetMethodInfo(compilerGlobals);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object Invoke(object obj, object thisob, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			bool construct = (options & BindingFlags.CreateInstance) != 0;
			bool brackets = (options & BindingFlags.GetProperty) != 0 && (options & BindingFlags.InvokeMethod) == 0;
			object value = func;
			if (value == null)
			{
				value = field.GetValue(base.obj);
			}
			FunctionObject functionObject = value as FunctionObject;
			if (obj is JSObject jSObject && functionObject != null && functionObject.isMethod && (functionObject.attributes & MethodAttributes.Virtual) != 0 && jSObject.GetParent() != functionObject.enclosing_scope && ((ClassScope)functionObject.enclosing_scope).HasInstance(jSObject))
			{
				LateBinding lateBinding = new LateBinding(functionObject.name);
				lateBinding.obj = jSObject;
				return lateBinding.Call(parameters, construct, brackets, ((ScriptObject)base.obj).engine);
			}
			return LateBinding.CallValue(value, parameters, construct, brackets, ((ScriptObject)base.obj).engine, thisob, binder, culture, null);
		}

		internal bool IsAccessibleFrom(ScriptObject scope)
		{
			return ((JSMemberField)field).IsAccessibleFrom(scope);
		}

		internal IReflect ReturnIR()
		{
			if (func != null)
			{
				return func.ReturnType(null);
			}
			return Typeob.Object;
		}
	}
	/// <summary>Used with <see cref="T:Microsoft.JScript.JSFunctionAttributeEnum" /> to annotate the calling conventions of methods and constructors that are generated by the JScript compiler.</summary>
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method)]
	public class JSFunctionAttribute : Attribute
	{
		internal JSFunctionAttributeEnum attributeValue;

		internal JSBuiltin builtinFunction;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JSFunctionAttribute" /> class, using the specified calling conventions.</summary>
		/// <param name="value">The calling conventions of the method or constructor.</param>
		public JSFunctionAttribute(JSFunctionAttributeEnum value)
		{
			attributeValue = value;
			builtinFunction = JSBuiltin.None;
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JSFunctionAttribute" /> class, using the specified calling conventions. The attribute identifies the specified built-in function.</summary>
		/// <param name="value">The calling conventions of the method or constructor.</param>
		/// <param name="builtinFunction">The built-in function that this attribute identifies.</param>
		public JSFunctionAttribute(JSFunctionAttributeEnum value, JSBuiltin builtinFunction)
		{
			attributeValue = value;
			this.builtinFunction = builtinFunction;
		}

		/// <summary>Gets the calling conventions of the method or constructor.</summary>
		/// <returns>The calling conventions of the method or constructor.</returns>
		public JSFunctionAttributeEnum GetAttributeValue()
		{
			return attributeValue;
		}
	}
	/// <summary>Specifies the calling conventions of functions that are generated by the JScript compiler. Used with the <see cref="T:Microsoft.JScript.JSFunctionAttribute" /> custom attribute.</summary>
	[Guid("BA5ED019-F669-3C35-93AC-3ABF776B62B3")]
	[ComVisible(true)]
	[Flags]
	public enum JSFunctionAttributeEnum
	{
		/// <summary>Specifies a regular .NET Framework method with no special calling conventions. Typically not used as in this case the JSFunctionAttribute is not emitted.</summary>
		None = 0,
		/// <summary>Specifies that the third parameter of the function is of type <see langword="Object" />. The caller should pass in an object that implements the JScript arguments object, typically an instance of <see cref="T:Microsoft.JScript.ArgumentsObject" />. The JScript runtime assumes that if <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.HasArguments" /> is set, then <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.HasStackFrame" /> and <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.HasThisObject" /> are also set.</summary>
		HasArguments = 1,
		/// <summary>Specifies that the first parameter of the function is of type <see langword="Object" /> and that it is usually named <paramref name="thisob" />. The caller should pass in an instance of the object that the function acts on.</summary>
		HasThisObject = 2,
		/// <summary>Specifies that the function is nested in another JScript function.</summary>
		IsNested = 4,
		/// <summary>Specifies that the function copies its local variables into a stack frame object maintained by the JScript runtime before making a call out. It copies the variables back from the stack frame object to its locals when control is returned to the function. This flag is set on functions that contain nested functions that access the parent function's locals.</summary>
		HasStackFrame = 8,
		/// <summary>Specifies that the function takes a variable number of arguments. The last parameter is of type array of <see langword="Object" />, which holds any arguments that are explicitly specified.</summary>
		HasVarArgs = 0x10,
		/// <summary>Specifies that the second parameter of the function is of type <see cref="T:Microsoft.JScript.Vsa.VsaEngine" />. The caller should pass in an instance of <see cref="T:Microsoft.JScript.Vsa.VsaEngine" /> from which the function can retrieve the runtime infrastructure. The JScript runtime assumes that if <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.HasEngine" /> is set then <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.HasThisObject" /> is also set.</summary>
		HasEngine = 0x20,
		/// <summary>Specifies that the function is a constructor function for a prototype-based object. For more information, see Prototype-based Objects and expando Modifier.</summary>
		IsExpandoMethod = 0x40,
		/// <summary>Specifies that the function is a constructor for a nested instance class. The first parameter of the function an instance of the parent class.</summary>
		IsInstanceNestedClassConstructor = 0x80,
		/// <summary>Specifies the aggregate of <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.HasArguments" />, <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.HasEngine" />, and <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.HasThisObject" />.</summary>
		ClassicFunction = 0x23,
		/// <summary>Specifies the aggregate of <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.HasStackFrame" />, <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.IsNested" />, and <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.HasEngine" />.</summary>
		NestedFunction = 0x2C,
		/// <summary>Specifies the aggregate of <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.ClassicFunction" /> and <see cref="F:Microsoft.JScript.JSFunctionAttributeEnum.NestedFunction" />.</summary>
		ClassicNestedFunction = 0x2F
	}
	internal sealed class JSGlobalField : JSVariableField
	{
		internal FieldInfo ILField;

		internal JSGlobalField(ScriptObject obj, string name, object value, FieldAttributes attributeFlags)
			: base(name, obj, attributeFlags)
		{
			base.value = value;
			ILField = null;
		}

		public override object GetValue(object obj)
		{
			if (ILField == null)
			{
				return value;
			}
			return ILField.GetValue(null);
		}

		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
		{
			if (ILField != null)
			{
				ILField.SetValue(null, value, invokeAttr, binder, culture);
			}
			else if ((base.IsLiteral || base.IsInitOnly) && !(base.value is Missing))
			{
				if (!(base.value is FunctionObject) || !(value is FunctionObject) || !Name.Equals(((FunctionObject)value).name))
				{
					throw new JScriptException(JSError.AssignmentToReadOnly);
				}
				base.value = value;
			}
			else if (type != null)
			{
				base.value = Convert.Coerce(value, type);
			}
			else
			{
				base.value = value;
			}
		}
	}
	internal class JSInProcCompiler
	{
		private int codeItemCounter;

		private string debugCommandLine;

		private void AddAssemblyReference(IJSVsaEngine engine, string filename)
		{
			IJSVsaReferenceItem iJSVsaReferenceItem = (IJSVsaReferenceItem)engine.Items.CreateItem(filename, JSVsaItemType.Reference, JSVsaItemFlag.None);
			iJSVsaReferenceItem.AssemblyName = filename;
		}

		private void AddDefinition(string def, Hashtable definitions, VsaEngine engine)
		{
			int num = def.IndexOf("=");
			object obj = null;
			string text;
			if (num == -1)
			{
				text = def.Trim();
				obj = true;
			}
			else
			{
				text = def.Substring(0, num).Trim();
				string text2 = def.Substring(num + 1).Trim();
				if (string.Compare(text2, "true", StringComparison.OrdinalIgnoreCase) == 0)
				{
					obj = true;
				}
				else if (string.Compare(text2, "false", StringComparison.OrdinalIgnoreCase) == 0)
				{
					obj = false;
				}
				else
				{
					try
					{
						obj = int.Parse(text2, CultureInfo.InvariantCulture);
					}
					catch
					{
						throw new CmdLineException(CmdLineError.InvalidDefinition, text, engine.ErrorCultureInfo);
					}
				}
			}
			if (text.Length == 0)
			{
				throw new CmdLineException(CmdLineError.MissingDefineArgument, engine.ErrorCultureInfo);
			}
			definitions[text] = obj;
		}

		private void AddResourceFile(ResInfo resinfo, Hashtable resources, Hashtable resourceFiles, VsaEngine engine)
		{
			if (!File.Exists(resinfo.fullpath))
			{
				throw new CmdLineException(CmdLineError.ManagedResourceNotFound, resinfo.filename, engine.ErrorCultureInfo);
			}
			if (resourceFiles[resinfo.fullpath] != null)
			{
				throw new CmdLineException(CmdLineError.DuplicateResourceFile, resinfo.filename, engine.ErrorCultureInfo);
			}
			if (resources[resinfo.name] != null)
			{
				throw new CmdLineException(CmdLineError.DuplicateResourceName, resinfo.name, engine.ErrorCultureInfo);
			}
			resources[resinfo.name] = resinfo;
			resourceFiles[resinfo.fullpath] = resinfo;
		}

		private void AddSourceFile(VsaEngine engine, string filename)
		{
			string name = "$SourceFile_" + codeItemCounter++;
			IJSVsaCodeItem iJSVsaCodeItem = (IJSVsaCodeItem)engine.Items.CreateItem(name, JSVsaItemType.Code, JSVsaItemFlag.None);
			iJSVsaCodeItem.SetOption("codebase", filename);
			iJSVsaCodeItem.SourceText = ReadFile(filename, engine);
		}

		internal int Compile(CompilerParameters options, string partialCmdLine, string[] sourceFiles, string outputFile)
		{
			StreamWriter streamWriter = null;
			int result = 0;
			try
			{
				streamWriter = new StreamWriter(outputFile);
				streamWriter.AutoFlush = true;
				if (options.IncludeDebugInformation)
				{
					PrintOptions(streamWriter, options);
					debugCommandLine = partialCmdLine;
				}
				VsaEngine vsaEngine = null;
				try
				{
					vsaEngine = CreateAndInitEngine(options, sourceFiles, outputFile, streamWriter);
				}
				catch (CmdLineException ex)
				{
					streamWriter.WriteLine(ex.Message);
					result = 10;
				}
				catch (Exception ex2)
				{
					streamWriter.WriteLine("fatal error JS2999: " + ex2);
					result = 10;
				}
				if (vsaEngine == null)
				{
					return result;
				}
				if (options.IncludeDebugInformation)
				{
					StringBuilder stringBuilder = new StringBuilder(debugCommandLine);
					foreach (string value in sourceFiles)
					{
						stringBuilder.Append(" \"");
						stringBuilder.Append(value);
						stringBuilder.Append("\"");
					}
					debugCommandLine = stringBuilder.ToString();
					string text = options.TempFiles.AddExtension("cmdline");
					StreamWriter streamWriter2 = null;
					try
					{
						streamWriter2 = new StreamWriter(text);
						streamWriter2.WriteLine(debugCommandLine);
						streamWriter2.Flush();
					}
					finally
					{
						streamWriter2?.Close();
					}
					StringBuilder stringBuilder2 = new StringBuilder();
					stringBuilder2.Append(Environment.NewLine);
					stringBuilder2.Append(JScriptException.Localize("CmdLine helper", CultureInfo.CurrentUICulture));
					stringBuilder2.Append(":");
					stringBuilder2.Append(Environment.NewLine);
					stringBuilder2.Append("    ");
					stringBuilder2.Append(options.TempFiles.TempDir);
					stringBuilder2.Append("> jsc.exe @\"");
					stringBuilder2.Append(text);
					stringBuilder2.Append("\"");
					stringBuilder2.Append(Environment.NewLine);
					streamWriter.WriteLine(stringBuilder2.ToString());
					PrintBanner(vsaEngine, streamWriter);
				}
				try
				{
					if (!vsaEngine.Compile())
					{
						return 10;
					}
					return 0;
				}
				catch (JSVsaException ex3)
				{
					if (ex3.ErrorCode == JSVsaError.AssemblyExpected)
					{
						if (ex3.InnerException != null && ex3.InnerException is BadImageFormatException)
						{
							CmdLineException ex4 = new CmdLineException(CmdLineError.InvalidAssembly, ex3.Message, vsaEngine.ErrorCultureInfo);
							streamWriter.WriteLine(ex4.Message);
						}
						else if (ex3.InnerException != null && ex3.InnerException is FileNotFoundException)
						{
							CmdLineException ex5 = new CmdLineException(CmdLineError.AssemblyNotFound, ex3.Message, vsaEngine.ErrorCultureInfo);
							streamWriter.WriteLine(ex5.Message);
						}
						else
						{
							CmdLineException ex6 = new CmdLineException(CmdLineError.InvalidAssembly, vsaEngine.ErrorCultureInfo);
							streamWriter.WriteLine(ex6.Message);
						}
					}
					else if (ex3.ErrorCode == JSVsaError.SaveCompiledStateFailed)
					{
						CmdLineException ex7 = new CmdLineException(CmdLineError.ErrorSavingCompiledState, ex3.Message, vsaEngine.ErrorCultureInfo);
						streamWriter.WriteLine(ex7.Message);
					}
					else
					{
						streamWriter.WriteLine(JScriptException.Localize("INTERNAL COMPILER ERROR", vsaEngine.ErrorCultureInfo));
						streamWriter.WriteLine(ex3);
					}
					return 10;
				}
				catch (Exception value2)
				{
					streamWriter.WriteLine(JScriptException.Localize("INTERNAL COMPILER ERROR", vsaEngine.ErrorCultureInfo));
					streamWriter.WriteLine(value2);
					return 10;
				}
			}
			finally
			{
				streamWriter?.Close();
			}
		}

		private VsaEngine CreateAndInitEngine(CompilerParameters options, string[] sourceFiles, string outputFile, TextWriter output)
		{
			VsaEngine vsaEngine = new VsaEngine(fast: true);
			VsaSite vsaSite = new VsaSite(output);
			vsaEngine.InitVsaEngine("JSCodeGenerator://Microsoft.JScript.Vsa.VsaEngine", vsaSite);
			ValidateOptions(options, vsaEngine);
			vsaEngine.GenerateDebugInfo = options.IncludeDebugInformation;
			vsaEngine.SetOption("referenceLoaderAPI", "LoadFile");
			vsaEngine.SetOption("fast", true);
			vsaEngine.SetOption("print", false);
			vsaEngine.SetOption("VersionSafe", false);
			vsaEngine.SetOption("output", options.OutputAssembly);
			if (options.GenerateExecutable)
			{
				vsaEngine.SetOption("PEFileKind", PEFileKinds.ConsoleApplication);
			}
			else
			{
				vsaEngine.SetOption("PEFileKind", PEFileKinds.Dll);
			}
			vsaSite.treatWarningsAsErrors = options.TreatWarningsAsErrors;
			vsaEngine.SetOption("warnaserror", options.TreatWarningsAsErrors);
			vsaSite.warningLevel = options.WarningLevel;
			vsaEngine.SetOption("WarningLevel", options.WarningLevel);
			if (options.Win32Resource != null && options.Win32Resource.Length > 0)
			{
				vsaEngine.SetOption("win32resource", options.Win32Resource);
			}
			bool flag = false;
			StringEnumerator enumerator = options.ReferencedAssemblies.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					string current = enumerator.Current;
					if (string.Compare(Path.GetFileName(current), "mscorlib.dll", StringComparison.OrdinalIgnoreCase) == 0)
					{
						flag = true;
					}
					AddAssemblyReference(vsaEngine, current);
				}
			}
			finally
			{
				if (enumerator is IDisposable disposable)
				{
					disposable.Dispose();
				}
			}
			if (!flag)
			{
				AddAssemblyReference(vsaEngine, "mscorlib.dll");
			}
			StringCollection args = SplitCmdLineArguments(options.CompilerOptions);
			ParseCompilerOptions(vsaEngine, args, output, options.GenerateExecutable);
			for (int i = 0; i < sourceFiles.Length; i++)
			{
				AddSourceFile(vsaEngine, sourceFiles[i]);
			}
			return vsaEngine;
		}

		private void GetAllDefines(string definitionList, Hashtable defines, VsaEngine engine)
		{
			int num = 0;
			int argumentSeparatorIndex;
			do
			{
				argumentSeparatorIndex = GetArgumentSeparatorIndex(definitionList, num);
				string def = ((argumentSeparatorIndex != -1) ? definitionList.Substring(num, argumentSeparatorIndex - num) : definitionList.Substring(num));
				AddDefinition(def, defines, engine);
				num = argumentSeparatorIndex + 1;
			}
			while (argumentSeparatorIndex > -1);
		}

		private int GetArgumentSeparatorIndex(string argList, int startIndex)
		{
			int num = argList.IndexOf(",", startIndex);
			int num2 = argList.IndexOf(";", startIndex);
			if (num == -1)
			{
				return num2;
			}
			if (num2 == -1)
			{
				return num;
			}
			if (num < num2)
			{
				return num;
			}
			return num2;
		}

		private void ParseCompilerOptions(VsaEngine engine, StringCollection args, TextWriter output, bool generateExe)
		{
			string text = Environment.GetEnvironmentVariable("LIB");
			bool flag = false;
			Hashtable hashtable = new Hashtable(10);
			Hashtable resources = new Hashtable(10);
			Hashtable resourceFiles = new Hashtable(10);
			bool flag2 = false;
			StringBuilder stringBuilder = null;
			if (debugCommandLine != null)
			{
				stringBuilder = new StringBuilder(debugCommandLine);
			}
			string text2 = ((Path.DirectorySeparatorChar == '/') ? "-" : "/");
			int i = 0;
			for (int count = args.Count; i < count; i++)
			{
				string text3 = args[i];
				if (text3 == null || text3.Length == 0)
				{
					continue;
				}
				if (text3[0] == '@')
				{
					throw new CmdLineException(CmdLineError.InvalidForCompilerOptions, "@<filename>", engine.ErrorCultureInfo);
				}
				if ('-' != text3[0] && ('/' != text3[0] || Path.DirectorySeparatorChar == '/'))
				{
					break;
				}
				string text4 = text3.Substring(1);
				if (text4.Length > 0)
				{
					switch (text4[0])
					{
					case '?':
						throw new CmdLineException(CmdLineError.InvalidForCompilerOptions, "/?", engine.ErrorCultureInfo);
					case 'A':
					case 'a':
					{
						object obj = CmdLineOptionParser.IsBooleanOption(text4, "autoref");
						if (obj != null)
						{
							engine.SetOption("autoref", obj);
							if (stringBuilder != null)
							{
								stringBuilder.Append(text3);
								stringBuilder.Append(" ");
							}
							continue;
						}
						break;
					}
					case 'C':
					case 'c':
					{
						object obj = CmdLineOptionParser.IsArgumentOption(text4, "codepage");
						if (obj != null)
						{
							throw new CmdLineException(CmdLineError.InvalidForCompilerOptions, "/codepage:<id>", engine.ErrorCultureInfo);
						}
						break;
					}
					case 'D':
					case 'd':
					{
						object obj = CmdLineOptionParser.IsBooleanOption(text4, "debug");
						if (obj != null)
						{
							engine.GenerateDebugInfo = (bool)obj;
							if (stringBuilder != null)
							{
								stringBuilder.Append(text3);
								stringBuilder.Append(" ");
							}
							continue;
						}
						obj = CmdLineOptionParser.IsArgumentOption(text4, "d", "define");
						if (obj != null)
						{
							GetAllDefines((string)obj, hashtable, engine);
							if (stringBuilder != null)
							{
								stringBuilder.Append(text2 + "d:\"");
								stringBuilder.Append((string)obj);
								stringBuilder.Append("\" ");
							}
							continue;
						}
						break;
					}
					case 'F':
					case 'f':
					{
						object obj = CmdLineOptionParser.IsBooleanOption(text4, "fast");
						if (obj != null)
						{
							engine.SetOption("fast", obj);
							if (stringBuilder != null)
							{
								stringBuilder.Append(text3);
								stringBuilder.Append(" ");
							}
							continue;
						}
						break;
					}
					case 'L':
					case 'l':
					{
						object obj = CmdLineOptionParser.IsArgumentOption(text4, "lcid");
						if (obj != null)
						{
							if (((string)obj).Length == 0)
							{
								throw new CmdLineException(CmdLineError.NoLocaleID, text3, engine.ErrorCultureInfo);
							}
							try
							{
								engine.LCID = int.Parse((string)obj, CultureInfo.InvariantCulture);
							}
							catch
							{
								throw new CmdLineException(CmdLineError.InvalidLocaleID, (string)obj, engine.ErrorCultureInfo);
							}
							continue;
						}
						obj = CmdLineOptionParser.IsArgumentOption(text4, "lib");
						if (obj != null)
						{
							string text5 = (string)obj;
							if (text5.Length == 0)
							{
								throw new CmdLineException(CmdLineError.MissingLibArgument, engine.ErrorCultureInfo);
							}
							text5 = text5.Replace(',', Path.PathSeparator);
							text = text5 + Path.PathSeparator + text;
							if (stringBuilder != null)
							{
								stringBuilder.Append(text2 + "lib:\"");
								stringBuilder.Append((string)obj);
								stringBuilder.Append("\" ");
							}
							continue;
						}
						obj = CmdLineOptionParser.IsArgumentOption(text4, "linkres", "linkresource");
						if (obj != null)
						{
							try
							{
								ResInfo resinfo = new ResInfo((string)obj, isLinked: true);
								AddResourceFile(resinfo, resources, resourceFiles, engine);
							}
							catch (CmdLineException)
							{
								throw;
							}
							catch
							{
								throw new CmdLineException(CmdLineError.ManagedResourceNotFound, engine.ErrorCultureInfo);
							}
							continue;
						}
						break;
					}
					case 'N':
					case 'n':
					{
						object obj = CmdLineOptionParser.IsBooleanOption(text4, "nologo");
						if (obj != null)
						{
							throw new CmdLineException(CmdLineError.InvalidForCompilerOptions, "/nologo[+|-]", engine.ErrorCultureInfo);
						}
						obj = CmdLineOptionParser.IsBooleanOption(text4, "nostdlib");
						if (obj != null)
						{
							throw new CmdLineException(CmdLineError.InvalidForCompilerOptions, "/nostdlib[+|-]", engine.ErrorCultureInfo);
						}
						break;
					}
					case 'O':
					case 'o':
					{
						object obj = CmdLineOptionParser.IsArgumentOption(text4, "out");
						if (obj != null)
						{
							throw new CmdLineException(CmdLineError.InvalidForCompilerOptions, "/out:<filename>", engine.ErrorCultureInfo);
						}
						break;
					}
					case 'P':
					case 'p':
					{
						object obj = CmdLineOptionParser.IsBooleanOption(text4, "print");
						if (obj != null)
						{
							engine.SetOption("print", obj);
							if (stringBuilder != null)
							{
								stringBuilder.Append(text3);
								stringBuilder.Append(" ");
							}
							continue;
						}
						obj = CmdLineOptionParser.IsArgumentOption(text4, "platform");
						if (obj == null)
						{
							break;
						}
						string strA = (string)obj;
						PortableExecutableKinds portableExecutableKinds;
						ImageFileMachine imageFileMachine;
						if (string.Compare(strA, "x86", StringComparison.OrdinalIgnoreCase) == 0)
						{
							portableExecutableKinds = PortableExecutableKinds.ILOnly | PortableExecutableKinds.Required32Bit;
							imageFileMachine = ImageFileMachine.I386;
						}
						else if (string.Compare(strA, "Itanium", StringComparison.OrdinalIgnoreCase) == 0)
						{
							portableExecutableKinds = PortableExecutableKinds.ILOnly | PortableExecutableKinds.PE32Plus;
							imageFileMachine = ImageFileMachine.IA64;
						}
						else if (string.Compare(strA, "x64", StringComparison.OrdinalIgnoreCase) == 0)
						{
							portableExecutableKinds = PortableExecutableKinds.ILOnly | PortableExecutableKinds.PE32Plus;
							imageFileMachine = ImageFileMachine.AMD64;
						}
						else
						{
							if (string.Compare(strA, "anycpu", StringComparison.OrdinalIgnoreCase) != 0)
							{
								throw new CmdLineException(CmdLineError.InvalidPlatform, (string)obj, engine.ErrorCultureInfo);
							}
							portableExecutableKinds = PortableExecutableKinds.ILOnly;
							imageFileMachine = ImageFileMachine.I386;
						}
						engine.SetOption("PortableExecutableKind", portableExecutableKinds);
						engine.SetOption("ImageFileMachine", imageFileMachine);
						if (stringBuilder != null)
						{
							stringBuilder.Append(text3);
							stringBuilder.Append(" ");
						}
						continue;
					}
					case 'R':
					case 'r':
					{
						object obj = CmdLineOptionParser.IsArgumentOption(text4, "r", "reference");
						if (obj != null)
						{
							throw new CmdLineException(CmdLineError.InvalidForCompilerOptions, "/r[eference]:<file list>", engine.ErrorCultureInfo);
						}
						obj = CmdLineOptionParser.IsArgumentOption(text4, "res", "resource");
						if (obj != null)
						{
							try
							{
								ResInfo resinfo2 = new ResInfo((string)obj, isLinked: false);
								AddResourceFile(resinfo2, resources, resourceFiles, engine);
							}
							catch (CmdLineException)
							{
								throw;
							}
							catch
							{
								throw new CmdLineException(CmdLineError.ManagedResourceNotFound, engine.ErrorCultureInfo);
							}
							continue;
						}
						break;
					}
					case 'T':
					case 't':
					{
						object obj = CmdLineOptionParser.IsArgumentOption(text4, "t", "target");
						if (obj == null)
						{
							break;
						}
						if (string.Compare((string)obj, "exe", StringComparison.OrdinalIgnoreCase) == 0)
						{
							if (!generateExe)
							{
								throw new CmdLineException(CmdLineError.IncompatibleTargets, text3, engine.ErrorCultureInfo);
							}
							if (flag2)
							{
								throw new CmdLineException(CmdLineError.MultipleTargets, engine.ErrorCultureInfo);
							}
							flag2 = true;
							continue;
						}
						if (string.Compare((string)obj, "winexe", StringComparison.OrdinalIgnoreCase) == 0)
						{
							if (!generateExe)
							{
								throw new CmdLineException(CmdLineError.IncompatibleTargets, text3, engine.ErrorCultureInfo);
							}
							if (flag2)
							{
								throw new CmdLineException(CmdLineError.MultipleTargets, engine.ErrorCultureInfo);
							}
							engine.SetOption("PEFileKind", PEFileKinds.WindowApplication);
							flag = true;
							flag2 = true;
							continue;
						}
						if (string.Compare((string)obj, "library", StringComparison.OrdinalIgnoreCase) == 0)
						{
							if (generateExe)
							{
								throw new CmdLineException(CmdLineError.IncompatibleTargets, engine.ErrorCultureInfo);
							}
							if (flag2)
							{
								throw new CmdLineException(CmdLineError.MultipleTargets, engine.ErrorCultureInfo);
							}
							flag2 = true;
							continue;
						}
						throw new CmdLineException(CmdLineError.InvalidTarget, (string)obj, engine.ErrorCultureInfo);
					}
					case 'U':
					case 'u':
					{
						object obj = CmdLineOptionParser.IsArgumentOption(text4, "utf8output");
						if (obj != null)
						{
							throw new CmdLineException(CmdLineError.InvalidForCompilerOptions, "/utf8output[+|-]", engine.ErrorCultureInfo);
						}
						break;
					}
					case 'V':
					case 'v':
					{
						object obj = CmdLineOptionParser.IsBooleanOption(text4, "VersionSafe");
						if (obj != null)
						{
							engine.SetOption("VersionSafe", obj);
							if (stringBuilder != null)
							{
								stringBuilder.Append(text3);
								stringBuilder.Append(" ");
							}
							continue;
						}
						break;
					}
					case 'W':
					case 'w':
					{
						object obj = CmdLineOptionParser.IsArgumentOption(text4, "w", "warn");
						if (obj != null)
						{
							if (((string)obj).Length == 0)
							{
								throw new CmdLineException(CmdLineError.NoWarningLevel, text3, engine.ErrorCultureInfo);
							}
							if (((string)obj).Length == 1)
							{
								if (stringBuilder != null)
								{
									stringBuilder.Append(text3);
									stringBuilder.Append(" ");
								}
								switch (((string)obj)[0])
								{
								case '0':
									engine.SetOption("WarningLevel", 0);
									continue;
								case '1':
									engine.SetOption("WarningLevel", 1);
									continue;
								case '2':
									engine.SetOption("WarningLevel", 2);
									continue;
								case '3':
									engine.SetOption("WarningLevel", 3);
									continue;
								case '4':
									engine.SetOption("WarningLevel", 4);
									continue;
								}
							}
							throw new CmdLineException(CmdLineError.InvalidWarningLevel, text3, engine.ErrorCultureInfo);
						}
						obj = CmdLineOptionParser.IsBooleanOption(text4, "warnaserror");
						if (obj != null)
						{
							engine.SetOption("warnaserror", obj);
							if (stringBuilder != null)
							{
								stringBuilder.Append(text3);
								stringBuilder.Append(" ");
							}
							continue;
						}
						obj = CmdLineOptionParser.IsArgumentOption(text4, "win32res");
						if (obj != null)
						{
							throw new CmdLineException(CmdLineError.InvalidForCompilerOptions, "/win32res:<filename>", engine.ErrorCultureInfo);
						}
						break;
					}
					}
				}
				throw new CmdLineException(CmdLineError.UnknownOption, text3, engine.ErrorCultureInfo);
			}
			if (stringBuilder != null)
			{
				if (generateExe)
				{
					if (flag)
					{
						stringBuilder.Append(text2 + "t:winexe ");
					}
					else
					{
						stringBuilder.Append(text2 + "t:exe ");
					}
				}
				else
				{
					stringBuilder.Append(text2 + "t:library ");
				}
				debugCommandLine = stringBuilder.ToString();
			}
			engine.SetOption("libpath", text);
			engine.SetOption("defines", hashtable);
		}

		internal void PrintBanner(VsaEngine engine, TextWriter output)
		{
			string text = 14.ToString(CultureInfo.InvariantCulture) + "." + 0.ToString(CultureInfo.InvariantCulture).PadLeft(2, '0') + "." + 9037.ToString(CultureInfo.InvariantCulture).PadLeft(4, '0');
			Version version = Environment.Version;
			string text2 = version.Major.ToString(CultureInfo.InvariantCulture) + "." + version.Minor.ToString(CultureInfo.InvariantCulture) + "." + version.Build.ToString(CultureInfo.InvariantCulture).PadLeft(4, '0');
			output.WriteLine(string.Format(engine.ErrorCultureInfo, JScriptException.Localize("Banner line 1", engine.ErrorCultureInfo), new object[1] { text }));
			output.WriteLine(string.Format(engine.ErrorCultureInfo, JScriptException.Localize("Banner line 2", engine.ErrorCultureInfo), new object[1] { text2 }));
			output.WriteLine(JScriptException.Localize("Banner line 3", engine.ErrorCultureInfo) + Environment.NewLine);
		}

		private void PrintOptions(TextWriter output, CompilerParameters options)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("CompilerParameters.CompilerOptions        : \"");
			stringBuilder.Append(options.CompilerOptions);
			stringBuilder.Append("\"");
			stringBuilder.Append(Environment.NewLine);
			stringBuilder.Append("CompilerParameters.GenerateExecutable     : ");
			stringBuilder.Append(options.GenerateExecutable.ToString(CultureInfo.InvariantCulture));
			stringBuilder.Append(Environment.NewLine);
			stringBuilder.Append("CompilerParameters.GenerateInMemory       : ");
			stringBuilder.Append(options.GenerateInMemory.ToString(CultureInfo.InvariantCulture));
			stringBuilder.Append(Environment.NewLine);
			stringBuilder.Append("CompilerParameters.IncludeDebugInformation: ");
			stringBuilder.Append(options.IncludeDebugInformation.ToString(CultureInfo.InvariantCulture));
			stringBuilder.Append(Environment.NewLine);
			stringBuilder.Append("CompilerParameters.MainClass              : \"");
			stringBuilder.Append(options.MainClass);
			stringBuilder.Append("\"");
			stringBuilder.Append(Environment.NewLine);
			stringBuilder.Append("CompilerParameters.OutputAssembly         : \"");
			stringBuilder.Append(options.OutputAssembly);
			stringBuilder.Append("\"");
			stringBuilder.Append(Environment.NewLine);
			stringBuilder.Append("CompilerParameters.ReferencedAssemblies   : ");
			StringEnumerator enumerator = options.ReferencedAssemblies.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					string current = enumerator.Current;
					stringBuilder.Append(Environment.NewLine);
					stringBuilder.Append("        \"");
					stringBuilder.Append(current);
					stringBuilder.Append("\"");
				}
			}
			finally
			{
				if (enumerator is IDisposable disposable)
				{
					disposable.Dispose();
				}
			}
			stringBuilder.Append(Environment.NewLine);
			stringBuilder.Append("CompilerParameters.TreatWarningsAsErrors  : ");
			stringBuilder.Append(options.TreatWarningsAsErrors.ToString(CultureInfo.InvariantCulture));
			stringBuilder.Append(Environment.NewLine);
			stringBuilder.Append("CompilerParameters.WarningLevel           : ");
			stringBuilder.Append(options.WarningLevel.ToString(CultureInfo.InvariantCulture));
			stringBuilder.Append(Environment.NewLine);
			stringBuilder.Append("CompilerParameters.Win32Resource          : \"");
			stringBuilder.Append(options.Win32Resource);
			stringBuilder.Append("\"");
			stringBuilder.Append(Environment.NewLine);
			output.WriteLine(stringBuilder.ToString());
		}

		protected string ReadFile(string fileName, VsaEngine engine)
		{
			string result = "";
			FileStream fileStream = null;
			try
			{
				fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
			}
			catch (ArgumentException)
			{
				throw new CmdLineException(CmdLineError.InvalidCharacters, fileName, engine.ErrorCultureInfo);
			}
			catch (FileNotFoundException)
			{
				throw new CmdLineException(CmdLineError.SourceNotFound, fileName, engine.ErrorCultureInfo);
			}
			try
			{
				if (fileStream.Length != 0L)
				{
					StreamReader streamReader = new StreamReader(fileStream, detectEncodingFromByteOrderMarks: true);
					try
					{
						return streamReader.ReadToEnd();
					}
					finally
					{
						streamReader.Close();
					}
				}
				return result;
			}
			finally
			{
				fileStream.Close();
			}
		}

		private StringCollection SplitCmdLineArguments(string argumentString)
		{
			StringCollection stringCollection = new StringCollection();
			if (argumentString == null || argumentString.Length == 0)
			{
				return stringCollection;
			}
			string pattern = "\\s*([^\\s\\\"]|(\\\"[^\\\"\\n]*\\\"))+";
			Regex regex = new Regex(pattern);
			MatchCollection matchCollection = regex.Matches(argumentString);
			if (matchCollection != null && matchCollection.Count != 0)
			{
				foreach (Match item in matchCollection)
				{
					string text = item.ToString().Trim();
					int num = 0;
					while ((num = text.IndexOf("\"", num)) != -1)
					{
						if (num == 0)
						{
							text = text.Substring(1);
						}
						else if (text[num - 1] == '\\')
						{
							num++;
						}
						else
						{
							text = text.Remove(num, 1);
						}
					}
					stringCollection.Add(text);
				}
				return stringCollection;
			}
			return stringCollection;
		}

		private void ValidateOptions(CompilerParameters options, VsaEngine engine)
		{
			string outputAssembly = options.OutputAssembly;
			try
			{
				if (Path.GetFileName(outputAssembly).Length == 0)
				{
					throw new CmdLineException(CmdLineError.NoFileName, outputAssembly, engine.ErrorCultureInfo);
				}
			}
			catch (ArgumentException)
			{
				throw new CmdLineException(CmdLineError.NoFileName, engine.ErrorCultureInfo);
			}
			if (Path.GetExtension(outputAssembly).Length == 0)
			{
				throw new CmdLineException(CmdLineError.MissingExtension, outputAssembly, engine.ErrorCultureInfo);
			}
			if (options.WarningLevel == -1)
			{
				options.WarningLevel = 4;
			}
			if (options.WarningLevel < 0 || options.WarningLevel > 4)
			{
				throw new CmdLineException(CmdLineError.InvalidWarningLevel, options.WarningLevel.ToString(CultureInfo.InvariantCulture), engine.ErrorCultureInfo);
			}
			if (options.Win32Resource != null && options.Win32Resource.Length > 0 && !File.Exists(options.Win32Resource))
			{
				throw new CmdLineException(CmdLineError.ResourceNotFound, options.Win32Resource, engine.ErrorCultureInfo);
			}
		}
	}
	internal class VsaSite : BaseVsaSite
	{
		public int warningLevel = 4;

		public bool treatWarningsAsErrors;

		public TextWriter output = Console.Out;

		public VsaSite(TextWriter redirectedOutput)
		{
			output = redirectedOutput;
		}

		public override bool OnCompilerError(IJSVsaError error)
		{
			int severity = error.Severity;
			if (severity > warningLevel)
			{
				return true;
			}
			bool fIsWarning = severity != 0 && !treatWarningsAsErrors;
			PrintError(error.SourceMoniker, error.Line, error.StartColumn, fIsWarning, error.Number, error.Description);
			return true;
		}

		private void PrintError(string sourceFile, int line, int column, bool fIsWarning, int number, string message)
		{
			string text = (10000 + (number & 0xFFFF)).ToString(CultureInfo.InvariantCulture).Substring(1);
			if (string.Compare(sourceFile, "no source", StringComparison.Ordinal) != 0)
			{
				output.Write(sourceFile + "(" + line.ToString(CultureInfo.InvariantCulture) + "," + column.ToString(CultureInfo.InvariantCulture) + ") : ");
			}
			output.WriteLine((fIsWarning ? "warning JS" : "error JS") + text + ": " + message);
		}
	}
	internal sealed class JSKeyword
	{
		private JSKeyword next;

		private JSToken token;

		private string name;

		private int length;

		private JSKeyword(JSToken token, string name)
		{
			this.name = name;
			next = null;
			this.token = token;
			length = this.name.Length;
		}

		private JSKeyword(JSToken token, string name, JSKeyword next)
		{
			this.name = name;
			this.next = next;
			this.token = token;
			length = this.name.Length;
		}

		internal static string CanBeIdentifier(JSToken keyword)
		{
			return keyword switch
			{
				JSToken.Abstract => "abstract", 
				JSToken.Assert => "assert", 
				JSToken.Boolean => "boolean", 
				JSToken.Byte => "byte", 
				JSToken.Char => "char", 
				JSToken.Decimal => "decimal", 
				JSToken.Double => "double", 
				JSToken.Ensure => "ensure", 
				JSToken.Enum => "enum", 
				JSToken.Event => "event", 
				JSToken.Final => "final", 
				JSToken.Float => "float", 
				JSToken.Get => "get", 
				JSToken.Goto => "goto", 
				JSToken.Implements => "implements", 
				JSToken.Int => "int", 
				JSToken.Interface => "interface", 
				JSToken.Internal => "internal", 
				JSToken.Invariant => "invariant", 
				JSToken.Long => "long", 
				JSToken.Namespace => "namespace", 
				JSToken.Native => "native", 
				JSToken.Package => "package", 
				JSToken.Private => "private", 
				JSToken.Protected => "protected", 
				JSToken.Public => "public", 
				JSToken.Require => "require", 
				JSToken.Sbyte => "sbyte", 
				JSToken.Set => "set", 
				JSToken.Short => "short", 
				JSToken.Static => "static", 
				JSToken.Synchronized => "synchronized", 
				JSToken.Throws => "throws", 
				JSToken.Transient => "transient", 
				JSToken.Void => "void", 
				JSToken.Volatile => "volatile", 
				JSToken.Uint => "uint", 
				JSToken.Ulong => "ulong", 
				JSToken.Ushort => "ushort", 
				JSToken.Use => "use", 
				_ => null, 
			};
		}

		internal JSToken GetKeyword(Context token, int length)
		{
			JSKeyword jSKeyword = this;
			while (jSKeyword != null)
			{
				if (length == jSKeyword.length)
				{
					int num = 1;
					int num2 = token.startPos + 1;
					char c;
					char c2;
					while (true)
					{
						if (num < length)
						{
							c = jSKeyword.name[num];
							c2 = token.source_string[num2];
							if (c != c2)
							{
								break;
							}
							num++;
							num2++;
							continue;
						}
						return jSKeyword.token;
					}
					if (c2 < c)
					{
						return JSToken.Identifier;
					}
					jSKeyword = jSKeyword.next;
				}
				else
				{
					if (length < jSKeyword.length)
					{
						return JSToken.Identifier;
					}
					jSKeyword = jSKeyword.next;
				}
			}
			return JSToken.Identifier;
		}

		internal static JSKeyword[] InitKeywords()
		{
			JSKeyword[] array = new JSKeyword[26];
			JSKeyword jSKeyword = new JSKeyword(JSToken.Abstract, "abstract");
			jSKeyword = (array[0] = new JSKeyword(JSToken.Assert, "assert", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Boolean, "boolean");
			jSKeyword = new JSKeyword(JSToken.Break, "break", jSKeyword);
			jSKeyword = (array[1] = new JSKeyword(JSToken.Byte, "byte", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Continue, "continue");
			jSKeyword = new JSKeyword(JSToken.Const, "const", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Class, "class", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Catch, "catch", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Char, "char", jSKeyword);
			jSKeyword = (array[2] = new JSKeyword(JSToken.Case, "case", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Debugger, "debugger");
			jSKeyword = new JSKeyword(JSToken.Default, "default", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Double, "double", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Delete, "delete", jSKeyword);
			jSKeyword = (array[3] = new JSKeyword(JSToken.Do, "do", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Extends, "extends");
			jSKeyword = new JSKeyword(JSToken.Export, "export", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Ensure, "ensure", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Event, "event", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Enum, "enum", jSKeyword);
			jSKeyword = (array[4] = new JSKeyword(JSToken.Else, "else", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Function, "function");
			jSKeyword = new JSKeyword(JSToken.Finally, "finally", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Float, "float", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Final, "final", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.False, "false", jSKeyword);
			jSKeyword = (array[5] = new JSKeyword(JSToken.For, "for", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Goto, "goto");
			jSKeyword = (array[6] = new JSKeyword(JSToken.Get, "get", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Instanceof, "instanceof");
			jSKeyword = new JSKeyword(JSToken.Implements, "implements", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Invariant, "invariant", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Interface, "interface", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Internal, "internal", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Import, "import", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Int, "int", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.In, "in", jSKeyword);
			jSKeyword = (array[8] = new JSKeyword(JSToken.If, "if", jSKeyword));
			jSKeyword = (array[11] = new JSKeyword(JSToken.Long, "long"));
			jSKeyword = new JSKeyword(JSToken.Namespace, "namespace");
			jSKeyword = new JSKeyword(JSToken.Native, "native", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Null, "null", jSKeyword);
			jSKeyword = (array[13] = new JSKeyword(JSToken.New, "new", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Protected, "protected");
			jSKeyword = new JSKeyword(JSToken.Private, "private", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Package, "package", jSKeyword);
			jSKeyword = (array[15] = new JSKeyword(JSToken.Public, "public", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Require, "require");
			jSKeyword = (array[17] = new JSKeyword(JSToken.Return, "return", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Synchronized, "synchronized");
			jSKeyword = new JSKeyword(JSToken.Switch, "switch", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Static, "static", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Super, "super", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Short, "short", jSKeyword);
			jSKeyword = (array[18] = new JSKeyword(JSToken.Set, "set", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Transient, "transient");
			jSKeyword = new JSKeyword(JSToken.Typeof, "typeof", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Throws, "throws", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.Throw, "throw", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.True, "true", jSKeyword);
			jSKeyword = new JSKeyword(JSToken.This, "this", jSKeyword);
			jSKeyword = (array[19] = new JSKeyword(JSToken.Try, "try", jSKeyword));
			jSKeyword = new JSKeyword(JSToken.Volatile, "volatile");
			jSKeyword = new JSKeyword(JSToken.Void, "void", jSKeyword);
			jSKeyword = (array[21] = new JSKeyword(JSToken.Var, "var", jSKeyword));
			jSKeyword = (array[20] = new JSKeyword(JSToken.Use, "use"));
			jSKeyword = new JSKeyword(JSToken.While, "while");
			jSKeyword = (array[22] = new JSKeyword(JSToken.With, "with", jSKeyword));
			return array;
		}
	}
	/// <summary>Represents a local variable.</summary>
	public sealed class JSLocalField : JSVariableField
	{
		internal int slotNumber;

		internal IReflect inferred_type;

		private ArrayList dependents;

		internal bool debugOn;

		internal JSLocalField outerField;

		internal bool isDefined;

		internal bool isUsedBeforeDefinition;

		/// <summary>Gets the type of this field.</summary>
		/// <returns>The type of this field.</returns>
		public override Type FieldType
		{
			get
			{
				if (type != null)
				{
					return base.FieldType;
				}
				return Convert.ToType(GetInferredType(null));
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JSLocalField" /> class, using the specified name, handle, and slot number.</summary>
		/// <param name="name">The name of this field.</param>
		/// <param name="handle">A handle to the internal metadata representation of this field.</param>
		/// <param name="slotNumber">The slot number of the variable.</param>
		public JSLocalField(string name, RuntimeTypeHandle handle, int slotNumber)
			: this(name, null, slotNumber, Missing.Value)
		{
			type = new TypeExpression(new ConstantWrapper(Type.GetTypeFromHandle(handle), null));
			isDefined = true;
		}

		internal JSLocalField(string name, FunctionScope scope, int slotNumber, object value)
			: base(name, scope, FieldAttributes.Public | FieldAttributes.Static)
		{
			this.slotNumber = slotNumber;
			inferred_type = null;
			dependents = null;
			base.value = value;
			debugOn = false;
			outerField = null;
			isDefined = false;
			isUsedBeforeDefinition = false;
		}

		internal override IReflect GetInferredType(JSField inference_target)
		{
			if (outerField != null)
			{
				return outerField.GetInferredType(inference_target);
			}
			if (type != null)
			{
				return base.GetInferredType(inference_target);
			}
			if (inferred_type == null || inferred_type == Typeob.Object)
			{
				return Typeob.Object;
			}
			if (inference_target != null && inference_target != this)
			{
				if (dependents == null)
				{
					dependents = new ArrayList();
				}
				dependents.Add(inference_target);
			}
			return inferred_type;
		}

		/// <summary>Gets the value of the field.</summary>
		/// <param name="obj">The object whose field value will be returned.</param>
		/// <returns>The value of the field.</returns>
		public override object GetValue(object obj)
		{
			if ((attributeFlags & FieldAttributes.Literal) != 0 && !(value is FunctionObject))
			{
				return value;
			}
			while (obj is BlockScope)
			{
				obj = ((BlockScope)obj).GetParent();
			}
			StackFrame stackFrame = (StackFrame)obj;
			JSLocalField jSLocalField = outerField;
			int num = slotNumber;
			while (jSLocalField != null)
			{
				num = jSLocalField.slotNumber;
				stackFrame = (StackFrame)stackFrame.GetParent();
				jSLocalField = jSLocalField.outerField;
			}
			return stackFrame.localVars[num];
		}

		internal void SetInferredType(IReflect ir, AST expr)
		{
			isDefined = true;
			if (type != null)
			{
				return;
			}
			if (outerField != null)
			{
				outerField.SetInferredType(ir, expr);
				return;
			}
			if (Convert.IsPrimitiveNumericTypeFitForDouble(ir))
			{
				ir = Typeob.Double;
			}
			else if (ir == Typeob.Void)
			{
				ir = Typeob.Object;
			}
			if (inferred_type == null)
			{
				inferred_type = ir;
			}
			else
			{
				if (ir == inferred_type || (Convert.IsPrimitiveNumericType(inferred_type) && Convert.IsPrimitiveNumericType(ir) && Convert.IsPromotableTo(ir, inferred_type)))
				{
					return;
				}
				inferred_type = Typeob.Object;
				if (dependents != null)
				{
					int i = 0;
					for (int count = dependents.Count; i < count; i++)
					{
						((JSLocalField)dependents[i]).SetInferredType(Typeob.Object, null);
					}
				}
			}
		}

		/// <summary>Sets the value of the field, using the specified value, culture, and binding information.</summary>
		/// <param name="obj">The object whose field value will be set.</param>
		/// <param name="value">The value to assign to the field.</param>
		/// <param name="invokeAttr">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">A set of properties that enables the binding, coercion of argument types, and invocation of members through reflection.</param>
		/// <param name="locale">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo locale)
		{
			if (type != null)
			{
				value = Convert.Coerce(value, type);
			}
			while (obj is BlockScope)
			{
				obj = ((BlockScope)obj).GetParent();
			}
			StackFrame stackFrame = (StackFrame)obj;
			JSLocalField jSLocalField = outerField;
			int num = slotNumber;
			while (jSLocalField != null)
			{
				num = jSLocalField.slotNumber;
				stackFrame = (StackFrame)stackFrame.GetParent();
				jSLocalField = jSLocalField.outerField;
			}
			if (stackFrame.localVars != null)
			{
				stackFrame.localVars[num] = value;
			}
		}
	}
	internal sealed class JSMemberField : JSVariableField
	{
		private object expandoValue;

		internal JSMemberField nextOverload;

		public override FieldAttributes Attributes
		{
			get
			{
				if ((attributeFlags & FieldAttributes.Literal) != 0)
				{
					if (value is FunctionObject && !((FunctionObject)value).isStatic)
					{
						return attributeFlags;
					}
					if (value is JSProperty)
					{
						JSProperty jSProperty = (JSProperty)value;
						if (jSProperty.getter != null && !jSProperty.getter.IsStatic)
						{
							return attributeFlags;
						}
						if (jSProperty.setter != null && !jSProperty.setter.IsStatic)
						{
							return attributeFlags;
						}
						return attributeFlags | FieldAttributes.Static;
					}
					return attributeFlags;
				}
				return attributeFlags;
			}
		}

		internal JSMemberField(ClassScope obj, string name, object value, FieldAttributes attributeFlags)
			: base(name, obj, attributeFlags)
		{
			base.value = value;
			nextOverload = null;
		}

		internal JSMemberField AddOverload(FunctionObject func, FieldAttributes attributeFlags)
		{
			JSMemberField jSMemberField = this;
			while (jSMemberField.nextOverload != null)
			{
				jSMemberField = jSMemberField.nextOverload;
			}
			JSMemberField jSMemberField2 = (jSMemberField.nextOverload = new JSMemberField((ClassScope)obj, Name, func, attributeFlags));
			jSMemberField2.type = type;
			return jSMemberField2;
		}

		internal void AddOverloadedMembers(MemberInfoList mems, ClassScope scope, BindingFlags attrs)
		{
			for (JSMemberField jSMemberField = this; jSMemberField != null; jSMemberField = jSMemberField.nextOverload)
			{
				MethodInfo asMethod = jSMemberField.GetAsMethod(scope);
				if (asMethod.IsStatic)
				{
					if ((attrs & BindingFlags.Static) == 0)
					{
						continue;
					}
				}
				else if ((attrs & BindingFlags.Instance) == 0)
				{
					continue;
				}
				if (asMethod.IsPublic)
				{
					if ((attrs & BindingFlags.Public) == 0)
					{
						continue;
					}
				}
				else if ((attrs & BindingFlags.NonPublic) == 0)
				{
					continue;
				}
				mems.Add(asMethod);
			}
			if ((attrs & BindingFlags.DeclaredOnly) != 0 && (attrs & BindingFlags.FlattenHierarchy) == 0)
			{
				return;
			}
			IReflect superType = scope.GetSuperType();
			MemberInfo[] member = superType.GetMember(Name, attrs & ~BindingFlags.DeclaredOnly);
			MemberInfo[] array = member;
			foreach (MemberInfo memberInfo in array)
			{
				if (memberInfo.MemberType == MemberTypes.Method)
				{
					mems.Add(memberInfo);
				}
			}
		}

		internal void CheckOverloadsForDuplicates()
		{
			JSMemberField jSMemberField = this;
			while (jSMemberField != null && jSMemberField.value is FunctionObject functionObject)
			{
				JSMemberField jSMemberField2 = jSMemberField.nextOverload;
				while (jSMemberField2 != null)
				{
					FunctionObject functionObject2 = (FunctionObject)jSMemberField2.value;
					if (functionObject2.implementedIface == functionObject.implementedIface)
					{
						ParameterInfo[] parameter_declarations = functionObject2.parameter_declarations;
						ParameterInfo[] suppars = parameter_declarations;
						parameter_declarations = functionObject.parameter_declarations;
						if (Class.ParametersMatch(suppars, parameter_declarations))
						{
							functionObject.funcContext.HandleError(JSError.DuplicateMethod);
							functionObject2.funcContext.HandleError(JSError.DuplicateMethod);
							break;
						}
					}
					jSMemberField2 = jSMemberField2.nextOverload;
				}
				jSMemberField = jSMemberField.nextOverload;
			}
		}

		internal override object GetMetaData()
		{
			if (metaData == null)
			{
				((ClassScope)obj).GetTypeBuilderOrEnumBuilder();
			}
			return metaData;
		}

		public override object GetValue(object obj)
		{
			if (obj is StackFrame)
			{
				return GetValue(((StackFrame)obj).closureInstance, (StackFrame)obj);
			}
			if (obj is ScriptObject)
			{
				return GetValue(obj, (ScriptObject)obj);
			}
			return GetValue(obj, null);
		}

		private object GetValue(object obj, ScriptObject scope)
		{
			if (base.IsStatic || base.IsLiteral)
			{
				return value;
			}
			if (base.obj != obj)
			{
				if (obj is JSObject jSObject)
				{
					FieldInfo field = jSObject.GetField(Name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
					if (field != null)
					{
						return field.GetValue(obj);
					}
					if (jSObject.outer_class_instance != null)
					{
						return GetValue(jSObject.outer_class_instance, null);
					}
				}
				throw new TargetException();
			}
			if (!base.IsPublic && (scope == null || !IsAccessibleFrom(scope)))
			{
				if (((JSObject)base.obj).noExpando)
				{
					throw new JScriptException(JSError.NotAccessible, new Context(new DocumentContext("", null), Name));
				}
				return expandoValue;
			}
			return value;
		}

		internal bool IsAccessibleFrom(ScriptObject scope)
		{
			while (scope != null && !(scope is ClassScope))
			{
				scope = scope.GetParent();
			}
			ClassScope classScope = null;
			classScope = ((!(obj is ClassScope)) ? ((ClassScope)obj.GetParent()) : ((ClassScope)obj));
			if (base.IsPrivate)
			{
				if (scope == null)
				{
					return false;
				}
				if (scope != classScope)
				{
					return ((ClassScope)scope).IsNestedIn(classScope, base.IsStatic);
				}
				return true;
			}
			if (base.IsFamily)
			{
				if (scope == null)
				{
					return false;
				}
				if (!((ClassScope)scope).IsSameOrDerivedFrom(classScope))
				{
					return ((ClassScope)scope).IsNestedIn(classScope, base.IsStatic);
				}
				return true;
			}
			if (base.IsFamilyOrAssembly && scope != null && (((ClassScope)scope).IsSameOrDerivedFrom(classScope) || ((ClassScope)scope).IsNestedIn(classScope, base.IsStatic)))
			{
				return true;
			}
			if (scope == null)
			{
				return classScope.GetPackage() == null;
			}
			return classScope.GetPackage() == ((ClassScope)scope).GetPackage();
		}

		internal ConstructorInfo[] GetAsConstructors(object proto)
		{
			JSMemberField jSMemberField = this;
			int num = 0;
			while (jSMemberField != null)
			{
				jSMemberField = jSMemberField.nextOverload;
				num++;
			}
			ConstructorInfo[] array = new ConstructorInfo[num];
			jSMemberField = this;
			num = 0;
			while (jSMemberField != null)
			{
				FunctionObject functionObject = (FunctionObject)jSMemberField.value;
				functionObject.isConstructor = true;
				functionObject.proto = proto;
				array[num++] = new JSConstructor(functionObject);
				jSMemberField = jSMemberField.nextOverload;
			}
			return array;
		}

		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo locale)
		{
			if (obj is StackFrame)
			{
				SetValue(((StackFrame)obj).closureInstance, value, invokeAttr, binder, locale, (StackFrame)obj);
			}
			else if (obj is ScriptObject)
			{
				SetValue(obj, value, invokeAttr, binder, locale, (ScriptObject)obj);
			}
			else
			{
				SetValue(obj, value, invokeAttr, binder, locale, null);
			}
		}

		private void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo locale, ScriptObject scope)
		{
			if (base.IsStatic || base.IsLiteral)
			{
				if ((base.IsLiteral || base.IsInitOnly) && !(base.value is Missing))
				{
					throw new JScriptException(JSError.AssignmentToReadOnly);
				}
			}
			else
			{
				if (base.obj != obj)
				{
					if (obj is JSObject)
					{
						FieldInfo field = ((JSObject)obj).GetField(Name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
						if (field != null)
						{
							field.SetValue(obj, value, invokeAttr, binder, locale);
							return;
						}
					}
					throw new TargetException();
				}
				if (!base.IsPublic && (scope == null || !IsAccessibleFrom(scope)))
				{
					if (((JSObject)base.obj).noExpando)
					{
						throw new JScriptException(JSError.NotAccessible, new Context(new DocumentContext("", null), Name));
					}
					expandoValue = value;
					return;
				}
			}
			if (type != null)
			{
				base.value = Convert.Coerce(value, type);
			}
			else
			{
				base.value = value;
			}
		}
	}
	/// <summary>Represents a JScript method. This class belongs to the name binding category.</summary>
	[Guid("561AC104-8869-4368-902F-4E0D7DDEDDDD")]
	[ComVisible(true)]
	public abstract class JSMethod : MethodInfo
	{
		internal object obj;

		/// <summary>Gets the type of member that this method is. Identifies the type of class derived from <see cref="T:System.Reflection.MemberInfo" /> that this class derives from.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MemberTypes.Method" />, because this class derives from <see cref="T:System.Reflection.MethodInfo" />.</returns>
		public override MemberTypes MemberType => MemberTypes.Method;

		/// <summary>Gets a handle to the internal metadata representation of this method.</summary>
		/// <returns>A handle to the internal metadata representation of this method.</returns>
		public override RuntimeMethodHandle MethodHandle => GetMethodInfo(null).MethodHandle;

		/// <summary>Gets the class object that was used to obtain this instance through reflection.</summary>
		/// <returns>The type that declares this method.</returns>
		public override Type ReflectedType => DeclaringType;

		/// <summary>Gets the custom attributes for the type of the return value of this method.</summary>
		/// <returns>null in all cases.</returns>
		public override ICustomAttributeProvider ReturnTypeCustomAttributes => null;

		internal JSMethod(object obj)
		{
			this.obj = obj;
		}

		internal abstract object Construct(object[] args);

		/// <summary>Returns the <see cref="T:System.Reflection.MethodInfo" /> object for the method on the direct or indirect base class in which this method was first declared.</summary>
		/// <returns>
		///   <see langword="this" /> in all cases.</returns>
		public override MethodInfo GetBaseDefinition()
		{
			return this;
		}

		internal virtual string GetClassFullName()
		{
			if (obj is ClassScope)
			{
				return ((ClassScope)obj).GetFullName();
			}
			throw new JScriptException(JSError.InternalError);
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this method, searching only for attributes of the specified type.</summary>
		/// <param name="t">The type of attribute to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of <see cref="T:System.Object" /> objects that has zero elements.</returns>
		public override object[] GetCustomAttributes(Type t, bool inherit)
		{
			return new object[0];
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this method.</summary>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array of <see cref="T:System.Object" /> objects that has zero elements.</returns>
		public override object[] GetCustomAttributes(bool inherit)
		{
			return new object[0];
		}

		/// <summary>Returns information about the implementation of this method.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MethodImplAttributes.Managed" /> and <see cref="F:System.Reflection.MethodImplAttributes.IL" />.</returns>
		public override MethodImplAttributes GetMethodImplementationFlags()
		{
			return MethodImplAttributes.IL;
		}

		internal abstract MethodInfo GetMethodInfo(CompilerGlobals compilerGlobals);

		internal virtual PackageScope GetPackage()
		{
			if (obj is ClassScope)
			{
				return ((ClassScope)obj).GetPackage();
			}
			throw new JScriptException(JSError.InternalError);
		}

		/// <summary>Invokes the method, using the specified information.</summary>
		/// <param name="obj">The object to call the method on.</param>
		/// <param name="options">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">An object that converts the type from actual argument type to formal argument type.</param>
		/// <param name="parameters">The argument list to pass to the method.</param>
		/// <param name="culture">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		/// <returns>The return value of the call to the method.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public override object Invoke(object obj, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			return Invoke(obj, obj, options, binder, parameters, culture);
		}

		internal abstract object Invoke(object obj, object thisob, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture);

		/// <summary>Determines whether the specified attribute type is attached to this method.</summary>
		/// <param name="type">The attribute type to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>
		///   <see langword="false" /> in all cases.</returns>
		public sealed override bool IsDefined(Type type, bool inherit)
		{
			return false;
		}
	}
	/// <summary>Wraps a <see cref="T:System.Reflection.MethodInfo" /> object.</summary>
	public sealed class JSMethodInfo : MethodInfo
	{
		internal MethodInfo method;

		private MethodAttributes methAttributes;

		private string name;

		private Type declaringType;

		private ParameterInfo[] parameters;

		private object[] attributes;

		private MethodInvoker methodInvoker;

		/// <summary>Gets the attributes that are associated with this method.</summary>
		/// <returns>A bitwise combination of the enumeration values.</returns>
		public override MethodAttributes Attributes => methAttributes;

		/// <summary>Gets the type that declares this method.</summary>
		/// <returns>The <see langword="Type" /> object for the class that declares this member.</returns>
		public override Type DeclaringType
		{
			get
			{
				Type type = declaringType;
				if (type == null)
				{
					type = (declaringType = method.DeclaringType);
				}
				return type;
			}
		}

		/// <summary>Gets the type of member that this method is. Identifies the type of class derived from <see cref="T:System.Reflection.MemberInfo" /> that this class derives from.</summary>
		/// <returns>
		///   <see cref="F:System.Reflection.MemberTypes.Method" />, because this class derives from <see cref="T:System.Reflection.MethodInfo" />.</returns>
		public override MemberTypes MemberType => MemberTypes.Method;

		/// <summary>Gets a handle to the internal metadata representation of this method.</summary>
		/// <returns>A handle to the internal metadata representation of this method.</returns>
		public override RuntimeMethodHandle MethodHandle => method.MethodHandle;

		/// <summary>Gets the name of this method.</summary>
		/// <returns>The name of this method.</returns>
		public override string Name
		{
			get
			{
				string text = name;
				if (text == null)
				{
					text = (name = method.Name);
				}
				return text;
			}
		}

		/// <summary>Gets the class object that was used to obtain this instance through reflection.</summary>
		/// <returns>The <see langword="Type" /> object that was used to obtain this method.</returns>
		public override Type ReflectedType => method.ReflectedType;

		/// <summary>Gets the type of the return value of this method.</summary>
		/// <returns>The type of the return value of this method.</returns>
		public override Type ReturnType => method.ReturnType;

		/// <summary>Gets the custom attributes for the type of the return value of this method.</summary>
		/// <returns>The custom attributes for the type of the return value of this method.</returns>
		public override ICustomAttributeProvider ReturnTypeCustomAttributes => method.ReturnTypeCustomAttributes;

		internal JSMethodInfo(MethodInfo method)
		{
			this.method = method;
			methAttributes = method.Attributes;
		}

		/// <summary>Returns the <see cref="T:System.Reflection.MethodInfo" /> object for the method of the direct or indirect base class in which this method was first declared.</summary>
		/// <returns>The first implementation of this method in the hierarchy.</returns>
		public override MethodInfo GetBaseDefinition()
		{
			return method.GetBaseDefinition();
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this method.</summary>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array that contains the custom attributes that are attached to this method, or, if there are none, an array that has zero elements.</returns>
		public sealed override object[] GetCustomAttributes(bool inherit)
		{
			object[] array = attributes;
			if (array != null)
			{
				return array;
			}
			return attributes = method.GetCustomAttributes(inherit: true);
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this method, searching only for attributes of the specified type.</summary>
		/// <param name="type">The type of attribute to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array that contains the custom attributes that are attached to this method, or, if there are none, an array that has zero elements.</returns>
		public sealed override object[] GetCustomAttributes(Type type, bool inherit)
		{
			if (type != typeof(JSFunctionAttribute))
			{
				return null;
			}
			object[] array = attributes;
			if (array != null)
			{
				return array;
			}
			return attributes = CustomAttribute.GetCustomAttributes(method, type, inherit: true);
		}

		/// <summary>Returns information about the implementation of this method.</summary>
		/// <returns>A bitwise combination of the enumeration values.</returns>
		public override MethodImplAttributes GetMethodImplementationFlags()
		{
			return method.GetMethodImplementationFlags();
		}

		/// <summary>Gets the parameters of this method.</summary>
		/// <returns>An array that contains information that matches the signature of this method.</returns>
		public override ParameterInfo[] GetParameters()
		{
			ParameterInfo[] array = parameters;
			if (array != null)
			{
				return array;
			}
			array = method.GetParameters();
			int i = 0;
			for (int num = array.Length; i < num; i++)
			{
				array[i] = new JSParameterInfo(array[i]);
			}
			return parameters = array;
		}

		/// <summary>Invokes the method, using the specified information.</summary>
		/// <param name="obj">The object to call the method on.</param>
		/// <param name="options">A bitwise combination of the enumeration values that control the binding.</param>
		/// <param name="binder">An object that converts the type from actual argument type to formal argument type.</param>
		/// <param name="parameters">The argument list to pass to the method.</param>
		/// <param name="culture">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		/// <returns>The return value of the call to the method.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public override object Invoke(object obj, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			MethodInfo methodInfo = TypeReferences.ToExecutionContext(method);
			if (binder != null)
			{
				try
				{
					return methodInfo.Invoke(obj, options, binder, parameters, culture);
				}
				catch (TargetInvocationException ex)
				{
					throw ex.InnerException;
				}
			}
			MethodInvoker methodInvoker = this.methodInvoker;
			if (methodInvoker == null)
			{
				methodInvoker = (this.methodInvoker = MethodInvoker.GetInvokerFor(methodInfo));
				if (methodInvoker == null)
				{
					try
					{
						return methodInfo.Invoke(obj, options, binder, parameters, culture);
					}
					catch (TargetInvocationException ex2)
					{
						throw ex2.InnerException;
					}
				}
			}
			return methodInvoker.Invoke(obj, parameters);
		}

		/// <summary>Determines whether the specified attribute type is attached to this method.</summary>
		/// <param name="type">The attribute type to search for.</param>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>
		///   <see langword="true" /> if one or more instances of the specified attribute <paramref name="type" /> is attached to this method; otherwise, <see langword="false" />.</returns>
		public sealed override bool IsDefined(Type type, bool inherit)
		{
			object[] array = attributes;
			if (array == null)
			{
				array = (attributes = CustomAttribute.GetCustomAttributes(method, type, inherit: true));
			}
			return array.Length != 0;
		}

		/// <summary>Returns a string that represents the method.</summary>
		/// <returns>A string that represents the method.</returns>
		public override string ToString()
		{
			return method.ToString();
		}
	}
	internal sealed class JSNativeMethod : JSMethod
	{
		private MethodInfo method;

		private ParameterInfo[] formalParams;

		private bool hasThis;

		private bool hasVarargs;

		private bool hasEngine;

		private VsaEngine engine;

		public override MethodAttributes Attributes => method.Attributes;

		public override Type DeclaringType => method.DeclaringType;

		public override string Name => method.Name;

		public override Type ReturnType => method.ReturnType;

		internal JSNativeMethod(MethodInfo method, object obj, VsaEngine engine)
			: base(obj)
		{
			this.method = method;
			formalParams = method.GetParameters();
			object[] customAttributes = CustomAttribute.GetCustomAttributes(method, typeof(JSFunctionAttribute), inherit: false);
			JSFunctionAttribute jSFunctionAttribute = ((customAttributes.Length != 0) ? ((JSFunctionAttribute)customAttributes[0]) : new JSFunctionAttribute(JSFunctionAttributeEnum.None));
			JSFunctionAttributeEnum attributeValue = jSFunctionAttribute.attributeValue;
			if ((attributeValue & JSFunctionAttributeEnum.HasThisObject) != 0)
			{
				hasThis = true;
			}
			if ((attributeValue & JSFunctionAttributeEnum.HasEngine) != 0)
			{
				hasEngine = true;
			}
			if ((attributeValue & JSFunctionAttributeEnum.HasVarArgs) != 0)
			{
				hasVarargs = true;
			}
			this.engine = engine;
		}

		internal override object Construct(object[] args)
		{
			throw new JScriptException(JSError.NoConstructor);
		}

		public override ParameterInfo[] GetParameters()
		{
			return formalParams;
		}

		internal override MethodInfo GetMethodInfo(CompilerGlobals compilerGlobals)
		{
			return method;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object Invoke(object obj, object thisob, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			int num = formalParams.Length;
			int num2 = ((parameters != null) ? parameters.Length : 0);
			if (!hasThis && !hasVarargs && num == num2)
			{
				if (binder != null)
				{
					return TypeReferences.ToExecutionContext(method).Invoke(base.obj, BindingFlags.SuppressChangeType, null, ConvertParams(0, parameters, binder, culture), null);
				}
				return TypeReferences.ToExecutionContext(method).Invoke(base.obj, options, binder, parameters, culture);
			}
			int num3 = (hasThis ? 1 : 0) + (hasEngine ? 1 : 0);
			object[] array = new object[num];
			if (hasThis)
			{
				array[0] = thisob;
				if (hasEngine)
				{
					array[1] = engine;
				}
			}
			else if (hasEngine)
			{
				array[0] = engine;
			}
			if (hasVarargs)
			{
				if (num == num3 + 1)
				{
					array[num3] = parameters;
				}
				else
				{
					int num4 = num - 1 - num3;
					if (num2 > num4)
					{
						ArrayObject.Copy(parameters, 0, array, num3, num4);
						int num5 = num2 - num4;
						object[] array2 = new object[num5];
						ArrayObject.Copy(parameters, num4, array2, 0, num5);
						array[num - 1] = array2;
					}
					else
					{
						ArrayObject.Copy(parameters, 0, array, num3, num2);
						for (int i = num2; i < num4; i++)
						{
							array[i + num3] = Missing.Value;
						}
						array[num - 1] = new object[0];
					}
				}
			}
			else
			{
				if (parameters != null)
				{
					if (num - num3 < num2)
					{
						ArrayObject.Copy(parameters, 0, array, num3, num - num3);
					}
					else
					{
						ArrayObject.Copy(parameters, 0, array, num3, num2);
					}
				}
				if (num - num3 > num2)
				{
					for (int j = num2 + num3; j < num; j++)
					{
						if (j == num - 1 && formalParams[j].ParameterType.IsArray && CustomAttribute.IsDefined(formalParams[j], typeof(ParamArrayAttribute), inherit: true))
						{
							array[j] = Array.CreateInstance(formalParams[j].ParameterType.GetElementType(), 0);
						}
						else
						{
							array[j] = Missing.Value;
						}
					}
				}
			}
			if (binder != null)
			{
				return TypeReferences.ToExecutionContext(method).Invoke(base.obj, BindingFlags.SuppressChangeType, null, ConvertParams(num3, array, binder, culture), null);
			}
			return TypeReferences.ToExecutionContext(method).Invoke(base.obj, options, binder, array, culture);
		}

		private object[] ConvertParams(int offset, object[] parameters, Binder binder, CultureInfo culture)
		{
			int num = formalParams.Length;
			if (hasVarargs)
			{
				num--;
			}
			for (int i = offset; i < num; i++)
			{
				Type parameterType = formalParams[i].ParameterType;
				if (parameterType != Typeob.Object)
				{
					parameters[i] = binder.ChangeType(parameters[i], parameterType, culture);
				}
			}
			return parameters;
		}
	}
	/// <summary>Represents an object in JScript. This class belongs to the objects and functions category.</summary>
	public class JSObject : ScriptObject, IEnumerable, IExpando, IReflect
	{
		private bool isASubClass;

		private IReflect subClassIR;

		private SimpleHashtable memberCache;

		internal bool noExpando;

		internal SimpleHashtable name_table;

		/// <summary>Stores a list of fields that are dynamically added and removed from the object.</summary>
		protected ArrayList field_table;

		internal JSObject outer_class_instance;

		internal SimpleHashtable NameTable
		{
			get
			{
				SimpleHashtable simpleHashtable = name_table;
				if (simpleHashtable == null)
				{
					simpleHashtable = (name_table = new SimpleHashtable(16u));
					field_table = new ArrayList();
				}
				return simpleHashtable;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JSObject" /> class.</summary>
		public JSObject()
			: this(null, checkSubType: false)
		{
			noExpando = false;
		}

		internal JSObject(ScriptObject parent)
			: this(parent, checkSubType: true)
		{
		}

		internal JSObject(ScriptObject parent, bool checkSubType)
			: base(parent)
		{
			memberCache = null;
			isASubClass = false;
			subClassIR = null;
			if (checkSubType)
			{
				Type type = Globals.TypeRefs.ToReferenceContext(GetType());
				if (type != Typeob.JSObject)
				{
					isASubClass = true;
					subClassIR = TypeReflector.GetTypeReflectorFor(type);
				}
			}
			noExpando = isASubClass;
			name_table = null;
			field_table = null;
			outer_class_instance = null;
		}

		internal JSObject(ScriptObject parent, Type subType)
			: base(parent)
		{
			memberCache = null;
			isASubClass = false;
			subClassIR = null;
			subType = Globals.TypeRefs.ToReferenceContext(subType);
			if (subType != Typeob.JSObject)
			{
				isASubClass = true;
				subClassIR = TypeReflector.GetTypeReflectorFor(subType);
			}
			noExpando = isASubClass;
			name_table = null;
			field_table = null;
		}

		/// <summary>Adds the specified field to the object.</summary>
		/// <param name="name">The name of the field to add.</param>
		/// <returns>The new field, if it is successfully added.</returns>
		public FieldInfo AddField(string name)
		{
			if (noExpando)
			{
				return null;
			}
			FieldInfo fieldInfo = (FieldInfo)NameTable[name];
			if (fieldInfo == null)
			{
				fieldInfo = new JSExpandoField(name);
				name_table[name] = fieldInfo;
				field_table.Add(fieldInfo);
			}
			return fieldInfo;
		}

		/// <summary>Adds the specified method to the object. <see cref="M:Microsoft.JScript.JSObject.System#Runtime#InteropServices#Expando#IExpando#AddMethod(System.String,System.Delegate)" /> is not implemented in JScript.</summary>
		/// <param name="name">The name of the method to add.</param>
		/// <param name="method">The delegate to the method.</param>
		/// <returns>null in all cases.</returns>
		MethodInfo IExpando.AddMethod(string name, Delegate method)
		{
			return null;
		}

		/// <summary>Adds the specified property to the object. This method is not implemented in JScript.</summary>
		/// <param name="name">The name of the property to add.</param>
		/// <returns>null in all cases.</returns>
		PropertyInfo IExpando.AddProperty(string name)
		{
			return null;
		}

		internal override bool DeleteMember(string name)
		{
			FieldInfo fieldInfo = (FieldInfo)NameTable[name];
			if (fieldInfo != null)
			{
				if (fieldInfo is JSExpandoField)
				{
					fieldInfo.SetValue(this, Missing.Value);
					name_table.Remove(name);
					field_table.Remove(fieldInfo);
					return true;
				}
				if (fieldInfo is JSPrototypeField)
				{
					fieldInfo.SetValue(this, Missing.Value);
					return true;
				}
				return false;
			}
			if (parent != null)
			{
				return LateBinding.DeleteMember(parent, name);
			}
			return false;
		}

		internal virtual string GetClassName()
		{
			return "Object";
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object GetDefaultValue(PreferredType preferred_type)
		{
			if (preferred_type == PreferredType.String)
			{
				if (GetMemberValue("toString") is ScriptFunction scriptFunction)
				{
					object obj = scriptFunction.Call(new object[0], this);
					if (obj == null)
					{
						return obj;
					}
					IConvertible iConvertible = Convert.GetIConvertible(obj);
					if (iConvertible != null && iConvertible.GetTypeCode() != TypeCode.Object)
					{
						return obj;
					}
				}
				if (GetMemberValue("valueOf") is ScriptFunction scriptFunction2)
				{
					object obj2 = scriptFunction2.Call(new object[0], this);
					if (obj2 == null)
					{
						return obj2;
					}
					IConvertible iConvertible2 = Convert.GetIConvertible(obj2);
					if (iConvertible2 != null && iConvertible2.GetTypeCode() != TypeCode.Object)
					{
						return obj2;
					}
				}
			}
			else if (preferred_type == PreferredType.LocaleString)
			{
				if (GetMemberValue("toLocaleString") is ScriptFunction scriptFunction3)
				{
					return scriptFunction3.Call(new object[0], this);
				}
			}
			else
			{
				if (preferred_type == PreferredType.Either && this is DateObject)
				{
					return GetDefaultValue(PreferredType.String);
				}
				if (GetMemberValue("valueOf") is ScriptFunction scriptFunction4)
				{
					object obj3 = scriptFunction4.Call(new object[0], this);
					if (obj3 == null)
					{
						return obj3;
					}
					IConvertible iConvertible3 = Convert.GetIConvertible(obj3);
					if (iConvertible3 != null && iConvertible3.GetTypeCode() != TypeCode.Object)
					{
						return obj3;
					}
				}
				if (GetMemberValue("toString") is ScriptFunction scriptFunction5)
				{
					object obj4 = scriptFunction5.Call(new object[0], this);
					if (obj4 == null)
					{
						return obj4;
					}
					IConvertible iConvertible4 = Convert.GetIConvertible(obj4);
					if (iConvertible4 != null && iConvertible4.GetTypeCode() != TypeCode.Object)
					{
						return obj4;
					}
				}
			}
			return this;
		}

		/// <summary>Returns an enumerator that iterates through the members of the object.</summary>
		/// <returns>An enumerator object that is used to iterate through the members of the object.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ForIn.JScriptGetEnumerator(this);
		}

		private static bool IsHiddenMember(MemberInfo mem)
		{
			Type declaringType = mem.DeclaringType;
			if (declaringType == Typeob.JSObject || declaringType == Typeob.ScriptObject || (declaringType == Typeob.ArrayWrapper && mem.Name != "length"))
			{
				return true;
			}
			return false;
		}

		private MemberInfo[] GetLocalMember(string name, BindingFlags bindingAttr, bool wrapMembers)
		{
			MemberInfo[] array = null;
			FieldInfo fieldInfo = ((name_table == null) ? null : ((FieldInfo)name_table[name]));
			if (fieldInfo == null && isASubClass)
			{
				if (memberCache != null)
				{
					array = (MemberInfo[])memberCache[name];
					if (array != null)
					{
						return array;
					}
				}
				bindingAttr &= ~BindingFlags.NonPublic;
				array = subClassIR.GetMember(name, bindingAttr);
				if (array.Length == 0)
				{
					array = subClassIR.GetMember(name, (bindingAttr & ~BindingFlags.Instance) | BindingFlags.Static);
				}
				int num = array.Length;
				if (num > 0)
				{
					int num2 = 0;
					MemberInfo[] array2 = array;
					foreach (MemberInfo mem in array2)
					{
						if (IsHiddenMember(mem))
						{
							num2++;
						}
					}
					if (num2 > 0 && (num != 1 || !(this is ObjectPrototype) || !(name == "ToString")))
					{
						MemberInfo[] array3 = new MemberInfo[num - num2];
						int num3 = 0;
						MemberInfo[] array4 = array;
						foreach (MemberInfo memberInfo in array4)
						{
							if (!IsHiddenMember(memberInfo))
							{
								array3[num3++] = memberInfo;
							}
						}
						array = array3;
					}
				}
				if ((array == null || array.Length == 0) && (bindingAttr & BindingFlags.Public) != 0 && (bindingAttr & BindingFlags.Instance) != 0)
				{
					BindingFlags bindingFlags = (bindingAttr & BindingFlags.IgnoreCase) | BindingFlags.Public | BindingFlags.Instance;
					if (this is StringObject)
					{
						array = TypeReflector.GetTypeReflectorFor(Typeob.String).GetMember(name, bindingFlags);
					}
					else if (this is NumberObject)
					{
						array = TypeReflector.GetTypeReflectorFor(((NumberObject)this).baseType).GetMember(name, bindingFlags);
					}
					else if (this is BooleanObject)
					{
						array = TypeReflector.GetTypeReflectorFor(Typeob.Boolean).GetMember(name, bindingFlags);
					}
					else if (this is StringConstructor)
					{
						array = TypeReflector.GetTypeReflectorFor(Typeob.String).GetMember(name, (bindingFlags | BindingFlags.Static) & ~BindingFlags.Instance);
					}
					else if (this is BooleanConstructor)
					{
						array = TypeReflector.GetTypeReflectorFor(Typeob.Boolean).GetMember(name, (bindingFlags | BindingFlags.Static) & ~BindingFlags.Instance);
					}
					else if (this is ArrayWrapper)
					{
						array = TypeReflector.GetTypeReflectorFor(Typeob.Array).GetMember(name, bindingFlags);
					}
				}
				if (array != null && array.Length != 0)
				{
					if (wrapMembers)
					{
						array = ScriptObject.WrapMembers(array, this);
					}
					if (memberCache == null)
					{
						memberCache = new SimpleHashtable(32u);
					}
					memberCache[name] = array;
					return array;
				}
			}
			if ((bindingAttr & BindingFlags.IgnoreCase) != 0 && (array == null || array.Length == 0))
			{
				array = null;
				IDictionaryEnumerator enumerator = name_table.GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (string.Compare(enumerator.Key.ToString(), name, StringComparison.OrdinalIgnoreCase) == 0)
					{
						fieldInfo = (FieldInfo)enumerator.Value;
						break;
					}
				}
			}
			if (fieldInfo != null)
			{
				return new MemberInfo[1] { fieldInfo };
			}
			if (array == null)
			{
				array = new MemberInfo[0];
			}
			return array;
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.MemberInfo" /> objects that correspond to all members that match the specified name.</summary>
		/// <param name="name">The name of the member to search for.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of members that match the <paramref name="name" /> argument.</returns>
		public override MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
		{
			return GetMember(name, bindingAttr, wrapMembers: false);
		}

		private MemberInfo[] GetMember(string name, BindingFlags bindingAttr, bool wrapMembers)
		{
			MemberInfo[] localMember = GetLocalMember(name, bindingAttr, wrapMembers);
			if (localMember.Length != 0)
			{
				return localMember;
			}
			if (parent != null)
			{
				if (parent is JSObject)
				{
					localMember = ((JSObject)parent).GetMember(name, bindingAttr, wrapMembers: true);
					wrapMembers = false;
				}
				else
				{
					localMember = parent.GetMember(name, bindingAttr);
				}
				MemberInfo[] array = localMember;
				foreach (MemberInfo memberInfo in array)
				{
					if (memberInfo.MemberType == MemberTypes.Field)
					{
						FieldInfo fieldInfo = (FieldInfo)memberInfo;
						JSMemberField jSMemberField = memberInfo as JSMemberField;
						if (jSMemberField != null)
						{
							if (!jSMemberField.IsStatic)
							{
								JSGlobalField value = new JSGlobalField(this, name, jSMemberField.value, FieldAttributes.Public);
								NameTable[name] = value;
								field_table.Add(value);
								fieldInfo = jSMemberField;
							}
						}
						else
						{
							fieldInfo = new JSPrototypeField(parent, (FieldInfo)memberInfo);
							if (!noExpando)
							{
								NameTable[name] = fieldInfo;
								field_table.Add(fieldInfo);
							}
						}
						return new MemberInfo[1] { fieldInfo };
					}
					if (!noExpando && memberInfo.MemberType == MemberTypes.Method)
					{
						FieldInfo fieldInfo2 = new JSPrototypeField(parent, new JSGlobalField(this, name, LateBinding.GetMemberValue(parent, name, null, localMember), FieldAttributes.Public | FieldAttributes.InitOnly));
						NameTable[name] = fieldInfo2;
						field_table.Add(fieldInfo2);
						return new MemberInfo[1] { fieldInfo2 };
					}
				}
				if (wrapMembers)
				{
					return ScriptObject.WrapMembers(localMember, parent);
				}
				return localMember;
			}
			return new MemberInfo[0];
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.MemberInfo" /> objects that correspond to all members of the current script object.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all members of the current object.</returns>
		public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
		{
			MemberInfoList memberInfoList = new MemberInfoList();
			SimpleHashtable simpleHashtable = new SimpleHashtable(32u);
			if (!noExpando && field_table != null)
			{
				IEnumerator enumerator = field_table.GetEnumerator();
				while (enumerator.MoveNext())
				{
					FieldInfo fieldInfo = (FieldInfo)enumerator.Current;
					memberInfoList.Add(fieldInfo);
					simpleHashtable[fieldInfo.Name] = fieldInfo;
				}
			}
			if (isASubClass)
			{
				MemberInfo[] members = GetType().GetMembers(bindingAttr & ~BindingFlags.NonPublic);
				int i = 0;
				for (int num = members.Length; i < num; i++)
				{
					MemberInfo memberInfo = members[i];
					if (!memberInfo.DeclaringType.IsAssignableFrom(Typeob.JSObject) && simpleHashtable[memberInfo.Name] == null)
					{
						MethodInfo methodInfo = memberInfo as MethodInfo;
						if (methodInfo == null || !methodInfo.IsSpecialName)
						{
							memberInfoList.Add(memberInfo);
							simpleHashtable[memberInfo.Name] = memberInfo;
						}
					}
				}
			}
			if (parent != null)
			{
				SimpleHashtable simpleHashtable2 = parent.wrappedMemberCache;
				if (simpleHashtable2 == null)
				{
					simpleHashtable2 = (parent.wrappedMemberCache = new SimpleHashtable(8u));
				}
				MemberInfo[] array = ScriptObject.WrapMembers(((IReflect)parent).GetMembers(bindingAttr & ~BindingFlags.NonPublic), parent, simpleHashtable2);
				int j = 0;
				for (int num2 = array.Length; j < num2; j++)
				{
					MemberInfo memberInfo2 = array[j];
					if (simpleHashtable[memberInfo2.Name] == null)
					{
						memberInfoList.Add(memberInfo2);
					}
				}
			}
			return memberInfoList.ToArray();
		}

		internal override void GetPropertyEnumerator(ArrayList enums, ArrayList objects)
		{
			if (field_table == null)
			{
				field_table = new ArrayList();
			}
			enums.Add(new ListEnumerator(field_table));
			objects.Add(this);
			if (parent != null)
			{
				parent.GetPropertyEnumerator(enums, objects);
			}
		}

		internal override object GetValueAtIndex(uint index)
		{
			string text = System.Convert.ToString(index, CultureInfo.InvariantCulture);
			FieldInfo fieldInfo = (FieldInfo)NameTable[text];
			if (fieldInfo != null)
			{
				return fieldInfo.GetValue(this);
			}
			object obj = null;
			obj = ((parent == null) ? Missing.Value : parent.GetMemberValue(text));
			if (this is StringObject && obj == Missing.Value)
			{
				string value = ((StringObject)this).value;
				if (index < value.Length)
				{
					return value[(int)index];
				}
			}
			return obj;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object GetMemberValue(string name)
		{
			FieldInfo fieldInfo = (FieldInfo)NameTable[name];
			if (fieldInfo == null && isASubClass)
			{
				fieldInfo = subClassIR.GetField(name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
				if (fieldInfo != null)
				{
					if (fieldInfo.DeclaringType == Typeob.ScriptObject)
					{
						return Missing.Value;
					}
				}
				else
				{
					PropertyInfo property = subClassIR.GetProperty(name, BindingFlags.Instance | BindingFlags.Public);
					if (property != null && !property.DeclaringType.IsAssignableFrom(Typeob.JSObject))
					{
						return JSProperty.GetGetMethod(property, nonPublic: false).Invoke(this, BindingFlags.SuppressChangeType, null, null, null);
					}
					try
					{
						MethodInfo method = subClassIR.GetMethod(name, BindingFlags.Static | BindingFlags.Public);
						if (method != null)
						{
							Type declaringType = method.DeclaringType;
							if (declaringType != Typeob.JSObject && declaringType != Typeob.ScriptObject && declaringType != Typeob.Object)
							{
								return new BuiltinFunction(this, method);
							}
						}
					}
					catch (AmbiguousMatchException)
					{
					}
				}
			}
			if (fieldInfo != null)
			{
				return fieldInfo.GetValue(this);
			}
			if (parent != null)
			{
				return parent.GetMemberValue(name);
			}
			return Missing.Value;
		}

		/// <summary>Removes the specified member from the object.</summary>
		/// <param name="m">The name of the member to remove.</param>
		void IExpando.RemoveMember(MemberInfo m)
		{
			DeleteMember(m.Name);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override void SetMemberValue(string name, object value)
		{
			SetMemberValue2(name, value);
		}

		/// <summary>Sets the value of a field that was dynamically added to the object and stored in <see cref="F:Microsoft.JScript.JSObject.field_table" />.</summary>
		/// <param name="name">The name of the field for which to set the value.</param>
		/// <param name="value">The new value of the field.</param>
		public void SetMemberValue2(string name, object value)
		{
			FieldInfo fieldInfo = (FieldInfo)NameTable[name];
			if (fieldInfo == null && isASubClass)
			{
				fieldInfo = GetType().GetField(name);
			}
			if (fieldInfo == null)
			{
				if (noExpando)
				{
					return;
				}
				fieldInfo = new JSExpandoField(name);
				name_table[name] = fieldInfo;
				field_table.Add(fieldInfo);
			}
			if (!fieldInfo.IsInitOnly && !fieldInfo.IsLiteral)
			{
				fieldInfo.SetValue(this, value);
			}
		}

		internal override void SetValueAtIndex(uint index, object value)
		{
			SetMemberValue(System.Convert.ToString(index, CultureInfo.InvariantCulture), value);
		}

		internal virtual void SwapValues(uint left, uint right)
		{
			string key = System.Convert.ToString(left, CultureInfo.InvariantCulture);
			string key2 = System.Convert.ToString(right, CultureInfo.InvariantCulture);
			FieldInfo fieldInfo = (FieldInfo)NameTable[key];
			FieldInfo fieldInfo2 = (FieldInfo)name_table[key2];
			if (fieldInfo == null)
			{
				if (!(fieldInfo2 == null))
				{
					name_table[key] = fieldInfo2;
					name_table.Remove(key2);
				}
			}
			else if (fieldInfo2 == null)
			{
				name_table[key2] = fieldInfo;
				name_table.Remove(key);
			}
			else
			{
				name_table[key] = fieldInfo2;
				name_table[key2] = fieldInfo;
			}
		}

		/// <summary>Returns a string that represents the current object.</summary>
		/// <returns>A string that represents the current object.</returns>
		public override string ToString()
		{
			return Convert.ToString(this);
		}
	}
	internal sealed class JSParameterInfo : ParameterInfo
	{
		private ParameterInfo parameter;

		private Type parameterType;

		private object[] attributes;

		public override object DefaultValue => TypeReferences.GetDefaultParameterValue(parameter);

		public override string Name => parameter.Name;

		public override Type ParameterType
		{
			get
			{
				Type type = parameterType;
				if (type != null)
				{
					return type;
				}
				return parameterType = parameter.ParameterType;
			}
		}

		internal JSParameterInfo(ParameterInfo parameter)
		{
			this.parameter = parameter;
		}

		public sealed override object[] GetCustomAttributes(bool inherit)
		{
			object[] array = attributes;
			if (array != null)
			{
				return array;
			}
			return attributes = parameter.GetCustomAttributes(inherit: true);
		}

		public sealed override object[] GetCustomAttributes(Type type, bool inherit)
		{
			object[] array = attributes;
			if (array != null)
			{
				return array;
			}
			return attributes = CustomAttribute.GetCustomAttributes(parameter, type, inherit: true);
		}

		public sealed override bool IsDefined(Type type, bool inherit)
		{
			object[] array = attributes;
			if (array == null)
			{
				array = (attributes = CustomAttribute.GetCustomAttributes(parameter, type, inherit: true));
			}
			return array.Length != 0;
		}
	}
	/// <summary>Parses JScript code. This class belongs to the scanning and parsing category.</summary>
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class JSParser
	{
		private enum BlockType
		{
			Block,
			Loop,
			Switch,
			Finally
		}

		private bool demandFullTrustOnFunctionCreation;

		private Context sourceContext;

		private JSScanner scanner;

		private Context currentToken;

		private Context errorToken;

		private int tokensSkipped;

		private const int c_MaxSkippedTokenNumber = 50;

		private NoSkipTokenSet noSkipTokenSet;

		private long goodTokensProcessed;

		private Block program;

		private ArrayList blockType;

		private SimpleHashtable labelTable;

		private int finallyEscaped;

		private int breakRecursion;

		private static int s_cDummyName;

		private Globals Globals;

		private int Severity;

		internal bool HasAborted => tokensSkipped > 50;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JSParser" /> class, specifying the source code to parse.</summary>
		/// <param name="context">The source code to parse.</param>
		public JSParser(Context context)
		{
			sourceContext = context;
			currentToken = context.Clone();
			scanner = new JSScanner(currentToken);
			noSkipTokenSet = new NoSkipTokenSet();
			errorToken = null;
			program = null;
			blockType = new ArrayList(16);
			labelTable = new SimpleHashtable(16u);
			finallyEscaped = 0;
			Globals = context.document.engine.Globals;
			Severity = 5;
			demandFullTrustOnFunctionCreation = false;
		}

		/// <summary>Parses the source code.</summary>
		/// <returns>The root of the abstract syntax tree that is created by parsing the code.</returns>
		public ScriptBlock Parse()
		{
			Block statement_block = ParseStatements(insideEval: false);
			return new ScriptBlock(sourceContext.Clone(), statement_block);
		}

		/// <summary>Parses the source code. Use this method instead of <see cref="M:Microsoft.JScript.JSParser.Parse" /> when the source code is inside an <see langword="eval" /> method call.</summary>
		/// <returns>The root of the abstract syntax tree that is created by parsing the code.</returns>
		public Block ParseEvalBody()
		{
			demandFullTrustOnFunctionCreation = true;
			return ParseStatements(insideEval: true);
		}

		internal ScriptBlock ParseExpressionItem()
		{
			int i = Globals.ScopeStack.Size();
			try
			{
				Block block = new Block(sourceContext.Clone());
				GetNextToken();
				block.Append(new Expression(sourceContext.Clone(), ParseExpression()));
				return new ScriptBlock(sourceContext.Clone(), block);
			}
			catch (EndOfFile)
			{
			}
			catch (ScannerException ex)
			{
				EOFError(ex.m_errorId);
			}
			catch (StackOverflowException)
			{
				Globals.ScopeStack.TrimToSize(i);
				ReportError(JSError.OutOfStack, skipToken: true);
			}
			return null;
		}

		private Block ParseStatements(bool insideEval)
		{
			int i = Globals.ScopeStack.Size();
			program = new Block(sourceContext.Clone());
			blockType.Add(BlockType.Block);
			errorToken = null;
			try
			{
				GetNextToken();
				noSkipTokenSet.Add(NoSkipTokenSet.s_StartStatementNoSkipTokenSet);
				noSkipTokenSet.Add(NoSkipTokenSet.s_TopLevelNoSkipTokenSet);
				try
				{
					while (currentToken.token != 0)
					{
						AST aST = null;
						try
						{
							if (currentToken.token == JSToken.Package && !insideEval)
							{
								aST = ParsePackage(currentToken.Clone());
							}
							else if (currentToken.token == JSToken.Import && !insideEval)
							{
								noSkipTokenSet.Add(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet);
								try
								{
									aST = ParseImportStatement();
								}
								catch (RecoveryTokenException ex)
								{
									if (IndexOfToken(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet, ex) == -1)
									{
										throw ex;
									}
									aST = ex._partiallyComputedNode;
									if (ex._token == JSToken.Semicolon)
									{
										GetNextToken();
									}
								}
								finally
								{
									noSkipTokenSet.Remove(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet);
								}
							}
							else
							{
								aST = ParseStatement();
							}
						}
						catch (RecoveryTokenException ex2)
						{
							if (TokenInList(NoSkipTokenSet.s_TopLevelNoSkipTokenSet, ex2) || TokenInList(NoSkipTokenSet.s_StartStatementNoSkipTokenSet, ex2))
							{
								aST = ex2._partiallyComputedNode;
							}
							else
							{
								errorToken = null;
								do
								{
									GetNextToken();
								}
								while (currentToken.token != 0 && !TokenInList(NoSkipTokenSet.s_TopLevelNoSkipTokenSet, currentToken.token) && !TokenInList(NoSkipTokenSet.s_StartStatementNoSkipTokenSet, currentToken.token));
							}
						}
						if (aST != null)
						{
							program.Append(aST);
						}
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_TopLevelNoSkipTokenSet);
					noSkipTokenSet.Remove(NoSkipTokenSet.s_StartStatementNoSkipTokenSet);
				}
			}
			catch (EndOfFile)
			{
			}
			catch (ScannerException ex3)
			{
				EOFError(ex3.m_errorId);
			}
			catch (StackOverflowException)
			{
				Globals.ScopeStack.TrimToSize(i);
				ReportError(JSError.OutOfStack, skipToken: true);
			}
			return program;
		}

		private AST ParseStatement()
		{
			AST aST = null;
			string text = null;
			switch (currentToken.token)
			{
			case JSToken.EndOfFile:
				EOFError(JSError.ErrEOF);
				throw new EndOfFile();
			case JSToken.Debugger:
				aST = new DebugBreak(currentToken.Clone());
				GetNextToken();
				break;
			case JSToken.Semicolon:
				aST = new Block(currentToken.Clone());
				GetNextToken();
				return aST;
			case JSToken.RightCurly:
				ReportError(JSError.SyntaxError);
				SkipTokensAndThrow();
				break;
			case JSToken.LeftCurly:
				return ParseBlock();
			case JSToken.Var:
			case JSToken.Const:
				return ParseVariableStatement(FieldAttributes.PrivateScope, null, currentToken.token);
			case JSToken.If:
				return ParseIfStatement();
			case JSToken.For:
				return ParseForStatement();
			case JSToken.Do:
				return ParseDoStatement();
			case JSToken.While:
				return ParseWhileStatement();
			case JSToken.Continue:
				aST = ParseContinueStatement();
				if (aST == null)
				{
					return new Block(CurrentPositionContext());
				}
				return aST;
			case JSToken.Break:
				aST = ParseBreakStatement();
				if (aST == null)
				{
					return new Block(CurrentPositionContext());
				}
				return aST;
			case JSToken.Return:
				aST = ParseReturnStatement();
				if (aST == null)
				{
					return new Block(CurrentPositionContext());
				}
				return aST;
			case JSToken.With:
				return ParseWithStatement();
			case JSToken.Switch:
				return ParseSwitchStatement();
			case JSToken.This:
			case JSToken.Super:
			{
				Context superCtx = currentToken.Clone();
				if (JSToken.LeftParen == scanner.PeekToken())
				{
					aST = ParseConstructorCall(superCtx);
					break;
				}
				goto default;
			}
			case JSToken.Throw:
				aST = ParseThrowStatement();
				if (aST == null)
				{
					return new Block(CurrentPositionContext());
				}
				break;
			case JSToken.Try:
				return ParseTryStatement();
			case JSToken.Internal:
			case JSToken.Abstract:
			case JSToken.Public:
			case JSToken.Static:
			case JSToken.Private:
			case JSToken.Protected:
			case JSToken.Final:
			{
				aST = ParseAttributes(null, unambiguousContext: false, isInsideClass: false, out var parsedOK);
				if (!parsedOK)
				{
					aST = ParseExpression(aST, single: false, bCanAssign: true, JSToken.None);
					aST = new Expression(aST.context.Clone(), aST);
					break;
				}
				return aST;
			}
			case JSToken.Package:
			{
				Context context = currentToken.Clone();
				aST = ParsePackage(context);
				if (aST is Package)
				{
					ReportError(JSError.PackageInWrongContext, context, skipToken: true);
					aST = new Block(context);
				}
				break;
			}
			case JSToken.Class:
			case JSToken.Interface:
				return ParseClass(FieldAttributes.PrivateScope, isStatic: false, currentToken.Clone(), isAbstract: false, isFinal: false, null);
			case JSToken.Enum:
				return ParseEnum(FieldAttributes.PrivateScope, currentToken.Clone(), null);
			case JSToken.Function:
				return ParseFunction(FieldAttributes.PrivateScope, inExpression: false, currentToken.Clone(), isMethod: false, isAbstract: false, isFinal: false, isInterface: false, null);
			case JSToken.Else:
				ReportError(JSError.InvalidElse);
				SkipTokensAndThrow();
				break;
			case JSToken.Import:
				ReportError(JSError.InvalidImport, skipToken: true);
				aST = new Block(currentToken.Clone());
				try
				{
					ParseImportStatement();
				}
				catch (RecoveryTokenException)
				{
				}
				break;
			default:
			{
				noSkipTokenSet.Add(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet);
				bool flag = false;
				try
				{
					bool canBeAttribute = true;
					aST = ParseUnaryExpression(out var isLeftHandSideExpr, ref canBeAttribute, isMinus: false);
					if (canBeAttribute)
					{
						if (aST is Lookup && JSToken.Colon == currentToken.token)
						{
							text = aST.ToString();
							if (labelTable[text] != null)
							{
								ReportError(JSError.BadLabel, aST.context.Clone(), skipToken: true);
								text = null;
								GetNextToken();
								return new Block(CurrentPositionContext());
							}
							GetNextToken();
							labelTable[text] = blockType.Count;
							aST = ((currentToken.token == JSToken.EndOfFile) ? new Block(CurrentPositionContext()) : ParseStatement());
							labelTable.Remove(text);
							return aST;
						}
						if (JSToken.Semicolon != currentToken.token && !scanner.GotEndOfLine())
						{
							aST = ParseAttributes(aST, unambiguousContext: false, isInsideClass: false, out var parsedOK2);
							if (parsedOK2)
							{
								return aST;
							}
						}
					}
					aST = ParseExpression(aST, single: false, isLeftHandSideExpr, JSToken.None);
					aST = new Expression(aST.context.Clone(), aST);
				}
				catch (RecoveryTokenException ex2)
				{
					if (ex2._partiallyComputedNode != null)
					{
						aST = ex2._partiallyComputedNode;
					}
					if (aST == null)
					{
						noSkipTokenSet.Remove(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet);
						flag = true;
						SkipTokensAndThrow();
					}
					if (IndexOfToken(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet, ex2) == -1)
					{
						ex2._partiallyComputedNode = aST;
						throw ex2;
					}
				}
				finally
				{
					if (!flag)
					{
						noSkipTokenSet.Remove(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet);
					}
				}
				break;
			}
			}
			if (JSToken.Semicolon == currentToken.token)
			{
				aST.context.UpdateWith(currentToken);
				GetNextToken();
			}
			else if (!scanner.GotEndOfLine() && JSToken.RightCurly != currentToken.token && currentToken.token != 0)
			{
				ReportError(JSError.NoSemicolon, skipToken: true);
			}
			return aST;
		}

		private AST ParseAttributes(AST statement, bool unambiguousContext, bool isInsideClass, out bool parsedOK)
		{
			AST aST = statement;
			ArrayList arrayList = new ArrayList();
			ArrayList arrayList2 = new ArrayList();
			ArrayList arrayList3 = new ArrayList();
			AST aST2 = null;
			ArrayList arrayList4 = new ArrayList();
			Context context = null;
			Context context2 = null;
			Context context3 = null;
			int num = 0;
			if (unambiguousContext)
			{
				num = 2;
			}
			FieldAttributes fieldAttributes = FieldAttributes.PrivateScope;
			FieldAttributes fieldAttributes2 = FieldAttributes.PrivateScope;
			Context context4 = null;
			if (statement != null)
			{
				aST2 = statement;
				arrayList4.Add(statement);
				arrayList.Add(CurrentPositionContext());
				context4 = statement.context.Clone();
				num = 1;
			}
			else
			{
				context4 = currentToken.Clone();
			}
			parsedOK = true;
			while (true)
			{
				JSToken jSToken = JSToken.None;
				switch (currentToken.token)
				{
				case JSToken.Internal:
				case JSToken.Abstract:
				case JSToken.Public:
				case JSToken.Static:
				case JSToken.Private:
				case JSToken.Protected:
				case JSToken.Final:
					jSToken = currentToken.token;
					goto case JSToken.Identifier;
				case JSToken.Var:
				case JSToken.Const:
				{
					int n = 0;
					for (int count6 = arrayList3.Count; n < count6; n += 2)
					{
						ReportError((JSError)arrayList3[n], (Context)arrayList3[n + 1], skipToken: true);
					}
					if (context != null)
					{
						ReportError(JSError.IllegalVisibility, context, skipToken: true);
					}
					if (context3 != null)
					{
						ReportError(JSError.IllegalVisibility, context3, skipToken: true);
					}
					context4.UpdateWith(currentToken);
					return ParseVariableStatement(fieldAttributes, FromASTListToCustomAttributeList(arrayList4), currentToken.token);
				}
				case JSToken.Function:
				{
					int m = 0;
					for (int count5 = arrayList3.Count; m < count5; m += 2)
					{
						ReportError((JSError)arrayList3[m], (Context)arrayList3[m + 1], skipToken: true);
					}
					context4.UpdateWith(currentToken);
					if (context2 != null)
					{
						if (context != null)
						{
							context2.HandleError(JSError.AbstractCannotBeStatic);
							context2 = null;
						}
						else if (context3 != null)
						{
							context3.HandleError(JSError.StaticIsAlreadyFinal);
							context3 = null;
						}
					}
					if (context != null)
					{
						if (context3 != null)
						{
							context3.HandleError(JSError.FinalPrecludesAbstract);
							context3 = null;
						}
						if (fieldAttributes2 == FieldAttributes.Private)
						{
							context.HandleError(JSError.AbstractCannotBePrivate);
							fieldAttributes2 = FieldAttributes.Family;
						}
					}
					return ParseFunction(fieldAttributes, inExpression: false, context4, isInsideClass, context != null, context3 != null, isInterface: false, FromASTListToCustomAttributeList(arrayList4));
				}
				case JSToken.Interface:
					if (context != null)
					{
						ReportError(JSError.IllegalVisibility, context, skipToken: true);
						context = null;
					}
					if (context3 != null)
					{
						ReportError(JSError.IllegalVisibility, context3, skipToken: true);
						context3 = null;
					}
					if (context2 != null)
					{
						ReportError(JSError.IllegalVisibility, context2, skipToken: true);
						context2 = null;
					}
					goto case JSToken.Class;
				case JSToken.Class:
				{
					int num2 = 0;
					for (int count7 = arrayList3.Count; num2 < count7; num2 += 2)
					{
						ReportError((JSError)arrayList3[num2], (Context)arrayList3[num2 + 1], skipToken: true);
					}
					context4.UpdateWith(currentToken);
					if (context3 != null && context != null)
					{
						context3.HandleError(JSError.FinalPrecludesAbstract);
					}
					return ParseClass(fieldAttributes, context2 != null, context4, context != null, context3 != null, FromASTListToCustomAttributeList(arrayList4));
				}
				case JSToken.Enum:
				{
					int i = 0;
					for (int count = arrayList3.Count; i < count; i += 2)
					{
						ReportError((JSError)arrayList3[i], (Context)arrayList3[i + 1], skipToken: true);
					}
					context4.UpdateWith(currentToken);
					if (context != null)
					{
						ReportError(JSError.IllegalVisibility, context, skipToken: true);
					}
					if (context3 != null)
					{
						ReportError(JSError.IllegalVisibility, context3, skipToken: true);
					}
					if (context2 != null)
					{
						ReportError(JSError.IllegalVisibility, context2, skipToken: true);
					}
					return ParseEnum(fieldAttributes, context4, FromASTListToCustomAttributeList(arrayList4));
				}
				case JSToken.Void:
				case JSToken.Boolean:
				case JSToken.Byte:
				case JSToken.Char:
				case JSToken.Double:
				case JSToken.Float:
				case JSToken.Int:
				case JSToken.Long:
				case JSToken.Short:
					parsedOK = false;
					aST2 = new Lookup(currentToken);
					jSToken = JSToken.None;
					arrayList4.Add(aST2);
					GetNextToken();
					break;
				case JSToken.Identifier:
				{
					bool canBeAttribute = true;
					statement = ParseUnaryExpression(out var _, ref canBeAttribute, isMinus: false, jSToken == JSToken.None);
					aST2 = statement;
					if (jSToken != JSToken.None)
					{
						if (statement is Lookup)
						{
							goto IL_07dc;
						}
						if (num != 2)
						{
							arrayList2.Add(currentToken.Clone());
						}
					}
					jSToken = JSToken.None;
					if (canBeAttribute)
					{
						arrayList4.Add(statement);
						break;
					}
					goto default;
				}
				default:
					{
						parsedOK = false;
						if (num != 2)
						{
							if (aST != statement || statement == null)
							{
								statement = aST2;
								int j = 0;
								for (int count2 = arrayList2.Count; j < count2; j++)
								{
									ForceReportInfo((Context)arrayList2[j], JSError.KeywordUsedAsIdentifier);
								}
								int k = 0;
								for (int count3 = arrayList.Count; k < count3; k++)
								{
									if (!currentToken.Equals((Context)arrayList[k]))
									{
										ReportError(JSError.NoSemicolon, (Context)arrayList[k], skipToken: true);
									}
								}
							}
							return statement;
						}
						if (arrayList4.Count > 0)
						{
							AST aST3 = (AST)arrayList4[arrayList4.Count - 1];
							if (aST3 is Lookup)
							{
								if (JSToken.Semicolon == currentToken.token || JSToken.Colon == currentToken.token)
								{
									ReportError(JSError.BadVariableDeclaration, aST3.context.Clone());
									SkipTokensAndThrow();
								}
							}
							else if (aST3 is Call && ((Call)aST3).CanBeFunctionDeclaration())
							{
								if (JSToken.Colon == currentToken.token || JSToken.LeftCurly == currentToken.token)
								{
									ReportError(JSError.BadFunctionDeclaration, aST3.context.Clone(), skipToken: true);
									if (JSToken.Colon == currentToken.token)
									{
										noSkipTokenSet.Add(NoSkipTokenSet.s_StartBlockNoSkipTokenSet);
										try
										{
											SkipTokensAndThrow();
										}
										catch (RecoveryTokenException)
										{
										}
										finally
										{
											noSkipTokenSet.Remove(NoSkipTokenSet.s_StartBlockNoSkipTokenSet);
										}
									}
									errorToken = null;
									if (JSToken.LeftCurly == currentToken.token)
									{
										FunctionScope item = new FunctionScope(Globals.ScopeStack.Peek(), isInsideClass);
										Globals.ScopeStack.Push(item);
										try
										{
											ParseBlock();
										}
										finally
										{
											Globals.ScopeStack.Pop();
										}
										SkipTokensAndThrow();
									}
								}
								else
								{
									ReportError(JSError.SyntaxError, aST3.context.Clone());
								}
								SkipTokensAndThrow();
							}
						}
						if (JSToken.LeftCurly == currentToken.token && isInsideClass)
						{
							int l = 0;
							for (int count4 = arrayList3.Count; l < count4; l += 2)
							{
								ReportError((JSError)arrayList3[l], (Context)arrayList3[l + 1]);
							}
							if (context2 == null)
							{
								ReportError(JSError.StaticMissingInStaticInit, CurrentPositionContext());
							}
							string name = ((ClassScope)Globals.ScopeStack.Peek()).name;
							bool flag = true;
							foreach (object item2 in arrayList4)
							{
								flag = false;
								if (context2 == null || !(item2 is Lookup) || !(item2.ToString() == name) || ((Lookup)item2).context.StartColumn <= context2.StartColumn)
								{
									ReportError(JSError.SyntaxError, ((AST)item2).context);
								}
							}
							if (flag)
							{
								ReportError(JSError.NoIdentifier, CurrentPositionContext());
							}
							errorToken = null;
							parsedOK = true;
							return ParseStaticInitializer(context4);
						}
						ReportError(JSError.MissingConstructForAttributes, context4.CombineWith(currentToken));
						SkipTokensAndThrow();
						goto IL_07dc;
					}
					IL_07dc:
					switch (jSToken)
					{
					case JSToken.Public:
						fieldAttributes2 = FieldAttributes.Public;
						goto default;
					case JSToken.Static:
						if (isInsideClass)
						{
							fieldAttributes2 = FieldAttributes.Static;
							if (context2 != null)
							{
								arrayList3.Add(JSError.SyntaxError);
								arrayList3.Add(statement.context.Clone());
							}
							else
							{
								context2 = statement.context.Clone();
							}
						}
						else
						{
							arrayList3.Add(JSError.NotInsideClass);
							arrayList3.Add(statement.context.Clone());
						}
						goto default;
					case JSToken.Private:
						if (isInsideClass)
						{
							fieldAttributes2 = FieldAttributes.Private;
						}
						else
						{
							arrayList3.Add(JSError.NotInsideClass);
							arrayList3.Add(statement.context.Clone());
						}
						goto default;
					case JSToken.Protected:
						if (isInsideClass)
						{
							fieldAttributes2 = FieldAttributes.Family;
						}
						else
						{
							arrayList3.Add(JSError.NotInsideClass);
							arrayList3.Add(statement.context.Clone());
						}
						goto default;
					case JSToken.Abstract:
						if (context != null)
						{
							arrayList3.Add(JSError.SyntaxError);
							arrayList3.Add(statement.context.Clone());
						}
						else
						{
							context = statement.context.Clone();
						}
						break;
					case JSToken.Final:
						if (context3 != null)
						{
							arrayList3.Add(JSError.SyntaxError);
							arrayList3.Add(statement.context.Clone());
						}
						else
						{
							context3 = statement.context.Clone();
						}
						break;
					case JSToken.Internal:
						fieldAttributes2 = FieldAttributes.Assembly;
						goto default;
					default:
						if ((fieldAttributes & FieldAttributes.FieldAccessMask) == fieldAttributes2 && fieldAttributes2 != 0)
						{
							arrayList3.Add(JSError.DupVisibility);
							arrayList3.Add(statement.context.Clone());
						}
						else if ((fieldAttributes & FieldAttributes.FieldAccessMask) > FieldAttributes.PrivateScope && (fieldAttributes2 & FieldAttributes.FieldAccessMask) > FieldAttributes.PrivateScope)
						{
							if ((fieldAttributes2 == FieldAttributes.Family && (fieldAttributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Assembly) || (fieldAttributes2 == FieldAttributes.Assembly && (fieldAttributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Family))
							{
								fieldAttributes &= ~FieldAttributes.FieldAccessMask;
								fieldAttributes |= FieldAttributes.FamORAssem;
							}
							else
							{
								arrayList3.Add(JSError.IncompatibleVisibility);
								arrayList3.Add(statement.context.Clone());
							}
						}
						else
						{
							fieldAttributes |= fieldAttributes2;
							context4.UpdateWith(statement.context);
						}
						break;
					}
					break;
				}
				if (num != 2)
				{
					if (scanner.GotEndOfLine())
					{
						num = 0;
						continue;
					}
					num++;
					arrayList.Add(currentToken.Clone());
				}
			}
		}

		private Block ParseBlock()
		{
			Context closingBraceContext;
			return ParseBlock(out closingBraceContext);
		}

		private Block ParseBlock(out Context closingBraceContext)
		{
			closingBraceContext = null;
			blockType.Add(BlockType.Block);
			Block block = new Block(currentToken.Clone());
			GetNextToken();
			noSkipTokenSet.Add(NoSkipTokenSet.s_StartStatementNoSkipTokenSet);
			noSkipTokenSet.Add(NoSkipTokenSet.s_BlockNoSkipTokenSet);
			try
			{
				while (JSToken.RightCurly != currentToken.token)
				{
					try
					{
						block.Append(ParseStatement());
					}
					catch (RecoveryTokenException ex)
					{
						if (ex._partiallyComputedNode != null)
						{
							block.Append(ex._partiallyComputedNode);
						}
						if (IndexOfToken(NoSkipTokenSet.s_StartStatementNoSkipTokenSet, ex) == -1)
						{
							throw ex;
						}
					}
				}
			}
			catch (RecoveryTokenException ex2)
			{
				if (IndexOfToken(NoSkipTokenSet.s_BlockNoSkipTokenSet, ex2) == -1)
				{
					ex2._partiallyComputedNode = block;
					throw ex2;
				}
			}
			finally
			{
				noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockNoSkipTokenSet);
				noSkipTokenSet.Remove(NoSkipTokenSet.s_StartStatementNoSkipTokenSet);
				blockType.RemoveAt(blockType.Count - 1);
			}
			closingBraceContext = currentToken.Clone();
			block.context.UpdateWith(currentToken);
			GetNextToken();
			return block;
		}

		private AST ParseVariableStatement(FieldAttributes visibility, CustomAttributeList customAttributes, JSToken kind)
		{
			Block block = new Block(currentToken.Clone());
			bool flag = true;
			AST aST = null;
			while (true)
			{
				noSkipTokenSet.Add(NoSkipTokenSet.s_EndOfLineToken);
				try
				{
					aST = ParseIdentifierInitializer(JSToken.None, visibility, customAttributes, kind);
				}
				catch (RecoveryTokenException ex)
				{
					if (ex._partiallyComputedNode != null && !flag)
					{
						block.Append(ex._partiallyComputedNode);
						block.context.UpdateWith(ex._partiallyComputedNode.context);
						ex._partiallyComputedNode = block;
					}
					if (IndexOfToken(NoSkipTokenSet.s_EndOfLineToken, ex) == -1)
					{
						throw ex;
					}
					if (flag)
					{
						aST = ex._partiallyComputedNode;
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_EndOfLineToken);
				}
				if (JSToken.Semicolon == currentToken.token || JSToken.RightCurly == currentToken.token)
				{
					if (JSToken.Semicolon == currentToken.token)
					{
						aST.context.UpdateWith(currentToken);
						GetNextToken();
					}
					break;
				}
				if (JSToken.Comma == currentToken.token)
				{
					flag = false;
					block.Append(aST);
					continue;
				}
				if (!scanner.GotEndOfLine())
				{
					ReportError(JSError.NoSemicolon, skipToken: true);
				}
				break;
			}
			if (flag)
			{
				return aST;
			}
			block.Append(aST);
			block.context.UpdateWith(aST.context);
			return block;
		}

		private AST ParseIdentifierInitializer(JSToken inToken, FieldAttributes visibility, CustomAttributeList customAttributes, JSToken kind)
		{
			Lookup lookup = null;
			TypeExpression typeExpression = null;
			AST aST = null;
			RecoveryTokenException ex = null;
			GetNextToken();
			if (JSToken.Identifier != currentToken.token)
			{
				string text = JSKeyword.CanBeIdentifier(currentToken.token);
				if (text != null)
				{
					ForceReportInfo(JSError.KeywordUsedAsIdentifier);
					lookup = new Lookup(text, currentToken.Clone());
				}
				else
				{
					ReportError(JSError.NoIdentifier);
					lookup = new Lookup("#_Missing Identifier_#" + s_cDummyName++, CurrentPositionContext());
				}
			}
			else
			{
				lookup = new Lookup(scanner.GetIdentifier(), currentToken.Clone());
			}
			GetNextToken();
			Context context = lookup.context.Clone();
			noSkipTokenSet.Add(NoSkipTokenSet.s_VariableDeclNoSkipTokenSet);
			try
			{
				if (JSToken.Colon == currentToken.token)
				{
					try
					{
						typeExpression = ParseTypeExpression();
					}
					catch (RecoveryTokenException ex2)
					{
						typeExpression = (TypeExpression)ex2._partiallyComputedNode;
						throw ex2;
					}
					finally
					{
						if (typeExpression != null)
						{
							context.UpdateWith(typeExpression.context);
						}
					}
				}
				if (JSToken.Assign == currentToken.token || JSToken.Equal == currentToken.token)
				{
					if (JSToken.Equal == currentToken.token)
					{
						ReportError(JSError.NoEqual, skipToken: true);
					}
					GetNextToken();
					try
					{
						aST = ParseExpression(single: true, inToken);
					}
					catch (RecoveryTokenException ex3)
					{
						aST = ex3._partiallyComputedNode;
						throw ex3;
					}
					finally
					{
						if (aST != null)
						{
							context.UpdateWith(aST.context);
						}
					}
				}
			}
			catch (RecoveryTokenException ex4)
			{
				if (IndexOfToken(NoSkipTokenSet.s_VariableDeclNoSkipTokenSet, ex4) == -1)
				{
					ex = ex4;
				}
			}
			finally
			{
				noSkipTokenSet.Remove(NoSkipTokenSet.s_VariableDeclNoSkipTokenSet);
			}
			AST aST2 = null;
			if (JSToken.Var == kind)
			{
				aST2 = new VariableDeclaration(context, lookup, typeExpression, aST, visibility, customAttributes);
			}
			else
			{
				if (aST == null)
				{
					ForceReportInfo(JSError.NoEqual);
				}
				aST2 = new Constant(context, lookup, typeExpression, aST, visibility, customAttributes);
			}
			customAttributes?.SetTarget(aST2);
			if (ex != null)
			{
				ex._partiallyComputedNode = aST2;
				throw ex;
			}
			return aST2;
		}

		private AST ParseQualifiedIdentifier(JSError error)
		{
			GetNextToken();
			AST aST = null;
			string text = null;
			Context context = currentToken.Clone();
			if (JSToken.Identifier != currentToken.token)
			{
				text = JSKeyword.CanBeIdentifier(currentToken.token);
				if (text != null)
				{
					switch (currentToken.token)
					{
					default:
						ForceReportInfo(JSError.KeywordUsedAsIdentifier);
						break;
					case JSToken.Void:
					case JSToken.Boolean:
					case JSToken.Byte:
					case JSToken.Char:
					case JSToken.Double:
					case JSToken.Float:
					case JSToken.Int:
					case JSToken.Long:
					case JSToken.Short:
						break;
					}
					aST = new Lookup(text, context);
				}
				else
				{
					ReportError(error, skipToken: true);
					SkipTokensAndThrow();
				}
			}
			else
			{
				aST = new Lookup(scanner.GetIdentifier(), context);
			}
			GetNextToken();
			if (JSToken.AccessField == currentToken.token)
			{
				aST = ParseScopeSequence(aST, error);
			}
			return aST;
		}

		private AST ParseScopeSequence(AST qualid, JSError error)
		{
			ConstantWrapper memberName = null;
			string text = null;
			do
			{
				GetNextToken();
				if (JSToken.Identifier != currentToken.token)
				{
					text = JSKeyword.CanBeIdentifier(currentToken.token);
					if (text != null)
					{
						ForceReportInfo(JSError.KeywordUsedAsIdentifier);
						memberName = new ConstantWrapper(text, currentToken.Clone());
					}
					else
					{
						ReportError(error, skipToken: true);
						SkipTokensAndThrow(qualid);
					}
				}
				else
				{
					memberName = new ConstantWrapper(scanner.GetIdentifier(), currentToken.Clone());
				}
				qualid = new Member(qualid.context.CombineWith(currentToken), qualid, memberName);
				GetNextToken();
			}
			while (JSToken.AccessField == currentToken.token);
			return qualid;
		}

		private TypeExpression ParseTypeExpression()
		{
			AST aST = null;
			try
			{
				aST = ParseQualifiedIdentifier(JSError.NeedType);
			}
			catch (RecoveryTokenException ex)
			{
				if (ex._partiallyComputedNode != null)
				{
					ex._partiallyComputedNode = new TypeExpression(ex._partiallyComputedNode);
				}
				throw ex;
			}
			TypeExpression typeExpression = new TypeExpression(aST);
			if (typeExpression != null)
			{
				while (!scanner.GotEndOfLine() && JSToken.LeftBracket == currentToken.token)
				{
					GetNextToken();
					int num = 1;
					while (JSToken.Comma == currentToken.token)
					{
						GetNextToken();
						num++;
					}
					if (JSToken.RightBracket != currentToken.token)
					{
						ReportError(JSError.NoRightBracket);
					}
					GetNextToken();
					if (typeExpression.isArray)
					{
						typeExpression = new TypeExpression(typeExpression);
					}
					typeExpression.isArray = true;
					typeExpression.rank = num;
				}
			}
			return typeExpression;
		}

		private If ParseIfStatement()
		{
			Context context = currentToken.Clone();
			AST aST = null;
			AST true_branch = null;
			AST false_branch = null;
			blockType.Add(BlockType.Block);
			try
			{
				GetNextToken();
				noSkipTokenSet.Add(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				try
				{
					if (JSToken.LeftParen != currentToken.token)
					{
						ReportError(JSError.NoLeftParen);
					}
					GetNextToken();
					aST = ParseExpression();
					if (JSToken.RightParen != currentToken.token)
					{
						context.UpdateWith(aST.context);
						ReportError(JSError.NoRightParen);
					}
					else
					{
						context.UpdateWith(currentToken);
					}
					GetNextToken();
				}
				catch (RecoveryTokenException ex)
				{
					aST = ((ex._partiallyComputedNode == null) ? new ConstantWrapper(true, CurrentPositionContext()) : ex._partiallyComputedNode);
					if (IndexOfToken(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet, ex) == -1)
					{
						ex._partiallyComputedNode = null;
						throw ex;
					}
					if (ex._token == JSToken.RightParen)
					{
						GetNextToken();
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				}
				if (aST is Assign)
				{
					aST.context.HandleError(JSError.SuspectAssignment);
				}
				if (JSToken.Semicolon == currentToken.token)
				{
					ForceReportInfo(JSError.SuspectSemicolon);
				}
				noSkipTokenSet.Add(NoSkipTokenSet.s_IfBodyNoSkipTokenSet);
				try
				{
					true_branch = ParseStatement();
				}
				catch (RecoveryTokenException ex2)
				{
					true_branch = ((ex2._partiallyComputedNode == null) ? new Block(CurrentPositionContext()) : ex2._partiallyComputedNode);
					if (IndexOfToken(NoSkipTokenSet.s_IfBodyNoSkipTokenSet, ex2) == -1)
					{
						ex2._partiallyComputedNode = new If(context, aST, true_branch, false_branch);
						throw ex2;
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_IfBodyNoSkipTokenSet);
				}
				if (JSToken.Else == currentToken.token)
				{
					GetNextToken();
					if (JSToken.Semicolon == currentToken.token)
					{
						ForceReportInfo(JSError.SuspectSemicolon);
					}
					try
					{
						false_branch = ParseStatement();
					}
					catch (RecoveryTokenException ex3)
					{
						false_branch = ((ex3._partiallyComputedNode == null) ? new Block(CurrentPositionContext()) : ex3._partiallyComputedNode);
						ex3._partiallyComputedNode = new If(context, aST, true_branch, false_branch);
						throw ex3;
					}
				}
			}
			finally
			{
				blockType.RemoveAt(blockType.Count - 1);
			}
			return new If(context, aST, true_branch, false_branch);
		}

		private AST ParseForStatement()
		{
			blockType.Add(BlockType.Loop);
			AST aST = null;
			try
			{
				Context context = currentToken.Clone();
				GetNextToken();
				if (JSToken.LeftParen != currentToken.token)
				{
					ReportError(JSError.NoLeftParen);
				}
				GetNextToken();
				bool flag = false;
				bool flag2 = false;
				AST var = null;
				AST aST2 = null;
				AST aST3 = null;
				AST aST4 = null;
				try
				{
					if (JSToken.Var == currentToken.token)
					{
						flag = true;
						aST2 = ParseIdentifierInitializer(JSToken.In, FieldAttributes.PrivateScope, null, JSToken.Var);
						AST aST5 = null;
						while (JSToken.Comma == currentToken.token)
						{
							flag = false;
							aST5 = ParseIdentifierInitializer(JSToken.In, FieldAttributes.PrivateScope, null, JSToken.Var);
							aST2 = new Comma(aST2.context.CombineWith(aST5.context), aST2, aST5);
						}
						if (flag)
						{
							if (JSToken.In == currentToken.token)
							{
								GetNextToken();
								aST3 = ParseExpression();
							}
							else
							{
								flag = false;
							}
						}
					}
					else if (JSToken.Semicolon != currentToken.token)
					{
						aST2 = ParseUnaryExpression(out var isLeftHandSideExpr, isMinus: false);
						if (isLeftHandSideExpr && JSToken.In == currentToken.token)
						{
							flag = true;
							var = aST2;
							aST2 = null;
							GetNextToken();
							noSkipTokenSet.Add(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
							try
							{
								aST3 = ParseExpression();
							}
							catch (RecoveryTokenException ex)
							{
								if (IndexOfToken(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet, ex) == -1)
								{
									ex._partiallyComputedNode = null;
									throw ex;
								}
								aST3 = ((ex._partiallyComputedNode != null) ? ex._partiallyComputedNode : new ConstantWrapper(true, CurrentPositionContext()));
								if (ex._token == JSToken.RightParen)
								{
									GetNextToken();
									flag2 = true;
								}
							}
							finally
							{
								noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
							}
						}
						else
						{
							aST2 = ParseExpression(aST2, single: false, isLeftHandSideExpr, JSToken.In);
						}
					}
					else
					{
						aST2 = new EmptyLiteral(CurrentPositionContext());
					}
				}
				catch (RecoveryTokenException ex2)
				{
					ex2._partiallyComputedNode = null;
					throw ex2;
				}
				if (flag)
				{
					if (!flag2)
					{
						if (JSToken.RightParen != currentToken.token)
						{
							ReportError(JSError.NoRightParen);
						}
						context.UpdateWith(currentToken);
						GetNextToken();
					}
					AST aST6 = null;
					try
					{
						aST6 = ParseStatement();
					}
					catch (RecoveryTokenException ex3)
					{
						aST6 = ((ex3._partiallyComputedNode != null) ? ex3._partiallyComputedNode : new Block(CurrentPositionContext()));
						ex3._partiallyComputedNode = new ForIn(context, var, aST2, aST3, aST6);
						throw ex3;
					}
					return new ForIn(context, var, aST2, aST3, aST6);
				}
				noSkipTokenSet.Add(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				try
				{
					if (JSToken.Semicolon != currentToken.token)
					{
						ReportError(JSError.NoSemicolon);
						if (JSToken.Colon == currentToken.token)
						{
							noSkipTokenSet.Add(NoSkipTokenSet.s_VariableDeclNoSkipTokenSet);
							try
							{
								SkipTokensAndThrow();
							}
							catch (RecoveryTokenException ex4)
							{
								if (JSToken.Semicolon != currentToken.token)
								{
									throw ex4;
								}
								errorToken = null;
							}
							finally
							{
								noSkipTokenSet.Remove(NoSkipTokenSet.s_VariableDeclNoSkipTokenSet);
							}
						}
					}
					GetNextToken();
					if (JSToken.Semicolon != currentToken.token)
					{
						aST3 = ParseExpression();
						if (JSToken.Semicolon != currentToken.token)
						{
							ReportError(JSError.NoSemicolon);
						}
					}
					else
					{
						aST3 = new ConstantWrapper(true, CurrentPositionContext());
					}
					GetNextToken();
					aST4 = ((JSToken.RightParen == currentToken.token) ? new EmptyLiteral(CurrentPositionContext()) : ParseExpression());
					if (JSToken.RightParen != currentToken.token)
					{
						ReportError(JSError.NoRightParen);
					}
					context.UpdateWith(currentToken);
					GetNextToken();
				}
				catch (RecoveryTokenException ex5)
				{
					if (IndexOfToken(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet, ex5) == -1)
					{
						ex5._partiallyComputedNode = null;
						throw ex5;
					}
					ex5._partiallyComputedNode = null;
					if (aST3 == null)
					{
						aST3 = new ConstantWrapper(true, CurrentPositionContext());
					}
					if (aST4 == null)
					{
						aST4 = new EmptyLiteral(CurrentPositionContext());
					}
					if (ex5._token == JSToken.RightParen)
					{
						GetNextToken();
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				}
				AST aST7 = null;
				try
				{
					aST7 = ParseStatement();
				}
				catch (RecoveryTokenException ex6)
				{
					aST7 = ((ex6._partiallyComputedNode != null) ? ex6._partiallyComputedNode : new Block(CurrentPositionContext()));
					ex6._partiallyComputedNode = new For(context, aST2, aST3, aST4, aST7);
					throw ex6;
				}
				return new For(context, aST2, aST3, aST4, aST7);
			}
			finally
			{
				blockType.RemoveAt(blockType.Count - 1);
			}
		}

		private DoWhile ParseDoStatement()
		{
			Context context = null;
			AST body = null;
			AST aST = null;
			blockType.Add(BlockType.Loop);
			try
			{
				GetNextToken();
				noSkipTokenSet.Add(NoSkipTokenSet.s_DoWhileBodyNoSkipTokenSet);
				try
				{
					body = ParseStatement();
				}
				catch (RecoveryTokenException ex)
				{
					body = ((ex._partiallyComputedNode == null) ? new Block(CurrentPositionContext()) : ex._partiallyComputedNode);
					if (IndexOfToken(NoSkipTokenSet.s_DoWhileBodyNoSkipTokenSet, ex) == -1)
					{
						ex._partiallyComputedNode = new DoWhile(CurrentPositionContext(), body, new ConstantWrapper(false, CurrentPositionContext()));
						throw ex;
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_DoWhileBodyNoSkipTokenSet);
				}
				if (JSToken.While != currentToken.token)
				{
					ReportError(JSError.NoWhile);
				}
				context = currentToken.Clone();
				GetNextToken();
				if (JSToken.LeftParen != currentToken.token)
				{
					ReportError(JSError.NoLeftParen);
				}
				GetNextToken();
				noSkipTokenSet.Add(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				try
				{
					aST = ParseExpression();
					if (JSToken.RightParen != currentToken.token)
					{
						ReportError(JSError.NoRightParen);
						context.UpdateWith(aST.context);
					}
					else
					{
						context.UpdateWith(currentToken);
					}
					GetNextToken();
				}
				catch (RecoveryTokenException ex2)
				{
					aST = ((ex2._partiallyComputedNode == null) ? new ConstantWrapper(false, CurrentPositionContext()) : ex2._partiallyComputedNode);
					if (IndexOfToken(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet, ex2) == -1)
					{
						ex2._partiallyComputedNode = new DoWhile(context, body, aST);
						throw ex2;
					}
					if (JSToken.RightParen == currentToken.token)
					{
						GetNextToken();
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				}
				if (JSToken.Semicolon == currentToken.token)
				{
					context.UpdateWith(currentToken);
					GetNextToken();
				}
			}
			finally
			{
				blockType.RemoveAt(blockType.Count - 1);
			}
			return new DoWhile(context, body, aST);
		}

		private While ParseWhileStatement()
		{
			Context context = currentToken.Clone();
			AST aST = null;
			AST body = null;
			blockType.Add(BlockType.Loop);
			try
			{
				GetNextToken();
				if (JSToken.LeftParen != currentToken.token)
				{
					ReportError(JSError.NoLeftParen);
				}
				GetNextToken();
				noSkipTokenSet.Add(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				try
				{
					aST = ParseExpression();
					if (JSToken.RightParen != currentToken.token)
					{
						ReportError(JSError.NoRightParen);
						context.UpdateWith(aST.context);
					}
					else
					{
						context.UpdateWith(currentToken);
					}
					GetNextToken();
				}
				catch (RecoveryTokenException ex)
				{
					if (IndexOfToken(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet, ex) == -1)
					{
						ex._partiallyComputedNode = null;
						throw ex;
					}
					aST = ((ex._partiallyComputedNode == null) ? new ConstantWrapper(false, CurrentPositionContext()) : ex._partiallyComputedNode);
					if (JSToken.RightParen == currentToken.token)
					{
						GetNextToken();
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				}
				try
				{
					body = ParseStatement();
				}
				catch (RecoveryTokenException ex2)
				{
					body = ((ex2._partiallyComputedNode == null) ? new Block(CurrentPositionContext()) : ex2._partiallyComputedNode);
					ex2._partiallyComputedNode = new While(context, aST, body);
					throw ex2;
				}
			}
			finally
			{
				blockType.RemoveAt(blockType.Count - 1);
			}
			return new While(context, aST, body);
		}

		private Continue ParseContinueStatement()
		{
			Context context = currentToken.Clone();
			int num = 0;
			GetNextToken();
			string text = null;
			if (!scanner.GotEndOfLine() && (JSToken.Identifier == currentToken.token || (text = JSKeyword.CanBeIdentifier(currentToken.token)) != null))
			{
				context.UpdateWith(currentToken);
				if (text != null)
				{
					ForceReportInfo(JSError.KeywordUsedAsIdentifier);
				}
				else
				{
					text = scanner.GetIdentifier();
				}
				object obj = labelTable[text];
				if (obj == null)
				{
					ReportError(JSError.NoLabel, skipToken: true);
					GetNextToken();
					return null;
				}
				num = (int)obj;
				if ((BlockType)blockType[num] != BlockType.Loop)
				{
					ReportError(JSError.BadContinue, context.Clone(), skipToken: true);
				}
				GetNextToken();
			}
			else
			{
				num = blockType.Count - 1;
				while (num >= 0 && (BlockType)blockType[num] != BlockType.Loop)
				{
					num--;
				}
				if (num < 0)
				{
					ReportError(JSError.BadContinue, context, skipToken: true);
					return null;
				}
			}
			if (JSToken.Semicolon == currentToken.token)
			{
				context.UpdateWith(currentToken);
				GetNextToken();
			}
			else if (JSToken.RightCurly != currentToken.token && !scanner.GotEndOfLine())
			{
				ReportError(JSError.NoSemicolon, skipToken: true);
			}
			int num2 = 0;
			int i = num;
			for (int count = blockType.Count; i < count; i++)
			{
				if ((BlockType)blockType[i] == BlockType.Finally)
				{
					num++;
					num2++;
				}
			}
			if (num2 > finallyEscaped)
			{
				finallyEscaped = num2;
			}
			return new Continue(context, blockType.Count - num, num2 > 0);
		}

		private Break ParseBreakStatement()
		{
			Context context = currentToken.Clone();
			int num = 0;
			GetNextToken();
			string text = null;
			if (!scanner.GotEndOfLine() && (JSToken.Identifier == currentToken.token || (text = JSKeyword.CanBeIdentifier(currentToken.token)) != null))
			{
				context.UpdateWith(currentToken);
				if (text != null)
				{
					ForceReportInfo(JSError.KeywordUsedAsIdentifier);
				}
				else
				{
					text = scanner.GetIdentifier();
				}
				object obj = labelTable[text];
				if (obj == null)
				{
					ReportError(JSError.NoLabel, skipToken: true);
					GetNextToken();
					return null;
				}
				num = (int)obj - 1;
				GetNextToken();
			}
			else
			{
				num = blockType.Count - 1;
				while (((BlockType)blockType[num] == BlockType.Block || (BlockType)blockType[num] == BlockType.Finally) && --num >= 0)
				{
				}
				num--;
				if (num < 0)
				{
					ReportError(JSError.BadBreak, context, skipToken: true);
					return null;
				}
			}
			if (JSToken.Semicolon == currentToken.token)
			{
				context.UpdateWith(currentToken);
				GetNextToken();
			}
			else if (JSToken.RightCurly != currentToken.token && !scanner.GotEndOfLine())
			{
				ReportError(JSError.NoSemicolon, skipToken: true);
			}
			int num2 = 0;
			int i = num;
			for (int count = blockType.Count; i < count; i++)
			{
				if ((BlockType)blockType[i] == BlockType.Finally)
				{
					num++;
					num2++;
				}
			}
			if (num2 > finallyEscaped)
			{
				finallyEscaped = num2;
			}
			return new Break(context, blockType.Count - num - 1, num2 > 0);
		}

		private bool CheckForReturnFromFinally()
		{
			int num = 0;
			for (int num2 = blockType.Count - 1; num2 >= 0; num2--)
			{
				if ((BlockType)blockType[num2] == BlockType.Finally)
				{
					num++;
				}
			}
			if (num > finallyEscaped)
			{
				finallyEscaped = num;
			}
			return num > 0;
		}

		private Return ParseReturnStatement()
		{
			Context context = currentToken.Clone();
			if (Globals.ScopeStack.Peek() is FunctionScope)
			{
				AST aST = null;
				GetNextToken();
				if (!scanner.GotEndOfLine())
				{
					if (JSToken.Semicolon != currentToken.token && JSToken.RightCurly != currentToken.token)
					{
						noSkipTokenSet.Add(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet);
						try
						{
							aST = ParseExpression();
						}
						catch (RecoveryTokenException ex)
						{
							aST = ex._partiallyComputedNode;
							if (IndexOfToken(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet, ex) == -1)
							{
								if (aST != null)
								{
									context.UpdateWith(aST.context);
								}
								ex._partiallyComputedNode = new Return(context, aST, CheckForReturnFromFinally());
								throw ex;
							}
						}
						finally
						{
							noSkipTokenSet.Remove(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet);
						}
						if (JSToken.Semicolon != currentToken.token && JSToken.RightCurly != currentToken.token && !scanner.GotEndOfLine())
						{
							ReportError(JSError.NoSemicolon, skipToken: true);
						}
					}
					if (JSToken.Semicolon == currentToken.token)
					{
						context.UpdateWith(currentToken);
						GetNextToken();
					}
					else if (aST != null)
					{
						context.UpdateWith(aST.context);
					}
				}
				return new Return(context, aST, CheckForReturnFromFinally());
			}
			ReportError(JSError.BadReturn, context, skipToken: true);
			GetNextToken();
			return null;
		}

		private Import ParseImportStatement()
		{
			Context context = currentToken.Clone();
			AST name = null;
			try
			{
				name = ParseQualifiedIdentifier(JSError.PackageExpected);
			}
			catch (RecoveryTokenException ex)
			{
				if (ex._partiallyComputedNode != null)
				{
					ex._partiallyComputedNode = new Import(context, ex._partiallyComputedNode);
				}
			}
			if (currentToken.token != JSToken.Semicolon && !scanner.GotEndOfLine())
			{
				ReportError(JSError.NoSemicolon, currentToken.Clone());
			}
			return new Import(context, name);
		}

		private With ParseWithStatement()
		{
			Context context = currentToken.Clone();
			AST aST = null;
			AST block = null;
			blockType.Add(BlockType.Block);
			try
			{
				GetNextToken();
				if (JSToken.LeftParen != currentToken.token)
				{
					ReportError(JSError.NoLeftParen);
				}
				GetNextToken();
				noSkipTokenSet.Add(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				try
				{
					aST = ParseExpression();
					if (JSToken.RightParen != currentToken.token)
					{
						context.UpdateWith(aST.context);
						ReportError(JSError.NoRightParen);
					}
					else
					{
						context.UpdateWith(currentToken);
					}
					GetNextToken();
				}
				catch (RecoveryTokenException ex)
				{
					if (IndexOfToken(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet, ex) == -1)
					{
						ex._partiallyComputedNode = null;
						throw ex;
					}
					aST = ((ex._partiallyComputedNode != null) ? ex._partiallyComputedNode : new ConstantWrapper(true, CurrentPositionContext()));
					context.UpdateWith(aST.context);
					if (ex._token == JSToken.RightParen)
					{
						GetNextToken();
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				}
				try
				{
					block = ParseStatement();
				}
				catch (RecoveryTokenException ex2)
				{
					block = ((ex2._partiallyComputedNode != null) ? ex2._partiallyComputedNode : new Block(CurrentPositionContext()));
					ex2._partiallyComputedNode = new With(context, aST, block);
				}
			}
			finally
			{
				blockType.RemoveAt(blockType.Count - 1);
			}
			return new With(context, aST, block);
		}

		private AST ParseSwitchStatement()
		{
			Context context = currentToken.Clone();
			AST expression = null;
			ASTList aSTList = null;
			blockType.Add(BlockType.Switch);
			try
			{
				GetNextToken();
				if (JSToken.LeftParen != currentToken.token)
				{
					ReportError(JSError.NoLeftParen);
				}
				GetNextToken();
				noSkipTokenSet.Add(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				noSkipTokenSet.Add(NoSkipTokenSet.s_SwitchNoSkipTokenSet);
				try
				{
					expression = ParseExpression();
					if (JSToken.RightParen != currentToken.token)
					{
						ReportError(JSError.NoRightParen);
					}
					GetNextToken();
					if (JSToken.LeftCurly != currentToken.token)
					{
						ReportError(JSError.NoLeftCurly);
					}
					GetNextToken();
				}
				catch (RecoveryTokenException ex)
				{
					if (IndexOfToken(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet, ex) == -1 && IndexOfToken(NoSkipTokenSet.s_SwitchNoSkipTokenSet, ex) == -1)
					{
						ex._partiallyComputedNode = null;
						throw ex;
					}
					expression = ((ex._partiallyComputedNode != null) ? ex._partiallyComputedNode : new ConstantWrapper(true, CurrentPositionContext()));
					if (IndexOfToken(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet, ex) != -1)
					{
						if (ex._token == JSToken.RightParen)
						{
							GetNextToken();
						}
						if (JSToken.LeftCurly != currentToken.token)
						{
							ReportError(JSError.NoLeftCurly);
						}
						GetNextToken();
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_SwitchNoSkipTokenSet);
					noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
				}
				aSTList = new ASTList(currentToken.Clone());
				bool flag = false;
				noSkipTokenSet.Add(NoSkipTokenSet.s_BlockNoSkipTokenSet);
				try
				{
					while (JSToken.RightCurly != currentToken.token)
					{
						SwitchCase switchCase = null;
						AST aST = null;
						Context context2 = currentToken.Clone();
						noSkipTokenSet.Add(NoSkipTokenSet.s_CaseNoSkipTokenSet);
						try
						{
							if (JSToken.Case == currentToken.token)
							{
								GetNextToken();
								aST = ParseExpression();
							}
							else if (JSToken.Default == currentToken.token)
							{
								if (flag)
								{
									ReportError(JSError.DupDefault, skipToken: true);
								}
								else
								{
									flag = true;
								}
								GetNextToken();
							}
							else
							{
								flag = true;
								ReportError(JSError.BadSwitch);
							}
							if (JSToken.Colon != currentToken.token)
							{
								ReportError(JSError.NoColon);
							}
							GetNextToken();
						}
						catch (RecoveryTokenException ex2)
						{
							if (IndexOfToken(NoSkipTokenSet.s_CaseNoSkipTokenSet, ex2) == -1)
							{
								ex2._partiallyComputedNode = null;
								throw ex2;
							}
							aST = ex2._partiallyComputedNode;
							if (ex2._token == JSToken.Colon)
							{
								GetNextToken();
							}
						}
						finally
						{
							noSkipTokenSet.Remove(NoSkipTokenSet.s_CaseNoSkipTokenSet);
						}
						blockType.Add(BlockType.Block);
						try
						{
							Block block = new Block(currentToken.Clone());
							noSkipTokenSet.Add(NoSkipTokenSet.s_SwitchNoSkipTokenSet);
							noSkipTokenSet.Add(NoSkipTokenSet.s_StartStatementNoSkipTokenSet);
							try
							{
								while (JSToken.RightCurly != currentToken.token && JSToken.Case != currentToken.token && JSToken.Default != currentToken.token)
								{
									try
									{
										block.Append(ParseStatement());
									}
									catch (RecoveryTokenException ex3)
									{
										if (ex3._partiallyComputedNode != null)
										{
											block.Append(ex3._partiallyComputedNode);
											ex3._partiallyComputedNode = null;
										}
										if (IndexOfToken(NoSkipTokenSet.s_StartStatementNoSkipTokenSet, ex3) == -1)
										{
											throw ex3;
										}
									}
								}
							}
							catch (RecoveryTokenException ex4)
							{
								if (IndexOfToken(NoSkipTokenSet.s_SwitchNoSkipTokenSet, ex4) == -1)
								{
									switchCase = ((aST != null) ? new SwitchCase(context2, aST, block) : new SwitchCase(context2, block));
									aSTList.Append(switchCase);
									throw ex4;
								}
							}
							finally
							{
								noSkipTokenSet.Remove(NoSkipTokenSet.s_StartStatementNoSkipTokenSet);
								noSkipTokenSet.Remove(NoSkipTokenSet.s_SwitchNoSkipTokenSet);
							}
							if (JSToken.RightCurly == currentToken.token)
							{
								block.context.UpdateWith(currentToken);
							}
							if (aST == null)
							{
								context2.UpdateWith(block.context);
								switchCase = new SwitchCase(context2, block);
							}
							else
							{
								context2.UpdateWith(block.context);
								switchCase = new SwitchCase(context2, aST, block);
							}
							aSTList.Append(switchCase);
						}
						finally
						{
							blockType.RemoveAt(blockType.Count - 1);
						}
					}
				}
				catch (RecoveryTokenException ex5)
				{
					if (IndexOfToken(NoSkipTokenSet.s_BlockNoSkipTokenSet, ex5) == -1)
					{
						context.UpdateWith(CurrentPositionContext());
						ex5._partiallyComputedNode = new Switch(context, expression, aSTList);
						throw ex5;
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockNoSkipTokenSet);
				}
				context.UpdateWith(currentToken);
				GetNextToken();
			}
			finally
			{
				blockType.RemoveAt(blockType.Count - 1);
			}
			return new Switch(context, expression, aSTList);
		}

		private AST ParseThrowStatement()
		{
			Context context = currentToken.Clone();
			GetNextToken();
			AST aST = null;
			if (!scanner.GotEndOfLine() && JSToken.Semicolon != currentToken.token)
			{
				noSkipTokenSet.Add(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet);
				try
				{
					aST = ParseExpression();
				}
				catch (RecoveryTokenException ex)
				{
					aST = ex._partiallyComputedNode;
					if (IndexOfToken(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet, ex) == -1)
					{
						if (aST != null)
						{
							ex._partiallyComputedNode = new Throw(context, ex._partiallyComputedNode);
						}
						throw ex;
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet);
				}
			}
			if (aST != null)
			{
				context.UpdateWith(aST.context);
			}
			return new Throw(context, aST);
		}

		private AST ParseTryStatement()
		{
			Context context = currentToken.Clone();
			Context closingBraceContext = null;
			AST body = null;
			AST aST = null;
			AST aST2 = null;
			AST aST3 = null;
			RecoveryTokenException ex = null;
			TypeExpression typeExpression = null;
			blockType.Add(BlockType.Block);
			try
			{
				bool flag = false;
				bool flag2 = false;
				GetNextToken();
				if (JSToken.LeftCurly != currentToken.token)
				{
					ReportError(JSError.NoLeftCurly);
				}
				noSkipTokenSet.Add(NoSkipTokenSet.s_NoTrySkipTokenSet);
				try
				{
					body = ParseBlock(out closingBraceContext);
				}
				catch (RecoveryTokenException ex2)
				{
					if (IndexOfToken(NoSkipTokenSet.s_NoTrySkipTokenSet, ex2) == -1)
					{
						throw ex2;
					}
					body = ex2._partiallyComputedNode;
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_NoTrySkipTokenSet);
				}
				while (JSToken.Catch == currentToken.token)
				{
					noSkipTokenSet.Add(NoSkipTokenSet.s_NoTrySkipTokenSet);
					try
					{
						if (aST2 != null)
						{
							body = new Try(context, body, aST, typeExpression, aST2, null, finallyHasControlFlowOutOfIt: false, closingBraceContext);
							aST = null;
							typeExpression = null;
							aST2 = null;
						}
						flag = true;
						GetNextToken();
						if (JSToken.LeftParen != currentToken.token)
						{
							ReportError(JSError.NoLeftParen);
						}
						GetNextToken();
						if (JSToken.Identifier != currentToken.token)
						{
							string text = JSKeyword.CanBeIdentifier(currentToken.token);
							if (text != null)
							{
								ForceReportInfo(JSError.KeywordUsedAsIdentifier);
								aST = new Lookup(text, currentToken.Clone());
							}
							else
							{
								ReportError(JSError.NoIdentifier);
								aST = new Lookup("##Exc##" + s_cDummyName++, CurrentPositionContext());
							}
						}
						else
						{
							aST = new Lookup(scanner.GetIdentifier(), currentToken.Clone());
						}
						GetNextToken();
						noSkipTokenSet.Add(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
						try
						{
							if (JSToken.Colon == currentToken.token)
							{
								typeExpression = ParseTypeExpression();
							}
							else
							{
								if (flag2)
								{
									ForceReportInfo(aST.context, JSError.UnreachableCatch);
								}
								flag2 = true;
							}
							if (JSToken.RightParen != currentToken.token)
							{
								ReportError(JSError.NoRightParen);
							}
							GetNextToken();
						}
						catch (RecoveryTokenException ex3)
						{
							if (IndexOfToken(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet, ex3) == -1)
							{
								ex3._partiallyComputedNode = null;
								throw ex3;
							}
							typeExpression = (TypeExpression)ex3._partiallyComputedNode;
							if (currentToken.token == JSToken.RightParen)
							{
								GetNextToken();
							}
						}
						finally
						{
							noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockConditionNoSkipTokenSet);
						}
						if (JSToken.LeftCurly != currentToken.token)
						{
							ReportError(JSError.NoLeftCurly);
						}
						aST2 = ParseBlock();
						context.UpdateWith(aST2.context);
					}
					catch (RecoveryTokenException ex4)
					{
						aST2 = ((ex4._partiallyComputedNode != null) ? ex4._partiallyComputedNode : new Block(CurrentPositionContext()));
						if (IndexOfToken(NoSkipTokenSet.s_NoTrySkipTokenSet, ex4) == -1)
						{
							if (typeExpression != null)
							{
								ex4._partiallyComputedNode = new Try(context, body, aST, typeExpression, aST2, null, finallyHasControlFlowOutOfIt: false, closingBraceContext);
							}
							throw ex4;
						}
					}
					finally
					{
						noSkipTokenSet.Remove(NoSkipTokenSet.s_NoTrySkipTokenSet);
					}
				}
				try
				{
					if (JSToken.Finally == currentToken.token)
					{
						GetNextToken();
						blockType.Add(BlockType.Finally);
						try
						{
							aST3 = ParseBlock();
							flag = true;
						}
						finally
						{
							blockType.RemoveAt(blockType.Count - 1);
						}
						context.UpdateWith(aST3.context);
					}
				}
				catch (RecoveryTokenException ex5)
				{
					ex = ex5;
				}
				if (!flag)
				{
					ReportError(JSError.NoCatch, skipToken: true);
					aST3 = new Block(CurrentPositionContext());
				}
			}
			finally
			{
				blockType.RemoveAt(blockType.Count - 1);
			}
			bool finallyHasControlFlowOutOfIt = false;
			if (finallyEscaped > 0)
			{
				finallyEscaped--;
				finallyHasControlFlowOutOfIt = true;
			}
			if (ex != null)
			{
				ex._partiallyComputedNode = new Try(context, body, aST, typeExpression, aST2, aST3, finallyHasControlFlowOutOfIt, closingBraceContext);
				throw ex;
			}
			return new Try(context, body, aST, typeExpression, aST2, aST3, finallyHasControlFlowOutOfIt, closingBraceContext);
		}

		private AST ParseClass(FieldAttributes visibilitySpec, bool isStatic, Context classCtx, bool isAbstract, bool isFinal, CustomAttributeList customAttributes)
		{
			AST aST = null;
			AST aST2 = null;
			TypeExpression superTypeExpression = null;
			Block block = null;
			ArrayList arrayList = new ArrayList();
			bool flag = JSToken.Interface == currentToken.token;
			GetNextToken();
			if (JSToken.Identifier == currentToken.token)
			{
				aST = new IdentifierLiteral(scanner.GetIdentifier(), currentToken.Clone());
			}
			else
			{
				ReportError(JSError.NoIdentifier);
				if (JSToken.Extends != currentToken.token && JSToken.Implements != currentToken.token && JSToken.LeftCurly != currentToken.token)
				{
					SkipTokensAndThrow();
				}
				aST = new IdentifierLiteral("##Missing Class Name##" + s_cDummyName++, CurrentPositionContext());
			}
			GetNextToken();
			if (JSToken.Extends == currentToken.token || JSToken.Implements == currentToken.token)
			{
				if (flag && JSToken.Extends == currentToken.token)
				{
					currentToken.token = JSToken.Implements;
				}
				if (JSToken.Extends == currentToken.token)
				{
					noSkipTokenSet.Add(NoSkipTokenSet.s_ClassExtendsNoSkipTokenSet);
					try
					{
						aST2 = ParseQualifiedIdentifier(JSError.NeedType);
					}
					catch (RecoveryTokenException ex)
					{
						if (IndexOfToken(NoSkipTokenSet.s_ClassExtendsNoSkipTokenSet, ex) == -1)
						{
							ex._partiallyComputedNode = null;
							throw ex;
						}
						aST2 = ex._partiallyComputedNode;
					}
					finally
					{
						noSkipTokenSet.Remove(NoSkipTokenSet.s_ClassExtendsNoSkipTokenSet);
					}
				}
				if (JSToken.Implements == currentToken.token)
				{
					do
					{
						AST aST3 = null;
						noSkipTokenSet.Add(NoSkipTokenSet.s_ClassImplementsNoSkipTokenSet);
						try
						{
							aST3 = ParseQualifiedIdentifier(JSError.NeedType);
							arrayList.Add(new TypeExpression(aST3));
						}
						catch (RecoveryTokenException ex2)
						{
							if (IndexOfToken(NoSkipTokenSet.s_ClassImplementsNoSkipTokenSet, ex2) == -1)
							{
								ex2._partiallyComputedNode = null;
								throw ex2;
							}
							if (ex2._partiallyComputedNode != null)
							{
								arrayList.Add(new TypeExpression(ex2._partiallyComputedNode));
							}
						}
						finally
						{
							noSkipTokenSet.Remove(NoSkipTokenSet.s_ClassImplementsNoSkipTokenSet);
						}
					}
					while (JSToken.Comma == currentToken.token);
				}
			}
			if (aST2 != null)
			{
				superTypeExpression = new TypeExpression(aST2);
			}
			if (JSToken.LeftCurly != currentToken.token)
			{
				ReportError(JSError.NoLeftCurly);
			}
			ArrayList arrayList2 = blockType;
			blockType = new ArrayList(16);
			SimpleHashtable simpleHashtable = labelTable;
			labelTable = new SimpleHashtable(16u);
			Globals.ScopeStack.Push(new ClassScope(aST, ((IActivationObject)Globals.ScopeStack.Peek()).GetGlobalScope()));
			try
			{
				block = ParseClassBody(isEnum: false, flag);
				classCtx.UpdateWith(block.context);
				TypeExpression[] array = new TypeExpression[arrayList.Count];
				arrayList.CopyTo(array);
				Class @class = new Class(classCtx, aST, superTypeExpression, array, block, visibilitySpec, isAbstract, isFinal, isStatic, flag, customAttributes);
				customAttributes?.SetTarget(@class);
				return @class;
			}
			catch (RecoveryTokenException ex3)
			{
				classCtx.UpdateWith(ex3._partiallyComputedNode.context);
				TypeExpression[] array = new TypeExpression[arrayList.Count];
				arrayList.CopyTo(array);
				ex3._partiallyComputedNode = new Class(classCtx, aST, superTypeExpression, array, (Block)ex3._partiallyComputedNode, visibilitySpec, isAbstract, isFinal, isStatic, flag, customAttributes);
				customAttributes?.SetTarget(ex3._partiallyComputedNode);
				throw ex3;
			}
			finally
			{
				Globals.ScopeStack.Pop();
				blockType = arrayList2;
				labelTable = simpleHashtable;
			}
		}

		private Block ParseClassBody(bool isEnum, bool isInterface)
		{
			blockType.Add(BlockType.Block);
			Block block = new Block(currentToken.Clone());
			try
			{
				GetNextToken();
				noSkipTokenSet.Add(NoSkipTokenSet.s_BlockNoSkipTokenSet);
				JSToken[] array = null;
				array = (isEnum ? NoSkipTokenSet.s_EnumBodyNoSkipTokenSet : ((!isInterface) ? NoSkipTokenSet.s_ClassBodyNoSkipTokenSet : NoSkipTokenSet.s_InterfaceBodyNoSkipTokenSet));
				try
				{
					while (JSToken.RightCurly != currentToken.token)
					{
						if (currentToken.token == JSToken.EndOfFile)
						{
							ReportError(JSError.NoRightCurly, skipToken: true);
							SkipTokensAndThrow();
						}
						noSkipTokenSet.Add(array);
						try
						{
							AST aST = (isEnum ? ParseEnumMember() : ParseClassMember(isInterface));
							if (aST != null)
							{
								block.Append(aST);
							}
						}
						catch (RecoveryTokenException ex)
						{
							if (ex._partiallyComputedNode != null)
							{
								block.Append(ex._partiallyComputedNode);
							}
							if (IndexOfToken(array, ex) == -1)
							{
								ex._partiallyComputedNode = null;
								throw ex;
							}
						}
						finally
						{
							noSkipTokenSet.Remove(array);
						}
					}
				}
				catch (RecoveryTokenException ex2)
				{
					ex2._partiallyComputedNode = block;
					throw ex2;
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockNoSkipTokenSet);
				}
				block.context.UpdateWith(currentToken);
				GetNextToken();
				return block;
			}
			finally
			{
				blockType.RemoveAt(blockType.Count - 1);
			}
		}

		private AST ParseClassMember(bool isInterface)
		{
			bool parsedOK = false;
			if (isInterface && currentToken.token == JSToken.Public)
			{
				GetNextToken();
			}
			switch (currentToken.token)
			{
			case JSToken.RightCurly:
				return null;
			case JSToken.Semicolon:
				GetNextToken();
				return ParseClassMember(isInterface);
			case JSToken.Var:
			case JSToken.Const:
				if (isInterface)
				{
					ReportError(JSError.VarIllegalInInterface, skipToken: true);
					GetNextToken();
					SkipTokensAndThrow();
				}
				return ParseVariableStatement(FieldAttributes.PrivateScope, null, currentToken.token);
			case JSToken.Internal:
			case JSToken.Abstract:
			case JSToken.Public:
			case JSToken.Static:
			case JSToken.Private:
			case JSToken.Protected:
			case JSToken.Final:
				if (isInterface)
				{
					ReportError(JSError.BadModifierInInterface, skipToken: true);
					GetNextToken();
					SkipTokensAndThrow();
				}
				return ParseAttributes(null, unambiguousContext: true, isInsideClass: true, out parsedOK);
			case JSToken.Interface:
				if (isInterface)
				{
					ReportError(JSError.InterfaceIllegalInInterface, skipToken: true);
					GetNextToken();
					SkipTokensAndThrow();
				}
				return ParseClass(FieldAttributes.PrivateScope, isStatic: false, currentToken.Clone(), isAbstract: false, isFinal: false, null);
			case JSToken.Class:
				if (isInterface)
				{
					ReportError(JSError.SyntaxError, skipToken: true);
					GetNextToken();
					SkipTokensAndThrow();
				}
				return ParseClass(FieldAttributes.PrivateScope, isStatic: false, currentToken.Clone(), isAbstract: false, isFinal: false, null);
			case JSToken.Enum:
				return ParseEnum(FieldAttributes.PrivateScope, currentToken.Clone(), null);
			case JSToken.Function:
				return ParseFunction(FieldAttributes.PrivateScope, inExpression: false, currentToken.Clone(), isMethod: true, isInterface, isFinal: false, isInterface, null);
			case JSToken.Identifier:
			{
				if (isInterface)
				{
					ReportError(JSError.SyntaxError, skipToken: true);
					GetNextToken();
					SkipTokensAndThrow();
				}
				bool canBeAttribute = true;
				bool isLeftHandSideExpr;
				AST aST2 = ParseUnaryExpression(out isLeftHandSideExpr, ref canBeAttribute, isMinus: false);
				if (canBeAttribute)
				{
					aST2 = ParseAttributes(aST2, unambiguousContext: true, isInsideClass: true, out parsedOK);
					if (parsedOK)
					{
						return aST2;
					}
				}
				ReportError(JSError.SyntaxError, aST2.context.Clone(), skipToken: true);
				SkipTokensAndThrow();
				return null;
			}
			case JSToken.Import:
				ReportError(JSError.InvalidImport, skipToken: true);
				try
				{
					ParseImportStatement();
				}
				catch (RecoveryTokenException)
				{
				}
				return null;
			case JSToken.Package:
			{
				Context context = currentToken.Clone();
				AST aST = ParsePackage(context);
				if (aST is Package)
				{
					ReportError(JSError.PackageInWrongContext, context, skipToken: true);
				}
				return null;
			}
			default:
				ReportError(JSError.SyntaxError, skipToken: true);
				GetNextToken();
				SkipTokensAndThrow();
				return null;
			}
		}

		private AST ParseEnum(FieldAttributes visibilitySpec, Context enumCtx, CustomAttributeList customAttributes)
		{
			IdentifierLiteral identifierLiteral = null;
			AST aST = null;
			TypeExpression baseType = null;
			Block block = null;
			GetNextToken();
			if (JSToken.Identifier == currentToken.token)
			{
				identifierLiteral = new IdentifierLiteral(scanner.GetIdentifier(), currentToken.Clone());
			}
			else
			{
				ReportError(JSError.NoIdentifier);
				if (JSToken.Colon != currentToken.token && JSToken.LeftCurly != currentToken.token)
				{
					SkipTokensAndThrow();
				}
				identifierLiteral = new IdentifierLiteral("##Missing Enum Name##" + s_cDummyName++, CurrentPositionContext());
			}
			GetNextToken();
			if (JSToken.Colon == currentToken.token)
			{
				noSkipTokenSet.Add(NoSkipTokenSet.s_EnumBaseTypeNoSkipTokenSet);
				try
				{
					aST = ParseQualifiedIdentifier(JSError.NeedType);
				}
				catch (RecoveryTokenException ex)
				{
					if (IndexOfToken(NoSkipTokenSet.s_ClassExtendsNoSkipTokenSet, ex) == -1)
					{
						ex._partiallyComputedNode = null;
						throw ex;
					}
					aST = ex._partiallyComputedNode;
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_EnumBaseTypeNoSkipTokenSet);
				}
			}
			if (aST != null)
			{
				baseType = new TypeExpression(aST);
			}
			if (JSToken.LeftCurly != currentToken.token)
			{
				ReportError(JSError.NoLeftCurly);
			}
			ArrayList arrayList = blockType;
			blockType = new ArrayList(16);
			SimpleHashtable simpleHashtable = labelTable;
			labelTable = new SimpleHashtable(16u);
			Globals.ScopeStack.Push(new ClassScope(identifierLiteral, ((IActivationObject)Globals.ScopeStack.Peek()).GetGlobalScope()));
			try
			{
				block = ParseClassBody(isEnum: true, isInterface: false);
				enumCtx.UpdateWith(block.context);
				EnumDeclaration enumDeclaration = new EnumDeclaration(enumCtx, identifierLiteral, baseType, block, visibilitySpec, customAttributes);
				customAttributes?.SetTarget(enumDeclaration);
				return enumDeclaration;
			}
			catch (RecoveryTokenException ex2)
			{
				enumCtx.UpdateWith(ex2._partiallyComputedNode.context);
				ex2._partiallyComputedNode = new EnumDeclaration(enumCtx, identifierLiteral, baseType, (Block)ex2._partiallyComputedNode, visibilitySpec, customAttributes);
				customAttributes?.SetTarget(ex2._partiallyComputedNode);
				throw ex2;
			}
			finally
			{
				Globals.ScopeStack.Pop();
				blockType = arrayList;
				labelTable = simpleHashtable;
			}
		}

		private AST ParseEnumMember()
		{
			AST result = null;
			Lookup lookup = null;
			AST value = null;
			switch (currentToken.token)
			{
			case JSToken.Semicolon:
				GetNextToken();
				return ParseEnumMember();
			case JSToken.Identifier:
			{
				lookup = new Lookup(currentToken.Clone());
				Context context = currentToken.Clone();
				GetNextToken();
				if (JSToken.Assign == currentToken.token)
				{
					GetNextToken();
					value = ParseExpression(single: true);
				}
				if (JSToken.Comma == currentToken.token)
				{
					GetNextToken();
				}
				else if (JSToken.RightCurly != currentToken.token)
				{
					ReportError(JSError.NoComma, skipToken: true);
				}
				return new Constant(context, lookup, null, value, FieldAttributes.Public, null);
			}
			case JSToken.Var:
				ReportError(JSError.NoVarInEnum, skipToken: true);
				GetNextToken();
				return ParseEnumMember();
			default:
				ReportError(JSError.SyntaxError, skipToken: true);
				SkipTokensAndThrow();
				return result;
			}
		}

		private bool GuessIfAbstract()
		{
			switch (currentToken.token)
			{
			case JSToken.Package:
			case JSToken.Internal:
			case JSToken.Abstract:
			case JSToken.Public:
			case JSToken.Static:
			case JSToken.Private:
			case JSToken.Protected:
			case JSToken.Final:
			case JSToken.Const:
			case JSToken.Class:
			case JSToken.Function:
			case JSToken.Interface:
			case JSToken.RightCurly:
			case JSToken.Enum:
				return true;
			case JSToken.Semicolon:
				GetNextToken();
				return true;
			default:
				return false;
			}
		}

		private AST ParseFunction(FieldAttributes visibilitySpec, bool inExpression, Context fncCtx, bool isMethod, bool isAbstract, bool isFinal, bool isInterface, CustomAttributeList customAttributes)
		{
			return ParseFunction(visibilitySpec, inExpression, fncCtx, isMethod, isAbstract, isFinal, isInterface, customAttributes, null);
		}

		private AST ParseFunction(FieldAttributes visibilitySpec, bool inExpression, Context fncCtx, bool isMethod, bool isAbstract, bool isFinal, bool isInterface, CustomAttributeList customAttributes, Call function)
		{
			if (demandFullTrustOnFunctionCreation)
			{
				new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
			}
			IdentifierLiteral identifierLiteral = null;
			AST aST = null;
			ArrayList arrayList = null;
			TypeExpression return_type = null;
			Block block = null;
			bool flag = false;
			bool flag2 = false;
			if (function == null)
			{
				GetNextToken();
				if (isMethod)
				{
					if (JSToken.Get == currentToken.token)
					{
						flag = true;
						GetNextToken();
					}
					else if (JSToken.Set == currentToken.token)
					{
						flag2 = true;
						GetNextToken();
					}
				}
				if (JSToken.Identifier == currentToken.token)
				{
					identifierLiteral = new IdentifierLiteral(scanner.GetIdentifier(), currentToken.Clone());
					GetNextToken();
					if (JSToken.AccessField == currentToken.token)
					{
						if (isInterface)
						{
							ReportError(JSError.SyntaxError, skipToken: true);
						}
						GetNextToken();
						if (JSToken.Identifier == currentToken.token)
						{
							aST = new Lookup(identifierLiteral.context);
							identifierLiteral = new IdentifierLiteral(scanner.GetIdentifier(), currentToken.Clone());
							GetNextToken();
							while (JSToken.AccessField == currentToken.token)
							{
								GetNextToken();
								if (JSToken.Identifier == currentToken.token)
								{
									aST = new Member(aST.context.CombineWith(currentToken), aST, new ConstantWrapper(identifierLiteral.ToString(), identifierLiteral.context));
									identifierLiteral = new IdentifierLiteral(scanner.GetIdentifier(), currentToken.Clone());
									GetNextToken();
								}
								else
								{
									ReportError(JSError.NoIdentifier, skipToken: true);
								}
							}
						}
						else
						{
							ReportError(JSError.NoIdentifier, skipToken: true);
						}
					}
				}
				else
				{
					string text = JSKeyword.CanBeIdentifier(currentToken.token);
					if (text != null)
					{
						ForceReportInfo(JSError.KeywordUsedAsIdentifier, isMethod);
						identifierLiteral = new IdentifierLiteral(text, currentToken.Clone());
						GetNextToken();
					}
					else
					{
						if (!inExpression)
						{
							text = currentToken.GetCode();
							ReportError(JSError.NoIdentifier, skipToken: true);
							GetNextToken();
						}
						else
						{
							text = "";
						}
						identifierLiteral = new IdentifierLiteral(text, CurrentPositionContext());
					}
				}
			}
			else
			{
				identifierLiteral = function.GetName();
			}
			ArrayList arrayList2 = blockType;
			blockType = new ArrayList(16);
			SimpleHashtable simpleHashtable = labelTable;
			labelTable = new SimpleHashtable(16u);
			FunctionScope functionScope = new FunctionScope(Globals.ScopeStack.Peek(), isMethod);
			Globals.ScopeStack.Push(functionScope);
			try
			{
				arrayList = new ArrayList();
				Context context = null;
				if (function == null)
				{
					if (JSToken.LeftParen != currentToken.token)
					{
						ReportError(JSError.NoLeftParen);
					}
					GetNextToken();
					while (JSToken.RightParen != currentToken.token)
					{
						if (context != null)
						{
							ReportError(JSError.ParamListNotLast, context, skipToken: true);
							context = null;
						}
						string text2 = null;
						TypeExpression typeExpression = null;
						noSkipTokenSet.Add(NoSkipTokenSet.s_FunctionDeclNoSkipTokenSet);
						try
						{
							if (JSToken.ParamArray == currentToken.token)
							{
								context = currentToken.Clone();
								GetNextToken();
							}
							if (JSToken.Identifier != currentToken.token && (text2 = JSKeyword.CanBeIdentifier(currentToken.token)) == null)
							{
								if (JSToken.LeftCurly == currentToken.token)
								{
									ReportError(JSError.NoRightParen);
									break;
								}
								if (JSToken.Comma == currentToken.token)
								{
									ReportError(JSError.SyntaxError, skipToken: true);
								}
								else
								{
									ReportError(JSError.SyntaxError, skipToken: true);
									SkipTokensAndThrow();
								}
								goto IL_0408;
							}
							if (text2 == null)
							{
								text2 = scanner.GetIdentifier();
							}
							else
							{
								ForceReportInfo(JSError.KeywordUsedAsIdentifier);
							}
							Context context2 = currentToken.Clone();
							GetNextToken();
							if (JSToken.Colon == currentToken.token)
							{
								typeExpression = ParseTypeExpression();
								if (typeExpression != null)
								{
									context2.UpdateWith(typeExpression.context);
								}
							}
							CustomAttributeList customAttributeList = null;
							if (context != null)
							{
								customAttributeList = new CustomAttributeList(context);
								customAttributeList.Append(new CustomAttribute(context, new Lookup("...", context), new ASTList(null)));
							}
							arrayList.Add(new ParameterDeclaration(context2, text2, typeExpression, customAttributeList));
							goto IL_0408;
							IL_0472:
							GetNextToken();
							continue;
							IL_0408:
							if (JSToken.RightParen == currentToken.token)
							{
								break;
							}
							if (JSToken.Comma == currentToken.token)
							{
								goto IL_0472;
							}
							if (JSToken.LeftCurly == currentToken.token)
							{
								ReportError(JSError.NoRightParen);
								break;
							}
							if (JSToken.Identifier == currentToken.token && typeExpression == null)
							{
								ReportError(JSError.NoCommaOrTypeDefinitionError);
							}
							else
							{
								ReportError(JSError.NoComma);
							}
							goto IL_0472;
						}
						catch (RecoveryTokenException ex)
						{
							if (IndexOfToken(NoSkipTokenSet.s_FunctionDeclNoSkipTokenSet, ex) == -1)
							{
								throw ex;
							}
							continue;
						}
						finally
						{
							noSkipTokenSet.Remove(NoSkipTokenSet.s_FunctionDeclNoSkipTokenSet);
						}
					}
					fncCtx.UpdateWith(currentToken);
					if (flag && arrayList.Count != 0)
					{
						ReportError(JSError.BadPropertyDeclaration, skipToken: true);
						flag = false;
					}
					else if (flag2 && arrayList.Count != 1)
					{
						ReportError(JSError.BadPropertyDeclaration, skipToken: true);
						flag2 = false;
					}
					GetNextToken();
					if (JSToken.Colon == currentToken.token)
					{
						if (flag2)
						{
							ReportError(JSError.SyntaxError);
						}
						noSkipTokenSet.Add(NoSkipTokenSet.s_StartBlockNoSkipTokenSet);
						try
						{
							return_type = ParseTypeExpression();
						}
						catch (RecoveryTokenException ex2)
						{
							if (IndexOfToken(NoSkipTokenSet.s_StartBlockNoSkipTokenSet, ex2) == -1)
							{
								ex2._partiallyComputedNode = null;
								throw ex2;
							}
							if (ex2._partiallyComputedNode != null)
							{
								return_type = (TypeExpression)ex2._partiallyComputedNode;
							}
						}
						finally
						{
							noSkipTokenSet.Remove(NoSkipTokenSet.s_StartBlockNoSkipTokenSet);
						}
						if (flag2)
						{
							return_type = null;
						}
					}
				}
				else
				{
					function.GetParameters(arrayList);
				}
				if (JSToken.LeftCurly != currentToken.token && (isAbstract || (isMethod && GuessIfAbstract())))
				{
					if (!isAbstract)
					{
						isAbstract = true;
						ReportError(JSError.ShouldBeAbstract, fncCtx, skipToken: true);
					}
					block = new Block(currentToken.Clone());
				}
				else
				{
					if (JSToken.LeftCurly != currentToken.token)
					{
						ReportError(JSError.NoLeftCurly, skipToken: true);
					}
					else if (isAbstract)
					{
						ReportError(JSError.AbstractWithBody, fncCtx, skipToken: true);
					}
					blockType.Add(BlockType.Block);
					noSkipTokenSet.Add(NoSkipTokenSet.s_BlockNoSkipTokenSet);
					noSkipTokenSet.Add(NoSkipTokenSet.s_StartStatementNoSkipTokenSet);
					try
					{
						block = new Block(currentToken.Clone());
						GetNextToken();
						while (JSToken.RightCurly != currentToken.token)
						{
							try
							{
								block.Append(ParseStatement());
							}
							catch (RecoveryTokenException ex3)
							{
								if (ex3._partiallyComputedNode != null)
								{
									block.Append(ex3._partiallyComputedNode);
								}
								if (IndexOfToken(NoSkipTokenSet.s_StartStatementNoSkipTokenSet, ex3) == -1)
								{
									throw ex3;
								}
							}
						}
						block.context.UpdateWith(currentToken);
						fncCtx.UpdateWith(currentToken);
					}
					catch (RecoveryTokenException ex4)
					{
						if (IndexOfToken(NoSkipTokenSet.s_BlockNoSkipTokenSet, ex4) == -1)
						{
							Globals.ScopeStack.Pop();
							try
							{
								ParameterDeclaration[] array = new ParameterDeclaration[arrayList.Count];
								arrayList.CopyTo(array);
								if (inExpression)
								{
									ex4._partiallyComputedNode = new FunctionExpression(fncCtx, identifierLiteral, array, return_type, block, functionScope, visibilitySpec);
								}
								else
								{
									ex4._partiallyComputedNode = new FunctionDeclaration(fncCtx, aST, identifierLiteral, array, return_type, block, functionScope, visibilitySpec, isMethod, flag, flag2, isAbstract, isFinal, customAttributes);
								}
								customAttributes?.SetTarget(ex4._partiallyComputedNode);
							}
							finally
							{
								Globals.ScopeStack.Push(functionScope);
							}
							throw ex4;
						}
					}
					finally
					{
						blockType.RemoveAt(blockType.Count - 1);
						noSkipTokenSet.Remove(NoSkipTokenSet.s_StartStatementNoSkipTokenSet);
						noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockNoSkipTokenSet);
					}
					GetNextToken();
				}
			}
			finally
			{
				blockType = arrayList2;
				labelTable = simpleHashtable;
				Globals.ScopeStack.Pop();
			}
			ParameterDeclaration[] array2 = new ParameterDeclaration[arrayList.Count];
			arrayList.CopyTo(array2);
			AST aST2 = ((!inExpression) ? ((AST)new FunctionDeclaration(fncCtx, aST, identifierLiteral, array2, return_type, block, functionScope, visibilitySpec, isMethod, flag, flag2, isAbstract, isFinal, customAttributes)) : ((AST)new FunctionExpression(fncCtx, identifierLiteral, array2, return_type, block, functionScope, visibilitySpec)));
			customAttributes?.SetTarget(aST2);
			return aST2;
		}

		internal AST ParseFunctionExpression()
		{
			demandFullTrustOnFunctionCreation = true;
			GetNextToken();
			return ParseFunction(FieldAttributes.PrivateScope, inExpression: true, currentToken.Clone(), isMethod: false, isAbstract: false, isFinal: false, isInterface: false, null);
		}

		internal string[] ParseNamedBreakpoint(out int argNumber)
		{
			argNumber = 0;
			AST aST = ParseQualifiedIdentifier(JSError.SyntaxError);
			if (aST != null)
			{
				string[] array = new string[4]
				{
					aST.ToString(),
					null,
					null,
					null
				};
				if (JSToken.LeftParen == currentToken.token)
				{
					string text = null;
					string text2 = null;
					AST aST2 = null;
					array[1] = "";
					GetNextToken();
					while (JSToken.RightParen != currentToken.token)
					{
						text = null;
						if (JSToken.Identifier != currentToken.token && (text = JSKeyword.CanBeIdentifier(currentToken.token)) == null)
						{
							return null;
						}
						if (text == null)
						{
							text = scanner.GetIdentifier();
						}
						aST2 = new Lookup(text, currentToken.Clone());
						GetNextToken();
						if (JSToken.AccessField == currentToken.token)
						{
							aST2 = ParseScopeSequence(aST2, JSError.SyntaxError);
							text2 = aST2.ToString();
							while (JSToken.LeftBracket == currentToken.token)
							{
								GetNextToken();
								if (JSToken.RightBracket != currentToken.token)
								{
									return null;
								}
								text2 += "[]";
								GetNextToken();
							}
						}
						else
						{
							if (JSToken.Colon == currentToken.token)
							{
								GetNextToken();
								if (JSToken.RightParen == currentToken.token)
								{
									return null;
								}
								continue;
							}
							text2 = aST2.ToString();
						}
						ref string reference = ref array[1];
						reference = reference + text2 + " ";
						argNumber++;
						if (JSToken.Comma == currentToken.token)
						{
							GetNextToken();
							if (JSToken.RightParen == currentToken.token)
							{
								return null;
							}
						}
					}
					GetNextToken();
					if (JSToken.Colon == currentToken.token)
					{
						GetNextToken();
						text = null;
						if (JSToken.Identifier != currentToken.token && (text = JSKeyword.CanBeIdentifier(currentToken.token)) == null)
						{
							return null;
						}
						if (text == null)
						{
							text = scanner.GetIdentifier();
						}
						aST2 = new Lookup(text, currentToken.Clone());
						GetNextToken();
						if (JSToken.AccessField == currentToken.token)
						{
							aST2 = ParseScopeSequence(aST2, JSError.SyntaxError);
							array[2] = aST2.ToString();
							while (JSToken.LeftBracket == currentToken.token)
							{
								GetNextToken();
								if (JSToken.RightBracket != currentToken.token)
								{
									return null;
								}
								array[2] += "[]";
								GetNextToken();
							}
						}
						else
						{
							array[2] = aST2.ToString();
						}
					}
				}
				if (JSToken.FirstBinaryOp == currentToken.token)
				{
					GetNextToken();
					if (JSToken.IntegerLiteral != currentToken.token)
					{
						return null;
					}
					array[3] = currentToken.GetCode();
					GetNextToken();
				}
				if (currentToken.token != 0)
				{
					return null;
				}
				return array;
			}
			return null;
		}

		private AST ParsePackage(Context packageContext)
		{
			GetNextToken();
			AST aST = null;
			bool flag = scanner.GotEndOfLine();
			if (JSToken.Identifier != currentToken.token)
			{
				if (JSScanner.CanParseAsExpression(currentToken.token))
				{
					ReportError(JSError.KeywordUsedAsIdentifier, packageContext.Clone(), skipToken: true);
					aST = new Lookup("package", packageContext);
					aST = MemberExpression(aST, null);
					aST = ParsePostfixExpression(aST, out var isLeftHandSideExpr);
					aST = ParseExpression(aST, single: false, isLeftHandSideExpr, JSToken.None);
					return new Expression(aST.context.Clone(), aST);
				}
				if (flag)
				{
					ReportError(JSError.KeywordUsedAsIdentifier, packageContext.Clone(), skipToken: true);
					return new Lookup("package", packageContext);
				}
				if (JSToken.Increment == currentToken.token || JSToken.Decrement == currentToken.token)
				{
					ReportError(JSError.KeywordUsedAsIdentifier, packageContext.Clone(), skipToken: true);
					aST = new Lookup("package", packageContext);
					aST = ParsePostfixExpression(aST, out var _);
					aST = ParseExpression(aST, single: false, bCanAssign: false, JSToken.None);
					return new Expression(aST.context.Clone(), aST);
				}
			}
			else
			{
				errorToken = currentToken;
				aST = ParseQualifiedIdentifier(JSError.NoIdentifier);
			}
			Context context = null;
			if (JSToken.LeftCurly != currentToken.token && aST == null)
			{
				context = currentToken.Clone();
				GetNextToken();
			}
			if (JSToken.LeftCurly == currentToken.token)
			{
				if (aST == null)
				{
					if (context == null)
					{
						context = currentToken.Clone();
					}
					ReportError(JSError.NoIdentifier, context, skipToken: true);
				}
			}
			else if (aST == null)
			{
				ReportError(JSError.SyntaxError, packageContext);
				if (JSScanner.CanStartStatement(context.token))
				{
					currentToken = context;
					return ParseStatement();
				}
				if (JSScanner.CanStartStatement(currentToken.token))
				{
					errorToken = null;
					return ParseStatement();
				}
				ReportError(JSError.SyntaxError);
				SkipTokensAndThrow();
			}
			else
			{
				if (flag)
				{
					ReportError(JSError.KeywordUsedAsIdentifier, packageContext.Clone(), skipToken: true);
					Block block = new Block(packageContext.Clone());
					block.Append(new Lookup("package", packageContext));
					aST = MemberExpression(aST, null);
					aST = ParsePostfixExpression(aST, out var _);
					aST = ParseExpression(aST, single: false, bCanAssign: true, JSToken.None);
					block.Append(new Expression(aST.context.Clone(), aST));
					block.context.UpdateWith(aST.context);
					return block;
				}
				ReportError(JSError.NoLeftCurly);
			}
			PackageScope packageScope = new PackageScope(Globals.ScopeStack.Peek());
			Globals.ScopeStack.Push(packageScope);
			try
			{
				string name = (packageScope.name = ((aST != null) ? aST.ToString() : "anonymous package"));
				packageContext.UpdateWith(currentToken);
				ASTList aSTList = new ASTList(packageContext);
				GetNextToken();
				noSkipTokenSet.Add(NoSkipTokenSet.s_BlockNoSkipTokenSet);
				noSkipTokenSet.Add(NoSkipTokenSet.s_PackageBodyNoSkipTokenSet);
				try
				{
					while (currentToken.token != JSToken.RightCurly)
					{
						AST aST2 = null;
						try
						{
							switch (currentToken.token)
							{
							case JSToken.Class:
							case JSToken.Interface:
								aSTList.Append(ParseClass(FieldAttributes.PrivateScope, isStatic: false, currentToken.Clone(), isAbstract: false, isFinal: false, null));
								break;
							case JSToken.Enum:
								aSTList.Append(ParseEnum(FieldAttributes.PrivateScope, currentToken.Clone(), null));
								break;
							case JSToken.Internal:
							case JSToken.Abstract:
							case JSToken.Public:
							case JSToken.Static:
							case JSToken.Private:
							case JSToken.Protected:
							case JSToken.Final:
							{
								aST2 = ParseAttributes(null, unambiguousContext: true, isInsideClass: false, out var parsedOK);
								if (parsedOK && aST2 is Class)
								{
									aSTList.Append(aST2);
									break;
								}
								ReportError(JSError.OnlyClassesAllowed, aST2.context.Clone(), skipToken: true);
								SkipTokensAndThrow();
								break;
							}
							case JSToken.Identifier:
							{
								bool canBeAttribute = true;
								aST2 = ParseUnaryExpression(out var _, ref canBeAttribute, isMinus: false);
								if (canBeAttribute)
								{
									aST2 = ParseAttributes(aST2, unambiguousContext: true, isInsideClass: false, out var parsedOK2);
									if (parsedOK2 && aST2 is Class)
									{
										aSTList.Append(aST2);
										break;
									}
								}
								ReportError(JSError.OnlyClassesAllowed, aST2.context.Clone(), skipToken: true);
								SkipTokensAndThrow();
								break;
							}
							case JSToken.EndOfFile:
								EOFError(JSError.ErrEOF);
								throw new EndOfFile();
							case JSToken.Semicolon:
								GetNextToken();
								break;
							case JSToken.Import:
								ReportError(JSError.InvalidImport, skipToken: true);
								try
								{
									ParseImportStatement();
								}
								catch (RecoveryTokenException)
								{
								}
								break;
							case JSToken.Package:
							{
								Context context2 = currentToken.Clone();
								AST aST3 = ParsePackage(context2);
								if (aST3 is Package)
								{
									ReportError(JSError.PackageInWrongContext, context2, skipToken: true);
								}
								break;
							}
							default:
								ReportError(JSError.OnlyClassesAllowed, (aST2 != null) ? aST2.context.Clone() : CurrentPositionContext(), skipToken: true);
								SkipTokensAndThrow();
								break;
							}
						}
						catch (RecoveryTokenException ex2)
						{
							if (ex2._partiallyComputedNode != null && ex2._partiallyComputedNode is Class)
							{
								aSTList.Append((Class)ex2._partiallyComputedNode);
								ex2._partiallyComputedNode = null;
							}
							if (IndexOfToken(NoSkipTokenSet.s_PackageBodyNoSkipTokenSet, ex2) == -1)
							{
								throw ex2;
							}
						}
					}
				}
				catch (RecoveryTokenException ex3)
				{
					if (IndexOfToken(NoSkipTokenSet.s_BlockNoSkipTokenSet, ex3) == -1)
					{
						ReportError(JSError.NoRightCurly, CurrentPositionContext());
						ex3._partiallyComputedNode = new Package(name, aST, aSTList, packageContext);
						throw ex3;
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_PackageBodyNoSkipTokenSet);
					noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockNoSkipTokenSet);
				}
				GetNextToken();
				return new Package(name, aST, aSTList, packageContext);
			}
			finally
			{
				Globals.ScopeStack.Pop();
			}
		}

		private AST ParseStaticInitializer(Context initContext)
		{
			if (demandFullTrustOnFunctionCreation)
			{
				new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
			}
			Block block = null;
			FunctionScope functionScope = new FunctionScope(Globals.ScopeStack.Peek());
			functionScope.isStatic = true;
			ArrayList arrayList = blockType;
			blockType = new ArrayList(16);
			SimpleHashtable simpleHashtable = labelTable;
			labelTable = new SimpleHashtable(16u);
			blockType.Add(BlockType.Block);
			noSkipTokenSet.Add(NoSkipTokenSet.s_BlockNoSkipTokenSet);
			noSkipTokenSet.Add(NoSkipTokenSet.s_StartStatementNoSkipTokenSet);
			try
			{
				Globals.ScopeStack.Push(functionScope);
				block = new Block(currentToken.Clone());
				GetNextToken();
				while (JSToken.RightCurly != currentToken.token)
				{
					try
					{
						block.Append(ParseStatement());
					}
					catch (RecoveryTokenException ex)
					{
						if (ex._partiallyComputedNode != null)
						{
							block.Append(ex._partiallyComputedNode);
						}
						if (IndexOfToken(NoSkipTokenSet.s_StartStatementNoSkipTokenSet, ex) == -1)
						{
							throw ex;
						}
					}
				}
			}
			catch (RecoveryTokenException ex2)
			{
				if (IndexOfToken(NoSkipTokenSet.s_BlockNoSkipTokenSet, ex2) == -1)
				{
					ex2._partiallyComputedNode = new StaticInitializer(initContext, block, functionScope);
					throw ex2;
				}
			}
			finally
			{
				noSkipTokenSet.Remove(NoSkipTokenSet.s_StartStatementNoSkipTokenSet);
				noSkipTokenSet.Remove(NoSkipTokenSet.s_BlockNoSkipTokenSet);
				blockType = arrayList;
				labelTable = simpleHashtable;
				Globals.ScopeStack.Pop();
			}
			block.context.UpdateWith(currentToken);
			initContext.UpdateWith(currentToken);
			GetNextToken();
			return new StaticInitializer(initContext, block, functionScope);
		}

		private AST ParseExpression()
		{
			bool isLeftHandSideExpr;
			AST leftHandSide = ParseUnaryExpression(out isLeftHandSideExpr, isMinus: false);
			return ParseExpression(leftHandSide, single: false, isLeftHandSideExpr, JSToken.None);
		}

		private AST ParseExpression(bool single)
		{
			bool isLeftHandSideExpr;
			AST leftHandSide = ParseUnaryExpression(out isLeftHandSideExpr, isMinus: false);
			return ParseExpression(leftHandSide, single, isLeftHandSideExpr, JSToken.None);
		}

		private AST ParseExpression(bool single, JSToken inToken)
		{
			bool isLeftHandSideExpr;
			AST leftHandSide = ParseUnaryExpression(out isLeftHandSideExpr, isMinus: false);
			return ParseExpression(leftHandSide, single, isLeftHandSideExpr, inToken);
		}

		private AST ParseExpression(AST leftHandSide, bool single, bool bCanAssign, JSToken inToken)
		{
			OpListItem opListItem = new OpListItem(JSToken.None, OpPrec.precNone, null);
			AstListItem astListItem = new AstListItem(leftHandSide, null);
			AST aST = null;
			try
			{
				while (JSScanner.IsProcessableOperator(currentToken.token) && inToken != currentToken.token)
				{
					OpPrec operatorPrecedence = JSScanner.GetOperatorPrecedence(currentToken.token);
					bool flag = JSScanner.IsRightAssociativeOperator(currentToken.token);
					while (operatorPrecedence < opListItem._prec || (operatorPrecedence == opListItem._prec && !flag))
					{
						aST = CreateExpressionNode(opListItem._operator, astListItem._prev._term, astListItem._term);
						opListItem = opListItem._prev;
						astListItem = astListItem._prev._prev;
						astListItem = new AstListItem(aST, astListItem);
					}
					if (JSToken.ConditionalIf == currentToken.token)
					{
						AST term = astListItem._term;
						astListItem = astListItem._prev;
						GetNextToken();
						AST operand = ParseExpression(single: true);
						if (JSToken.Colon != currentToken.token)
						{
							ReportError(JSError.NoColon);
						}
						GetNextToken();
						AST aST2 = ParseExpression(single: true, inToken);
						aST = new Conditional(term.context.CombineWith(aST2.context), term, operand, aST2);
						astListItem = new AstListItem(aST, astListItem);
						continue;
					}
					if (JSScanner.IsAssignmentOperator(currentToken.token))
					{
						if (!bCanAssign)
						{
							ReportError(JSError.IllegalAssignment);
							SkipTokensAndThrow();
						}
					}
					else
					{
						bCanAssign = false;
					}
					opListItem = new OpListItem(currentToken.token, operatorPrecedence, opListItem);
					GetNextToken();
					if (bCanAssign)
					{
						astListItem = new AstListItem(ParseUnaryExpression(out bCanAssign, isMinus: false), astListItem);
						continue;
					}
					astListItem = new AstListItem(ParseUnaryExpression(out var isLeftHandSideExpr, isMinus: false), astListItem);
					isLeftHandSideExpr = isLeftHandSideExpr;
				}
				while (opListItem._operator != JSToken.None)
				{
					aST = CreateExpressionNode(opListItem._operator, astListItem._prev._term, astListItem._term);
					opListItem = opListItem._prev;
					astListItem = astListItem._prev._prev;
					astListItem = new AstListItem(aST, astListItem);
				}
				if (!single && JSToken.Comma == currentToken.token)
				{
					GetNextToken();
					AST aST3 = ParseExpression(single: false, inToken);
					astListItem._term = new Comma(astListItem._term.context.CombineWith(aST3.context), astListItem._term, aST3);
				}
				return astListItem._term;
			}
			catch (RecoveryTokenException ex)
			{
				ex._partiallyComputedNode = leftHandSide;
				throw ex;
			}
		}

		private AST ParseUnaryExpression(out bool isLeftHandSideExpr, bool isMinus)
		{
			bool canBeAttribute = false;
			return ParseUnaryExpression(out isLeftHandSideExpr, ref canBeAttribute, isMinus, warnForKeyword: false);
		}

		private AST ParseUnaryExpression(out bool isLeftHandSideExpr, ref bool canBeAttribute, bool isMinus)
		{
			return ParseUnaryExpression(out isLeftHandSideExpr, ref canBeAttribute, isMinus, warnForKeyword: true);
		}

		private AST ParseUnaryExpression(out bool isLeftHandSideExpr, ref bool canBeAttribute, bool isMinus, bool warnForKeyword)
		{
			AST ast = null;
			isLeftHandSideExpr = false;
			bool isLeftHandSideExpr2 = false;
			Context context = null;
			AST aST = null;
			switch (currentToken.token)
			{
			case JSToken.Void:
				context = currentToken.Clone();
				GetNextToken();
				canBeAttribute = false;
				aST = ParseUnaryExpression(out isLeftHandSideExpr2, ref canBeAttribute, isMinus: false);
				context.UpdateWith(aST.context);
				ast = new VoidOp(context, aST);
				break;
			case JSToken.Typeof:
				context = currentToken.Clone();
				GetNextToken();
				canBeAttribute = false;
				aST = ParseUnaryExpression(out isLeftHandSideExpr2, ref canBeAttribute, isMinus: false);
				context.UpdateWith(aST.context);
				ast = new Typeof(context, aST);
				break;
			case JSToken.FirstBinaryOp:
				context = currentToken.Clone();
				GetNextToken();
				canBeAttribute = false;
				aST = ParseUnaryExpression(out isLeftHandSideExpr2, ref canBeAttribute, isMinus: false);
				context.UpdateWith(aST.context);
				ast = new NumericUnary(context, aST, JSToken.FirstBinaryOp);
				break;
			case JSToken.Minus:
				context = currentToken.Clone();
				GetNextToken();
				canBeAttribute = false;
				aST = ParseUnaryExpression(out isLeftHandSideExpr2, ref canBeAttribute, isMinus: true);
				if (aST.context.token == JSToken.NumericLiteral)
				{
					context.UpdateWith(aST.context);
					aST.context = context;
					ast = aST;
				}
				else
				{
					context.UpdateWith(aST.context);
					ast = new NumericUnary(context, aST, JSToken.Minus);
				}
				break;
			case JSToken.BitwiseNot:
				context = currentToken.Clone();
				GetNextToken();
				canBeAttribute = false;
				aST = ParseUnaryExpression(out isLeftHandSideExpr2, ref canBeAttribute, isMinus: false);
				context.UpdateWith(aST.context);
				ast = new NumericUnary(context, aST, JSToken.BitwiseNot);
				break;
			case JSToken.FirstOp:
				context = currentToken.Clone();
				GetNextToken();
				canBeAttribute = false;
				aST = ParseUnaryExpression(out isLeftHandSideExpr2, ref canBeAttribute, isMinus: false);
				context.UpdateWith(aST.context);
				ast = new NumericUnary(context, aST, JSToken.FirstOp);
				break;
			case JSToken.Delete:
				context = currentToken.Clone();
				GetNextToken();
				canBeAttribute = false;
				aST = ParseUnaryExpression(out isLeftHandSideExpr2, ref canBeAttribute, isMinus: false);
				context.UpdateWith(aST.context);
				ast = new Delete(context, aST);
				break;
			case JSToken.Increment:
				context = currentToken.Clone();
				GetNextToken();
				canBeAttribute = false;
				aST = ParseUnaryExpression(out isLeftHandSideExpr2, ref canBeAttribute, isMinus: false);
				context.UpdateWith(aST.context);
				ast = new PostOrPrefixOperator(context, aST, PostOrPrefix.PrefixIncrement);
				break;
			case JSToken.Decrement:
				context = currentToken.Clone();
				GetNextToken();
				canBeAttribute = false;
				aST = ParseUnaryExpression(out isLeftHandSideExpr2, ref canBeAttribute, isMinus: false);
				context.UpdateWith(aST.context);
				ast = new PostOrPrefixOperator(context, aST, PostOrPrefix.PrefixDecrement);
				break;
			default:
				noSkipTokenSet.Add(NoSkipTokenSet.s_PostfixExpressionNoSkipTokenSet);
				try
				{
					ast = ParseLeftHandSideExpression(isMinus, ref canBeAttribute, warnForKeyword);
				}
				catch (RecoveryTokenException ex)
				{
					if (IndexOfToken(NoSkipTokenSet.s_PostfixExpressionNoSkipTokenSet, ex) == -1)
					{
						throw ex;
					}
					if (ex._partiallyComputedNode == null)
					{
						SkipTokensAndThrow();
					}
					else
					{
						ast = ex._partiallyComputedNode;
					}
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_PostfixExpressionNoSkipTokenSet);
				}
				ast = ParsePostfixExpression(ast, out isLeftHandSideExpr, ref canBeAttribute);
				break;
			}
			isLeftHandSideExpr2 = isLeftHandSideExpr2;
			return ast;
		}

		private AST ParsePostfixExpression(AST ast, out bool isLeftHandSideExpr)
		{
			bool canBeAttribute = false;
			return ParsePostfixExpression(ast, out isLeftHandSideExpr, ref canBeAttribute);
		}

		private AST ParsePostfixExpression(AST ast, out bool isLeftHandSideExpr, ref bool canBeAttribute)
		{
			isLeftHandSideExpr = true;
			Context context = null;
			if (ast != null && !scanner.GotEndOfLine())
			{
				if (JSToken.Increment == currentToken.token)
				{
					isLeftHandSideExpr = false;
					context = ast.context.Clone();
					context.UpdateWith(currentToken);
					canBeAttribute = false;
					ast = new PostOrPrefixOperator(context, ast, PostOrPrefix.PostfixIncrement);
					GetNextToken();
				}
				else if (JSToken.Decrement == currentToken.token)
				{
					isLeftHandSideExpr = false;
					context = ast.context.Clone();
					context.UpdateWith(currentToken);
					canBeAttribute = false;
					ast = new PostOrPrefixOperator(context, ast, PostOrPrefix.PostfixDecrement);
					GetNextToken();
				}
			}
			return ast;
		}

		private AST ParseLeftHandSideExpression()
		{
			return ParseLeftHandSideExpression(isMinus: false);
		}

		private AST ParseLeftHandSideExpression(bool isMinus)
		{
			bool canBeAttribute = false;
			return ParseLeftHandSideExpression(isMinus, ref canBeAttribute, warnForKeyword: false);
		}

		private AST ParseLeftHandSideExpression(bool isMinus, ref bool canBeAttribute, bool warnForKeyword)
		{
			AST aST = null;
			bool flag = false;
			ArrayList arrayList = null;
			while (JSToken.New == currentToken.token)
			{
				if (arrayList == null)
				{
					arrayList = new ArrayList(4);
				}
				arrayList.Add(currentToken.Clone());
				GetNextToken();
			}
			switch (currentToken.token)
			{
			case JSToken.Identifier:
				aST = new Lookup(scanner.GetIdentifier(), currentToken.Clone());
				break;
			case JSToken.This:
				canBeAttribute = false;
				aST = new ThisLiteral(currentToken.Clone(), isSuper: false);
				break;
			case JSToken.Super:
				canBeAttribute = false;
				aST = new ThisLiteral(currentToken.Clone(), isSuper: true);
				break;
			case JSToken.StringLiteral:
				canBeAttribute = false;
				aST = new ConstantWrapper(scanner.GetStringLiteral(), currentToken.Clone());
				break;
			case JSToken.IntegerLiteral:
			{
				canBeAttribute = false;
				string code2 = currentToken.GetCode();
				object obj = Convert.LiteralToNumber(code2, currentToken);
				if (obj == null)
				{
					obj = 0;
				}
				aST = new ConstantWrapper(obj, currentToken.Clone());
				((ConstantWrapper)aST).isNumericLiteral = true;
				break;
			}
			case JSToken.NumericLiteral:
			{
				canBeAttribute = false;
				string str = (isMinus ? ("-" + currentToken.GetCode()) : currentToken.GetCode());
				double num2 = Convert.ToNumber(str, hexOK: false, octalOK: false, Missing.Value);
				aST = new ConstantWrapper(num2, currentToken.Clone());
				((ConstantWrapper)aST).isNumericLiteral = true;
				break;
			}
			case JSToken.True:
				canBeAttribute = false;
				aST = new ConstantWrapper(true, currentToken.Clone());
				break;
			case JSToken.False:
				canBeAttribute = false;
				aST = new ConstantWrapper(false, currentToken.Clone());
				break;
			case JSToken.Null:
				canBeAttribute = false;
				aST = new NullLiteral(currentToken.Clone());
				break;
			case JSToken.PreProcessorConstant:
				canBeAttribute = false;
				aST = new ConstantWrapper(scanner.GetPreProcessorValue(), currentToken.Clone());
				break;
			case JSToken.Divide:
			{
				canBeAttribute = false;
				string text2 = scanner.ScanRegExp();
				if (text2 != null)
				{
					bool flag2 = false;
					try
					{
						new Regex(text2, RegexOptions.ECMAScript);
					}
					catch (ArgumentException)
					{
						text2 = "";
						flag2 = true;
					}
					string text3 = scanner.ScanRegExpFlags();
					if (text3 == null)
					{
						aST = new RegExpLiteral(text2, null, currentToken.Clone());
					}
					else
					{
						try
						{
							aST = new RegExpLiteral(text2, text3, currentToken.Clone());
						}
						catch (JScriptException)
						{
							aST = new RegExpLiteral(text2, null, currentToken.Clone());
							flag2 = true;
						}
					}
					if (flag2)
					{
						ReportError(JSError.RegExpSyntax, skipToken: true);
					}
					break;
				}
				goto default;
			}
			case JSToken.LeftParen:
				canBeAttribute = false;
				GetNextToken();
				noSkipTokenSet.Add(NoSkipTokenSet.s_ParenExpressionNoSkipToken);
				try
				{
					aST = ParseExpression();
					if (JSToken.RightParen != currentToken.token)
					{
						ReportError(JSError.NoRightParen);
					}
				}
				catch (RecoveryTokenException ex4)
				{
					if (IndexOfToken(NoSkipTokenSet.s_ParenExpressionNoSkipToken, ex4) == -1)
					{
						throw ex4;
					}
					aST = ex4._partiallyComputedNode;
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_ParenExpressionNoSkipToken);
				}
				if (aST == null)
				{
					SkipTokensAndThrow();
				}
				break;
			case JSToken.LeftBracket:
			{
				canBeAttribute = false;
				Context context2 = currentToken.Clone();
				ASTList aSTList3 = new ASTList(currentToken.Clone());
				GetNextToken();
				if (currentToken.token == JSToken.Identifier && scanner.PeekToken() == JSToken.Colon)
				{
					noSkipTokenSet.Add(NoSkipTokenSet.s_BracketToken);
					try
					{
						if (currentToken.GetCode() == "assembly")
						{
							GetNextToken();
							GetNextToken();
							return new AssemblyCustomAttributeList(ParseCustomAttributeList());
						}
						ReportError(JSError.ExpectedAssembly);
						SkipTokensAndThrow();
					}
					catch (RecoveryTokenException ex2)
					{
						ex2._partiallyComputedNode = new Block(context2);
						return ex2._partiallyComputedNode;
					}
					finally
					{
						if (currentToken.token == JSToken.RightBracket)
						{
							errorToken = null;
							GetNextToken();
						}
						noSkipTokenSet.Remove(NoSkipTokenSet.s_BracketToken);
					}
				}
				while (JSToken.RightBracket != currentToken.token)
				{
					if (JSToken.Comma != currentToken.token)
					{
						noSkipTokenSet.Add(NoSkipTokenSet.s_ArrayInitNoSkipTokenSet);
						try
						{
							aSTList3.Append(ParseExpression(single: true));
							if (JSToken.Comma != currentToken.token)
							{
								if (JSToken.RightBracket != currentToken.token)
								{
									ReportError(JSError.NoRightBracket);
								}
								break;
							}
						}
						catch (RecoveryTokenException ex3)
						{
							if (ex3._partiallyComputedNode != null)
							{
								aSTList3.Append(ex3._partiallyComputedNode);
							}
							if (IndexOfToken(NoSkipTokenSet.s_ArrayInitNoSkipTokenSet, ex3) == -1)
							{
								context2.UpdateWith(CurrentPositionContext());
								ex3._partiallyComputedNode = new ArrayLiteral(context2, aSTList3);
								throw ex3;
							}
							if (JSToken.RightBracket == currentToken.token)
							{
								break;
							}
						}
						finally
						{
							noSkipTokenSet.Remove(NoSkipTokenSet.s_ArrayInitNoSkipTokenSet);
						}
					}
					else
					{
						aSTList3.Append(new ConstantWrapper(Missing.Value, currentToken.Clone()));
					}
					GetNextToken();
				}
				context2.UpdateWith(currentToken);
				aST = new ArrayLiteral(context2, aSTList3);
				break;
			}
			case JSToken.LeftCurly:
			{
				canBeAttribute = false;
				Context context = currentToken.Clone();
				GetNextToken();
				ASTList aSTList = new ASTList(currentToken.Clone());
				if (JSToken.RightCurly != currentToken.token)
				{
					while (true)
					{
						AST aST2 = null;
						AST aST3 = null;
						if (JSToken.Identifier == currentToken.token)
						{
							aST2 = new ConstantWrapper(scanner.GetIdentifier(), currentToken.Clone());
						}
						else if (JSToken.StringLiteral == currentToken.token)
						{
							aST2 = new ConstantWrapper(scanner.GetStringLiteral(), currentToken.Clone());
						}
						else if (JSToken.IntegerLiteral == currentToken.token || JSToken.NumericLiteral == currentToken.token)
						{
							string code = currentToken.GetCode();
							double num = Convert.ToNumber(code, hexOK: true, octalOK: true, Missing.Value);
							aST2 = new ConstantWrapper(num, currentToken.Clone());
							((ConstantWrapper)aST2).isNumericLiteral = true;
						}
						else
						{
							ReportError(JSError.NoMemberIdentifier);
							aST2 = new IdentifierLiteral("_#Missing_Field#_" + s_cDummyName++, CurrentPositionContext());
						}
						ASTList aSTList2 = new ASTList(aST2.context.Clone());
						GetNextToken();
						noSkipTokenSet.Add(NoSkipTokenSet.s_ObjectInitNoSkipTokenSet);
						try
						{
							if (JSToken.Colon != currentToken.token)
							{
								ReportError(JSError.NoColon, skipToken: true);
								aST3 = ParseExpression(single: true);
							}
							else
							{
								GetNextToken();
								aST3 = ParseExpression(single: true);
							}
							aSTList2.Append(aST2);
							aSTList2.Append(aST3);
							aSTList.Append(aSTList2);
							if (JSToken.RightCurly == currentToken.token)
							{
								break;
							}
							if (JSToken.Comma == currentToken.token)
							{
								GetNextToken();
								continue;
							}
							if (scanner.GotEndOfLine())
							{
								ReportError(JSError.NoRightCurly);
							}
							else
							{
								ReportError(JSError.NoComma, skipToken: true);
							}
							SkipTokensAndThrow();
							continue;
						}
						catch (RecoveryTokenException ex)
						{
							if (ex._partiallyComputedNode != null)
							{
								aST3 = ex._partiallyComputedNode;
								aSTList2.Append(aST2);
								aSTList2.Append(aST3);
								aSTList.Append(aSTList2);
							}
							if (IndexOfToken(NoSkipTokenSet.s_ObjectInitNoSkipTokenSet, ex) == -1)
							{
								ex._partiallyComputedNode = new ObjectLiteral(context, aSTList);
								throw ex;
							}
							if (JSToken.Comma == currentToken.token)
							{
								GetNextToken();
							}
							if (JSToken.RightCurly == currentToken.token)
							{
								break;
							}
							continue;
						}
						finally
						{
							noSkipTokenSet.Remove(NoSkipTokenSet.s_ObjectInitNoSkipTokenSet);
						}
					}
				}
				aSTList.context.UpdateWith(currentToken);
				context.UpdateWith(currentToken);
				aST = new ObjectLiteral(context, aSTList);
				break;
			}
			case JSToken.Function:
				canBeAttribute = false;
				aST = ParseFunction(FieldAttributes.PrivateScope, inExpression: true, currentToken.Clone(), isMethod: false, isAbstract: false, isFinal: false, isInterface: false, null);
				flag = true;
				break;
			default:
			{
				string text = JSKeyword.CanBeIdentifier(currentToken.token);
				if (text != null)
				{
					if (warnForKeyword)
					{
						switch (currentToken.token)
						{
						default:
							ForceReportInfo(JSError.KeywordUsedAsIdentifier);
							break;
						case JSToken.Void:
						case JSToken.Boolean:
						case JSToken.Byte:
						case JSToken.Char:
						case JSToken.Double:
						case JSToken.Float:
						case JSToken.Int:
						case JSToken.Long:
						case JSToken.Short:
							break;
						}
					}
					canBeAttribute = false;
					aST = new Lookup(text, currentToken.Clone());
				}
				else
				{
					if (currentToken.token == JSToken.BitwiseAnd)
					{
						ReportError(JSError.WrongUseOfAddressOf);
						errorToken = null;
						GetNextToken();
						return ParseLeftHandSideExpression(isMinus, ref canBeAttribute, warnForKeyword);
					}
					ReportError(JSError.ExpressionExpected);
					SkipTokensAndThrow();
				}
				break;
			}
			}
			if (!flag)
			{
				GetNextToken();
			}
			return MemberExpression(aST, arrayList, ref canBeAttribute);
		}

		private AST ParseConstructorCall(Context superCtx)
		{
			bool isSuperConstructorCall = JSToken.Super == currentToken.token;
			GetNextToken();
			Context context = currentToken.Clone();
			ASTList arguments = new ASTList(context);
			noSkipTokenSet.Add(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet);
			noSkipTokenSet.Add(NoSkipTokenSet.s_ParenToken);
			try
			{
				arguments = ParseExpressionList(JSToken.RightParen);
				GetNextToken();
			}
			catch (RecoveryTokenException ex)
			{
				if (ex._partiallyComputedNode != null)
				{
					arguments = (ASTList)ex._partiallyComputedNode;
				}
				if (IndexOfToken(NoSkipTokenSet.s_ParenToken, ex) == -1 && IndexOfToken(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet, ex) == -1)
				{
					ex._partiallyComputedNode = new ConstructorCall(superCtx, arguments, isSuperConstructorCall);
					throw ex;
				}
				if (ex._token == JSToken.RightParen)
				{
					GetNextToken();
				}
			}
			finally
			{
				noSkipTokenSet.Remove(NoSkipTokenSet.s_ParenToken);
				noSkipTokenSet.Remove(NoSkipTokenSet.s_EndOfStatementNoSkipTokenSet);
			}
			superCtx.UpdateWith(context);
			return new ConstructorCall(superCtx, arguments, isSuperConstructorCall);
		}

		private CustomAttributeList ParseCustomAttributeList()
		{
			CustomAttributeList customAttributeList = new CustomAttributeList(currentToken.Clone());
			while (true)
			{
				Context context = currentToken.Clone();
				bool canBeAttribute = true;
				bool isLeftHandSideExpr;
				AST aST = ParseUnaryExpression(out isLeftHandSideExpr, ref canBeAttribute, isMinus: false, warnForKeyword: false);
				if (canBeAttribute)
				{
					if (aST is Lookup || aST is Member)
					{
						customAttributeList.Append(new CustomAttribute(aST.context, aST, new ASTList(null)));
					}
					else
					{
						customAttributeList.Append(((Call)aST).ToCustomAttribute());
					}
				}
				else if (tokensSkipped == 0)
				{
					ReportError(JSError.SyntaxError, context);
				}
				if (currentToken.token == JSToken.RightBracket)
				{
					break;
				}
				if (currentToken.token == JSToken.Comma)
				{
					GetNextToken();
					continue;
				}
				ReportError(JSError.NoRightBracketOrComma);
				SkipTokensAndThrow();
			}
			return customAttributeList;
		}

		private AST MemberExpression(AST expression, ArrayList newContexts)
		{
			bool canBeAttribute = false;
			return MemberExpression(expression, newContexts, ref canBeAttribute);
		}

		private AST MemberExpression(AST expression, ArrayList newContexts, ref bool canBeAttribute)
		{
			bool canBeQualid;
			return MemberExpression(expression, newContexts, out canBeQualid, ref canBeAttribute);
		}

		private AST MemberExpression(AST expression, ArrayList newContexts, out bool canBeQualid, ref bool canBeAttribute)
		{
			bool flag = false;
			canBeQualid = true;
			while (true)
			{
				noSkipTokenSet.Add(NoSkipTokenSet.s_MemberExprNoSkipTokenSet);
				try
				{
					ASTList aSTList;
					switch (currentToken.token)
					{
					case JSToken.LeftParen:
					{
						if (flag)
						{
							canBeAttribute = false;
						}
						else
						{
							flag = true;
						}
						canBeQualid = false;
						aSTList = null;
						RecoveryTokenException ex = null;
						noSkipTokenSet.Add(NoSkipTokenSet.s_ParenToken);
						try
						{
							aSTList = ParseExpressionList(JSToken.RightParen);
						}
						catch (RecoveryTokenException ex2)
						{
							aSTList = (ASTList)ex2._partiallyComputedNode;
							if (IndexOfToken(NoSkipTokenSet.s_ParenToken, ex2) == -1)
							{
								ex = ex2;
							}
						}
						finally
						{
							noSkipTokenSet.Remove(NoSkipTokenSet.s_ParenToken);
						}
						if (expression is Lookup)
						{
							string text = expression.ToString();
							if (text.Equals("eval"))
							{
								expression.context.UpdateWith(aSTList.context);
								expression = ((aSTList.count == 1) ? new Eval(expression.context, aSTList[0], null) : ((aSTList.count <= 1) ? new Eval(expression.context, new ConstantWrapper("", CurrentPositionContext()), null) : new Eval(expression.context, aSTList[0], aSTList[1])));
								canBeAttribute = false;
							}
							else if (Globals.engine.doPrint && text.Equals("print"))
							{
								expression.context.UpdateWith(aSTList.context);
								expression = new Print(expression.context, aSTList);
								canBeAttribute = false;
							}
							else
							{
								expression = new Call(expression.context.CombineWith(aSTList.context), expression, aSTList, inBrackets: false);
							}
						}
						else
						{
							expression = new Call(expression.context.CombineWith(aSTList.context), expression, aSTList, inBrackets: false);
						}
						if (newContexts != null && newContexts.Count > 0)
						{
							((Context)newContexts[newContexts.Count - 1]).UpdateWith(expression.context);
							if (!(expression is Call))
							{
								expression = new Call((Context)newContexts[newContexts.Count - 1], expression, new ASTList(CurrentPositionContext()), inBrackets: false);
							}
							else
							{
								expression.context = (Context)newContexts[newContexts.Count - 1];
							}
							((Call)expression).isConstructor = true;
							newContexts.RemoveAt(newContexts.Count - 1);
						}
						if (ex != null)
						{
							ex._partiallyComputedNode = expression;
							throw ex;
						}
						GetNextToken();
						continue;
					}
					case JSToken.LeftBracket:
						canBeQualid = false;
						canBeAttribute = false;
						noSkipTokenSet.Add(NoSkipTokenSet.s_BracketToken);
						try
						{
							aSTList = ParseExpressionList(JSToken.RightBracket);
						}
						catch (RecoveryTokenException ex3)
						{
							if (IndexOfToken(NoSkipTokenSet.s_BracketToken, ex3) == -1)
							{
								if (ex3._partiallyComputedNode != null)
								{
									ex3._partiallyComputedNode = new Call(expression.context.CombineWith(currentToken.Clone()), expression, (ASTList)ex3._partiallyComputedNode, inBrackets: true);
								}
								else
								{
									ex3._partiallyComputedNode = expression;
								}
								throw ex3;
							}
							aSTList = (ASTList)ex3._partiallyComputedNode;
						}
						finally
						{
							noSkipTokenSet.Remove(NoSkipTokenSet.s_BracketToken);
						}
						expression = new Call(expression.context.CombineWith(currentToken.Clone()), expression, aSTList, inBrackets: true);
						if (newContexts != null && newContexts.Count > 0)
						{
							((Context)newContexts[newContexts.Count - 1]).UpdateWith(expression.context);
							expression.context = (Context)newContexts[newContexts.Count - 1];
							((Call)expression).isConstructor = true;
							newContexts.RemoveAt(newContexts.Count - 1);
						}
						GetNextToken();
						continue;
					case JSToken.AccessField:
					{
						if (flag)
						{
							canBeAttribute = false;
						}
						ConstantWrapper constantWrapper = null;
						GetNextToken();
						if (JSToken.Identifier != currentToken.token)
						{
							string text2 = JSKeyword.CanBeIdentifier(currentToken.token);
							if (text2 != null)
							{
								ForceReportInfo(JSError.KeywordUsedAsIdentifier);
								constantWrapper = new ConstantWrapper(text2, currentToken.Clone());
							}
							else
							{
								ReportError(JSError.NoIdentifier);
								SkipTokensAndThrow(expression);
							}
						}
						else
						{
							constantWrapper = new ConstantWrapper(scanner.GetIdentifier(), currentToken.Clone());
						}
						GetNextToken();
						expression = new Member(expression.context.CombineWith(constantWrapper.context), expression, constantWrapper);
						continue;
					}
					}
					if (newContexts != null)
					{
						while (newContexts.Count > 0)
						{
							((Context)newContexts[newContexts.Count - 1]).UpdateWith(expression.context);
							expression = new Call((Context)newContexts[newContexts.Count - 1], expression, new ASTList(CurrentPositionContext()), inBrackets: false);
							((Call)expression).isConstructor = true;
							newContexts.RemoveAt(newContexts.Count - 1);
						}
					}
					return expression;
				}
				catch (RecoveryTokenException ex4)
				{
					if (IndexOfToken(NoSkipTokenSet.s_MemberExprNoSkipTokenSet, ex4) != -1)
					{
						expression = ex4._partiallyComputedNode;
						continue;
					}
					throw ex4;
				}
				finally
				{
					noSkipTokenSet.Remove(NoSkipTokenSet.s_MemberExprNoSkipTokenSet);
				}
			}
		}

		private ASTList ParseExpressionList(JSToken terminator)
		{
			Context context = currentToken.Clone();
			int currentLine = scanner.GetCurrentLine();
			GetNextToken();
			ASTList aSTList = new ASTList(context);
			if (terminator != currentToken.token)
			{
				while (true)
				{
					noSkipTokenSet.Add(NoSkipTokenSet.s_ExpressionListNoSkipTokenSet);
					try
					{
						if (JSToken.BitwiseAnd == currentToken.token)
						{
							Context context2 = currentToken.Clone();
							GetNextToken();
							AST aST = ParseLeftHandSideExpression();
							if (aST is Member || aST is Lookup)
							{
								context2.UpdateWith(aST.context);
								aSTList.Append(new AddressOf(context2, aST));
							}
							else
							{
								ReportError(JSError.DoesNotHaveAnAddress, context2.Clone());
								aSTList.Append(aST);
							}
							goto IL_0109;
						}
						if (JSToken.Comma == currentToken.token)
						{
							aSTList.Append(new ConstantWrapper(System.Reflection.Missing.Value, currentToken.Clone()));
							goto IL_0109;
						}
						if (terminator == currentToken.token)
						{
							break;
						}
						aSTList.Append(ParseExpression(single: true));
						goto IL_0109;
						IL_0109:
						if (terminator != currentToken.token)
						{
							if (JSToken.Comma == currentToken.token)
							{
								goto IL_01c9;
							}
							if (terminator != JSToken.RightParen)
							{
								ReportError(JSError.NoRightBracketOrComma);
								goto IL_017a;
							}
							if (JSToken.Semicolon != currentToken.token || JSToken.RightParen != scanner.PeekToken())
							{
								ReportError(JSError.NoRightParenOrComma);
								goto IL_017a;
							}
							ReportError(JSError.UnexpectedSemicolon, skipToken: true);
							GetNextToken();
						}
						goto end_IL_0046;
						IL_017a:
						SkipTokensAndThrow();
						goto IL_01c9;
						end_IL_0046:;
					}
					catch (RecoveryTokenException ex)
					{
						if (ex._partiallyComputedNode != null)
						{
							aSTList.Append(ex._partiallyComputedNode);
						}
						if (IndexOfToken(NoSkipTokenSet.s_ExpressionListNoSkipTokenSet, ex) == -1)
						{
							ex._partiallyComputedNode = aSTList;
							throw ex;
						}
						goto IL_01c9;
					}
					finally
					{
						noSkipTokenSet.Remove(NoSkipTokenSet.s_ExpressionListNoSkipTokenSet);
					}
					break;
					IL_01c9:
					GetNextToken();
				}
			}
			context.UpdateWith(currentToken);
			return aSTList;
		}

		private AST CreateExpressionNode(JSToken op, AST operand1, AST operand2)
		{
			Context context = operand1.context.CombineWith(operand2.context);
			return op switch
			{
				JSToken.Assign => new Assign(context, operand1, operand2), 
				JSToken.BitwiseAnd => new BitwiseBinary(context, operand1, operand2, JSToken.BitwiseAnd), 
				JSToken.BitwiseAndAssign => new BitwiseBinaryAssign(context, operand1, operand2, JSToken.BitwiseAnd), 
				JSToken.BitwiseOr => new BitwiseBinary(context, operand1, operand2, JSToken.BitwiseOr), 
				JSToken.BitwiseOrAssign => new BitwiseBinaryAssign(context, operand1, operand2, JSToken.BitwiseOr), 
				JSToken.BitwiseXor => new BitwiseBinary(context, operand1, operand2, JSToken.BitwiseXor), 
				JSToken.BitwiseXorAssign => new BitwiseBinaryAssign(context, operand1, operand2, JSToken.BitwiseXor), 
				JSToken.Comma => new Comma(context, operand1, operand2), 
				JSToken.Divide => new NumericBinary(context, operand1, operand2, JSToken.Divide), 
				JSToken.DivideAssign => new NumericBinaryAssign(context, operand1, operand2, JSToken.Divide), 
				JSToken.Equal => new Equality(context, operand1, operand2, JSToken.Equal), 
				JSToken.GreaterThan => new Relational(context, operand1, operand2, JSToken.GreaterThan), 
				JSToken.GreaterThanEqual => new Relational(context, operand1, operand2, JSToken.GreaterThanEqual), 
				JSToken.In => new In(context, operand1, operand2), 
				JSToken.Instanceof => new Instanceof(context, operand1, operand2), 
				JSToken.LeftShift => new BitwiseBinary(context, operand1, operand2, JSToken.LeftShift), 
				JSToken.LeftShiftAssign => new BitwiseBinaryAssign(context, operand1, operand2, JSToken.LeftShift), 
				JSToken.LessThan => new Relational(context, operand1, operand2, JSToken.LessThan), 
				JSToken.LessThanEqual => new Relational(context, operand1, operand2, JSToken.LessThanEqual), 
				JSToken.LogicalAnd => new Logical_and(context, operand1, operand2), 
				JSToken.LogicalOr => new Logical_or(context, operand1, operand2), 
				JSToken.Minus => new NumericBinary(context, operand1, operand2, JSToken.Minus), 
				JSToken.MinusAssign => new NumericBinaryAssign(context, operand1, operand2, JSToken.Minus), 
				JSToken.Modulo => new NumericBinary(context, operand1, operand2, JSToken.Modulo), 
				JSToken.ModuloAssign => new NumericBinaryAssign(context, operand1, operand2, JSToken.Modulo), 
				JSToken.Multiply => new NumericBinary(context, operand1, operand2, JSToken.Multiply), 
				JSToken.MultiplyAssign => new NumericBinaryAssign(context, operand1, operand2, JSToken.Multiply), 
				JSToken.NotEqual => new Equality(context, operand1, operand2, JSToken.NotEqual), 
				JSToken.FirstBinaryOp => new Plus(context, operand1, operand2), 
				JSToken.PlusAssign => new PlusAssign(context, operand1, operand2), 
				JSToken.RightShift => new BitwiseBinary(context, operand1, operand2, JSToken.RightShift), 
				JSToken.RightShiftAssign => new BitwiseBinaryAssign(context, operand1, operand2, JSToken.RightShift), 
				JSToken.StrictEqual => new StrictEquality(context, operand1, operand2, JSToken.StrictEqual), 
				JSToken.StrictNotEqual => new StrictEquality(context, operand1, operand2, JSToken.StrictNotEqual), 
				JSToken.UnsignedRightShift => new BitwiseBinary(context, operand1, operand2, JSToken.UnsignedRightShift), 
				JSToken.UnsignedRightShiftAssign => new BitwiseBinaryAssign(context, operand1, operand2, JSToken.UnsignedRightShift), 
				_ => null, 
			};
		}

		private void GetNextToken()
		{
			if (errorToken != null)
			{
				if (breakRecursion > 10)
				{
					errorToken = null;
					scanner.GetNextToken();
				}
				else
				{
					breakRecursion++;
					currentToken = errorToken;
					errorToken = null;
				}
			}
			else
			{
				goodTokensProcessed++;
				breakRecursion = 0;
				scanner.GetNextToken();
			}
		}

		private Context CurrentPositionContext()
		{
			Context context = currentToken.Clone();
			context.endPos = ((context.startPos < context.source_string.Length) ? (context.startPos + 1) : context.startPos);
			return context;
		}

		private void ReportError(JSError errorId)
		{
			ReportError(errorId, skipToken: false);
		}

		private void ReportError(JSError errorId, bool skipToken)
		{
			Context context = currentToken.Clone();
			context.endPos = context.startPos + 1;
			ReportError(errorId, context, skipToken);
		}

		private void ReportError(JSError errorId, Context context)
		{
			ReportError(errorId, context, skipToken: false);
		}

		private void ReportError(JSError errorId, Context context, bool skipToken)
		{
			int severity = Severity;
			Severity = new JScriptException(errorId).Severity;
			if (context.token == JSToken.EndOfFile)
			{
				EOFError(errorId);
				return;
			}
			if (goodTokensProcessed > 0 || Severity < severity)
			{
				context.HandleError(errorId);
			}
			if (skipToken)
			{
				goodTokensProcessed = -1L;
				return;
			}
			errorToken = currentToken;
			goodTokensProcessed = 0L;
		}

		private void ForceReportInfo(JSError errorId)
		{
			ForceReportInfo(currentToken.Clone(), errorId);
		}

		private void ForceReportInfo(Context context, JSError errorId)
		{
			context.HandleError(errorId);
		}

		private void ForceReportInfo(JSError errorId, bool treatAsError)
		{
			currentToken.Clone().HandleError(errorId, treatAsError);
		}

		private void EOFError(JSError errorId)
		{
			Context context = sourceContext.Clone();
			context.lineNumber = scanner.GetCurrentLine();
			context.endLineNumber = context.lineNumber;
			context.startLinePos = scanner.GetStartLinePosition();
			context.endLinePos = context.startLinePos;
			context.startPos = sourceContext.endPos;
			context.endPos++;
			context.HandleError(errorId);
		}

		private void SkipTokensAndThrow()
		{
			SkipTokensAndThrow(null);
		}

		private void SkipTokensAndThrow(AST partialAST)
		{
			errorToken = null;
			bool flag = noSkipTokenSet.HasToken(JSToken.EndOfLine);
			while (!noSkipTokenSet.HasToken(currentToken.token))
			{
				if (flag && scanner.GotEndOfLine())
				{
					errorToken = currentToken;
					throw new RecoveryTokenException(JSToken.EndOfLine, partialAST);
				}
				GetNextToken();
				if (++tokensSkipped > 50)
				{
					ForceReportInfo(JSError.TooManyTokensSkipped);
					throw new EndOfFile();
				}
				if (currentToken.token == JSToken.EndOfFile)
				{
					throw new EndOfFile();
				}
			}
			errorToken = currentToken;
			throw new RecoveryTokenException(currentToken.token, partialAST);
		}

		private int IndexOfToken(JSToken[] tokens, RecoveryTokenException exc)
		{
			return IndexOfToken(tokens, exc._token);
		}

		private int IndexOfToken(JSToken[] tokens, JSToken token)
		{
			int i = 0;
			int num;
			for (num = tokens.Length; i < num && tokens[i] != token; i++)
			{
			}
			if (i >= num)
			{
				i = -1;
			}
			else
			{
				errorToken = null;
			}
			return i;
		}

		private bool TokenInList(JSToken[] tokens, JSToken token)
		{
			return -1 != IndexOfToken(tokens, token);
		}

		private bool TokenInList(JSToken[] tokens, RecoveryTokenException exc)
		{
			return -1 != IndexOfToken(tokens, exc._token);
		}

		private CustomAttributeList FromASTListToCustomAttributeList(ArrayList attributes)
		{
			CustomAttributeList customAttributeList = null;
			if (attributes != null && attributes.Count > 0)
			{
				customAttributeList = new CustomAttributeList(((AST)attributes[0]).context);
			}
			int i = 0;
			for (int count = attributes.Count; i < count; i++)
			{
				ASTList args = new ASTList(null);
				if (attributes[i] is Lookup || attributes[i] is Member)
				{
					customAttributeList.Append(new CustomAttribute(((AST)attributes[i]).context, (AST)attributes[i], args));
				}
				else
				{
					customAttributeList.Append(((Call)attributes[i]).ToCustomAttribute());
				}
			}
			return customAttributeList;
		}
	}
	internal class AstListItem
	{
		internal AstListItem _prev;

		internal AST _term;

		internal AstListItem(AST term, AstListItem prev)
		{
			_prev = prev;
			_term = term;
		}
	}
	internal class OpListItem
	{
		internal OpListItem _prev;

		internal JSToken _operator;

		internal OpPrec _prec;

		internal OpListItem(JSToken op, OpPrec prec, OpListItem prev)
		{
			_prev = prev;
			_operator = op;
			_prec = prec;
		}
	}
	/// <summary>This class is used by the JScript parser to represent parser exceptions.</summary>
	[Serializable]
	public class ParserException : Exception
	{
		internal ParserException()
			: base(JScriptException.Localize("Parser Exception", CultureInfo.CurrentUICulture))
		{
		}
	}
	internal class RecoveryTokenException : ParserException
	{
		internal JSToken _token;

		internal AST _partiallyComputedNode;

		internal RecoveryTokenException(JSToken token, AST partialAST)
		{
			_token = token;
			_partiallyComputedNode = partialAST;
		}
	}
	/// <summary>This class is used by the JScript parser to represent reaching the end of a file as an exception. Code can throw this error to stop the parser.</summary>
	[Serializable]
	public class EndOfFile : ParserException
	{
		internal EndOfFile()
		{
		}
	}
	internal class NoSkipTokenSet
	{
		private class TokenSetListItem
		{
			internal TokenSetListItem _next;

			internal JSToken[] _tokens;

			internal TokenSetListItem(JSToken[] tokens, TokenSetListItem next)
			{
				_next = next;
				_tokens = tokens;
			}
		}

		private TokenSetListItem _tokenSet;

		internal static readonly JSToken[] s_ArrayInitNoSkipTokenSet = new JSToken[2]
		{
			JSToken.RightBracket,
			JSToken.Comma
		};

		internal static readonly JSToken[] s_BlockConditionNoSkipTokenSet = new JSToken[3]
		{
			JSToken.RightParen,
			JSToken.LeftCurly,
			JSToken.EndOfLine
		};

		internal static readonly JSToken[] s_BlockNoSkipTokenSet = new JSToken[1] { JSToken.RightCurly };

		internal static readonly JSToken[] s_BracketToken = new JSToken[1] { JSToken.RightBracket };

		internal static readonly JSToken[] s_CaseNoSkipTokenSet = new JSToken[4]
		{
			JSToken.Case,
			JSToken.Default,
			JSToken.Colon,
			JSToken.EndOfLine
		};

		internal static readonly JSToken[] s_ClassBodyNoSkipTokenSet = new JSToken[10]
		{
			JSToken.Class,
			JSToken.Interface,
			JSToken.Enum,
			JSToken.Function,
			JSToken.Var,
			JSToken.Const,
			JSToken.Static,
			JSToken.Public,
			JSToken.Private,
			JSToken.Protected
		};

		internal static readonly JSToken[] s_InterfaceBodyNoSkipTokenSet = new JSToken[5]
		{
			JSToken.Enum,
			JSToken.Function,
			JSToken.Public,
			JSToken.EndOfLine,
			JSToken.Semicolon
		};

		internal static readonly JSToken[] s_ClassExtendsNoSkipTokenSet = new JSToken[2]
		{
			JSToken.LeftCurly,
			JSToken.Implements
		};

		internal static readonly JSToken[] s_ClassImplementsNoSkipTokenSet = new JSToken[2]
		{
			JSToken.LeftCurly,
			JSToken.Comma
		};

		internal static readonly JSToken[] s_DoWhileBodyNoSkipTokenSet = new JSToken[1] { JSToken.While };

		internal static readonly JSToken[] s_EndOfLineToken = new JSToken[1] { JSToken.EndOfLine };

		internal static readonly JSToken[] s_EndOfStatementNoSkipTokenSet = new JSToken[2]
		{
			JSToken.Semicolon,
			JSToken.EndOfLine
		};

		internal static readonly JSToken[] s_EnumBaseTypeNoSkipTokenSet = new JSToken[1] { JSToken.LeftCurly };

		internal static readonly JSToken[] s_EnumBodyNoSkipTokenSet = new JSToken[1] { JSToken.Identifier };

		internal static readonly JSToken[] s_ExpressionListNoSkipTokenSet = new JSToken[1] { JSToken.Comma };

		internal static readonly JSToken[] s_FunctionDeclNoSkipTokenSet = new JSToken[3]
		{
			JSToken.RightParen,
			JSToken.LeftCurly,
			JSToken.Comma
		};

		internal static readonly JSToken[] s_IfBodyNoSkipTokenSet = new JSToken[1] { JSToken.Else };

		internal static readonly JSToken[] s_MemberExprNoSkipTokenSet = new JSToken[3]
		{
			JSToken.LeftBracket,
			JSToken.LeftParen,
			JSToken.AccessField
		};

		internal static readonly JSToken[] s_NoTrySkipTokenSet = new JSToken[2]
		{
			JSToken.Catch,
			JSToken.Finally
		};

		internal static readonly JSToken[] s_ObjectInitNoSkipTokenSet = new JSToken[2]
		{
			JSToken.RightCurly,
			JSToken.Comma
		};

		internal static readonly JSToken[] s_PackageBodyNoSkipTokenSet = new JSToken[3]
		{
			JSToken.Class,
			JSToken.Interface,
			JSToken.Enum
		};

		internal static readonly JSToken[] s_ParenExpressionNoSkipToken = new JSToken[1] { JSToken.RightParen };

		internal static readonly JSToken[] s_ParenToken = new JSToken[1] { JSToken.RightParen };

		internal static readonly JSToken[] s_PostfixExpressionNoSkipTokenSet = new JSToken[2]
		{
			JSToken.Increment,
			JSToken.Decrement
		};

		internal static readonly JSToken[] s_StartBlockNoSkipTokenSet = new JSToken[1] { JSToken.LeftCurly };

		internal static readonly JSToken[] s_StartStatementNoSkipTokenSet = new JSToken[10]
		{
			JSToken.LeftCurly,
			JSToken.Var,
			JSToken.Const,
			JSToken.If,
			JSToken.For,
			JSToken.Do,
			JSToken.While,
			JSToken.With,
			JSToken.Switch,
			JSToken.Try
		};

		internal static readonly JSToken[] s_SwitchNoSkipTokenSet = new JSToken[2]
		{
			JSToken.Case,
			JSToken.Default
		};

		internal static readonly JSToken[] s_TopLevelNoSkipTokenSet = new JSToken[6]
		{
			JSToken.Package,
			JSToken.Class,
			JSToken.Interface,
			JSToken.Enum,
			JSToken.Function,
			JSToken.Import
		};

		internal static readonly JSToken[] s_VariableDeclNoSkipTokenSet = new JSToken[2]
		{
			JSToken.Comma,
			JSToken.Semicolon
		};

		internal NoSkipTokenSet()
		{
			_tokenSet = null;
		}

		internal void Add(JSToken[] tokens)
		{
			_tokenSet = new TokenSetListItem(tokens, _tokenSet);
		}

		internal void Remove(JSToken[] tokens)
		{
			TokenSetListItem tokenSetListItem = _tokenSet;
			TokenSetListItem tokenSetListItem2 = null;
			while (tokenSetListItem != null)
			{
				if (tokenSetListItem._tokens == tokens)
				{
					if (tokenSetListItem2 == null)
					{
						_tokenSet = _tokenSet._next;
					}
					else
					{
						tokenSetListItem2._next = tokenSetListItem._next;
					}
					break;
				}
				tokenSetListItem2 = tokenSetListItem;
				tokenSetListItem = tokenSetListItem._next;
			}
		}

		internal bool HasToken(JSToken token)
		{
			for (TokenSetListItem tokenSetListItem = _tokenSet; tokenSetListItem != null; tokenSetListItem = tokenSetListItem._next)
			{
				int i = 0;
				for (int num = tokenSetListItem._tokens.Length; i < num; i++)
				{
					if (tokenSetListItem._tokens[i] == token)
					{
						return true;
					}
				}
			}
			return false;
		}
	}
	internal class JSProperty : PropertyInfo
	{
		private string name;

		private ParameterInfo[] formal_parameters;

		internal PropertyBuilder metaData;

		internal JSMethod getter;

		internal JSMethod setter;

		public override PropertyAttributes Attributes => PropertyAttributes.None;

		public override bool CanRead => GetGetMethod(this, nonPublic: true) != null;

		public override bool CanWrite => GetSetMethod(this, nonPublic: true) != null;

		public override Type DeclaringType
		{
			get
			{
				if (getter != null)
				{
					return getter.DeclaringType;
				}
				return setter.DeclaringType;
			}
		}

		public override MemberTypes MemberType => MemberTypes.Property;

		public override string Name => name;

		public override Type PropertyType
		{
			get
			{
				if (getter != null)
				{
					return getter.ReturnType;
				}
				if (setter != null)
				{
					ParameterInfo[] parameters = setter.GetParameters();
					if (parameters.Length != 0)
					{
						return parameters[parameters.Length - 1].ParameterType;
					}
				}
				return Typeob.Void;
			}
		}

		public override Type ReflectedType
		{
			get
			{
				if (getter != null)
				{
					return getter.ReflectedType;
				}
				return setter.ReflectedType;
			}
		}

		internal JSProperty(string name)
		{
			this.name = name;
			formal_parameters = null;
			getter = null;
			setter = null;
		}

		internal virtual string GetClassFullName()
		{
			if (getter != null)
			{
				return getter.GetClassFullName();
			}
			return setter.GetClassFullName();
		}

		internal bool GetterAndSetterAreConsistent()
		{
			if (getter == null || setter == null)
			{
				return true;
			}
			((JSFieldMethod)getter).func.PartiallyEvaluate();
			((JSFieldMethod)setter).func.PartiallyEvaluate();
			ParameterInfo[] parameters = getter.GetParameters();
			ParameterInfo[] parameters2 = setter.GetParameters();
			int num = parameters.Length;
			int num2 = parameters2.Length;
			if (num != num2 - 1)
			{
				return false;
			}
			if (!((JSFieldMethod)getter).func.ReturnType(null).Equals(((ParameterDeclaration)parameters2[num]).type.ToIReflect()))
			{
				return false;
			}
			for (int i = 0; i < num; i++)
			{
				if (((ParameterDeclaration)parameters[i]).type.ToIReflect() != ((ParameterDeclaration)parameters2[i]).type.ToIReflect())
				{
					return false;
				}
			}
			return (getter.Attributes & ~MethodAttributes.Abstract) == (setter.Attributes & ~MethodAttributes.Abstract);
		}

		public sealed override object[] GetCustomAttributes(Type t, bool inherit)
		{
			return new object[0];
		}

		public sealed override object[] GetCustomAttributes(bool inherit)
		{
			if (getter != null)
			{
				return getter.GetCustomAttributes(inherit: true);
			}
			if (setter != null)
			{
				return setter.GetCustomAttributes(inherit: true);
			}
			return new object[0];
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static object GetValue(PropertyInfo prop, object obj, object[] index)
		{
			JSProperty jSProperty = prop as JSProperty;
			if (jSProperty != null)
			{
				return jSProperty.GetValue(obj, BindingFlags.ExactBinding, null, index, null);
			}
			JSWrappedProperty jSWrappedProperty = prop as JSWrappedProperty;
			if (jSWrappedProperty != null)
			{
				return jSWrappedProperty.GetValue(obj, BindingFlags.ExactBinding, null, index, null);
			}
			MethodInfo getMethod = GetGetMethod(prop, nonPublic: false);
			if (getMethod != null)
			{
				try
				{
					return getMethod.Invoke(obj, BindingFlags.ExactBinding, null, index, null);
				}
				catch (TargetInvocationException ex)
				{
					throw ex.InnerException;
				}
			}
			throw new MissingMethodException();
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		public override object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)
		{
			MethodInfo methodInfo = getter;
			JSObject jSObject = obj as JSObject;
			if (methodInfo == null && jSObject != null)
			{
				methodInfo = jSObject.GetMethod("get_" + name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				JSWrappedMethod jSWrappedMethod = methodInfo as JSWrappedMethod;
				if (jSWrappedMethod != null)
				{
					methodInfo = jSWrappedMethod.method;
				}
			}
			if (methodInfo == null)
			{
				methodInfo = GetGetMethod(nonPublic: false);
			}
			if (methodInfo != null)
			{
				try
				{
					return methodInfo.Invoke(obj, invokeAttr, binder, (index == null) ? new object[0] : index, culture);
				}
				catch (TargetInvocationException ex)
				{
					throw ex.InnerException;
				}
			}
			return Missing.Value;
		}

		public override MethodInfo[] GetAccessors(bool nonPublic)
		{
			if (getter != null && (nonPublic || getter.IsPublic))
			{
				if (setter != null && (nonPublic || setter.IsPublic))
				{
					return new MethodInfo[2] { getter, setter };
				}
				return new MethodInfo[1] { getter };
			}
			if (setter != null && (nonPublic || setter.IsPublic))
			{
				return new MethodInfo[1] { setter };
			}
			return new MethodInfo[0];
		}

		internal static MethodInfo GetGetMethod(PropertyInfo prop, bool nonPublic)
		{
			if (prop == null)
			{
				return null;
			}
			JSProperty jSProperty = prop as JSProperty;
			if (jSProperty != null)
			{
				return jSProperty.GetGetMethod(nonPublic);
			}
			MethodInfo getMethod = prop.GetGetMethod(nonPublic);
			if (getMethod != null)
			{
				return getMethod;
			}
			Type declaringType = prop.DeclaringType;
			if (declaringType == null)
			{
				return null;
			}
			Type baseType = declaringType.BaseType;
			if (baseType == null)
			{
				return null;
			}
			getMethod = prop.GetGetMethod(nonPublic);
			if (getMethod == null)
			{
				return null;
			}
			BindingFlags bindingFlags = BindingFlags.Public;
			bindingFlags = ((!getMethod.IsStatic) ? (bindingFlags | BindingFlags.Instance) : (bindingFlags | (BindingFlags.Static | BindingFlags.FlattenHierarchy)));
			if (nonPublic)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			string text = prop.Name;
			prop = null;
			try
			{
				prop = baseType.GetProperty(text, bindingFlags, null, null, new Type[0], null);
			}
			catch (AmbiguousMatchException)
			{
			}
			if (prop != null)
			{
				return GetGetMethod(prop, nonPublic);
			}
			return null;
		}

		public override MethodInfo GetGetMethod(bool nonPublic)
		{
			if (getter == null)
			{
				try
				{
					IReflect superType = ((ClassScope)setter.obj).GetSuperType();
					BindingFlags bindingFlags = BindingFlags.Public;
					bindingFlags = ((!setter.IsStatic) ? (bindingFlags | BindingFlags.Instance) : (bindingFlags | (BindingFlags.Static | BindingFlags.FlattenHierarchy)));
					if (nonPublic)
					{
						bindingFlags |= BindingFlags.NonPublic;
					}
					PropertyInfo property = superType.GetProperty(name, bindingFlags, null, null, new Type[0], null);
					if (property is JSProperty)
					{
						return property.GetGetMethod(nonPublic);
					}
					return GetGetMethod(property, nonPublic);
				}
				catch (AmbiguousMatchException)
				{
				}
			}
			if (nonPublic || getter.IsPublic)
			{
				return getter;
			}
			return null;
		}

		public override ParameterInfo[] GetIndexParameters()
		{
			if (formal_parameters == null)
			{
				if (getter != null)
				{
					formal_parameters = getter.GetParameters();
				}
				else
				{
					ParameterInfo[] parameters = setter.GetParameters();
					int num = parameters.Length;
					if (num <= 1)
					{
						num = 1;
					}
					formal_parameters = new ParameterInfo[num - 1];
					for (int i = 0; i < num - 1; i++)
					{
						formal_parameters[i] = parameters[i];
					}
				}
			}
			return formal_parameters;
		}

		internal static MethodInfo GetSetMethod(PropertyInfo prop, bool nonPublic)
		{
			if (prop == null)
			{
				return null;
			}
			JSProperty jSProperty = prop as JSProperty;
			if (jSProperty != null)
			{
				return jSProperty.GetSetMethod(nonPublic);
			}
			MethodInfo setMethod = prop.GetSetMethod(nonPublic);
			if (setMethod != null)
			{
				return setMethod;
			}
			Type declaringType = prop.DeclaringType;
			if (declaringType == null)
			{
				return null;
			}
			Type baseType = declaringType.BaseType;
			if (baseType == null)
			{
				return null;
			}
			setMethod = prop.GetGetMethod(nonPublic);
			if (setMethod == null)
			{
				return null;
			}
			BindingFlags bindingFlags = BindingFlags.Public;
			bindingFlags = ((!setMethod.IsStatic) ? (bindingFlags | BindingFlags.Instance) : (bindingFlags | (BindingFlags.Static | BindingFlags.FlattenHierarchy)));
			if (nonPublic)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			string text = prop.Name;
			prop = null;
			try
			{
				prop = baseType.GetProperty(text, bindingFlags, null, null, new Type[0], null);
			}
			catch (AmbiguousMatchException)
			{
			}
			if (prop != null)
			{
				return GetSetMethod(prop, nonPublic);
			}
			return null;
		}

		public override MethodInfo GetSetMethod(bool nonPublic)
		{
			if (setter == null)
			{
				try
				{
					IReflect superType = ((ClassScope)getter.obj).GetSuperType();
					BindingFlags bindingFlags = BindingFlags.Public;
					bindingFlags = ((!getter.IsStatic) ? (bindingFlags | BindingFlags.Instance) : (bindingFlags | (BindingFlags.Static | BindingFlags.FlattenHierarchy)));
					if (nonPublic)
					{
						bindingFlags |= BindingFlags.NonPublic;
					}
					PropertyInfo property = superType.GetProperty(name, bindingFlags, null, null, new Type[0], null);
					if (property is JSProperty)
					{
						return property.GetSetMethod(nonPublic);
					}
					return GetSetMethod(property, nonPublic);
				}
				catch (AmbiguousMatchException)
				{
				}
			}
			if (nonPublic || setter.IsPublic)
			{
				return setter;
			}
			return null;
		}

		public sealed override bool IsDefined(Type type, bool inherit)
		{
			return false;
		}

		internal IReflect PropertyIR()
		{
			if (getter is JSFieldMethod)
			{
				return ((JSFieldMethod)getter).ReturnIR();
			}
			if (setter != null)
			{
				ParameterInfo[] parameters = setter.GetParameters();
				if (parameters.Length != 0)
				{
					ParameterInfo parameterInfo = parameters[parameters.Length - 1];
					if (parameterInfo is ParameterDeclaration)
					{
						return ((ParameterDeclaration)parameterInfo).ParameterIReflect;
					}
					return parameterInfo.ParameterType;
				}
			}
			return Typeob.Void;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static void SetValue(PropertyInfo prop, object obj, object value, object[] index)
		{
			JSProperty jSProperty = prop as JSProperty;
			if (jSProperty != null)
			{
				jSProperty.SetValue(obj, value, BindingFlags.ExactBinding, null, index, null);
				return;
			}
			MethodInfo setMethod = GetSetMethod(prop, nonPublic: false);
			if (setMethod != null)
			{
				int num = ((index != null) ? index.Length : 0);
				object[] array = new object[num + 1];
				if (num > 0)
				{
					ArrayObject.Copy(index, 0, array, 0, num);
				}
				array[num] = value;
				setMethod.Invoke(obj, BindingFlags.ExactBinding, null, array, null);
				return;
			}
			throw new MissingMethodException();
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)
		{
			MethodInfo methodInfo = setter;
			JSObject jSObject = obj as JSObject;
			if (methodInfo == null && jSObject != null)
			{
				methodInfo = jSObject.GetMethod("set_" + name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				JSWrappedMethod jSWrappedMethod = methodInfo as JSWrappedMethod;
				if (jSWrappedMethod != null)
				{
					methodInfo = jSWrappedMethod.method;
				}
			}
			if (methodInfo == null)
			{
				methodInfo = GetSetMethod(nonPublic: false);
			}
			if (methodInfo != null)
			{
				if (index == null || index.Length == 0)
				{
					methodInfo.Invoke(obj, invokeAttr, binder, new object[1] { value }, culture);
					return;
				}
				int num = index.Length;
				object[] array = new object[num + 1];
				ArrayObject.Copy(index, 0, array, 0, num);
				array[num] = value;
				methodInfo.Invoke(obj, invokeAttr, binder, array, culture);
			}
		}
	}
	internal sealed class JSPropertyField : JSField
	{
		internal PropertyInfo wrappedProperty;

		internal object wrappedObject;

		public override string Name => wrappedProperty.Name;

		public override FieldAttributes Attributes => FieldAttributes.Public;

		public override Type DeclaringType => wrappedProperty.DeclaringType;

		public override Type FieldType => wrappedProperty.PropertyType;

		internal JSPropertyField(PropertyInfo field, object obj)
		{
			wrappedProperty = field;
			wrappedObject = obj;
		}

		public override object GetValue(object obj)
		{
			return wrappedProperty.GetValue(wrappedObject, new object[0]);
		}

		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo locale)
		{
			wrappedProperty.SetValue(wrappedObject, value, invokeAttr, binder, new object[0], locale);
		}
	}
	internal class JSPropertyInfo : PropertyInfo
	{
		private PropertyInfo property;

		private Type declaringType;

		internal MethodInfo getter;

		internal MethodInfo setter;

		public override PropertyAttributes Attributes => property.Attributes;

		public override bool CanRead => property.CanRead;

		public override bool CanWrite => property.CanWrite;

		public override Type DeclaringType
		{
			get
			{
				Type type = declaringType;
				if (type == null)
				{
					type = (declaringType = property.DeclaringType);
				}
				return type;
			}
		}

		public override string Name => property.Name;

		public override Type PropertyType => property.PropertyType;

		public override Type ReflectedType => property.ReflectedType;

		internal JSPropertyInfo(PropertyInfo property)
		{
			this.property = property;
		}

		public override MethodInfo GetGetMethod(bool nonPublic)
		{
			MethodInfo methodInfo = getter;
			if (methodInfo == null)
			{
				methodInfo = property.GetGetMethod(nonPublic);
				if (methodInfo != null)
				{
					methodInfo = new JSMethodInfo(methodInfo);
				}
				getter = methodInfo;
			}
			return methodInfo;
		}

		public override ParameterInfo[] GetIndexParameters()
		{
			MethodInfo getMethod = GetGetMethod(nonPublic: false);
			if (getMethod != null)
			{
				return getMethod.GetParameters();
			}
			return property.GetIndexParameters();
		}

		public override MethodInfo GetSetMethod(bool nonPublic)
		{
			MethodInfo methodInfo = setter;
			if (methodInfo == null)
			{
				methodInfo = property.GetSetMethod(nonPublic);
				if (methodInfo != null)
				{
					methodInfo = new JSMethodInfo(methodInfo);
				}
				setter = methodInfo;
			}
			return methodInfo;
		}

		public override MethodInfo[] GetAccessors(bool nonPublic)
		{
			throw new JScriptException(JSError.InternalError);
		}

		public override object[] GetCustomAttributes(Type t, bool inherit)
		{
			return CustomAttribute.GetCustomAttributes(property, t, inherit);
		}

		public override object[] GetCustomAttributes(bool inherit)
		{
			return property.GetCustomAttributes(inherit);
		}

		public override object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)
		{
			return GetGetMethod(nonPublic: false).Invoke(obj, invokeAttr, binder, (index == null) ? new object[0] : index, culture);
		}

		public override bool IsDefined(Type type, bool inherit)
		{
			return CustomAttribute.IsDefined(property, type, inherit);
		}

		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)
		{
			if (index == null || index.Length == 0)
			{
				GetSetMethod(nonPublic: false).Invoke(obj, invokeAttr, binder, new object[1] { value }, culture);
				return;
			}
			int num = index.Length;
			object[] array = new object[num + 1];
			ArrayObject.Copy(index, 0, array, 0, num);
			array[num] = value;
			GetSetMethod(nonPublic: false).Invoke(obj, invokeAttr, binder, array, culture);
		}
	}
	internal sealed class JSPrototypeField : JSField
	{
		private object prototypeObject;

		internal FieldInfo prototypeField;

		internal object value;

		public override FieldAttributes Attributes => FieldAttributes.Public | FieldAttributes.Static;

		public override string Name => prototypeField.Name;

		internal JSPrototypeField(object prototypeObject, FieldInfo prototypeField)
		{
			this.prototypeObject = prototypeObject;
			this.prototypeField = prototypeField;
			value = Missing.Value;
		}

		public override object GetValue(object obj)
		{
			if (value is Missing)
			{
				return prototypeField.GetValue(prototypeObject);
			}
			return value;
		}

		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo locale)
		{
			this.value = value;
		}
	}
	/// <summary>Adds a constructor function property to a <see cref="T:Microsoft.JScript.JSObject" /> for early binding purposes. This class belongs to the objects and functions category.</summary>
	public class JSPrototypeObject : JSObject
	{
		/// <summary>Stores a constructor function object that defines a prototype-based object.</summary>
		public object constructor;

		internal JSPrototypeObject(ScriptObject parent, ScriptFunction constructor)
			: base(parent, typeof(JSPrototypeObject))
		{
			this.constructor = constructor;
			noExpando = false;
		}
	}
	/// <summary>Scans JScript code searching for individual units of code, or tokens. This class belongs to the scanning and parsing category.</summary>
	public sealed class JSScanner
	{
		private string strSourceCode;

		private int startPos;

		private int endPos;

		private int currentPos;

		private int currentLine;

		private int startLinePos;

		private Context currentToken;

		private string escapedString;

		private StringBuilder identifier;

		private int idLastPosOnBuilder;

		private bool gotEndOfLine;

		private bool IsAuthoring;

		private bool peekModeOn;

		private bool scanForDebugger;

		private JSKeyword[] keywords;

		private static readonly JSKeyword[] s_Keywords = JSKeyword.InitKeywords();

		private bool preProcessorOn;

		private int matchIf;

		private object preProcessorValue;

		private SimpleHashtable ppTable;

		private DocumentContext currentDocument;

		private Globals globals;

		private static readonly OpPrec[] s_OperatorsPrec = InitOperatorsPrec();

		private static readonly OpPrec[] s_PPOperatorsPrec = InitPPOperatorsPrec();

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JSScanner" /> class.</summary>
		public JSScanner()
		{
			keywords = s_Keywords;
			strSourceCode = null;
			startPos = 0;
			endPos = 0;
			currentPos = 0;
			currentLine = 1;
			startLinePos = 0;
			currentToken = null;
			escapedString = null;
			identifier = new StringBuilder(128);
			idLastPosOnBuilder = 0;
			gotEndOfLine = false;
			IsAuthoring = false;
			peekModeOn = false;
			preProcessorOn = false;
			matchIf = 0;
			ppTable = null;
			currentDocument = null;
			globals = null;
			scanForDebugger = false;
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.JSScanner" /> class, specifying the source code to scan.</summary>
		/// <param name="sourceContext">The source code to scan.</param>
		public JSScanner(Context sourceContext)
		{
			IsAuthoring = false;
			peekModeOn = false;
			keywords = s_Keywords;
			preProcessorOn = false;
			matchIf = 0;
			ppTable = null;
			SetSource(sourceContext);
			currentDocument = null;
			globals = sourceContext.document.engine.Globals;
		}

		/// <summary>Sets a flag that indicates whether the scanner is operating in authoring mode.</summary>
		/// <param name="mode">
		///   <see langword="true" /> to indicate authoring mode; otherwise, <see langword="false" />.</param>
		public void SetAuthoringMode(bool mode)
		{
			IsAuthoring = mode;
		}

		/// <summary>Sets the source code to scan.</summary>
		/// <param name="sourceContext">The source code to scan.</param>
		public void SetSource(Context sourceContext)
		{
			strSourceCode = sourceContext.source_string;
			startPos = sourceContext.startPos;
			startLinePos = sourceContext.startLinePos;
			endPos = ((0 < sourceContext.endPos && sourceContext.endPos < strSourceCode.Length) ? sourceContext.endPos : strSourceCode.Length);
			currentToken = sourceContext;
			escapedString = null;
			identifier = new StringBuilder(128);
			idLastPosOnBuilder = 0;
			currentPos = startPos;
			currentLine = ((sourceContext.lineNumber <= 0) ? 1 : sourceContext.lineNumber);
			gotEndOfLine = false;
			scanForDebugger = sourceContext.document != null && sourceContext.document.engine != null && VsaEngine.executeForJSEE;
		}

		internal JSToken PeekToken()
		{
			int num = currentPos;
			int num2 = currentLine;
			int num3 = startLinePos;
			bool flag = gotEndOfLine;
			int num4 = idLastPosOnBuilder;
			peekModeOn = true;
			JSToken jSToken = JSToken.None;
			Context context = currentToken;
			currentToken = currentToken.Clone();
			try
			{
				GetNextToken();
				return currentToken.token;
			}
			finally
			{
				currentToken = context;
				currentPos = num;
				currentLine = num2;
				startLinePos = num3;
				gotEndOfLine = flag;
				identifier.Length = 0;
				idLastPosOnBuilder = num4;
				peekModeOn = false;
				escapedString = null;
			}
		}

		/// <summary>Scans for the next token in the code.</summary>
		public void GetNextToken()
		{
			JSToken jSToken = JSToken.None;
			gotEndOfLine = false;
			try
			{
				int num = currentLine;
				while (true)
				{
					SkipBlanks();
					currentToken.startPos = currentPos;
					currentToken.lineNumber = currentLine;
					currentToken.startLinePos = startLinePos;
					char c = GetChar(currentPos++);
					switch (c)
					{
					case '\0':
						if (currentPos < endPos)
						{
							continue;
						}
						currentPos--;
						jSToken = JSToken.EndOfFile;
						if (matchIf > 0)
						{
							currentToken.endLineNumber = currentLine;
							currentToken.endLinePos = startLinePos;
							currentToken.endPos = currentPos;
							HandleError(JSError.NoCcEnd);
						}
						break;
					case '=':
						jSToken = JSToken.Assign;
						if ('=' == GetChar(currentPos))
						{
							currentPos++;
							jSToken = JSToken.Equal;
							if ('=' == GetChar(currentPos))
							{
								currentPos++;
								jSToken = JSToken.StrictEqual;
							}
						}
						break;
					case '>':
						jSToken = JSToken.GreaterThan;
						if ('>' == GetChar(currentPos))
						{
							currentPos++;
							jSToken = JSToken.RightShift;
							if ('>' == GetChar(currentPos))
							{
								currentPos++;
								jSToken = JSToken.UnsignedRightShift;
							}
						}
						if ('=' == GetChar(currentPos))
						{
							currentPos++;
							switch (jSToken)
							{
							case JSToken.GreaterThan:
								jSToken = JSToken.GreaterThanEqual;
								break;
							case JSToken.RightShift:
								jSToken = JSToken.RightShiftAssign;
								break;
							case JSToken.UnsignedRightShift:
								jSToken = JSToken.UnsignedRightShiftAssign;
								break;
							}
						}
						break;
					case '<':
						jSToken = JSToken.LessThan;
						if ('<' == GetChar(currentPos))
						{
							currentPos++;
							jSToken = JSToken.LeftShift;
						}
						if ('=' == GetChar(currentPos))
						{
							currentPos++;
							jSToken = ((jSToken != JSToken.LessThan) ? JSToken.LeftShiftAssign : JSToken.LessThanEqual);
						}
						break;
					case '!':
						jSToken = JSToken.FirstOp;
						if ('=' == GetChar(currentPos))
						{
							currentPos++;
							jSToken = JSToken.NotEqual;
							if ('=' == GetChar(currentPos))
							{
								currentPos++;
								jSToken = JSToken.StrictNotEqual;
							}
						}
						break;
					case ',':
						jSToken = JSToken.Comma;
						break;
					case '~':
						jSToken = JSToken.BitwiseNot;
						break;
					case '?':
						jSToken = JSToken.ConditionalIf;
						break;
					case ':':
						jSToken = JSToken.Colon;
						if (':' == GetChar(currentPos))
						{
							currentPos++;
							jSToken = JSToken.DoubleColon;
						}
						break;
					case '.':
						jSToken = JSToken.AccessField;
						c = GetChar(currentPos);
						if (IsDigit(c))
						{
							jSToken = ScanNumber('.');
						}
						else if ('.' == c)
						{
							c = GetChar(currentPos + 1);
							if ('.' == c)
							{
								currentPos += 2;
								jSToken = JSToken.ParamArray;
							}
						}
						break;
					case '&':
						jSToken = JSToken.BitwiseAnd;
						c = GetChar(currentPos);
						if ('&' == c)
						{
							currentPos++;
							jSToken = JSToken.LogicalAnd;
						}
						else if ('=' == c)
						{
							currentPos++;
							jSToken = JSToken.BitwiseAndAssign;
						}
						break;
					case '|':
						jSToken = JSToken.BitwiseOr;
						c = GetChar(currentPos);
						if ('|' == c)
						{
							currentPos++;
							jSToken = JSToken.LogicalOr;
						}
						else if ('=' == c)
						{
							currentPos++;
							jSToken = JSToken.BitwiseOrAssign;
						}
						break;
					case '+':
						jSToken = JSToken.FirstBinaryOp;
						c = GetChar(currentPos);
						if ('+' == c)
						{
							currentPos++;
							jSToken = JSToken.Increment;
						}
						else if ('=' == c)
						{
							currentPos++;
							jSToken = JSToken.PlusAssign;
						}
						break;
					case '-':
						jSToken = JSToken.Minus;
						c = GetChar(currentPos);
						if ('-' == c)
						{
							currentPos++;
							jSToken = JSToken.Decrement;
						}
						else if ('=' == c)
						{
							currentPos++;
							jSToken = JSToken.MinusAssign;
						}
						break;
					case '*':
						jSToken = JSToken.Multiply;
						if ('=' == GetChar(currentPos))
						{
							currentPos++;
							jSToken = JSToken.MultiplyAssign;
						}
						break;
					case '\\':
						currentPos--;
						if (IsIdentifierStartChar(ref c))
						{
							currentPos++;
							ScanIdentifier();
							jSToken = JSToken.Identifier;
							break;
						}
						currentPos++;
						c = GetChar(currentPos);
						if ('a' <= c && c <= 'z')
						{
							JSKeyword jSKeyword2 = keywords[c - 97];
							if (jSKeyword2 != null)
							{
								currentToken.startPos++;
								jSToken = ScanKeyword(jSKeyword2);
								if (jSToken != JSToken.Identifier)
								{
									jSToken = JSToken.Identifier;
									break;
								}
								currentToken.startPos--;
							}
						}
						currentPos = currentToken.startPos + 1;
						HandleError(JSError.IllegalChar);
						break;
					case '/':
					{
						jSToken = JSToken.Divide;
						c = GetChar(currentPos);
						bool flag = false;
						switch (c)
						{
						case '/':
							if (GetChar(++currentPos) == '@' && !peekModeOn)
							{
								if (preProcessorOn)
								{
									if (IsBlankSpace(GetChar(++currentPos)))
									{
										continue;
									}
									flag = true;
									break;
								}
								if ('c' == GetChar(++currentPos) && 'c' == GetChar(++currentPos) && '_' == GetChar(++currentPos) && 'o' == GetChar(++currentPos) && 'n' == GetChar(++currentPos))
								{
									char char2 = GetChar(currentPos + 1);
									if (!IsDigit(char2) && !IsAsciiLetter(char2) && !IsUnicodeLetter(char2))
									{
										SetPreProcessorOn();
										currentPos++;
										continue;
									}
								}
							}
							SkipSingleLineComment();
							if (!IsAuthoring)
							{
								continue;
							}
							jSToken = JSToken.Comment;
							break;
						case '*':
							if (GetChar(++currentPos) == '@' && !peekModeOn)
							{
								if (preProcessorOn)
								{
									if (IsBlankSpace(GetChar(++currentPos)))
									{
										continue;
									}
									flag = true;
									break;
								}
								if ('c' == GetChar(++currentPos) && 'c' == GetChar(++currentPos) && '_' == GetChar(++currentPos) && 'o' == GetChar(++currentPos) && 'n' == GetChar(++currentPos))
								{
									char @char = GetChar(currentPos + 1);
									if (!IsDigit(@char) && !IsAsciiLetter(@char) && !IsUnicodeLetter(@char))
									{
										SetPreProcessorOn();
										currentPos++;
										continue;
									}
								}
							}
							SkipMultiLineComment();
							if (!IsAuthoring)
							{
								continue;
							}
							if (currentPos > endPos)
							{
								jSToken = JSToken.UnterminatedComment;
								currentPos = endPos;
							}
							else
							{
								jSToken = JSToken.Comment;
							}
							break;
						case '=':
							currentPos++;
							jSToken = JSToken.DivideAssign;
							break;
						}
						if (!flag)
						{
							break;
						}
						goto case '@';
					}
					case '^':
						jSToken = JSToken.BitwiseXor;
						if ('=' == GetChar(currentPos))
						{
							currentPos++;
							jSToken = JSToken.BitwiseXorAssign;
						}
						break;
					case '%':
						jSToken = JSToken.Modulo;
						if ('=' == GetChar(currentPos))
						{
							currentPos++;
							jSToken = JSToken.ModuloAssign;
						}
						break;
					case '(':
						jSToken = JSToken.LeftParen;
						break;
					case ')':
						jSToken = JSToken.RightParen;
						break;
					case '{':
						jSToken = JSToken.LeftCurly;
						break;
					case '}':
						jSToken = JSToken.RightCurly;
						break;
					case '[':
						jSToken = JSToken.LeftBracket;
						break;
					case ']':
						jSToken = JSToken.RightBracket;
						break;
					case ';':
						jSToken = JSToken.Semicolon;
						break;
					case '"':
					case '\'':
						jSToken = JSToken.StringLiteral;
						ScanString(c);
						break;
					case '\r':
						if (GetChar(currentPos) == '\n')
						{
							currentPos++;
						}
						currentLine++;
						startLinePos = currentPos;
						continue;
					case '\n':
						currentLine++;
						startLinePos = currentPos;
						continue;
					case '\u2028':
						currentLine++;
						startLinePos = currentPos;
						continue;
					case '\u2029':
						currentLine++;
						startLinePos = currentPos;
						continue;
					case '@':
					{
						if (scanForDebugger)
						{
							HandleError(JSError.CcInvalidInDebugger);
						}
						if (peekModeOn)
						{
							currentToken.token = JSToken.PreProcessDirective;
							break;
						}
						int num2 = currentPos;
						currentToken.startPos = num2;
						currentToken.lineNumber = currentLine;
						currentToken.startLinePos = startLinePos;
						ScanIdentifier();
						switch (currentPos - num2)
						{
						case 0:
							if (preProcessorOn && '*' == GetChar(currentPos) && '/' == GetChar(++currentPos))
							{
								currentPos++;
							}
							else
							{
								HandleError(JSError.IllegalChar);
							}
							continue;
						case 2:
							if ('i' == strSourceCode[num2] && 'f' == strSourceCode[num2 + 1])
							{
								if (!preProcessorOn)
								{
									SetPreProcessorOn();
								}
								matchIf++;
								if (!PPTestCond())
								{
									PPSkipToNextCondition(checkCondition: true);
								}
								continue;
							}
							break;
						case 3:
							if ('s' == strSourceCode[num2] && 'e' == strSourceCode[num2 + 1] && 't' == strSourceCode[num2 + 2])
							{
								if (!preProcessorOn)
								{
									SetPreProcessorOn();
								}
								PPScanSet();
								continue;
							}
							if ('e' == strSourceCode[num2] && 'n' == strSourceCode[num2 + 1] && 'd' == strSourceCode[num2 + 2])
							{
								if (0 >= matchIf)
								{
									HandleError(JSError.CcInvalidEnd);
								}
								else
								{
									matchIf--;
								}
								continue;
							}
							break;
						case 4:
							if ('e' == strSourceCode[num2] && 'l' == strSourceCode[num2 + 1] && 's' == strSourceCode[num2 + 2] && 'e' == strSourceCode[num2 + 3])
							{
								if (0 >= matchIf)
								{
									HandleError(JSError.CcInvalidElse);
								}
								else
								{
									PPSkipToNextCondition(checkCondition: false);
								}
								continue;
							}
							if ('e' == strSourceCode[num2] && 'l' == strSourceCode[num2 + 1] && 'i' == strSourceCode[num2 + 2] && 'f' == strSourceCode[num2 + 3])
							{
								if (0 >= matchIf)
								{
									HandleError(JSError.CcInvalidElif);
								}
								else
								{
									PPSkipToNextCondition(checkCondition: false);
								}
								continue;
							}
							break;
						case 5:
							if ('c' == GetChar(num2) && 'c' == GetChar(num2 + 1) && '_' == GetChar(num2 + 2) && 'o' == GetChar(num2 + 3) && 'n' == GetChar(num2 + 4))
							{
								if (!preProcessorOn)
								{
									SetPreProcessorOn();
								}
								continue;
							}
							break;
						}
						if (!preProcessorOn)
						{
							HandleError(JSError.CcOff);
							continue;
						}
						object obj = ppTable[strSourceCode.Substring(num2, currentPos - num2)];
						if (obj == null)
						{
							preProcessorValue = double.NaN;
						}
						else
						{
							preProcessorValue = obj;
						}
						jSToken = JSToken.PreProcessorConstant;
						break;
					}
					case '$':
					case '_':
						ScanIdentifier();
						jSToken = JSToken.Identifier;
						break;
					default:
						if ('a' <= c && c <= 'z')
						{
							JSKeyword jSKeyword = keywords[c - 97];
							if (jSKeyword != null)
							{
								jSToken = ScanKeyword(jSKeyword);
								break;
							}
							jSToken = JSToken.Identifier;
							ScanIdentifier();
							break;
						}
						if (IsDigit(c))
						{
							jSToken = ScanNumber(c);
							break;
						}
						if (('A' <= c && c <= 'Z') || IsUnicodeLetter(c))
						{
							jSToken = JSToken.Identifier;
							ScanIdentifier();
							break;
						}
						HandleError(JSError.IllegalChar);
						continue;
					}
					break;
				}
				currentToken.endLineNumber = currentLine;
				currentToken.endLinePos = startLinePos;
				currentToken.endPos = currentPos;
				gotEndOfLine = ((currentLine > num || jSToken == JSToken.EndOfFile) ? true : false);
				if (gotEndOfLine && jSToken == JSToken.StringLiteral && currentToken.lineNumber == num)
				{
					gotEndOfLine = false;
				}
			}
			catch (IndexOutOfRangeException)
			{
				jSToken = JSToken.None;
				currentToken.endPos = currentPos;
				currentToken.endLineNumber = currentLine;
				currentToken.endLinePos = startLinePos;
				throw new ScannerException(JSError.ErrEOF);
			}
			currentToken.token = jSToken;
		}

		private char GetChar(int index)
		{
			if (index < endPos)
			{
				return strSourceCode[index];
			}
			return '\0';
		}

		/// <summary>Gets the current position in the code string. This is a pointer that moves as the code is scanned.</summary>
		/// <param name="absolute">This parameter is ignored.</param>
		/// <returns>The current position in the code string.</returns>
		public int GetCurrentPosition(bool absolute)
		{
			return currentPos;
		}

		/// <summary>Gets the current line number in the code. This is a pointer that moves as the code is scanned.</summary>
		/// <returns>The current line number in the code.</returns>
		public int GetCurrentLine()
		{
			return currentLine;
		}

		/// <summary>Gets the position in the code string where the first line of the current code starts. All lines of code are stored in a single string. This is a pointer that moves as the code is scanned.</summary>
		/// <returns>The position in the code string where the first line of the current code starts.</returns>
		public int GetStartLinePosition()
		{
			return startLinePos;
		}

		/// <summary>Gets a string that has been scanned and had all its escape sequences replaced.</summary>
		/// <returns>A string that has been scanned and had all its escape sequences replaced.</returns>
		public string GetStringLiteral()
		{
			return escapedString;
		}

		/// <summary>Gets the source code that is associated with this scanner object.</summary>
		/// <returns>The source code to scan.</returns>
		public string GetSourceCode()
		{
			return strSourceCode;
		}

		/// <summary>Indicates whether the end of a line was reached after the scanner scans or peeks for a token.</summary>
		/// <returns>
		///   <see langword="true" /> if the end of the line was reached; otherwise, <see langword="false" />.</returns>
		public bool GotEndOfLine()
		{
			return gotEndOfLine;
		}

		internal string GetIdentifier()
		{
			string text = null;
			if (identifier.Length > 0)
			{
				text = identifier.ToString();
				identifier.Length = 0;
			}
			else
			{
				text = currentToken.GetCode();
			}
			if (text.Length > 500)
			{
				text = text.Substring(0, 500) + text.GetHashCode().ToString(CultureInfo.InvariantCulture);
			}
			return text;
		}

		private void ScanIdentifier()
		{
			while (true)
			{
				char @char = GetChar(currentPos);
				if (!IsIdentifierPartChar(@char))
				{
					break;
				}
				currentPos++;
			}
			if (idLastPosOnBuilder > 0)
			{
				identifier.Append(strSourceCode.Substring(idLastPosOnBuilder, currentPos - idLastPosOnBuilder));
				idLastPosOnBuilder = 0;
			}
		}

		private JSToken ScanKeyword(JSKeyword keyword)
		{
			char @char;
			while (true)
			{
				@char = GetChar(currentPos);
				if ('a' > @char || @char > 'z')
				{
					break;
				}
				currentPos++;
			}
			if (IsIdentifierPartChar(@char))
			{
				ScanIdentifier();
				return JSToken.Identifier;
			}
			return keyword.GetKeyword(currentToken, currentPos - currentToken.startPos);
		}

		private JSToken ScanNumber(char leadChar)
		{
			bool flag = '.' == leadChar;
			JSToken result = (flag ? JSToken.NumericLiteral : JSToken.IntegerLiteral);
			bool flag2 = false;
			char @char;
			if ('0' == leadChar)
			{
				@char = GetChar(currentPos);
				if ('x' == @char || 'X' == @char)
				{
					if (!IsHexDigit(GetChar(currentPos + 1)))
					{
						HandleError(JSError.BadHexDigit);
					}
					while (IsHexDigit(GetChar(++currentPos)))
					{
					}
					return result;
				}
			}
			while (true)
			{
				@char = GetChar(currentPos);
				if (!IsDigit(@char))
				{
					if ('.' == @char)
					{
						if (flag)
						{
							break;
						}
						flag = true;
						result = JSToken.NumericLiteral;
					}
					else if ('e' == @char || 'E' == @char)
					{
						if (flag2)
						{
							break;
						}
						flag2 = true;
						result = JSToken.NumericLiteral;
					}
					else
					{
						if ('+' != @char && '-' != @char)
						{
							break;
						}
						char char2 = GetChar(currentPos - 1);
						if ('e' != char2 && 'E' != char2)
						{
							break;
						}
					}
				}
				currentPos++;
			}
			@char = GetChar(currentPos - 1);
			if ('+' == @char || '-' == @char)
			{
				currentPos--;
				@char = GetChar(currentPos - 1);
			}
			if ('e' == @char || 'E' == @char)
			{
				currentPos--;
			}
			return result;
		}

		internal string ScanRegExp()
		{
			int num = currentPos;
			bool flag = false;
			char @char;
			while (!IsEndLineOrEOF(@char = GetChar(currentPos++), 0))
			{
				if (flag)
				{
					flag = false;
					continue;
				}
				switch (@char)
				{
				case '/':
					if (num == currentPos)
					{
						return null;
					}
					currentToken.endPos = currentPos;
					currentToken.endLinePos = startLinePos;
					currentToken.endLineNumber = currentLine;
					return strSourceCode.Substring(currentToken.startPos + 1, currentToken.endPos - currentToken.startPos - 2);
				case '\\':
					flag = true;
					break;
				}
			}
			currentPos = num;
			return null;
		}

		internal string ScanRegExpFlags()
		{
			int num = currentPos;
			while (IsAsciiLetter(GetChar(currentPos)))
			{
				currentPos++;
			}
			if (num != currentPos)
			{
				currentToken.endPos = currentPos;
				currentToken.endLineNumber = currentLine;
				currentToken.endLinePos = startLinePos;
				return strSourceCode.Substring(num, currentToken.endPos - num);
			}
			return null;
		}

		private void ScanString(char cStringTerminator)
		{
			int num = currentPos;
			escapedString = null;
			StringBuilder stringBuilder = null;
			char c;
			do
			{
				c = GetChar(currentPos++);
				if (c != '\\')
				{
					if (IsLineTerminator(c, 0))
					{
						HandleError(JSError.UnterminatedString);
						currentPos--;
						break;
					}
					if (c == '\0')
					{
						currentPos--;
						HandleError(JSError.UnterminatedString);
						break;
					}
					continue;
				}
				if (stringBuilder == null)
				{
					stringBuilder = new StringBuilder(128);
				}
				if (currentPos - num - 1 > 0)
				{
					stringBuilder.Append(strSourceCode, num, currentPos - num - 1);
				}
				bool flag = false;
				int num2 = 0;
				c = GetChar(currentPos++);
				switch (c)
				{
				case '\r':
					if ('\n' == GetChar(currentPos))
					{
						currentPos++;
					}
					goto case '\n';
				case '\n':
				case '\u2028':
				case '\u2029':
					currentLine++;
					startLinePos = currentPos;
					break;
				case 'b':
					stringBuilder.Append('\b');
					break;
				case 't':
					stringBuilder.Append('\t');
					break;
				case 'n':
					stringBuilder.Append('\n');
					break;
				case 'v':
					stringBuilder.Append('\v');
					break;
				case 'f':
					stringBuilder.Append('\f');
					break;
				case 'r':
					stringBuilder.Append('\r');
					break;
				case '"':
					stringBuilder.Append('"');
					c = '\0';
					break;
				case '\'':
					stringBuilder.Append('\'');
					c = '\0';
					break;
				case '\\':
					stringBuilder.Append('\\');
					break;
				case 'x':
					c = GetChar(currentPos++);
					if ((uint)(c - 48) <= 9u)
					{
						num2 = c - 48 << 4;
					}
					else if ((uint)(c - 65) <= 5u)
					{
						num2 = c + 10 - 65 << 4;
					}
					else
					{
						if ((uint)(c - 97) > 5u)
						{
							HandleError(JSError.BadHexDigit);
							if (c != cStringTerminator)
							{
								currentPos--;
							}
							break;
						}
						num2 = c + 10 - 97 << 4;
					}
					c = GetChar(currentPos++);
					if ((uint)(c - 48) <= 9u)
					{
						num2 |= c - 48;
					}
					else if ((uint)(c - 65) <= 5u)
					{
						num2 |= c + 10 - 65;
					}
					else
					{
						if ((uint)(c - 97) > 5u)
						{
							HandleError(JSError.BadHexDigit);
							if (c != cStringTerminator)
							{
								currentPos--;
							}
							break;
						}
						num2 |= c + 10 - 97;
					}
					stringBuilder.Append((char)num2);
					break;
				case 'u':
					c = GetChar(currentPos++);
					if ((uint)(c - 48) <= 9u)
					{
						num2 = c - 48 << 12;
					}
					else if ((uint)(c - 65) <= 5u)
					{
						num2 = c + 10 - 65 << 12;
					}
					else
					{
						if ((uint)(c - 97) > 5u)
						{
							HandleError(JSError.BadHexDigit);
							if (c != cStringTerminator)
							{
								currentPos--;
							}
							break;
						}
						num2 = c + 10 - 97 << 12;
					}
					c = GetChar(currentPos++);
					if ((uint)(c - 48) <= 9u)
					{
						num2 |= c - 48 << 8;
					}
					else if ((uint)(c - 65) <= 5u)
					{
						num2 |= c + 10 - 65 << 8;
					}
					else
					{
						if ((uint)(c - 97) > 5u)
						{
							HandleError(JSError.BadHexDigit);
							if (c != cStringTerminator)
							{
								currentPos--;
							}
							break;
						}
						num2 |= c + 10 - 97 << 8;
					}
					c = GetChar(currentPos++);
					if ((uint)(c - 48) <= 9u)
					{
						num2 |= c - 48 << 4;
					}
					else if ((uint)(c - 65) <= 5u)
					{
						num2 |= c + 10 - 65 << 4;
					}
					else
					{
						if ((uint)(c - 97) > 5u)
						{
							HandleError(JSError.BadHexDigit);
							if (c != cStringTerminator)
							{
								currentPos--;
							}
							break;
						}
						num2 |= c + 10 - 97 << 4;
					}
					c = GetChar(currentPos++);
					if ((uint)(c - 48) <= 9u)
					{
						num2 |= c - 48;
					}
					else if ((uint)(c - 65) <= 5u)
					{
						num2 |= c + 10 - 65;
					}
					else
					{
						if ((uint)(c - 97) > 5u)
						{
							HandleError(JSError.BadHexDigit);
							if (c != cStringTerminator)
							{
								currentPos--;
							}
							break;
						}
						num2 |= c + 10 - 97;
					}
					stringBuilder.Append((char)num2);
					break;
				case '0':
				case '1':
				case '2':
				case '3':
					flag = true;
					num2 = c - 48 << 6;
					goto case '4';
				case '4':
				case '5':
				case '6':
				case '7':
					if (!flag)
					{
						num2 = c - 48 << 3;
					}
					c = GetChar(currentPos++);
					if ((uint)(c - 48) <= 7u)
					{
						if (flag)
						{
							num2 |= c - 48 << 3;
							c = GetChar(currentPos++);
							if ((uint)(c - 48) <= 7u)
							{
								num2 |= c - 48;
								stringBuilder.Append((char)num2);
								break;
							}
							stringBuilder.Append((char)(num2 >> 3));
							if (c != cStringTerminator)
							{
								currentPos--;
							}
						}
						else
						{
							num2 |= c - 48;
							stringBuilder.Append((char)num2);
						}
					}
					else
					{
						if (flag)
						{
							stringBuilder.Append((char)(num2 >> 6));
						}
						else
						{
							stringBuilder.Append((char)(num2 >> 3));
						}
						if (c != cStringTerminator)
						{
							currentPos--;
						}
					}
					break;
				default:
					stringBuilder.Append(c);
					break;
				}
				num = currentPos;
			}
			while (c != cStringTerminator);
			if (stringBuilder != null)
			{
				if (currentPos - num - 1 > 0)
				{
					stringBuilder.Append(strSourceCode, num, currentPos - num - 1);
				}
				escapedString = stringBuilder.ToString();
			}
			else if (currentPos <= currentToken.startPos + 2)
			{
				escapedString = "";
			}
			else
			{
				escapedString = currentToken.source_string.Substring(currentToken.startPos + 1, currentPos - currentToken.startPos - 2);
			}
		}

		private void SkipSingleLineComment()
		{
			while (!IsEndLineOrEOF(GetChar(currentPos++), 0))
			{
			}
			if (IsAuthoring)
			{
				currentToken.endPos = currentPos;
				currentToken.endLineNumber = currentLine;
				currentToken.endLinePos = startLinePos;
				gotEndOfLine = true;
			}
			currentLine++;
			startLinePos = currentPos;
		}

		/// <summary>Skips a comment that spans multiple lines, and advances the pointers that identify the current position in the code.</summary>
		/// <returns>The new current position in the code string.</returns>
		public int SkipMultiLineComment()
		{
			while (true)
			{
				char @char = GetChar(currentPos);
				while ('*' == @char)
				{
					@char = GetChar(++currentPos);
					if ('/' == @char)
					{
						currentPos++;
						return currentPos;
					}
					if (@char == '\0')
					{
						break;
					}
					if (IsLineTerminator(@char, 1))
					{
						@char = GetChar(++currentPos);
						currentLine++;
						startLinePos = currentPos + 1;
					}
				}
				if (@char == '\0' && currentPos >= endPos)
				{
					break;
				}
				if (IsLineTerminator(@char, 1))
				{
					currentLine++;
					startLinePos = currentPos + 1;
				}
				currentPos++;
			}
			if (!IsAuthoring)
			{
				currentToken.endPos = --currentPos;
				currentToken.endLinePos = startLinePos;
				currentToken.endLineNumber = currentLine;
				throw new ScannerException(JSError.NoCommentEnd);
			}
			return currentPos;
		}

		private void SkipBlanks()
		{
			char @char = GetChar(currentPos);
			while (IsBlankSpace(@char))
			{
				@char = GetChar(++currentPos);
			}
		}

		private static bool IsBlankSpace(char c)
		{
			switch (c)
			{
			case '\t':
			case '\v':
			case '\f':
			case ' ':
			case '\u00a0':
				return true;
			default:
				if (c >= '\u0080')
				{
					return char.GetUnicodeCategory(c) == UnicodeCategory.SpaceSeparator;
				}
				return false;
			}
		}

		private bool IsLineTerminator(char c, int increment)
		{
			switch (c)
			{
			case '\r':
				if ('\n' == GetChar(currentPos + increment))
				{
					currentPos++;
				}
				return true;
			case '\n':
				return true;
			case '\u2028':
				return true;
			case '\u2029':
				return true;
			default:
				return false;
			}
		}

		private bool IsEndLineOrEOF(char c, int increment)
		{
			if (!IsLineTerminator(c, increment))
			{
				if (c == '\0')
				{
					return currentPos >= endPos;
				}
				return false;
			}
			return true;
		}

		private int GetHexValue(char hex)
		{
			if ('0' <= hex && hex <= '9')
			{
				return hex - 48;
			}
			if ('a' <= hex && hex <= 'f')
			{
				return hex - 97 + 10;
			}
			return hex - 65 + 10;
		}

		internal bool IsIdentifierPartChar(char c)
		{
			if (IsIdentifierStartChar(ref c))
			{
				return true;
			}
			if ('0' <= c && c <= '9')
			{
				return true;
			}
			if (c < '\u0080')
			{
				return false;
			}
			UnicodeCategory unicodeCategory = char.GetUnicodeCategory(c);
			if ((uint)(unicodeCategory - 5) <= 1u || unicodeCategory == UnicodeCategory.DecimalDigitNumber || unicodeCategory == UnicodeCategory.ConnectorPunctuation)
			{
				return true;
			}
			return false;
		}

		internal bool IsIdentifierStartChar(ref char c)
		{
			bool flag = false;
			if ('\\' == c && 'u' == GetChar(currentPos + 1))
			{
				char @char = GetChar(currentPos + 2);
				if (IsHexDigit(@char))
				{
					char char2 = GetChar(currentPos + 3);
					if (IsHexDigit(char2))
					{
						char char3 = GetChar(currentPos + 4);
						if (IsHexDigit(char3))
						{
							char char4 = GetChar(currentPos + 5);
							if (IsHexDigit(char4))
							{
								flag = true;
								c = (char)((GetHexValue(@char) << 12) | (GetHexValue(char2) << 8) | (GetHexValue(char3) << 4) | GetHexValue(char4));
							}
						}
					}
				}
			}
			if (('a' > c || c > 'z') && ('A' > c || c > 'Z') && '_' != c && '$' != c)
			{
				if (c < '\u0080')
				{
					return false;
				}
				UnicodeCategory unicodeCategory = char.GetUnicodeCategory(c);
				if ((uint)unicodeCategory > 4u && unicodeCategory != UnicodeCategory.LetterNumber)
				{
					return false;
				}
			}
			if (flag)
			{
				int num = ((idLastPosOnBuilder > 0) ? idLastPosOnBuilder : currentToken.startPos);
				if (currentPos - num > 0)
				{
					identifier.Append(strSourceCode.Substring(num, currentPos - num));
				}
				identifier.Append(c);
				currentPos += 5;
				idLastPosOnBuilder = currentPos + 1;
			}
			return true;
		}

		internal static bool IsDigit(char c)
		{
			if ('0' <= c)
			{
				return c <= '9';
			}
			return false;
		}

		internal static bool IsHexDigit(char c)
		{
			if (!IsDigit(c) && ('A' > c || c > 'F'))
			{
				if ('a' <= c)
				{
					return c <= 'f';
				}
				return false;
			}
			return true;
		}

		internal static bool IsAsciiLetter(char c)
		{
			if ('A' > c || c > 'Z')
			{
				if ('a' <= c)
				{
					return c <= 'z';
				}
				return false;
			}
			return true;
		}

		internal static bool IsUnicodeLetter(char c)
		{
			if (c >= '\u0080')
			{
				return char.IsLetter(c);
			}
			return false;
		}

		private void SetPreProcessorOn()
		{
			preProcessorOn = true;
			ppTable = new SimpleHashtable(16u);
			ppTable["_debug"] = globals.engine.GenerateDebugInfo;
			ppTable["_fast"] = ((IActivationObject)globals.ScopeStack.Peek()).GetGlobalScope().fast;
			ppTable["_jscript"] = true;
			ppTable["_jscript_build"] = GlobalObject.ScriptEngineBuildVersion();
			ppTable["_jscript_version"] = Convert.ToNumber(GlobalObject.ScriptEngineMajorVersion() + "." + GlobalObject.ScriptEngineMinorVersion());
			ppTable["_microsoft"] = true;
			if (globals.engine.PEMachineArchitecture == ImageFileMachine.I386 && globals.engine.PEKindFlags == PortableExecutableKinds.ILOnly)
			{
				ppTable["_win32"] = Environment.OSVersion.Platform.ToString().StartsWith("Win32", StringComparison.Ordinal);
				ppTable["_x86"] = true;
			}
			Hashtable hashtable = (Hashtable)globals.engine.GetOption("defines");
			if (hashtable == null)
			{
				return;
			}
			foreach (DictionaryEntry item in hashtable)
			{
				ppTable[item.Key] = item.Value;
			}
		}

		private bool PPTestCond()
		{
			SkipBlanks();
			if ('(' != GetChar(currentPos))
			{
				currentToken.startPos = currentPos - 1;
				currentToken.lineNumber = currentLine;
				currentToken.startLinePos = startLinePos;
				HandleError(JSError.NoLeftParen);
			}
			else
			{
				currentPos++;
			}
			object value = PPScanExpr();
			if (')' != GetChar(currentPos++))
			{
				currentToken.startPos = currentPos - 1;
				currentToken.lineNumber = currentLine;
				currentToken.startLinePos = startLinePos;
				HandleError(JSError.NoRightParen);
				currentPos--;
			}
			return Convert.ToBoolean(value);
		}

		private void PPSkipToNextCondition(bool checkCondition)
		{
			int num = 0;
			while (true)
			{
				switch (GetChar(currentPos++))
				{
				case '\0':
					if (currentPos >= endPos)
					{
						currentPos--;
						currentToken.endPos = currentPos;
						currentToken.endLineNumber = currentLine;
						currentToken.endLinePos = startLinePos;
						HandleError(JSError.NoCcEnd);
						throw new ScannerException(JSError.ErrEOF);
					}
					break;
				case '\r':
					if (GetChar(currentPos) == '\n')
					{
						currentPos++;
					}
					currentLine++;
					startLinePos = currentPos;
					break;
				case '\n':
					currentLine++;
					startLinePos = currentPos;
					break;
				case '\u2028':
					currentLine++;
					startLinePos = currentPos;
					break;
				case '\u2029':
					currentLine++;
					startLinePos = currentPos;
					break;
				case '@':
					currentToken.startPos = currentPos;
					currentToken.lineNumber = currentLine;
					currentToken.startLinePos = startLinePos;
					ScanIdentifier();
					switch (currentPos - currentToken.startPos)
					{
					case 2:
						if ('i' == strSourceCode[currentToken.startPos] && 'f' == strSourceCode[currentToken.startPos + 1])
						{
							num++;
						}
						break;
					case 3:
						if ('e' == strSourceCode[currentToken.startPos] && 'n' == strSourceCode[currentToken.startPos + 1] && 'd' == strSourceCode[currentToken.startPos + 2])
						{
							if (num == 0)
							{
								matchIf--;
								return;
							}
							num--;
						}
						break;
					case 4:
						if ('e' == strSourceCode[currentToken.startPos] && 'l' == strSourceCode[currentToken.startPos + 1] && 's' == strSourceCode[currentToken.startPos + 2] && 'e' == strSourceCode[currentToken.startPos + 3])
						{
							if (num == 0 && checkCondition)
							{
								return;
							}
						}
						else if ('e' == strSourceCode[currentToken.startPos] && 'l' == strSourceCode[currentToken.startPos + 1] && 'i' == strSourceCode[currentToken.startPos + 2] && 'f' == strSourceCode[currentToken.startPos + 3] && num == 0 && checkCondition && PPTestCond())
						{
							return;
						}
						break;
					}
					break;
				}
			}
		}

		private void PPScanSet()
		{
			SkipBlanks();
			if ('@' != GetChar(currentPos++))
			{
				HandleError(JSError.NoAt);
				currentPos--;
			}
			int num = currentPos;
			ScanIdentifier();
			int num2 = currentPos - num;
			string text = null;
			if (num2 == 0)
			{
				currentToken.startPos = currentPos - 1;
				currentToken.lineNumber = currentLine;
				currentToken.startLinePos = startLinePos;
				HandleError(JSError.NoIdentifier);
				text = "#_Missing CC Identifier_#";
			}
			else
			{
				text = strSourceCode.Substring(num, num2);
			}
			SkipBlanks();
			char @char = GetChar(currentPos++);
			if ('(' == @char)
			{
				if (text.Equals("position"))
				{
					PPRemapPositionInfo();
					return;
				}
				if (text.Equals("option"))
				{
					PPLanguageOption();
					return;
				}
				if (text.Equals("debug"))
				{
					PPDebugDirective();
					return;
				}
				currentToken.startPos = currentPos - 1;
				currentToken.lineNumber = currentLine;
				currentToken.startLinePos = startLinePos;
				HandleError(JSError.NoEqual);
				currentPos--;
			}
			else
			{
				if ('=' != @char)
				{
					currentToken.startPos = currentPos - 1;
					currentToken.lineNumber = currentLine;
					currentToken.startLinePos = startLinePos;
					HandleError(JSError.NoEqual);
					currentPos--;
				}
				object value = PPScanConstant();
				ppTable[text] = value;
			}
		}

		private object PPScanExpr()
		{
			OpListItem opListItem = new OpListItem(JSToken.None, OpPrec.precNone, null);
			ConstantListItem constantListItem = new ConstantListItem(PPScanConstant(), null);
			while (true)
			{
				GetNextToken();
				if (!IsPPOperator(currentToken.token))
				{
					break;
				}
				OpPrec pPOperatorPrecedence = GetPPOperatorPrecedence(currentToken.token);
				while (pPOperatorPrecedence < opListItem._prec)
				{
					object term = PPGetValue(opListItem._operator, constantListItem.prev.term, constantListItem.term);
					opListItem = opListItem._prev;
					constantListItem = constantListItem.prev.prev;
					constantListItem = new ConstantListItem(term, constantListItem);
				}
				opListItem = new OpListItem(currentToken.token, pPOperatorPrecedence, opListItem);
				constantListItem = new ConstantListItem(PPScanConstant(), constantListItem);
			}
			while (opListItem._operator != JSToken.None)
			{
				object term = PPGetValue(opListItem._operator, constantListItem.prev.term, constantListItem.term);
				opListItem = opListItem._prev;
				constantListItem = constantListItem.prev.prev;
				constantListItem = new ConstantListItem(term, constantListItem);
			}
			currentPos = currentToken.startPos;
			return constantListItem.term;
		}

		private void PPRemapPositionInfo()
		{
			GetNextToken();
			string text = null;
			int num = 0;
			int num2 = -1;
			bool flag = false;
			while (JSToken.RightParen != currentToken.token)
			{
				if (JSToken.Identifier == currentToken.token)
				{
					if (currentToken.Equals("file"))
					{
						if (currentDocument == null)
						{
							if (text == null)
							{
								GetNextToken();
								if (JSToken.Assign != currentToken.token)
								{
									HandleError(JSError.InvalidPositionDirective);
								}
								else
								{
									GetNextToken();
									if (JSToken.StringLiteral != currentToken.token)
									{
										HandleError(JSError.InvalidPositionDirective);
									}
									else
									{
										text = GetStringLiteral();
										if (!(text == currentToken.document.documentName))
										{
											goto IL_0316;
										}
										text = null;
										HandleError(JSError.InvalidPositionDirective);
									}
								}
							}
							else
							{
								HandleError(JSError.InvalidPositionDirective);
							}
						}
						else
						{
							HandleError(JSError.CannotNestPositionDirective);
						}
					}
					else if (currentToken.Equals("line"))
					{
						if (currentDocument == null)
						{
							if (num == 0)
							{
								GetNextToken();
								if (JSToken.Assign != currentToken.token)
								{
									HandleError(JSError.InvalidPositionDirective);
								}
								else
								{
									GetNextToken();
									if (JSToken.IntegerLiteral != currentToken.token)
									{
										HandleError(JSError.InvalidPositionDirective);
									}
									else
									{
										string code = currentToken.GetCode();
										double num3 = Convert.ToNumber(code, hexOK: true, octalOK: true, Missing.Value);
										if ((double)(int)num3 == num3 && num3 > 0.0)
										{
											num = (int)num3;
											goto IL_0316;
										}
										num = 1;
										HandleError(JSError.InvalidPositionDirective);
									}
								}
							}
							else
							{
								HandleError(JSError.InvalidPositionDirective);
							}
						}
						else
						{
							HandleError(JSError.CannotNestPositionDirective);
						}
					}
					else if (currentToken.Equals("column"))
					{
						if (currentDocument == null)
						{
							if (num2 == -1)
							{
								GetNextToken();
								if (JSToken.Assign != currentToken.token)
								{
									HandleError(JSError.InvalidPositionDirective);
								}
								else
								{
									GetNextToken();
									if (JSToken.IntegerLiteral != currentToken.token)
									{
										HandleError(JSError.InvalidPositionDirective);
									}
									else
									{
										string code2 = currentToken.GetCode();
										double num4 = Convert.ToNumber(code2, hexOK: true, octalOK: true, Missing.Value);
										if ((double)(int)num4 == num4 && num4 >= 0.0)
										{
											num2 = (int)num4;
											goto IL_0316;
										}
										num2 = 0;
										HandleError(JSError.InvalidPositionDirective);
									}
								}
							}
							else
							{
								HandleError(JSError.InvalidPositionDirective);
							}
						}
						else
						{
							HandleError(JSError.CannotNestPositionDirective);
						}
					}
					else if (currentToken.Equals("end"))
					{
						if (currentDocument != null)
						{
							GetNextToken();
							if (JSToken.RightParen == currentToken.token)
							{
								currentToken.document = currentDocument;
								currentDocument = null;
								flag = true;
								break;
							}
							HandleError(JSError.InvalidPositionDirective);
						}
						else
						{
							HandleError(JSError.WrongDirective);
						}
					}
					else
					{
						HandleError(JSError.InvalidPositionDirective);
					}
				}
				else
				{
					HandleError(JSError.InvalidPositionDirective);
				}
				while (JSToken.RightParen != currentToken.token && currentToken.token != 0)
				{
					GetNextToken();
				}
				break;
				IL_0316:
				GetNextToken();
				if (JSToken.RightParen == currentToken.token)
				{
					break;
				}
				if (JSToken.Semicolon == currentToken.token)
				{
					GetNextToken();
				}
			}
			SkipBlanks();
			if (';' == GetChar(currentPos))
			{
				currentPos++;
				SkipBlanks();
			}
			if (currentPos < endPos && !IsLineTerminator(GetChar(currentPos++), 0))
			{
				HandleError(JSError.MustBeEOL);
				while (currentPos < endPos && !IsLineTerminator(GetChar(currentPos++), 0))
				{
				}
			}
			currentLine++;
			startLinePos = currentPos;
			if (flag)
			{
				return;
			}
			if (text == null && num == 0 && num2 == -1)
			{
				HandleError(JSError.InvalidPositionDirective);
				return;
			}
			if (text == null)
			{
				text = currentToken.document.documentName;
			}
			if (num == 0)
			{
				num = 1;
			}
			if (num2 == -1)
			{
				num2 = 0;
			}
			currentDocument = currentToken.document;
			currentToken.document = new DocumentContext(text, num, num2, currentLine, currentDocument.sourceItem);
		}

		private void PPDebugDirective()
		{
			GetNextToken();
			bool flag = false;
			if (JSToken.Identifier == currentToken.token)
			{
				if (currentToken.Equals("off"))
				{
					flag = false;
				}
				else
				{
					if (!currentToken.Equals("on"))
					{
						HandleError(JSError.InvalidDebugDirective);
						goto IL_00c3;
					}
					flag = true;
				}
				GetNextToken();
				if (JSToken.RightParen != currentToken.token)
				{
					HandleError(JSError.InvalidDebugDirective);
				}
				else
				{
					currentToken.document.debugOn = flag && globals.engine.GenerateDebugInfo;
					ppTable["_debug"] = flag;
				}
			}
			else
			{
				HandleError(JSError.InvalidDebugDirective);
			}
			goto IL_00c3;
			IL_00c3:
			while (JSToken.RightParen != currentToken.token)
			{
				GetNextToken();
			}
			SkipBlanks();
			if (';' == GetChar(currentPos))
			{
				currentPos++;
				SkipBlanks();
			}
			if (!IsLineTerminator(GetChar(currentPos++), 0))
			{
				HandleError(JSError.MustBeEOL);
				while (!IsLineTerminator(GetChar(currentPos++), 0))
				{
				}
			}
			currentLine++;
			startLinePos = currentPos;
		}

		private void PPLanguageOption()
		{
			GetNextToken();
			HandleError(JSError.InvalidLanguageOption);
			GetNextToken();
			Context context = null;
			while (JSToken.RightParen != currentToken.token)
			{
				if (context == null)
				{
					context = currentToken.Clone();
				}
				else
				{
					context.UpdateWith(currentToken);
				}
				GetNextToken();
			}
			if (context != null)
			{
				HandleError(JSError.NoRightParen);
			}
		}

		private object PPScanConstant()
		{
			GetNextToken();
			object result;
			switch (currentToken.token)
			{
			case JSToken.FirstBinaryOp:
				result = Convert.ToNumber(PPScanConstant());
				break;
			case JSToken.Minus:
				result = 0.0 - Convert.ToNumber(PPScanConstant());
				break;
			case JSToken.BitwiseNot:
				result = ~Convert.ToInt32(PPScanConstant());
				break;
			case JSToken.FirstOp:
				result = !Convert.ToBoolean(PPScanConstant());
				break;
			case JSToken.IntegerLiteral:
				result = Convert.ToNumber(currentToken.GetCode(), hexOK: true, octalOK: true, Missing.Value);
				break;
			case JSToken.NumericLiteral:
				result = Convert.ToNumber(currentToken.GetCode(), hexOK: false, octalOK: false, Missing.Value);
				break;
			case JSToken.PreProcessorConstant:
				result = preProcessorValue;
				break;
			case JSToken.True:
				result = true;
				break;
			case JSToken.False:
				result = false;
				break;
			case JSToken.LeftParen:
				result = PPScanExpr();
				GetNextToken();
				if (JSToken.RightParen != currentToken.token)
				{
					currentToken.endPos = currentToken.startPos + 1;
					currentToken.endLineNumber = currentLine;
					currentToken.endLinePos = startLinePos;
					HandleError(JSError.NoRightParen);
					currentPos = currentToken.startPos;
				}
				break;
			default:
				HandleError(JSError.NotConst);
				currentPos = currentToken.startPos;
				result = true;
				break;
			}
			return result;
		}

		private object PPGetValue(JSToken op, object op1, object op2)
		{
			return op switch
			{
				JSToken.FirstBinaryOp => Convert.ToNumber(op1) + Convert.ToNumber(op2), 
				JSToken.Minus => Convert.ToNumber(op1) - Convert.ToNumber(op2), 
				JSToken.LogicalOr => Convert.ToBoolean(op1) || Convert.ToBoolean(op2), 
				JSToken.LogicalAnd => Convert.ToBoolean(op1) && Convert.ToBoolean(op2), 
				JSToken.BitwiseOr => Convert.ToInt32(op1) | Convert.ToInt32(op2), 
				JSToken.BitwiseXor => Convert.ToInt32(op1) ^ Convert.ToInt32(op2), 
				JSToken.BitwiseAnd => Convert.ToInt32(op1) & Convert.ToInt32(op2), 
				JSToken.Equal => Convert.ToNumber(op1) == Convert.ToNumber(op2), 
				JSToken.NotEqual => Convert.ToNumber(op1) != Convert.ToNumber(op2), 
				JSToken.StrictEqual => op1 == op2, 
				JSToken.StrictNotEqual => op1 != op2, 
				JSToken.GreaterThan => Convert.ToNumber(op1) > Convert.ToNumber(op2), 
				JSToken.LessThan => Convert.ToNumber(op1) < Convert.ToNumber(op2), 
				JSToken.LessThanEqual => Convert.ToNumber(op1) <= Convert.ToNumber(op2), 
				JSToken.GreaterThanEqual => Convert.ToNumber(op1) >= Convert.ToNumber(op2), 
				JSToken.LeftShift => Convert.ToInt32(op1) << Convert.ToInt32(op2), 
				JSToken.RightShift => Convert.ToInt32(op1) >> Convert.ToInt32(op2), 
				JSToken.UnsignedRightShift => (uint)Convert.ToInt32(op1) >> Convert.ToInt32(op2), 
				JSToken.Multiply => Convert.ToNumber(op1) * Convert.ToNumber(op2), 
				JSToken.Divide => Convert.ToNumber(op1) / Convert.ToNumber(op2), 
				JSToken.Modulo => Convert.ToInt32(op1) % Convert.ToInt32(op2), 
				_ => null, 
			};
		}

		internal object GetPreProcessorValue()
		{
			return preProcessorValue;
		}

		private void HandleError(JSError error)
		{
			if (!IsAuthoring)
			{
				currentToken.HandleError(error);
			}
		}

		/// <summary>Determines whether the specified token is an operator in the JScript language.</summary>
		/// <param name="token">The token to check.</param>
		/// <returns>
		///   <see langword="true" /> if the token is an operator; otherwise, <see langword="false" />.</returns>
		public static bool IsOperator(JSToken token)
		{
			if (JSToken.FirstOp <= token)
			{
				return token <= JSToken.Comma;
			}
			return false;
		}

		internal static bool IsAssignmentOperator(JSToken token)
		{
			if (JSToken.Assign <= token)
			{
				return token <= JSToken.UnsignedRightShiftAssign;
			}
			return false;
		}

		internal static bool CanStartStatement(JSToken token)
		{
			if (JSToken.If <= token)
			{
				return token <= JSToken.Function;
			}
			return false;
		}

		internal static bool CanParseAsExpression(JSToken token)
		{
			if (JSToken.FirstBinaryOp > token || token > JSToken.Comma)
			{
				if (JSToken.LeftParen <= token)
				{
					return token <= JSToken.AccessField;
				}
				return false;
			}
			return true;
		}

		internal static bool IsRightAssociativeOperator(JSToken token)
		{
			if (JSToken.Assign <= token)
			{
				return token <= JSToken.ConditionalIf;
			}
			return false;
		}

		/// <summary>Determines whether the specified token is a keyword in the JScript language.</summary>
		/// <param name="token">The token to check.</param>
		/// <returns>
		///   <see langword="true" /> if the token is a keyword; otherwise, <see langword="false" />.</returns>
		public static bool IsKeyword(JSToken token)
		{
			switch (token)
			{
			case JSToken.If:
			case JSToken.For:
			case JSToken.Do:
			case JSToken.While:
			case JSToken.Continue:
			case JSToken.Break:
			case JSToken.Return:
			case JSToken.Import:
			case JSToken.With:
			case JSToken.Switch:
			case JSToken.Throw:
			case JSToken.Try:
			case JSToken.Package:
			case JSToken.Abstract:
			case JSToken.Public:
			case JSToken.Static:
			case JSToken.Private:
			case JSToken.Protected:
			case JSToken.Final:
			case JSToken.Var:
			case JSToken.Const:
			case JSToken.Class:
			case JSToken.Function:
			case JSToken.Null:
			case JSToken.True:
			case JSToken.False:
			case JSToken.This:
			case JSToken.Delete:
			case JSToken.Void:
			case JSToken.Typeof:
			case JSToken.Instanceof:
			case JSToken.In:
			case JSToken.Case:
			case JSToken.Catch:
			case JSToken.Debugger:
			case JSToken.Default:
			case JSToken.Else:
			case JSToken.Export:
			case JSToken.Extends:
			case JSToken.Finally:
			case JSToken.Get:
			case JSToken.Implements:
			case JSToken.Interface:
			case JSToken.New:
			case JSToken.Set:
			case JSToken.Super:
			case JSToken.Boolean:
			case JSToken.Byte:
			case JSToken.Char:
			case JSToken.Double:
			case JSToken.Enum:
			case JSToken.Float:
			case JSToken.Goto:
			case JSToken.Int:
			case JSToken.Long:
			case JSToken.Native:
			case JSToken.Short:
			case JSToken.Synchronized:
			case JSToken.Transient:
			case JSToken.Throws:
			case JSToken.Volatile:
				return true;
			default:
				return false;
			}
		}

		internal static bool IsProcessableOperator(JSToken token)
		{
			if (JSToken.FirstBinaryOp <= token)
			{
				return token <= JSToken.ConditionalIf;
			}
			return false;
		}

		internal static bool IsPPOperator(JSToken token)
		{
			if (JSToken.FirstBinaryOp <= token)
			{
				return token <= JSToken.Modulo;
			}
			return false;
		}

		internal static OpPrec GetOperatorPrecedence(JSToken token)
		{
			return s_OperatorsPrec[(int)(token - 46)];
		}

		internal static OpPrec GetPPOperatorPrecedence(JSToken token)
		{
			return s_PPOperatorsPrec[(int)(token - 46)];
		}

		private static OpPrec[] InitOperatorsPrec()
		{
			OpPrec[] array = new OpPrec[36];
			array[0] = OpPrec.precAdditive;
			array[1] = OpPrec.precAdditive;
			array[2] = OpPrec.precLogicalOr;
			array[3] = OpPrec.precLogicalAnd;
			array[4] = OpPrec.precBitwiseOr;
			array[5] = OpPrec.precBitwiseXor;
			array[6] = OpPrec.precBitwiseAnd;
			array[7] = OpPrec.precEquality;
			array[8] = OpPrec.precEquality;
			array[9] = OpPrec.precEquality;
			array[10] = OpPrec.precEquality;
			array[21] = OpPrec.precRelational;
			array[22] = OpPrec.precRelational;
			array[11] = OpPrec.precRelational;
			array[12] = OpPrec.precRelational;
			array[13] = OpPrec.precRelational;
			array[14] = OpPrec.precRelational;
			array[15] = OpPrec.precShift;
			array[16] = OpPrec.precShift;
			array[17] = OpPrec.precShift;
			array[18] = OpPrec.precMultiplicative;
			array[19] = OpPrec.precMultiplicative;
			array[20] = OpPrec.precMultiplicative;
			array[23] = OpPrec.precAssignment;
			array[24] = OpPrec.precAssignment;
			array[25] = OpPrec.precAssignment;
			array[26] = OpPrec.precAssignment;
			array[27] = OpPrec.precAssignment;
			array[28] = OpPrec.precAssignment;
			array[29] = OpPrec.precAssignment;
			array[30] = OpPrec.precAssignment;
			array[31] = OpPrec.precAssignment;
			array[32] = OpPrec.precAssignment;
			array[33] = OpPrec.precAssignment;
			array[34] = OpPrec.precAssignment;
			array[35] = OpPrec.precConditional;
			return array;
		}

		private static OpPrec[] InitPPOperatorsPrec()
		{
			return new OpPrec[21]
			{
				OpPrec.precAdditive,
				OpPrec.precAdditive,
				OpPrec.precLogicalOr,
				OpPrec.precLogicalAnd,
				OpPrec.precBitwiseOr,
				OpPrec.precBitwiseXor,
				OpPrec.precBitwiseAnd,
				OpPrec.precEquality,
				OpPrec.precEquality,
				OpPrec.precEquality,
				OpPrec.precEquality,
				OpPrec.precRelational,
				OpPrec.precRelational,
				OpPrec.precRelational,
				OpPrec.precRelational,
				OpPrec.precShift,
				OpPrec.precShift,
				OpPrec.precShift,
				OpPrec.precMultiplicative,
				OpPrec.precMultiplicative,
				OpPrec.precMultiplicative
			};
		}
	}
	/// <summary>Specifies the individual units of code, or tokens, that make up the JScript language.</summary>
	public enum JSToken
	{
		/// <summary>No token. For example, before scanning any tokens, or in error situations.</summary>
		None = -1,
		/// <summary>The end of the file being scanned or parsed. This is the default value.</summary>
		EndOfFile = 0,
		/// <summary>The <c>if</c> statement.</summary>
		If = 1,
		/// <summary>The <c>for</c> statement.</summary>
		For = 2,
		/// <summary>The <c>do</c> statement.</summary>
		Do = 3,
		/// <summary>The <c>while</c> statement.</summary>
		While = 4,
		/// <summary>The <c>continue</c> statement.</summary>
		Continue = 5,
		/// <summary>The <c>break</c> statement.</summary>
		Break = 6,
		/// <summary>The <c>return</c> statement.</summary>
		Return = 7,
		/// <summary>The <c>import</c> statement.</summary>
		Import = 8,
		/// <summary>The <c>with</c> statement.</summary>
		With = 9,
		/// <summary>The <c>switch</c> statement.</summary>
		Switch = 10,
		/// <summary>The <c>throw</c> statement.</summary>
		Throw = 11,
		/// <summary>The <c>try</c> statement.</summary>
		Try = 12,
		/// <summary>The <c>package</c> statement.</summary>
		Package = 13,
		/// <summary>The <c>internal</c> modifier.</summary>
		Internal = 14,
		/// <summary>The <c>abstract</c> modifier.</summary>
		Abstract = 15,
		/// <summary>The <c>public</c> modifier.</summary>
		Public = 16,
		/// <summary>The <c>static</c> modifier.</summary>
		Static = 17,
		/// <summary>The <c>private</c> modifier.</summary>
		Private = 18,
		/// <summary>The <c>protected</c> modifier.</summary>
		Protected = 19,
		/// <summary>The <c>final</c> modifier.</summary>
		Final = 20,
		/// <summary>The <c>event</c> reserved word.</summary>
		Event = 21,
		/// <summary>The <c>var</c> statement.</summary>
		Var = 22,
		/// <summary>The <c>const</c> statement.</summary>
		Const = 23,
		/// <summary>The <c>class</c> statement.</summary>
		Class = 24,
		/// <summary>The <c>function</c> statement.</summary>
		Function = 25,
		/// <summary>The <c>{</c> symbol.</summary>
		LeftCurly = 26,
		/// <summary>The <c>;</c> symbol.</summary>
		Semicolon = 27,
		/// <summary>The <c>null</c> literal.</summary>
		Null = 28,
		/// <summary>The <c>true</c> literal.</summary>
		True = 29,
		/// <summary>The <c>false</c> literal.</summary>
		False = 30,
		/// <summary>The <c>this</c> statement.</summary>
		This = 31,
		/// <summary>An identifier.</summary>
		Identifier = 32,
		/// <summary>A numeric literal.</summary>
		StringLiteral = 33,
		/// <summary>An integer literal.</summary>
		IntegerLiteral = 34,
		/// <summary>A numeric literal.</summary>
		NumericLiteral = 35,
		/// <summary>The <c>(</c> symbol.</summary>
		LeftParen = 36,
		/// <summary>The <c>[</c> symbol.</summary>
		LeftBracket = 37,
		/// <summary>The <c>.</c> field accessor symbol.</summary>
		AccessField = 38,
		/// <summary>A placeholder enumeration member that enables comparisons such as <c>if JSToken.FirstOp &lt;= token &amp;&amp; token &lt;= JSToken.LastOp then...</c></summary>
		FirstOp = 39,
		/// <summary>The <c>!</c> logical NOT operator.</summary>
		LogicalNot = 39,
		/// <summary>The <c>~</c> bitwise NOT operator.</summary>
		BitwiseNot = 40,
		/// <summary>The <c>delete</c> operator.</summary>
		Delete = 41,
		/// <summary>The <c>void</c> operator.</summary>
		Void = 42,
		/// <summary>The <c>typeof</c> operator.</summary>
		Typeof = 43,
		/// <summary>The <c>++</c> increment operator.</summary>
		Increment = 44,
		/// <summary>The <c>--</c> decrement operator.</summary>
		Decrement = 45,
		/// <summary>A placeholder enumeration member that enables comparisons such as <c>if JSToken.FirstBinaryOp &lt;= token &amp;&amp; token &lt;= JSToken.LastBinaryOp then...</c></summary>
		FirstBinaryOp = 46,
		/// <summary>The <c>+</c> addition operator.</summary>
		Plus = 46,
		/// <summary>The <c>-</c> subtraction operator.</summary>
		Minus = 47,
		/// <summary>The <c>||</c> logical OR operator.</summary>
		LogicalOr = 48,
		/// <summary>The <c>&amp;&amp;</c> logical AND operator.</summary>
		LogicalAnd = 49,
		/// <summary>The <c>|</c> bitwise OR operator.</summary>
		BitwiseOr = 50,
		/// <summary>The <c>^</c> bitwise XOR operator.</summary>
		BitwiseXor = 51,
		/// <summary>The <c>&amp;</c> bitwise AND operator.</summary>
		BitwiseAnd = 52,
		/// <summary>The <c>==</c> equality comparison operator.</summary>
		Equal = 53,
		/// <summary>The <c>!=</c> inequality comparison operator.</summary>
		NotEqual = 54,
		/// <summary>The <c>===</c> identity comparison operator.</summary>
		StrictEqual = 55,
		/// <summary>The <c>!==</c> identity comparison operator.</summary>
		StrictNotEqual = 56,
		/// <summary>The <c>&gt;</c> relational comparison operator.</summary>
		GreaterThan = 57,
		/// <summary>The <c>&lt;</c> relational comparison operator.</summary>
		LessThan = 58,
		/// <summary>The <c>&lt;=</c> relational comparison operator.</summary>
		LessThanEqual = 59,
		/// <summary>The <c>&gt;=</c> relational comparison operator.</summary>
		GreaterThanEqual = 60,
		/// <summary>The <c>&lt;&lt;</c> bitwise left shift operator.</summary>
		LeftShift = 61,
		/// <summary>The <c>&gt;&gt;</c> bitwise right shift operator.</summary>
		RightShift = 62,
		/// <summary>The <c>&gt;&gt;&gt;</c> unsigned right shift operator.</summary>
		UnsignedRightShift = 63,
		/// <summary>The <c>*</c> multiplication operator.</summary>
		Multiply = 64,
		/// <summary>The <c>/</c> division operator.</summary>
		Divide = 65,
		/// <summary>The <c>%</c> modulus operator.</summary>
		Modulo = 66,
		/// <summary>A placeholder enumeration member that enables comparisons such as <c>if JSToken.FirstBinaryOp &lt;= token &amp;&amp; token &lt;= JSToken.LastPPOperator then...</c> PPOperators are operations that can be pre-processed.</summary>
		LastPPOperator = 66,
		/// <summary>The <c>instanceof</c> operator.</summary>
		Instanceof = 67,
		/// <summary>The <c>in</c> operator.</summary>
		In = 68,
		/// <summary>The <c>=</c> assignment operator.</summary>
		Assign = 69,
		/// <summary>The <c>+=</c> addition assignment operator.</summary>
		PlusAssign = 70,
		/// <summary>The <c>-=</c> subtraction assignment operator.</summary>
		MinusAssign = 71,
		/// <summary>The <c>*=</c> multiplication assignment operator.</summary>
		MultiplyAssign = 72,
		/// <summary>The <c>/=</c> division assignment operator.</summary>
		DivideAssign = 73,
		/// <summary>The <c>&amp;=</c> bitwise AND assignment operator.</summary>
		BitwiseAndAssign = 74,
		/// <summary>The <c>|=</c> bitwise OR assignment operator.</summary>
		BitwiseOrAssign = 75,
		/// <summary>The <c>^=</c> bitwise XOR assignment operator.</summary>
		BitwiseXorAssign = 76,
		/// <summary>The <c>%=</c> modulus assignment operator.</summary>
		ModuloAssign = 77,
		/// <summary>The <c>&lt;&lt;=</c> left shift assignment operator.</summary>
		LeftShiftAssign = 78,
		/// <summary>The <c>&gt;&gt;=</c> right shift assignment operator.</summary>
		RightShiftAssign = 79,
		/// <summary>The <c>&gt;&gt;&gt;=</c> unsigned right shift assignment operator.</summary>
		UnsignedRightShiftAssign = 80,
		/// <summary>A placeholder enumeration member that enables comparisons such as <c>if JSToken.Assign &lt;= token &amp;&amp; token &lt;= JSToken.LastAssign then...</c></summary>
		LastAssign = 80,
		/// <summary>A placeholder enumeration member that enables comparisons such as <c>if JSToken.FirstBinaryOp &lt;= token &amp;&amp; token &lt;= JSToken.LastBinaryOp then...</c></summary>
		LastBinaryOp = 80,
		/// <summary>The <c>?</c> ternary operator.</summary>
		ConditionalIf = 81,
		/// <summary>The <c>:</c> ternary operator.</summary>
		Colon = 82,
		/// <summary>The <c>,</c> comma operator.</summary>
		Comma = 83,
		/// <summary>A placeholder enumeration member that enables comparisons such as <c>if JSToken.FirstBinaryOp &lt;= token &amp;&amp; token &lt;= JSToken.LastOp then...</c></summary>
		LastOp = 83,
		/// <summary>The <c>case</c> keyword of a <c>switch</c> statement.</summary>
		Case = 84,
		/// <summary>The <c>catch</c> keyword of a <c>try</c> statement.</summary>
		Catch = 85,
		/// <summary>The <c>debugger</c> statement.</summary>
		Debugger = 86,
		/// <summary>The <c>default</c> keyword of a <c>switch</c> statement.</summary>
		Default = 87,
		/// <summary>The <c>else</c> keyword of an <c>if</c> statement.</summary>
		Else = 88,
		/// <summary>The <c>export</c> reserved word.</summary>
		Export = 89,
		/// <summary>The <c>extends</c> keyword of a <c>class</c> statement.</summary>
		Extends = 90,
		/// <summary>The <c>finally</c> keyword of a <c>try</c> statement.</summary>
		Finally = 91,
		/// <summary>The <c>get</c> keyword of a <c>function get</c> statement.</summary>
		Get = 92,
		/// <summary>The <c>implements</c> keyword of a <c>class</c> or <c>interface</c> statement.</summary>
		Implements = 93,
		/// <summary>The <c>interface</c> statement.</summary>
		Interface = 94,
		/// <summary>The <c>new</c> operator.</summary>
		New = 95,
		/// <summary>The <c>set</c> keyword of a <c>function set</c> statement.</summary>
		Set = 96,
		/// <summary>The <c>super</c> statement.</summary>
		Super = 97,
		/// <summary>The <c>)</c> symbol.</summary>
		RightParen = 98,
		/// <summary>The <c>}</c> symbol.</summary>
		RightCurly = 99,
		/// <summary>The <c>]</c> symbol.</summary>
		RightBracket = 100,
		/// <summary>A preprocessor constant.</summary>
		PreProcessorConstant = 101,
		/// <summary>Comment text.</summary>
		Comment = 102,
		/// <summary>An un-terminated comment.</summary>
		UnterminatedComment = 103,
		/// <summary>The <c>assert</c> reserved word.</summary>
		Assert = 104,
		/// <summary>The <c>boolean</c> data type.</summary>
		Boolean = 105,
		/// <summary>The <c>byte</c> data type.</summary>
		Byte = 106,
		/// <summary>The <c>char</c> data type.</summary>
		Char = 107,
		/// <summary>The <c>decimal</c> data type.</summary>
		Decimal = 108,
		/// <summary>The <c>double</c> data type.</summary>
		Double = 109,
		/// <summary>The <c>::</c> reserved word.</summary>
		DoubleColon = 110,
		/// <summary>The <c>enum</c> statement.</summary>
		Enum = 111,
		/// <summary>The <c>ensure</c> reserved word.</summary>
		Ensure = 112,
		/// <summary>The <c>float</c> data type.</summary>
		Float = 113,
		/// <summary>The <c>goto</c> reserved word.</summary>
		Goto = 114,
		/// <summary>The <c>int</c> data type.</summary>
		Int = 115,
		/// <summary>The <c>invariant</c> reserved word.</summary>
		Invariant = 116,
		/// <summary>The <c>long</c> data type.</summary>
		Long = 117,
		/// <summary>The <c>namespace</c> reserved word.</summary>
		Namespace = 118,
		/// <summary>The <c>native</c> reserved word.</summary>
		Native = 119,
		/// <summary>The <c>require</c> reserved word.</summary>
		Require = 120,
		/// <summary>The <c>sbyte</c> data type.</summary>
		Sbyte = 121,
		/// <summary>The <c>short</c> data type.</summary>
		Short = 122,
		/// <summary>The <c>synchronized</c> reserved word.</summary>
		Synchronized = 123,
		/// <summary>The <c>transient</c> reserved word.</summary>
		Transient = 124,
		/// <summary>The <c>throws</c> reserved word.</summary>
		Throws = 125,
		/// <summary>The <c>...</c> reserved word.</summary>
		ParamArray = 126,
		/// <summary>The <c>volatile</c> reserved word.</summary>
		Volatile = 127,
		/// <summary>The <c>ushort</c> data type.</summary>
		Ushort = 128,
		/// <summary>The <c>uint</c> data type.</summary>
		Uint = 129,
		/// <summary>The <c>ulong</c> data type.</summary>
		Ulong = 130,
		/// <summary>The <c>use</c> reserved word.</summary>
		Use = 131,
		/// <summary>The end of the line being parsed.</summary>
		EndOfLine = 132,
		/// <summary>A preprocessor directive.</summary>
		PreProcessDirective = 133
	}
	/// <summary>Supports variable fields in JScript. This is the base class for parameters, local variables, global variables, and class members.</summary>
	public abstract class JSVariableField : JSField
	{
		internal ScriptObject obj;

		private string name;

		internal string debuggerName;

		internal object metaData;

		internal TypeExpression type;

		internal FieldAttributes attributeFlags;

		private MethodInfo method;

		internal object value;

		internal CustomAttributeList customAttributes;

		internal Context originalContext;

		internal CLSComplianceSpec clsCompliance;

		/// <summary>Gets the attributes that are associated with this field.</summary>
		/// <returns>A bitwise combination of the enumeration values.</returns>
		public override FieldAttributes Attributes => attributeFlags;

		/// <summary>Gets the type that declares this field.</summary>
		/// <returns>The <see langword="Type" /> object for the class that declares this member.</returns>
		public override Type DeclaringType
		{
			get
			{
				if (obj is ClassScope)
				{
					return ((ClassScope)obj).GetTypeBuilderOrEnumBuilder();
				}
				return null;
			}
		}

		/// <summary>Gets the type of this field.</summary>
		/// <returns>The type of this field.</returns>
		public override Type FieldType
		{
			get
			{
				Type type = Typeob.Object;
				if (this.type != null)
				{
					type = this.type.ToType();
					if (type == Typeob.Void)
					{
						type = Typeob.Object;
					}
				}
				return type;
			}
		}

		/// <summary>Gets the name of this field.</summary>
		/// <returns>The name of this field.</returns>
		public override string Name => name;

		internal JSVariableField(string name, ScriptObject obj, FieldAttributes attributeFlags)
		{
			this.obj = obj;
			this.name = name;
			debuggerName = name;
			metaData = null;
			if ((attributeFlags & FieldAttributes.FieldAccessMask) == 0)
			{
				attributeFlags |= FieldAttributes.Public;
			}
			this.attributeFlags = attributeFlags;
			type = null;
			method = null;
			value = null;
			originalContext = null;
			clsCompliance = CLSComplianceSpec.NotAttributed;
		}

		internal void CheckCLSCompliance(bool classIsCLSCompliant)
		{
			if (customAttributes != null)
			{
				CustomAttribute attribute = customAttributes.GetAttribute(Typeob.CLSCompliantAttribute);
				if (attribute != null)
				{
					clsCompliance = attribute.GetCLSComplianceValue();
					customAttributes.Remove(attribute);
				}
			}
			if (classIsCLSCompliant)
			{
				if (clsCompliance != CLSComplianceSpec.NonCLSCompliant && type != null && !type.IsCLSCompliant())
				{
					clsCompliance = CLSComplianceSpec.NonCLSCompliant;
					if (originalContext != null)
					{
						originalContext.HandleError(JSError.NonCLSCompliantMember);
					}
				}
			}
			else if (clsCompliance == CLSComplianceSpec.CLSCompliant)
			{
				originalContext.HandleError(JSError.MemberTypeCLSCompliantMismatch);
			}
		}

		internal MethodInfo GetAsMethod(object obj)
		{
			if (method == null)
			{
				method = new JSFieldMethod(this, obj);
			}
			return method;
		}

		internal override string GetClassFullName()
		{
			if (obj is ClassScope)
			{
				return ((ClassScope)obj).GetFullName();
			}
			throw new JScriptException(JSError.InternalError);
		}

		/// <summary>Returns an array that contains the custom attributes that are attached to this field.</summary>
		/// <param name="inherit">
		///   <see langword="true" /> to search this member's inheritance hierarchy to find the attributes.</param>
		/// <returns>An array that contains the custom attributes that are attached to this field, or, if there are none, an array that has zero elements.</returns>
		public override object[] GetCustomAttributes(bool inherit)
		{
			if (customAttributes != null)
			{
				return (object[])customAttributes.Evaluate();
			}
			return new object[0];
		}

		internal virtual IReflect GetInferredType(JSField inference_target)
		{
			if (type != null)
			{
				return type.ToIReflect();
			}
			return Typeob.Object;
		}

		internal override object GetMetaData()
		{
			return metaData;
		}

		internal override PackageScope GetPackage()
		{
			if (obj is ClassScope)
			{
				return ((ClassScope)obj).GetPackage();
			}
			throw new JScriptException(JSError.InternalError);
		}

		internal void WriteCustomAttribute(bool doCRS)
		{
			if (!(metaData is FieldBuilder))
			{
				return;
			}
			FieldBuilder fieldBuilder = (FieldBuilder)metaData;
			if (customAttributes != null)
			{
				CustomAttributeBuilder[] customAttributeBuilders = customAttributes.GetCustomAttributeBuilders(getForProperty: false);
				int i = 0;
				for (int num = customAttributeBuilders.Length; i < num; i++)
				{
					fieldBuilder.SetCustomAttribute(customAttributeBuilders[i]);
				}
			}
			if (clsCompliance == CLSComplianceSpec.CLSCompliant)
			{
				fieldBuilder.SetCustomAttribute(new CustomAttributeBuilder(CompilerGlobals.clsCompliantAttributeCtor, new object[1] { true }));
			}
			else if (clsCompliance == CLSComplianceSpec.NonCLSCompliant)
			{
				fieldBuilder.SetCustomAttribute(new CustomAttributeBuilder(CompilerGlobals.clsCompliantAttributeCtor, new object[1] { false }));
			}
			if (doCRS && base.IsStatic)
			{
				fieldBuilder.SetCustomAttribute(new CustomAttributeBuilder(CompilerGlobals.contextStaticAttributeCtor, new object[0]));
			}
		}
	}
	internal sealed class JSWrappedField : JSField, IWrappedMember
	{
		internal FieldInfo wrappedField;

		internal object wrappedObject;

		public override string Name => wrappedField.Name;

		public override FieldAttributes Attributes => wrappedField.Attributes;

		public override Type DeclaringType => wrappedField.DeclaringType;

		public override Type FieldType => wrappedField.FieldType;

		internal JSWrappedField(FieldInfo field, object obj)
		{
			if (field is JSFieldInfo)
			{
				field = ((JSFieldInfo)field).field;
			}
			wrappedField = field;
			wrappedObject = obj;
			if (obj is JSObject && !Typeob.JSObject.IsAssignableFrom(field.DeclaringType))
			{
				if (obj is BooleanObject)
				{
					wrappedObject = ((BooleanObject)obj).value;
				}
				else if (obj is NumberObject)
				{
					wrappedObject = ((NumberObject)obj).value;
				}
				else if (obj is StringObject)
				{
					wrappedObject = ((StringObject)obj).value;
				}
			}
		}

		internal override string GetClassFullName()
		{
			if (wrappedField is JSField)
			{
				return ((JSField)wrappedField).GetClassFullName();
			}
			return wrappedField.DeclaringType.FullName;
		}

		internal override object GetMetaData()
		{
			if (wrappedField is JSField)
			{
				return ((JSField)wrappedField).GetMetaData();
			}
			return wrappedField;
		}

		internal override PackageScope GetPackage()
		{
			if (wrappedField is JSField)
			{
				return ((JSField)wrappedField).GetPackage();
			}
			return null;
		}

		public override object GetValue(object obj)
		{
			return wrappedField.GetValue(wrappedObject);
		}

		public object GetWrappedObject()
		{
			return wrappedObject;
		}

		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo locale)
		{
			wrappedField.SetValue(wrappedObject, value, invokeAttr, binder, locale);
		}
	}
	internal sealed class JSWrappedMethod : JSMethod, IWrappedMember
	{
		internal MethodInfo method;

		private ParameterInfo[] pars;

		public override MethodAttributes Attributes => method.Attributes;

		public override Type DeclaringType => method.DeclaringType;

		public override string Name => method.Name;

		public override Type ReturnType => method.ReturnType;

		internal JSWrappedMethod(MethodInfo method, object obj)
			: base(obj)
		{
			base.obj = obj;
			if (method is JSMethodInfo)
			{
				method = ((JSMethodInfo)method).method;
			}
			this.method = method.GetBaseDefinition();
			pars = this.method.GetParameters();
			if (obj is JSObject && !Typeob.JSObject.IsAssignableFrom(method.DeclaringType))
			{
				if (obj is BooleanObject)
				{
					base.obj = ((BooleanObject)obj).value;
				}
				else if (obj is NumberObject)
				{
					base.obj = ((NumberObject)obj).value;
				}
				else if (obj is StringObject)
				{
					base.obj = ((StringObject)obj).value;
				}
				else if (obj is ArrayWrapper)
				{
					base.obj = ((ArrayWrapper)obj).value;
				}
			}
		}

		private object[] CheckArguments(object[] args)
		{
			object[] array = args;
			if (args != null && args.Length < pars.Length)
			{
				array = new object[pars.Length];
				ArrayObject.Copy(args, array, args.Length);
				int i = args.Length;
				for (int num = pars.Length; i < num; i++)
				{
					array[i] = Type.Missing;
				}
			}
			return array;
		}

		internal override object Construct(object[] args)
		{
			if (method is JSMethod)
			{
				return ((JSMethod)method).Construct(args);
			}
			if (method.GetParameters().Length == 0 && method.ReturnType == Typeob.Object)
			{
				object obj = method.Invoke(base.obj, BindingFlags.SuppressChangeType, null, null, null);
				if (obj is ScriptFunction)
				{
					return ((ScriptFunction)obj).Construct(args);
				}
			}
			throw new JScriptException(JSError.NoConstructor);
		}

		internal override string GetClassFullName()
		{
			if (method is JSMethod)
			{
				return ((JSMethod)method).GetClassFullName();
			}
			return method.DeclaringType.FullName;
		}

		internal override PackageScope GetPackage()
		{
			if (method is JSMethod)
			{
				return ((JSMethod)method).GetPackage();
			}
			return null;
		}

		public override ParameterInfo[] GetParameters()
		{
			return pars;
		}

		internal override MethodInfo GetMethodInfo(CompilerGlobals compilerGlobals)
		{
			if (method is JSMethod)
			{
				return ((JSMethod)method).GetMethodInfo(compilerGlobals);
			}
			return method;
		}

		public object GetWrappedObject()
		{
			return obj;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		public override object Invoke(object obj, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			parameters = CheckArguments(parameters);
			return Invoke(base.obj, base.obj, options, binder, parameters, culture);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object Invoke(object obj, object thisob, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			parameters = CheckArguments(parameters);
			if (base.obj != null && !(base.obj is Type))
			{
				obj = base.obj;
			}
			if (method is JSMethod)
			{
				return ((JSMethod)method).Invoke(obj, thisob, options, binder, parameters, culture);
			}
			return method.Invoke(obj, options, binder, parameters, culture);
		}

		public override string ToString()
		{
			return method.ToString();
		}
	}
	internal class JSWrappedProperty : PropertyInfo, IWrappedMember
	{
		internal object obj;

		internal PropertyInfo property;

		public override MemberTypes MemberType => MemberTypes.Property;

		public override string Name
		{
			get
			{
				if (obj is LenientGlobalObject && property.Name.StartsWith("Slow", StringComparison.Ordinal))
				{
					return property.Name.Substring(4);
				}
				return property.Name;
			}
		}

		public override Type DeclaringType => property.DeclaringType;

		public override Type ReflectedType => property.ReflectedType;

		public override PropertyAttributes Attributes => property.Attributes;

		public override bool CanRead => property.CanRead;

		public override bool CanWrite => property.CanWrite;

		public override Type PropertyType => property.PropertyType;

		internal JSWrappedProperty(PropertyInfo property, object obj)
		{
			this.obj = obj;
			this.property = property;
			if (!(obj is JSObject))
			{
				return;
			}
			Type declaringType = property.DeclaringType;
			if (declaringType == Typeob.Object || declaringType == Typeob.String || declaringType.IsPrimitive || declaringType == Typeob.Array)
			{
				if (obj is BooleanObject)
				{
					this.obj = ((BooleanObject)obj).value;
				}
				else if (obj is NumberObject)
				{
					this.obj = ((NumberObject)obj).value;
				}
				else if (obj is StringObject)
				{
					this.obj = ((StringObject)obj).value;
				}
				else if (obj is ArrayWrapper)
				{
					this.obj = ((ArrayWrapper)obj).value;
				}
			}
		}

		internal virtual string GetClassFullName()
		{
			if (property is JSProperty)
			{
				return ((JSProperty)property).GetClassFullName();
			}
			return property.DeclaringType.FullName;
		}

		public override object[] GetCustomAttributes(Type t, bool inherit)
		{
			return CustomAttribute.GetCustomAttributes(property, t, inherit);
		}

		public override object[] GetCustomAttributes(bool inherit)
		{
			return property.GetCustomAttributes(inherit);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		public override object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)
		{
			return property.GetValue(this.obj, invokeAttr, binder, index, culture);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)
		{
			property.SetValue(this.obj, value, invokeAttr, binder, index, culture);
		}

		public override MethodInfo[] GetAccessors(bool nonPublic)
		{
			return property.GetAccessors(nonPublic);
		}

		public override MethodInfo GetGetMethod(bool nonPublic)
		{
			MethodInfo getMethod = JSProperty.GetGetMethod(property, nonPublic);
			if (getMethod == null)
			{
				return null;
			}
			return new JSWrappedMethod(getMethod, obj);
		}

		public override ParameterInfo[] GetIndexParameters()
		{
			return property.GetIndexParameters();
		}

		public override MethodInfo GetSetMethod(bool nonPublic)
		{
			MethodInfo setMethod = JSProperty.GetSetMethod(property, nonPublic);
			if (setMethod == null)
			{
				return null;
			}
			return new JSWrappedMethod(setMethod, obj);
		}

		public object GetWrappedObject()
		{
			return obj;
		}

		public override bool IsDefined(Type type, bool inherit)
		{
			return CustomAttribute.IsDefined(property, type, inherit);
		}
	}
	internal class JSWrappedPropertyAndMethod : JSWrappedProperty
	{
		protected MethodInfo method;

		private ParameterInfo[] parameters;

		public MethodInfo Method => method;

		internal JSWrappedPropertyAndMethod(PropertyInfo property, MethodInfo method, object obj)
			: base(property, obj)
		{
			this.method = method;
			parameters = method.GetParameters();
		}

		private object[] CheckArguments(object[] arguments)
		{
			if (arguments == null)
			{
				return arguments;
			}
			int num = arguments.Length;
			int num2 = parameters.Length;
			if (num >= num2)
			{
				return arguments;
			}
			object[] array = new object[num2];
			ArrayObject.Copy(arguments, array, num);
			for (int i = num; i < num2; i++)
			{
				array[i] = Type.Missing;
			}
			return array;
		}

		internal object Invoke(object obj, BindingFlags options, Binder binder, object[] parameters, CultureInfo culture)
		{
			parameters = CheckArguments(parameters);
			if (base.obj != null && !(base.obj is Type))
			{
				obj = base.obj;
			}
			return method.Invoke(obj, options, binder, parameters, culture);
		}
	}
	/// <summary>Represents a reference to a class member, callable expression, or variable name. This class attempts to resolve the reference to the correct value at run time.</summary>
	public sealed class LateBinding
	{
		private object last_ir;

		internal MemberInfo last_member;

		internal MemberInfo[] last_members;

		internal object last_object;

		private string name;

		/// <summary>Stores a reference to the object that the binding reference is defined on.</summary>
		public object obj;

		private bool checkForDebugger;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.LateBinding" /> class, using the specified identifier.</summary>
		/// <param name="name">A string that identifies the binding reference.</param>
		public LateBinding(string name)
			: this(name, null, checkForDebugger: false)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.LateBinding" /> class, using the specified identifier and object.</summary>
		/// <param name="name">A string that identifies the binding reference.</param>
		/// <param name="obj">The object that the binding reference is defined on.</param>
		public LateBinding(string name, object obj)
			: this(name, obj, checkForDebugger: false)
		{
		}

		internal LateBinding(string name, object obj, bool checkForDebugger)
		{
			last_ir = null;
			last_member = null;
			last_members = null;
			last_object = null;
			this.name = name;
			this.obj = obj;
			this.checkForDebugger = checkForDebugger;
		}

		internal MemberInfo BindToMember()
		{
			if (this.obj == last_object && last_member != null)
			{
				return last_member;
			}
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
			object obj = this.obj;
			Type type = obj.GetType();
			TypeReflector typeReflectorFor = TypeReflector.GetTypeReflectorFor(type);
			IReflect reflect = null;
			if (typeReflectorFor.Is__ComObject())
			{
				if (!checkForDebugger)
				{
					return null;
				}
				if (!(obj is IDebuggerObject debuggerObject))
				{
					return null;
				}
				if (debuggerObject.IsCOMObject())
				{
					return null;
				}
				reflect = (IReflect)obj;
			}
			else if (typeReflectorFor.ImplementsIReflect())
			{
				reflect = obj as ScriptObject;
				if (reflect != null)
				{
					if (obj is ClassScope)
					{
						bindingAttr = BindingFlags.Static | BindingFlags.Public;
					}
				}
				else
				{
					reflect = obj as Type;
					if (reflect != null)
					{
						bindingAttr = BindingFlags.Static | BindingFlags.Public;
					}
					else
					{
						reflect = (IReflect)obj;
					}
				}
			}
			else
			{
				reflect = typeReflectorFor;
			}
			last_object = this.obj;
			last_ir = reflect;
			MemberInfo[] array = (last_members = reflect.GetMember(name, bindingAttr));
			last_member = SelectMember(array);
			if (this.obj is Type)
			{
				MemberInfo[] member = typeof(Type).GetMember(name, BindingFlags.Instance | BindingFlags.Public);
				int num = 0;
				int num2 = 0;
				if (member != null && (num = member.Length) > 0)
				{
					if (array == null || (num2 = array.Length) == 0)
					{
						last_member = SelectMember(last_members = member);
					}
					else
					{
						MemberInfo[] array2 = new MemberInfo[num + num2];
						object[] array3 = array;
						object[] source = array3;
						array3 = array2;
						ArrayObject.Copy(source, 0, array3, 0, num2);
						array3 = member;
						object[] source2 = array3;
						array3 = array2;
						ArrayObject.Copy(source2, 0, array3, num2, num);
						last_member = SelectMember(last_members = array2);
					}
				}
			}
			return last_member;
		}

		/// <summary>Resolves the binding reference by calling a member.</summary>
		/// <param name="arguments">The arguments to pass to the member.</param>
		/// <param name="construct">
		///   <see langword="true" /> to use the construct method; otherwise, <see langword="false" />.</param>
		/// <param name="brackets">
		///   <see langword="true" /> if the binding reference contains brackets; otherwise, <see langword="false" />.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>The return value of the call to the member.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public object Call(object[] arguments, bool construct, bool brackets, VsaEngine engine)
		{
			try
			{
				if (name == null)
				{
					return CallValue(obj, arguments, construct, brackets, engine, ((IActivationObject)engine.ScriptObjectStackTop()).GetDefaultThisObject(), JSBinder.ob, null, null);
				}
				return Call(JSBinder.ob, arguments, null, null, null, construct, brackets, engine);
			}
			catch (TargetInvocationException ex)
			{
				throw ex.InnerException;
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal object Call(Binder binder, object[] arguments, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters, bool construct, bool brackets, VsaEngine engine)
		{
			MemberInfo memberInfo = BindToMember();
			if (obj is ScriptObject || obj is GlobalObject)
			{
				if (obj is WithObject)
				{
					object contained_object = ((WithObject)obj).contained_object;
					if (!(contained_object is ScriptObject))
					{
						IReflect iRForObjectThatRequiresInvokeMember = GetIRForObjectThatRequiresInvokeMember(contained_object, VsaEngine.executeForJSEE);
						if (iRForObjectThatRequiresInvokeMember != null)
						{
							return CallCOMObject(iRForObjectThatRequiresInvokeMember, name, contained_object, binder, arguments, modifiers, culture, namedParameters, construct, brackets, engine);
						}
					}
				}
				if (memberInfo is FieldInfo)
				{
					return CallValue(((FieldInfo)memberInfo).GetValue(obj), arguments, construct, brackets, engine, obj, JSBinder.ob, null, null);
				}
				if (memberInfo is PropertyInfo && !(memberInfo is JSProperty))
				{
					if (!brackets)
					{
						JSWrappedPropertyAndMethod jSWrappedPropertyAndMethod = memberInfo as JSWrappedPropertyAndMethod;
						if (jSWrappedPropertyAndMethod != null)
						{
							BindingFlags options = ((arguments == null || arguments.Length == 0) ? BindingFlags.InvokeMethod : (BindingFlags.InvokeMethod | BindingFlags.GetProperty));
							return jSWrappedPropertyAndMethod.Invoke(obj, options, JSBinder.ob, arguments, null);
						}
					}
					return CallValue(JSProperty.GetValue((PropertyInfo)memberInfo, obj, null), arguments, construct, brackets, engine, obj, JSBinder.ob, null, null);
				}
				if (memberInfo is MethodInfo)
				{
					if (memberInfo is JSMethod)
					{
						if (construct)
						{
							return ((JSMethod)memberInfo).Construct(arguments);
						}
						return ((JSMethod)memberInfo).Invoke(obj, obj, BindingFlags.Default, JSBinder.ob, arguments, null);
					}
					Type declaringType = memberInfo.DeclaringType;
					if (declaringType == typeof(object))
					{
						return CallMethod((MethodInfo)memberInfo, arguments, obj, binder, culture, namedParameters);
					}
					if (declaringType == typeof(string))
					{
						return CallMethod((MethodInfo)memberInfo, arguments, Convert.ToString(obj), binder, culture, namedParameters);
					}
					if (Convert.IsPrimitiveNumericType(declaringType))
					{
						return CallMethod((MethodInfo)memberInfo, arguments, Convert.CoerceT(obj, declaringType), binder, culture, namedParameters);
					}
					if (declaringType == typeof(bool))
					{
						return CallMethod((MethodInfo)memberInfo, arguments, Convert.ToBoolean(obj), binder, culture, namedParameters);
					}
					if (declaringType == typeof(StringObject) || declaringType == typeof(BooleanObject) || declaringType == typeof(NumberObject) || brackets)
					{
						return CallMethod((MethodInfo)memberInfo, arguments, Convert.ToObject(obj, engine), binder, culture, namedParameters);
					}
					if (declaringType == typeof(GlobalObject) && ((MethodInfo)memberInfo).IsSpecialName)
					{
						return CallValue(((MethodInfo)memberInfo).Invoke(obj, null), arguments, construct, brackets: false, engine, obj, JSBinder.ob, null, null);
					}
					if (!(obj is ClassScope))
					{
						if (CustomAttribute.IsDefined(memberInfo, typeof(JSFunctionAttribute), inherit: false))
						{
							FieldInfo fieldInfo = SelectMember(last_members) as FieldInfo;
							if (fieldInfo != null)
							{
								object value = obj;
								if (!(value is Closure))
								{
									value = fieldInfo.GetValue(obj);
								}
								return CallValue(value, arguments, construct, brackets, engine, obj, JSBinder.ob, null, null);
							}
						}
						return CallValue(new BuiltinFunction(obj, (MethodInfo)memberInfo), arguments, construct, brackets: false, engine, obj, JSBinder.ob, null, null);
					}
				}
			}
			MethodInfo methodInfo = memberInfo as MethodInfo;
			if (methodInfo != null)
			{
				return CallMethod(methodInfo, arguments, obj, binder, culture, namedParameters);
			}
			JSConstructor jSConstructor = memberInfo as JSConstructor;
			if (jSConstructor != null)
			{
				return CallValue(jSConstructor.cons, arguments, construct, brackets, engine, obj, JSBinder.ob, null, null);
			}
			if (memberInfo is Type)
			{
				return CallValue(memberInfo, arguments, construct, brackets, engine, obj, JSBinder.ob, null, null);
			}
			if (memberInfo is ConstructorInfo)
			{
				return CallOneOfTheMembers(new MemberInfo[1] { last_member }, arguments, construct: true, obj, binder, culture, namedParameters, engine);
			}
			if (!construct && memberInfo is PropertyInfo)
			{
				if (memberInfo is COMPropertyInfo)
				{
					return ((PropertyInfo)memberInfo).GetValue(obj, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.OptionalParamBinding, binder, arguments, culture);
				}
				if (((PropertyInfo)memberInfo).GetIndexParameters().Length == 0)
				{
					Type propertyType = ((PropertyInfo)memberInfo).PropertyType;
					if (propertyType == typeof(object))
					{
						MethodInfo getMethod = JSProperty.GetGetMethod((PropertyInfo)memberInfo, nonPublic: false);
						if (getMethod != null)
						{
							object val = getMethod.Invoke(obj, null);
							return CallValue(val, arguments, construct, brackets, engine, obj, JSBinder.ob, null, null);
						}
					}
					MemberInfo[] defaultMembers = TypeReflector.GetTypeReflectorFor(propertyType).GetDefaultMembers();
					if (defaultMembers != null && defaultMembers.Length != 0)
					{
						MethodInfo getMethod2 = JSProperty.GetGetMethod((PropertyInfo)memberInfo, nonPublic: false);
						if (getMethod2 != null)
						{
							object thisob = getMethod2.Invoke(obj, null);
							return CallOneOfTheMembers(defaultMembers, arguments, construct: false, thisob, binder, culture, namedParameters, engine);
						}
					}
				}
			}
			if (last_members != null && last_members.Length != 0)
			{
				bool memberCalled;
				object result = CallOneOfTheMembers(last_members, arguments, construct, obj, binder, culture, namedParameters, engine, out memberCalled);
				if (memberCalled)
				{
					return result;
				}
			}
			IReflect iRForObjectThatRequiresInvokeMember2 = GetIRForObjectThatRequiresInvokeMember(obj, VsaEngine.executeForJSEE);
			if (iRForObjectThatRequiresInvokeMember2 != null)
			{
				return CallCOMObject(iRForObjectThatRequiresInvokeMember2, name, obj, binder, arguments, modifiers, culture, namedParameters, construct, brackets, engine);
			}
			object memberValue = GetMemberValue(obj, name, last_member, last_members);
			if (!(memberValue is Missing))
			{
				return CallValue(memberValue, arguments, construct, brackets, engine, obj, JSBinder.ob, null, null);
			}
			if (brackets)
			{
				if (obj is IActivationObject)
				{
					throw new JScriptException(JSError.ObjectExpected);
				}
				throw new JScriptException(JSError.OLENoPropOrMethod);
			}
			throw new JScriptException(JSError.FunctionExpected);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		private static object CallCOMObject(IReflect ir, string name, object ob, Binder binder, object[] arguments, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters, bool construct, bool brackets, VsaEngine engine)
		{
			try
			{
				try
				{
					Change64bitIntegersToDouble(arguments);
					BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.OptionalParamBinding;
					if (construct)
					{
						return ir.InvokeMember(name, bindingFlags | BindingFlags.CreateInstance, binder, ob, arguments, modifiers, culture, namedParameters);
					}
					if (brackets)
					{
						try
						{
							return ir.InvokeMember(name, bindingFlags | BindingFlags.GetProperty | BindingFlags.GetField, binder, ob, arguments, modifiers, culture, namedParameters);
						}
						catch (TargetInvocationException)
						{
							object obj = ir.InvokeMember(name, bindingFlags | BindingFlags.GetProperty | BindingFlags.GetField, binder, ob, new object[0], modifiers, culture, new string[0]);
							return CallValue(obj, arguments, construct, brackets, engine, obj, binder, culture, namedParameters);
						}
					}
					int num = ((arguments != null) ? arguments.Length : 0);
					if (namedParameters != null && namedParameters.Length != 0 && (namedParameters[0].Equals("[DISPID=-613]") || namedParameters[0].Equals("this")))
					{
						num--;
					}
					bindingFlags |= ((num > 0) ? (BindingFlags.InvokeMethod | BindingFlags.GetProperty) : BindingFlags.InvokeMethod);
					return ir.InvokeMember(name, bindingFlags, binder, ob, arguments, modifiers, culture, namedParameters);
				}
				catch (MissingMemberException)
				{
					if (brackets)
					{
						return null;
					}
					throw new JScriptException(JSError.FunctionExpected);
				}
				catch (COMException ex3)
				{
					int errorCode = ex3.ErrorCode;
					if (errorCode == -2147352570 || errorCode == -2147352573)
					{
						if (brackets)
						{
							return null;
						}
						throw new JScriptException(JSError.FunctionExpected);
					}
					if ((errorCode & 0xFFFF0000u) == 2148139008u)
					{
						string source = ex3.Source;
						if (source != null && source.IndexOf("JScript") != -1)
						{
							throw new JScriptException(ex3, null);
						}
					}
					throw ex3;
				}
			}
			catch (JScriptException ex4)
			{
				if ((ex4.Number & 0xFFFF) == 5002)
				{
					MemberInfo[] member = typeof(object).GetMember(name, BindingFlags.Instance | BindingFlags.Public);
					if (member != null && member.Length != 0)
					{
						return CallOneOfTheMembers(member, arguments, construct, ob, binder, culture, namedParameters, engine);
					}
				}
				throw ex4;
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		private static object CallMethod(MethodInfo method, object[] arguments, object thisob, Binder binder, CultureInfo culture, string[] namedParameters)
		{
			if (namedParameters != null && namedParameters.Length != 0)
			{
				if (arguments.Length < namedParameters.Length)
				{
					throw new JScriptException(JSError.MoreNamedParametersThanArguments);
				}
				arguments = JSBinder.ArrangeNamedArguments(method, arguments, namedParameters);
			}
			object[] array = LickArgumentsIntoShape(method.GetParameters(), arguments, binder, culture);
			try
			{
				object result = method.Invoke(thisob, BindingFlags.SuppressChangeType, null, array, null);
				if (array != arguments && array != null && arguments != null)
				{
					int num = arguments.Length;
					int num2 = array.Length;
					if (num2 < num)
					{
						num = num2;
					}
					for (int i = 0; i < num; i++)
					{
						arguments[i] = array[i];
					}
				}
				return result;
			}
			catch (TargetException e)
			{
				if (thisob is ClassScope classScope)
				{
					return classScope.FakeCallToTypeMethod(method, array, e);
				}
				throw;
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static object CallOneOfTheMembers(MemberInfo[] members, object[] arguments, bool construct, object thisob, Binder binder, CultureInfo culture, string[] namedParameters, VsaEngine engine)
		{
			bool memberCalled;
			object result = CallOneOfTheMembers(members, arguments, construct, thisob, binder, culture, namedParameters, engine, out memberCalled);
			if (!memberCalled)
			{
				throw new MissingMemberException();
			}
			return result;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static object CallOneOfTheMembers(MemberInfo[] members, object[] arguments, bool construct, object thisob, Binder binder, CultureInfo culture, string[] namedParameters, VsaEngine engine, out bool memberCalled)
		{
			memberCalled = true;
			if (construct)
			{
				ConstructorInfo constructorInfo = JSBinder.SelectConstructor(Runtime.TypeRefs, members, ref arguments, namedParameters);
				if (constructorInfo != null)
				{
					if (CustomAttribute.IsDefined(constructorInfo, typeof(JSFunctionAttribute), inherit: false))
					{
						if (thisob is StackFrame)
						{
							thisob = ((StackFrame)thisob).closureInstance;
						}
						int num = arguments.Length;
						object[] array = new object[num + 1];
						ArrayObject.Copy(arguments, 0, array, 0, num);
						array[num] = thisob;
						arguments = array;
					}
					object obj = null;
					JSConstructor jSConstructor = constructorInfo as JSConstructor;
					obj = ((!(jSConstructor != null)) ? constructorInfo.Invoke(BindingFlags.SuppressChangeType, null, LickArgumentsIntoShape(constructorInfo.GetParameters(), arguments, JSBinder.ob, culture), null) : jSConstructor.Construct(thisob, LickArgumentsIntoShape(constructorInfo.GetParameters(), arguments, JSBinder.ob, culture)));
					if (obj is INeedEngine)
					{
						((INeedEngine)obj).SetEngine(engine);
					}
					return obj;
				}
			}
			else
			{
				object[] array2 = arguments;
				MethodInfo methodInfo = JSBinder.SelectMethod(Runtime.TypeRefs, members, ref arguments, namedParameters);
				if (methodInfo != null)
				{
					if (methodInfo is JSMethod)
					{
						return ((JSMethod)methodInfo).Invoke(thisob, thisob, BindingFlags.Default, JSBinder.ob, arguments, null);
					}
					if (CustomAttribute.IsDefined(methodInfo, typeof(JSFunctionAttribute), inherit: false))
					{
						if (!construct)
						{
							JSBuiltin builtinFunction = ((JSFunctionAttribute)CustomAttribute.GetCustomAttributes(methodInfo, typeof(JSFunctionAttribute), inherit: false)[0]).builtinFunction;
							if (builtinFunction != 0)
							{
								if (thisob is IActivationObject activationObject)
								{
									thisob = activationObject.GetDefaultThisObject();
								}
								return BuiltinFunction.QuickCall(arguments, thisob, builtinFunction, null, engine);
							}
						}
						return CallValue(new BuiltinFunction(thisob, methodInfo), arguments, construct, brackets: false, engine, thisob, JSBinder.ob, null, null);
					}
					object[] array3 = LickArgumentsIntoShape(methodInfo.GetParameters(), arguments, JSBinder.ob, culture);
					if (thisob != null && !methodInfo.DeclaringType.IsAssignableFrom(thisob.GetType()))
					{
						if (thisob is StringObject)
						{
							return methodInfo.Invoke(((StringObject)thisob).value, BindingFlags.SuppressChangeType, null, array3, null);
						}
						if (thisob is NumberObject)
						{
							return methodInfo.Invoke(((NumberObject)thisob).value, BindingFlags.SuppressChangeType, null, array3, null);
						}
						if (thisob is BooleanObject)
						{
							return methodInfo.Invoke(((BooleanObject)thisob).value, BindingFlags.SuppressChangeType, null, array3, null);
						}
						if (thisob is ArrayWrapper)
						{
							return methodInfo.Invoke(((ArrayWrapper)thisob).value, BindingFlags.SuppressChangeType, null, array3, null);
						}
					}
					object result = methodInfo.Invoke(thisob, BindingFlags.SuppressChangeType, null, array3, null);
					if (array3 != array2 && arguments == array2 && array3 != null && arguments != null)
					{
						int num2 = arguments.Length;
						int num3 = array3.Length;
						if (num3 < num2)
						{
							num2 = num3;
						}
						for (int i = 0; i < num2; i++)
						{
							arguments[i] = array3[i];
						}
					}
					return result;
				}
			}
			memberCalled = false;
			return null;
		}

		/// <summary>Resolves the binding reference by calling a member.</summary>
		/// <param name="thisob">The object that the binding reference is defined on.</param>
		/// <param name="val">Information about the member to call.</param>
		/// <param name="arguments">The arguments to pass to the member.</param>
		/// <param name="construct">
		///   <see langword="true" /> to use the construct method; otherwise, <see langword="false" />.</param>
		/// <param name="brackets">
		///   <see langword="true" /> if the binding reference contains brackets; otherwise, <see langword="false" />.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>The return value of the call to the member.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public static object CallValue(object thisob, object val, object[] arguments, bool construct, bool brackets, VsaEngine engine)
		{
			try
			{
				return CallValue(val, arguments, construct, brackets, engine, thisob, JSBinder.ob, null, null);
			}
			catch (TargetInvocationException ex)
			{
				throw ex.InnerException;
			}
		}

		/// <summary>Resolves the binding reference by calling a member.</summary>
		/// <param name="val">Information about the member to call.</param>
		/// <param name="thisob">The object that the binding reference is defined on.</param>
		/// <param name="arguments">The arguments to pass to the member.</param>
		/// <param name="construct">
		///   <see langword="true" /> to use the construct method; otherwise, <see langword="false" />.</param>
		/// <param name="brackets">
		///   <see langword="true" /> if the binding reference contains brackets; otherwise, <see langword="false" />.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>The return value of the call to the member.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public static object CallValue2(object val, object thisob, object[] arguments, bool construct, bool brackets, VsaEngine engine)
		{
			try
			{
				return CallValue(val, arguments, construct, brackets, engine, thisob, JSBinder.ob, null, null);
			}
			catch (TargetInvocationException ex)
			{
				throw ex.InnerException;
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static object CallValue(object val, object[] arguments, bool construct, bool brackets, VsaEngine engine, object thisob, Binder binder, CultureInfo culture, string[] namedParameters)
		{
			if (construct)
			{
				if (val is ScriptFunction)
				{
					ScriptFunction scriptFunction = (ScriptFunction)val;
					if (brackets)
					{
						object obj = (obj = scriptFunction[arguments]);
						if (obj != null)
						{
							return CallValue(obj, new object[0], construct: true, brackets: false, engine, thisob, binder, culture, namedParameters);
						}
						Type predefinedType = Runtime.TypeRefs.GetPredefinedType(scriptFunction.name);
						if (predefinedType != null)
						{
							int num = arguments.Length;
							int[] array = new int[num];
							num = 0;
							object[] array2 = arguments;
							int num2 = 0;
							while (true)
							{
								if (num2 < array2.Length)
								{
									object obj2 = array2[num2];
									if (obj2 is int)
									{
										array[num++] = (int)obj2;
									}
									else
									{
										IConvertible iConvertible = Convert.GetIConvertible(obj2);
										if (iConvertible == null || !Convert.IsPrimitiveNumericTypeCode(iConvertible.GetTypeCode()))
										{
											break;
										}
										double num3 = iConvertible.ToDouble(null);
										int num4 = (int)num3;
										if (num3 != (double)num4)
										{
											break;
										}
										array[num++] = num4;
									}
									num2++;
									continue;
								}
								return Array.CreateInstance(predefinedType, array);
							}
						}
					}
					if (scriptFunction is FunctionObject functionObject)
					{
						return functionObject.Construct(thisob as JSObject, (arguments == null) ? new object[0] : arguments);
					}
					object obj3 = scriptFunction.Construct((arguments == null) ? new object[0] : arguments);
					if (obj3 is JSObject jSObject)
					{
						jSObject.outer_class_instance = thisob as JSObject;
					}
					return obj3;
				}
				if (val is ClassScope)
				{
					if (brackets)
					{
						return Array.CreateInstance(typeof(object), ToIndices(arguments));
					}
					MemberInfo[] constructors = ((ClassScope)val).constructors;
					JSObject jSObject2 = (JSObject)CallOneOfTheMembers(constructors, arguments, construct, thisob, binder, culture, namedParameters, engine);
					jSObject2.noExpando = ((ClassScope)val).noExpando;
					return jSObject2;
				}
				if (val is Type)
				{
					Type type = (Type)val;
					if (type.IsInterface && type.IsImport)
					{
						type = JSBinder.HandleCoClassAttribute(type);
					}
					if (brackets)
					{
						return Array.CreateInstance(type, ToIndices(arguments));
					}
					ConstructorInfo[] constructors2 = type.GetConstructors();
					object obj4 = null;
					if (constructors2 == null || constructors2.Length == 0)
					{
						obj4 = Activator.CreateInstance(type, BindingFlags.Default, JSBinder.ob, arguments, null);
					}
					else
					{
						MemberInfo[] constructors = constructors2;
						obj4 = CallOneOfTheMembers(constructors, arguments, construct, thisob, binder, culture, namedParameters, engine);
					}
					if (obj4 is INeedEngine)
					{
						((INeedEngine)obj4).SetEngine(engine);
					}
					return obj4;
				}
				if (val is TypedArray && brackets)
				{
					return Array.CreateInstance(typeof(object), ToIndices(arguments));
				}
				if (VsaEngine.executeForJSEE && val is IDebuggerObject)
				{
					if (!(val is IReflect reflect))
					{
						throw new JScriptException(JSError.FunctionExpected);
					}
					return reflect.InvokeMember(string.Empty, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.CreateInstance | BindingFlags.OptionalParamBinding, binder, thisob, arguments, null, culture, namedParameters);
				}
			}
			if (brackets)
			{
				if (val is ScriptObject scriptObject)
				{
					object obj5 = scriptObject[arguments];
					if (construct)
					{
						return CallValue(thisob, obj5, new object[0], construct: true, brackets: false, engine);
					}
					return obj5;
				}
			}
			else
			{
				if (val is ScriptFunction)
				{
					if (thisob is IActivationObject)
					{
						thisob = ((IActivationObject)thisob).GetDefaultThisObject();
					}
					return ((ScriptFunction)val).Call((arguments == null) ? new object[0] : arguments, thisob, binder, culture);
				}
				if (val is Delegate)
				{
					return CallMethod(((Delegate)val).Method, arguments, thisob, binder, culture, namedParameters);
				}
				if (val is MethodInfo)
				{
					return CallMethod((MethodInfo)val, arguments, thisob, binder, culture, namedParameters);
				}
				if (val is Type && arguments.Length == 1)
				{
					return Convert.CoerceT(arguments[0], (Type)val, explicitOK: true);
				}
				if (VsaEngine.executeForJSEE && val is IDebuggerObject)
				{
					if (!(val is IReflect ir))
					{
						throw new JScriptException(JSError.FunctionExpected);
					}
					object[] array3 = new object[((arguments != null) ? arguments.Length : 0) + 1];
					array3[0] = thisob;
					if (arguments != null)
					{
						ArrayObject.Copy(arguments, 0, array3, 1, arguments.Length);
					}
					string[] array4 = new string[((namedParameters != null) ? namedParameters.Length : 0) + 1];
					array4[0] = "this";
					if (namedParameters != null)
					{
						object[] array5 = namedParameters;
						object[] source = array5;
						array5 = array4;
						ArrayObject.Copy(source, 0, array5, 1, namedParameters.Length);
					}
					return CallCOMObject(ir, string.Empty, val, binder, array3, null, culture, array4, construct: false, brackets: false, engine);
				}
				if (val is ClassScope)
				{
					if (arguments == null || arguments.Length != 1)
					{
						throw new JScriptException(JSError.FunctionExpected);
					}
					if (((ClassScope)val).HasInstance(arguments[0]))
					{
						return arguments[0];
					}
					throw new InvalidCastException(null);
				}
				if (val is TypedArray && arguments.Length == 1)
				{
					return Convert.Coerce(arguments[0], val, explicitOK: true);
				}
				if (val is ScriptObject)
				{
					throw new JScriptException(JSError.FunctionExpected);
				}
				if (val is MemberInfo[])
				{
					return CallOneOfTheMembers((MemberInfo[])val, arguments, construct, thisob, binder, culture, namedParameters, engine);
				}
			}
			if (val != null)
			{
				if (val is Array array6)
				{
					if (arguments.Length != array6.Rank)
					{
						throw new JScriptException(JSError.IncorrectNumberOfIndices);
					}
					return array6.GetValue(ToIndices(arguments));
				}
				val = Convert.ToObject(val, engine);
				if (val is ScriptObject scriptObject2)
				{
					if (brackets)
					{
						return scriptObject2[arguments];
					}
					if (scriptObject2 is ScriptFunction scriptFunction2)
					{
						if (thisob is IActivationObject activationObject)
						{
							thisob = activationObject.GetDefaultThisObject();
						}
						return scriptFunction2.Call((arguments == null) ? new object[0] : arguments, thisob, binder, culture);
					}
					throw new JScriptException(JSError.InvalidCall);
				}
				IReflect iRForObjectThatRequiresInvokeMember = GetIRForObjectThatRequiresInvokeMember(val, VsaEngine.executeForJSEE);
				if (iRForObjectThatRequiresInvokeMember != null)
				{
					if (brackets)
					{
						string text = string.Empty;
						int num5 = arguments.Length;
						if (num5 > 0)
						{
							text = Convert.ToString(arguments[num5 - 1]);
						}
						return CallCOMObject(iRForObjectThatRequiresInvokeMember, text, val, binder, null, null, culture, namedParameters, construct: false, brackets: true, engine);
					}
					if (!(val is IReflect))
					{
						return CallCOMObject(iRForObjectThatRequiresInvokeMember, string.Empty, val, binder, arguments, null, culture, namedParameters, construct: false, brackets, engine);
					}
					object[] array7 = new object[((arguments != null) ? arguments.Length : 0) + 1];
					array7[0] = thisob;
					if (arguments != null)
					{
						ArrayObject.Copy(arguments, 0, array7, 1, arguments.Length);
					}
					string[] array8 = new string[((namedParameters != null) ? namedParameters.Length : 0) + 1];
					array8[0] = "[DISPID=-613]";
					if (namedParameters != null)
					{
						object[] array5 = namedParameters;
						object[] source2 = array5;
						array5 = array8;
						ArrayObject.Copy(source2, 0, array5, 1, namedParameters.Length);
					}
					return CallCOMObject(iRForObjectThatRequiresInvokeMember, "[DISPID=0]", val, binder, array7, null, culture, array8, construct: false, brackets, engine);
				}
				if (VsaEngine.executeForJSEE && val is IDebuggerObject && val is IReflect)
				{
					return CallCOMObject((IReflect)val, string.Empty, val, binder, arguments, null, culture, namedParameters, construct: false, brackets, engine);
				}
				MemberInfo[] defaultMembers = TypeReflector.GetTypeReflectorFor(val.GetType()).GetDefaultMembers();
				if (defaultMembers != null && defaultMembers.Length != 0)
				{
					MethodInfo methodInfo = JSBinder.SelectMethod(Runtime.TypeRefs, defaultMembers, ref arguments, namedParameters);
					if (methodInfo != null)
					{
						return CallMethod(methodInfo, arguments, val, binder, culture, namedParameters);
					}
				}
			}
			throw new JScriptException(JSError.FunctionExpected);
		}

		private static void Change64bitIntegersToDouble(object[] arguments)
		{
			if (arguments == null)
			{
				return;
			}
			int i = 0;
			for (int num = arguments.Length; i < num; i++)
			{
				object ob = arguments[i];
				IConvertible iConvertible = Convert.GetIConvertible(ob);
				TypeCode typeCode = Convert.GetTypeCode(ob, iConvertible);
				if ((uint)(typeCode - 11) <= 1u)
				{
					arguments[i] = iConvertible.ToDouble(null);
				}
			}
		}

		/// <summary>Deletes the binding reference member from the object that the binding reference is defined on.</summary>
		/// <returns>
		///   <see langword="true" /> if the member was successfully deleted; otherwise, <see langword="false" />.</returns>
		public bool Delete()
		{
			return DeleteMember(obj, name);
		}

		/// <summary>Deletes the specified member from the specified object.</summary>
		/// <param name="obj">The object to delete from.</param>
		/// <param name="name">The member to delete.</param>
		/// <returns>
		///   <see langword="true" /> if the member was successfully deleted; otherwise, <see langword="false" />.</returns>
		public static bool DeleteMember(object obj, string name)
		{
			if (name == null || obj == null)
			{
				return false;
			}
			if (obj is ScriptObject)
			{
				return ((ScriptObject)obj).DeleteMember(name);
			}
			if (obj is IExpando)
			{
				try
				{
					IExpando expando = (IExpando)obj;
					MemberInfo[] member = expando.GetMember(name, BindingFlags.Instance | BindingFlags.Public);
					MemberInfo memberInfo = SelectMember(member);
					if (memberInfo != null)
					{
						expando.RemoveMember(memberInfo);
						return true;
					}
					return false;
				}
				catch
				{
					return false;
				}
			}
			if (obj is IDictionary)
			{
				IDictionary dictionary = (IDictionary)obj;
				if (dictionary.Contains(name))
				{
					dictionary.Remove(name);
					return true;
				}
				return false;
			}
			Type type = obj.GetType();
			MethodInfo method = TypeReflector.GetTypeReflectorFor(type).GetMethod("op_Delete", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[2]
			{
				type,
				typeof(object[])
			}, null);
			if (method == null || (method.Attributes & MethodAttributes.SpecialName) == 0 || method.ReturnType != typeof(bool))
			{
				return false;
			}
			return (bool)method.Invoke(null, new object[2]
			{
				obj,
				new object[1] { name }
			});
		}

		internal static bool DeleteValueAtIndex(object obj, ulong index)
		{
			if (obj is ArrayObject && index < uint.MaxValue)
			{
				return ((ArrayObject)obj).DeleteValueAtIndex((uint)index);
			}
			return DeleteMember(obj, index.ToString(CultureInfo.InvariantCulture));
		}

		private static IReflect GetIRForObjectThatRequiresInvokeMember(object obj, bool checkForDebugger)
		{
			Type type = obj.GetType();
			TypeReflector typeReflectorFor = TypeReflector.GetTypeReflectorFor(type);
			if (!typeReflectorFor.Is__ComObject())
			{
				return null;
			}
			if (checkForDebugger && obj is IDebuggerObject debuggerObject)
			{
				if (!debuggerObject.IsCOMObject())
				{
					return null;
				}
				return (IReflect)obj;
			}
			return type;
		}

		private static IReflect GetIRForObjectThatRequiresInvokeMember(object obj, bool checkForDebugger, TypeCode tcode)
		{
			if (tcode == TypeCode.Object)
			{
				return GetIRForObjectThatRequiresInvokeMember(obj, checkForDebugger);
			}
			return null;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static object GetMemberValue(object obj, string name)
		{
			if (obj is ScriptObject)
			{
				return ((ScriptObject)obj).GetMemberValue(name);
			}
			LateBinding lateBinding = new LateBinding(name, obj);
			return lateBinding.GetNonMissingValue();
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static object GetMemberValue2(object obj, string name)
		{
			if (obj is ScriptObject)
			{
				return ((ScriptObject)obj).GetMemberValue(name);
			}
			LateBinding lateBinding = new LateBinding(name, obj);
			return lateBinding.GetValue();
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static object GetMemberValue(object obj, string name, MemberInfo member, MemberInfo[] members)
		{
			if (member != null)
			{
				try
				{
					switch (member.MemberType)
					{
					case MemberTypes.Field:
					{
						object obj2 = ((FieldInfo)member).GetValue(obj);
						Type type = obj as Type;
						if (type != null && type.IsEnum)
						{
							try
							{
								obj2 = Enum.ToObject(type, ((IConvertible)obj2).ToUInt64(null));
							}
							catch
							{
							}
						}
						return obj2;
					}
					case MemberTypes.Property:
					{
						PropertyInfo propertyInfo = (PropertyInfo)member;
						if (propertyInfo.DeclaringType == typeof(ArrayObject))
						{
							if (obj is ArrayObject arrayObject)
							{
								return arrayObject.length;
							}
						}
						else if (propertyInfo.DeclaringType == typeof(StringObject) && obj is StringObject stringObject)
						{
							return stringObject.length;
						}
						return JSProperty.GetValue(propertyInfo, obj, null);
					}
					case MemberTypes.Event:
						return null;
					case MemberTypes.NestedType:
						return member;
					}
				}
				catch
				{
					if (obj is StringObject)
					{
						return GetMemberValue(((StringObject)obj).value, name, member, members);
					}
					if (obj is NumberObject)
					{
						return GetMemberValue(((NumberObject)obj).value, name, member, members);
					}
					if (obj is BooleanObject)
					{
						return GetMemberValue(((BooleanObject)obj).value, name, member, members);
					}
					if (obj is ArrayWrapper)
					{
						return GetMemberValue(((ArrayWrapper)obj).value, name, member, members);
					}
					throw;
				}
			}
			if (members != null && members.Length != 0)
			{
				if (members.Length == 1 && members[0].MemberType == MemberTypes.Method)
				{
					MethodInfo methodInfo = (MethodInfo)members[0];
					Type declaringType = methodInfo.DeclaringType;
					if (declaringType == typeof(GlobalObject) || (declaringType != null && declaringType != typeof(StringObject) && declaringType != typeof(NumberObject) && declaringType != typeof(BooleanObject) && declaringType.IsSubclassOf(typeof(JSObject))))
					{
						return Globals.BuiltinFunctionFor(obj, methodInfo);
					}
				}
				return new FunctionWrapper(name, obj, members);
			}
			if (obj is ScriptObject)
			{
				return ((ScriptObject)obj).GetMemberValue(name);
			}
			if (obj is Namespace)
			{
				Namespace @namespace = (Namespace)obj;
				string typeName = @namespace.Name + "." + name;
				Type type2 = @namespace.GetType(typeName);
				if (type2 != null)
				{
					return type2;
				}
				return Namespace.GetNamespace(typeName, @namespace.engine);
			}
			IReflect iRForObjectThatRequiresInvokeMember = GetIRForObjectThatRequiresInvokeMember(obj, checkForDebugger: true);
			if (iRForObjectThatRequiresInvokeMember != null)
			{
				try
				{
					return iRForObjectThatRequiresInvokeMember.InvokeMember(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.GetField | BindingFlags.GetProperty | BindingFlags.OptionalParamBinding, JSBinder.ob, obj, null, null, null, null);
				}
				catch (MissingMemberException)
				{
				}
				catch (COMException ex2)
				{
					int errorCode = ex2.ErrorCode;
					if (errorCode != -2147352570 && errorCode != -2147352573)
					{
						throw ex2;
					}
				}
			}
			return Missing.Value;
		}

		/// <summary>Gets the value of the binding reference, and converts a <see cref="T:Microsoft.JScript.Missing" /> value to null.</summary>
		/// <returns>The value of the binding reference; otherwise, null.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public object GetNonMissingValue()
		{
			object value = GetValue();
			if (value is Missing)
			{
				return null;
			}
			return value;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal object GetValue()
		{
			BindToMember();
			return GetMemberValue(obj, name, last_member, last_members);
		}

		/// <summary>Gets the value of the binding reference, and throws an exception if it cannot be resolved.</summary>
		/// <returns>The value of the binding reference.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public object GetValue2()
		{
			object value = GetValue();
			if (value == Missing.Value)
			{
				throw new JScriptException(JSError.UndefinedIdentifier, new Context(new DocumentContext("", null), name));
			}
			return value;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static object GetValueAtIndex(object obj, ulong index)
		{
			if (obj is ScriptObject)
			{
				if (index < uint.MaxValue)
				{
					return ((ScriptObject)obj).GetValueAtIndex((uint)index);
				}
				return ((ScriptObject)obj).GetMemberValue(index.ToString(CultureInfo.InvariantCulture));
			}
			while (true)
			{
				Type type;
				checked
				{
					if (obj is IList)
					{
						return ((IList)obj)[(int)index];
					}
					if (obj is Array)
					{
						return ((Array)obj).GetValue((int)index);
					}
					type = obj.GetType();
					if (type.IsCOMObject || obj is IReflect || index > int.MaxValue)
					{
						return GetMemberValue(obj, index.ToString(CultureInfo.InvariantCulture));
					}
				}
				MethodInfo defaultPropertyForArrayIndex = JSBinder.GetDefaultPropertyForArrayIndex(type, (int)index, null, getSetter: false);
				if (!(defaultPropertyForArrayIndex != null))
				{
					break;
				}
				ParameterInfo[] parameters = defaultPropertyForArrayIndex.GetParameters();
				if (parameters == null || parameters.Length == 0)
				{
					obj = defaultPropertyForArrayIndex.Invoke(obj, BindingFlags.SuppressChangeType, null, null, null);
					continue;
				}
				return defaultPropertyForArrayIndex.Invoke(obj, BindingFlags.Default, JSBinder.ob, new object[1] { (int)index }, null);
			}
			return Missing.Value;
		}

		private static object[] LickArgumentsIntoShape(ParameterInfo[] pars, object[] arguments, Binder binder, CultureInfo culture)
		{
			if (arguments == null)
			{
				return null;
			}
			int num = pars.Length;
			if (num == 0)
			{
				return null;
			}
			object[] array = arguments;
			int num2 = arguments.Length;
			if (num2 != num)
			{
				array = new object[num];
			}
			int num3 = num - 1;
			int num4 = ((num2 < num3) ? num2 : num3);
			for (int i = 0; i < num4; i++)
			{
				object obj = arguments[i];
				if (obj is DBNull)
				{
					array[i] = null;
				}
				else
				{
					array[i] = binder.ChangeType(arguments[i], pars[i].ParameterType, culture);
				}
			}
			for (int j = num4; j < num3; j++)
			{
				object obj2 = TypeReferences.GetDefaultParameterValue(pars[j]);
				if (obj2 == System.Convert.DBNull)
				{
					obj2 = binder.ChangeType(null, pars[j].ParameterType, culture);
				}
				array[j] = obj2;
			}
			if (CustomAttribute.IsDefined(pars[num3], typeof(ParamArrayAttribute), inherit: false))
			{
				int num5 = num2 - num3;
				if (num5 < 0)
				{
					num5 = 0;
				}
				Type elementType = pars[num3].ParameterType.GetElementType();
				Array array2 = Array.CreateInstance(elementType, num5);
				for (int k = 0; k < num5; k++)
				{
					array2.SetValue(binder.ChangeType(arguments[k + num3], elementType, culture), k);
				}
				array[num3] = array2;
			}
			else if (num2 < num)
			{
				object obj3 = TypeReferences.GetDefaultParameterValue(pars[num3]);
				if (obj3 == System.Convert.DBNull)
				{
					obj3 = binder.ChangeType(null, pars[num3].ParameterType, culture);
				}
				array[num3] = obj3;
			}
			else
			{
				array[num3] = binder.ChangeType(arguments[num3], pars[num3].ParameterType, culture);
			}
			return array;
		}

		internal static MemberInfo SelectMember(MemberInfo[] mems)
		{
			if (mems == null)
			{
				return null;
			}
			MemberInfo memberInfo = null;
			foreach (MemberInfo memberInfo2 in mems)
			{
				switch (memberInfo2.MemberType)
				{
				case MemberTypes.Field:
					if (memberInfo == null || memberInfo.MemberType != MemberTypes.Field)
					{
						memberInfo = memberInfo2;
					}
					break;
				case MemberTypes.Property:
					if (memberInfo == null || (memberInfo.MemberType != MemberTypes.Field && memberInfo.MemberType != MemberTypes.Property))
					{
						ParameterInfo[] indexParameters = ((PropertyInfo)memberInfo2).GetIndexParameters();
						if (indexParameters != null && indexParameters.Length == 0)
						{
							memberInfo = memberInfo2;
						}
					}
					break;
				case MemberTypes.TypeInfo:
				case MemberTypes.NestedType:
					if (memberInfo == null)
					{
						memberInfo = memberInfo2;
					}
					break;
				}
			}
			return memberInfo;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal void SetIndexedDefaultPropertyValue(object ob, object[] arguments, object value)
		{
			if (ob is ScriptObject scriptObject)
			{
				scriptObject[arguments] = value;
				return;
			}
			if (ob is Array array)
			{
				if (arguments.Length != array.Rank)
				{
					throw new JScriptException(JSError.IncorrectNumberOfIndices);
				}
				array.SetValue(value, ToIndices(arguments));
				return;
			}
			TypeCode typeCode = Convert.GetTypeCode(ob);
			if (Convert.NeedsWrapper(typeCode))
			{
				return;
			}
			IReflect reflect = GetIRForObjectThatRequiresInvokeMember(ob, checkForDebugger, typeCode);
			if (reflect == null && checkForDebugger && ob is IDebuggerObject && ob is IReflect)
			{
				reflect = (IReflect)ob;
			}
			if (reflect != null)
			{
				try
				{
					int num = arguments.Length + 1;
					object[] array2 = new object[num];
					ArrayObject.Copy(arguments, 0, array2, 0, num - 1);
					array2[num - 1] = value;
					reflect.InvokeMember(string.Empty, BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetField | BindingFlags.SetProperty | BindingFlags.OptionalParamBinding, JSBinder.ob, ob, array2, null, null, null);
					return;
				}
				catch (MissingMemberException)
				{
					throw new JScriptException(JSError.OLENoPropOrMethod);
				}
			}
			MemberInfo[] defaultMembers = TypeReflector.GetTypeReflectorFor(ob.GetType()).GetDefaultMembers();
			if (defaultMembers != null && defaultMembers.Length != 0)
			{
				PropertyInfo propertyInfo = JSBinder.SelectProperty(Runtime.TypeRefs, defaultMembers, arguments);
				if (propertyInfo != null)
				{
					MethodInfo setMethod = JSProperty.GetSetMethod(propertyInfo, nonPublic: false);
					if (setMethod != null)
					{
						arguments = LickArgumentsIntoShape(propertyInfo.GetIndexParameters(), arguments, JSBinder.ob, null);
						value = Convert.CoerceT(value, propertyInfo.PropertyType);
						int num2 = arguments.Length + 1;
						object[] array3 = new object[num2];
						ArrayObject.Copy(arguments, 0, array3, 0, num2 - 1);
						array3[num2 - 1] = value;
						setMethod.Invoke(ob, array3);
						return;
					}
				}
			}
			throw new JScriptException(JSError.OLENoPropOrMethod);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal void SetIndexedPropertyValue(object[] arguments, object value)
		{
			if (obj == null)
			{
				throw new JScriptException(JSError.ObjectExpected);
			}
			if (name == null)
			{
				SetIndexedDefaultPropertyValue(obj, arguments, value);
				return;
			}
			MemberInfo memberInfo = BindToMember();
			if (last_members != null && last_members.Length != 0)
			{
				PropertyInfo propertyInfo = JSBinder.SelectProperty(Runtime.TypeRefs, last_members, arguments);
				if (propertyInfo != null)
				{
					if (arguments.Length != 0 && propertyInfo.GetIndexParameters().Length == 0 && !(propertyInfo is COMPropertyInfo))
					{
						MethodInfo getMethod = JSProperty.GetGetMethod(propertyInfo, nonPublic: false);
						if (getMethod != null)
						{
							SetIndexedPropertyValueStatic(getMethod.Invoke(obj, null), arguments, value);
							return;
						}
					}
					arguments = LickArgumentsIntoShape(propertyInfo.GetIndexParameters(), arguments, JSBinder.ob, null);
					value = Convert.CoerceT(value, propertyInfo.PropertyType);
					JSProperty.SetValue(propertyInfo, obj, value, arguments);
					return;
				}
			}
			TypeCode typeCode = Convert.GetTypeCode(obj);
			if (Convert.NeedsWrapper(typeCode))
			{
				return;
			}
			IReflect iRForObjectThatRequiresInvokeMember = GetIRForObjectThatRequiresInvokeMember(obj, checkForDebugger, typeCode);
			if (iRForObjectThatRequiresInvokeMember != null)
			{
				int num = arguments.Length + 1;
				object[] array = new object[num];
				ArrayObject.Copy(arguments, 0, array, 0, num - 1);
				array[num - 1] = value;
				iRForObjectThatRequiresInvokeMember.InvokeMember(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetField | BindingFlags.SetProperty | BindingFlags.OptionalParamBinding, JSBinder.ob, obj, array, null, null, null);
			}
			else
			{
				object value2 = GetValue();
				if (value2 == null || value2 is Missing)
				{
					throw new JScriptException(JSError.OLENoPropOrMethod);
				}
				SetIndexedDefaultPropertyValue(value2, arguments, value);
			}
		}

		/// <summary>Sets an indexed property.</summary>
		/// <param name="obj">The object that the binding reference is defined on.</param>
		/// <param name="arguments">The arguments to pass to the member.</param>
		/// <param name="value">The new value of the property.</param>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public static void SetIndexedPropertyValueStatic(object obj, object[] arguments, object value)
		{
			if (obj == null)
			{
				throw new JScriptException(JSError.ObjectExpected);
			}
			if (obj is ScriptObject scriptObject)
			{
				scriptObject[arguments] = value;
				return;
			}
			if (obj is Array array)
			{
				if (arguments.Length != array.Rank)
				{
					throw new JScriptException(JSError.IncorrectNumberOfIndices);
				}
				array.SetValue(value, ToIndices(arguments));
				return;
			}
			TypeCode typeCode = Convert.GetTypeCode(obj);
			if (Convert.NeedsWrapper(typeCode))
			{
				return;
			}
			IReflect iRForObjectThatRequiresInvokeMember = GetIRForObjectThatRequiresInvokeMember(obj, checkForDebugger: true, typeCode);
			if (iRForObjectThatRequiresInvokeMember != null)
			{
				string text = string.Empty;
				int num = arguments.Length;
				if (num > 0)
				{
					text = Convert.ToString(arguments[num - 1]);
				}
				iRForObjectThatRequiresInvokeMember.InvokeMember(text, BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetField | BindingFlags.SetProperty | BindingFlags.OptionalParamBinding, JSBinder.ob, obj, new object[1] { value }, null, null, null);
				return;
			}
			MemberInfo[] defaultMembers = TypeReflector.GetTypeReflectorFor(obj.GetType()).GetDefaultMembers();
			if (defaultMembers != null && defaultMembers.Length != 0)
			{
				PropertyInfo propertyInfo = JSBinder.SelectProperty(Runtime.TypeRefs, defaultMembers, arguments);
				if (propertyInfo != null)
				{
					MethodInfo setMethod = JSProperty.GetSetMethod(propertyInfo, nonPublic: false);
					if (setMethod != null)
					{
						arguments = LickArgumentsIntoShape(propertyInfo.GetIndexParameters(), arguments, JSBinder.ob, null);
						value = Convert.CoerceT(value, propertyInfo.PropertyType);
						int num2 = arguments.Length + 1;
						object[] array2 = new object[num2];
						ArrayObject.Copy(arguments, 0, array2, 0, num2 - 1);
						array2[num2 - 1] = value;
						setMethod.Invoke(obj, array2);
						return;
					}
				}
			}
			throw new JScriptException(JSError.OLENoPropOrMethod);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		private static void SetMember(object obj, object value, MemberInfo member)
		{
			switch (member.MemberType)
			{
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				if (!fieldInfo.IsLiteral && !fieldInfo.IsInitOnly)
				{
					if (fieldInfo is JSField)
					{
						fieldInfo.SetValue(obj, value);
					}
					else
					{
						fieldInfo.SetValue(obj, Convert.CoerceT(value, fieldInfo.FieldType), BindingFlags.SuppressChangeType, null, null);
					}
				}
				break;
			}
			case MemberTypes.Property:
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				if (propertyInfo is JSProperty || propertyInfo is JSWrappedProperty)
				{
					propertyInfo.SetValue(obj, value, null);
					break;
				}
				MethodInfo setMethod = JSProperty.GetSetMethod(propertyInfo, nonPublic: false);
				if (!(setMethod != null))
				{
					break;
				}
				try
				{
					setMethod.Invoke(obj, BindingFlags.SuppressChangeType, null, new object[1] { Convert.CoerceT(value, propertyInfo.PropertyType) }, null);
					break;
				}
				catch (TargetInvocationException ex)
				{
					throw ex.InnerException;
				}
			}
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static void SetMemberValue(object obj, string name, object value)
		{
			if (obj is ScriptObject)
			{
				((ScriptObject)obj).SetMemberValue(name, value);
				return;
			}
			LateBinding lateBinding = new LateBinding(name, obj);
			lateBinding.SetValue(value);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static void SetMemberValue(object obj, string name, object value, MemberInfo member, MemberInfo[] members)
		{
			if (member != null)
			{
				SetMember(obj, value, member);
				return;
			}
			if (obj is ScriptObject)
			{
				((ScriptObject)obj).SetMemberValue(name, value);
				return;
			}
			TypeCode typeCode = Convert.GetTypeCode(obj);
			if (Convert.NeedsWrapper(typeCode))
			{
				return;
			}
			IReflect iRForObjectThatRequiresInvokeMember = GetIRForObjectThatRequiresInvokeMember(obj, checkForDebugger: true, typeCode);
			if (iRForObjectThatRequiresInvokeMember != null)
			{
				try
				{
					object[] args = new object[1] { value };
					IConvertible convertible = value as IConvertible;
					BindingFlags invokeAttr = BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetField | BindingFlags.SetProperty | BindingFlags.OptionalParamBinding;
					iRForObjectThatRequiresInvokeMember.InvokeMember(name, invokeAttr, JSBinder.ob, obj, args, null, null, null);
					return;
				}
				catch (MissingMemberException)
				{
				}
				catch (COMException ex2)
				{
					int errorCode = ex2.ErrorCode;
					if (errorCode != -2147352570 && errorCode != -2147352573)
					{
						throw ex2;
					}
				}
			}
			if (!(obj is IExpando))
			{
				return;
			}
			PropertyInfo propertyInfo = ((IExpando)obj).AddProperty(name);
			if (propertyInfo != null)
			{
				propertyInfo.SetValue(obj, value, null);
				return;
			}
			FieldInfo fieldInfo = ((IExpando)obj).AddField(name);
			if (fieldInfo != null)
			{
				fieldInfo.SetValue(obj, value);
			}
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal static void SetValueAtIndex(object obj, ulong index, object value)
		{
			if (obj is ScriptObject)
			{
				if (index < uint.MaxValue)
				{
					((ScriptObject)obj).SetValueAtIndex((uint)index, value);
				}
				else
				{
					((ScriptObject)obj).SetMemberValue(index.ToString(CultureInfo.InvariantCulture), value);
				}
				return;
			}
			while (true)
			{
				if (obj is IList)
				{
					IList list = (IList)obj;
					if (index < (ulong)list.Count)
					{
						list[(int)index] = value;
					}
					else
					{
						list.Insert((int)index, value);
					}
					break;
				}
				if (obj is Array)
				{
					((Array)obj).SetValue(Convert.CoerceT(value, obj.GetType().GetElementType()), checked((int)index));
					break;
				}
				Type type = obj.GetType();
				if (type.IsCOMObject || obj is IReflect || index > int.MaxValue)
				{
					SetMemberValue(obj, index.ToString(CultureInfo.InvariantCulture), value);
					break;
				}
				MethodInfo defaultPropertyForArrayIndex = JSBinder.GetDefaultPropertyForArrayIndex(type, (int)index, null, getSetter: true);
				if (defaultPropertyForArrayIndex != null)
				{
					ParameterInfo[] parameters = defaultPropertyForArrayIndex.GetParameters();
					if (parameters == null || parameters.Length == 0)
					{
						obj = defaultPropertyForArrayIndex.Invoke(obj, BindingFlags.SuppressChangeType, null, null, null);
						continue;
					}
					defaultPropertyForArrayIndex.Invoke(obj, BindingFlags.Default, JSBinder.ob, new object[2]
					{
						(int)index,
						value
					}, null);
					break;
				}
				break;
			}
		}

		/// <summary>Sets a property.</summary>
		/// <param name="value">The new value of the property.</param>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public void SetValue(object value)
		{
			BindToMember();
			SetMemberValue(obj, name, value, last_member, last_members);
		}

		internal static void SwapValues(object obj, uint left, uint right)
		{
			if (obj is JSObject)
			{
				((JSObject)obj).SwapValues(left, right);
			}
			else if (obj is IList)
			{
				IList list = (IList)obj;
				object value = list[(int)left];
				list[(int)left] = list[(int)right];
				list[(int)right] = value;
			}
			else if (obj is Array)
			{
				Array array = (Array)obj;
				object value2 = array.GetValue((int)left);
				array.SetValue(array.GetValue((int)right), (int)left);
				array.SetValue(value2, (int)right);
			}
			else if (obj is IExpando)
			{
				string text = System.Convert.ToString(left, CultureInfo.InvariantCulture);
				string text2 = System.Convert.ToString(right, CultureInfo.InvariantCulture);
				IExpando expando = (IExpando)obj;
				FieldInfo fieldInfo = expando.GetField(text, BindingFlags.Instance | BindingFlags.Public);
				FieldInfo fieldInfo2 = expando.GetField(text2, BindingFlags.Instance | BindingFlags.Public);
				if (fieldInfo == null)
				{
					if (fieldInfo2 == null)
					{
						return;
					}
					try
					{
						fieldInfo = expando.AddField(text);
						fieldInfo.SetValue(obj, fieldInfo2.GetValue(obj));
						expando.RemoveMember(fieldInfo2);
					}
					catch
					{
						throw new JScriptException(JSError.ActionNotSupported);
					}
				}
				else if (fieldInfo2 == null)
				{
					try
					{
						fieldInfo2 = expando.AddField(text2);
						fieldInfo2.SetValue(obj, fieldInfo.GetValue(obj));
						expando.RemoveMember(fieldInfo);
					}
					catch
					{
						throw new JScriptException(JSError.ActionNotSupported);
					}
				}
				object value3 = fieldInfo.GetValue(obj);
				fieldInfo.SetValue(obj, fieldInfo2.GetValue(obj));
				fieldInfo2.SetValue(obj, value3);
			}
			else
			{
				object valueAtIndex = GetValueAtIndex(obj, left);
				object valueAtIndex2 = GetValueAtIndex(obj, right);
				if (valueAtIndex is Missing)
				{
					DeleteValueAtIndex(obj, right);
				}
				else
				{
					SetValueAtIndex(obj, right, valueAtIndex);
				}
				if (valueAtIndex2 is Missing)
				{
					DeleteValueAtIndex(obj, left);
				}
				else
				{
					SetValueAtIndex(obj, left, valueAtIndex2);
				}
			}
		}

		private static int[] ToIndices(object[] arguments)
		{
			int num = arguments.Length;
			int[] array = new int[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = Convert.ToInt32(arguments[i]);
			}
			return array;
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class. The <see cref="T:Microsoft.JScript.LenientArrayPrototype" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientArrayPrototype : ArrayPrototype
	{
		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ArrayConstructor" /> object.</summary>
		public new object constructor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.concat(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object concat;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.join(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object join;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.pop(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object pop;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.push(System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object push;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.reverse(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object reverse;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.shift(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object shift;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.slice(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object slice;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.sort(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object sort;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.splice(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Double,System.Double,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object splice;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.unshift(System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object unshift;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.toLocaleString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object toLocaleString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ArrayPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ArrayPrototype" /> class.</summary>
		public new object toString;

		internal LenientArrayPrototype(FunctionPrototype funcprot, ObjectPrototype parent)
			: base(parent)
		{
			noExpando = false;
			Type typeFromHandle = typeof(ArrayPrototype);
			concat = new BuiltinFunction("concat", this, typeFromHandle.GetMethod("concat"), funcprot);
			join = new BuiltinFunction("join", this, typeFromHandle.GetMethod("join"), funcprot);
			pop = new BuiltinFunction("pop", this, typeFromHandle.GetMethod("pop"), funcprot);
			push = new BuiltinFunction("push", this, typeFromHandle.GetMethod("push"), funcprot);
			reverse = new BuiltinFunction("reverse", this, typeFromHandle.GetMethod("reverse"), funcprot);
			shift = new BuiltinFunction("shift", this, typeFromHandle.GetMethod("shift"), funcprot);
			slice = new BuiltinFunction("slice", this, typeFromHandle.GetMethod("slice"), funcprot);
			sort = new BuiltinFunction("sort", this, typeFromHandle.GetMethod("sort"), funcprot);
			splice = new BuiltinFunction("splice", this, typeFromHandle.GetMethod("splice"), funcprot);
			unshift = new BuiltinFunction("unshift", this, typeFromHandle.GetMethod("unshift"), funcprot);
			toLocaleString = new BuiltinFunction("toLocaleString", this, typeFromHandle.GetMethod("toLocaleString"), funcprot);
			toString = new BuiltinFunction("toString", this, typeFromHandle.GetMethod("toString"), funcprot);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.BooleanPrototype" /> class. The <see cref="T:Microsoft.JScript.LenientBooleanPrototype" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientBooleanPrototype : BooleanPrototype
	{
		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.BooleanConstructor" /> object.</summary>
		public new object constructor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.BooleanPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.BooleanPrototype" /> class.</summary>
		public new object toString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.BooleanPrototype.valueOf(System.Object)" /> method of the <see cref="T:Microsoft.JScript.BooleanPrototype" /> class.</summary>
		public new object valueOf;

		internal LenientBooleanPrototype(LenientFunctionPrototype funcprot, LenientObjectPrototype parent)
			: base(parent, typeof(LenientBooleanPrototype))
		{
			noExpando = false;
			Type typeFromHandle = typeof(BooleanPrototype);
			toString = new BuiltinFunction("toString", this, typeFromHandle.GetMethod("toString"), funcprot);
			valueOf = new BuiltinFunction("valueOf", this, typeFromHandle.GetMethod("valueOf"), funcprot);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.DateConstructor" /> class. The <see cref="T:Microsoft.JScript.LenientDateConstructor" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientDateConstructor : DateConstructor
	{
		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DateConstructor.parse(System.String)" /> method of the <see cref="T:Microsoft.JScript.DateConstructor" /> class.</summary>
		public new object parse;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DateConstructor.UTC(System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DateConstructor" /> class.</summary>
		public new object UTC;

		internal LenientDateConstructor(LenientFunctionPrototype parent, LenientDatePrototype prototypeProp)
			: base(parent, prototypeProp)
		{
			noExpando = false;
			Type typeFromHandle = typeof(DateConstructor);
			parse = new BuiltinFunction("parse", this, typeFromHandle.GetMethod("parse"), parent);
			UTC = new BuiltinFunction("UTC", this, typeFromHandle.GetMethod("UTC"), parent);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.DatePrototype" /> class. The <see cref="T:Microsoft.JScript.LenientDatePrototype" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientDatePrototype : DatePrototype
	{
		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.DateConstructor" /> object.</summary>
		public new object constructor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getTime(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getTime;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getYear(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		[NotRecommended("getYear")]
		public new object getYear;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getFullYear(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getFullYear;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getUTCFullYear(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getUTCFullYear;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getMonth(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getMonth;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getUTCMonth(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getUTCMonth;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getDate(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getDate;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getUTCDate(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getUTCDate;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getDay(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getDay;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getUTCDay(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getUTCDay;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getHours(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getHours;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getUTCHours(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getUTCHours;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getMinutes(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getMinutes;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getUTCMinutes(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getUTCMinutes;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getSeconds(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getSeconds;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getUTCSeconds(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getUTCSeconds;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getMilliseconds(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getMilliseconds;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getUTCMilliseconds(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getUTCMilliseconds;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getVarDate(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getVarDate;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.getTimezoneOffset(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object getTimezoneOffset;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setTime(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setTime;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setMilliseconds(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setMilliseconds;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setUTCMilliseconds(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setUTCMilliseconds;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setSeconds(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setSeconds;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setUTCSeconds(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setUTCSeconds;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setMinutes(System.Object,System.Double,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setMinutes;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setUTCMinutes(System.Object,System.Double,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setUTCMinutes;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setHours(System.Object,System.Double,System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setHours;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setUTCHours(System.Object,System.Double,System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setUTCHours;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setDate(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setDate;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setUTCDate(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setUTCDate;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setMonth(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setMonth;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setUTCMonth(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setUTCMonth;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setFullYear(System.Object,System.Double,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setFullYear;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setUTCFullYear(System.Object,System.Double,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object setUTCFullYear;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.setYear(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		[NotRecommended("setYear")]
		public new object setYear;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.toGMTString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		[NotRecommended("toGMTString")]
		public new object toGMTString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.toDateString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object toDateString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.toLocaleDateString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object toLocaleDateString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.toLocaleString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object toLocaleString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.toLocaleTimeString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object toLocaleTimeString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object toString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.toTimeString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object toTimeString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.toUTCString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object toUTCString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.DatePrototype.valueOf(System.Object)" /> method of the <see cref="T:Microsoft.JScript.DatePrototype" /> class.</summary>
		public new object valueOf;

		internal LenientDatePrototype(LenientFunctionPrototype funcprot, LenientObjectPrototype parent)
			: base(parent)
		{
			noExpando = false;
			Type typeFromHandle = typeof(DatePrototype);
			getTime = new BuiltinFunction("getTime", this, typeFromHandle.GetMethod("getTime"), funcprot);
			getYear = new BuiltinFunction("getYear", this, typeFromHandle.GetMethod("getYear"), funcprot);
			getFullYear = new BuiltinFunction("getFullYear", this, typeFromHandle.GetMethod("getFullYear"), funcprot);
			getUTCFullYear = new BuiltinFunction("getUTCFullYear", this, typeFromHandle.GetMethod("getUTCFullYear"), funcprot);
			getMonth = new BuiltinFunction("getMonth", this, typeFromHandle.GetMethod("getMonth"), funcprot);
			getUTCMonth = new BuiltinFunction("getUTCMonth", this, typeFromHandle.GetMethod("getUTCMonth"), funcprot);
			getDate = new BuiltinFunction("getDate", this, typeFromHandle.GetMethod("getDate"), funcprot);
			getUTCDate = new BuiltinFunction("getUTCDate", this, typeFromHandle.GetMethod("getUTCDate"), funcprot);
			getDay = new BuiltinFunction("getDay", this, typeFromHandle.GetMethod("getDay"), funcprot);
			getUTCDay = new BuiltinFunction("getUTCDay", this, typeFromHandle.GetMethod("getUTCDay"), funcprot);
			getHours = new BuiltinFunction("getHours", this, typeFromHandle.GetMethod("getHours"), funcprot);
			getUTCHours = new BuiltinFunction("getUTCHours", this, typeFromHandle.GetMethod("getUTCHours"), funcprot);
			getMinutes = new BuiltinFunction("getMinutes", this, typeFromHandle.GetMethod("getMinutes"), funcprot);
			getUTCMinutes = new BuiltinFunction("getUTCMinutes", this, typeFromHandle.GetMethod("getUTCMinutes"), funcprot);
			getSeconds = new BuiltinFunction("getSeconds", this, typeFromHandle.GetMethod("getSeconds"), funcprot);
			getUTCSeconds = new BuiltinFunction("getUTCSeconds", this, typeFromHandle.GetMethod("getUTCSeconds"), funcprot);
			getMilliseconds = new BuiltinFunction("getMilliseconds", this, typeFromHandle.GetMethod("getMilliseconds"), funcprot);
			getUTCMilliseconds = new BuiltinFunction("getUTCMilliseconds", this, typeFromHandle.GetMethod("getUTCMilliseconds"), funcprot);
			getVarDate = new BuiltinFunction("getVarDate", this, typeFromHandle.GetMethod("getVarDate"), funcprot);
			getTimezoneOffset = new BuiltinFunction("getTimezoneOffset", this, typeFromHandle.GetMethod("getTimezoneOffset"), funcprot);
			setTime = new BuiltinFunction("setTime", this, typeFromHandle.GetMethod("setTime"), funcprot);
			setMilliseconds = new BuiltinFunction("setMilliseconds", this, typeFromHandle.GetMethod("setMilliseconds"), funcprot);
			setUTCMilliseconds = new BuiltinFunction("setUTCMilliseconds", this, typeFromHandle.GetMethod("setUTCMilliseconds"), funcprot);
			setSeconds = new BuiltinFunction("setSeconds", this, typeFromHandle.GetMethod("setSeconds"), funcprot);
			setUTCSeconds = new BuiltinFunction("setUTCSeconds", this, typeFromHandle.GetMethod("setUTCSeconds"), funcprot);
			setMinutes = new BuiltinFunction("setMinutes", this, typeFromHandle.GetMethod("setMinutes"), funcprot);
			setUTCMinutes = new BuiltinFunction("setUTCMinutes", this, typeFromHandle.GetMethod("setUTCMinutes"), funcprot);
			setHours = new BuiltinFunction("setHours", this, typeFromHandle.GetMethod("setHours"), funcprot);
			setUTCHours = new BuiltinFunction("setUTCHours", this, typeFromHandle.GetMethod("setUTCHours"), funcprot);
			setDate = new BuiltinFunction("setDate", this, typeFromHandle.GetMethod("setDate"), funcprot);
			setUTCDate = new BuiltinFunction("setUTCDate", this, typeFromHandle.GetMethod("setUTCDate"), funcprot);
			setMonth = new BuiltinFunction("setMonth", this, typeFromHandle.GetMethod("setMonth"), funcprot);
			setUTCMonth = new BuiltinFunction("setUTCMonth", this, typeFromHandle.GetMethod("setUTCMonth"), funcprot);
			setFullYear = new BuiltinFunction("setFullYear", this, typeFromHandle.GetMethod("setFullYear"), funcprot);
			setUTCFullYear = new BuiltinFunction("setUTCFullYear", this, typeFromHandle.GetMethod("setUTCFullYear"), funcprot);
			setYear = new BuiltinFunction("setYear", this, typeFromHandle.GetMethod("setYear"), funcprot);
			toDateString = new BuiltinFunction("toDateString", this, typeFromHandle.GetMethod("toDateString"), funcprot);
			toLocaleDateString = new BuiltinFunction("toLocaleDateString", this, typeFromHandle.GetMethod("toLocaleDateString"), funcprot);
			toLocaleString = new BuiltinFunction("toLocaleString", this, typeFromHandle.GetMethod("toLocaleString"), funcprot);
			toLocaleTimeString = new BuiltinFunction("toLocaleTimeString", this, typeFromHandle.GetMethod("toLocaleTimeString"), funcprot);
			toGMTString = new BuiltinFunction("toUTCString", this, typeFromHandle.GetMethod("toUTCString"), funcprot);
			toString = new BuiltinFunction("toString", this, typeFromHandle.GetMethod("toString"), funcprot);
			toTimeString = new BuiltinFunction("toTimeString", this, typeFromHandle.GetMethod("toTimeString"), funcprot);
			toUTCString = new BuiltinFunction("toUTCString", this, typeFromHandle.GetMethod("toUTCString"), funcprot);
			valueOf = new BuiltinFunction("valueOf", this, typeFromHandle.GetMethod("valueOf"), funcprot);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.EnumeratorPrototype" /> class. The <see cref="T:Microsoft.JScript.LenientEnumeratorPrototype" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientEnumeratorPrototype : EnumeratorPrototype
	{
		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.EnumeratorConstructor" /> object.</summary>
		public new object constructor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.EnumeratorPrototype.atEnd(System.Object)" /> method of the <see cref="T:Microsoft.JScript.EnumeratorPrototype" /> class.</summary>
		public new object atEnd;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.EnumeratorPrototype.item(System.Object)" /> method of the <see cref="T:Microsoft.JScript.EnumeratorPrototype" /> class.</summary>
		public new object item;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.EnumeratorPrototype.moveFirst(System.Object)" /> method of the <see cref="T:Microsoft.JScript.EnumeratorPrototype" /> class.</summary>
		public new object moveFirst;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.EnumeratorPrototype.moveNext(System.Object)" /> method of the <see cref="T:Microsoft.JScript.EnumeratorPrototype" /> class.</summary>
		public new object moveNext;

		internal LenientEnumeratorPrototype(LenientFunctionPrototype funcprot, LenientObjectPrototype parent)
			: base(parent)
		{
			noExpando = false;
			Type typeFromHandle = typeof(EnumeratorPrototype);
			atEnd = new BuiltinFunction("atEnd", this, typeFromHandle.GetMethod("atEnd"), funcprot);
			item = new BuiltinFunction("item", this, typeFromHandle.GetMethod("item"), funcprot);
			moveFirst = new BuiltinFunction("moveFirst", this, typeFromHandle.GetMethod("moveFirst"), funcprot);
			moveNext = new BuiltinFunction("moveNext", this, typeFromHandle.GetMethod("moveNext"), funcprot);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.ErrorPrototype" /> class. The <see cref="T:Microsoft.JScript.LenientErrorPrototype" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientErrorPrototype : ErrorPrototype
	{
		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ErrorConstructor" /> object.</summary>
		public new object constructor;

		/// <summary>Stores a string that contains the name of the subtype of the error.</summary>
		public new object name;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ErrorPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ErrorPrototype" /> class.</summary>
		public new object toString;

		internal LenientErrorPrototype(LenientFunctionPrototype funcprot, ScriptObject parent, string name)
			: base(parent, name)
		{
			noExpando = false;
			this.name = name;
			Type typeFromHandle = typeof(ErrorPrototype);
			toString = new BuiltinFunction("toString", this, typeFromHandle.GetMethod("toString"), funcprot);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.FunctionPrototype" /> class. The <see cref="T:Microsoft.JScript.LenientFunctionPrototype" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientFunctionPrototype : FunctionPrototype
	{
		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.FunctionConstructor" /> object.</summary>
		public new object constructor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.FunctionPrototype.apply(System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.FunctionPrototype" /> class.</summary>
		public new object apply;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.FunctionPrototype.call(System.Object,System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.FunctionPrototype" /> class.</summary>
		public new object call;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.FunctionPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.FunctionPrototype" /> class.</summary>
		public new object toString;

		internal LenientFunctionPrototype(ScriptObject parent)
			: base(parent)
		{
			noExpando = false;
			Type typeFromHandle = typeof(FunctionPrototype);
			apply = new BuiltinFunction("apply", this, typeFromHandle.GetMethod("apply"), this);
			call = new BuiltinFunction("call", this, typeFromHandle.GetMethod("call"), this);
			toString = new BuiltinFunction("toString", this, typeFromHandle.GetMethod("toString"), this);
		}
	}
	/// <summary>Stores constructor function objects, data type information, and objects that represent the static methods of the <see cref="T:Microsoft.JScript.GlobalObject" /> class. The <see cref="T:Microsoft.JScript.LenientGlobalObject" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientGlobalObject : GlobalObject
	{
		/// <summary>Represents positive infinity.</summary>
		public new object Infinity;

		private object MathField;

		/// <summary>Represents a value that is not a number (NaN).</summary>
		public new object NaN;

		/// <summary>Represents a value that is null.</summary>
		public new object undefined;

		private object ActiveXObjectField;

		private object ArrayField;

		private object BooleanField;

		private object DateField;

		private object EnumeratorField;

		private object ErrorField;

		private object EvalErrorField;

		private object FunctionField;

		private object NumberField;

		private object ObjectField;

		private object RangeErrorField;

		private object ReferenceErrorField;

		private object RegExpField;

		private object StringField;

		private object SyntaxErrorField;

		private object TypeErrorField;

		private object VBArrayField;

		private object URIErrorField;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.decodeURI(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object decodeURI;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.decodeURIComponent(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object decodeURIComponent;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.encodeURI(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object encodeURI;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.encodeURIComponent(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object encodeURIComponent;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.escape(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		[NotRecommended("escape")]
		public new object escape;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.eval(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object eval;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.isNaN(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object isNaN;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.isFinite(System.Double)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object isFinite;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.parseInt(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object parseInt;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.parseFloat(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object parseFloat;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.GetObject(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object GetObject;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.ScriptEngine" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object ScriptEngine;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.ScriptEngineBuildVersion" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object ScriptEngineBuildVersion;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.ScriptEngineMajorVersion" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object ScriptEngineMajorVersion;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.ScriptEngineMinorVersion" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		public new object ScriptEngineMinorVersion;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.GlobalObject.unescape(System.Object)" /> method of the <see cref="T:Microsoft.JScript.GlobalObject" /> class.</summary>
		[NotRecommended("unescape")]
		public new object unescape;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="boolean" /> data type.</summary>
		public new object boolean;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="byte" /> data type.</summary>
		public new object @byte;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="char" /> data type.</summary>
		public new object @char;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="decimal" /> data type.</summary>
		public new object @decimal;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="double" /> data type.</summary>
		public new object @double;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="float" /> data type.</summary>
		public new object @float;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="int" /> data type.</summary>
		public new object @int;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="long" /> data type.</summary>
		public new object @long;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="sbyte" /> data type.</summary>
		public new object @sbyte;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="short" /> data type.</summary>
		public new object @short;

		/// <summary>Stores the managed type that corresponds to the return value of a function that does not return a value.</summary>
		public new object @void;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="uint" /> data type.</summary>
		public new object @uint;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="ulong" /> data type.</summary>
		public new object @ulong;

		/// <summary>Stores the managed type that corresponds to the JScript <see langword="ushort" /> data type.</summary>
		public new object @ushort;

		private LenientArrayPrototype arrayPrototypeField;

		private LenientFunctionPrototype functionPrototypeField;

		private LenientObjectPrototype objectPrototypeField;

		private VsaEngine engine;

		private LenientArrayPrototype arrayPrototype
		{
			get
			{
				if (arrayPrototypeField == null)
				{
					arrayPrototypeField = new LenientArrayPrototype(functionPrototype, objectPrototype);
				}
				return arrayPrototypeField;
			}
		}

		private LenientFunctionPrototype functionPrototype
		{
			get
			{
				if (functionPrototypeField == null)
				{
					object obj = objectPrototype;
				}
				return functionPrototypeField;
			}
		}

		private LenientObjectPrototype objectPrototype
		{
			get
			{
				if (objectPrototypeField == null)
				{
					LenientObjectPrototype lenientObjectPrototype = (objectPrototypeField = new LenientObjectPrototype(engine));
					LenientFunctionPrototype lenientFunctionPrototype = (functionPrototypeField = new LenientFunctionPrototype(lenientObjectPrototype));
					lenientObjectPrototype.Initialize(lenientFunctionPrototype);
					JSObject jSObject = new JSObject(lenientObjectPrototype, checkSubType: false);
					jSObject.AddField("constructor").SetValue(jSObject, lenientFunctionPrototype);
					lenientFunctionPrototype.proto = jSObject;
				}
				return objectPrototypeField;
			}
		}

		internal override ActiveXObjectConstructor originalActiveXObject
		{
			get
			{
				if (originalActiveXObjectField == null)
				{
					originalActiveXObjectField = new ActiveXObjectConstructor(functionPrototype);
				}
				return originalActiveXObjectField;
			}
		}

		internal override ArrayConstructor originalArray
		{
			get
			{
				if (originalArrayField == null)
				{
					originalArrayField = new ArrayConstructor(functionPrototype, arrayPrototype);
				}
				return originalArrayField;
			}
		}

		internal override BooleanConstructor originalBoolean
		{
			get
			{
				if (originalBooleanField == null)
				{
					originalBooleanField = new BooleanConstructor(functionPrototype, new LenientBooleanPrototype(functionPrototype, objectPrototype));
				}
				return originalBooleanField;
			}
		}

		internal override DateConstructor originalDate
		{
			get
			{
				if (originalDateField == null)
				{
					originalDateField = new LenientDateConstructor(functionPrototype, new LenientDatePrototype(functionPrototype, objectPrototype));
				}
				return originalDateField;
			}
		}

		internal override ErrorConstructor originalError
		{
			get
			{
				if (originalErrorField == null)
				{
					originalErrorField = new ErrorConstructor(functionPrototype, new LenientErrorPrototype(functionPrototype, objectPrototype, "Error"), this);
				}
				return originalErrorField;
			}
		}

		internal override EnumeratorConstructor originalEnumerator
		{
			get
			{
				if (originalEnumeratorField == null)
				{
					originalEnumeratorField = new EnumeratorConstructor(functionPrototype, new LenientEnumeratorPrototype(functionPrototype, objectPrototype));
				}
				return originalEnumeratorField;
			}
		}

		internal override ErrorConstructor originalEvalError
		{
			get
			{
				if (originalEvalErrorField == null)
				{
					originalEvalErrorField = new ErrorConstructor("EvalError", ErrorType.EvalError, originalError, this);
				}
				return originalEvalErrorField;
			}
		}

		internal override FunctionConstructor originalFunction
		{
			get
			{
				if (originalFunctionField == null)
				{
					originalFunctionField = new FunctionConstructor(functionPrototype);
				}
				return originalFunctionField;
			}
		}

		internal override NumberConstructor originalNumber
		{
			get
			{
				if (originalNumberField == null)
				{
					originalNumberField = new NumberConstructor(functionPrototype, new LenientNumberPrototype(functionPrototype, objectPrototype));
				}
				return originalNumberField;
			}
		}

		internal override ObjectConstructor originalObject
		{
			get
			{
				if (originalObjectField == null)
				{
					originalObjectField = new ObjectConstructor(functionPrototype, objectPrototype);
				}
				return originalObjectField;
			}
		}

		internal override ObjectPrototype originalObjectPrototype
		{
			get
			{
				if (originalObjectPrototypeField == null)
				{
					originalObjectPrototypeField = ObjectPrototype.ob;
				}
				return originalObjectPrototypeField;
			}
		}

		internal override ErrorConstructor originalRangeError
		{
			get
			{
				if (originalRangeErrorField == null)
				{
					originalRangeErrorField = new ErrorConstructor("RangeError", ErrorType.RangeError, originalError, this);
				}
				return originalRangeErrorField;
			}
		}

		internal override ErrorConstructor originalReferenceError
		{
			get
			{
				if (originalReferenceErrorField == null)
				{
					originalReferenceErrorField = new ErrorConstructor("ReferenceError", ErrorType.ReferenceError, originalError, this);
				}
				return originalReferenceErrorField;
			}
		}

		internal override RegExpConstructor originalRegExp
		{
			get
			{
				if (originalRegExpField == null)
				{
					originalRegExpField = new RegExpConstructor(functionPrototype, new LenientRegExpPrototype(functionPrototype, objectPrototype), arrayPrototype);
				}
				return originalRegExpField;
			}
		}

		internal override StringConstructor originalString
		{
			get
			{
				if (originalStringField == null)
				{
					originalStringField = new LenientStringConstructor(functionPrototype, new LenientStringPrototype(functionPrototype, objectPrototype));
				}
				return originalStringField;
			}
		}

		internal override ErrorConstructor originalSyntaxError
		{
			get
			{
				if (originalSyntaxErrorField == null)
				{
					originalSyntaxErrorField = new ErrorConstructor("SyntaxError", ErrorType.SyntaxError, originalError, this);
				}
				return originalSyntaxErrorField;
			}
		}

		internal override ErrorConstructor originalTypeError
		{
			get
			{
				if (originalTypeErrorField == null)
				{
					originalTypeErrorField = new ErrorConstructor("TypeError", ErrorType.TypeError, originalError, this);
				}
				return originalTypeErrorField;
			}
		}

		internal override ErrorConstructor originalURIError
		{
			get
			{
				if (originalURIErrorField == null)
				{
					originalURIErrorField = new ErrorConstructor("URIError", ErrorType.URIError, originalError, this);
				}
				return originalURIErrorField;
			}
		}

		internal override VBArrayConstructor originalVBArray
		{
			get
			{
				if (originalVBArrayField == null)
				{
					originalVBArrayField = new VBArrayConstructor(functionPrototype, new LenientVBArrayPrototype(functionPrototype, objectPrototype));
				}
				return originalVBArrayField;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by an <see cref="T:Microsoft.JScript.ActiveXObjectConstructor" /> constructor function object.</summary>
		/// <returns>An <see cref="T:Microsoft.JScript.ActiveXObjectConstructor" /> object.</returns>
		public new object ActiveXObject
		{
			get
			{
				if (ActiveXObjectField is Missing)
				{
					ActiveXObjectField = originalActiveXObject;
				}
				return ActiveXObjectField;
			}
			set
			{
				ActiveXObjectField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by an <see cref="T:Microsoft.JScript.ArrayConstructor" /> constructor function object.</summary>
		/// <returns>An <see cref="T:Microsoft.JScript.ArrayConstructor" /> object.</returns>
		public new object Array
		{
			get
			{
				if (ArrayField is Missing)
				{
					ArrayField = originalArray;
				}
				return ArrayField;
			}
			set
			{
				ArrayField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by a <see cref="T:Microsoft.JScript.BooleanConstructor" /> constructor function object.</summary>
		/// <returns>A <see cref="T:Microsoft.JScript.BooleanConstructor" /> object.</returns>
		public new object Boolean
		{
			get
			{
				if (BooleanField is Missing)
				{
					BooleanField = originalBoolean;
				}
				return BooleanField;
			}
			set
			{
				BooleanField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by a <see cref="T:Microsoft.JScript.LenientDateConstructor" /> constructor function object.</summary>
		/// <returns>A <see cref="T:Microsoft.JScript.LenientDateConstructor" /> object.</returns>
		public new object Date
		{
			get
			{
				if (DateField is Missing)
				{
					DateField = originalDate;
				}
				return DateField;
			}
			set
			{
				DateField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by an <see cref="T:Microsoft.JScript.EnumeratorConstructor" /> constructor function object.</summary>
		/// <returns>An <see cref="T:Microsoft.JScript.EnumeratorConstructor" /> object.</returns>
		public new object Enumerator
		{
			get
			{
				if (EnumeratorField is Missing)
				{
					EnumeratorField = originalEnumerator;
				}
				return EnumeratorField;
			}
			set
			{
				EnumeratorField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by an <see cref="T:Microsoft.JScript.ErrorConstructor" /> constructor function object.</summary>
		/// <returns>An <see cref="T:Microsoft.JScript.ErrorConstructor" /> object.</returns>
		public new object Error
		{
			get
			{
				if (ErrorField is Missing)
				{
					ErrorField = originalError;
				}
				return ErrorField;
			}
			set
			{
				ErrorField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by an <see cref="T:Microsoft.JScript.ErrorConstructor" /> constructor function object, and that is initialized as an <see cref="F:Microsoft.JScript.ErrorType.EvalError" />.</summary>
		/// <returns>An <see cref="T:Microsoft.JScript.ErrorConstructor" /> object.</returns>
		public new object EvalError
		{
			get
			{
				if (EvalErrorField is Missing)
				{
					EvalErrorField = originalEvalError;
				}
				return EvalErrorField;
			}
			set
			{
				EvalErrorField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by a <see cref="T:Microsoft.JScript.FunctionConstructor" /> constructor function object.</summary>
		/// <returns>A <see cref="T:Microsoft.JScript.FunctionConstructor" /> object.</returns>
		public new object Function
		{
			get
			{
				if (FunctionField is Missing)
				{
					FunctionField = originalFunction;
				}
				return FunctionField;
			}
			set
			{
				FunctionField = value;
			}
		}

		/// <summary>Gets or sets a <see cref="T:Microsoft.JScript.LenientMathObject" /> object.</summary>
		/// <returns>A <see cref="T:Microsoft.JScript.LenientMathObject" /> object.</returns>
		public new object Math
		{
			get
			{
				if (MathField is Missing)
				{
					MathField = new LenientMathObject(objectPrototype, functionPrototype);
				}
				return MathField;
			}
			set
			{
				MathField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by a <see cref="T:Microsoft.JScript.NumberConstructor" /> constructor function object.</summary>
		/// <returns>A <see cref="T:Microsoft.JScript.NumberConstructor" /> object.</returns>
		public new object Number
		{
			get
			{
				if (NumberField is Missing)
				{
					NumberField = originalNumber;
				}
				return NumberField;
			}
			set
			{
				NumberField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by an <see cref="T:Microsoft.JScript.ObjectConstructor" /> constructor function object.</summary>
		/// <returns>An <see cref="T:Microsoft.JScript.ObjectConstructor" /> object.</returns>
		public new object Object
		{
			get
			{
				if (ObjectField is Missing)
				{
					ObjectField = originalObject;
				}
				return ObjectField;
			}
			set
			{
				ObjectField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by an <see cref="T:Microsoft.JScript.ErrorConstructor" /> constructor function object, and that is initialized as a <see cref="F:Microsoft.JScript.ErrorType.RangeError" />.</summary>
		/// <returns>An <see cref="T:Microsoft.JScript.ErrorConstructor" /> object.</returns>
		public new object RangeError
		{
			get
			{
				if (RangeErrorField is Missing)
				{
					RangeErrorField = originalRangeError;
				}
				return RangeErrorField;
			}
			set
			{
				RangeErrorField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by an <see cref="T:Microsoft.JScript.ErrorConstructor" /> constructor function object, and that is initialized as a <see cref="F:Microsoft.JScript.ErrorType.ReferenceError" />.</summary>
		/// <returns>An <see cref="T:Microsoft.JScript.ErrorConstructor" /> object.</returns>
		public new object ReferenceError
		{
			get
			{
				if (ReferenceErrorField is Missing)
				{
					ReferenceErrorField = originalReferenceError;
				}
				return ReferenceErrorField;
			}
			set
			{
				ReferenceErrorField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by a <see cref="T:Microsoft.JScript.RegExpConstructor" /> constructor function object.</summary>
		/// <returns>A <see cref="T:Microsoft.JScript.RegExpConstructor" /> object.</returns>
		public new object RegExp
		{
			get
			{
				if (RegExpField is Missing)
				{
					RegExpField = originalRegExp;
				}
				return RegExpField;
			}
			set
			{
				RegExpField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by a <see cref="T:Microsoft.JScript.LenientStringConstructor" /> constructor function object.</summary>
		/// <returns>A <see cref="T:Microsoft.JScript.LenientStringConstructor" /> object.</returns>
		public new object String
		{
			get
			{
				if (StringField is Missing)
				{
					StringField = originalString;
				}
				return StringField;
			}
			set
			{
				StringField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by an <see cref="T:Microsoft.JScript.ErrorConstructor" /> constructor function object, and that is initialized as a <see cref="F:Microsoft.JScript.ErrorType.SyntaxError" />.</summary>
		/// <returns>An <see cref="T:Microsoft.JScript.ErrorConstructor" /> object.</returns>
		public new object SyntaxError
		{
			get
			{
				if (SyntaxErrorField is Missing)
				{
					SyntaxErrorField = originalSyntaxError;
				}
				return SyntaxErrorField;
			}
			set
			{
				SyntaxErrorField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by an <see cref="T:Microsoft.JScript.ErrorConstructor" /> constructor function object, and that is initialized as a <see cref="F:Microsoft.JScript.ErrorType.TypeError" />.</summary>
		/// <returns>An <see cref="T:Microsoft.JScript.ErrorConstructor" /> object.</returns>
		public new object TypeError
		{
			get
			{
				if (TypeErrorField is Missing)
				{
					TypeErrorField = originalTypeError;
				}
				return TypeErrorField;
			}
			set
			{
				TypeErrorField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by an <see cref="T:Microsoft.JScript.ErrorConstructor" /> constructor function object, and that is initialized as a <see cref="F:Microsoft.JScript.ErrorType.URIError" />.</summary>
		/// <returns>An <see cref="T:Microsoft.JScript.ErrorConstructor" /> object.</returns>
		public new object URIError
		{
			get
			{
				if (URIErrorField is Missing)
				{
					URIErrorField = originalURIError;
				}
				return URIErrorField;
			}
			set
			{
				URIErrorField = value;
			}
		}

		/// <summary>Gets or sets a prototype-based object that is defined by a <see cref="T:Microsoft.JScript.VBArrayConstructor" /> constructor function object.</summary>
		/// <returns>A <see cref="T:Microsoft.JScript.VBArrayConstructor" /> object.</returns>
		public new object VBArray
		{
			get
			{
				if (VBArrayField is Missing)
				{
					VBArrayField = originalVBArray;
				}
				return VBArrayField;
			}
			set
			{
				VBArrayField = value;
			}
		}

		internal LenientGlobalObject(VsaEngine engine)
		{
			this.engine = engine;
			Infinity = double.PositiveInfinity;
			NaN = double.NaN;
			undefined = null;
			ActiveXObjectField = Missing.Value;
			ArrayField = Missing.Value;
			BooleanField = Missing.Value;
			DateField = Missing.Value;
			EnumeratorField = Missing.Value;
			ErrorField = Missing.Value;
			EvalErrorField = Missing.Value;
			FunctionField = Missing.Value;
			MathField = Missing.Value;
			NumberField = Missing.Value;
			ObjectField = Missing.Value;
			RangeErrorField = Missing.Value;
			ReferenceErrorField = Missing.Value;
			RegExpField = Missing.Value;
			StringField = Missing.Value;
			SyntaxErrorField = Missing.Value;
			TypeErrorField = Missing.Value;
			VBArrayField = Missing.Value;
			URIErrorField = Missing.Value;
			Type typeFromHandle = typeof(GlobalObject);
			LenientFunctionPrototype parent = functionPrototype;
			decodeURI = new BuiltinFunction("decodeURI", this, typeFromHandle.GetMethod("decodeURI"), parent);
			decodeURIComponent = new BuiltinFunction("decodeURIComponent", this, typeFromHandle.GetMethod("decodeURIComponent"), parent);
			encodeURI = new BuiltinFunction("encodeURI", this, typeFromHandle.GetMethod("encodeURI"), parent);
			encodeURIComponent = new BuiltinFunction("encodeURIComponent", this, typeFromHandle.GetMethod("encodeURIComponent"), parent);
			escape = new BuiltinFunction("escape", this, typeFromHandle.GetMethod("escape"), parent);
			eval = new BuiltinFunction("eval", this, typeFromHandle.GetMethod("eval"), parent);
			isNaN = new BuiltinFunction("isNaN", this, typeFromHandle.GetMethod("isNaN"), parent);
			isFinite = new BuiltinFunction("isFinite", this, typeFromHandle.GetMethod("isFinite"), parent);
			parseInt = new BuiltinFunction("parseInt", this, typeFromHandle.GetMethod("parseInt"), parent);
			GetObject = new BuiltinFunction("GetObject", this, typeFromHandle.GetMethod("GetObject"), parent);
			parseFloat = new BuiltinFunction("parseFloat", this, typeFromHandle.GetMethod("parseFloat"), parent);
			ScriptEngine = new BuiltinFunction("ScriptEngine", this, typeFromHandle.GetMethod("ScriptEngine"), parent);
			ScriptEngineBuildVersion = new BuiltinFunction("ScriptEngineBuildVersion", this, typeFromHandle.GetMethod("ScriptEngineBuildVersion"), parent);
			ScriptEngineMajorVersion = new BuiltinFunction("ScriptEngineMajorVersion", this, typeFromHandle.GetMethod("ScriptEngineMajorVersion"), parent);
			ScriptEngineMinorVersion = new BuiltinFunction("ScriptEngineMinorVersion", this, typeFromHandle.GetMethod("ScriptEngineMinorVersion"), parent);
			unescape = new BuiltinFunction("unescape", this, typeFromHandle.GetMethod("unescape"), parent);
			boolean = Typeob.Boolean;
			@byte = Typeob.Byte;
			@char = Typeob.Char;
			@decimal = Typeob.Decimal;
			@double = Typeob.Double;
			@float = Typeob.Single;
			@int = Typeob.Int32;
			@long = Typeob.Int64;
			@sbyte = Typeob.SByte;
			@short = Typeob.Int16;
			@void = Typeob.Void;
			@uint = Typeob.UInt32;
			@ulong = Typeob.UInt64;
			@ushort = Typeob.UInt16;
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.MathObject" /> class. The <see cref="T:Microsoft.JScript.LenientMathObject" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientMathObject : MathObject
	{
		/// <summary>Stores a value that represents Euler's constant, the base of the natural logarithm, specified by the constant e.</summary>
		public new const double E = Math.E;

		/// <summary>Stores a value that represents the logarithm base e of 10, the natural logarithm of 10.</summary>
		public new const double LN10 = 2.3025850929940459;

		/// <summary>Stores a value that represents the logarithm base e of 2, the natural logarithm of 2.</summary>
		public new const double LN2 = 0.69314718055994529;

		/// <summary>Stores a value that represents the logarithm base 2 of e, the binary logarithm of e.</summary>
		public new const double LOG2E = 1.4426950408889634;

		/// <summary>Stores a value that represents the logarithm base 10 of e, the common logarithm of e.</summary>
		public new const double LOG10E = 0.43429448190325182;

		/// <summary>Stores a value that represents the ratio of the circumference of a circle to its diameter, specified by the constant π.</summary>
		public new const double PI = Math.PI;

		/// <summary>Stores a value that represents the following equivalent values: (√2)/2, √(½), and 1/(√2).</summary>
		public new const double SQRT1_2 = 0.70710678118654757;

		/// <summary>Stores a value that represents √2.</summary>
		public new const double SQRT2 = 1.4142135623730951;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.abs(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object abs;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.acos(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object acos;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.asin(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object asin;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.atan(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object atan;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.atan2(System.Double,System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object atan2;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.ceil(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object ceil;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.cos(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object cos;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.exp(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object exp;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.floor(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object floor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.log(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object log;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.max(System.Object,System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object max;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.min(System.Object,System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object min;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.pow(System.Double,System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object pow;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.random" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object random;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.round(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object round;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.sin(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object sin;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.sqrt(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object sqrt;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.MathObject.tan(System.Double)" /> method of the <see cref="T:Microsoft.JScript.MathObject" /> class.</summary>
		public new object tan;

		internal LenientMathObject(ScriptObject parent, FunctionPrototype funcprot)
			: base(parent)
		{
			noExpando = false;
			Type typeFromHandle = typeof(MathObject);
			abs = new BuiltinFunction("abs", this, typeFromHandle.GetMethod("abs"), funcprot);
			acos = new BuiltinFunction("acos", this, typeFromHandle.GetMethod("acos"), funcprot);
			asin = new BuiltinFunction("asin", this, typeFromHandle.GetMethod("asin"), funcprot);
			atan = new BuiltinFunction("atan", this, typeFromHandle.GetMethod("atan"), funcprot);
			atan2 = new BuiltinFunction("atan2", this, typeFromHandle.GetMethod("atan2"), funcprot);
			ceil = new BuiltinFunction("ceil", this, typeFromHandle.GetMethod("ceil"), funcprot);
			cos = new BuiltinFunction("cos", this, typeFromHandle.GetMethod("cos"), funcprot);
			exp = new BuiltinFunction("exp", this, typeFromHandle.GetMethod("exp"), funcprot);
			floor = new BuiltinFunction("floor", this, typeFromHandle.GetMethod("floor"), funcprot);
			log = new BuiltinFunction("log", this, typeFromHandle.GetMethod("log"), funcprot);
			max = new BuiltinFunction("max", this, typeFromHandle.GetMethod("max"), funcprot);
			min = new BuiltinFunction("min", this, typeFromHandle.GetMethod("min"), funcprot);
			pow = new BuiltinFunction("pow", this, typeFromHandle.GetMethod("pow"), funcprot);
			random = new BuiltinFunction("random", this, typeFromHandle.GetMethod("random"), funcprot);
			round = new BuiltinFunction("round", this, typeFromHandle.GetMethod("round"), funcprot);
			sin = new BuiltinFunction("sin", this, typeFromHandle.GetMethod("sin"), funcprot);
			sqrt = new BuiltinFunction("sqrt", this, typeFromHandle.GetMethod("sqrt"), funcprot);
			tan = new BuiltinFunction("tan", this, typeFromHandle.GetMethod("tan"), funcprot);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class. The <see cref="T:Microsoft.JScript.LenientNumberPrototype" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientNumberPrototype : NumberPrototype
	{
		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.NumberConstructor" /> object.</summary>
		public new object constructor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.NumberPrototype.toExponential(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		public new object toExponential;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.NumberPrototype.toFixed(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		public new object toFixed;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.NumberPrototype.toLocaleString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		public new object toLocaleString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.NumberPrototype.toPrecision(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		public new object toPrecision;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.NumberPrototype.toString(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		public new object toString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.NumberPrototype.valueOf(System.Object)" /> method of the <see cref="T:Microsoft.JScript.NumberPrototype" /> class.</summary>
		public new object valueOf;

		internal LenientNumberPrototype(LenientFunctionPrototype funcprot, LenientObjectPrototype parent)
			: base(parent)
		{
			noExpando = false;
			Type typeFromHandle = typeof(NumberPrototype);
			toExponential = new BuiltinFunction("toExponential", this, typeFromHandle.GetMethod("toExponential"), funcprot);
			toFixed = new BuiltinFunction("toFixed", this, typeFromHandle.GetMethod("toFixed"), funcprot);
			toLocaleString = new BuiltinFunction("toLocaleString", this, typeFromHandle.GetMethod("toLocaleString"), funcprot);
			toPrecision = new BuiltinFunction("toPrecision", this, typeFromHandle.GetMethod("toPrecision"), funcprot);
			toString = new BuiltinFunction("toString", this, typeFromHandle.GetMethod("toString"), funcprot);
			valueOf = new BuiltinFunction("valueOf", this, typeFromHandle.GetMethod("valueOf"), funcprot);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class. The <see cref="T:Microsoft.JScript.LenientObjectPrototype" /> class belongs to the built-in object model category.</summary>
	public class LenientObjectPrototype : ObjectPrototype
	{
		/// <summary>Stores a reference to an <see cref="T:Microsoft.JScript.ObjectConstructor" /> object.</summary>
		public new object constructor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ObjectPrototype.hasOwnProperty(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		public new object hasOwnProperty;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ObjectPrototype.isPrototypeOf(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		public new object isPrototypeOf;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ObjectPrototype.propertyIsEnumerable(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		public new object propertyIsEnumerable;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ObjectPrototype.toLocaleString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		public new object toLocaleString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ObjectPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		public new object toString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.ObjectPrototype.valueOf(System.Object)" /> method of the <see cref="T:Microsoft.JScript.ObjectPrototype" /> class.</summary>
		public new object valueOf;

		internal LenientObjectPrototype(VsaEngine engine)
		{
			base.engine = engine;
			noExpando = false;
		}

		internal void Initialize(LenientFunctionPrototype funcprot)
		{
			Type typeFromHandle = typeof(ObjectPrototype);
			hasOwnProperty = new BuiltinFunction("hasOwnProperty", this, typeFromHandle.GetMethod("hasOwnProperty"), funcprot);
			isPrototypeOf = new BuiltinFunction("isPrototypeOf", this, typeFromHandle.GetMethod("isPrototypeOf"), funcprot);
			propertyIsEnumerable = new BuiltinFunction("propertyIsEnumerable", this, typeFromHandle.GetMethod("propertyIsEnumerable"), funcprot);
			toLocaleString = new BuiltinFunction("toLocaleString", this, typeFromHandle.GetMethod("toLocaleString"), funcprot);
			toString = new BuiltinFunction("toString", this, typeFromHandle.GetMethod("toString"), funcprot);
			valueOf = new BuiltinFunction("valueOf", this, typeFromHandle.GetMethod("valueOf"), funcprot);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.RegExpPrototype" /> class. The <see cref="T:Microsoft.JScript.LenientRegExpPrototype" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientRegExpPrototype : RegExpPrototype
	{
		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.RegExpConstructor" /> object.</summary>
		public new object constructor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.RegExpPrototype.compile(System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.RegExpPrototype" /> class.</summary>
		public new object compile;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.RegExpPrototype.exec(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.RegExpPrototype" /> class.</summary>
		public new object exec;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.RegExpPrototype.test(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.RegExpPrototype" /> class.</summary>
		public new object test;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.RegExpPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.RegExpPrototype" /> class.</summary>
		public new object toString;

		internal LenientRegExpPrototype(LenientFunctionPrototype funcprot, LenientObjectPrototype parent)
			: base(parent)
		{
			noExpando = false;
			Type typeFromHandle = typeof(RegExpPrototype);
			compile = new BuiltinFunction("compile", this, typeFromHandle.GetMethod("compile"), funcprot);
			exec = new BuiltinFunction("exec", this, typeFromHandle.GetMethod("exec"), funcprot);
			test = new BuiltinFunction("test", this, typeFromHandle.GetMethod("test"), funcprot);
			toString = new BuiltinFunction("toString", this, typeFromHandle.GetMethod("toString"), funcprot);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.StringConstructor" /> class. The <see cref="T:Microsoft.JScript.LenientStringConstructor" /> class belongs to the built-in object model category.</summary>
	public class LenientStringConstructor : StringConstructor
	{
		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringConstructor.fromCharCode(System.Object[])" /> method of the <see cref="T:Microsoft.JScript.StringConstructor" /> class.</summary>
		public new object fromCharCode;

		internal LenientStringConstructor(LenientFunctionPrototype parent, LenientStringPrototype prototypeProp)
			: base(parent, prototypeProp)
		{
			noExpando = false;
			Type typeFromHandle = typeof(StringConstructor);
			fromCharCode = new BuiltinFunction("fromCharCode", this, typeFromHandle.GetMethod("fromCharCode"), parent);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.StringPrototype" /> class. The <see cref="T:Microsoft.JScript.LenientStringPrototype" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientStringPrototype : StringPrototype
	{
		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.StringConstructor" /> object.</summary>
		public new object constructor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.anchor(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object anchor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.big(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object big;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.blink(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object blink;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.bold(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object bold;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.charAt(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object charAt;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.charCodeAt(System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object charCodeAt;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.concat(System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object concat;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.fixed(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object @fixed;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.fontcolor(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object fontcolor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.fontsize(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object fontsize;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.indexOf(System.Object,System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object indexOf;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.italics(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object italics;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.lastIndexOf(System.Object,System.Object,System.Double)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object lastIndexOf;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.link(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object link;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.localeCompare(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object localeCompare;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.match(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object match;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.replace(System.Object,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object replace;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.search(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object search;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.slice(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object slice;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.small(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object small;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.split(System.Object,Microsoft.JScript.Vsa.VsaEngine,System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object split;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.strike(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object strike;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.sub(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object sub;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.substr(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		[NotRecommended("substr")]
		public new object substr;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.substring(System.Object,System.Double,System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object substring;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.sup(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object sup;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.toLocaleLowerCase(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object toLocaleLowerCase;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.toLocaleUpperCase(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object toLocaleUpperCase;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.toLowerCase(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object toLowerCase;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.toString(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object toString;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.toUpperCase(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object toUpperCase;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.StringPrototype.valueOf(System.Object)" /> method of the <see cref="T:Microsoft.JScript.StringPrototype" /> class.</summary>
		public new object valueOf;

		internal LenientStringPrototype(LenientFunctionPrototype funcprot, LenientObjectPrototype parent)
			: base(funcprot, parent)
		{
			noExpando = false;
			Type typeFromHandle = typeof(StringPrototype);
			anchor = new BuiltinFunction("anchor", this, typeFromHandle.GetMethod("anchor"), funcprot);
			big = new BuiltinFunction("big", this, typeFromHandle.GetMethod("big"), funcprot);
			blink = new BuiltinFunction("blink", this, typeFromHandle.GetMethod("blink"), funcprot);
			bold = new BuiltinFunction("bold", this, typeFromHandle.GetMethod("bold"), funcprot);
			charAt = new BuiltinFunction("charAt", this, typeFromHandle.GetMethod("charAt"), funcprot);
			charCodeAt = new BuiltinFunction("charCodeAt", this, typeFromHandle.GetMethod("charCodeAt"), funcprot);
			concat = new BuiltinFunction("concat", this, typeFromHandle.GetMethod("concat"), funcprot);
			@fixed = new BuiltinFunction("fixed", this, typeFromHandle.GetMethod("fixed"), funcprot);
			fontcolor = new BuiltinFunction("fontcolor", this, typeFromHandle.GetMethod("fontcolor"), funcprot);
			fontsize = new BuiltinFunction("fontsize", this, typeFromHandle.GetMethod("fontsize"), funcprot);
			indexOf = new BuiltinFunction("indexOf", this, typeFromHandle.GetMethod("indexOf"), funcprot);
			italics = new BuiltinFunction("italics", this, typeFromHandle.GetMethod("italics"), funcprot);
			lastIndexOf = new BuiltinFunction("lastIndexOf", this, typeFromHandle.GetMethod("lastIndexOf"), funcprot);
			link = new BuiltinFunction("link", this, typeFromHandle.GetMethod("link"), funcprot);
			localeCompare = new BuiltinFunction("localeCompare", this, typeFromHandle.GetMethod("localeCompare"), funcprot);
			match = new BuiltinFunction("match", this, typeFromHandle.GetMethod("match"), funcprot);
			replace = new BuiltinFunction("replace", this, typeFromHandle.GetMethod("replace"), funcprot);
			search = new BuiltinFunction("search", this, typeFromHandle.GetMethod("search"), funcprot);
			slice = new BuiltinFunction("slice", this, typeFromHandle.GetMethod("slice"), funcprot);
			small = new BuiltinFunction("small", this, typeFromHandle.GetMethod("small"), funcprot);
			split = new BuiltinFunction("split", this, typeFromHandle.GetMethod("split"), funcprot);
			strike = new BuiltinFunction("strike", this, typeFromHandle.GetMethod("strike"), funcprot);
			sub = new BuiltinFunction("sub", this, typeFromHandle.GetMethod("sub"), funcprot);
			substr = new BuiltinFunction("substr", this, typeFromHandle.GetMethod("substr"), funcprot);
			substring = new BuiltinFunction("substring", this, typeFromHandle.GetMethod("substring"), funcprot);
			sup = new BuiltinFunction("sup", this, typeFromHandle.GetMethod("sup"), funcprot);
			toLocaleLowerCase = new BuiltinFunction("toLocaleLowerCase", this, typeFromHandle.GetMethod("toLocaleLowerCase"), funcprot);
			toLocaleUpperCase = new BuiltinFunction("toLocaleUpperCase", this, typeFromHandle.GetMethod("toLocaleUpperCase"), funcprot);
			toLowerCase = new BuiltinFunction("toLowerCase", this, typeFromHandle.GetMethod("toLowerCase"), funcprot);
			toString = new BuiltinFunction("toString", this, typeFromHandle.GetMethod("toString"), funcprot);
			toUpperCase = new BuiltinFunction("toUpperCase", this, typeFromHandle.GetMethod("toUpperCase"), funcprot);
			valueOf = new BuiltinFunction("valueOf", this, typeFromHandle.GetMethod("valueOf"), funcprot);
		}
	}
	/// <summary>Stores objects that represent the static methods of the <see cref="T:Microsoft.JScript.VBArrayPrototype" /> class. The <see cref="T:Microsoft.JScript.LenientVBArrayPrototype" /> class belongs to the built-in object model category.</summary>
	public sealed class LenientVBArrayPrototype : VBArrayPrototype
	{
		/// <summary>Stores a reference to a <see cref="T:Microsoft.JScript.VBArrayConstructor" /> object.</summary>
		public new object constructor;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.VBArrayPrototype.dimensions(System.Object)" /> method of the <see cref="T:Microsoft.JScript.VBArrayPrototype" /> class.</summary>
		public new object dimensions;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.VBArrayPrototype.getItem(System.Object,System.Object[])" /> method of the <see cref="T:Microsoft.JScript.VBArrayPrototype" /> class.</summary>
		public new object getItem;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.VBArrayPrototype.lbound(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.VBArrayPrototype" /> class.</summary>
		public new object lbound;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.VBArrayPrototype.toArray(System.Object,Microsoft.JScript.Vsa.VsaEngine)" /> method of the <see cref="T:Microsoft.JScript.VBArrayPrototype" /> class.</summary>
		public new object toArray;

		/// <summary>Stores an object that represents the static <see cref="M:Microsoft.JScript.VBArrayPrototype.ubound(System.Object,System.Object)" /> method of the <see cref="T:Microsoft.JScript.VBArrayPrototype" /> class.</summary>
		public new object ubound;

		internal LenientVBArrayPrototype(LenientFunctionPrototype funcprot, LenientObjectPrototype parent)
			: base(funcprot, parent)
		{
			noExpando = false;
			Type typeFromHandle = typeof(VBArrayPrototype);
			dimensions = new BuiltinFunction("dimensions", this, typeFromHandle.GetMethod("dimensions"), funcprot);
			getItem = new BuiltinFunction("getItem", this, typeFromHandle.GetMethod("getItem"), funcprot);
			lbound = new BuiltinFunction("lbound", this, typeFromHandle.GetMethod("lbound"), funcprot);
			toArray = new BuiltinFunction("toArray", this, typeFromHandle.GetMethod("toArray"), funcprot);
			ubound = new BuiltinFunction("ubound", this, typeFromHandle.GetMethod("ubound"), funcprot);
		}
	}
	internal class ListEnumerator : IEnumerator
	{
		private int curr;

		private ArrayList list;

		public virtual object Current => list[curr];

		internal ListEnumerator(ArrayList list)
		{
			curr = -1;
			this.list = list;
		}

		public virtual bool MoveNext()
		{
			return ++curr < list.Count;
		}

		public virtual void Reset()
		{
			curr = -1;
		}
	}
	internal sealed class Logical_and : BinaryOp
	{
		internal Logical_and(Context context, AST operand1, AST operand2)
			: base(context, operand1, operand2)
		{
		}

		internal override object Evaluate()
		{
			object obj = operand1.Evaluate();
			MethodInfo methodInfo = null;
			Type type = null;
			if (obj != null && !(obj is IConvertible))
			{
				type = obj.GetType();
				methodInfo = type.GetMethod("op_False", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[1] { type }, null);
				if (methodInfo == null || (methodInfo.Attributes & MethodAttributes.SpecialName) == 0 || methodInfo.ReturnType != Typeob.Boolean)
				{
					methodInfo = null;
				}
			}
			if (methodInfo == null)
			{
				if (!Convert.ToBoolean(obj))
				{
					return obj;
				}
				return operand2.Evaluate();
			}
			methodInfo = new JSMethodInfo(methodInfo);
			if ((bool)methodInfo.Invoke(null, BindingFlags.SuppressChangeType, null, new object[1] { obj }, null))
			{
				return obj;
			}
			object obj2 = operand2.Evaluate();
			Type type2 = null;
			if (obj2 != null && !(obj2 is IConvertible))
			{
				type2 = obj2.GetType();
				if (type == type2)
				{
					MethodInfo method = type.GetMethod("op_BitwiseAnd", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[2] { type, type }, null);
					if (method != null && (method.Attributes & MethodAttributes.SpecialName) != 0)
					{
						method = new JSMethodInfo(method);
						return method.Invoke(null, BindingFlags.SuppressChangeType, null, new object[2] { obj, obj2 }, null);
					}
				}
			}
			return obj2;
		}

		internal override IReflect InferType(JSField inference_target)
		{
			IReflect reflect = operand1.InferType(inference_target);
			IReflect reflect2 = operand2.InferType(inference_target);
			if (reflect == reflect2)
			{
				return reflect;
			}
			return Typeob.Object;
		}

		internal override void TranslateToConditionalBranch(ILGenerator il, bool branchIfTrue, Label label, bool shortForm)
		{
			Label label2 = il.DefineLabel();
			if (branchIfTrue)
			{
				operand1.TranslateToConditionalBranch(il, branchIfTrue: false, label2, shortForm);
				operand2.TranslateToConditionalBranch(il, branchIfTrue: true, label, shortForm);
				il.MarkLabel(label2);
			}
			else
			{
				operand1.TranslateToConditionalBranch(il, branchIfTrue: false, label, shortForm);
				operand2.TranslateToConditionalBranch(il, branchIfTrue: false, label, shortForm);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Type type = Convert.ToType(operand1.InferType(null));
			Type type2 = Convert.ToType(operand2.InferType(null));
			if (type != type2)
			{
				type = Typeob.Object;
			}
			MethodInfo methodInfo = type.GetMethod("op_False", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[1] { type }, null);
			if (methodInfo == null || (methodInfo.Attributes & MethodAttributes.SpecialName) == 0 || methodInfo.ReturnType != Typeob.Boolean)
			{
				methodInfo = null;
			}
			MethodInfo methodInfo2 = null;
			if (methodInfo != null)
			{
				methodInfo2 = type.GetMethod("op_BitwiseAnd", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[2] { type, type }, null);
			}
			if (methodInfo2 == null || (methodInfo2.Attributes & MethodAttributes.SpecialName) == 0)
			{
				methodInfo = null;
			}
			Label label = il.DefineLabel();
			operand1.TranslateToIL(il, type);
			il.Emit(OpCodes.Dup);
			if (methodInfo != null)
			{
				if (type.IsValueType)
				{
					Convert.EmitLdloca(il, type);
				}
				il.Emit(OpCodes.Call, methodInfo);
				il.Emit(OpCodes.Brtrue, label);
				operand2.TranslateToIL(il, type);
				il.Emit(OpCodes.Call, methodInfo2);
				il.MarkLabel(label);
				Convert.Emit(this, il, methodInfo2.ReturnType, rtype);
			}
			else
			{
				Convert.Emit(this, il, type, Typeob.Boolean, truncationPermitted: true);
				il.Emit(OpCodes.Brfalse, label);
				il.Emit(OpCodes.Pop);
				operand2.TranslateToIL(il, type);
				il.MarkLabel(label);
				Convert.Emit(this, il, type, rtype);
			}
		}
	}
	internal sealed class Logical_or : BinaryOp
	{
		internal Logical_or(Context context, AST operand1, AST operand2)
			: base(context, operand1, operand2)
		{
		}

		internal override object Evaluate()
		{
			object obj = operand1.Evaluate();
			MethodInfo methodInfo = null;
			Type type = null;
			if (obj != null && !(obj is IConvertible))
			{
				type = obj.GetType();
				methodInfo = type.GetMethod("op_True", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[1] { type }, null);
				if (methodInfo == null || (methodInfo.Attributes & MethodAttributes.SpecialName) == 0 || methodInfo.ReturnType != Typeob.Boolean)
				{
					methodInfo = null;
				}
			}
			if (methodInfo == null)
			{
				if (Convert.ToBoolean(obj))
				{
					return obj;
				}
				return operand2.Evaluate();
			}
			methodInfo = new JSMethodInfo(methodInfo);
			if ((bool)methodInfo.Invoke(null, BindingFlags.SuppressChangeType, null, new object[1] { obj }, null))
			{
				return obj;
			}
			object obj2 = operand2.Evaluate();
			Type type2 = null;
			if (obj2 != null && !(obj2 is IConvertible))
			{
				type2 = obj2.GetType();
				if (type == type2)
				{
					MethodInfo method = type.GetMethod("op_BitwiseOr", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[2] { type, type }, null);
					if (method != null && (method.Attributes & MethodAttributes.SpecialName) != 0)
					{
						method = new JSMethodInfo(method);
						return method.Invoke(null, BindingFlags.SuppressChangeType, null, new object[2] { obj, obj2 }, null);
					}
				}
			}
			return obj2;
		}

		internal override IReflect InferType(JSField inference_target)
		{
			IReflect reflect = operand1.InferType(inference_target);
			IReflect reflect2 = operand2.InferType(inference_target);
			if (reflect == reflect2)
			{
				return reflect;
			}
			return Typeob.Object;
		}

		internal override void TranslateToConditionalBranch(ILGenerator il, bool branchIfTrue, Label label, bool shortForm)
		{
			Label label2 = il.DefineLabel();
			if (branchIfTrue)
			{
				operand1.TranslateToConditionalBranch(il, branchIfTrue: true, label, shortForm);
				operand2.TranslateToConditionalBranch(il, branchIfTrue: true, label, shortForm);
			}
			else
			{
				operand1.TranslateToConditionalBranch(il, branchIfTrue: true, label2, shortForm);
				operand2.TranslateToConditionalBranch(il, branchIfTrue: false, label, shortForm);
				il.MarkLabel(label2);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Type type = Convert.ToType(operand1.InferType(null));
			Type type2 = Convert.ToType(operand2.InferType(null));
			if (type != type2)
			{
				type = Typeob.Object;
			}
			MethodInfo methodInfo = type.GetMethod("op_True", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[1] { type }, null);
			if (methodInfo == null || (methodInfo.Attributes & MethodAttributes.SpecialName) == 0 || methodInfo.ReturnType != Typeob.Boolean)
			{
				methodInfo = null;
			}
			MethodInfo methodInfo2 = null;
			if (methodInfo != null)
			{
				methodInfo2 = type.GetMethod("op_BitwiseOr", BindingFlags.Static | BindingFlags.Public | BindingFlags.ExactBinding, null, new Type[2] { type, type }, null);
			}
			if (methodInfo2 == null || (methodInfo2.Attributes & MethodAttributes.SpecialName) == 0)
			{
				methodInfo = null;
			}
			Label label = il.DefineLabel();
			operand1.TranslateToIL(il, type);
			il.Emit(OpCodes.Dup);
			if (methodInfo != null)
			{
				if (type.IsValueType)
				{
					Convert.EmitLdloca(il, type);
				}
				il.Emit(OpCodes.Call, methodInfo);
				il.Emit(OpCodes.Brtrue, label);
				operand2.TranslateToIL(il, type);
				il.Emit(OpCodes.Call, methodInfo2);
				il.MarkLabel(label);
				Convert.Emit(this, il, methodInfo2.ReturnType, rtype);
			}
			else
			{
				Convert.Emit(this, il, type, Typeob.Boolean, truncationPermitted: true);
				il.Emit(OpCodes.Brtrue, label);
				il.Emit(OpCodes.Pop);
				operand2.TranslateToIL(il, type);
				il.MarkLabel(label);
				Convert.Emit(this, il, type, rtype);
			}
		}
	}
	internal sealed class Lookup : Binding
	{
		private int lexLevel;

		private int evalLexLevel;

		private LocalBuilder fieldLoc;

		private LocalBuilder refLoc;

		private LateBinding lateBinding;

		private bool thereIsAnObjectOnTheStack;

		internal string Name => name;

		internal Lookup(Context context)
			: base(context, context.GetCode())
		{
			lexLevel = 0;
			evalLexLevel = 0;
			fieldLoc = null;
			refLoc = null;
			lateBinding = null;
			thereIsAnObjectOnTheStack = false;
		}

		internal Lookup(string name, Context context)
			: this(context)
		{
			base.name = name;
		}

		private void BindName()
		{
			int num = 0;
			int num2 = 0;
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			BindingFlags bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
			bool flag = false;
			bool flag2 = false;
			while (scriptObject != null)
			{
				MemberInfo[] array = null;
				WithObject withObject = scriptObject as WithObject;
				if ((members = ((!(withObject != null && flag2)) ? scriptObject.GetMember(name, bindingFlags) : withObject.GetMember(name, bindingFlags, forceInstanceLookup: false))).Length != 0)
				{
					break;
				}
				if (scriptObject is WithObject)
				{
					isFullyResolved = isFullyResolved && ((WithObject)scriptObject).isKnownAtCompileTime;
					num++;
				}
				else if (scriptObject is ActivationObject)
				{
					isFullyResolved = isFullyResolved && ((ActivationObject)scriptObject).isKnownAtCompileTime;
					if (scriptObject is BlockScope || (scriptObject is FunctionScope && ((FunctionScope)scriptObject).mustSaveStackLocals))
					{
						num++;
					}
					if (scriptObject is ClassScope)
					{
						if (flag)
						{
							flag2 = true;
						}
						if (((ClassScope)scriptObject).owner.isStatic)
						{
							bindingFlags &= ~BindingFlags.Instance;
							flag = true;
						}
					}
				}
				else if (scriptObject is StackFrame)
				{
					num++;
				}
				num2++;
				scriptObject = scriptObject.GetParent();
			}
			if (members.Length != 0)
			{
				lexLevel = num;
				evalLexLevel = num2;
			}
		}

		internal bool CanPlaceAppropriateObjectOnStack(object ob)
		{
			if (ob is LenientGlobalObject)
			{
				return true;
			}
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			int num = lexLevel;
			while (num > 0 && (scriptObject is WithObject || scriptObject is BlockScope))
			{
				if (scriptObject is WithObject)
				{
					num--;
				}
				scriptObject = scriptObject.GetParent();
			}
			if (!(scriptObject is WithObject))
			{
				return scriptObject is GlobalScope;
			}
			return true;
		}

		internal override void CheckIfOKToUseInSuperConstructorCall()
		{
			FieldInfo fieldInfo = member as FieldInfo;
			if (fieldInfo != null)
			{
				if (!fieldInfo.IsStatic)
				{
					context.HandleError(JSError.NotAllowedInSuperConstructorCall);
				}
				return;
			}
			MethodInfo methodInfo = member as MethodInfo;
			if (methodInfo != null)
			{
				if (!methodInfo.IsStatic)
				{
					context.HandleError(JSError.NotAllowedInSuperConstructorCall);
				}
				return;
			}
			PropertyInfo propertyInfo = member as PropertyInfo;
			if (!(propertyInfo != null))
			{
				return;
			}
			methodInfo = JSProperty.GetGetMethod(propertyInfo, nonPublic: true);
			if (methodInfo != null && !methodInfo.IsStatic)
			{
				context.HandleError(JSError.NotAllowedInSuperConstructorCall);
				return;
			}
			methodInfo = JSProperty.GetSetMethod(propertyInfo, nonPublic: true);
			if (methodInfo != null && !methodInfo.IsStatic)
			{
				context.HandleError(JSError.NotAllowedInSuperConstructorCall);
			}
		}

		internal override object Evaluate()
		{
			object obj = null;
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			if (!isFullyResolved)
			{
				obj = ((IActivationObject)scriptObject).GetMemberValue(name, evalLexLevel);
				if (!(obj is Missing))
				{
					return obj;
				}
			}
			if (members == null && !VsaEngine.executeForJSEE)
			{
				BindName();
				ResolveRHValue();
			}
			obj = base.Evaluate();
			if (obj is Missing)
			{
				throw new JScriptException(JSError.UndefinedIdentifier, context);
			}
			return obj;
		}

		internal override LateBinding EvaluateAsLateBinding()
		{
			if (!isFullyResolved)
			{
				BindName();
				isFullyResolved = false;
			}
			if (defaultMember == member)
			{
				defaultMember = null;
			}
			object @object = GetObject();
			LateBinding lateBinding = this.lateBinding;
			if (lateBinding == null)
			{
				lateBinding = (this.lateBinding = new LateBinding(name, @object, VsaEngine.executeForJSEE));
			}
			lateBinding.obj = @object;
			lateBinding.last_object = @object;
			lateBinding.last_members = members;
			lateBinding.last_member = member;
			if (!isFullyResolved)
			{
				members = null;
			}
			return lateBinding;
		}

		internal override WrappedNamespace EvaluateAsWrappedNamespace(bool giveErrorIfNameInUse)
		{
			Namespace @namespace = Namespace.GetNamespace(name, base.Engine);
			GlobalScope globalScope = ((IActivationObject)base.Globals.ScopeStack.Peek()).GetGlobalScope();
			FieldInfo fieldInfo = (giveErrorIfNameInUse ? globalScope.GetLocalField(name) : globalScope.GetField(name, BindingFlags.Static | BindingFlags.Public));
			if (fieldInfo != null)
			{
				if (giveErrorIfNameInUse && (!fieldInfo.IsLiteral || !(fieldInfo.GetValue(null) is Namespace)))
				{
					context.HandleError(JSError.DuplicateName, treatAsError: true);
				}
			}
			else
			{
				fieldInfo = globalScope.AddNewField(name, @namespace, FieldAttributes.Public | FieldAttributes.Literal);
				((JSVariableField)fieldInfo).type = new TypeExpression(new ConstantWrapper(Typeob.Namespace, context));
				((JSVariableField)fieldInfo).originalContext = context;
			}
			return new WrappedNamespace(name, base.Engine);
		}

		protected override object GetObject()
		{
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			object obj;
			if (member is JSMemberField)
			{
				StackFrame stackFrame;
				while (true)
				{
					if (scriptObject != null)
					{
						stackFrame = scriptObject as StackFrame;
						if (stackFrame != null)
						{
							break;
						}
						scriptObject = scriptObject.GetParent();
						continue;
					}
					return null;
				}
				obj = stackFrame.closureInstance;
			}
			else
			{
				for (int num = evalLexLevel; num > 0; num--)
				{
					scriptObject = scriptObject.GetParent();
				}
				obj = scriptObject;
			}
			if (defaultMember != null)
			{
				switch (defaultMember.MemberType)
				{
				case MemberTypes.Field:
					return ((FieldInfo)defaultMember).GetValue(obj);
				case MemberTypes.Method:
					return ((MethodInfo)defaultMember).Invoke(obj, new object[0]);
				case MemberTypes.Property:
					return ((PropertyInfo)defaultMember).GetValue(obj, null);
				case MemberTypes.Event:
					return null;
				case MemberTypes.NestedType:
					return member;
				}
			}
			return obj;
		}

		protected override void HandleNoSuchMemberError()
		{
			if (isFullyResolved)
			{
				context.HandleError(JSError.UndeclaredVariable, base.Engine.doFast);
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			if (!isFullyResolved)
			{
				return Typeob.Object;
			}
			return base.InferType(inference_target);
		}

		internal bool InFunctionNestedInsideInstanceMethod()
		{
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject || scriptObject is BlockScope)
			{
				scriptObject = scriptObject.GetParent();
			}
			for (FunctionScope functionScope = scriptObject as FunctionScope; functionScope != null; functionScope = scriptObject as FunctionScope)
			{
				if (functionScope.owner.isMethod)
				{
					return !functionScope.owner.isStatic;
				}
				scriptObject = functionScope.owner.enclosing_scope;
				while (scriptObject is WithObject || scriptObject is BlockScope)
				{
					scriptObject = scriptObject.GetParent();
				}
			}
			return false;
		}

		internal bool InStaticCode()
		{
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject || scriptObject is BlockScope)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is FunctionScope functionScope)
			{
				return functionScope.isStatic;
			}
			if (scriptObject is StackFrame stackFrame)
			{
				return stackFrame.thisObject is Type;
			}
			if (scriptObject is ClassScope classScope)
			{
				return classScope.inStaticInitializerCode;
			}
			return true;
		}

		internal override AST PartiallyEvaluate()
		{
			BindName();
			if (members == null || members.Length == 0)
			{
				ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
				while (scriptObject is FunctionScope)
				{
					scriptObject = scriptObject.GetParent();
				}
				if (!(scriptObject is WithObject) || isFullyResolved)
				{
					context.HandleError(JSError.UndeclaredVariable, isFullyResolved && base.Engine.doFast);
				}
			}
			else
			{
				ResolveRHValue();
				MemberInfo memberInfo = member;
				if (memberInfo is FieldInfo)
				{
					FieldInfo fieldInfo = (FieldInfo)memberInfo;
					if (fieldInfo is JSLocalField && !((JSLocalField)fieldInfo).isDefined)
					{
						((JSLocalField)fieldInfo).isUsedBeforeDefinition = true;
						context.HandleError(JSError.VariableMightBeUnitialized);
					}
					if (fieldInfo.IsLiteral)
					{
						object obj = ((fieldInfo is JSVariableField) ? ((JSVariableField)fieldInfo).value : TypeReferences.GetConstantValue(fieldInfo));
						if (obj is AST)
						{
							AST aST = ((AST)obj).PartiallyEvaluate();
							if (aST is ConstantWrapper && isFullyResolved)
							{
								return aST;
							}
							obj = null;
						}
						if (!(obj is FunctionObject) && isFullyResolved)
						{
							return new ConstantWrapper(obj, context);
						}
					}
					else if (fieldInfo.IsInitOnly && fieldInfo.IsStatic && fieldInfo.DeclaringType == Typeob.GlobalObject && isFullyResolved)
					{
						return new ConstantWrapper(fieldInfo.GetValue(null), context);
					}
				}
				else if (memberInfo is PropertyInfo)
				{
					PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
					if (!propertyInfo.CanWrite && !(propertyInfo is JSProperty) && propertyInfo.DeclaringType == Typeob.GlobalObject && isFullyResolved)
					{
						return new ConstantWrapper(propertyInfo.GetValue(null, null), context);
					}
				}
				if (memberInfo is Type && isFullyResolved)
				{
					return new ConstantWrapper(memberInfo, context);
				}
			}
			return this;
		}

		internal override AST PartiallyEvaluateAsCallable()
		{
			BindName();
			return this;
		}

		internal override AST PartiallyEvaluateAsReference()
		{
			BindName();
			if (members == null || members.Length == 0)
			{
				ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
				if (!(scriptObject is WithObject) || isFullyResolved)
				{
					context.HandleError(JSError.UndeclaredVariable, isFullyResolved && base.Engine.doFast);
				}
			}
			else
			{
				ResolveLHValue();
			}
			return this;
		}

		internal override object ResolveCustomAttribute(ASTList args, IReflect[] argIRs, AST target)
		{
			if (name == "expando")
			{
				MemberInfo[] array = (members = Typeob.Expando.GetConstructors(BindingFlags.Instance | BindingFlags.Public));
			}
			else if (name == "override")
			{
				MemberInfo[] array = (members = Typeob.Override.GetConstructors(BindingFlags.Instance | BindingFlags.Public));
			}
			else if (name == "hide")
			{
				MemberInfo[] array = (members = Typeob.Hide.GetConstructors(BindingFlags.Instance | BindingFlags.Public));
			}
			else if (name == "...")
			{
				MemberInfo[] array = (members = Typeob.ParamArrayAttribute.GetConstructors(BindingFlags.Instance | BindingFlags.Public));
			}
			else
			{
				name += "Attribute";
				BindName();
				if (members == null || members.Length == 0)
				{
					name = name.Substring(0, name.Length - 9);
					BindName();
				}
			}
			return base.ResolveCustomAttribute(args, argIRs, target);
		}

		internal override void SetPartialValue(AST partial_value)
		{
			if (members == null || members.Length == 0)
			{
				return;
			}
			if (member is JSLocalField)
			{
				JSLocalField jSLocalField = (JSLocalField)member;
				if (jSLocalField.type == null)
				{
					IReflect reflect = partial_value.InferType(jSLocalField);
					if (reflect == Typeob.String && partial_value is Plus)
					{
						jSLocalField.SetInferredType(Typeob.Object, partial_value);
					}
					else
					{
						jSLocalField.SetInferredType(reflect, partial_value);
					}
					return;
				}
				jSLocalField.isDefined = true;
			}
			Binding.AssignmentCompatible(InferType(null), partial_value, partial_value.InferType(null), isFullyResolved);
		}

		internal override void SetValue(object value)
		{
			if (!isFullyResolved)
			{
				EvaluateAsLateBinding().SetValue(value);
			}
			else
			{
				base.SetValue(value);
			}
		}

		internal void SetWithValue(WithObject scope, object value)
		{
			FieldInfo field = scope.GetField(name, lexLevel);
			if (field != null)
			{
				field.SetValue(scope, value);
			}
		}

		public override string ToString()
		{
			return name;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (isFullyResolved)
			{
				base.TranslateToIL(il, rtype);
				return;
			}
			Label label = il.DefineLabel();
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
			il.Emit(OpCodes.Castclass, Typeob.IActivationObject);
			il.Emit(OpCodes.Ldstr, name);
			ConstantWrapper.TranslateToILInt(il, lexLevel);
			il.Emit(OpCodes.Callvirt, CompilerGlobals.getMemberValueMethod);
			il.Emit(OpCodes.Dup);
			il.Emit(OpCodes.Call, CompilerGlobals.isMissingMethod);
			il.Emit(OpCodes.Brfalse, label);
			il.Emit(OpCodes.Pop);
			base.TranslateToIL(il, Typeob.Object);
			il.MarkLabel(label);
			Convert.Emit(this, il, Typeob.Object, rtype);
		}

		internal override void TranslateToILCall(ILGenerator il, Type rtype, ASTList argList, bool construct, bool brackets)
		{
			if (isFullyResolved)
			{
				base.TranslateToILCall(il, rtype, argList, construct, brackets);
				return;
			}
			Label label = il.DefineLabel();
			Label label2 = il.DefineLabel();
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
			il.Emit(OpCodes.Castclass, Typeob.IActivationObject);
			il.Emit(OpCodes.Ldstr, name);
			ConstantWrapper.TranslateToILInt(il, lexLevel);
			il.Emit(OpCodes.Callvirt, CompilerGlobals.getMemberValueMethod);
			il.Emit(OpCodes.Dup);
			il.Emit(OpCodes.Call, CompilerGlobals.isMissingMethod);
			il.Emit(OpCodes.Brfalse, label);
			il.Emit(OpCodes.Pop);
			base.TranslateToILCall(il, Typeob.Object, argList, construct, brackets);
			il.Emit(OpCodes.Br, label2);
			il.MarkLabel(label);
			TranslateToILDefaultThisObject(il);
			argList.TranslateToIL(il, Typeob.ArrayOfObject);
			if (construct)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			if (brackets)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.callValue2Method);
			il.MarkLabel(label2);
			Convert.Emit(this, il, Typeob.Object, rtype);
		}

		internal void TranslateToILDefaultThisObject(ILGenerator il)
		{
			TranslateToILDefaultThisObject(il, 0);
		}

		private void TranslateToILDefaultThisObject(ILGenerator il, int lexLevel)
		{
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
			while (lexLevel-- > 0)
			{
				il.Emit(OpCodes.Call, CompilerGlobals.getParentMethod);
			}
			il.Emit(OpCodes.Castclass, Typeob.IActivationObject);
			il.Emit(OpCodes.Callvirt, CompilerGlobals.getDefaultThisObjectMethod);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			if (defaultMember != null)
			{
				return;
			}
			if (member != null)
			{
				switch (member.MemberType)
				{
				case MemberTypes.Constructor:
				case MemberTypes.Method:
				case MemberTypes.Property:
				case MemberTypes.TypeInfo:
				case MemberTypes.NestedType:
					return;
				case MemberTypes.Field:
					if (member is JSExpandoField)
					{
						member = null;
						break;
					}
					return;
				}
			}
			refLoc = il.DeclareLocal(Typeob.LateBinding);
			il.Emit(OpCodes.Ldstr, name);
			if (isFullyResolved && member == null && IsBoundToMethodInfos())
			{
				MethodInfo methodInfo = members[0] as MethodInfo;
				if (methodInfo.IsStatic)
				{
					il.Emit(OpCodes.Ldtoken, methodInfo.DeclaringType);
					il.Emit(OpCodes.Call, CompilerGlobals.getTypeFromHandleMethod);
				}
				else
				{
					TranslateToILObjectForMember(il, methodInfo.DeclaringType, noValue: false, methodInfo);
				}
			}
			else
			{
				EmitILToLoadEngine(il);
				il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
			}
			il.Emit(OpCodes.Newobj, CompilerGlobals.lateBindingConstructor2);
			il.Emit(OpCodes.Stloc, refLoc);
		}

		private bool IsBoundToMethodInfos()
		{
			if (members == null || members.Length == 0)
			{
				return false;
			}
			for (int i = 0; i < members.Length; i++)
			{
				if (!(members[i] is MethodInfo))
				{
					return false;
				}
			}
			return true;
		}

		protected override void TranslateToILObject(ILGenerator il, Type obType, bool noValue)
		{
			TranslateToILObjectForMember(il, obType, noValue, member);
		}

		private void TranslateToILObjectForMember(ILGenerator il, Type obType, bool noValue, MemberInfo mem)
		{
			thereIsAnObjectOnTheStack = true;
			if (mem is IWrappedMember)
			{
				object wrappedObject = ((IWrappedMember)mem).GetWrappedObject();
				if (wrappedObject is LenientGlobalObject)
				{
					EmitILToLoadEngine(il);
					il.Emit(OpCodes.Call, CompilerGlobals.getLenientGlobalObjectMethod);
				}
				else if (wrappedObject is Type || wrappedObject is ClassScope)
				{
					if (obType.IsAssignableFrom(Typeob.Type))
					{
						new ConstantWrapper(wrappedObject, null).TranslateToIL(il, Typeob.Type);
						return;
					}
					ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
					while (scriptObject is WithObject || scriptObject is BlockScope)
					{
						scriptObject = scriptObject.GetParent();
					}
					if (scriptObject is FunctionScope)
					{
						FunctionObject owner = ((FunctionScope)scriptObject).owner;
						if (owner.isMethod)
						{
							il.Emit(OpCodes.Ldarg_0);
						}
						else
						{
							EmitILToLoadEngine(il);
							il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
							scriptObject = base.Globals.ScopeStack.Peek();
							while (scriptObject is WithObject || scriptObject is BlockScope)
							{
								il.Emit(OpCodes.Call, CompilerGlobals.getParentMethod);
								scriptObject = scriptObject.GetParent();
							}
							il.Emit(OpCodes.Castclass, Typeob.StackFrame);
							il.Emit(OpCodes.Ldfld, CompilerGlobals.closureInstanceField);
						}
					}
					else if (scriptObject is ClassScope)
					{
						il.Emit(OpCodes.Ldarg_0);
					}
					for (scriptObject = base.Globals.ScopeStack.Peek(); scriptObject != null; scriptObject = scriptObject.GetParent())
					{
						if (scriptObject is ClassScope classScope)
						{
							if (classScope.IsSameOrDerivedFrom(obType))
							{
								break;
							}
							il.Emit(OpCodes.Ldfld, classScope.outerClassField);
						}
					}
				}
				else
				{
					TranslateToILDefaultThisObject(il, lexLevel);
					Convert.Emit(this, il, Typeob.Object, obType);
				}
				return;
			}
			ScriptObject scriptObject2 = base.Globals.ScopeStack.Peek();
			while (scriptObject2 is WithObject || scriptObject2 is BlockScope)
			{
				scriptObject2 = scriptObject2.GetParent();
			}
			if (scriptObject2 is FunctionScope)
			{
				FunctionObject owner2 = ((FunctionScope)scriptObject2).owner;
				if (!owner2.isMethod)
				{
					EmitILToLoadEngine(il);
					il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
					scriptObject2 = base.Globals.ScopeStack.Peek();
					while (scriptObject2 is WithObject || scriptObject2 is BlockScope)
					{
						il.Emit(OpCodes.Call, CompilerGlobals.getParentMethod);
						scriptObject2 = scriptObject2.GetParent();
					}
					il.Emit(OpCodes.Castclass, Typeob.StackFrame);
					il.Emit(OpCodes.Ldfld, CompilerGlobals.closureInstanceField);
					while (scriptObject2 != null)
					{
						if (scriptObject2 is ClassScope)
						{
							ClassScope classScope2 = (ClassScope)scriptObject2;
							if (classScope2.IsSameOrDerivedFrom(obType))
							{
								break;
							}
							il.Emit(OpCodes.Castclass, classScope2.GetTypeBuilder());
							il.Emit(OpCodes.Ldfld, classScope2.outerClassField);
						}
						scriptObject2 = scriptObject2.GetParent();
					}
					il.Emit(OpCodes.Castclass, obType);
					return;
				}
			}
			il.Emit(OpCodes.Ldarg_0);
			while (scriptObject2 != null)
			{
				if (scriptObject2 is ClassScope)
				{
					ClassScope classScope3 = (ClassScope)scriptObject2;
					if (classScope3.IsSameOrDerivedFrom(obType))
					{
						break;
					}
					il.Emit(OpCodes.Ldfld, classScope3.outerClassField);
				}
				scriptObject2 = scriptObject2.GetParent();
			}
		}

		internal override void TranslateToILPreSet(ILGenerator il)
		{
			TranslateToILPreSet(il, doBoth: false);
		}

		internal void TranslateToILPreSet(ILGenerator il, bool doBoth)
		{
			if (isFullyResolved)
			{
				base.TranslateToILPreSet(il);
				return;
			}
			Label label = il.DefineLabel();
			LocalBuilder local = (fieldLoc = il.DeclareLocal(Typeob.FieldInfo));
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
			il.Emit(OpCodes.Castclass, Typeob.IActivationObject);
			il.Emit(OpCodes.Ldstr, name);
			ConstantWrapper.TranslateToILInt(il, lexLevel);
			il.Emit(OpCodes.Callvirt, CompilerGlobals.getFieldMethod);
			il.Emit(OpCodes.Stloc, local);
			if (!doBoth)
			{
				il.Emit(OpCodes.Ldloc, local);
				il.Emit(OpCodes.Ldnull);
				il.Emit(OpCodes.Bne_Un_S, label);
			}
			base.TranslateToILPreSet(il);
			if (thereIsAnObjectOnTheStack)
			{
				Label label2 = il.DefineLabel();
				il.Emit(OpCodes.Br_S, label2);
				il.MarkLabel(label);
				il.Emit(OpCodes.Ldnull);
				il.MarkLabel(label2);
			}
			else
			{
				il.MarkLabel(label);
			}
		}

		internal override void TranslateToILPreSetPlusGet(ILGenerator il)
		{
			if (isFullyResolved)
			{
				base.TranslateToILPreSetPlusGet(il);
				return;
			}
			Label label = il.DefineLabel();
			Label label2 = il.DefineLabel();
			LocalBuilder local = (fieldLoc = il.DeclareLocal(Typeob.FieldInfo));
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
			il.Emit(OpCodes.Castclass, Typeob.IActivationObject);
			il.Emit(OpCodes.Ldstr, name);
			ConstantWrapper.TranslateToILInt(il, lexLevel);
			il.Emit(OpCodes.Callvirt, CompilerGlobals.getFieldMethod);
			il.Emit(OpCodes.Stloc, local);
			il.Emit(OpCodes.Ldloc, local);
			il.Emit(OpCodes.Ldnull);
			il.Emit(OpCodes.Bne_Un_S, label2);
			base.TranslateToILPreSetPlusGet(il);
			il.Emit(OpCodes.Br_S, label);
			il.MarkLabel(label2);
			if (thereIsAnObjectOnTheStack)
			{
				il.Emit(OpCodes.Ldnull);
			}
			il.Emit(OpCodes.Ldloc, fieldLoc);
			il.Emit(OpCodes.Ldnull);
			il.Emit(OpCodes.Callvirt, CompilerGlobals.getFieldValueMethod);
			il.MarkLabel(label);
		}

		internal override void TranslateToILSet(ILGenerator il, AST rhvalue)
		{
			TranslateToILSet(il, doBoth: false, rhvalue);
		}

		internal void TranslateToILSet(ILGenerator il, bool doBoth, AST rhvalue)
		{
			if (isFullyResolved)
			{
				base.TranslateToILSet(il, rhvalue);
				return;
			}
			rhvalue?.TranslateToIL(il, Typeob.Object);
			if (fieldLoc == null)
			{
				il.Emit(OpCodes.Call, CompilerGlobals.setIndexedPropertyValueStaticMethod);
				return;
			}
			LocalBuilder local = il.DeclareLocal(Typeob.Object);
			if (doBoth)
			{
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Stloc, local);
				isFullyResolved = true;
				Convert.Emit(this, il, Typeob.Object, Convert.ToType(InferType(null)));
				base.TranslateToILSet(il, (AST)null);
			}
			Label label = il.DefineLabel();
			il.Emit(OpCodes.Ldloc, fieldLoc);
			il.Emit(OpCodes.Ldnull);
			il.Emit(OpCodes.Beq_S, label);
			Label label2 = il.DefineLabel();
			if (!doBoth)
			{
				il.Emit(OpCodes.Stloc, local);
				if (thereIsAnObjectOnTheStack)
				{
					il.Emit(OpCodes.Pop);
				}
			}
			il.Emit(OpCodes.Ldloc, fieldLoc);
			il.Emit(OpCodes.Ldnull);
			il.Emit(OpCodes.Ldloc, local);
			il.Emit(OpCodes.Callvirt, CompilerGlobals.setFieldValueMethod);
			il.Emit(OpCodes.Br_S, label2);
			il.MarkLabel(label);
			if (!doBoth)
			{
				isFullyResolved = true;
				Convert.Emit(this, il, Typeob.Object, Convert.ToType(InferType(null)));
				base.TranslateToILSet(il, (AST)null);
			}
			il.MarkLabel(label2);
		}

		protected override void TranslateToILWithDupOfThisOb(ILGenerator il)
		{
			TranslateToILDefaultThisObject(il);
			TranslateToIL(il, Typeob.Object);
		}

		internal void TranslateToLateBinding(ILGenerator il)
		{
			thereIsAnObjectOnTheStack = true;
			il.Emit(OpCodes.Ldloc, refLoc);
		}
	}
	/// <summary>Provides constants and static methods for trigonometric functions, logarithmic functions, and other common mathematical functions. This class belongs to the built-in object model category.</summary>
	public class MathObject : JSObject
	{
		/// <summary>Stores a value that represents Euler's constant, which is the base of the natural logarithm, specified by the constant e.</summary>
		public const double E = Math.E;

		/// <summary>Stores a value that represents the logarithm base e of 10, the natural logarithm of 10.</summary>
		public const double LN10 = 2.3025850929940459;

		/// <summary>Stores a value that represents the logarithm base e of 2, the natural logarithm of 2.</summary>
		public const double LN2 = 0.69314718055994529;

		/// <summary>Stores a value that represents the logarithm base 2 of e, the binary logarithm of e.</summary>
		public const double LOG2E = 1.4426950408889634;

		/// <summary>Stores a value that represents the logarithm base 10 of e, the common logarithm of e.</summary>
		public const double LOG10E = 0.43429448190325182;

		/// <summary>Stores a value that represents the ratio of the circumference of a circle to its diameter, specified by the constant π.</summary>
		public const double PI = Math.PI;

		/// <summary>Stores a value that represents the following equivalent values: (√2)/2, √(½), and 1/(√2).</summary>
		public const double SQRT1_2 = 0.70710678118654757;

		/// <summary>Stores a value that represents √2.</summary>
		public const double SQRT2 = 1.4142135623730951;

		private static readonly Random internalRandom = new Random();

		internal static MathObject ob = null;

		internal MathObject(ScriptObject parent)
			: base(parent)
		{
		}

		/// <summary>Calculates the absolute value of the specified number.</summary>
		/// <param name="d">The number to calculate the absolute value of.</param>
		/// <returns>The absolute value of <paramref name="d" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_abs)]
		public static double abs(double d)
		{
			if (d < 0.0)
			{
				return 0.0 - d;
			}
			if (d > 0.0)
			{
				return d;
			}
			if (d == d)
			{
				return 0.0;
			}
			return d;
		}

		/// <summary>Calculates the inverse cosine of the specified number.</summary>
		/// <param name="x">The number to calculate the inverse cosine of.</param>
		/// <returns>The inverse cosine of <paramref name="x" />, measured in radians.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_acos)]
		public static double acos(double x)
		{
			return Math.Acos(x);
		}

		/// <summary>Calculates the inverse sine of the specified number.</summary>
		/// <param name="x">The number to calculate the inverse sine of.</param>
		/// <returns>The inverse sine of <paramref name="x" />, measured in radians.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_asin)]
		public static double asin(double x)
		{
			return Math.Asin(x);
		}

		/// <summary>Calculates the inverse tangent of the specified number.</summary>
		/// <param name="x">The number to calculate the inverse tangent of.</param>
		/// <returns>The inverse tangent of <paramref name="x" />, measured in radians.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_atan)]
		public static double atan(double x)
		{
			return Math.Atan(x);
		}

		/// <summary>Calculates the inverse tangent of the quotient of the specified numbers.</summary>
		/// <param name="dy">The numerator of the quotient to calculate the inverse tangent of.</param>
		/// <param name="dx">The denominator of the quotient to calculate the inverse tangent of.</param>
		/// <returns>The inverse tangent of <paramref name="dy" />/<paramref name="dx" />, measured in radians.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_atan2)]
		public static double atan2(double dy, double dx)
		{
			return Math.Atan2(dy, dx);
		}

		/// <summary>Calculates the ceiling of the specified number, which is the smallest integer that is greater than or equal to the specified number.</summary>
		/// <param name="x">The number to calculate the ceiling of.</param>
		/// <returns>The ceiling of <paramref name="x" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_ceil)]
		public static double ceil(double x)
		{
			return Math.Ceiling(x);
		}

		private static double Compare(double x, double y)
		{
			if (x != 0.0 || y != 0.0)
			{
				if (x == y)
				{
					return 0.0;
				}
				return x - y;
			}
			double num = 1.0 / x;
			double num2 = 1.0 / y;
			if (num < 0.0)
			{
				return (!(num2 < 0.0)) ? (-1) : 0;
			}
			if (num2 < 0.0)
			{
				return 1.0;
			}
			return 0.0;
		}

		/// <summary>Calculates the cosine of the specified angle.</summary>
		/// <param name="x">An angle, measured in radians.</param>
		/// <returns>The cosine of <paramref name="x" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_cos)]
		public static double cos(double x)
		{
			return Math.Cos(x);
		}

		/// <summary>Calculates the number e to the raised specified power, where e is Euler's constant, the base of the natural logarithm.</summary>
		/// <param name="x">The power to raise <c>e</c> to.</param>
		/// <returns>The number e raised to the <paramref name="x" /> power.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_exp)]
		public static double exp(double x)
		{
			return Math.Exp(x);
		}

		/// <summary>Calculates the floor of the specified number, which is the largest integer that is less than or equal to the specified number.</summary>
		/// <param name="x">The number to calculate the floor of.</param>
		/// <returns>The floor of <paramref name="x" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_floor)]
		public static double floor(double x)
		{
			return Math.Floor(x);
		}

		internal override string GetClassName()
		{
			return "Math";
		}

		/// <summary>Calculates the logarithm base e of the specified number, which is the natural logarithm of the specified number.</summary>
		/// <param name="x">The number to calculate the natural logarithm of.</param>
		/// <returns>The natural logarithm of <paramref name="x" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_log)]
		public static double log(double x)
		{
			return Math.Log(x);
		}

		/// <summary>Returns the largest of two or more specified numbers.</summary>
		/// <param name="x">The first number to compare.</param>
		/// <param name="y">The second number to compare.</param>
		/// <param name="args">Additional numbers to compare.</param>
		/// <returns>The largest of <paramref name="x" />, <paramref name="y" />, and the numbers that are contained in <paramref name="args" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs, JSBuiltin.Math_max)]
		public static double max(object x, object y, params object[] args)
		{
			if (x is Missing)
			{
				return double.NegativeInfinity;
			}
			double num = Convert.ToNumber(x);
			if (y is Missing)
			{
				return num;
			}
			double num2 = Convert.ToNumber(y);
			double num3 = Compare(num, num2);
			if (num3 != num3)
			{
				return num3;
			}
			double num4 = num;
			if (num3 < 0.0)
			{
				num4 = num2;
			}
			if (args.Length == 0)
			{
				return num4;
			}
			return maxv(num4, args, 0);
		}

		private static double maxv(double lhMax, object[] args, int start)
		{
			if (args.Length == start)
			{
				return lhMax;
			}
			double num = Convert.ToNumber(args[start]);
			double num2 = Compare(lhMax, num);
			if (num2 != num2)
			{
				return num2;
			}
			if (num2 > 0.0)
			{
				num = lhMax;
			}
			return maxv(num, args, start + 1);
		}

		/// <summary>Returns the smallest of two or more specified numbers.</summary>
		/// <param name="x">The first number to compare.</param>
		/// <param name="y">The second number to compare.</param>
		/// <param name="args">Additional numbers to compare.</param>
		/// <returns>The smallest of <paramref name="x" />, <paramref name="y" />, and the numbers that are contained in <paramref name="args" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs, JSBuiltin.Math_min)]
		public static double min(object x, object y, params object[] args)
		{
			if (x is Missing)
			{
				return double.PositiveInfinity;
			}
			double num = Convert.ToNumber(x);
			if (y is Missing)
			{
				return num;
			}
			double num2 = Convert.ToNumber(y);
			double num3 = Compare(num, num2);
			if (num3 != num3)
			{
				return num3;
			}
			double num4 = num;
			if (num3 > 0.0)
			{
				num4 = num2;
			}
			if (args.Length == 0)
			{
				return num4;
			}
			return minv(num4, args, 0);
		}

		private static double minv(double lhMin, object[] args, int start)
		{
			if (args.Length == start)
			{
				return lhMin;
			}
			double num = Convert.ToNumber(args[start]);
			double num2 = Compare(lhMin, num);
			if (num2 != num2)
			{
				return num2;
			}
			if (num2 < 0.0)
			{
				num = lhMin;
			}
			return minv(num, args, start + 1);
		}

		/// <summary>Calculates the specified number raised to the specified power.</summary>
		/// <param name="dx">The number to raise to the <paramref name="dy" /> power.</param>
		/// <param name="dy">The power to raise <paramref name="dx" /> to.</param>
		/// <returns>The number <paramref name="dx" /> raised to the <paramref name="dy" /> power.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_pow)]
		public static double pow(double dx, double dy)
		{
			if (dy == 0.0)
			{
				return 1.0;
			}
			if ((dx == 1.0 || dx == -1.0) && (dy == double.PositiveInfinity || dy == double.NegativeInfinity))
			{
				return double.NaN;
			}
			if (double.IsNaN(dy))
			{
				return double.NaN;
			}
			if (dx == double.NegativeInfinity && dy < 0.0 && Math.IEEERemainder(0.0 - dy + 1.0, 2.0) == 0.0)
			{
				return -0.0;
			}
			try
			{
				return Math.Pow(dx, dy);
			}
			catch
			{
				if (dx != dx || dy != dy)
				{
					return double.NaN;
				}
				if (dx == 0.0 && dy < 0.0)
				{
					if ((double)(long)dy == dy && (long)(0.0 - dy) % 2 > 0)
					{
						double num = 1.0 / dx;
						if (!(num >= 0.0))
						{
							return double.NegativeInfinity;
						}
					}
					return double.PositiveInfinity;
				}
				return double.NaN;
			}
		}

		/// <summary>Generates a random number between 0 and 1. This method does not generate a cryptographically secure random number.</summary>
		/// <returns>A number that is greater than or equal to 0, and less than 1.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_random)]
		public static double random()
		{
			return internalRandom.NextDouble();
		}

		/// <summary>Rounds the specified number down or up to the nearest integer.</summary>
		/// <param name="d">The number to round.</param>
		/// <returns>If the fractional part of <paramref name="d" /> is less than halfway to the next integer, <paramref name="d" /> rounded down. If the fractional part of <paramref name="d" /> is halfway or more to the next integer, <paramref name="d" /> rounded up.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_round)]
		public static double round(double d)
		{
			if (d == 0.0)
			{
				return d;
			}
			return Math.Floor(d + 0.5);
		}

		/// <summary>Calculates the sine of the specified angle.</summary>
		/// <param name="x">An angle, measured in radians.</param>
		/// <returns>The sine of <paramref name="x" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_sin)]
		public static double sin(double x)
		{
			return Math.Sin(x);
		}

		/// <summary>Calculates the square root of the specified number.</summary>
		/// <param name="x">The number to calculate the square root of.</param>
		/// <returns>The square root of <paramref name="x" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_sqrt)]
		public static double sqrt(double x)
		{
			return Math.Sqrt(x);
		}

		/// <summary>Calculates the tangent of the specified angle.</summary>
		/// <param name="x">An angle, measured in radians.</param>
		/// <returns>The tangent of <paramref name="x" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.None, JSBuiltin.Math_tan)]
		public static double tan(double x)
		{
			return Math.Tan(x);
		}
	}
	internal sealed class Member : Binding
	{
		private bool fast;

		private bool isImplicitWrapper;

		private LateBinding lateBinding;

		private Context memberNameContext;

		internal AST rootObject;

		private IReflect rootObjectInferredType;

		private LocalBuilder refLoc;

		private LocalBuilder temp;

		internal Member(Context context, AST rootObject, AST memberName)
			: base(context, memberName.context.GetCode())
		{
			fast = base.Engine.doFast;
			isImplicitWrapper = false;
			isNonVirtual = rootObject is ThisLiteral && ((ThisLiteral)rootObject).isSuper;
			lateBinding = null;
			memberNameContext = memberName.context;
			this.rootObject = rootObject;
			rootObjectInferredType = null;
			refLoc = null;
			temp = null;
		}

		private void BindName(JSField inferenceTarget)
		{
			MemberInfo[] array = null;
			rootObject = rootObject.PartiallyEvaluate();
			IReflect obType = (rootObjectInferredType = rootObject.InferType(inferenceTarget));
			if (rootObject is ConstantWrapper)
			{
				object obj = Convert.ToObject2(rootObject.Evaluate(), base.Engine);
				if (obj == null)
				{
					rootObject.context.HandleError(JSError.ObjectExpected);
					return;
				}
				ClassScope classScope = obj as ClassScope;
				Type type = obj as Type;
				if (classScope != null || type != null)
				{
					array = ((classScope != null) ? (members = classScope.GetMember(name, BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)) : (members = type.GetMember(name, BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)));
					if (array.Length == 0)
					{
						array = (members = Typeob.Type.GetMember(name, BindingFlags.Instance | BindingFlags.Public));
					}
					return;
				}
				if (obj is Namespace @namespace)
				{
					string text = @namespace.Name + "." + name;
					classScope = base.Engine.GetClass(text);
					if (classScope != null)
					{
						FieldAttributes fieldAttributes = FieldAttributes.Literal;
						if ((classScope.owner.attributes & TypeAttributes.Public) == 0)
						{
							fieldAttributes |= FieldAttributes.Private;
						}
						members = new MemberInfo[1]
						{
							new JSGlobalField(null, name, classScope, fieldAttributes)
						};
						return;
					}
					type = base.Engine.GetType(text);
					if (type != null)
					{
						members = new MemberInfo[1] { type };
						return;
					}
				}
				else if (obj is MathObject || (obj is ScriptFunction && !(obj is FunctionObject)))
				{
					obType = (IReflect)obj;
				}
			}
			obType = ProvideWrapperForPrototypeProperties(obType);
			if (obType == Typeob.Object && !isNonVirtual)
			{
				members = new MemberInfo[0];
				return;
			}
			Type type2 = obType as Type;
			if (type2 != null && type2.IsInterface)
			{
				members = JSBinder.GetInterfaceMembers(name, type2);
				return;
			}
			if (obType is ClassScope classScope2 && classScope2.owner.isInterface)
			{
				members = classScope2.owner.GetInterfaceMember(name);
				return;
			}
			while (obType != null)
			{
				if (obType is ClassScope classScope3)
				{
					if ((members = obType.GetMember(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy)).Length != 0)
					{
						break;
					}
					obType = classScope3.GetSuperType();
					continue;
				}
				type2 = obType as Type;
				if (type2 == null)
				{
					members = obType.GetMember(name, BindingFlags.Instance | BindingFlags.Public);
					break;
				}
				array = (members = type2.GetMember(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
				if (array.Length != 0)
				{
					MemberInfo memberInfo = LateBinding.SelectMember(array);
					if (memberInfo == null && (members = type2.GetMember(name, MemberTypes.Method, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)).Length == 0)
					{
						members = type2.GetMember(name, MemberTypes.Property, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
					}
					break;
				}
				obType = type2.BaseType;
			}
		}

		internal override object Evaluate()
		{
			object obj = base.Evaluate();
			if (obj is Missing)
			{
				obj = null;
			}
			return obj;
		}

		internal override LateBinding EvaluateAsLateBinding()
		{
			LateBinding lateBinding = this.lateBinding;
			if (lateBinding == null)
			{
				if (member != null && !rootObjectInferredType.Equals(rootObject.InferType(null)))
				{
					InvalidateBinding();
				}
				lateBinding = (this.lateBinding = new LateBinding(name, null, VsaEngine.executeForJSEE));
				lateBinding.last_member = member;
			}
			object value = rootObject.Evaluate();
			try
			{
				value = (lateBinding.obj = Convert.ToObject(value, base.Engine));
				if (defaultMember == null)
				{
					if (member != null)
					{
						lateBinding.last_object = value;
						return lateBinding;
					}
					return lateBinding;
				}
				return lateBinding;
			}
			catch (JScriptException ex)
			{
				if (ex.context == null)
				{
					ex.context = rootObject.context;
				}
				throw ex;
			}
		}

		internal object EvaluateAsType()
		{
			WrappedNamespace wrappedNamespace = rootObject.EvaluateAsWrappedNamespace(giveErrorIfNameInUse: false);
			object memberValue = wrappedNamespace.GetMemberValue(name);
			if (memberValue != null && !(memberValue is Missing))
			{
				return memberValue;
			}
			object obj = null;
			if (!(rootObject is Member member))
			{
				if (!(rootObject is Lookup lookup))
				{
					return null;
				}
				obj = lookup.PartiallyEvaluate();
				if (obj is ConstantWrapper constantWrapper)
				{
					obj = constantWrapper.value;
				}
				else
				{
					JSGlobalField jSGlobalField = lookup.member as JSGlobalField;
					if (!(jSGlobalField != null) || !jSGlobalField.IsLiteral)
					{
						return null;
					}
					obj = jSGlobalField.value;
				}
			}
			else
			{
				obj = member.EvaluateAsType();
			}
			if (obj is ClassScope classScope)
			{
				MemberInfo[] array = classScope.GetMember(name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
				if (array.Length == 0)
				{
					return null;
				}
				JSMemberField jSMemberField = array[0] as JSMemberField;
				if (jSMemberField == null || !jSMemberField.IsLiteral || !(jSMemberField.value is ClassScope) || (!jSMemberField.IsPublic && !jSMemberField.IsAccessibleFrom(base.Engine.ScriptObjectStackTop())))
				{
					return null;
				}
				return jSMemberField.value;
			}
			Type type = obj as Type;
			if (type != null)
			{
				return type.GetNestedType(name);
			}
			return null;
		}

		internal override WrappedNamespace EvaluateAsWrappedNamespace(bool giveErrorIfNameInUse)
		{
			WrappedNamespace wrappedNamespace = rootObject.EvaluateAsWrappedNamespace(giveErrorIfNameInUse);
			string text = name;
			wrappedNamespace.AddFieldOrUseExistingField(text, Namespace.GetNamespace(wrappedNamespace.ToString() + "." + text, base.Engine), FieldAttributes.Literal);
			return new WrappedNamespace(wrappedNamespace.ToString() + "." + text, base.Engine);
		}

		protected override object GetObject()
		{
			return Convert.ToObject(rootObject.Evaluate(), base.Engine);
		}

		protected override void HandleNoSuchMemberError()
		{
			IReflect reflect = rootObject.InferType(null);
			object obj = null;
			if (rootObject is ConstantWrapper)
			{
				obj = rootObject.Evaluate();
			}
			if ((reflect == Typeob.Object && !isNonVirtual) || (reflect is JSObject && !((JSObject)reflect).noExpando) || (reflect is GlobalScope && !((GlobalScope)reflect).isKnownAtCompileTime))
			{
				return;
			}
			if (reflect is Type)
			{
				Type type = (Type)reflect;
				if (Typeob.ScriptFunction.IsAssignableFrom(type) || type == Typeob.MathObject)
				{
					memberNameContext.HandleError(JSError.OLENoPropOrMethod);
					return;
				}
				if (Typeob.IExpando.IsAssignableFrom(type) || (!fast && (type == Typeob.Boolean || type == Typeob.String || Convert.IsPrimitiveNumericType(type))))
				{
					return;
				}
				if (obj is ClassScope)
				{
					MemberInfo[] array = ((ClassScope)obj).GetMember(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
					if (array.Length != 0)
					{
						memberNameContext.HandleError(JSError.NonStaticWithTypeName);
						return;
					}
				}
			}
			if (obj is FunctionObject)
			{
				rootObject = new ConstantWrapper(((FunctionObject)obj).name, rootObject.context);
				memberNameContext.HandleError(JSError.OLENoPropOrMethod);
				return;
			}
			if (reflect is ClassScope)
			{
				MemberInfo[] array2 = ((ClassScope)reflect).GetMember(name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
				if (array2.Length != 0)
				{
					memberNameContext.HandleError(JSError.StaticRequiresTypeName);
					return;
				}
			}
			if (obj is Type)
			{
				memberNameContext.HandleError(JSError.NoSuchStaticMember, Convert.ToTypeName((Type)obj));
			}
			else if (obj is ClassScope)
			{
				memberNameContext.HandleError(JSError.NoSuchStaticMember, Convert.ToTypeName((ClassScope)obj));
			}
			else if (obj is Namespace)
			{
				memberNameContext.HandleError(JSError.NoSuchType, ((Namespace)obj).Name + "." + name);
			}
			else if (reflect != FunctionPrototype.ob || !(rootObject is Binding) || !(((Binding)rootObject).member is JSVariableField) || !(((JSVariableField)((Binding)rootObject).member).value is FunctionObject))
			{
				memberNameContext.HandleError(JSError.NoSuchMember, Convert.ToTypeName(reflect));
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			if (members == null)
			{
				BindName(inference_target);
			}
			else if (!rootObjectInferredType.Equals(rootObject.InferType(inference_target)))
			{
				InvalidateBinding();
			}
			return base.InferType((JSField)null);
		}

		internal override IReflect InferTypeOfCall(JSField inference_target, bool isConstructor)
		{
			if (!rootObjectInferredType.Equals(rootObject.InferType(inference_target)))
			{
				InvalidateBinding();
			}
			return base.InferTypeOfCall(null, isConstructor);
		}

		internal override AST PartiallyEvaluate()
		{
			BindName(null);
			if (members == null || members.Length == 0)
			{
				if (rootObject is ConstantWrapper)
				{
					object obj = rootObject.Evaluate();
					if (obj is Namespace)
					{
						return new ConstantWrapper(Namespace.GetNamespace(((Namespace)obj).Name + "." + name, base.Engine), context);
					}
				}
				HandleNoSuchMemberError();
				return this;
			}
			ResolveRHValue();
			if (member is FieldInfo && ((FieldInfo)member).IsLiteral)
			{
				object obj2 = ((member is JSVariableField) ? ((JSVariableField)member).value : TypeReferences.GetConstantValue((FieldInfo)member));
				if (obj2 is AST)
				{
					AST aST = ((AST)obj2).PartiallyEvaluate();
					if (aST is ConstantWrapper)
					{
						return aST;
					}
					obj2 = null;
				}
				if (!(obj2 is FunctionObject) && (!(obj2 is ClassScope) || ((ClassScope)obj2).owner.IsStatic))
				{
					return new ConstantWrapper(obj2, context);
				}
			}
			else if (member is Type)
			{
				return new ConstantWrapper(member, context);
			}
			return this;
		}

		internal override AST PartiallyEvaluateAsCallable()
		{
			BindName(null);
			return this;
		}

		internal override AST PartiallyEvaluateAsReference()
		{
			BindName(null);
			if (members == null || members.Length == 0)
			{
				if (isImplicitWrapper && !Convert.IsArray(rootObjectInferredType))
				{
					context.HandleError(JSError.UselessAssignment);
				}
				else
				{
					HandleNoSuchMemberError();
				}
				return this;
			}
			ResolveLHValue();
			if (isImplicitWrapper && (member == null || (!(member is JSField) && Typeob.JSObject.IsAssignableFrom(member.DeclaringType))))
			{
				context.HandleError(JSError.UselessAssignment);
			}
			return this;
		}

		private IReflect ProvideWrapperForPrototypeProperties(IReflect obType)
		{
			if (obType == Typeob.String)
			{
				obType = base.Globals.globalObject.originalString.Construct();
				((JSObject)obType).noExpando = fast;
				isImplicitWrapper = true;
			}
			else if ((obType is Type && Typeob.Array.IsAssignableFrom((Type)obType)) || obType is TypedArray)
			{
				obType = base.Globals.globalObject.originalArray.ConstructWrapper();
				((JSObject)obType).noExpando = fast;
				isImplicitWrapper = true;
			}
			else if (obType == Typeob.Boolean)
			{
				obType = base.Globals.globalObject.originalBoolean.Construct();
				((JSObject)obType).noExpando = fast;
				isImplicitWrapper = true;
			}
			else if (Convert.IsPrimitiveNumericType(obType))
			{
				Type baseType = (Type)obType;
				obType = base.Globals.globalObject.originalNumber.Construct();
				((JSObject)obType).noExpando = fast;
				((NumberObject)obType).baseType = baseType;
				isImplicitWrapper = true;
			}
			else if (obType is Type)
			{
				obType = Convert.ToIReflect((Type)obType, base.Engine);
			}
			return obType;
		}

		internal override object ResolveCustomAttribute(ASTList args, IReflect[] argIRs, AST target)
		{
			name += "Attribute";
			BindName(null);
			if (members == null || members.Length == 0)
			{
				name = name.Substring(0, name.Length - 9);
				BindName(null);
			}
			return base.ResolveCustomAttribute(args, argIRs, target);
		}

		public override string ToString()
		{
			return rootObject.ToString() + "." + name;
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			rootObject.TranslateToILInitializer(il);
			if (!rootObjectInferredType.Equals(rootObject.InferType(null)))
			{
				InvalidateBinding();
			}
			if (defaultMember != null)
			{
				return;
			}
			if (member != null)
			{
				switch (member.MemberType)
				{
				case MemberTypes.Constructor:
				case MemberTypes.Method:
				case MemberTypes.Property:
				case MemberTypes.TypeInfo:
				case MemberTypes.NestedType:
					return;
				case MemberTypes.Field:
					if (member is JSExpandoField)
					{
						member = null;
						break;
					}
					return;
				}
			}
			refLoc = il.DeclareLocal(Typeob.LateBinding);
			il.Emit(OpCodes.Ldstr, name);
			il.Emit(OpCodes.Newobj, CompilerGlobals.lateBindingConstructor);
			il.Emit(OpCodes.Stloc, refLoc);
		}

		protected override void TranslateToILObject(ILGenerator il, Type obType, bool noValue)
		{
			if (noValue && obType.IsValueType && obType != Typeob.Enum)
			{
				if (temp == null)
				{
					rootObject.TranslateToILReference(il, obType);
					return;
				}
				Type type = Convert.ToType(rootObject.InferType(null));
				if (type == obType)
				{
					il.Emit(OpCodes.Ldloca, temp);
					return;
				}
				il.Emit(OpCodes.Ldloc, temp);
				Convert.Emit(this, il, type, obType);
				Convert.EmitLdloca(il, obType);
			}
			else if (temp == null || rootObject is ThisLiteral)
			{
				rootObject.TranslateToIL(il, obType);
			}
			else
			{
				il.Emit(OpCodes.Ldloc, temp);
				Type source_type = Convert.ToType(rootObject.InferType(null));
				Convert.Emit(this, il, source_type, obType);
			}
		}

		protected override void TranslateToILWithDupOfThisOb(ILGenerator il)
		{
			IReflect reflect = rootObject.InferType(null);
			Type type = Convert.ToType(reflect);
			rootObject.TranslateToIL(il, type);
			if (reflect == Typeob.Object || reflect == Typeob.String || reflect is TypedArray || (reflect is Type && (Type)reflect == type && Typeob.Array.IsAssignableFrom(type)))
			{
				type = Typeob.Object;
				EmitILToLoadEngine(il);
				il.Emit(OpCodes.Call, CompilerGlobals.toObjectMethod);
			}
			il.Emit(OpCodes.Dup);
			temp = il.DeclareLocal(type);
			il.Emit(OpCodes.Stloc, temp);
			Convert.Emit(this, il, type, Typeob.Object);
			TranslateToIL(il, Typeob.Object);
		}

		internal void TranslateToLateBinding(ILGenerator il, bool speculativeEarlyBindingsExist)
		{
			if (speculativeEarlyBindingsExist)
			{
				LocalBuilder local = il.DeclareLocal(Typeob.Object);
				il.Emit(OpCodes.Stloc, local);
				il.Emit(OpCodes.Ldloc, refLoc);
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Ldloc, local);
			}
			else
			{
				il.Emit(OpCodes.Ldloc, refLoc);
				il.Emit(OpCodes.Dup);
				TranslateToILObject(il, Typeob.Object, noValue: false);
			}
			IReflect reflect = rootObject.InferType(null);
			if (reflect == Typeob.Object || reflect == Typeob.String || reflect is TypedArray || (reflect is Type && ((Type)reflect).IsPrimitive) || (reflect is Type && Typeob.Array.IsAssignableFrom((Type)reflect)))
			{
				EmitILToLoadEngine(il);
				il.Emit(OpCodes.Call, CompilerGlobals.toObjectMethod);
			}
			il.Emit(OpCodes.Stfld, CompilerGlobals.objectField);
		}
	}
	/// <summary>Maintains a list of <see cref="T:System.Reflection.MemberInfo" /> elements.</summary>
	public sealed class MemberInfoList
	{
		internal int count;

		private MemberInfo[] list;

		internal MemberInfo this[int i]
		{
			get
			{
				return list[i];
			}
			set
			{
				list[i] = value;
			}
		}

		internal MemberInfoList()
		{
			count = 0;
			list = new MemberInfo[16];
		}

		internal void Add(MemberInfo elem)
		{
			int num = count++;
			if (list.Length == num)
			{
				Grow();
			}
			list[num] = elem;
		}

		internal void AddRange(MemberInfo[] elems)
		{
			foreach (MemberInfo elem in elems)
			{
				Add(elem);
			}
		}

		private void Grow()
		{
			MemberInfo[] array = list;
			int num = array.Length;
			MemberInfo[] array2 = (list = new MemberInfo[num + 16]);
			for (int i = 0; i < num; i++)
			{
				array2[i] = array[i];
			}
		}

		internal MemberInfo[] ToArray()
		{
			int num = count;
			MemberInfo[] array = new MemberInfo[num];
			MemberInfo[] array2 = list;
			for (int i = 0; i < num; i++)
			{
				array[i] = array2[i];
			}
			return array;
		}
	}
	/// <summary>Represents the invoker for a particular method. Used by the <see cref="T:Microsoft.JScript.JSMethodInfo" /> class to invoke methods.</summary>
	public abstract class MethodInvoker
	{
		private static SimpleHashtable invokerFor = new SimpleHashtable(64u);

		private static int count = 0;

		/// <summary>When overridden in a derived class, invokes the method.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="parameters">The arguments to use for the method.</param>
		/// <returns>The result of invoking the method.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public abstract object Invoke(object thisob, object[] parameters);

		private static bool DoesCallerRequireFullTrust(MethodInfo method)
		{
			Assembly assembly = method.DeclaringType.Assembly;
			FileIOPermission fileIOPermission = new FileIOPermission(PermissionState.None);
			fileIOPermission.AllFiles = FileIOPermissionAccess.PathDiscovery;
			fileIOPermission.Assert();
			byte[] publicKey = assembly.GetName().GetPublicKey();
			if (publicKey == null || publicKey.Length == 0)
			{
				return false;
			}
			if (CustomAttribute.GetCustomAttributes(assembly, typeof(AllowPartiallyTrustedCallersAttribute), inherit: true).Length != 0)
			{
				return false;
			}
			return true;
		}

		internal static MethodInvoker GetInvokerFor(MethodInfo method)
		{
			if (method.DeclaringType == typeof(CodeAccessPermission) && (method.Name == "Deny" || method.Name == "Assert" || method.Name == "PermitOnly"))
			{
				throw new JScriptException(JSError.CannotCallSecurityMethodLateBound);
			}
			if (invokerFor[method] is MethodInvoker result)
			{
				return result;
			}
			if (!SafeToCall(method))
			{
				return null;
			}
			bool requiresDemand = DoesCallerRequireFullTrust(method);
			lock (invokerFor)
			{
				if (invokerFor[method] is MethodInvoker result2)
				{
					return result2;
				}
				MethodInvoker methodInvoker = SpitAndInstantiateClassFor(method, requiresDemand);
				invokerFor[method] = methodInvoker;
				return methodInvoker;
			}
		}

		private static bool SafeToCall(MethodInfo meth)
		{
			Type declaringType = meth.DeclaringType;
			if (declaringType != null && declaringType != typeof(Activator) && declaringType != typeof(AppDomain) && declaringType != typeof(IsolatedStorageFile) && declaringType != typeof(MethodRental) && declaringType != typeof(TypeLibConverter) && declaringType != typeof(SecurityManager) && !typeof(Assembly).IsAssignableFrom(declaringType) && !typeof(MemberInfo).IsAssignableFrom(declaringType) && !typeof(ResourceManager).IsAssignableFrom(declaringType) && !typeof(Delegate).IsAssignableFrom(declaringType) && (declaringType.Attributes & TypeAttributes.HasSecurity) == 0 && (meth.Attributes & MethodAttributes.HasSecurity) == 0)
			{
				return (meth.Attributes & MethodAttributes.PinvokeImpl) == 0;
			}
			return false;
		}

		[ReflectionPermission(SecurityAction.Assert, Unrestricted = true)]
		private static MethodInvoker SpitAndInstantiateClassFor(MethodInfo method, bool requiresDemand)
		{
			TypeBuilder typeBuilder = Runtime.ThunkModuleBuilder.DefineType("invoker" + count++, TypeAttributes.Public, typeof(MethodInvoker));
			MethodBuilder methodBuilder = typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Virtual, typeof(object), new Type[2]
			{
				typeof(object),
				typeof(object[])
			});
			if (requiresDemand)
			{
				methodBuilder.AddDeclarativeSecurity(SecurityAction.Demand, new NamedPermissionSet("FullTrust"));
			}
			methodBuilder.SetCustomAttribute(new CustomAttributeBuilder(Runtime.TypeRefs.debuggerStepThroughAttributeCtor, new object[0]));
			methodBuilder.SetCustomAttribute(new CustomAttributeBuilder(Runtime.TypeRefs.debuggerHiddenAttributeCtor, new object[0]));
			ILGenerator iLGenerator = methodBuilder.GetILGenerator();
			if (!method.DeclaringType.IsPublic)
			{
				method = method.GetBaseDefinition();
			}
			Type declaringType = method.DeclaringType;
			if (!method.IsStatic)
			{
				iLGenerator.Emit(OpCodes.Ldarg_1);
				if (declaringType.IsValueType)
				{
					Convert.EmitUnbox(iLGenerator, declaringType, Type.GetTypeCode(declaringType));
					Convert.EmitLdloca(iLGenerator, declaringType);
				}
				else
				{
					iLGenerator.Emit(OpCodes.Castclass, declaringType);
				}
			}
			ParameterInfo[] parameters = method.GetParameters();
			LocalBuilder[] array = null;
			int i = 0;
			for (int num = parameters.Length; i < num; i++)
			{
				iLGenerator.Emit(OpCodes.Ldarg_2);
				ConstantWrapper.TranslateToILInt(iLGenerator, i);
				Type parameterType = parameters[i].ParameterType;
				if (parameterType.IsByRef)
				{
					parameterType = parameterType.GetElementType();
					if (array == null)
					{
						array = new LocalBuilder[num];
					}
					array[i] = iLGenerator.DeclareLocal(parameterType);
					iLGenerator.Emit(OpCodes.Ldelem_Ref);
					if (parameterType.IsValueType)
					{
						Convert.EmitUnbox(iLGenerator, parameterType, Type.GetTypeCode(parameterType));
					}
					iLGenerator.Emit(OpCodes.Stloc, array[i]);
					iLGenerator.Emit(OpCodes.Ldloca, array[i]);
				}
				else
				{
					iLGenerator.Emit(OpCodes.Ldelem_Ref);
					if (parameterType.IsValueType)
					{
						Convert.EmitUnbox(iLGenerator, parameterType, Type.GetTypeCode(parameterType));
					}
				}
			}
			if (!method.IsStatic && method.IsVirtual && !method.IsFinal && (!declaringType.IsSealed || !declaringType.IsValueType))
			{
				iLGenerator.Emit(OpCodes.Callvirt, method);
			}
			else
			{
				iLGenerator.Emit(OpCodes.Call, method);
			}
			Type returnType = method.ReturnType;
			if (returnType == typeof(void))
			{
				iLGenerator.Emit(OpCodes.Ldnull);
			}
			else if (returnType.IsValueType)
			{
				iLGenerator.Emit(OpCodes.Box, returnType);
			}
			if (array != null)
			{
				int j = 0;
				for (int num2 = parameters.Length; j < num2; j++)
				{
					LocalBuilder localBuilder = array[j];
					if (localBuilder != null)
					{
						iLGenerator.Emit(OpCodes.Ldarg_2);
						ConstantWrapper.TranslateToILInt(iLGenerator, j);
						iLGenerator.Emit(OpCodes.Ldloc, localBuilder);
						Type elementType = parameters[j].ParameterType.GetElementType();
						if (elementType.IsValueType)
						{
							iLGenerator.Emit(OpCodes.Box, elementType);
						}
						iLGenerator.Emit(OpCodes.Stelem_Ref);
					}
				}
			}
			iLGenerator.Emit(OpCodes.Ret);
			Type type = typeBuilder.CreateType();
			return (MethodInvoker)Activator.CreateInstance(type);
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.MethodInvoker" /> class.</summary>
		protected MethodInvoker()
		{
		}
	}
	/// <summary>Represents the value of a variable that has been instantiated but that has not yet had its value set.</summary>
	public sealed class Missing
	{
		/// <summary>Specifies the value of a variable that has been instantiated but that has not yet had its value set.</summary>
		public static readonly Missing Value = new Missing();

		private Missing()
		{
		}
	}
	/// <summary>Represents a namespace.</summary>
	public sealed class Namespace
	{
		private string name;

		internal VsaEngine engine;

		internal string Name => name;

		private Namespace(string name, VsaEngine engine)
		{
			this.name = name;
			this.engine = engine;
		}

		/// <summary>Creates and returns a new instance of the <see cref="T:Microsoft.JScript.Namespace" /> class.</summary>
		/// <param name="name">The name of the namespace.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>A new instance of the <see cref="T:Microsoft.JScript.Namespace" /> class.</returns>
		public static Namespace GetNamespace(string name, VsaEngine engine)
		{
			return new Namespace(name, engine);
		}

		internal Type GetType(string typeName)
		{
			return engine.GetType(typeName);
		}
	}
	/// <summary>Indicates that a method or field is not recommended.</summary>
	[AttributeUsage(AttributeTargets.Method | AttributeTargets.Field)]
	public class NotRecommended : Attribute
	{
		private string message;

		/// <summary>Gets a value that indicates whether using a method or field that is not recommended is an error.</summary>
		/// <returns>
		///   <see langword="false" /> in all cases.</returns>
		public bool IsError => false;

		/// <summary>Gets the name of the method or field that is not recommended.</summary>
		/// <returns>The name of the method or field that is not recommended.</returns>
		public string Message => JScriptException.Localize(message, null);

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.NotRecommended" /> attribute class.</summary>
		/// <param name="message">The name of the method or field that is not recommended.</param>
		public NotRecommended(string message)
		{
			this.message = message;
		}
	}
	internal sealed class NullLiteral : ConstantWrapper
	{
		internal NullLiteral(Context context)
			: base(DBNull.Value, context)
		{
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public class NumberConstructor : ScriptFunction
	{
		/// <summary>Represents the largest possible value of a <see cref="T:System.Double" />. This field is constant.</summary>
		public const double MAX_VALUE = double.MaxValue;

		/// <summary>Represents the smallest positive <see cref="T:System.Double" /> value that is greater than zero. This field is constant.</summary>
		public const double MIN_VALUE = double.Epsilon;

		/// <summary>Represents a value that is not a number (NaN). This field is constant.</summary>
		public const double NaN = double.NaN;

		/// <summary>Represents negative infinity. This field is constant.</summary>
		public const double NEGATIVE_INFINITY = double.NegativeInfinity;

		/// <summary>Represents positive infinity. This field is constant.</summary>
		public const double POSITIVE_INFINITY = double.PositiveInfinity;

		internal static readonly NumberConstructor ob = new NumberConstructor();

		private NumberPrototype originalPrototype;

		internal NumberConstructor()
			: base(FunctionPrototype.ob, "Number", 1)
		{
			originalPrototype = NumberPrototype.ob;
			NumberPrototype._constructor = this;
			proto = NumberPrototype.ob;
		}

		internal NumberConstructor(LenientFunctionPrototype parent, LenientNumberPrototype prototypeProp)
			: base(parent, "Number", 1)
		{
			originalPrototype = prototypeProp;
			prototypeProp.constructor = this;
			proto = prototypeProp;
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			if (args.Length == 0)
			{
				return 0;
			}
			return Convert.ToNumber(args[0]);
		}

		internal NumberObject Construct()
		{
			return new NumberObject(originalPrototype, 0.0, implicitWrapper: false);
		}

		internal override object Construct(object[] args)
		{
			return CreateInstance(args);
		}

		internal NumberObject ConstructImplicitWrapper(object arg)
		{
			return new NumberObject(originalPrototype, arg, implicitWrapper: true);
		}

		internal NumberObject ConstructWrapper(object arg)
		{
			return new NumberObject(originalPrototype, arg, implicitWrapper: false);
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>An instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new NumberObject CreateInstance(params object[] args)
		{
			if (args.Length == 0)
			{
				return new NumberObject(originalPrototype, 0.0, implicitWrapper: false);
			}
			return new NumberObject(originalPrototype, Convert.ToNumber(args[0]), implicitWrapper: false);
		}

		/// <summary>Converts the specified object to a number.</summary>
		/// <param name="arg">The object to convert.</param>
		/// <returns>
		///   <paramref name="arg" /> expressed as a number, if that is possible.</returns>
		public double Invoke(object arg)
		{
			return Convert.ToNumber(arg);
		}
	}
	/// <summary>Represents a number object. This class belongs to the built-in object model category.</summary>
	public class NumberObject : JSObject
	{
		internal Type baseType;

		internal object value;

		private bool implicitWrapper;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.NumberObject" /> class.</summary>
		/// <param name="parent">The parent of the object.</param>
		/// <param name="value">The underlying value that the class represents.</param>
		protected NumberObject(ScriptObject parent, object value)
			: base(parent)
		{
			baseType = Globals.TypeRefs.ToReferenceContext(value.GetType());
			this.value = value;
			noExpando = false;
			implicitWrapper = false;
		}

		internal NumberObject(ScriptObject parent, object value, bool implicitWrapper)
			: base(parent, typeof(NumberObject))
		{
			baseType = Globals.TypeRefs.ToReferenceContext(value.GetType());
			this.value = value;
			noExpando = implicitWrapper;
			this.implicitWrapper = implicitWrapper;
		}

		internal NumberObject(ScriptObject parent, Type baseType)
			: base(parent)
		{
			this.baseType = baseType;
			value = 0.0;
			noExpando = false;
		}

		internal override object GetDefaultValue(PreferredType preferred_type)
		{
			if (GetParent() is LenientNumberPrototype)
			{
				return base.GetDefaultValue(preferred_type);
			}
			switch (preferred_type)
			{
			case PreferredType.String:
				if (!noExpando)
				{
					object obj2 = base.NameTable["toString"];
					if (obj2 != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return Convert.ToString(value);
			case PreferredType.LocaleString:
				return base.GetDefaultValue(preferred_type);
			default:
				if (!noExpando)
				{
					object obj = base.NameTable["valueOf"];
					if (obj == null && preferred_type == PreferredType.Either)
					{
						obj = base.NameTable["toString"];
					}
					if (obj != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return value;
			}
		}

		internal override string GetClassName()
		{
			return "Number";
		}

		/// <summary>Returns the type of the underlying value object, or returns <see cref="T:Microsoft.JScript.NumberObject" />.</summary>
		/// <returns>The type of the underlying value object, or <see cref="T:Microsoft.JScript.NumberObject" />.</returns>
		public new Type GetType()
		{
			if (!implicitWrapper)
			{
				return Typeob.NumberObject;
			}
			return baseType;
		}
	}
	/// <summary>Provides static methods and properties for <see cref="T:Microsoft.JScript.NumberObject" /> objects. All methods of this class are called by passing in a reference to the object that is requesting access to the method. This class belongs to the built-in object model category.</summary>
	public class NumberPrototype : NumberObject
	{
		internal static readonly NumberPrototype ob = new NumberPrototype(ObjectPrototype.ob);

		internal static NumberConstructor _constructor;

		/// <summary>Gets a reference to a prototype-based object that is using this prototype.</summary>
		/// <returns>A reference to a prototype-based object.</returns>
		public static NumberConstructor constructor => _constructor;

		internal NumberPrototype(ObjectPrototype parent)
			: base(parent, 0.0)
		{
			noExpando = true;
		}

		private static double ThisobToDouble(object thisob)
		{
			thisob = valueOf(thisob);
			return ((IConvertible)thisob).ToDouble(null);
		}

		/// <summary>Creates a string representation of the specified <see cref="T:Microsoft.JScript.NumberObject" /> that uses scientific (E) notation.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="fractionDigits">A number between 0 and 20 that represents the number of decimal places to display. The default is 16.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Number_toExponential)]
		public static string toExponential(object thisob, object fractionDigits)
		{
			double num = ThisobToDouble(thisob);
			double num2 = ((fractionDigits != null && !(fractionDigits is Missing)) ? Convert.ToInteger(fractionDigits) : 16.0);
			if (num2 < 0.0 || num2 > 20.0)
			{
				throw new JScriptException(JSError.FractionOutOfRange);
			}
			StringBuilder stringBuilder = new StringBuilder("#.");
			for (int i = 0; (double)i < num2; i++)
			{
				stringBuilder.Append('0');
			}
			stringBuilder.Append("e+0");
			return num.ToString(stringBuilder.ToString(), CultureInfo.InvariantCulture);
		}

		/// <summary>Creates a string representation of the specified <see cref="T:Microsoft.JScript.NumberObject" /> that displays the specified number of decimal digits.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="fractionDigits">A number between 0 and 20 that represents the number of decimal places to display. The default is 0.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Number_toFixed)]
		public static string toFixed(object thisob, double fractionDigits)
		{
			double num = ThisobToDouble(thisob);
			if (double.IsNaN(fractionDigits))
			{
				fractionDigits = 0.0;
			}
			else if (fractionDigits < 0.0 || fractionDigits > 20.0)
			{
				throw new JScriptException(JSError.FractionOutOfRange);
			}
			return num.ToString("f" + ((int)fractionDigits).ToString(CultureInfo.InvariantCulture), CultureInfo.InvariantCulture);
		}

		/// <summary>Creates a string representation of the specified object that is based on <see cref="P:System.Globalization.NumberFormatInfo.CurrentInfo" /> and <see cref="T:System.Globalization.CultureInfo" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Number_toLocaleString)]
		public static string toLocaleString(object thisob)
		{
			return Convert.ToString(valueOf(thisob), PreferredType.LocaleString, explicitOK: true);
		}

		/// <summary>Creates a string representation of the specified <see cref="T:Microsoft.JScript.NumberObject" /> that displays the specified number of precision digits.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="precision">A number between 0 and 21 that represents the number of precision digits to display. <c>Precision digits</c> are the digits of the decimal and the exponent combined.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Number_toPrecision)]
		public static string toPrecision(object thisob, object precision)
		{
			double num = ThisobToDouble(thisob);
			if (precision == null || precision is Missing)
			{
				return Convert.ToString(num);
			}
			double num2 = Convert.ToInteger(precision);
			if (num2 < 1.0 || num2 > 21.0)
			{
				throw new JScriptException(JSError.PrecisionOutOfRange);
			}
			int num3 = (int)num2;
			if (double.IsNaN(num))
			{
				return "NaN";
			}
			if (double.IsInfinity(num))
			{
				if (!(num > 0.0))
				{
					return "-Infinity";
				}
				return "Infinity";
			}
			string text;
			if (num >= 0.0)
			{
				text = "";
			}
			else
			{
				text = "-";
				num = 0.0 - num;
			}
			string text2 = num.ToString("e" + (num3 - 1).ToString(CultureInfo.InvariantCulture), CultureInfo.InvariantCulture);
			int num4 = int.Parse(text2.Substring(text2.Length - 4), CultureInfo.InvariantCulture);
			text2 = text2.Substring(0, 1) + text2.Substring(2, num3 - 1);
			if (num4 >= num3 || num4 < -6)
			{
				return text + text2.Substring(0, 1) + ((num3 > 1) ? ("." + text2.Substring(1)) : "") + ((num4 >= 0) ? "e+" : "e") + num4.ToString(CultureInfo.InvariantCulture);
			}
			if (num4 == num3 - 1)
			{
				return text + text2;
			}
			if (num4 >= 0)
			{
				return text + text2.Substring(0, num4 + 1) + "." + text2.Substring(num4 + 1);
			}
			return text + "0." + text2.PadLeft(num3 - num4 - 1, '0');
		}

		/// <summary>Creates a string representation of the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="radix">A number between 2 and 36 that represents the base of the number system that <paramref name="thisob" /> is expressed in. The default is 10.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Number_toString)]
		public static string toString(object thisob, object radix)
		{
			int num = 10;
			if (radix is IConvertible)
			{
				double num2 = ((IConvertible)radix).ToDouble(CultureInfo.InvariantCulture);
				int num3 = (int)num2;
				if (num2 == (double)num3)
				{
					num = num3;
				}
			}
			if (num < 2 || num > 36)
			{
				num = 10;
			}
			return Convert.ToString(valueOf(thisob), num);
		}

		/// <summary>Returns the value of the specified <see cref="T:Microsoft.JScript.NumberObject" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Number_valueOf)]
		public static object valueOf(object thisob)
		{
			if (thisob is NumberObject)
			{
				return ((NumberObject)thisob).value;
			}
			TypeCode typeCode = Convert.GetTypeCode(thisob);
			if ((uint)(typeCode - 5) <= 9u)
			{
				return thisob;
			}
			throw new JScriptException(JSError.NumberExpected);
		}
	}
	/// <summary>Performs binary operations on numeric operands. This class belongs to the abstract syntax tree category.</summary>
	public sealed class NumericBinary : BinaryOp
	{
		private object metaData;

		internal NumericBinary(Context context, AST operand1, AST operand2, JSToken operatorTok)
			: base(context, operand1, operand2, operatorTok)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.NumericBinary" /> class.</summary>
		/// <param name="operatorTok">One of the <see cref="T:Microsoft.JScript.JSToken" /> enumeration values. Specifies the operation to perform.</param>
		public NumericBinary(int operatorTok)
			: base(null, null, null, (JSToken)operatorTok)
		{
		}

		internal override object Evaluate()
		{
			return EvaluateNumericBinary(operand1.Evaluate(), operand2.Evaluate());
		}

		/// <summary>Performs a binary operation on the specified numeric operands.</summary>
		/// <param name="v1">The first operand.</param>
		/// <param name="v2">The second operand.</param>
		/// <returns>The result of the operation.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public object EvaluateNumericBinary(object v1, object v2)
		{
			if (v1 is int && v2 is int)
			{
				return DoOp((int)v1, (int)v2, operatorTok);
			}
			if (v1 is double && v2 is double)
			{
				return DoOp((double)v1, (double)v2, operatorTok);
			}
			return EvaluateNumericBinary(v1, v2, operatorTok);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		private object EvaluateNumericBinary(object v1, object v2, JSToken operatorTok)
		{
			IConvertible iConvertible = Convert.GetIConvertible(v1);
			IConvertible iConvertible2 = Convert.GetIConvertible(v2);
			TypeCode typeCode = Convert.GetTypeCode(v1, iConvertible);
			TypeCode typeCode2 = Convert.GetTypeCode(v2, iConvertible2);
			switch (typeCode)
			{
			case TypeCode.Empty:
				return double.NaN;
			case TypeCode.DBNull:
				return EvaluateNumericBinary(0, v2, operatorTok);
			case TypeCode.Char:
			{
				int num7 = iConvertible.ToInt32(null);
				object obj;
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return DoOp(num7, 0, operatorTok);
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
					obj = DoOp(num7, iConvertible2.ToInt32(null), operatorTok);
					break;
				case TypeCode.UInt32:
				case TypeCode.Int64:
					obj = DoOp(num7, iConvertible2.ToInt64(null), operatorTok);
					break;
				case TypeCode.UInt64:
					obj = DoOp(num7, iConvertible2.ToDouble(null), operatorTok);
					break;
				case TypeCode.Single:
				case TypeCode.Double:
					obj = DoOp(iConvertible.ToInt32(null), iConvertible2.ToDouble(null), operatorTok);
					break;
				case TypeCode.String:
					obj = DoOp(num7, Convert.ToNumber(v2, iConvertible2), operatorTok);
					break;
				default:
					obj = null;
					break;
				}
				if (base.operatorTok == JSToken.Minus && obj != null && typeCode2 != TypeCode.Char)
				{
					return Convert.Coerce2(obj, TypeCode.Char, truncationPermitted: false);
				}
				if (obj != null)
				{
					return obj;
				}
				break;
			}
			case TypeCode.Boolean:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			{
				int num6 = iConvertible.ToInt32(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return DoOp(num6, 0, operatorTok);
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
					return DoOp(num6, iConvertible2.ToInt32(null), operatorTok);
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return DoOp(num6, iConvertible2.ToInt64(null), operatorTok);
				case TypeCode.UInt64:
					if (num6 >= 0)
					{
						return DoOp((ulong)num6, iConvertible2.ToUInt64(null), operatorTok);
					}
					return DoOp(num6, iConvertible2.ToDouble(null), operatorTok);
				case TypeCode.Single:
				case TypeCode.Double:
					return DoOp(num6, iConvertible2.ToDouble(null), operatorTok);
				}
				break;
			}
			case TypeCode.UInt32:
			{
				uint num4 = iConvertible.ToUInt32(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return DoOp(num4, 0u, operatorTok);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.Int32:
				{
					int num5 = iConvertible2.ToInt32(null);
					if (num5 >= 0)
					{
						return DoOp(num4, (uint)num5, operatorTok);
					}
					return DoOp(num4, num5, operatorTok);
				}
				case TypeCode.Int64:
					return DoOp(num4, iConvertible2.ToInt64(null), operatorTok);
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.UInt16:
				case TypeCode.UInt32:
					return DoOp(num4, iConvertible2.ToUInt32(null), operatorTok);
				case TypeCode.UInt64:
					return DoOp(num4, iConvertible2.ToUInt64(null), operatorTok);
				case TypeCode.Single:
				case TypeCode.Double:
					return DoOp(num4, iConvertible2.ToDouble(null), operatorTok);
				}
				break;
			}
			case TypeCode.Int64:
			{
				long num3 = iConvertible.ToInt64(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return DoOp(num3, 0L, operatorTok);
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return DoOp(num3, iConvertible2.ToInt64(null), operatorTok);
				case TypeCode.UInt64:
					if (num3 >= 0)
					{
						return DoOp((ulong)num3, iConvertible2.ToUInt64(null), operatorTok);
					}
					return DoOp(num3, iConvertible2.ToDouble(null), operatorTok);
				case TypeCode.Single:
				case TypeCode.Double:
					return DoOp(num3, iConvertible2.ToDouble(null), operatorTok);
				}
				break;
			}
			case TypeCode.UInt64:
			{
				ulong num = iConvertible.ToUInt64(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return DoOp(num, 0uL, operatorTok);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.Int32:
				case TypeCode.Int64:
				{
					long num2 = iConvertible2.ToInt64(null);
					if (num2 >= 0)
					{
						return DoOp(num, (ulong)num2, operatorTok);
					}
					return DoOp(num, num2, operatorTok);
				}
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.UInt16:
				case TypeCode.UInt32:
				case TypeCode.UInt64:
					return DoOp(num, iConvertible2.ToUInt64(null), operatorTok);
				case TypeCode.Single:
				case TypeCode.Double:
					return DoOp(num, iConvertible2.ToDouble(null), operatorTok);
				}
				break;
			}
			case TypeCode.Single:
			case TypeCode.Double:
			{
				double x = iConvertible.ToDouble(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return DoOp(x, 0.0, operatorTok);
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
					return DoOp(x, iConvertible2.ToInt32(null), operatorTok);
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
					return DoOp(x, iConvertible2.ToDouble(null), operatorTok);
				}
				break;
			}
			}
			if (v2 == null)
			{
				return double.NaN;
			}
			MethodInfo @operator = GetOperator(v1.GetType(), v2.GetType());
			if (@operator != null)
			{
				return @operator.Invoke(null, BindingFlags.Default, JSBinder.ob, new object[2] { v1, v2 }, null);
			}
			return DoOp(v1, v2, iConvertible, iConvertible2, operatorTok);
		}

		/// <summary>Performs the specified binary operation on the specified numeric operands.</summary>
		/// <param name="v1">The first operand.</param>
		/// <param name="v2">The second operand.</param>
		/// <param name="operatorTok">One of the <see cref="T:Microsoft.JScript.JSToken" /> enumeration values. Specifies the operation to perform.</param>
		/// <returns>The result of the operation.</returns>
		public static object DoOp(object v1, object v2, JSToken operatorTok)
		{
			return DoOp(v1, v2, Convert.GetIConvertible(v1), Convert.GetIConvertible(v2), operatorTok);
		}

		private static object DoOp(object v1, object v2, IConvertible ic1, IConvertible ic2, JSToken operatorTok)
		{
			if (operatorTok == JSToken.Minus)
			{
				IConvertible ic3 = ic1;
				object obj = Convert.ToPrimitive(v1, PreferredType.Either, ref ic3);
				TypeCode typeCode = Convert.GetTypeCode(obj, ic3);
				if (typeCode == TypeCode.Char)
				{
					IConvertible ic4 = ic2;
					object obj2 = Convert.ToPrimitive(v2, PreferredType.Either, ref ic4);
					TypeCode typeCode2 = Convert.GetTypeCode(obj2, ic4);
					if (typeCode2 == TypeCode.String)
					{
						string text = ic4.ToString(null);
						if (text.Length == 1)
						{
							typeCode2 = TypeCode.Char;
							obj2 = text[0];
							ic4 = Convert.GetIConvertible(obj2);
						}
					}
					object obj3 = DoOp(Convert.ToNumber(obj, ic3), Convert.ToNumber(obj2, ic4), operatorTok);
					if (typeCode2 != TypeCode.Char)
					{
						obj3 = Convert.Coerce2(obj3, TypeCode.Char, truncationPermitted: false);
					}
					return obj3;
				}
			}
			return DoOp(Convert.ToNumber(v1, ic1), Convert.ToNumber(v2, ic2), operatorTok);
		}

		private static object DoOp(int x, int y, JSToken operatorTok)
		{
			switch (operatorTok)
			{
			case JSToken.Divide:
				return (double)x / (double)y;
			case JSToken.Minus:
			{
				int num = x - y;
				if (num < x == y > 0)
				{
					return num;
				}
				return (double)x - (double)y;
			}
			case JSToken.Modulo:
				if (x <= 0 || y <= 0)
				{
					return (double)x % (double)y;
				}
				return x % y;
			case JSToken.Multiply:
				if (x == 0 || y == 0)
				{
					return (double)x * (double)y;
				}
				try
				{
					return checked(x * y);
				}
				catch (OverflowException)
				{
					return (double)x * (double)y;
				}
			default:
				throw new JScriptException(JSError.InternalError);
			}
		}

		private static object DoOp(uint x, uint y, JSToken operatorTok)
		{
			switch (operatorTok)
			{
			case JSToken.Divide:
				return (double)x / (double)y;
			case JSToken.Minus:
			{
				uint num = x - y;
				if (num <= x)
				{
					return num;
				}
				return (double)x - (double)y;
			}
			case JSToken.Modulo:
				if (y == 0)
				{
					return double.NaN;
				}
				return x % y;
			case JSToken.Multiply:
				try
				{
					return checked(x * y);
				}
				catch (OverflowException)
				{
					return (double)x * (double)y;
				}
			default:
				throw new JScriptException(JSError.InternalError);
			}
		}

		private static object DoOp(long x, long y, JSToken operatorTok)
		{
			switch (operatorTok)
			{
			case JSToken.Divide:
				return (double)x / (double)y;
			case JSToken.Minus:
			{
				long num = x - y;
				if (num < x == y > 0)
				{
					return num;
				}
				return (double)x - (double)y;
			}
			case JSToken.Modulo:
			{
				if (y == 0L)
				{
					return double.NaN;
				}
				long num2 = x % y;
				if (num2 == 0L)
				{
					if (x < 0)
					{
						if (y < 0)
						{
							return 0;
						}
						return -0.0;
					}
					if (y < 0)
					{
						return -0.0;
					}
					return 0;
				}
				return num2;
			}
			case JSToken.Multiply:
				if (x == 0L || y == 0L)
				{
					return (double)x * (double)y;
				}
				try
				{
					return checked(x * y);
				}
				catch (OverflowException)
				{
					return (double)x * (double)y;
				}
			default:
				throw new JScriptException(JSError.InternalError);
			}
		}

		private static object DoOp(ulong x, ulong y, JSToken operatorTok)
		{
			switch (operatorTok)
			{
			case JSToken.Divide:
				return (double)x / (double)y;
			case JSToken.Minus:
			{
				ulong num = x - y;
				if (num <= x)
				{
					return num;
				}
				return (double)x - (double)y;
			}
			case JSToken.Modulo:
				if (y == 0L)
				{
					return double.NaN;
				}
				return x % y;
			case JSToken.Multiply:
				try
				{
					return checked(x * y);
				}
				catch (OverflowException)
				{
					return (double)x * (double)y;
				}
			default:
				throw new JScriptException(JSError.InternalError);
			}
		}

		private static object DoOp(double x, double y, JSToken operatorTok)
		{
			return operatorTok switch
			{
				JSToken.Divide => x / y, 
				JSToken.Minus => x - y, 
				JSToken.Modulo => x % y, 
				JSToken.Multiply => x * y, 
				_ => throw new JScriptException(JSError.InternalError), 
			};
		}

		internal override IReflect InferType(JSField inference_target)
		{
			MethodInfo methodInfo = ((!(type1 == null) && !(inference_target != null)) ? GetOperator(type1, type2) : GetOperator(operand1.InferType(inference_target), operand2.InferType(inference_target)));
			if (methodInfo != null)
			{
				metaData = methodInfo;
				return methodInfo.ReturnType;
			}
			if (type1 == Typeob.Char && operatorTok == JSToken.Minus)
			{
				TypeCode typeCode = Type.GetTypeCode(type2);
				if (Convert.IsPrimitiveNumericTypeCode(typeCode) || typeCode == TypeCode.Boolean)
				{
					return Typeob.Char;
				}
				if (typeCode == TypeCode.Char)
				{
					return Typeob.Int32;
				}
			}
			if ((Convert.IsPrimitiveNumericTypeFitForDouble(type1) || Typeob.JSObject.IsAssignableFrom(type1)) && (Convert.IsPrimitiveNumericTypeFitForDouble(type2) || Typeob.JSObject.IsAssignableFrom(type2)))
			{
				return Typeob.Double;
			}
			return Typeob.Object;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (metaData == null)
			{
				Type type = Typeob.Double;
				if (Convert.IsPrimitiveNumericType(rtype) && Convert.IsPromotableTo(type1, rtype) && Convert.IsPromotableTo(type2, rtype))
				{
					type = rtype;
				}
				if (operatorTok == JSToken.Divide)
				{
					type = Typeob.Double;
				}
				else if (type == Typeob.SByte || type == Typeob.Int16)
				{
					type = Typeob.Int32;
				}
				else if (type == Typeob.Byte || type == Typeob.UInt16 || type == Typeob.Char)
				{
					type = Typeob.UInt32;
				}
				operand1.TranslateToIL(il, type);
				operand2.TranslateToIL(il, type);
				if (type == Typeob.Double || type == Typeob.Single)
				{
					switch (operatorTok)
					{
					case JSToken.Divide:
						il.Emit(OpCodes.Div);
						break;
					case JSToken.Minus:
						il.Emit(OpCodes.Sub);
						break;
					case JSToken.Modulo:
						il.Emit(OpCodes.Rem);
						break;
					case JSToken.Multiply:
						il.Emit(OpCodes.Mul);
						break;
					default:
						throw new JScriptException(JSError.InternalError, context);
					}
				}
				else if (type == Typeob.Int32 || type == Typeob.Int64)
				{
					switch (operatorTok)
					{
					case JSToken.Divide:
						il.Emit(OpCodes.Div);
						break;
					case JSToken.Minus:
						il.Emit(OpCodes.Sub_Ovf);
						break;
					case JSToken.Modulo:
						il.Emit(OpCodes.Rem);
						break;
					case JSToken.Multiply:
						il.Emit(OpCodes.Mul_Ovf);
						break;
					default:
						throw new JScriptException(JSError.InternalError, context);
					}
				}
				else
				{
					switch (operatorTok)
					{
					case JSToken.Divide:
						il.Emit(OpCodes.Div);
						break;
					case JSToken.Minus:
						il.Emit(OpCodes.Sub_Ovf_Un);
						break;
					case JSToken.Modulo:
						il.Emit(OpCodes.Rem);
						break;
					case JSToken.Multiply:
						il.Emit(OpCodes.Mul_Ovf_Un);
						break;
					default:
						throw new JScriptException(JSError.InternalError, context);
					}
				}
				if (Convert.ToType(InferType(null)) == Typeob.Char)
				{
					Convert.Emit(this, il, type, Typeob.Char);
					Convert.Emit(this, il, Typeob.Char, rtype);
				}
				else
				{
					Convert.Emit(this, il, type, rtype);
				}
			}
			else if (metaData is MethodInfo)
			{
				MethodInfo methodInfo = (MethodInfo)metaData;
				ParameterInfo[] parameters = methodInfo.GetParameters();
				operand1.TranslateToIL(il, parameters[0].ParameterType);
				operand2.TranslateToIL(il, parameters[1].ParameterType);
				il.Emit(OpCodes.Call, methodInfo);
				Convert.Emit(this, il, methodInfo.ReturnType, rtype);
			}
			else
			{
				il.Emit(OpCodes.Ldloc, (LocalBuilder)metaData);
				operand1.TranslateToIL(il, Typeob.Object);
				operand2.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.evaluateNumericBinaryMethod);
				Convert.Emit(this, il, Typeob.Object, rtype);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			IReflect reflect = InferType(null);
			operand1.TranslateToILInitializer(il);
			operand2.TranslateToILInitializer(il);
			if (reflect == Typeob.Object)
			{
				metaData = il.DeclareLocal(Typeob.NumericBinary);
				ConstantWrapper.TranslateToILInt(il, (int)operatorTok);
				il.Emit(OpCodes.Newobj, CompilerGlobals.numericBinaryConstructor);
				il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
			}
		}
	}
	internal class NumericBinaryAssign : BinaryOp
	{
		private NumericBinary binOp;

		private object metaData;

		internal NumericBinaryAssign(Context context, AST operand1, AST operand2, JSToken operatorTok)
			: base(context, operand1, operand2, operatorTok)
		{
			binOp = new NumericBinary(context, operand1, operand2, operatorTok);
			metaData = null;
		}

		internal override object Evaluate()
		{
			object v = operand1.Evaluate();
			object v2 = operand2.Evaluate();
			object obj = binOp.EvaluateNumericBinary(v, v2);
			try
			{
				operand1.SetValue(obj);
				return obj;
			}
			catch (JScriptException ex)
			{
				if (ex.context == null)
				{
					ex.context = context;
				}
				throw ex;
			}
			catch (Exception e)
			{
				throw new JScriptException(e, context);
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			MethodInfo methodInfo = ((!(type1 == null) && !(inference_target != null)) ? GetOperator(type1, type2) : GetOperator(operand1.InferType(inference_target), operand2.InferType(inference_target)));
			if (methodInfo != null)
			{
				metaData = methodInfo;
				return methodInfo.ReturnType;
			}
			if (type1 == Typeob.Char && operatorTok == JSToken.Minus)
			{
				TypeCode typeCode = Type.GetTypeCode(type2);
				if (Convert.IsPrimitiveNumericTypeCode(typeCode) || typeCode == TypeCode.Boolean)
				{
					return Typeob.Char;
				}
				if (typeCode == TypeCode.Char)
				{
					return Typeob.Int32;
				}
			}
			if (Convert.IsPrimitiveNumericType(type1))
			{
				if (Convert.IsPromotableTo(type2, type1) || (operand2 is ConstantWrapper && ((ConstantWrapper)operand2).IsAssignableTo(type1)))
				{
					return type1;
				}
				if (Convert.IsPrimitiveNumericType(type1) && Convert.IsPrimitiveNumericTypeFitForDouble(type2))
				{
					return Typeob.Double;
				}
			}
			return Typeob.Object;
		}

		internal override AST PartiallyEvaluate()
		{
			operand1 = operand1.PartiallyEvaluateAsReference();
			operand2 = operand2.PartiallyEvaluate();
			binOp = new NumericBinary(context, operand1, operand2, operatorTok);
			operand1.SetPartialValue(binOp);
			return this;
		}

		private void TranslateToILForNoOverloadCase(ILGenerator il, Type rtype)
		{
			Type type = Convert.ToType(operand1.InferType(null));
			Type type2 = Convert.ToType(operand2.InferType(null));
			Type type3 = Typeob.Double;
			if (operatorTok != JSToken.Divide && (rtype == Typeob.Void || rtype == type || Convert.IsPrimitiveNumericType(type)) && (Convert.IsPromotableTo(type2, type) || (operand2 is ConstantWrapper && ((ConstantWrapper)operand2).IsAssignableTo(type))))
			{
				type3 = type;
			}
			if (type3 == Typeob.SByte || type3 == Typeob.Int16)
			{
				type3 = Typeob.Int32;
			}
			else if (type3 == Typeob.Byte || type3 == Typeob.UInt16 || type3 == Typeob.Char)
			{
				type3 = Typeob.UInt32;
			}
			if (operand2 is ConstantWrapper)
			{
				if (!((ConstantWrapper)operand2).IsAssignableTo(type3))
				{
					type3 = Typeob.Object;
				}
			}
			else if ((Convert.IsPrimitiveSignedNumericType(type2) && Convert.IsPrimitiveUnsignedIntegerType(type)) || (Convert.IsPrimitiveUnsignedIntegerType(type2) && Convert.IsPrimitiveSignedIntegerType(type)))
			{
				type3 = Typeob.Object;
			}
			operand1.TranslateToILPreSetPlusGet(il);
			Convert.Emit(this, il, type, type3);
			operand2.TranslateToIL(il, type3);
			if (type3 == Typeob.Object)
			{
				il.Emit(OpCodes.Ldc_I4, (int)operatorTok);
				il.Emit(OpCodes.Call, CompilerGlobals.numericbinaryDoOpMethod);
			}
			else if (type3 == Typeob.Double || type3 == Typeob.Single)
			{
				switch (operatorTok)
				{
				case JSToken.Divide:
					il.Emit(OpCodes.Div);
					break;
				case JSToken.Minus:
					il.Emit(OpCodes.Sub);
					break;
				case JSToken.Modulo:
					il.Emit(OpCodes.Rem);
					break;
				case JSToken.Multiply:
					il.Emit(OpCodes.Mul);
					break;
				default:
					throw new JScriptException(JSError.InternalError, context);
				}
			}
			else if (type3 == Typeob.Int32 || type3 == Typeob.Int64 || type3 == Typeob.Int16 || type3 == Typeob.SByte)
			{
				switch (operatorTok)
				{
				case JSToken.Divide:
					il.Emit(OpCodes.Div);
					break;
				case JSToken.Minus:
					il.Emit(OpCodes.Sub_Ovf);
					break;
				case JSToken.Modulo:
					il.Emit(OpCodes.Rem);
					break;
				case JSToken.Multiply:
					il.Emit(OpCodes.Mul_Ovf);
					break;
				default:
					throw new JScriptException(JSError.InternalError, context);
				}
			}
			else
			{
				switch (operatorTok)
				{
				case JSToken.Divide:
					il.Emit(OpCodes.Div);
					break;
				case JSToken.Minus:
					il.Emit(OpCodes.Sub_Ovf_Un);
					break;
				case JSToken.Modulo:
					il.Emit(OpCodes.Rem);
					break;
				case JSToken.Multiply:
					il.Emit(OpCodes.Mul_Ovf_Un);
					break;
				default:
					throw new JScriptException(JSError.InternalError, context);
				}
			}
			if (rtype != Typeob.Void)
			{
				LocalBuilder local = il.DeclareLocal(type3);
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Stloc, local);
				Convert.Emit(this, il, type3, type);
				operand1.TranslateToILSet(il);
				il.Emit(OpCodes.Ldloc, local);
				Convert.Emit(this, il, type3, rtype);
			}
			else
			{
				Convert.Emit(this, il, type3, type);
				operand1.TranslateToILSet(il);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (metaData == null)
			{
				TranslateToILForNoOverloadCase(il, rtype);
			}
			else if (metaData is MethodInfo)
			{
				object obj = null;
				MethodInfo methodInfo = (MethodInfo)metaData;
				Type type = Convert.ToType(operand1.InferType(null));
				ParameterInfo[] parameters = methodInfo.GetParameters();
				operand1.TranslateToILPreSetPlusGet(il);
				Convert.Emit(this, il, type, parameters[0].ParameterType);
				operand2.TranslateToIL(il, parameters[1].ParameterType);
				il.Emit(OpCodes.Call, methodInfo);
				if (rtype != Typeob.Void)
				{
					obj = il.DeclareLocal(rtype);
					il.Emit(OpCodes.Dup);
					Convert.Emit(this, il, type, rtype);
					il.Emit(OpCodes.Stloc, (LocalBuilder)obj);
				}
				Convert.Emit(this, il, methodInfo.ReturnType, type);
				operand1.TranslateToILSet(il);
				if (rtype != Typeob.Void)
				{
					il.Emit(OpCodes.Ldloc, (LocalBuilder)obj);
				}
			}
			else
			{
				Type type2 = Convert.ToType(operand1.InferType(null));
				LocalBuilder local = il.DeclareLocal(Typeob.Object);
				operand1.TranslateToILPreSetPlusGet(il);
				Convert.Emit(this, il, type2, Typeob.Object);
				il.Emit(OpCodes.Stloc, local);
				il.Emit(OpCodes.Ldloc, (LocalBuilder)metaData);
				il.Emit(OpCodes.Ldloc, local);
				operand2.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.evaluateNumericBinaryMethod);
				if (rtype != Typeob.Void)
				{
					il.Emit(OpCodes.Dup);
					il.Emit(OpCodes.Stloc, local);
				}
				Convert.Emit(this, il, Typeob.Object, type2);
				operand1.TranslateToILSet(il);
				if (rtype != Typeob.Void)
				{
					il.Emit(OpCodes.Ldloc, local);
					Convert.Emit(this, il, Typeob.Object, rtype);
				}
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			IReflect reflect = InferType(null);
			operand1.TranslateToILInitializer(il);
			operand2.TranslateToILInitializer(il);
			if (reflect == Typeob.Object)
			{
				metaData = il.DeclareLocal(Typeob.NumericBinary);
				ConstantWrapper.TranslateToILInt(il, (int)operatorTok);
				il.Emit(OpCodes.Newobj, CompilerGlobals.numericBinaryConstructor);
				il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
			}
		}
	}
	/// <summary>Performs unary operations on numeric operands. This class belongs to the abstract syntax tree category.</summary>
	public sealed class NumericUnary : UnaryOp
	{
		private object metaData;

		private JSToken operatorTok;

		private MethodInfo operatorMeth;

		private Type type;

		internal NumericUnary(Context context, AST operand, JSToken operatorTok)
			: base(context, operand)
		{
			this.operatorTok = operatorTok;
			operatorMeth = null;
			type = null;
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.NumericUnary" /> class.</summary>
		/// <param name="operatorTok">One of the <see cref="T:Microsoft.JScript.JSToken" /> enumeration values. Specifies the operation to perform.</param>
		public NumericUnary(int operatorTok)
			: this(null, null, (JSToken)operatorTok)
		{
		}

		internal override object Evaluate()
		{
			return EvaluateUnary(operand.Evaluate());
		}

		/// <summary>Performs a unary operation on a numeric operand.</summary>
		/// <param name="v">The operand.</param>
		/// <returns>The result of the operation.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public object EvaluateUnary(object v)
		{
			IConvertible iConvertible = Convert.GetIConvertible(v);
			switch (Convert.GetTypeCode(v, iConvertible))
			{
			case TypeCode.Empty:
				return EvaluateUnary(double.NaN);
			case TypeCode.DBNull:
				return EvaluateUnary(0);
			case TypeCode.Boolean:
				return EvaluateUnary(iConvertible.ToBoolean(null) ? 1 : 0);
			case TypeCode.Char:
				return EvaluateUnary((int)iConvertible.ToChar(null));
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			{
				int num5 = iConvertible.ToInt32(null);
				return operatorTok switch
				{
					JSToken.BitwiseNot => ~num5, 
					JSToken.FirstOp => num5 == 0, 
					JSToken.Minus => num5 switch
					{
						0 => 0.0 - (double)num5, 
						int.MinValue => (ulong)(0.0 - (double)num5), 
						_ => -num5, 
					}, 
					JSToken.FirstBinaryOp => num5, 
					_ => throw new JScriptException(JSError.InternalError, context), 
				};
			}
			case TypeCode.UInt32:
			{
				uint num4 = iConvertible.ToUInt32(null);
				switch (operatorTok)
				{
				case JSToken.BitwiseNot:
					return ~num4;
				case JSToken.FirstOp:
					return num4 == 0;
				case JSToken.Minus:
					if (num4 != 0 && num4 <= int.MaxValue)
					{
						return (int)(0 - num4);
					}
					return 0.0 - (double)num4;
				case JSToken.FirstBinaryOp:
					return num4;
				default:
					throw new JScriptException(JSError.InternalError, context);
				}
			}
			case TypeCode.Int64:
			{
				long num3 = iConvertible.ToInt64(null);
				switch (operatorTok)
				{
				case JSToken.BitwiseNot:
					return ~num3;
				case JSToken.FirstOp:
					return num3 == 0;
				case JSToken.Minus:
					if (num3 == 0L || num3 == long.MinValue)
					{
						return 0.0 - (double)num3;
					}
					return -num3;
				case JSToken.FirstBinaryOp:
					return num3;
				default:
					throw new JScriptException(JSError.InternalError, context);
				}
			}
			case TypeCode.UInt64:
			{
				ulong num2 = iConvertible.ToUInt64(null);
				switch (operatorTok)
				{
				case JSToken.BitwiseNot:
					return ~num2;
				case JSToken.FirstOp:
					return num2 == 0;
				case JSToken.Minus:
					if (num2 != 0L && num2 <= long.MaxValue)
					{
						return (long)(0L - num2);
					}
					return 0.0 - (double)num2;
				case JSToken.FirstBinaryOp:
					return num2;
				default:
					throw new JScriptException(JSError.InternalError, context);
				}
			}
			case TypeCode.Single:
			case TypeCode.Double:
			{
				double num = iConvertible.ToDouble(null);
				return operatorTok switch
				{
					JSToken.BitwiseNot => (int)(~Runtime.DoubleToInt64(num)), 
					JSToken.FirstOp => !Convert.ToBoolean(num), 
					JSToken.Minus => 0.0 - num, 
					JSToken.FirstBinaryOp => num, 
					_ => throw new JScriptException(JSError.InternalError, context), 
				};
			}
			default:
			{
				MethodInfo @operator = GetOperator(v.GetType());
				if (@operator != null)
				{
					return @operator.Invoke(null, BindingFlags.Default, JSBinder.ob, new object[1] { v }, null);
				}
				break;
			}
			case TypeCode.String:
				break;
			}
			return operatorTok switch
			{
				JSToken.BitwiseNot => ~Convert.ToInt32(v, iConvertible), 
				JSToken.FirstOp => !Convert.ToBoolean(v, iConvertible), 
				JSToken.Minus => 0.0 - Convert.ToNumber(v, iConvertible), 
				JSToken.FirstBinaryOp => Convert.ToNumber(v, iConvertible), 
				_ => throw new JScriptException(JSError.InternalError, context), 
			};
		}

		private MethodInfo GetOperator(IReflect ir)
		{
			Type type = ((ir is Type) ? ((Type)ir) : Typeob.Object);
			if (this.type == type)
			{
				return operatorMeth;
			}
			this.type = type;
			if (Convert.IsPrimitiveNumericType(type) || Typeob.JSObject.IsAssignableFrom(type))
			{
				operatorMeth = null;
				return null;
			}
			switch (operatorTok)
			{
			case JSToken.BitwiseNot:
				operatorMeth = type.GetMethod("op_OnesComplement", BindingFlags.Static | BindingFlags.Public, JSBinder.ob, new Type[1] { type }, null);
				break;
			case JSToken.FirstOp:
				operatorMeth = type.GetMethod("op_LogicalNot", BindingFlags.Static | BindingFlags.Public, JSBinder.ob, new Type[1] { type }, null);
				break;
			case JSToken.Minus:
				operatorMeth = type.GetMethod("op_UnaryNegation", BindingFlags.Static | BindingFlags.Public, JSBinder.ob, new Type[1] { type }, null);
				break;
			case JSToken.FirstBinaryOp:
				operatorMeth = type.GetMethod("op_UnaryPlus", BindingFlags.Static | BindingFlags.Public, JSBinder.ob, new Type[1] { type }, null);
				break;
			default:
				throw new JScriptException(JSError.InternalError, context);
			}
			if (operatorMeth == null || (operatorMeth.Attributes & MethodAttributes.SpecialName) == 0 || operatorMeth.GetParameters().Length != 1)
			{
				operatorMeth = null;
			}
			if (operatorMeth != null)
			{
				operatorMeth = new JSMethodInfo(operatorMeth);
			}
			return operatorMeth;
		}

		internal override IReflect InferType(JSField inference_target)
		{
			MethodInfo methodInfo = ((!(type == null) && !(inference_target != null)) ? GetOperator(type) : GetOperator(operand.InferType(inference_target)));
			if (methodInfo != null)
			{
				metaData = methodInfo;
				return methodInfo.ReturnType;
			}
			if (operatorTok == JSToken.FirstOp)
			{
				return Typeob.Boolean;
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.Empty:
				if (operatorTok != JSToken.BitwiseNot)
				{
					return Typeob.Double;
				}
				return Typeob.Int32;
			case TypeCode.Object:
				return Typeob.Object;
			case TypeCode.DBNull:
				return Typeob.Int32;
			case TypeCode.Boolean:
				return Typeob.Int32;
			case TypeCode.SByte:
				if (operatorTok != JSToken.BitwiseNot)
				{
					return Typeob.Int32;
				}
				return Typeob.SByte;
			case TypeCode.Char:
				return Typeob.Int32;
			case TypeCode.Byte:
				if (operatorTok != JSToken.BitwiseNot)
				{
					return Typeob.Int32;
				}
				return Typeob.Byte;
			case TypeCode.Int16:
				if (operatorTok != JSToken.BitwiseNot)
				{
					return Typeob.Int32;
				}
				return Typeob.Int16;
			case TypeCode.UInt16:
				if (operatorTok != JSToken.BitwiseNot)
				{
					return Typeob.Int32;
				}
				return Typeob.UInt16;
			case TypeCode.Int32:
				return Typeob.Int32;
			case TypeCode.UInt32:
				if (operatorTok != JSToken.Minus)
				{
					return Typeob.UInt32;
				}
				return Typeob.Double;
			case TypeCode.Int64:
				return Typeob.Int64;
			case TypeCode.UInt64:
				if (operatorTok != JSToken.Minus)
				{
					return Typeob.UInt64;
				}
				return Typeob.Double;
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.String:
				if (operatorTok != JSToken.BitwiseNot)
				{
					return Typeob.Double;
				}
				return Typeob.Int32;
			default:
				if (Typeob.JSObject.IsAssignableFrom(type))
				{
					return Typeob.Double;
				}
				return Typeob.Object;
			}
		}

		internal override void TranslateToConditionalBranch(ILGenerator il, bool branchIfTrue, Label label, bool shortForm)
		{
			if (operatorTok == JSToken.FirstOp)
			{
				operand.TranslateToConditionalBranch(il, !branchIfTrue, label, shortForm);
			}
			else
			{
				base.TranslateToConditionalBranch(il, branchIfTrue, label, shortForm);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (metaData == null)
			{
				Type type = ((operatorTok == JSToken.FirstOp) ? Typeob.Boolean : Typeob.Double);
				if (Convert.IsPrimitiveNumericType(rtype) && Convert.IsPromotableTo(this.type, rtype))
				{
					type = rtype;
				}
				if (operatorTok == JSToken.BitwiseNot && !Convert.IsPrimitiveIntegerType(type))
				{
					type = this.type;
					if (!Convert.IsPrimitiveIntegerType(type))
					{
						type = Typeob.Int32;
					}
				}
				operand.TranslateToIL(il, this.type);
				Convert.Emit(this, il, this.type, type, truncationPermitted: true);
				switch (operatorTok)
				{
				case JSToken.BitwiseNot:
					il.Emit(OpCodes.Not);
					break;
				case JSToken.FirstOp:
					Convert.Emit(this, il, type, Typeob.Boolean, truncationPermitted: true);
					type = Typeob.Boolean;
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Ceq);
					break;
				case JSToken.Minus:
					il.Emit(OpCodes.Neg);
					break;
				default:
					throw new JScriptException(JSError.InternalError, context);
				case JSToken.FirstBinaryOp:
					break;
				}
				Convert.Emit(this, il, type, rtype);
			}
			else if (metaData is MethodInfo)
			{
				MethodInfo methodInfo = (MethodInfo)metaData;
				ParameterInfo[] parameters = methodInfo.GetParameters();
				operand.TranslateToIL(il, parameters[0].ParameterType);
				il.Emit(OpCodes.Call, methodInfo);
				Convert.Emit(this, il, methodInfo.ReturnType, rtype);
			}
			else
			{
				il.Emit(OpCodes.Ldloc, (LocalBuilder)metaData);
				operand.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.evaluateUnaryMethod);
				Convert.Emit(this, il, Typeob.Object, rtype);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			IReflect reflect = InferType(null);
			operand.TranslateToILInitializer(il);
			if (reflect == Typeob.Object)
			{
				metaData = il.DeclareLocal(Typeob.NumericUnary);
				ConstantWrapper.TranslateToILInt(il, (int)operatorTok);
				il.Emit(OpCodes.Newobj, CompilerGlobals.numericUnaryConstructor);
				il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
			}
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public sealed class ObjectConstructor : ScriptFunction
	{
		internal static readonly ObjectConstructor ob = new ObjectConstructor();

		internal ObjectPrototype originalPrototype;

		internal ObjectConstructor()
			: base(FunctionPrototype.ob, "Object", 1)
		{
			originalPrototype = ObjectPrototype.ob;
			ObjectPrototype._constructor = this;
			proto = ObjectPrototype.ob;
		}

		internal ObjectConstructor(LenientFunctionPrototype parent, LenientObjectPrototype prototypeProp)
			: base(parent, "Object", 1)
		{
			originalPrototype = prototypeProp;
			prototypeProp.constructor = this;
			proto = prototypeProp;
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			if (args.Length == 0)
			{
				return ConstructObject();
			}
			object obj = args[0];
			if (obj == null || obj == DBNull.Value)
			{
				return Construct(args);
			}
			return Convert.ToObject3(obj, engine);
		}

		internal override object Construct(object[] args)
		{
			if (args.Length == 0)
			{
				return ConstructObject();
			}
			object obj = args[0];
			switch (Convert.GetTypeCode(obj))
			{
			case TypeCode.Empty:
			case TypeCode.DBNull:
				return ConstructObject();
			case TypeCode.Object:
			{
				if (obj is ScriptObject)
				{
					return obj;
				}
				IReflect reflect = null;
				reflect = ((!(obj is IReflect)) ? obj.GetType() : ((IReflect)obj));
				return reflect.InvokeMember(string.Empty, BindingFlags.Public | BindingFlags.CreateInstance | BindingFlags.OptionalParamBinding, JSBinder.ob, obj, new object[0], null, null, null);
			}
			default:
				return Convert.ToObject3(obj, engine);
			}
		}

		/// <summary>Creates an instance of the prototype-based object.</summary>
		/// <returns>The instance of the object.</returns>
		public JSObject ConstructObject()
		{
			return new JSObject(originalPrototype, checkSubType: false);
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>The instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new object CreateInstance(params object[] args)
		{
			return Construct(args);
		}

		/// <summary>Invokes a method of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the method.</param>
		/// <returns>The result of the call to the method.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public object Invoke(params object[] args)
		{
			return Call(args, null);
		}
	}
	internal sealed class ObjectLiteral : AST
	{
		internal AST[] keys;

		internal AST[] values;

		internal ObjectLiteral(Context context, ASTList propertyList)
			: base(context)
		{
			int count = propertyList.count;
			keys = new AST[count];
			values = new AST[count];
			for (int i = 0; i < count; i++)
			{
				ASTList aSTList = (ASTList)propertyList[i];
				keys[i] = aSTList[0];
				values[i] = aSTList[1];
			}
		}

		internal override void CheckIfOKToUseInSuperConstructorCall()
		{
			int i = 0;
			for (int num = values.Length; i < num; i++)
			{
				values[i].CheckIfOKToUseInSuperConstructorCall();
			}
		}

		internal override object Evaluate()
		{
			JSObject jSObject = base.Engine.GetOriginalObjectConstructor().ConstructObject();
			int i = 0;
			for (int num = keys.Length; i < num; i++)
			{
				jSObject.SetMemberValue(keys[i].Evaluate().ToString(), values[i].Evaluate());
			}
			return jSObject;
		}

		internal override AST PartiallyEvaluate()
		{
			int num = keys.Length;
			for (int i = 0; i < num; i++)
			{
				keys[i] = keys[i].PartiallyEvaluate();
				values[i] = values[i].PartiallyEvaluate();
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			int num = keys.Length;
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.getOriginalObjectConstructorMethod);
			il.Emit(OpCodes.Call, CompilerGlobals.constructObjectMethod);
			for (int i = 0; i < num; i++)
			{
				il.Emit(OpCodes.Dup);
				keys[i].TranslateToIL(il, Typeob.String);
				values[i].TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.setMemberValue2Method);
			}
			Convert.Emit(this, il, Typeob.Object, rtype);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			int i = 0;
			for (int num = keys.Length; i < num; i++)
			{
				keys[i].TranslateToILInitializer(il);
				values[i].TranslateToILInitializer(il);
			}
		}
	}
	/// <summary>Provides static methods and properties for <see cref="T:Microsoft.JScript.JSObject" /> objects. All methods of this class are called by passing in a reference to the object that is requesting access to the method. This class belongs to the built-in object model category.</summary>
	public class ObjectPrototype : JSObject
	{
		internal static readonly ObjectPrototype ob = new ObjectPrototype();

		internal static ObjectConstructor _constructor;

		/// <summary>Gets a reference to a prototype-based object that is using this prototype.</summary>
		/// <returns>A reference to a prototype-based object.</returns>
		public static ObjectConstructor constructor => _constructor;

		internal ObjectPrototype()
			: base(null)
		{
			if (Globals.contextEngine == null)
			{
				engine = new VsaEngine(fast: true);
				engine.InitVsaEngine("JS7://Microsoft.JScript.Vsa.VsaEngine", new DefaultVsaSite());
			}
			else
			{
				engine = Globals.contextEngine;
			}
		}

		internal static ObjectPrototype CommonInstance()
		{
			return ob;
		}

		/// <summary>Determines whether the specified object contains the specified property.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="name">The property to search for.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="name" /> is a property of <paramref name="thisob" /> and has been set; otherwise, <see langword="false" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Object_hasOwnProperty)]
		public static bool hasOwnProperty(object thisob, object name)
		{
			string name2 = Convert.ToString(name);
			if (thisob is ArrayObject)
			{
				long num = ArrayObject.Array_index_for(name2);
				if (num >= 0)
				{
					object valueAtIndex = ((ArrayObject)thisob).GetValueAtIndex((uint)num);
					if (valueAtIndex != null)
					{
						return valueAtIndex != Missing.Value;
					}
					return false;
				}
			}
			if (thisob is JSObject)
			{
				MemberInfo[] member = ((JSObject)thisob).GetMember(name2, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
				int num2 = member.Length;
				if (num2 > 1)
				{
					return true;
				}
				if (num2 < 1)
				{
					return false;
				}
				if (member[0] is JSPrototypeField)
				{
					return !(((JSPrototypeField)member[0]).value is Missing);
				}
				return true;
			}
			return !(LateBinding.GetMemberValue(thisob, name2) is Missing);
		}

		/// <summary>Determines whether the first specified object can be instantiated as the type of the second specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="ob">The object that has the desired type.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="ob" /> is in the inheritance hierarchy of <paramref name="thisob" />; otherwise, <see langword="false" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Object_isPrototypeOf)]
		public static bool isPrototypeOf(object thisob, object ob)
		{
			if (thisob is ScriptObject && ob is ScriptObject)
			{
				while (ob != null)
				{
					if (ob == thisob)
					{
						return true;
					}
					ob = ((ScriptObject)ob).GetParent();
				}
			}
			return false;
		}

		/// <summary>Determines whether the specified property of the specified object is enumerable.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="name">The property to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="name" /> is an enumerable property; otherwise, <see langword="false" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Object_propertyIsEnumerable)]
		public static bool propertyIsEnumerable(object thisob, object name)
		{
			string name2 = Convert.ToString(name);
			if (thisob is ArrayObject)
			{
				long num = ArrayObject.Array_index_for(name2);
				if (num >= 0)
				{
					object valueAtIndex = ((ArrayObject)thisob).GetValueAtIndex((uint)num);
					if (valueAtIndex != null)
					{
						return valueAtIndex != Missing.Value;
					}
					return false;
				}
			}
			if (thisob is JSObject)
			{
				FieldInfo field = ((JSObject)thisob).GetField(name2, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
				if (field != null)
				{
					return field is JSExpandoField;
				}
				return false;
			}
			return false;
		}

		/// <summary>Creates a string representation of the specified object by using the <see cref="T:Microsoft.JScript.Convert" /> class.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" /> that is created by the <see cref="T:Microsoft.JScript.Convert" /> class.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Object_toLocaleString)]
		public static string toLocaleString(object thisob)
		{
			return Convert.ToString(thisob);
		}

		/// <summary>Creates a string representation of the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The name of the class of the object, if it has one defined; otherwise, the <see cref="P:System.Reflection.MemberInfo.Name" /> of the <see cref="T:System.Type" /> of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Object_toString)]
		public static string toString(object thisob)
		{
			if (thisob is JSObject)
			{
				return "[object " + ((JSObject)thisob).GetClassName() + "]";
			}
			return "[object " + thisob.GetType().Name + "]";
		}

		/// <summary>Returns the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>
		///   <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.Object_valueOf)]
		public static object valueOf(object thisob)
		{
			return thisob;
		}
	}
	internal enum OpPrec
	{
		precNone,
		precSeqEval,
		precAssignment,
		precConditional,
		precLogicalOr,
		precLogicalAnd,
		precBitwiseOr,
		precBitwiseXor,
		precBitwiseAnd,
		precEquality,
		precRelational,
		precShift,
		precAdditive,
		precMultiplicative
	}
	/// <summary>Creates packages of JScript code for use by other code. This class belongs to the abstract syntax tree category.</summary>
	public sealed class Package : AST
	{
		private string name;

		private ASTList classList;

		private PackageScope scope;

		internal Package(string name, AST id, ASTList classList, Context context)
			: base(context)
		{
			this.name = name;
			this.classList = classList;
			scope = (PackageScope)base.Globals.ScopeStack.Peek();
			scope.owner = this;
			base.Engine.AddPackage(scope);
			if (id is Lookup lookup)
			{
				lookup.EvaluateAsWrappedNamespace(giveErrorIfNameInUse: true);
			}
			else if (id is Member member)
			{
				member.EvaluateAsWrappedNamespace(giveErrorIfNameInUse: true);
			}
		}

		internal override object Evaluate()
		{
			base.Globals.ScopeStack.Push(scope);
			try
			{
				int i = 0;
				for (int count = classList.count; i < count; i++)
				{
					classList[i].Evaluate();
				}
				return new Completion();
			}
			finally
			{
				base.Globals.ScopeStack.Pop();
			}
		}

		/// <summary>Creates the specified package by using the specified scripting engine.</summary>
		/// <param name="rootName">The name of the package.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		public static void JScriptPackage(string rootName, VsaEngine engine)
		{
			GlobalScope globalScope = ((IActivationObject)engine.ScriptObjectStackTop()).GetGlobalScope();
			FieldInfo localField = globalScope.GetLocalField(rootName);
			if (localField == null)
			{
				localField = globalScope.AddNewField(rootName, Namespace.GetNamespace(rootName, engine), FieldAttributes.Public | FieldAttributes.Literal);
			}
		}

		internal void MergeWith(Package p)
		{
			int i = 0;
			for (int count = p.classList.count; i < count; i++)
			{
				classList.Append(p.classList[i]);
			}
			scope.MergeWith(p.scope);
		}

		internal override AST PartiallyEvaluate()
		{
			scope.AddOwnName();
			base.Globals.ScopeStack.Push(scope);
			try
			{
				int i = 0;
				for (int count = classList.count; i < count; i++)
				{
					classList[i].PartiallyEvaluate();
				}
				return this;
			}
			finally
			{
				base.Globals.ScopeStack.Pop();
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			base.Globals.ScopeStack.Push(scope);
			int i = 0;
			for (int count = classList.count; i < count; i++)
			{
				classList[i].TranslateToIL(il, Typeob.Void);
			}
			base.Globals.ScopeStack.Pop();
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			string text = name;
			int num = text.IndexOf('.');
			if (num > 0)
			{
				text = text.Substring(0, num);
			}
			il.Emit(OpCodes.Ldstr, text);
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.jScriptPackageMethod);
			base.Globals.ScopeStack.Push(scope);
			int i = 0;
			for (int count = classList.count; i < count; i++)
			{
				classList[i].TranslateToILInitializer(il);
			}
			base.Globals.ScopeStack.Pop();
		}

		internal override Context GetFirstExecutableContext()
		{
			return null;
		}
	}
	internal class PackageScope : ActivationObject
	{
		internal string name;

		internal Package owner;

		public PackageScope(ScriptObject parent)
			: base(parent)
		{
			fast = true;
			name = null;
			owner = null;
			isKnownAtCompileTime = true;
		}

		internal override JSVariableField AddNewField(string name, object value, FieldAttributes attributeFlags)
		{
			base.AddNewField(this.name + "." + name, value, attributeFlags);
			return base.AddNewField(name, value, attributeFlags);
		}

		internal void AddOwnName()
		{
			string text = name;
			int num = text.IndexOf('.');
			if (num > 0)
			{
				text = text.Substring(0, num);
			}
			base.AddNewField(text, Namespace.GetNamespace(text, engine), FieldAttributes.Public | FieldAttributes.Literal);
		}

		protected override JSVariableField CreateField(string name, FieldAttributes attributeFlags, object value)
		{
			return new JSGlobalField(this, name, value, attributeFlags);
		}

		internal override string GetName()
		{
			return name;
		}

		internal void MergeWith(PackageScope p)
		{
			foreach (object item in p.field_table)
			{
				JSGlobalField jSGlobalField = (JSGlobalField)item;
				ClassScope classScope = jSGlobalField.value as ClassScope;
				if (name_table[jSGlobalField.Name] != null)
				{
					if (classScope != null)
					{
						classScope.owner.context.HandleError(JSError.DuplicateName, jSGlobalField.Name, treatAsError: true);
						classScope.owner.name += p.GetHashCode().ToString(CultureInfo.InvariantCulture);
					}
					continue;
				}
				field_table.Add(jSGlobalField);
				name_table[jSGlobalField.Name] = jSGlobalField;
				if (classScope != null)
				{
					classScope.owner.enclosingScope = this;
					classScope.package = this;
				}
			}
		}
	}
	internal sealed class ParameterDeclaration : ParameterInfo
	{
		internal string identifier;

		internal TypeExpression type;

		internal Context context;

		internal CustomAttributeList customAttributes;

		public override object DefaultValue => System.Convert.DBNull;

		public override string Name => identifier;

		internal IReflect ParameterIReflect => type.ToIReflect();

		public override Type ParameterType
		{
			get
			{
				Type type = this.type.ToType();
				if (type == Typeob.Void)
				{
					type = Typeob.Object;
				}
				return type;
			}
		}

		internal ParameterDeclaration(Context context, string identifier, TypeExpression type, CustomAttributeList customAttributes)
		{
			this.identifier = identifier;
			this.type = ((type == null) ? new TypeExpression(new ConstantWrapper(Typeob.Object, context)) : type);
			this.context = context;
			ActivationObject activationObject = (ActivationObject)context.document.engine.Globals.ScopeStack.Peek();
			if (activationObject.name_table[this.identifier] != null)
			{
				context.HandleError(JSError.DuplicateName, this.identifier, activationObject is ClassScope || activationObject.fast || type != null);
			}
			else
			{
				JSVariableField jSVariableField = activationObject.AddNewField(this.identifier, null, FieldAttributes.PrivateScope);
				jSVariableField.originalContext = context;
			}
			this.customAttributes = customAttributes;
		}

		internal ParameterDeclaration(Type type, string identifier)
		{
			this.identifier = identifier;
			this.type = new TypeExpression(new ConstantWrapper(type, null));
			customAttributes = null;
		}

		public override object[] GetCustomAttributes(bool inherit)
		{
			return new FieldInfo[0];
		}

		public override object[] GetCustomAttributes(Type attributeType, bool inherit)
		{
			return new FieldInfo[0];
		}

		public override bool IsDefined(Type attributeType, bool inherit)
		{
			if (customAttributes != null)
			{
				return customAttributes.GetAttribute(attributeType) != null;
			}
			return false;
		}

		internal void PartiallyEvaluate()
		{
			if (type != null)
			{
				type.PartiallyEvaluate();
			}
			if (customAttributes == null)
			{
				return;
			}
			customAttributes.PartiallyEvaluate();
			if (!CustomAttribute.IsDefined(this, typeof(ParamArrayAttribute), inherit: false))
			{
				return;
			}
			if (type != null)
			{
				IReflect reflect = type.ToIReflect();
				if ((reflect is Type && ((Type)reflect).IsArray) || reflect is TypedArray)
				{
					return;
				}
			}
			customAttributes.context.HandleError(JSError.IllegalParamArrayAttribute);
		}
	}
	/// <summary>Performs addition and concatenation operations. This class belongs to the abstract syntax tree category.</summary>
	public sealed class Plus : BinaryOp
	{
		private object metaData;

		internal Plus(Context context, AST operand1, AST operand2)
			: base(context, operand1, operand2, JSToken.FirstBinaryOp)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Plus" /> class.</summary>
		public Plus()
			: base(null, null, null, JSToken.FirstBinaryOp)
		{
		}

		internal override object Evaluate()
		{
			return EvaluatePlus(operand1.Evaluate(), operand2.Evaluate());
		}

		/// <summary>Performs an addition or concatenation operation.</summary>
		/// <param name="v1">The first operand.</param>
		/// <param name="v2">The second operand.</param>
		/// <returns>The result of the operation.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public object EvaluatePlus(object v1, object v2)
		{
			if (v1 is int && v2 is int)
			{
				return DoOp((int)v1, (int)v2);
			}
			if (v1 is double && v2 is double)
			{
				return DoOp((double)v1, (double)v2);
			}
			return EvaluatePlus2(v1, v2);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		private object EvaluatePlus2(object v1, object v2)
		{
			IConvertible iConvertible = Convert.GetIConvertible(v1);
			IConvertible iConvertible2 = Convert.GetIConvertible(v2);
			TypeCode typeCode = Convert.GetTypeCode(v1, iConvertible);
			TypeCode typeCode2 = Convert.GetTypeCode(v2, iConvertible2);
			switch (typeCode)
			{
			case TypeCode.Empty:
				return DoOp(v1, v2);
			case TypeCode.DBNull:
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return 0;
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
					return iConvertible2.ToInt32(null);
				case TypeCode.UInt32:
					return iConvertible2.ToUInt32(null);
				case TypeCode.Int64:
					return iConvertible2.ToInt64(null);
				case TypeCode.UInt64:
					return iConvertible2.ToUInt64(null);
				case TypeCode.Single:
				case TypeCode.Double:
					return iConvertible2.ToDouble(null);
				case TypeCode.String:
					return "null" + iConvertible2.ToString(null);
				}
				break;
			case TypeCode.Char:
			{
				int num8 = iConvertible.ToInt32(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return num8;
				case TypeCode.Boolean:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
					return ((IConvertible)DoOp(num8, iConvertible2.ToInt32(null))).ToChar(null);
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return ((IConvertible)DoOp(num8, iConvertible2.ToInt64(null))).ToChar(null);
				case TypeCode.UInt64:
					return ((IConvertible)DoOp((ulong)num8, iConvertible2.ToUInt64(null))).ToChar(null);
				case TypeCode.Single:
				case TypeCode.Double:
					return (char)checked((ushort)(int)Convert.CheckIfDoubleIsInteger((double)DoOp(num8, iConvertible2.ToDouble(null))));
				case TypeCode.Object:
				case TypeCode.Decimal:
				case TypeCode.DateTime:
					return DoOp(v1, v2);
				case TypeCode.Char:
				case TypeCode.String:
					return iConvertible.ToString(null) + iConvertible2.ToString(null);
				}
				break;
			}
			case TypeCode.Boolean:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			{
				int num7 = iConvertible.ToInt32(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return num7;
				case TypeCode.Char:
					return ((IConvertible)DoOp(num7, iConvertible2.ToInt32(null))).ToChar(null);
				case TypeCode.Boolean:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
					return DoOp(num7, iConvertible2.ToInt32(null));
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return DoOp(num7, iConvertible2.ToInt64(null));
				case TypeCode.UInt64:
					if (num7 >= 0)
					{
						return DoOp((ulong)num7, iConvertible2.ToUInt64(null));
					}
					return DoOp(num7, iConvertible2.ToDouble(null));
				case TypeCode.Single:
				case TypeCode.Double:
					return DoOp(num7, iConvertible2.ToDouble(null));
				case TypeCode.String:
					return Convert.ToString(v1) + iConvertible2.ToString(null);
				}
				break;
			}
			case TypeCode.UInt32:
			{
				uint num5 = iConvertible.ToUInt32(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return num5;
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.Int32:
				{
					int num6 = iConvertible2.ToInt32(null);
					if (num6 >= 0)
					{
						return DoOp(num5, (uint)num6);
					}
					return DoOp(num5, num6);
				}
				case TypeCode.Int64:
					return DoOp(num5, iConvertible2.ToInt64(null));
				case TypeCode.Char:
					return ((IConvertible)DoOp(num5, iConvertible2.ToUInt32(null))).ToChar(null);
				case TypeCode.Boolean:
				case TypeCode.UInt16:
				case TypeCode.UInt32:
					return DoOp(num5, iConvertible2.ToUInt32(null));
				case TypeCode.UInt64:
					return DoOp(num5, iConvertible2.ToUInt64(null));
				case TypeCode.Single:
				case TypeCode.Double:
					return DoOp(num5, iConvertible2.ToDouble(null));
				case TypeCode.String:
					return Convert.ToString(v1) + iConvertible2.ToString(null);
				}
				break;
			}
			case TypeCode.Int64:
			{
				long num4 = iConvertible.ToInt64(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return num4;
				case TypeCode.Char:
					return ((IConvertible)DoOp(num4, iConvertible2.ToInt64(null))).ToChar(null);
				case TypeCode.Boolean:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return DoOp(num4, iConvertible2.ToInt64(null));
				case TypeCode.UInt64:
					if (num4 >= 0)
					{
						return DoOp((ulong)num4, iConvertible2.ToUInt64(null));
					}
					return DoOp(num4, iConvertible2.ToDouble(null));
				case TypeCode.Single:
				case TypeCode.Double:
					return DoOp(num4, iConvertible2.ToDouble(null));
				case TypeCode.String:
					return Convert.ToString(v1) + iConvertible2.ToString(null);
				}
				break;
			}
			case TypeCode.UInt64:
			{
				ulong num2 = iConvertible.ToUInt64(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return num2;
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.Int32:
				case TypeCode.Int64:
				{
					long num3 = iConvertible2.ToInt64(null);
					if (num3 >= 0)
					{
						return DoOp(num2, (ulong)num3);
					}
					return DoOp(num2, num3);
				}
				case TypeCode.Char:
					return ((IConvertible)DoOp(num2, iConvertible2.ToUInt64(null))).ToChar(null);
				case TypeCode.Boolean:
				case TypeCode.UInt16:
				case TypeCode.UInt32:
				case TypeCode.UInt64:
					return DoOp(num2, iConvertible2.ToUInt64(null));
				case TypeCode.Single:
				case TypeCode.Double:
					return DoOp(num2, iConvertible2.ToDouble(null));
				case TypeCode.String:
					return Convert.ToString(v1) + iConvertible2.ToString(null);
				}
				break;
			}
			case TypeCode.Single:
			case TypeCode.Double:
			{
				double num = iConvertible.ToDouble(null);
				switch (typeCode2)
				{
				case TypeCode.Empty:
					return double.NaN;
				case TypeCode.DBNull:
					return iConvertible.ToDouble(null);
				case TypeCode.Char:
					return System.Convert.ToChar(System.Convert.ToInt32(num + (double)iConvertible2.ToInt32(null)));
				case TypeCode.Boolean:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
					return num + (double)iConvertible2.ToInt32(null);
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
					return num + iConvertible2.ToDouble(null);
				case TypeCode.String:
					return new ConcatString(Convert.ToString(num), iConvertible2.ToString(null));
				}
				break;
			}
			case TypeCode.String:
				switch (typeCode2)
				{
				case TypeCode.String:
					if (v1 is ConcatString)
					{
						return new ConcatString((ConcatString)v1, iConvertible2.ToString(null));
					}
					return new ConcatString(iConvertible.ToString(null), iConvertible2.ToString(null));
				default:
					if (v1 is ConcatString)
					{
						return new ConcatString((ConcatString)v1, Convert.ToString(v2));
					}
					return new ConcatString(iConvertible.ToString(null), Convert.ToString(v2));
				case TypeCode.Object:
					break;
				}
				break;
			}
			MethodInfo @operator = GetOperator((v1 == null) ? Typeob.Empty : v1.GetType(), (v2 == null) ? Typeob.Empty : v2.GetType());
			if (@operator != null)
			{
				return @operator.Invoke(null, BindingFlags.Default, JSBinder.ob, new object[2] { v1, v2 }, null);
			}
			return DoOp(v1, v2);
		}

		private new MethodInfo GetOperator(IReflect ir1, IReflect ir2)
		{
			Type type = ((ir1 is Type) ? ((Type)ir1) : Typeob.Object);
			Type type2 = ((ir2 is Type) ? ((Type)ir2) : Typeob.Object);
			if (type1 == type && base.type2 == type2)
			{
				return operatorMeth;
			}
			if (type == Typeob.String || type2 == Typeob.String || ((Convert.IsPrimitiveNumericType(type) || Typeob.JSObject.IsAssignableFrom(type)) && (Convert.IsPrimitiveNumericType(type2) || Typeob.JSObject.IsAssignableFrom(type2))))
			{
				operatorMeth = null;
				type1 = type;
				base.type2 = type2;
				return null;
			}
			return base.GetOperator((IReflect)type, (IReflect)type2);
		}

		private static object DoOp(double x, double y)
		{
			return x + y;
		}

		private static object DoOp(int x, int y)
		{
			int num = x + y;
			if (num < x == y < 0)
			{
				return num;
			}
			return (double)x + (double)y;
		}

		private static object DoOp(long x, long y)
		{
			long num = x + y;
			if (num < x == y < 0)
			{
				return num;
			}
			return (double)x + (double)y;
		}

		private static object DoOp(uint x, uint y)
		{
			uint num = x + y;
			if (num >= x)
			{
				return num;
			}
			return (double)x + (double)y;
		}

		private static object DoOp(ulong x, ulong y)
		{
			ulong num = x + y;
			if (num >= x)
			{
				return num;
			}
			return (double)x + (double)y;
		}

		/// <summary>Performs an addition or concatenation operation.</summary>
		/// <param name="v1">The first operand.</param>
		/// <param name="v2">The second operand.</param>
		/// <returns>The result of the operation.</returns>
		public static object DoOp(object v1, object v2)
		{
			IConvertible ic = Convert.GetIConvertible(v1);
			IConvertible ic2 = Convert.GetIConvertible(v2);
			v1 = Convert.ToPrimitive(v1, PreferredType.Either, ref ic);
			v2 = Convert.ToPrimitive(v2, PreferredType.Either, ref ic2);
			TypeCode typeCode = Convert.GetTypeCode(v1, ic);
			TypeCode typeCode2 = Convert.GetTypeCode(v2, ic2);
			if (typeCode == TypeCode.String)
			{
				if (v1 is ConcatString)
				{
					return new ConcatString((ConcatString)v1, Convert.ToString(v2, ic2));
				}
				return new ConcatString(ic.ToString(null), Convert.ToString(v2, ic2));
			}
			if (typeCode2 == TypeCode.String)
			{
				return Convert.ToString(v1, ic) + ic2.ToString(null);
			}
			if (typeCode == TypeCode.Char && typeCode2 == TypeCode.Char)
			{
				return ic.ToString(null) + ic2.ToString(null);
			}
			if ((typeCode == TypeCode.Char && (Convert.IsPrimitiveNumericTypeCode(typeCode2) || typeCode2 == TypeCode.Boolean)) || (typeCode2 == TypeCode.Char && (Convert.IsPrimitiveNumericTypeCode(typeCode) || typeCode == TypeCode.Boolean)))
			{
				return (char)Runtime.DoubleToInt64(Convert.ToNumber(v1, ic) + Convert.ToNumber(v2, ic2));
			}
			return Convert.ToNumber(v1, ic) + Convert.ToNumber(v2, ic2);
		}

		internal override IReflect InferType(JSField inference_target)
		{
			MethodInfo methodInfo = ((!(type1 == null) && !(inference_target != null)) ? GetOperator(type1, type2) : GetOperator(operand1.InferType(inference_target), operand2.InferType(inference_target)));
			if (methodInfo != null)
			{
				metaData = methodInfo;
				return methodInfo.ReturnType;
			}
			if (type1 == Typeob.String || type2 == Typeob.String)
			{
				return Typeob.String;
			}
			if (type1 == Typeob.Char && type2 == Typeob.Char)
			{
				return Typeob.String;
			}
			if (Convert.IsPrimitiveNumericTypeFitForDouble(type1))
			{
				if (type2 == Typeob.Char)
				{
					return Typeob.Char;
				}
				if (Convert.IsPrimitiveNumericTypeFitForDouble(type2))
				{
					return Typeob.Double;
				}
				return Typeob.Object;
			}
			if (Convert.IsPrimitiveNumericTypeFitForDouble(type2))
			{
				if (type1 == Typeob.Char)
				{
					return Typeob.Char;
				}
				if (Convert.IsPrimitiveNumericTypeFitForDouble(type1))
				{
					return Typeob.Double;
				}
				return Typeob.Object;
			}
			if (type1 == Typeob.Boolean && type2 == Typeob.Char)
			{
				return Typeob.Char;
			}
			if (type1 == Typeob.Char && type2 == Typeob.Boolean)
			{
				return Typeob.Char;
			}
			return Typeob.Object;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Type type = Convert.ToType(InferType(null));
			if (metaData == null)
			{
				Type @object = Typeob.Object;
				@object = ((rtype == Typeob.Double) ? rtype : ((type1 == Typeob.Char && type2 == Typeob.Char) ? Typeob.String : ((Convert.IsPrimitiveNumericType(rtype) && Convert.IsPromotableTo(type1, rtype) && Convert.IsPromotableTo(type2, rtype)) ? rtype : ((!(type1 != Typeob.String) || !(type2 != Typeob.String)) ? Typeob.String : Typeob.Double))));
				if (@object == Typeob.SByte || @object == Typeob.Int16)
				{
					@object = Typeob.Int32;
				}
				else if (@object == Typeob.Byte || @object == Typeob.UInt16 || @object == Typeob.Char)
				{
					@object = Typeob.UInt32;
				}
				if (@object == Typeob.String)
				{
					if (operand1 is Plus && type1 == @object)
					{
						Plus plus = (Plus)operand1;
						if (plus.operand1 is Plus && plus.type1 == @object)
						{
							Plus plus2 = (Plus)plus.operand1;
							if (plus2.operand1 is Plus && plus2.type1 == @object)
							{
								int num = plus.TranslateToILArrayOfStrings(il, 1);
								il.Emit(OpCodes.Dup);
								ConstantWrapper.TranslateToILInt(il, num - 1);
								operand2.TranslateToIL(il, @object);
								il.Emit(OpCodes.Stelem_Ref);
								il.Emit(OpCodes.Call, CompilerGlobals.stringConcatArrMethod);
								Convert.Emit(this, il, @object, rtype);
							}
							else
							{
								TranslateToStringWithSpecialCaseForNull(il, plus2.operand1);
								TranslateToStringWithSpecialCaseForNull(il, plus2.operand2);
								TranslateToStringWithSpecialCaseForNull(il, plus.operand2);
								TranslateToStringWithSpecialCaseForNull(il, operand2);
								il.Emit(OpCodes.Call, CompilerGlobals.stringConcat4Method);
								Convert.Emit(this, il, @object, rtype);
							}
						}
						else
						{
							TranslateToStringWithSpecialCaseForNull(il, plus.operand1);
							TranslateToStringWithSpecialCaseForNull(il, plus.operand2);
							TranslateToStringWithSpecialCaseForNull(il, operand2);
							il.Emit(OpCodes.Call, CompilerGlobals.stringConcat3Method);
							Convert.Emit(this, il, @object, rtype);
						}
					}
					else
					{
						TranslateToStringWithSpecialCaseForNull(il, operand1);
						TranslateToStringWithSpecialCaseForNull(il, operand2);
						il.Emit(OpCodes.Call, CompilerGlobals.stringConcat2Method);
						Convert.Emit(this, il, @object, rtype);
					}
				}
				else
				{
					operand1.TranslateToIL(il, @object);
					operand2.TranslateToIL(il, @object);
					if (@object == Typeob.Object)
					{
						il.Emit(OpCodes.Call, CompilerGlobals.plusDoOpMethod);
					}
					else if (@object == Typeob.Double || @object == Typeob.Single)
					{
						il.Emit(OpCodes.Add);
					}
					else if (@object == Typeob.Int32 || @object == Typeob.Int64)
					{
						il.Emit(OpCodes.Add_Ovf);
					}
					else
					{
						il.Emit(OpCodes.Add_Ovf_Un);
					}
					if (type == Typeob.Char)
					{
						Convert.Emit(this, il, @object, Typeob.Char);
						Convert.Emit(this, il, Typeob.Char, rtype);
					}
					else
					{
						Convert.Emit(this, il, @object, rtype);
					}
				}
			}
			else if (metaData is MethodInfo)
			{
				MethodInfo methodInfo = (MethodInfo)metaData;
				ParameterInfo[] parameters = methodInfo.GetParameters();
				operand1.TranslateToIL(il, parameters[0].ParameterType);
				operand2.TranslateToIL(il, parameters[1].ParameterType);
				il.Emit(OpCodes.Call, methodInfo);
				Convert.Emit(this, il, methodInfo.ReturnType, rtype);
			}
			else
			{
				il.Emit(OpCodes.Ldloc, (LocalBuilder)metaData);
				operand1.TranslateToIL(il, Typeob.Object);
				operand2.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Callvirt, CompilerGlobals.evaluatePlusMethod);
				Convert.Emit(this, il, Typeob.Object, rtype);
			}
		}

		private int TranslateToILArrayOfStrings(ILGenerator il, int n)
		{
			int num = n + 2;
			if (operand1 is Plus && type1 == Typeob.String)
			{
				num = ((Plus)operand1).TranslateToILArrayOfStrings(il, n + 1);
			}
			else
			{
				ConstantWrapper.TranslateToILInt(il, num);
				il.Emit(OpCodes.Newarr, Typeob.String);
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Ldc_I4_0);
				TranslateToStringWithSpecialCaseForNull(il, operand1);
				il.Emit(OpCodes.Stelem_Ref);
			}
			il.Emit(OpCodes.Dup);
			ConstantWrapper.TranslateToILInt(il, num - 1 - n);
			TranslateToStringWithSpecialCaseForNull(il, operand2);
			il.Emit(OpCodes.Stelem_Ref);
			return num;
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			IReflect reflect = InferType(null);
			operand1.TranslateToILInitializer(il);
			operand2.TranslateToILInitializer(il);
			if (reflect == Typeob.Object)
			{
				metaData = il.DeclareLocal(Typeob.Plus);
				il.Emit(OpCodes.Newobj, CompilerGlobals.plusConstructor);
				il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
			}
		}

		private static void TranslateToStringWithSpecialCaseForNull(ILGenerator il, AST operand)
		{
			if (operand is ConstantWrapper constantWrapper)
			{
				if (constantWrapper.value is DBNull)
				{
					il.Emit(OpCodes.Ldstr, "null");
				}
				else if (constantWrapper.value == Empty.Value)
				{
					il.Emit(OpCodes.Ldstr, "undefined");
				}
				else
				{
					constantWrapper.TranslateToIL(il, Typeob.String);
				}
			}
			else
			{
				operand.TranslateToIL(il, Typeob.String);
			}
		}
	}
	internal sealed class PlusAssign : BinaryOp
	{
		private Plus binOp;

		private object metaData;

		internal PlusAssign(Context context, AST operand1, AST operand2)
			: base(context, operand1, operand2, JSToken.FirstBinaryOp)
		{
			binOp = new Plus(context, operand1, operand2);
			metaData = null;
		}

		internal override object Evaluate()
		{
			object v = operand1.Evaluate();
			object v2 = operand2.Evaluate();
			object obj = binOp.EvaluatePlus(v, v2);
			try
			{
				operand1.SetValue(obj);
				return obj;
			}
			catch (JScriptException ex)
			{
				if (ex.context == null)
				{
					ex.context = context;
				}
				throw ex;
			}
			catch (Exception e)
			{
				throw new JScriptException(e, context);
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			MethodInfo methodInfo = ((!(type1 == null) && !(inference_target != null)) ? GetOperator(type1, type2) : GetOperator(operand1.InferType(inference_target), operand2.InferType(inference_target)));
			if (methodInfo != null)
			{
				metaData = methodInfo;
				return methodInfo.ReturnType;
			}
			if (type1 == Typeob.String || type2 == Typeob.String)
			{
				return Typeob.String;
			}
			if (Convert.IsPrimitiveNumericType(type1))
			{
				if (Convert.IsPromotableTo(type2, type1) || (operand2 is ConstantWrapper && ((ConstantWrapper)operand2).IsAssignableTo(type1)))
				{
					return type1;
				}
				if (Convert.IsPrimitiveNumericType(type1) && Convert.IsPrimitiveNumericTypeFitForDouble(type2))
				{
					return Typeob.Double;
				}
			}
			return Typeob.Object;
		}

		internal override AST PartiallyEvaluate()
		{
			operand1 = operand1.PartiallyEvaluateAsReference();
			operand2 = operand2.PartiallyEvaluate();
			binOp = new Plus(context, operand1, operand2);
			operand1.SetPartialValue(binOp);
			if (base.Engine.doFast && operand1 is Binding binding && binding.member is JSVariableField)
			{
				TypeExpression type = ((JSVariableField)binding.member).type;
				if (type != null && type.InferType(null) == Typeob.String)
				{
					operand1.context.HandleError(JSError.StringConcatIsSlow);
				}
			}
			return this;
		}

		private void TranslateToILForNoOverloadCase(ILGenerator il, Type rtype)
		{
			Type type = Convert.ToType(operand1.InferType(null));
			Type type2 = Convert.ToType(operand2.InferType(null));
			Type type3 = Typeob.Object;
			if (type == Typeob.String || type2 == Typeob.String)
			{
				type3 = Typeob.String;
			}
			else if (rtype == Typeob.Void || rtype == type || (Convert.IsPrimitiveNumericType(type) && (Convert.IsPromotableTo(type2, type) || (operand2 is ConstantWrapper && ((ConstantWrapper)operand2).IsAssignableTo(type)))))
			{
				type3 = type;
			}
			if (type3 == Typeob.SByte || type3 == Typeob.Int16)
			{
				type3 = Typeob.Int32;
			}
			else if (type3 == Typeob.Byte || type3 == Typeob.UInt16)
			{
				type3 = Typeob.UInt32;
			}
			if (operand2 is ConstantWrapper)
			{
				if (!((ConstantWrapper)operand2).IsAssignableTo(type3))
				{
					type3 = Typeob.Object;
				}
			}
			else if ((Convert.IsPrimitiveSignedNumericType(type2) && Convert.IsPrimitiveUnsignedIntegerType(type)) || (Convert.IsPrimitiveUnsignedIntegerType(type2) && Convert.IsPrimitiveSignedIntegerType(type)))
			{
				type3 = Typeob.Object;
			}
			operand1.TranslateToILPreSetPlusGet(il);
			Convert.Emit(this, il, type, type3);
			operand2.TranslateToIL(il, type3);
			if (type3 == Typeob.Object || type3 == Typeob.String)
			{
				il.Emit(OpCodes.Call, CompilerGlobals.plusDoOpMethod);
				type3 = Typeob.Object;
			}
			else if (type3 == Typeob.Double || type3 == Typeob.Single)
			{
				il.Emit(OpCodes.Add);
			}
			else if (type3 == Typeob.Int32 || type3 == Typeob.Int64 || type3 == Typeob.Int16 || type3 == Typeob.SByte)
			{
				il.Emit(OpCodes.Add_Ovf);
			}
			else
			{
				il.Emit(OpCodes.Add_Ovf_Un);
			}
			if (rtype != Typeob.Void)
			{
				LocalBuilder local = il.DeclareLocal(type3);
				il.Emit(OpCodes.Dup);
				il.Emit(OpCodes.Stloc, local);
				Convert.Emit(this, il, type3, type);
				operand1.TranslateToILSet(il);
				il.Emit(OpCodes.Ldloc, local);
				Convert.Emit(this, il, type3, rtype);
			}
			else
			{
				Convert.Emit(this, il, type3, type);
				operand1.TranslateToILSet(il);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (metaData == null)
			{
				TranslateToILForNoOverloadCase(il, rtype);
			}
			else if (metaData is MethodInfo)
			{
				object obj = null;
				MethodInfo methodInfo = (MethodInfo)metaData;
				Type type = Convert.ToType(operand1.InferType(null));
				ParameterInfo[] parameters = methodInfo.GetParameters();
				operand1.TranslateToILPreSetPlusGet(il);
				Convert.Emit(this, il, type, parameters[0].ParameterType);
				operand2.TranslateToIL(il, parameters[1].ParameterType);
				il.Emit(OpCodes.Call, methodInfo);
				if (rtype != Typeob.Void)
				{
					obj = il.DeclareLocal(rtype);
					il.Emit(OpCodes.Dup);
					Convert.Emit(this, il, type, rtype);
					il.Emit(OpCodes.Stloc, (LocalBuilder)obj);
				}
				Convert.Emit(this, il, methodInfo.ReturnType, type);
				operand1.TranslateToILSet(il);
				if (rtype != Typeob.Void)
				{
					il.Emit(OpCodes.Ldloc, (LocalBuilder)obj);
				}
			}
			else
			{
				Type type2 = Convert.ToType(operand1.InferType(null));
				LocalBuilder local = il.DeclareLocal(Typeob.Object);
				operand1.TranslateToILPreSetPlusGet(il);
				Convert.Emit(this, il, type2, Typeob.Object);
				il.Emit(OpCodes.Stloc, local);
				il.Emit(OpCodes.Ldloc, (LocalBuilder)metaData);
				il.Emit(OpCodes.Ldloc, local);
				operand2.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.evaluatePlusMethod);
				if (rtype != Typeob.Void)
				{
					il.Emit(OpCodes.Dup);
					il.Emit(OpCodes.Stloc, local);
				}
				Convert.Emit(this, il, Typeob.Object, type2);
				operand1.TranslateToILSet(il);
				if (rtype != Typeob.Void)
				{
					il.Emit(OpCodes.Ldloc, local);
					Convert.Emit(this, il, Typeob.Object, rtype);
				}
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			IReflect reflect = InferType(null);
			operand1.TranslateToILInitializer(il);
			operand2.TranslateToILInitializer(il);
			if (reflect == Typeob.Object)
			{
				metaData = il.DeclareLocal(Typeob.Plus);
				il.Emit(OpCodes.Newobj, CompilerGlobals.plusConstructor);
				il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
			}
		}
	}
	internal enum PostOrPrefix
	{
		PostfixDecrement,
		PostfixIncrement,
		PrefixDecrement,
		PrefixIncrement
	}
	/// <summary>Performs increment and decrement operations that correspond to the prefix and postfix syntax. This class belongs to the abstract syntax tree category.</summary>
	public class PostOrPrefixOperator : UnaryOp
	{
		private MethodInfo operatorMeth;

		private PostOrPrefix operatorTok;

		private object metaData;

		private Type type;

		internal PostOrPrefixOperator(Context context, AST operand)
			: base(context, operand)
		{
		}

		internal PostOrPrefixOperator(Context context, AST operand, PostOrPrefix operatorTok)
			: base(context, operand)
		{
			operatorMeth = null;
			this.operatorTok = operatorTok;
			metaData = null;
			type = null;
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.PostOrPrefixOperator" /> class.</summary>
		/// <param name="operatorTok">One of the <see cref="T:Microsoft.JScript.JSToken" /> enumeration values. Specifies the operation to perform.</param>
		public PostOrPrefixOperator(int operatorTok)
			: this(null, null, (PostOrPrefix)operatorTok)
		{
		}

		private object DoOp(int i)
		{
			PostOrPrefix postOrPrefix = operatorTok;
			if (postOrPrefix == PostOrPrefix.PostfixIncrement || postOrPrefix == PostOrPrefix.PrefixIncrement)
			{
				if (i == int.MaxValue)
				{
					return 2147483648.0;
				}
				return i + 1;
			}
			if (i == int.MinValue)
			{
				return -2147483649.0;
			}
			return i - 1;
		}

		private object DoOp(uint i)
		{
			PostOrPrefix postOrPrefix = operatorTok;
			if (postOrPrefix == PostOrPrefix.PostfixIncrement || postOrPrefix == PostOrPrefix.PrefixIncrement)
			{
				if (i == uint.MaxValue)
				{
					return 4294967296.0;
				}
				return i + 1;
			}
			if (i == 0)
			{
				return -1.0;
			}
			return i - 1;
		}

		private object DoOp(long i)
		{
			PostOrPrefix postOrPrefix = operatorTok;
			if (postOrPrefix == PostOrPrefix.PostfixIncrement || postOrPrefix == PostOrPrefix.PrefixIncrement)
			{
				if (i == long.MaxValue)
				{
					return 9.2233720368547758E+18;
				}
				return i + 1;
			}
			if (i == long.MinValue)
			{
				return -9.2233720368547758E+18;
			}
			return i - 1;
		}

		private object DoOp(ulong i)
		{
			PostOrPrefix postOrPrefix = operatorTok;
			if (postOrPrefix == PostOrPrefix.PostfixIncrement || postOrPrefix == PostOrPrefix.PrefixIncrement)
			{
				if (i == ulong.MaxValue)
				{
					return 1.8446744073709552E+19;
				}
				return i + 1;
			}
			if (i == 0L)
			{
				return -1.0;
			}
			return i - 1;
		}

		private object DoOp(double d)
		{
			PostOrPrefix postOrPrefix = operatorTok;
			if (postOrPrefix == PostOrPrefix.PostfixIncrement || postOrPrefix == PostOrPrefix.PrefixIncrement)
			{
				return d + 1.0;
			}
			return d - 1.0;
		}

		internal override object Evaluate()
		{
			try
			{
				object v = operand.Evaluate();
				object obj = EvaluatePostOrPrefix(ref v);
				operand.SetValue(obj);
				switch (operatorTok)
				{
				case PostOrPrefix.PostfixDecrement:
				case PostOrPrefix.PostfixIncrement:
					return v;
				case PostOrPrefix.PrefixDecrement:
				case PostOrPrefix.PrefixIncrement:
					return obj;
				default:
					throw new JScriptException(JSError.InternalError, context);
				}
			}
			catch (JScriptException ex)
			{
				if (ex.context == null)
				{
					ex.context = context;
				}
				throw ex;
			}
			catch (Exception e)
			{
				throw new JScriptException(e, context);
			}
		}

		/// <summary>Performs an increment or decrement operation on the specified operand.</summary>
		/// <param name="v">The operand.</param>
		/// <returns>The result of the operation.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public object EvaluatePostOrPrefix(ref object v)
		{
			IConvertible iConvertible = Convert.GetIConvertible(v);
			switch (Convert.GetTypeCode(v, iConvertible))
			{
			case TypeCode.Empty:
				v = double.NaN;
				return v;
			case TypeCode.DBNull:
				v = 0;
				return DoOp(0);
			case TypeCode.Boolean:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			{
				int i4;
				v = (i4 = iConvertible.ToInt32(null));
				return DoOp(i4);
			}
			case TypeCode.Char:
			{
				int i4 = iConvertible.ToInt32(null);
				return ((IConvertible)DoOp(i4)).ToChar(null);
			}
			case TypeCode.UInt32:
			{
				uint i3;
				v = (i3 = iConvertible.ToUInt32(null));
				return DoOp(i3);
			}
			case TypeCode.Int64:
			{
				long i2;
				v = (i2 = iConvertible.ToInt64(null));
				return DoOp(i2);
			}
			case TypeCode.UInt64:
			{
				ulong i;
				v = (i = iConvertible.ToUInt64(null));
				return DoOp(i);
			}
			case TypeCode.Single:
			case TypeCode.Double:
			{
				double d;
				v = (d = iConvertible.ToDouble(null));
				return DoOp(d);
			}
			default:
			{
				MethodInfo @operator = GetOperator(v.GetType());
				if (@operator != null)
				{
					return @operator.Invoke(null, BindingFlags.Default, JSBinder.ob, new object[1] { v }, null);
				}
				double d;
				v = (d = Convert.ToNumber(v, iConvertible));
				return DoOp(d);
			}
			}
		}

		private MethodInfo GetOperator(IReflect ir)
		{
			Type type = ((ir is Type) ? ((Type)ir) : Typeob.Object);
			if (this.type == type)
			{
				return operatorMeth;
			}
			this.type = type;
			if (Convert.IsPrimitiveNumericType(type) || Typeob.JSObject.IsAssignableFrom(type))
			{
				operatorMeth = null;
				return null;
			}
			switch (operatorTok)
			{
			case PostOrPrefix.PostfixDecrement:
			case PostOrPrefix.PrefixDecrement:
				operatorMeth = type.GetMethod("op_Decrement", BindingFlags.Static | BindingFlags.Public, JSBinder.ob, new Type[1] { type }, null);
				break;
			case PostOrPrefix.PostfixIncrement:
			case PostOrPrefix.PrefixIncrement:
				operatorMeth = type.GetMethod("op_Increment", BindingFlags.Static | BindingFlags.Public, JSBinder.ob, new Type[1] { type }, null);
				break;
			default:
				throw new JScriptException(JSError.InternalError, context);
			}
			if (operatorMeth != null && (!operatorMeth.IsStatic || (operatorMeth.Attributes & MethodAttributes.SpecialName) == 0 || operatorMeth.GetParameters().Length != 1))
			{
				operatorMeth = null;
			}
			if (operatorMeth != null)
			{
				operatorMeth = new JSMethodInfo(operatorMeth);
			}
			return operatorMeth;
		}

		internal override IReflect InferType(JSField inference_target)
		{
			MethodInfo methodInfo = ((!(type == null) && !(inference_target != null)) ? GetOperator(type) : GetOperator(operand.InferType(inference_target)));
			if (methodInfo != null)
			{
				metaData = methodInfo;
				return methodInfo.ReturnType;
			}
			if (Convert.IsPrimitiveNumericType(type))
			{
				return type;
			}
			if (type == Typeob.Char)
			{
				return type;
			}
			if (Typeob.JSObject.IsAssignableFrom(type))
			{
				return Typeob.Double;
			}
			return Typeob.Object;
		}

		internal override AST PartiallyEvaluate()
		{
			operand = operand.PartiallyEvaluateAsReference();
			operand.SetPartialValue(this);
			return this;
		}

		private void TranslateToILForNoOverloadCase(ILGenerator il, Type rtype)
		{
			Type type = Convert.ToType(operand.InferType(null));
			operand.TranslateToILPreSetPlusGet(il);
			if (rtype == Typeob.Void)
			{
				Type type2 = Typeob.Double;
				if (Convert.IsPrimitiveNumericType(type))
				{
					type2 = ((!(type == Typeob.SByte) && !(type == Typeob.Int16)) ? ((!(type == Typeob.Byte) && !(type == Typeob.UInt16) && !(type == Typeob.Char)) ? type : Typeob.UInt32) : Typeob.Int32);
				}
				Convert.Emit(this, il, type, type2);
				il.Emit(OpCodes.Ldc_I4_1);
				Convert.Emit(this, il, Typeob.Int32, type2);
				if (type2 == Typeob.Double || type2 == Typeob.Single)
				{
					if (operatorTok == PostOrPrefix.PostfixDecrement || operatorTok == PostOrPrefix.PrefixDecrement)
					{
						il.Emit(OpCodes.Sub);
					}
					else
					{
						il.Emit(OpCodes.Add);
					}
				}
				else if (type2 == Typeob.Int32 || type2 == Typeob.Int64)
				{
					if (operatorTok == PostOrPrefix.PostfixDecrement || operatorTok == PostOrPrefix.PrefixDecrement)
					{
						il.Emit(OpCodes.Sub_Ovf);
					}
					else
					{
						il.Emit(OpCodes.Add_Ovf);
					}
				}
				else if (operatorTok == PostOrPrefix.PostfixDecrement || operatorTok == PostOrPrefix.PrefixDecrement)
				{
					il.Emit(OpCodes.Sub_Ovf_Un);
				}
				else
				{
					il.Emit(OpCodes.Add_Ovf_Un);
				}
				Convert.Emit(this, il, type2, type);
				operand.TranslateToILSet(il);
				return;
			}
			Type type3 = Typeob.Double;
			if (Convert.IsPrimitiveNumericType(rtype) && Convert.IsPromotableTo(type, rtype))
			{
				type3 = rtype;
			}
			else if (Convert.IsPrimitiveNumericType(type) && Convert.IsPromotableTo(rtype, type))
			{
				type3 = type;
			}
			if (type3 == Typeob.SByte || type3 == Typeob.Int16)
			{
				type3 = Typeob.Int32;
			}
			else if (type3 == Typeob.Byte || type3 == Typeob.UInt16 || type3 == Typeob.Char)
			{
				type3 = Typeob.UInt32;
			}
			LocalBuilder local = il.DeclareLocal(rtype);
			Convert.Emit(this, il, type, type3);
			if (operatorTok == PostOrPrefix.PostfixDecrement)
			{
				il.Emit(OpCodes.Dup);
				if (type == Typeob.Char)
				{
					Convert.Emit(this, il, type3, Typeob.Char);
					Convert.Emit(this, il, Typeob.Char, rtype);
				}
				else
				{
					Convert.Emit(this, il, type3, rtype);
				}
				il.Emit(OpCodes.Stloc, local);
				il.Emit(OpCodes.Ldc_I4_1);
				Convert.Emit(this, il, Typeob.Int32, type3);
				if (type3 == Typeob.Double || type3 == Typeob.Single)
				{
					il.Emit(OpCodes.Sub);
				}
				else if (type3 == Typeob.Int32 || type3 == Typeob.Int64)
				{
					il.Emit(OpCodes.Sub_Ovf);
				}
				else
				{
					il.Emit(OpCodes.Sub_Ovf_Un);
				}
			}
			else if (operatorTok == PostOrPrefix.PostfixIncrement)
			{
				il.Emit(OpCodes.Dup);
				if (type == Typeob.Char)
				{
					Convert.Emit(this, il, type3, Typeob.Char);
					Convert.Emit(this, il, Typeob.Char, rtype);
				}
				else
				{
					Convert.Emit(this, il, type3, rtype);
				}
				il.Emit(OpCodes.Stloc, local);
				il.Emit(OpCodes.Ldc_I4_1);
				Convert.Emit(this, il, Typeob.Int32, type3);
				if (type3 == Typeob.Double || type3 == Typeob.Single)
				{
					il.Emit(OpCodes.Add);
				}
				else if (type3 == Typeob.Int32 || type3 == Typeob.Int64)
				{
					il.Emit(OpCodes.Add_Ovf);
				}
				else
				{
					il.Emit(OpCodes.Add_Ovf_Un);
				}
			}
			else if (operatorTok == PostOrPrefix.PrefixDecrement)
			{
				il.Emit(OpCodes.Ldc_I4_1);
				Convert.Emit(this, il, Typeob.Int32, type3);
				if (type3 == Typeob.Double || type3 == Typeob.Single)
				{
					il.Emit(OpCodes.Sub);
				}
				else if (type3 == Typeob.Int32 || type3 == Typeob.Int64)
				{
					il.Emit(OpCodes.Sub_Ovf);
				}
				else
				{
					il.Emit(OpCodes.Sub_Ovf_Un);
				}
				il.Emit(OpCodes.Dup);
				if (type == Typeob.Char)
				{
					Convert.Emit(this, il, type3, Typeob.Char);
					Convert.Emit(this, il, Typeob.Char, rtype);
				}
				else
				{
					Convert.Emit(this, il, type3, rtype);
				}
				il.Emit(OpCodes.Stloc, local);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_1);
				Convert.Emit(this, il, Typeob.Int32, type3);
				if (type3 == Typeob.Double || type3 == Typeob.Single)
				{
					il.Emit(OpCodes.Add);
				}
				else if (type3 == Typeob.Int32 || type3 == Typeob.Int64)
				{
					il.Emit(OpCodes.Add_Ovf);
				}
				else
				{
					il.Emit(OpCodes.Add_Ovf_Un);
				}
				il.Emit(OpCodes.Dup);
				if (type == Typeob.Char)
				{
					Convert.Emit(this, il, type3, Typeob.Char);
					Convert.Emit(this, il, Typeob.Char, rtype);
				}
				else
				{
					Convert.Emit(this, il, type3, rtype);
				}
				il.Emit(OpCodes.Stloc, local);
			}
			Convert.Emit(this, il, type3, type);
			operand.TranslateToILSet(il);
			il.Emit(OpCodes.Ldloc, local);
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (metaData == null)
			{
				TranslateToILForNoOverloadCase(il, rtype);
			}
			else if (metaData is MethodInfo)
			{
				object obj = null;
				Type type = Convert.ToType(operand.InferType(null));
				operand.TranslateToILPreSetPlusGet(il);
				if (rtype != Typeob.Void)
				{
					obj = il.DeclareLocal(rtype);
					if (operatorTok == PostOrPrefix.PostfixDecrement || operatorTok == PostOrPrefix.PostfixIncrement)
					{
						il.Emit(OpCodes.Dup);
						Convert.Emit(this, il, type, rtype);
						il.Emit(OpCodes.Stloc, (LocalBuilder)obj);
					}
				}
				MethodInfo methodInfo = (MethodInfo)metaData;
				ParameterInfo[] parameters = methodInfo.GetParameters();
				Convert.Emit(this, il, type, parameters[0].ParameterType);
				il.Emit(OpCodes.Call, methodInfo);
				if (rtype != Typeob.Void && (operatorTok == PostOrPrefix.PrefixDecrement || operatorTok == PostOrPrefix.PrefixIncrement))
				{
					il.Emit(OpCodes.Dup);
					Convert.Emit(this, il, type, rtype);
					il.Emit(OpCodes.Stloc, (LocalBuilder)obj);
				}
				Convert.Emit(this, il, methodInfo.ReturnType, type);
				operand.TranslateToILSet(il);
				if (rtype != Typeob.Void)
				{
					il.Emit(OpCodes.Ldloc, (LocalBuilder)obj);
				}
			}
			else
			{
				Type type2 = Convert.ToType(operand.InferType(null));
				LocalBuilder local = il.DeclareLocal(Typeob.Object);
				operand.TranslateToILPreSetPlusGet(il);
				Convert.Emit(this, il, type2, Typeob.Object);
				il.Emit(OpCodes.Stloc, local);
				il.Emit(OpCodes.Ldloc, (LocalBuilder)metaData);
				il.Emit(OpCodes.Ldloca, local);
				il.Emit(OpCodes.Call, CompilerGlobals.evaluatePostOrPrefixOperatorMethod);
				if (rtype != Typeob.Void && (operatorTok == PostOrPrefix.PrefixDecrement || operatorTok == PostOrPrefix.PrefixIncrement))
				{
					il.Emit(OpCodes.Dup);
					il.Emit(OpCodes.Stloc, local);
				}
				Convert.Emit(this, il, Typeob.Object, type2);
				operand.TranslateToILSet(il);
				if (rtype != Typeob.Void)
				{
					il.Emit(OpCodes.Ldloc, local);
					Convert.Emit(this, il, Typeob.Object, rtype);
				}
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			IReflect reflect = InferType(null);
			operand.TranslateToILInitializer(il);
			if (reflect == Typeob.Object)
			{
				metaData = il.DeclareLocal(Typeob.PostOrPrefixOperator);
				ConstantWrapper.TranslateToILInt(il, (int)operatorTok);
				il.Emit(OpCodes.Newobj, CompilerGlobals.postOrPrefixConstructor);
				il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
			}
		}
	}
	internal sealed class Print : AST
	{
		private ASTList operand;

		private Completion completion;

		internal Print(Context context, AST operand)
			: base(context)
		{
			this.operand = (ASTList)operand;
			completion = new Completion();
		}

		internal override object Evaluate()
		{
			object[] array = operand.EvaluateAsArray();
			for (int i = 0; i < array.Length - 1; i++)
			{
				ScriptStream.Out.Write(Convert.ToString(array[i]));
			}
			if (array.Length != 0)
			{
				completion.value = Convert.ToString(array[array.Length - 1]);
				ScriptStream.Out.WriteLine(completion.value);
			}
			else
			{
				ScriptStream.Out.WriteLine("");
				completion.value = null;
			}
			return completion;
		}

		internal override AST PartiallyEvaluate()
		{
			operand = (ASTList)operand.PartiallyEvaluate();
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (context.document.debugOn)
			{
				il.Emit(OpCodes.Nop);
			}
			ASTList aSTList = operand;
			int count = aSTList.count;
			for (int i = 0; i < count; i++)
			{
				AST aST = aSTList[i];
				IReflect reflect = aST.InferType(null);
				if (reflect == Typeob.String)
				{
					aST.TranslateToIL(il, Typeob.String);
				}
				else
				{
					aST.TranslateToIL(il, Typeob.Object);
					ConstantWrapper.TranslateToILInt(il, 1);
					il.Emit(OpCodes.Call, CompilerGlobals.toStringMethod);
				}
				if (i == count - 1)
				{
					il.Emit(OpCodes.Call, CompilerGlobals.writeLineMethod);
				}
				else
				{
					il.Emit(OpCodes.Call, CompilerGlobals.writeMethod);
				}
			}
			if (count == 0)
			{
				il.Emit(OpCodes.Ldstr, "");
				il.Emit(OpCodes.Call, CompilerGlobals.writeLineMethod);
			}
			if (rtype != Typeob.Void)
			{
				il.Emit(OpCodes.Ldsfld, CompilerGlobals.undefinedField);
				Convert.Emit(this, il, Typeob.Object, rtype);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			ASTList aSTList = operand;
			for (int i = 0; i < aSTList.count; i++)
			{
				aSTList[i].TranslateToILInitializer(il);
			}
		}
	}
	internal class RangeEnumerator : IEnumerator
	{
		private int curr;

		private int start;

		private int stop;

		public virtual object Current => curr;

		internal RangeEnumerator(int start, int stop)
		{
			curr = start - 1;
			this.start = start;
			this.stop = stop;
		}

		public virtual bool MoveNext()
		{
			return ++curr <= stop;
		}

		public virtual void Reset()
		{
			curr = start - 1;
		}
	}
	/// <summary>Represents a range error. For example, a range error can occur when you use an incorrect index to access an array element.</summary>
	public sealed class RangeErrorObject : ErrorObject
	{
		internal RangeErrorObject(ErrorPrototype parent, object[] args)
			: base(parent, args)
		{
		}

		internal RangeErrorObject(ErrorPrototype parent, object e)
			: base(parent, e)
		{
		}
	}
	/// <summary>Defines methods that capture output that would otherwise go to the console. This interface is implemented by the <see cref="T:Microsoft.JScript.Vsa.VsaEngine" />.</summary>
	[Guid("5B807FA1-00CD-46ee-A493-FD80AC944715")]
	[ComVisible(true)]
	public interface IRedirectOutput
	{
		/// <summary>When implemented in a class, redirects the specified output stream to a new stream or data storage.</summary>
		/// <param name="output">The output to redirect.</param>
		void SetOutputStream(IMessageReceiver output);
	}
	/// <summary>Defines methods that receive output from a scripting engine. This interface acts as a callback object to capture output that would otherwise go to the console.</summary>
	[Guid("F062C7FB-53BF-4f0d-B0F6-D66C5948E63F")]
	[ComVisible(true)]
	public interface IMessageReceiver
	{
		/// <summary>When implemented in a class, captures the specified output.</summary>
		/// <param name="strValue">The output to capture.</param>
		void Message(string strValue);
	}
	/// <summary>Represents a stream that sends its data to an <see cref="T:Microsoft.JScript.IMessageReceiver" />. The data is stored in a buffer until the data is flushed or the stream is closed.</summary>
	public class COMCharStream : Stream
	{
		private IMessageReceiver messageReceiver;

		private StringBuilder buffer;

		/// <summary>Gets a value that indicates whether the current stream supports writing.</summary>
		/// <returns>
		///   <see langword="true" /> in all cases.</returns>
		public override bool CanWrite => true;

		/// <summary>Gets a value that indicates whether the current stream supports reading.</summary>
		/// <returns>
		///   <see langword="false" /> in all cases.</returns>
		public override bool CanRead => false;

		/// <summary>Gets a value that indicates whether the current stream supports seeking.</summary>
		/// <returns>
		///   <see langword="false" /> in all cases.</returns>
		public override bool CanSeek => false;

		/// <summary>Gets the length of the stream.</summary>
		/// <returns>The length of the stream.</returns>
		public override long Length => buffer.Length;

		/// <summary>Gets the current position in the stream. The set method does not do anything.</summary>
		/// <returns>The current position in the stream.</returns>
		public override long Position
		{
			get
			{
				return buffer.Length;
			}
			set
			{
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.COMCharStream" /> class.</summary>
		/// <param name="messageReceiver">The receiver of the data of the stream.</param>
		public COMCharStream(IMessageReceiver messageReceiver)
		{
			this.messageReceiver = messageReceiver;
			buffer = new StringBuilder(128);
		}

		/// <summary>Sends this stream's data to the <see cref="T:Microsoft.JScript.IMessageReceiver" /> and clears its buffer.</summary>
		public override void Close()
		{
			Flush();
		}

		/// <summary>Sends this stream's data to the <see cref="T:Microsoft.JScript.IMessageReceiver" /> and clears its buffer.</summary>
		public override void Flush()
		{
			messageReceiver.Message(buffer.ToString());
			buffer = new StringBuilder(128);
		}

		/// <summary>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</summary>
		/// <param name="buffer">An array of bytes in which to store the data that is read from the stream.</param>
		/// <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing the data that is read from the stream.</param>
		/// <param name="count">The maximum number of bytes to read from the stream.</param>
		/// <returns>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</returns>
		public override int Read(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}

		/// <summary>Sets the position in the current stream. This method does not do anything. It always returns 0.</summary>
		/// <param name="offset">A byte offset relative to the <paramref name="origin" /> parameter.</param>
		/// <param name="origin">A value that indicates the reference point that is used to obtain the new position.</param>
		/// <returns>0 in all cases.</returns>
		public override long Seek(long offset, SeekOrigin origin)
		{
			return 0L;
		}

		/// <summary>Sets the length of the stream.</summary>
		/// <param name="value">The new length of the stream.</param>
		public override void SetLength(long value)
		{
			buffer.Length = (int)value;
		}

		/// <summary>Writes the specified byte data to the stream.</summary>
		/// <param name="buffer">An array of byte data to copy to the current stream.</param>
		/// <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</param>
		/// <param name="count">The number of bytes to copy from <paramref name="buffer" /> to the current stream.</param>
		public override void Write(byte[] buffer, int offset, int count)
		{
			for (int num = count; num > 0; num--)
			{
				this.buffer.Append((char)buffer[offset++]);
			}
		}
	}
	/// <summary>Represents a reference error. For example, a reference error can occur when you reference an undeclared variable.</summary>
	public sealed class ReferenceErrorObject : ErrorObject
	{
		internal ReferenceErrorObject(ErrorPrototype parent, object[] args)
			: base(parent, args)
		{
		}

		internal ReferenceErrorObject(ErrorPrototype parent, object e)
			: base(parent, e)
		{
		}
	}
	/// <summary>Represents a reference to an assembly.</summary>
	[AttributeUsage(AttributeTargets.Assembly)]
	public class ReferenceAttribute : Attribute
	{
		/// <summary>Specifies the reference to the assembly.</summary>
		public string reference;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.ReferenceAttribute" /> class.</summary>
		/// <param name="reference">The reference to the assembly.</param>
		public ReferenceAttribute(string reference)
		{
			this.reference = reference;
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public sealed class RegExpConstructor : ScriptFunction
	{
		internal static readonly RegExpConstructor ob = new RegExpConstructor();

		private RegExpPrototype originalPrototype;

		internal ArrayPrototype arrayPrototype;

		private Regex regex;

		private Match lastRegexMatch;

		internal object inputString;

		private string lastInput;

		/// <summary>Gets the index of the last successful match, before advancing the index.</summary>
		/// <returns>The index of the last successful match, if there was one.</returns>
		public object index => GetIndex();

		/// <summary>Gets or sets the input string for a regular expression search.</summary>
		/// <returns>The input string for a regular expression search.</returns>
		public object input
		{
			get
			{
				return GetInput();
			}
			set
			{
				if (noExpando)
				{
					throw new JScriptException(JSError.AssignmentToReadOnly);
				}
				SetInput(value);
			}
		}

		/// <summary>Gets the index of the last successful match, after advancing the index.</summary>
		/// <returns>The index of the last successful match, if there was one.</returns>
		public object lastIndex => GetLastIndex();

		/// <summary>Gets a string representation of the last successful match.</summary>
		/// <returns>A string representation of the last successful match, if there was one.</returns>
		public object lastMatch => GetLastMatch();

		/// <summary>Gets the last <see cref="T:System.Text.RegularExpressions.Group" /> from the <see cref="P:System.Text.RegularExpressions.Match.Groups" /> of the last match.</summary>
		/// <returns>A string representation of the last group, if there was one.</returns>
		public object lastParen => GetLastParen();

		/// <summary>Gets a substring of the input string between the start of the input and the start of the last successful match.</summary>
		/// <returns>A substring of the input string, if there was one.</returns>
		public object leftContext => GetLeftContext();

		/// <summary>Gets a substring of the input string between the start of the last successful match and the end of the input.</summary>
		/// <returns>A substring of the input string, if there was one.</returns>
		public object rightContext => GetRightContext();

		internal RegExpConstructor()
			: base(FunctionPrototype.ob, "RegExp", 2)
		{
			originalPrototype = RegExpPrototype.ob;
			RegExpPrototype._constructor = this;
			proto = RegExpPrototype.ob;
			arrayPrototype = ArrayPrototype.ob;
			regex = null;
			lastRegexMatch = null;
			inputString = "";
			lastInput = null;
		}

		internal RegExpConstructor(LenientFunctionPrototype parent, LenientRegExpPrototype prototypeProp, LenientArrayPrototype arrayPrototype)
			: base(parent, "RegExp", 2)
		{
			originalPrototype = prototypeProp;
			prototypeProp.constructor = this;
			proto = prototypeProp;
			this.arrayPrototype = arrayPrototype;
			regex = null;
			lastRegexMatch = null;
			inputString = "";
			lastInput = null;
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			return Invoke(args);
		}

		internal override object Construct(object[] args)
		{
			return CreateInstance(args);
		}

		private RegExpObject ConstructNew(object[] args)
		{
			string source = ((args.Length != 0 && args[0] != null) ? Convert.ToString(args[0]) : "");
			if (args.Length != 0 && args[0] is Regex)
			{
				throw new JScriptException(JSError.TypeMismatch);
			}
			bool ignoreCase = false;
			bool global = false;
			bool multiline = false;
			if (args.Length >= 2 && args[1] != null)
			{
				string text = Convert.ToString(args[1]);
				for (int i = 0; i < text.Length; i++)
				{
					switch (text[i])
					{
					case 'i':
						ignoreCase = true;
						break;
					case 'g':
						global = true;
						break;
					case 'm':
						multiline = true;
						break;
					default:
						throw new JScriptException(JSError.RegExpSyntax);
					}
				}
			}
			return new RegExpObject(originalPrototype, source, ignoreCase, global, multiline, this);
		}

		/// <summary>Creates a new <see cref="T:Microsoft.JScript.RegExpObject" /> object for the specified regular expression pattern and flags.</summary>
		/// <param name="pattern">The regular expression pattern to match.</param>
		/// <param name="ignoreCase">
		///   <see langword="true" /> to use case-insensitive matching; otherwise, <see langword="false" />.</param>
		/// <param name="global">
		///   <see langword="true" /> to use a global match; otherwise, <see langword="false" />.</param>
		/// <param name="multiline">
		///   <see langword="true" /> to use a multiline match; otherwise, <see langword="false" />.</param>
		/// <returns>A new <see cref="T:Microsoft.JScript.RegExpObject" /> object.</returns>
		public object Construct(string pattern, bool ignoreCase, bool global, bool multiline)
		{
			return new RegExpObject(originalPrototype, pattern, ignoreCase, global, multiline, this);
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>An instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new RegExpObject CreateInstance(params object[] args)
		{
			if (args == null || args.Length == 0 || !(args[0] is RegExpObject regExpObject))
			{
				return ConstructNew(args);
			}
			if (args.Length > 1 && args[1] != null)
			{
				throw new JScriptException(JSError.RegExpSyntax);
			}
			return new RegExpObject(originalPrototype, regExpObject.source, regExpObject.ignoreCase, regExpObject.global, regExpObject.multiline, this);
		}

		/// <summary>Creates an instance of a prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>An instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public RegExpObject Invoke(params object[] args)
		{
			if (args == null || args.Length == 0 || !(args[0] is RegExpObject result))
			{
				return ConstructNew(args);
			}
			if (args.Length > 1 && args[1] != null)
			{
				throw new JScriptException(JSError.RegExpSyntax);
			}
			return result;
		}

		private object GetIndex()
		{
			return (lastRegexMatch == null) ? (-1) : lastRegexMatch.Index;
		}

		private object GetInput()
		{
			return inputString;
		}

		private object GetLastIndex()
		{
			return (lastRegexMatch == null) ? (-1) : ((lastRegexMatch.Length == 0) ? (lastRegexMatch.Index + 1) : (lastRegexMatch.Index + lastRegexMatch.Length));
		}

		private object GetLastMatch()
		{
			if (lastRegexMatch != null)
			{
				return lastRegexMatch.ToString();
			}
			return "";
		}

		private object GetLastParen()
		{
			if (regex == null || lastRegexMatch == null)
			{
				return "";
			}
			string[] groupNames = regex.GetGroupNames();
			if (groupNames.Length <= 1)
			{
				return "";
			}
			int groupnum = regex.GroupNumberFromName(groupNames[groupNames.Length - 1]);
			Group group = lastRegexMatch.Groups[groupnum];
			if (!group.Success)
			{
				return "";
			}
			return group.ToString();
		}

		private object GetLeftContext()
		{
			if (lastRegexMatch != null && lastInput != null)
			{
				return lastInput.Substring(0, lastRegexMatch.Index);
			}
			return "";
		}

		internal override object GetMemberValue(string name)
		{
			if (name.Length == 2 && name[0] == '$')
			{
				char c = name[1];
				switch (c)
				{
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					if (lastRegexMatch == null)
					{
						return "";
					}
					Group group = lastRegexMatch.Groups[c.ToString()];
					if (!group.Success)
					{
						return "";
					}
					return group.ToString();
				}
				case '`':
					return GetLeftContext();
				case '\'':
					return GetRightContext();
				case '&':
					return GetLastMatch();
				case '+':
					return GetLastParen();
				case '_':
					return GetInput();
				}
			}
			return base.GetMemberValue(name);
		}

		private object GetRightContext()
		{
			if (lastRegexMatch != null && lastInput != null)
			{
				return lastInput.Substring(lastRegexMatch.Index + lastRegexMatch.Length);
			}
			return "";
		}

		private void SetInput(object value)
		{
			inputString = value;
		}

		internal override void SetMemberValue(string name, object value)
		{
			if (noExpando)
			{
				throw new JScriptException(JSError.AssignmentToReadOnly);
			}
			if (name.Length == 2 && name[0] == '$')
			{
				switch (name[1])
				{
				case '&':
				case '\'':
				case '+':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case '`':
					return;
				case '_':
					SetInput(value);
					return;
				}
			}
			base.SetMemberValue(name, value);
		}

		internal int UpdateConstructor(Regex regex, Match match, string input)
		{
			if (!noExpando)
			{
				this.regex = regex;
				lastRegexMatch = match;
				inputString = input;
				lastInput = input;
			}
			if (match.Length != 0)
			{
				return match.Index + match.Length;
			}
			return match.Index + 1;
		}
	}
	internal sealed class RegExpLiteral : AST
	{
		private string source;

		private bool ignoreCase;

		private bool global;

		private bool multiline;

		private JSGlobalField regExpVar;

		private static int counter;

		internal RegExpLiteral(string source, string flags, Context context)
			: base(context)
		{
			this.source = source;
			ignoreCase = (global = (multiline = false));
			if (flags == null)
			{
				return;
			}
			for (int i = 0; i < flags.Length; i++)
			{
				switch (flags[i])
				{
				case 'i':
					if (ignoreCase)
					{
						throw new JScriptException(JSError.RegExpSyntax);
					}
					ignoreCase = true;
					break;
				case 'g':
					if (global)
					{
						throw new JScriptException(JSError.RegExpSyntax);
					}
					global = true;
					break;
				case 'm':
					if (multiline)
					{
						throw new JScriptException(JSError.RegExpSyntax);
					}
					multiline = true;
					break;
				default:
					throw new JScriptException(JSError.RegExpSyntax);
				}
			}
		}

		internal override object Evaluate()
		{
			if (VsaEngine.executeForJSEE)
			{
				throw new JScriptException(JSError.NonSupportedInDebugger);
			}
			RegExpObject regExpObject = (RegExpObject)base.Globals.RegExpTable[this];
			if (regExpObject == null)
			{
				regExpObject = (RegExpObject)base.Engine.GetOriginalRegExpConstructor().Construct(source, ignoreCase, global, multiline);
				base.Globals.RegExpTable[this] = regExpObject;
			}
			return regExpObject;
		}

		internal override IReflect InferType(JSField inferenceTarget)
		{
			return Typeob.RegExpObject;
		}

		internal override AST PartiallyEvaluate()
		{
			string name = "regexp " + counter++.ToString(CultureInfo.InvariantCulture);
			GlobalScope globalScope = (GlobalScope)base.Engine.GetGlobalScope().GetObject();
			JSGlobalField jSGlobalField = (JSGlobalField)globalScope.AddNewField(name, null, FieldAttributes.Assembly);
			jSGlobalField.type = new TypeExpression(new ConstantWrapper(Typeob.RegExpObject, context));
			regExpVar = jSGlobalField;
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			il.Emit(OpCodes.Ldsfld, (FieldInfo)regExpVar.GetMetaData());
			Convert.Emit(this, il, Typeob.RegExpObject, rtype);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			ScriptObject scriptObject = base.Engine.ScriptObjectStackTop();
			while (scriptObject != null && (scriptObject is WithObject || scriptObject is BlockScope))
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is FunctionScope)
			{
				EmitILToLoadEngine(il);
				il.Emit(OpCodes.Pop);
			}
			il.Emit(OpCodes.Ldsfld, (FieldInfo)regExpVar.GetMetaData());
			Label label = il.DefineLabel();
			il.Emit(OpCodes.Brtrue_S, label);
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.getOriginalRegExpConstructorMethod);
			il.Emit(OpCodes.Ldstr, source);
			if (ignoreCase)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			if (global)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			if (multiline)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			il.Emit(OpCodes.Call, CompilerGlobals.regExpConstructMethod);
			il.Emit(OpCodes.Castclass, Typeob.RegExpObject);
			il.Emit(OpCodes.Stsfld, (FieldInfo)regExpVar.GetMetaData());
			il.MarkLabel(label);
		}
	}
	/// <summary>Represents the results from a regular expression match. This class belongs to the built-in object model category.</summary>
	public sealed class RegExpMatch : ArrayObject
	{
		private bool hydrated;

		private Regex regex;

		private MatchCollection matches;

		private Match match;

		internal RegExpMatch(ArrayPrototype parent, Regex regex, Match match, string input)
			: base(parent, typeof(RegExpMatch))
		{
			hydrated = false;
			this.regex = regex;
			matches = null;
			this.match = match;
			SetMemberValue("input", input);
			SetMemberValue("index", match.Index);
			SetMemberValue("lastIndex", (match.Length == 0) ? (match.Index + 1) : (match.Index + match.Length));
			string[] groupNames = regex.GetGroupNames();
			int num = 0;
			for (int i = 1; i < groupNames.Length; i++)
			{
				string text = groupNames[i];
				int num2 = regex.GroupNumberFromName(text);
				if (text.Equals(num2.ToString(CultureInfo.InvariantCulture)))
				{
					if (num2 > num)
					{
						num = num2;
					}
				}
				else
				{
					Group group = match.Groups[text];
					SetMemberValue(text, group.Success ? group.ToString() : null);
				}
			}
			length = num + 1;
		}

		internal RegExpMatch(ArrayPrototype parent, Regex regex, MatchCollection matches, string input)
			: base(parent)
		{
			hydrated = false;
			length = matches.Count;
			this.regex = regex;
			this.matches = matches;
			this.match = null;
			Match match = matches[matches.Count - 1];
			SetMemberValue("input", input);
			SetMemberValue("index", match.Index);
			SetMemberValue("lastIndex", (match.Length == 0) ? (match.Index + 1) : (match.Index + match.Length));
		}

		internal override void Concat(ArrayObject source)
		{
			if (!hydrated)
			{
				Hydrate();
			}
			base.Concat(source);
		}

		internal override void Concat(object value)
		{
			if (!hydrated)
			{
				Hydrate();
			}
			base.Concat(value);
		}

		internal override bool DeleteValueAtIndex(uint index)
		{
			if (!hydrated)
			{
				Hydrate();
			}
			return base.DeleteValueAtIndex(index);
		}

		internal override object GetValueAtIndex(uint index)
		{
			if (!hydrated)
			{
				if (matches != null)
				{
					if (index < matches.Count)
					{
						return matches[(int)index].ToString();
					}
				}
				else if (match != null)
				{
					int num = regex.GroupNumberFromName(index.ToString(CultureInfo.InvariantCulture));
					if (num >= 0)
					{
						Group group = match.Groups[num];
						if (!group.Success)
						{
							return "";
						}
						return group.ToString();
					}
				}
			}
			return base.GetValueAtIndex(index);
		}

		internal override object GetMemberValue(string name)
		{
			if (!hydrated)
			{
				long num = ArrayObject.Array_index_for(name);
				if (num >= 0)
				{
					return GetValueAtIndex((uint)num);
				}
			}
			return base.GetMemberValue(name);
		}

		private void Hydrate()
		{
			if (matches != null)
			{
				int i = 0;
				for (int count = matches.Count; i < count; i++)
				{
					base.SetValueAtIndex((uint)i, (object)matches[i].ToString());
				}
			}
			else if (match != null)
			{
				string[] groupNames = regex.GetGroupNames();
				int j = 1;
				for (int num = groupNames.Length; j < num; j++)
				{
					string text = groupNames[j];
					int num2 = regex.GroupNumberFromName(text);
					Group group = match.Groups[num2];
					object value = (group.Success ? group.ToString() : "");
					if (text.Equals(num2.ToString(CultureInfo.InvariantCulture)))
					{
						base.SetValueAtIndex((uint)num2, value);
					}
				}
			}
			hydrated = true;
			regex = null;
			matches = null;
			match = null;
		}

		internal override void SetValueAtIndex(uint index, object value)
		{
			if (!hydrated)
			{
				Hydrate();
			}
			base.SetValueAtIndex(index, value);
		}

		internal override object Shift()
		{
			if (!hydrated)
			{
				Hydrate();
			}
			return base.Shift();
		}

		internal override void Sort(ScriptFunction compareFn)
		{
			if (!hydrated)
			{
				Hydrate();
			}
			base.Sort(compareFn);
		}

		internal override void Splice(uint start, uint deleteItems, object[] args, ArrayObject outArray, uint oldLength, uint newLength)
		{
			if (!hydrated)
			{
				Hydrate();
			}
			base.Splice(start, deleteItems, args, outArray, oldLength, newLength);
		}

		internal override void SwapValues(uint pi, uint qi)
		{
			if (!hydrated)
			{
				Hydrate();
			}
			base.SwapValues(pi, qi);
		}

		internal override ArrayObject Unshift(object[] args)
		{
			if (!hydrated)
			{
				Hydrate();
			}
			return base.Unshift(args);
		}
	}
	/// <summary>Represents a regular expression object. This class belongs to the built-in object model category.</summary>
	public sealed class RegExpObject : JSObject
	{
		internal RegExpConstructor regExpConst;

		private string sourceInt;

		internal bool ignoreCaseInt;

		internal bool globalInt;

		internal bool multilineInt;

		internal Regex regex;

		internal object lastIndexInt;

		/// <summary>Gets the regular expression pattern that is represented by this object.</summary>
		/// <returns>The regular expression pattern that is represented by this object.</returns>
		public string source => sourceInt;

		/// <summary>Gets a value indicating whether searches are performed with the case-insensitive flag (<c>/i</c>).</summary>
		/// <returns>
		///   <see langword="true" /> if case-insensitive searches are performed; otherwise, <see langword="false" />.</returns>
		public bool ignoreCase => ignoreCaseInt;

		/// <summary>Gets a value indicating whether searches are performed with the global flag (<c>/g</c>), matching all occurrences.</summary>
		/// <returns>
		///   <see langword="true" /> if global searches are performed; otherwise, <see langword="false" />.</returns>
		public bool global => globalInt;

		/// <summary>Gets a value indicating whether searches are performed with the multiline flag (<c>/m</c>).</summary>
		/// <returns>
		///   <see langword="true" /> if searches are performed in multiline mode; otherwise, <see langword="false" />.</returns>
		public bool multiline => multilineInt;

		/// <summary>Gets or sets the index of the last successful match.</summary>
		/// <returns>The index of the last successful match, if there was one.</returns>
		public object lastIndex
		{
			get
			{
				return lastIndexInt;
			}
			set
			{
				lastIndexInt = value;
			}
		}

		internal RegExpObject(RegExpPrototype parent, string source, bool ignoreCase, bool global, bool multiline, RegExpConstructor regExpConst)
			: base(parent)
		{
			this.regExpConst = regExpConst;
			sourceInt = source;
			ignoreCaseInt = ignoreCase;
			globalInt = global;
			multilineInt = multiline;
			RegexOptions regexOptions = RegexOptions.ECMAScript | RegexOptions.CultureInvariant;
			if (ignoreCase)
			{
				regexOptions |= RegexOptions.IgnoreCase;
			}
			if (multiline)
			{
				regexOptions |= RegexOptions.Multiline;
			}
			try
			{
				regex = new Regex(source, regexOptions);
			}
			catch (ArgumentException)
			{
				throw new JScriptException(JSError.RegExpSyntax);
			}
			lastIndexInt = 0;
			noExpando = false;
		}

		internal RegExpObject(Regex regex)
			: base(null)
		{
			regExpConst = null;
			sourceInt = "";
			ignoreCaseInt = (regex.Options & RegexOptions.IgnoreCase) != 0;
			globalInt = false;
			multilineInt = (regex.Options & RegexOptions.Multiline) != 0;
			this.regex = regex;
			lastIndexInt = 0;
			noExpando = true;
		}

		internal RegExpObject compile(string source, string flags)
		{
			sourceInt = source;
			ignoreCaseInt = (globalInt = (multilineInt = false));
			RegexOptions regexOptions = RegexOptions.ECMAScript | RegexOptions.CultureInvariant;
			for (int i = 0; i < flags.Length; i++)
			{
				switch (flags[i])
				{
				case 'i':
					if (ignoreCaseInt)
					{
						throw new JScriptException(JSError.RegExpSyntax);
					}
					ignoreCaseInt = true;
					regexOptions |= RegexOptions.IgnoreCase;
					break;
				case 'g':
					if (globalInt)
					{
						throw new JScriptException(JSError.RegExpSyntax);
					}
					globalInt = true;
					break;
				case 'm':
					if (multilineInt)
					{
						throw new JScriptException(JSError.RegExpSyntax);
					}
					multilineInt = true;
					regexOptions |= RegexOptions.Multiline;
					break;
				default:
					throw new JScriptException(JSError.RegExpSyntax);
				}
			}
			try
			{
				regex = new Regex(source, regexOptions);
				return this;
			}
			catch (ArgumentException)
			{
				throw new JScriptException(JSError.RegExpSyntax);
			}
		}

		internal object exec(string input)
		{
			Match match = null;
			if (!globalInt)
			{
				match = regex.Match(input);
			}
			else
			{
				int num = (int)Runtime.DoubleToInt64(Convert.ToInteger(lastIndexInt));
				if (num <= 0)
				{
					match = regex.Match(input);
				}
				else if (num <= input.Length)
				{
					match = regex.Match(input, num);
				}
			}
			if (match == null || !match.Success)
			{
				lastIndexInt = 0;
				return DBNull.Value;
			}
			lastIndexInt = regExpConst.UpdateConstructor(regex, match, input);
			return new RegExpMatch(regExpConst.arrayPrototype, regex, match, input);
		}

		internal override string GetClassName()
		{
			return "RegExp";
		}

		internal bool test(string input)
		{
			Match match = null;
			if (!globalInt)
			{
				match = regex.Match(input);
			}
			else
			{
				int num = (int)Runtime.DoubleToInt64(Convert.ToInteger(lastIndexInt));
				if (num <= 0)
				{
					match = regex.Match(input);
				}
				else if (num <= input.Length)
				{
					match = regex.Match(input, num);
				}
			}
			if (match == null || !match.Success)
			{
				lastIndexInt = 0;
				return false;
			}
			lastIndexInt = regExpConst.UpdateConstructor(regex, match, input);
			return true;
		}

		/// <summary>Creates a string representation of this object that contains the regular expression pattern and flags.</summary>
		/// <returns>A string representation of this object.</returns>
		public override string ToString()
		{
			return "/" + sourceInt + "/" + (ignoreCaseInt ? "i" : "") + (globalInt ? "g" : "") + (multilineInt ? "m" : "");
		}
	}
	/// <summary>Provides static methods and properties for <see cref="T:Microsoft.JScript.RegExpObject" /> objects. All methods of this class are called by passing in a reference to the object that is requesting access to the method. This class belongs to the built-in object model category.</summary>
	public class RegExpPrototype : JSObject
	{
		internal static readonly RegExpPrototype ob = new RegExpPrototype(ObjectPrototype.ob);

		internal static RegExpConstructor _constructor;

		/// <summary>Gets a reference to a prototype-based object that is using this prototype.</summary>
		/// <returns>A reference to a prototype-based object.</returns>
		public static RegExpConstructor constructor => _constructor;

		internal RegExpPrototype(ObjectPrototype parent)
			: base(parent)
		{
		}

		/// <summary>Creates and compiles a new <see cref="T:Microsoft.JScript.RegExpObject" /> object for the specified regular expression pattern and flags.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="source">The regular expression pattern to search for.</param>
		/// <param name="flags">Flags for the ignore case, global, and multiline modes.</param>
		/// <returns>A new <see cref="T:Microsoft.JScript.RegExpObject" /> object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.RegExp_compile)]
		public static RegExpObject compile(object thisob, object source, object flags)
		{
			if (!(thisob is RegExpObject regExpObject))
			{
				throw new JScriptException(JSError.RegExpExpected);
			}
			return regExpObject.compile((source == null || source is Missing) ? "" : Convert.ToString(source), (flags == null || flags is Missing) ? "" : Convert.ToString(flags));
		}

		/// <summary>Runs a search for the specified regular expression pattern on the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="input">The regular expression pattern to search for.</param>
		/// <returns>The result of the search for the regular expression pattern.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.RegExp_exec)]
		public static object exec(object thisob, object input)
		{
			if (!(thisob is RegExpObject regExpObject))
			{
				throw new JScriptException(JSError.RegExpExpected);
			}
			if (input is Missing && !regExpObject.regExpConst.noExpando)
			{
				input = regExpObject.regExpConst.input;
			}
			return regExpObject.exec(Convert.ToString(input));
		}

		/// <summary>Tests the search for the specified regular expression pattern on the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="input">The regular expression pattern to search for.</param>
		/// <returns>
		///   <see langword="true" /> if the search succeeds; otherwise, <see langword="false" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.RegExp_test)]
		public static bool test(object thisob, object input)
		{
			if (!(thisob is RegExpObject regExpObject))
			{
				throw new JScriptException(JSError.RegExpExpected);
			}
			if (input is Missing && !regExpObject.regExpConst.noExpando)
			{
				input = regExpObject.regExpConst.input;
			}
			return regExpObject.test(Convert.ToString(input));
		}

		/// <summary>Creates a string representation of the specified object that contains the regular expression pattern and flags.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.RegExp_toString)]
		public static string toString(object thisob)
		{
			if (!(thisob is RegExpObject regExpObject))
			{
				throw new JScriptException(JSError.RegExpExpected);
			}
			return regExpObject.ToString();
		}
	}
	internal abstract class RegExpReplace
	{
		internal Match lastMatch;

		internal RegExpReplace()
		{
			lastMatch = null;
		}

		internal abstract string Evaluate(Match match);
	}
	internal class ReplaceUsingFunction : RegExpReplace
	{
		private ScriptFunction function;

		private int cArgs;

		private int[] groupNumbers;

		private string source;

		internal ReplaceUsingFunction(Regex regex, ScriptFunction function, string source)
		{
			this.function = function;
			cArgs = function.GetNumberOfFormalParameters();
			bool flag = function is Closure && ((Closure)function).func.hasArgumentsObject;
			groupNumbers = null;
			this.source = source;
			if (!(cArgs > 1 || flag))
			{
				return;
			}
			string[] groupNames = regex.GetGroupNames();
			int num = groupNames.Length - 1;
			if (flag)
			{
				cArgs = num + 3;
			}
			if (num > 0)
			{
				if (num > cArgs - 1)
				{
					num = cArgs - 1;
				}
				groupNumbers = new int[num];
				for (int i = 0; i < num; i++)
				{
					groupNumbers[i] = regex.GroupNumberFromName(groupNames[i + 1]);
				}
			}
		}

		internal override string Evaluate(Match match)
		{
			lastMatch = match;
			object[] array = new object[cArgs];
			if (cArgs > 0)
			{
				array[0] = match.ToString();
				if (cArgs > 1)
				{
					int i = 1;
					if (groupNumbers != null)
					{
						for (; i <= groupNumbers.Length; i++)
						{
							Group group = match.Groups[groupNumbers[i - 1]];
							array[i] = (group.Success ? group.ToString() : null);
						}
					}
					if (i < cArgs)
					{
						array[i++] = match.Index;
						if (i < cArgs)
						{
							array[i++] = source;
							for (; i < cArgs; i++)
							{
								array[i] = null;
							}
						}
					}
				}
			}
			object obj = function.Call(array, null);
			return match.Result((obj is Empty) ? "" : Convert.ToString(obj));
		}
	}
	internal class ReplaceWithString : RegExpReplace
	{
		private string replaceString;

		internal ReplaceWithString(string replaceString)
		{
			this.replaceString = replaceString;
		}

		internal override string Evaluate(Match match)
		{
			lastMatch = match;
			return match.Result(replaceString);
		}
	}
	/// <summary>Performs relational comparison operations. This class belongs to the abstract syntax tree category.</summary>
	public class Relational : BinaryOp
	{
		private object metaData;

		internal Relational(Context context, AST operand1, AST operand2, JSToken operatorTok)
			: base(context, operand1, operand2, operatorTok)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Relational" /> class.</summary>
		/// <param name="operatorTok">One of the <see cref="T:Microsoft.JScript.JSToken" /> enumeration values. Specifies the comparison to perform.</param>
		public Relational(int operatorTok)
			: base(null, null, null, (JSToken)operatorTok)
		{
		}

		internal override object Evaluate()
		{
			object v = operand1.Evaluate();
			object v2 = operand2.Evaluate();
			double num = EvaluateRelational(v, v2);
			return operatorTok switch
			{
				JSToken.GreaterThan => num > 0.0, 
				JSToken.GreaterThanEqual => num >= 0.0, 
				JSToken.LessThan => num < 0.0, 
				JSToken.LessThanEqual => num <= 0.0, 
				_ => throw new JScriptException(JSError.InternalError, context), 
			};
		}

		/// <summary>Performs a relational comparison operation on the specified operands.</summary>
		/// <param name="v1">The first operand.</param>
		/// <param name="v2">The second operand.</param>
		/// <returns>The result of the operation.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public double EvaluateRelational(object v1, object v2)
		{
			if (v1 is int)
			{
				if (v2 is int)
				{
					return (double)(int)v1 - (double)(int)v2;
				}
				if (v2 is double)
				{
					return (double)(int)v1 - (double)v2;
				}
			}
			else if (v1 is double)
			{
				if (v2 is double)
				{
					double num = (double)v1;
					double num2 = (double)v2;
					if (num == num2)
					{
						return 0.0;
					}
					return num - num2;
				}
				if (v2 is int)
				{
					return (double)v1 - (double)(int)v2;
				}
			}
			IConvertible iConvertible = Convert.GetIConvertible(v1);
			IConvertible iConvertible2 = Convert.GetIConvertible(v2);
			TypeCode typeCode = Convert.GetTypeCode(v1, iConvertible);
			TypeCode typeCode2 = Convert.GetTypeCode(v2, iConvertible2);
			if (typeCode == TypeCode.Object && typeCode2 == TypeCode.Object)
			{
				MethodInfo @operator = GetOperator(v1.GetType(), v2.GetType());
				if (@operator != null)
				{
					bool flag = Convert.ToBoolean(@operator.Invoke(null, BindingFlags.Default, JSBinder.ob, new object[2] { v1, v2 }, null));
					switch (operatorTok)
					{
					case JSToken.GreaterThan:
					case JSToken.GreaterThanEqual:
						return flag ? 1 : (-1);
					case JSToken.LessThan:
					case JSToken.LessThanEqual:
						return (!flag) ? 1 : (-1);
					default:
						throw new JScriptException(JSError.InternalError, context);
					}
				}
			}
			return JScriptCompare2(v1, v2, iConvertible, iConvertible2, typeCode, typeCode2);
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return Typeob.Boolean;
		}

		/// <summary>Performs a relational comparison operation on the specified operands.</summary>
		/// <param name="v1">The first operand.</param>
		/// <param name="v2">The second operand.</param>
		/// <returns>The result of the operation.</returns>
		public static double JScriptCompare(object v1, object v2)
		{
			if (v1 is int)
			{
				if (v2 is int)
				{
					return (int)v1 - (int)v2;
				}
				if (v2 is double)
				{
					return (double)(int)v1 - (double)v2;
				}
			}
			else if (v1 is double)
			{
				if (v2 is double)
				{
					double num = (double)v1;
					double num2 = (double)v2;
					if (num == num2)
					{
						return 0.0;
					}
					return num - num2;
				}
				if (v2 is int)
				{
					return (double)v1 - (double)(int)v2;
				}
			}
			IConvertible iConvertible = Convert.GetIConvertible(v1);
			IConvertible iConvertible2 = Convert.GetIConvertible(v2);
			TypeCode typeCode = Convert.GetTypeCode(v1, iConvertible);
			TypeCode typeCode2 = Convert.GetTypeCode(v2, iConvertible2);
			return JScriptCompare2(v1, v2, iConvertible, iConvertible2, typeCode, typeCode2);
		}

		private static double JScriptCompare2(object v1, object v2, IConvertible ic1, IConvertible ic2, TypeCode t1, TypeCode t2)
		{
			if (t1 == TypeCode.Object)
			{
				v1 = Convert.ToPrimitive(v1, PreferredType.Number, ref ic1);
				t1 = Convert.GetTypeCode(v1, ic1);
			}
			if (t2 == TypeCode.Object)
			{
				v2 = Convert.ToPrimitive(v2, PreferredType.Number, ref ic2);
				t2 = Convert.GetTypeCode(v2, ic2);
			}
			switch (t1)
			{
			case TypeCode.Char:
				if (t2 == TypeCode.String)
				{
					return string.CompareOrdinal(Convert.ToString(v1, ic1), ic2.ToString(null));
				}
				goto case TypeCode.SByte;
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			{
				long num5 = ic1.ToInt64(null);
				switch (t2)
				{
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return num5 - ic2.ToInt64(null);
				case TypeCode.UInt64:
				{
					if (num5 < 0)
					{
						return -1.0;
					}
					ulong num6 = ic2.ToUInt64(null);
					if ((ulong)num5 < num6)
					{
						return -1.0;
					}
					if (num5 == (long)num6)
					{
						return 0.0;
					}
					return 1.0;
				}
				case TypeCode.Single:
				case TypeCode.Double:
					return (double)num5 - ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (double)(new decimal(num5) - ic2.ToDecimal(null));
				default:
				{
					object obj2 = Convert.ToNumber(v2, ic2);
					return JScriptCompare2(v1, obj2, ic1, Convert.GetIConvertible(obj2), t1, TypeCode.Double);
				}
				}
			}
			case TypeCode.UInt64:
			{
				ulong num2 = ic1.ToUInt64(null);
				switch (t2)
				{
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				{
					long num4 = ic2.ToInt64(null);
					if (num4 < 0)
					{
						return 1.0;
					}
					if (num2 == (ulong)num4)
					{
						return 0.0;
					}
					return -1.0;
				}
				case TypeCode.UInt64:
				{
					ulong num3 = ic2.ToUInt64(null);
					if (num2 < num3)
					{
						return -1.0;
					}
					if (num2 == num3)
					{
						return 0.0;
					}
					return 1.0;
				}
				case TypeCode.Single:
				case TypeCode.Double:
					return (double)num2 - ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (double)(new decimal(num2) - ic2.ToDecimal(null));
				default:
				{
					object obj = Convert.ToNumber(v2, ic2);
					return JScriptCompare2(v1, obj, ic1, Convert.GetIConvertible(obj), t1, TypeCode.Double);
				}
				}
			}
			case TypeCode.Decimal:
			{
				decimal num = ic1.ToDecimal(null);
				switch (t2)
				{
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return (double)(num - new decimal(ic2.ToInt64(null)));
				case TypeCode.UInt64:
					return (double)(num - new decimal(ic2.ToUInt64(null)));
				case TypeCode.Single:
				case TypeCode.Double:
					return (double)(num - new decimal(ic2.ToDouble(null)));
				case TypeCode.Decimal:
					return (double)(num - ic2.ToDecimal(null));
				default:
					return (double)(num - new decimal(Convert.ToNumber(v2, ic2)));
				}
			}
			case TypeCode.String:
				switch (t2)
				{
				case TypeCode.String:
					return string.CompareOrdinal(ic1.ToString(null), ic2.ToString(null));
				case TypeCode.Char:
					return string.CompareOrdinal(ic1.ToString(null), Convert.ToString(v2, ic2));
				}
				break;
			}
			double num7 = Convert.ToNumber(v1, ic1);
			double num8 = Convert.ToNumber(v2, ic2);
			if (num7 == num8)
			{
				return 0.0;
			}
			return num7 - num8;
		}

		internal override void TranslateToConditionalBranch(ILGenerator il, bool branchIfTrue, Label label, bool shortForm)
		{
			Type type = type1;
			Type type2 = base.type2;
			Type type3 = Typeob.Object;
			if (type.IsPrimitive && type2.IsPrimitive)
			{
				type3 = Typeob.Double;
				if (Convert.IsPromotableTo(type, type2))
				{
					type3 = type2;
				}
				else if (Convert.IsPromotableTo(type2, type))
				{
					type3 = type;
				}
				else if (type == Typeob.Int64 || type == Typeob.UInt64 || type2 == Typeob.Int64 || type2 == Typeob.UInt64)
				{
					type3 = Typeob.Object;
				}
			}
			if (type3 == Typeob.SByte || type3 == Typeob.Int16)
			{
				type3 = Typeob.Int32;
			}
			else if (type3 == Typeob.Byte || type3 == Typeob.UInt16)
			{
				type3 = Typeob.UInt32;
			}
			if (metaData == null)
			{
				operand1.TranslateToIL(il, type3);
				operand2.TranslateToIL(il, type3);
				if (type3 == Typeob.Object)
				{
					il.Emit(OpCodes.Call, CompilerGlobals.jScriptCompareMethod);
					il.Emit(OpCodes.Ldc_I4_0);
					il.Emit(OpCodes.Conv_R8);
					type3 = Typeob.Double;
				}
			}
			else
			{
				if (metaData is MethodInfo)
				{
					MethodInfo methodInfo = (MethodInfo)metaData;
					ParameterInfo[] parameters = methodInfo.GetParameters();
					operand1.TranslateToIL(il, parameters[0].ParameterType);
					operand2.TranslateToIL(il, parameters[1].ParameterType);
					il.Emit(OpCodes.Call, methodInfo);
					if (branchIfTrue)
					{
						il.Emit(shortForm ? OpCodes.Brtrue_S : OpCodes.Brtrue, label);
					}
					else
					{
						il.Emit(shortForm ? OpCodes.Brfalse_S : OpCodes.Brfalse, label);
					}
					return;
				}
				il.Emit(OpCodes.Ldloc, (LocalBuilder)metaData);
				operand1.TranslateToIL(il, Typeob.Object);
				operand2.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.evaluateRelationalMethod);
				il.Emit(OpCodes.Ldc_I4_0);
				il.Emit(OpCodes.Conv_R8);
				type3 = Typeob.Double;
			}
			if (branchIfTrue)
			{
				if (type3 == Typeob.UInt32 || type3 == Typeob.UInt64)
				{
					switch (operatorTok)
					{
					case JSToken.GreaterThan:
						il.Emit(shortForm ? OpCodes.Bgt_Un_S : OpCodes.Bgt_Un, label);
						break;
					case JSToken.GreaterThanEqual:
						il.Emit(shortForm ? OpCodes.Bge_Un_S : OpCodes.Bge_Un, label);
						break;
					case JSToken.LessThan:
						il.Emit(shortForm ? OpCodes.Blt_Un_S : OpCodes.Blt_Un, label);
						break;
					case JSToken.LessThanEqual:
						il.Emit(shortForm ? OpCodes.Ble_Un_S : OpCodes.Ble_Un, label);
						break;
					default:
						throw new JScriptException(JSError.InternalError, context);
					}
				}
				else
				{
					switch (operatorTok)
					{
					case JSToken.GreaterThan:
						il.Emit(shortForm ? OpCodes.Bgt_S : OpCodes.Bgt, label);
						break;
					case JSToken.GreaterThanEqual:
						il.Emit(shortForm ? OpCodes.Bge_S : OpCodes.Bge, label);
						break;
					case JSToken.LessThan:
						il.Emit(shortForm ? OpCodes.Blt_S : OpCodes.Blt, label);
						break;
					case JSToken.LessThanEqual:
						il.Emit(shortForm ? OpCodes.Ble_S : OpCodes.Ble, label);
						break;
					default:
						throw new JScriptException(JSError.InternalError, context);
					}
				}
			}
			else if (type3 == Typeob.Int32 || type3 == Typeob.Int64)
			{
				switch (operatorTok)
				{
				case JSToken.GreaterThan:
					il.Emit(shortForm ? OpCodes.Ble_S : OpCodes.Ble, label);
					break;
				case JSToken.GreaterThanEqual:
					il.Emit(shortForm ? OpCodes.Blt_S : OpCodes.Blt, label);
					break;
				case JSToken.LessThan:
					il.Emit(shortForm ? OpCodes.Bge_S : OpCodes.Bge, label);
					break;
				case JSToken.LessThanEqual:
					il.Emit(shortForm ? OpCodes.Bgt_S : OpCodes.Bgt, label);
					break;
				default:
					throw new JScriptException(JSError.InternalError, context);
				}
			}
			else
			{
				switch (operatorTok)
				{
				case JSToken.GreaterThan:
					il.Emit(shortForm ? OpCodes.Ble_Un_S : OpCodes.Ble_Un, label);
					break;
				case JSToken.GreaterThanEqual:
					il.Emit(shortForm ? OpCodes.Blt_Un_S : OpCodes.Blt_Un, label);
					break;
				case JSToken.LessThan:
					il.Emit(shortForm ? OpCodes.Bge_Un_S : OpCodes.Bge_Un, label);
					break;
				case JSToken.LessThanEqual:
					il.Emit(shortForm ? OpCodes.Bgt_Un_S : OpCodes.Bgt_Un, label);
					break;
				default:
					throw new JScriptException(JSError.InternalError, context);
				}
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Label label = il.DefineLabel();
			Label label2 = il.DefineLabel();
			TranslateToConditionalBranch(il, branchIfTrue: true, label, shortForm: true);
			il.Emit(OpCodes.Ldc_I4_0);
			il.Emit(OpCodes.Br_S, label2);
			il.MarkLabel(label);
			il.Emit(OpCodes.Ldc_I4_1);
			il.MarkLabel(label2);
			Convert.Emit(this, il, Typeob.Boolean, rtype);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			operand1.TranslateToILInitializer(il);
			operand2.TranslateToILInitializer(il);
			MethodInfo @operator = GetOperator(operand1.InferType(null), operand2.InferType(null));
			if (@operator != null)
			{
				metaData = @operator;
			}
			else if ((!type1.IsPrimitive && !Typeob.JSObject.IsAssignableFrom(type1)) || (!type2.IsPrimitive && !Typeob.JSObject.IsAssignableFrom(type2)))
			{
				metaData = il.DeclareLocal(Typeob.Relational);
				ConstantWrapper.TranslateToILInt(il, (int)operatorTok);
				il.Emit(OpCodes.Newobj, CompilerGlobals.relationalConstructor);
				il.Emit(OpCodes.Stloc, (LocalBuilder)metaData);
			}
		}
	}
	internal sealed class Return : AST
	{
		private Completion completion;

		private AST operand;

		private FunctionScope enclosingFunctionScope;

		private bool leavesFinally;

		internal Return(Context context, AST operand, bool leavesFinally)
			: base(context)
		{
			completion = new Completion();
			completion.Return = true;
			this.operand = operand;
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (!(scriptObject is FunctionScope))
			{
				scriptObject = scriptObject.GetParent();
				if (scriptObject == null)
				{
					base.context.HandleError(JSError.BadReturn);
					scriptObject = new FunctionScope(null);
				}
			}
			enclosingFunctionScope = (FunctionScope)scriptObject;
			if (this.operand != null && enclosingFunctionScope.returnVar == null)
			{
				enclosingFunctionScope.AddReturnValueField();
			}
			this.leavesFinally = leavesFinally;
		}

		internal override object Evaluate()
		{
			if (operand != null)
			{
				completion.value = operand.Evaluate();
			}
			return completion;
		}

		internal override bool HasReturn()
		{
			return true;
		}

		internal override AST PartiallyEvaluate()
		{
			if (leavesFinally)
			{
				context.HandleError(JSError.BadWayToLeaveFinally);
			}
			if (operand != null)
			{
				operand = operand.PartiallyEvaluate();
				if (enclosingFunctionScope.returnVar != null)
				{
					if (enclosingFunctionScope.returnVar.type == null)
					{
						enclosingFunctionScope.returnVar.SetInferredType(operand.InferType(enclosingFunctionScope.returnVar), operand);
					}
					else
					{
						Binding.AssignmentCompatible(enclosingFunctionScope.returnVar.type.ToIReflect(), operand, operand.InferType(null), reportError: true);
					}
				}
				else
				{
					context.HandleError(JSError.CannotReturnValueFromVoidFunction);
					operand = null;
				}
			}
			else if (enclosingFunctionScope.returnVar != null)
			{
				enclosingFunctionScope.returnVar.SetInferredType(Typeob.Object, null);
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			context.EmitLineInfo(il);
			if (operand != null)
			{
				operand.TranslateToIL(il, enclosingFunctionScope.returnVar.FieldType);
			}
			else if (enclosingFunctionScope.returnVar != null)
			{
				il.Emit(OpCodes.Ldsfld, CompilerGlobals.undefinedField);
				Convert.Emit(this, il, Typeob.Object, enclosingFunctionScope.returnVar.FieldType);
			}
			if (enclosingFunctionScope.returnVar != null)
			{
				il.Emit(OpCodes.Stloc, (LocalBuilder)enclosingFunctionScope.returnVar.GetMetaData());
			}
			if (leavesFinally)
			{
				il.Emit(OpCodes.Newobj, CompilerGlobals.returnOutOfFinallyConstructor);
				il.Emit(OpCodes.Throw);
			}
			else if (base.compilerGlobals.InsideProtectedRegion)
			{
				il.Emit(OpCodes.Leave, enclosingFunctionScope.owner.returnLabel);
			}
			else
			{
				il.Emit(OpCodes.Br, enclosingFunctionScope.owner.returnLabel);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			if (operand != null)
			{
				operand.TranslateToILInitializer(il);
			}
		}
	}
	/// <summary>Represents the exception state when code execution returns out of a <see langword="finally" /> block.</summary>
	[Serializable]
	public sealed class ReturnOutOfFinally : ApplicationException
	{
		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.ReturnOutOfFinally" /> class.</summary>
		public ReturnOutOfFinally()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.ReturnOutOfFinally" /> class, using the specified error message.</summary>
		/// <param name="m">The message that describes the error.</param>
		public ReturnOutOfFinally(string m)
			: base(m)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.ReturnOutOfFinally" /> class, using the specified error message and a reference to the inner exception that is the cause of this exception.</summary>
		/// <param name="m">The message that describes the error.</param>
		/// <param name="e">The exception that is the cause of the current exception.</param>
		public ReturnOutOfFinally(string m, Exception e)
			: base(m, e)
		{
		}

		private ReturnOutOfFinally(SerializationInfo s, StreamingContext c)
			: base(s, c)
		{
		}
	}
	/// <summary>Provides utility functions.</summary>
	public static class Runtime
	{
		private const decimal DecimalTwoToThe64 = 18446744073709551616m;

		private static TypeReferences _typeRefs;

		private static ModuleBuilder _thunkModuleBuilder;

		internal static TypeReferences TypeRefs
		{
			get
			{
				TypeReferences typeReferences = _typeRefs;
				if (typeReferences == null)
				{
					typeReferences = (_typeRefs = new TypeReferences(typeof(Runtime).Module));
				}
				return typeReferences;
			}
		}

		internal static ModuleBuilder ThunkModuleBuilder
		{
			get
			{
				ModuleBuilder moduleBuilder = _thunkModuleBuilder;
				if (null == moduleBuilder)
				{
					moduleBuilder = (_thunkModuleBuilder = CreateThunkModuleBuilder());
				}
				return moduleBuilder;
			}
		}

		/// <summary>Determines whether two specified values are equal.</summary>
		/// <param name="v1">The first operand.</param>
		/// <param name="v2">The second operand.</param>
		/// <returns>
		///   <see langword="true" /> if the values are equal; <see langword="false" /> if the values are not equal.</returns>
		public new static bool Equals(object v1, object v2)
		{
			Equality equality = new Equality(53);
			return equality.EvaluateEquality(v1, v2);
		}

		/// <summary>Converts the specified <see cref="T:System.Double" /> value to an <see cref="T:System.Int64" />.</summary>
		/// <param name="val">The value to convert.</param>
		/// <returns>
		///   <paramref name="val" /> converted to an <see cref="T:System.Int64" />.</returns>
		public static long DoubleToInt64(double val)
		{
			if (double.IsNaN(val))
			{
				return 0L;
			}
			if (-9.2233720368547758E+18 <= val && val <= 9.2233720368547758E+18)
			{
				return (long)val;
			}
			if (double.IsInfinity(val))
			{
				return 0L;
			}
			double num = Math.IEEERemainder((double)Math.Sign(val) * Math.Floor(Math.Abs(val)), 1.8446744073709552E+19);
			if (num == 9.2233720368547758E+18)
			{
				return long.MinValue;
			}
			return (long)num;
		}

		/// <summary>Converts the specified <see cref="T:System.Decimal" /> value to an <see cref="T:System.Int64" />.</summary>
		/// <param name="val">The value to convert.</param>
		/// <returns>
		///   <paramref name="val" /> converted to an <see cref="T:System.Int64" />.</returns>
		public static long UncheckedDecimalToInt64(decimal val)
		{
			val = decimal.Truncate(val);
			if (val < new decimal(long.MinValue) || new decimal(long.MaxValue) < val)
			{
				val = decimal.Remainder(val, 18446744073709551616m);
				if (val < new decimal(long.MinValue))
				{
					val += 18446744073709551616m;
				}
				else if (val > new decimal(long.MaxValue))
				{
					val -= 18446744073709551616m;
				}
			}
			return (long)val;
		}

		[ReflectionPermission(SecurityAction.Assert, ReflectionEmit = true)]
		[FileIOPermission(SecurityAction.Assert, Unrestricted = true)]
		private static ModuleBuilder CreateThunkModuleBuilder()
		{
			AssemblyName assemblyName = new AssemblyName();
			assemblyName.Name = "JScript Thunk Assembly";
			AssemblyBuilder assemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
			ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule("JScript Thunk Module");
			moduleBuilder.SetCustomAttribute(new CustomAttributeBuilder(typeof(SecurityTransparentAttribute).GetConstructor(new Type[0]), new object[0]));
			return moduleBuilder;
		}
	}
	internal class ScannerException : Exception
	{
		internal JSError m_errorId;

		internal ScannerException(JSError errorId)
			: base(JScriptException.Localize("Scanner Exception", CultureInfo.CurrentUICulture))
		{
			m_errorId = errorId;
		}
	}
	/// <summary>Represents a block of JScript code. This class belongs to the abstract syntax tree category.</summary>
	public class ScriptBlock : AST
	{
		private Block statement_block;

		private JSField[] fields;

		private GlobalScope own_scope;

		internal ScriptBlock(Context context, Block statement_block)
			: base(context)
		{
			this.statement_block = statement_block;
			own_scope = (GlobalScope)base.Engine.ScriptObjectStackTop();
			fields = null;
		}

		internal override object Evaluate()
		{
			if (fields == null)
			{
				fields = own_scope.GetFields();
			}
			int i = 0;
			for (int num = fields.Length; i < num; i++)
			{
				FieldInfo fieldInfo = fields[i];
				if (!(fieldInfo is JSExpandoField))
				{
					object value = fieldInfo.GetValue(own_scope);
					if (value is FunctionObject)
					{
						((FunctionObject)value).engine = base.Engine;
						own_scope.AddFieldOrUseExistingField(fieldInfo.Name, new Closure((FunctionObject)value), fieldInfo.Attributes);
					}
					else if (value is ClassScope)
					{
						own_scope.AddFieldOrUseExistingField(fieldInfo.Name, value, fieldInfo.Attributes);
					}
					else
					{
						own_scope.AddFieldOrUseExistingField(fieldInfo.Name, Missing.Value, fieldInfo.Attributes);
					}
				}
			}
			object obj = statement_block.Evaluate();
			if (obj is Completion)
			{
				obj = ((Completion)obj).value;
			}
			return obj;
		}

		internal void ProcessAssemblyAttributeLists()
		{
			statement_block.ProcessAssemblyAttributeLists();
		}

		internal override AST PartiallyEvaluate()
		{
			statement_block.PartiallyEvaluate();
			if (base.Engine.PEFileKind == PEFileKinds.Dll && base.Engine.doSaveAfterCompile)
			{
				statement_block.ComplainAboutAnythingOtherThanClassOrPackage();
			}
			fields = own_scope.GetFields();
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Expression expression = statement_block.ToExpression();
			if (expression != null)
			{
				expression.TranslateToIL(il, rtype);
				return;
			}
			statement_block.TranslateToIL(il, Typeob.Void);
			new ConstantWrapper(null, context).TranslateToIL(il, rtype);
		}

		internal TypeBuilder TranslateToILClass(CompilerGlobals compilerGlobals)
		{
			return TranslateToILClass(compilerGlobals, pushScope: true);
		}

		internal TypeBuilder TranslateToILClass(CompilerGlobals compilerGlobals, bool pushScope)
		{
			TypeBuilder typeBuilder = (compilerGlobals.classwriter = compilerGlobals.module.DefineType("JScript " + base.Engine.classCounter++.ToString(CultureInfo.InvariantCulture), TypeAttributes.Public, Typeob.GlobalScope, null));
			compilerGlobals.classwriter.SetCustomAttribute(new CustomAttributeBuilder(CompilerGlobals.compilerGlobalScopeAttributeCtor, new object[0]));
			if (null == compilerGlobals.globalScopeClassWriter)
			{
				compilerGlobals.globalScopeClassWriter = typeBuilder;
			}
			ConstructorBuilder constructorBuilder = compilerGlobals.classwriter.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[1] { Typeob.GlobalScope });
			ILGenerator iLGenerator = constructorBuilder.GetILGenerator();
			iLGenerator.Emit(OpCodes.Ldarg_0);
			iLGenerator.Emit(OpCodes.Ldarg_1);
			iLGenerator.Emit(OpCodes.Dup);
			iLGenerator.Emit(OpCodes.Ldfld, CompilerGlobals.engineField);
			iLGenerator.Emit(OpCodes.Call, CompilerGlobals.globalScopeConstructor);
			iLGenerator.Emit(OpCodes.Ret);
			MethodBuilder methodBuilder = typeBuilder.DefineMethod("Global Code", MethodAttributes.Public, Typeob.Object, null);
			iLGenerator = methodBuilder.GetILGenerator();
			if (base.Engine.GenerateDebugInfo)
			{
				for (ScriptObject parent = own_scope.GetParent(); parent != null; parent = parent.GetParent())
				{
					if (parent is WrappedNamespace && !((WrappedNamespace)parent).name.Equals(""))
					{
						iLGenerator.UsingNamespace(((WrappedNamespace)parent).name);
					}
				}
			}
			int startLine = context.StartLine;
			int startColumn = context.StartColumn;
			GetFirstExecutableContext()?.EmitFirstLineInfo(iLGenerator);
			if (pushScope)
			{
				EmitILToLoadEngine(iLGenerator);
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Call, CompilerGlobals.pushScriptObjectMethod);
			}
			TranslateToILInitializer(iLGenerator);
			TranslateToIL(iLGenerator, Typeob.Object);
			if (pushScope)
			{
				EmitILToLoadEngine(iLGenerator);
				iLGenerator.Emit(OpCodes.Call, CompilerGlobals.popScriptObjectMethod);
				iLGenerator.Emit(OpCodes.Pop);
			}
			iLGenerator.Emit(OpCodes.Ret);
			return typeBuilder;
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			int num = fields.Length;
			if (num > 0)
			{
				for (int i = 0; i < num; i++)
				{
					JSGlobalField jSGlobalField = fields[i] as JSGlobalField;
					if (jSGlobalField == null)
					{
						continue;
					}
					Type fieldType = jSGlobalField.FieldType;
					if ((jSGlobalField.IsLiteral && fieldType != Typeob.ScriptFunction && fieldType != Typeob.Type) || jSGlobalField.metaData != null)
					{
						if ((fieldType.IsPrimitive || fieldType == Typeob.String || fieldType.IsEnum) && jSGlobalField.metaData == null)
						{
							FieldBuilder fieldBuilder = base.compilerGlobals.classwriter.DefineField(jSGlobalField.Name, fieldType, jSGlobalField.Attributes);
							fieldBuilder.SetConstant(jSGlobalField.value);
						}
					}
					else if (!(jSGlobalField.value is FunctionObject) || !((FunctionObject)jSGlobalField.value).suppressIL)
					{
						FieldBuilder fieldBuilder2 = (FieldBuilder)(jSGlobalField.metaData = base.compilerGlobals.classwriter.DefineField(jSGlobalField.Name, fieldType, (jSGlobalField.Attributes & ~(FieldAttributes.InitOnly | FieldAttributes.Literal)) | FieldAttributes.Static));
						jSGlobalField.WriteCustomAttribute(base.Engine.doCRS);
					}
				}
			}
			statement_block.TranslateToILInitializer(il);
		}

		internal override Context GetFirstExecutableContext()
		{
			return statement_block.GetFirstExecutableContext();
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. Most of the constructor function classes, such as <see cref="T:Microsoft.JScript.DateConstructor" />, <see cref="T:Microsoft.JScript.NumberConstructor" />, <see cref="T:Microsoft.JScript.StringConstructor" />, and <see cref="T:Microsoft.JScript.ObjectConstructor" />, inherit from this class. This class belongs to the objects and functions category.</summary>
	public abstract class ScriptFunction : JSObject
	{
		/// <summary>Stores the number of elements that are in the <paramref name="args" /> parameter of the <see cref="M:Microsoft.JScript.ScriptFunction.CreateInstance(System.Object[])" /> method.</summary>
		protected int ilength;

		internal string name;

		internal object proto;

		/// <summary>Gets or sets the number of elements that are in the <paramref name="args" /> parameter of the <see cref="M:Microsoft.JScript.ScriptFunction.CreateInstance(System.Object[])" /> method.</summary>
		/// <returns>The number of elements that are in the <paramref name="args" /> parameter of the <see cref="M:Microsoft.JScript.ScriptFunction.CreateInstance(System.Object[])" /> method.</returns>
		public virtual int length
		{
			get
			{
				return ilength;
			}
			set
			{
			}
		}

		/// <summary>Gets or sets the prototype object for this constructor function.</summary>
		/// <returns>The prototype object for this constructor function.</returns>
		public object prototype
		{
			get
			{
				return proto;
			}
			set
			{
				if (!noExpando)
				{
					proto = value;
				}
			}
		}

		internal ScriptFunction(ScriptObject parent)
			: base(parent)
		{
			ilength = 0;
			name = "Function.prototype";
			proto = Missing.Value;
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.ScriptFunction" /> class.</summary>
		/// <param name="parent">The parent prototype of the object that this function constructs.</param>
		/// <param name="name">The name of the object that this function constructs.</param>
		protected ScriptFunction(ScriptObject parent, string name)
			: base(parent, typeof(ScriptFunction))
		{
			ilength = 0;
			this.name = name;
			proto = new JSPrototypeObject(parent.GetParent(), this);
		}

		internal ScriptFunction(ScriptObject parent, string name, int length)
			: base(parent)
		{
			ilength = length;
			this.name = name;
			proto = new JSPrototypeObject(parent.GetParent(), this);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal abstract object Call(object[] args, object thisob);

		internal virtual object Call(object[] args, object thisob, Binder binder, CultureInfo culture)
		{
			return Call(args, thisob);
		}

		internal virtual object Call(object[] args, object thisob, ScriptObject enclosing_scope, Closure calleeClosure, Binder binder, CultureInfo culture)
		{
			return Call(args, thisob);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal virtual object Construct(object[] args)
		{
			JSObject jSObject = new JSObject(null, checkSubType: false);
			jSObject.SetParent(GetPrototypeForConstructedObject());
			object obj = Call(args, jSObject);
			if (obj is ScriptObject || (this is BuiltinFunction && ((BuiltinFunction)this).method.Name.Equals("CreateInstance")))
			{
				return obj;
			}
			return jSObject;
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>An instance of the object.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public object CreateInstance(params object[] args)
		{
			return Construct(args);
		}

		internal override string GetClassName()
		{
			return "Function";
		}

		internal virtual int GetNumberOfFormalParameters()
		{
			return ilength;
		}

		/// <summary>Gets the prototype object for this constructor function.</summary>
		/// <returns>The prototype object for this constructor function.</returns>
		protected ScriptObject GetPrototypeForConstructedObject()
		{
			object obj = proto;
			if (obj is JSObject)
			{
				return (JSObject)obj;
			}
			if (obj is ClassScope)
			{
				return (ClassScope)obj;
			}
			return (ObjectPrototype)GetParent().GetParent();
		}

		internal virtual bool HasInstance(object ob)
		{
			if (!(ob is JSObject))
			{
				return false;
			}
			object obj = proto;
			if (!(obj is ScriptObject))
			{
				throw new JScriptException(JSError.InvalidPrototype);
			}
			ScriptObject scriptObject = ((JSObject)ob).GetParent();
			ScriptObject scriptObject2 = (ScriptObject)obj;
			while (scriptObject != null)
			{
				if (scriptObject == scriptObject2)
				{
					return true;
				}
				if (scriptObject is WithObject)
				{
					object contained_object = ((WithObject)scriptObject).contained_object;
					if (contained_object == scriptObject2 && contained_object is ClassScope)
					{
						return true;
					}
				}
				scriptObject = scriptObject.GetParent();
			}
			return false;
		}

		/// <summary>Invokes a method of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="args">The arguments to pass to the method.</param>
		/// <returns>The result of the call to the method.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasVarArgs)]
		public object Invoke(object thisob, params object[] args)
		{
			return Call(args, thisob);
		}

		/// <summary>Invokes the specified member.</summary>
		/// <param name="name">The name of the member to invoke.</param>
		/// <param name="invokeAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <param name="binder">An object that performs type conversion from actual argument type to formal argument type.</param>
		/// <param name="target">The object on which to invoke the member. This must be the current script object.</param>
		/// <param name="args">An array of objects that contains the number, order, and type of the parameters of the member to be invoked. This is an empty array if there are no parameters.</param>
		/// <param name="modifiers">An array that has the same length as the <paramref name="args" /> parameter. It represents the invoked member's argument attributes in the metadata.</param>
		/// <param name="culture">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		/// <param name="namedParameters">An array of parameters.</param>
		/// <returns>The return value of the call to the member.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters)
		{
			if (target != this)
			{
				throw new TargetException();
			}
			string value = "this";
			if (name.Equals("[DISPID=0]"))
			{
				name = string.Empty;
				if (namedParameters != null)
				{
					value = "[DISPID=-613]";
				}
			}
			if (name == null || name == string.Empty)
			{
				if ((invokeAttr & BindingFlags.CreateInstance) != 0)
				{
					if ((invokeAttr & (BindingFlags.InvokeMethod | BindingFlags.GetField | BindingFlags.SetField | BindingFlags.GetProperty | BindingFlags.SetProperty | BindingFlags.PutDispProperty)) != 0)
					{
						throw new ArgumentException();
					}
					return Construct(args);
				}
				if ((invokeAttr & BindingFlags.InvokeMethod) != 0)
				{
					object thisob = null;
					if (namedParameters != null)
					{
						int num = Array.IndexOf(namedParameters, value);
						if (num == 0)
						{
							thisob = args[0];
							int num2 = args.Length - 1;
							object[] array = new object[num2];
							ArrayObject.Copy(args, 1, array, 0, num2);
							args = array;
						}
						if (num != 0 || namedParameters.Length != 1)
						{
							throw new ArgumentException();
						}
					}
					if (args.Length != 0 || (invokeAttr & (BindingFlags.GetField | BindingFlags.GetProperty)) == 0)
					{
						return Call(args, thisob, binder, culture);
					}
				}
			}
			return base.InvokeMember(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
		}

		/// <summary>Returns a string representation of the constructor function.</summary>
		/// <returns>A string that contains the name of the constructor function and a placeholder for the code.</returns>
		public override string ToString()
		{
			return "function " + name + "() {\n    [native code]\n}";
		}
	}
	/// <summary>Supports all JScript classes. This is the ultimate base class of all JScript classes. This class belongs to the objects and functions category.</summary>
	[ComVisible(true)]
	public abstract class ScriptObject : IReflect
	{
		/// <summary>Stores a reference to the parent object.</summary>
		protected ScriptObject parent;

		internal SimpleHashtable wrappedMemberCache;

		/// <summary>Stores a reference to the scripting engine.</summary>
		public VsaEngine engine;

		/// <summary>Gets or sets a member of the script object that is designated by the specified <see cref="T:System.Double" /> index value.</summary>
		/// <param name="index">The index of the member.</param>
		/// <returns>The value of the member that is at <paramref name="index" />.</returns>
		public object this[double index]
		{
			get
			{
				if (this == null)
				{
					throw new JScriptException(JSError.ObjectExpected);
				}
				object obj = ((!(index >= 0.0) || !(index <= 4294967295.0) || index != Math.Round(index)) ? GetMemberValue(Convert.ToString(index)) : GetValueAtIndex((uint)index));
				if (!(obj is Missing))
				{
					return obj;
				}
				return null;
			}
			set
			{
				if (index >= 0.0 && index <= 4294967295.0 && index == Math.Round(index))
				{
					SetValueAtIndex((uint)index, value);
				}
				else
				{
					SetMemberValue(Convert.ToString(index), value);
				}
			}
		}

		/// <summary>Gets or sets a member of the script object that is designated by the specified <see cref="T:System.Int32" /> index value.</summary>
		/// <param name="index">The index of the member.</param>
		/// <returns>The value of the member that is at <paramref name="index" />.</returns>
		public object this[int index]
		{
			get
			{
				if (this == null)
				{
					throw new JScriptException(JSError.ObjectExpected);
				}
				object obj = ((index < 0) ? GetMemberValue(Convert.ToString(index)) : GetValueAtIndex((uint)index));
				if (!(obj is Missing))
				{
					return obj;
				}
				return null;
			}
			set
			{
				if (this == null)
				{
					throw new JScriptException(JSError.ObjectExpected);
				}
				if (index >= 0)
				{
					SetValueAtIndex((uint)index, value);
				}
				else
				{
					SetMemberValue(Convert.ToString(index), value);
				}
			}
		}

		/// <summary>Gets or sets a member of the script object that is designated by the specified name.</summary>
		/// <param name="name">The name of the member.</param>
		/// <returns>The value of the member that is named <paramref name="name" />.</returns>
		public object this[string name]
		{
			get
			{
				if (this == null)
				{
					throw new JScriptException(JSError.ObjectExpected);
				}
				object memberValue = GetMemberValue(name);
				if (!(memberValue is Missing))
				{
					return memberValue;
				}
				return null;
			}
			set
			{
				if (this == null)
				{
					throw new JScriptException(JSError.ObjectExpected);
				}
				SetMemberValue(name, value);
			}
		}

		/// <summary>Gets or sets a member of the script object that is designated by the specified name, <see cref="T:System.Double" /> index value, or <see cref="T:System.Int32" /> index value.</summary>
		/// <param name="pars">The name or index of the member.</param>
		/// <returns>The value of the member that is specified in <paramref name="pars" />.</returns>
		public object this[params object[] pars]
		{
			get
			{
				int num = pars.Length;
				if (num == 0)
				{
					if (this is ScriptFunction || this == null)
					{
						throw new JScriptException(JSError.FunctionExpected);
					}
					throw new JScriptException(JSError.TooFewParameters);
				}
				if (this == null)
				{
					throw new JScriptException(JSError.ObjectExpected);
				}
				object obj = pars[num - 1];
				if (obj is int)
				{
					return this[(int)obj];
				}
				IConvertible iConvertible = Convert.GetIConvertible(obj);
				if (iConvertible != null && Convert.IsPrimitiveNumericTypeCode(iConvertible.GetTypeCode()))
				{
					double num2 = iConvertible.ToDouble(null);
					if (num2 >= 0.0 && num2 <= 2147483647.0 && num2 == Math.Round(num2))
					{
						return this[(int)num2];
					}
				}
				return this[Convert.ToString(obj)];
			}
			set
			{
				int num = pars.Length;
				if (num == 0)
				{
					if (this == null)
					{
						throw new JScriptException(JSError.FunctionExpected);
					}
					if (this is ScriptFunction)
					{
						throw new JScriptException(JSError.CannotAssignToFunctionResult);
					}
					throw new JScriptException(JSError.TooFewParameters);
				}
				if (this == null)
				{
					throw new JScriptException(JSError.ObjectExpected);
				}
				object obj = pars[num - 1];
				if (obj is int)
				{
					this[(int)obj] = value;
					return;
				}
				IConvertible iConvertible = Convert.GetIConvertible(obj);
				if (iConvertible != null && Convert.IsPrimitiveNumericTypeCode(iConvertible.GetTypeCode()))
				{
					double num2 = iConvertible.ToDouble(null);
					if (num2 >= 0.0 && num2 <= 2147483647.0 && num2 == Math.Round(num2))
					{
						this[(int)num2] = value;
						return;
					}
				}
				this[Convert.ToString(obj)] = value;
			}
		}

		/// <summary>Gets the type of the script object.</summary>
		/// <returns>The type of the script object.</returns>
		public virtual Type UnderlyingSystemType => GetType();

		internal ScriptObject(ScriptObject parent)
		{
			this.parent = parent;
			wrappedMemberCache = null;
			if (this.parent != null)
			{
				engine = parent.engine;
			}
			else
			{
				engine = null;
			}
		}

		internal virtual bool DeleteMember(string name)
		{
			return false;
		}

		internal virtual object GetDefaultValue(PreferredType preferred_type)
		{
			throw new JScriptException(JSError.InternalError);
		}

		/// <summary>Gets a field that has the specified name.</summary>
		/// <param name="name">The name of the field to get.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>A field that has the specified <paramref name="name" />, or null if the script object does not contain the field.</returns>
		public FieldInfo GetField(string name, BindingFlags bindingAttr)
		{
			MemberInfo[] member = GetMember(name, bindingAttr);
			foreach (MemberInfo memberInfo in member)
			{
				if (memberInfo.MemberType == MemberTypes.Field)
				{
					return (FieldInfo)memberInfo;
				}
			}
			return null;
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.FieldInfo" /> objects that correspond to all fields of the current script object.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all fields of the current script object.</returns>
		public virtual FieldInfo[] GetFields(BindingFlags bindingAttr)
		{
			if (this is ArrayObject arrayObject && arrayObject.denseArrayLength != 0)
			{
				uint num = arrayObject.denseArrayLength;
				if (num > arrayObject.len)
				{
					num = arrayObject.len;
				}
				for (uint num2 = 0u; num2 < num; num2++)
				{
					object obj = arrayObject.denseArray[num2];
					if (obj != Missing.Value)
					{
						arrayObject.SetMemberValue2(num2.ToString(CultureInfo.InvariantCulture), obj);
					}
				}
				arrayObject.denseArrayLength = 0u;
				arrayObject.denseArray = null;
			}
			MemberInfo[] members = GetMembers(bindingAttr);
			if (members == null)
			{
				return new FieldInfo[0];
			}
			int num3 = 0;
			MemberInfo[] array = members;
			foreach (MemberInfo memberInfo in array)
			{
				if (memberInfo.MemberType == MemberTypes.Field)
				{
					num3++;
				}
			}
			FieldInfo[] array2 = new FieldInfo[num3];
			num3 = 0;
			MemberInfo[] array3 = members;
			foreach (MemberInfo memberInfo2 in array3)
			{
				if (memberInfo2.MemberType == MemberTypes.Field)
				{
					array2[num3++] = (FieldInfo)memberInfo2;
				}
			}
			return array2;
		}

		/// <summary>When overridden in a derived class, gets an array of <see cref="T:System.Reflection.MemberInfo" /> objects that correspond to all members that match a specified name.</summary>
		/// <param name="name">The name of the member to search for.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that match the <paramref name="name" /> argument.</returns>
		public abstract MemberInfo[] GetMember(string name, BindingFlags bindingAttr);

		internal virtual object GetMemberValue(string name)
		{
			MemberInfo[] member = GetMember(name, BindingFlags.Instance | BindingFlags.Public);
			if (member.Length == 0)
			{
				return Missing.Value;
			}
			return LateBinding.GetMemberValue(this, name, LateBinding.SelectMember(member), member);
		}

		/// <summary>When overridden in a derived class, gets an array of <see cref="T:System.Reflection.MemberInfo" /> objects that correspond to all members of the current script object.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all members of the current script object.</returns>
		public abstract MemberInfo[] GetMembers(BindingFlags bindingAttr);

		/// <summary>Gets a method that has the specified name.</summary>
		/// <param name="name">The name of the method to get.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>A method that has the specified <paramref name="name" />, or null if the script object does not contain the method.</returns>
		public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
		{
			return GetMethod(name, bindingAttr, JSBinder.ob, Type.EmptyTypes, null);
		}

		/// <summary>Gets a method that has the specified name by using the specified selection criteria.</summary>
		/// <param name="name">The name of the method to search for.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <param name="binder">An object that performs type conversion from actual argument type to formal argument type.</param>
		/// <param name="types">The parameter types that are used to locate a matching method.</param>
		/// <param name="modifiers">An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified.</param>
		/// <returns>A method that has the specified <paramref name="name" />, or null if the script object does not contain the method.</returns>
		public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
		{
			MemberInfo[] member = GetMember(name, bindingAttr);
			if (member.Length == 1)
			{
				return member[0] as MethodInfo;
			}
			int num = 0;
			MemberInfo[] array = member;
			foreach (MemberInfo memberInfo in array)
			{
				if (memberInfo.MemberType == MemberTypes.Method)
				{
					num++;
				}
			}
			if (num == 0)
			{
				return null;
			}
			MethodInfo[] array2 = new MethodInfo[num];
			num = 0;
			MemberInfo[] array3 = member;
			foreach (MemberInfo memberInfo2 in array3)
			{
				if (memberInfo2.MemberType == MemberTypes.Method)
				{
					array2[num++] = (MethodInfo)memberInfo2;
				}
			}
			if (binder == null)
			{
				binder = JSBinder.ob;
			}
			Binder binder2 = binder;
			MethodBase[] match = array2;
			return (MethodInfo)binder2.SelectMethod(bindingAttr, match, types, modifiers);
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.MethodInfo" /> objects that correspond to all methods of the current script object.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all methods of the current script object.</returns>
		public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr)
		{
			MemberInfo[] members = GetMembers(bindingAttr);
			if (members == null)
			{
				return new MethodInfo[0];
			}
			int num = 0;
			MemberInfo[] array = members;
			foreach (MemberInfo memberInfo in array)
			{
				if (memberInfo.MemberType == MemberTypes.Method)
				{
					num++;
				}
			}
			MethodInfo[] array2 = new MethodInfo[num];
			num = 0;
			MemberInfo[] array3 = members;
			foreach (MemberInfo memberInfo2 in array3)
			{
				if (memberInfo2.MemberType == MemberTypes.Method)
				{
					array2[num++] = (MethodInfo)memberInfo2;
				}
			}
			return array2;
		}

		/// <summary>Gets a reference to the parent object.</summary>
		/// <returns>A reference to the parent object.</returns>
		public ScriptObject GetParent()
		{
			return parent;
		}

		internal virtual void GetPropertyEnumerator(ArrayList enums, ArrayList objects)
		{
			MemberInfo[] members = GetMembers(BindingFlags.Instance | BindingFlags.Public);
			if (members.Length != 0)
			{
				enums.Add(members.GetEnumerator());
				objects.Add(this);
			}
			GetParent()?.GetPropertyEnumerator(enums, objects);
		}

		/// <summary>Gets a property that has the specified name.</summary>
		/// <param name="name">The name of the property to get.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>A property that has the specified <paramref name="name" />, or null if the script object does not contain the property.</returns>
		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
		{
			return GetProperty(name, bindingAttr, JSBinder.ob, null, Type.EmptyTypes, null);
		}

		/// <summary>Gets a property that has the specified name by using the specified selection criteria.</summary>
		/// <param name="name">The name of the property to search for.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <param name="binder">An object that performs type conversion from actual argument type to formal argument type.</param>
		/// <param name="returnType">The type of the return value that the property must have.</param>
		/// <param name="types">The index types of the property being searched for. Used for index properties, such as the indexer for a class.</param>
		/// <param name="modifiers">An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified.</param>
		/// <returns>A property that has the specified <paramref name="name" />, or null if the script object does not contain the property.</returns>
		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
		{
			MemberInfo[] member = GetMember(name, bindingAttr);
			if (member.Length == 1)
			{
				return member[0] as PropertyInfo;
			}
			int num = 0;
			MemberInfo[] array = member;
			foreach (MemberInfo memberInfo in array)
			{
				if (memberInfo.MemberType == MemberTypes.Property)
				{
					num++;
				}
			}
			if (num == 0)
			{
				return null;
			}
			PropertyInfo[] array2 = new PropertyInfo[num];
			num = 0;
			MemberInfo[] array3 = member;
			foreach (MemberInfo memberInfo2 in array3)
			{
				if (memberInfo2.MemberType == MemberTypes.Property)
				{
					array2[num++] = (PropertyInfo)memberInfo2;
				}
			}
			if (binder == null)
			{
				binder = JSBinder.ob;
			}
			return binder.SelectProperty(bindingAttr, array2, returnType, types, modifiers);
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.PropertyInfo" /> objects that correspond to all properties of the current script object.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all properties of the current script object.</returns>
		public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr)
		{
			MemberInfo[] members = GetMembers(bindingAttr);
			if (members == null)
			{
				return new PropertyInfo[0];
			}
			int num = 0;
			MemberInfo[] array = members;
			foreach (MemberInfo memberInfo in array)
			{
				if (memberInfo.MemberType == MemberTypes.Property)
				{
					num++;
				}
			}
			PropertyInfo[] array2 = new PropertyInfo[num];
			num = 0;
			MemberInfo[] array3 = members;
			foreach (MemberInfo memberInfo2 in array3)
			{
				if (memberInfo2.MemberType == MemberTypes.Property)
				{
					array2[num++] = (PropertyInfo)memberInfo2;
				}
			}
			return array2;
		}

		internal virtual object GetValueAtIndex(uint index)
		{
			return GetMemberValue(index.ToString(CultureInfo.CurrentUICulture));
		}

		/// <summary>Invokes the specified member.</summary>
		/// <param name="name">The name of the member to invoke.</param>
		/// <param name="invokeAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <param name="binder">An object that performs type conversion from actual argument type to formal argument type.</param>
		/// <param name="target">The object on which to invoke the member. This must be the current script object.</param>
		/// <param name="args">An array of objects that contains the number, order, and type of the parameters of the member to be invoked. This is an empty array if there are no parameters.</param>
		/// <param name="modifiers">An array that has the same length as the args parameter. It represents the invoked member's argument attributes in the metadata.</param>
		/// <param name="locale">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		/// <param name="namedParameters">An array of parameters.</param>
		/// <returns>The return value of the call to the member.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo locale, string[] namedParameters)
		{
			if (target != this)
			{
				throw new TargetException();
			}
			bool flag = name.StartsWith("< JScript-", StringComparison.Ordinal);
			bool flag2 = name == null || name == string.Empty || name.Equals("[DISPID=0]") || flag;
			if ((invokeAttr & BindingFlags.CreateInstance) != 0)
			{
				if ((invokeAttr & (BindingFlags.InvokeMethod | BindingFlags.GetField | BindingFlags.SetField | BindingFlags.GetProperty | BindingFlags.SetProperty | BindingFlags.PutDispProperty)) != 0)
				{
					throw new ArgumentException(JScriptException.Localize("Bad binding flags", locale));
				}
				if (flag2)
				{
					throw new MissingMethodException();
				}
				LateBinding lateBinding = new LateBinding(name, this);
				return lateBinding.Call(binder, args, modifiers, locale, namedParameters, construct: true, brackets: false, engine);
			}
			if (name == null)
			{
				throw new ArgumentException(JScriptException.Localize("Bad name", locale));
			}
			if ((invokeAttr & (BindingFlags.InvokeMethod | BindingFlags.GetField | BindingFlags.GetProperty)) != 0)
			{
				if ((invokeAttr & (BindingFlags.SetField | BindingFlags.SetProperty | BindingFlags.PutDispProperty)) != 0)
				{
					throw new ArgumentException(JScriptException.Localize("Bad binding flags", locale));
				}
				if (flag2)
				{
					if ((invokeAttr & (BindingFlags.GetField | BindingFlags.GetProperty)) == 0)
					{
						throw new MissingMethodException();
					}
					if (args == null || args.Length == 0)
					{
						if (this is JSObject || this is GlobalScope || this is ClassScope)
						{
							PreferredType preferred_type = PreferredType.Either;
							if (flag)
							{
								if (name.StartsWith("< JScript-Number", StringComparison.Ordinal))
								{
									preferred_type = PreferredType.Number;
								}
								else if (name.StartsWith("< JScript-String", StringComparison.Ordinal))
								{
									preferred_type = PreferredType.String;
								}
								else if (name.StartsWith("< JScript-LocaleString", StringComparison.Ordinal))
								{
									preferred_type = PreferredType.LocaleString;
								}
							}
							return GetDefaultValue(preferred_type);
						}
						throw new MissingFieldException();
					}
					if (args.Length > 1)
					{
						throw new ArgumentException(JScriptException.Localize("Too many arguments", locale));
					}
					object obj = args[0];
					if (obj is int)
					{
						return this[(int)obj];
					}
					IConvertible iConvertible = Convert.GetIConvertible(obj);
					if (iConvertible != null && Convert.IsPrimitiveNumericTypeCode(iConvertible.GetTypeCode()))
					{
						double num = iConvertible.ToDouble(null);
						if (num >= 0.0 && num <= 2147483647.0 && num == Math.Round(num))
						{
							return this[(int)num];
						}
					}
					return this[Convert.ToString(obj)];
				}
				if ((args == null || args.Length == 0) && (invokeAttr & (BindingFlags.GetField | BindingFlags.GetProperty)) != 0)
				{
					object memberValue = GetMemberValue(name);
					if (memberValue != Missing.Value)
					{
						return memberValue;
					}
					if ((invokeAttr & BindingFlags.InvokeMethod) == 0)
					{
						throw new MissingFieldException();
					}
				}
				LateBinding lateBinding2 = new LateBinding(name, this);
				return lateBinding2.Call(binder, args, modifiers, locale, namedParameters, construct: false, brackets: false, engine);
			}
			if ((invokeAttr & (BindingFlags.SetField | BindingFlags.SetProperty | BindingFlags.PutDispProperty)) != 0)
			{
				if (flag2)
				{
					if (args == null || args.Length < 2)
					{
						throw new ArgumentException(JScriptException.Localize("Too few arguments", locale));
					}
					if (args.Length > 2)
					{
						throw new ArgumentException(JScriptException.Localize("Too many arguments", locale));
					}
					object obj2 = args[0];
					if (obj2 is int)
					{
						this[(int)obj2] = args[1];
						return null;
					}
					IConvertible iConvertible2 = Convert.GetIConvertible(obj2);
					if (iConvertible2 != null && Convert.IsPrimitiveNumericTypeCode(iConvertible2.GetTypeCode()))
					{
						double num2 = iConvertible2.ToDouble(null);
						if (num2 >= 0.0 && num2 <= 2147483647.0 && num2 == Math.Round(num2))
						{
							this[(int)num2] = args[1];
							return null;
						}
					}
					this[Convert.ToString(obj2)] = args[1];
					return null;
				}
				if (args == null || args.Length < 1)
				{
					throw new ArgumentException(JScriptException.Localize("Too few arguments", locale));
				}
				if (args.Length > 1)
				{
					throw new ArgumentException(JScriptException.Localize("Too many arguments", locale));
				}
				SetMemberValue(name, args[0]);
				return null;
			}
			throw new ArgumentException(JScriptException.Localize("Bad binding flags", locale));
		}

		internal virtual void SetMemberValue(string name, object value)
		{
			MemberInfo[] member = GetMember(name, BindingFlags.Instance | BindingFlags.Public);
			LateBinding.SetMemberValue(this, name, value, LateBinding.SelectMember(member), member);
		}

		internal void SetParent(ScriptObject parent)
		{
			this.parent = parent;
			if (parent != null)
			{
				engine = parent.engine;
			}
		}

		internal virtual void SetValueAtIndex(uint index, object value)
		{
			SetMemberValue(index.ToString(CultureInfo.InvariantCulture), value);
		}

		/// <summary>Creates an array of wrapped objects that contain the specified members together with the specified object.</summary>
		/// <param name="members">The members to wrap.</param>
		/// <param name="obj">The object that <paramref name="members" /> are defined on.</param>
		/// <returns>An array of wrapped objects, each of which contains member information and a copy of <paramref name="obj" />.</returns>
		protected static MemberInfo[] WrapMembers(MemberInfo[] members, object obj)
		{
			if (members == null)
			{
				return null;
			}
			int num = members.Length;
			if (num == 0)
			{
				return members;
			}
			MemberInfo[] array = new MemberInfo[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = WrapMember(members[i], obj);
			}
			return array;
		}

		/// <summary>Creates a wrapped object that contains the specified member together with the specified object.</summary>
		/// <param name="member">The member to wrap.</param>
		/// <param name="obj">The object that <paramref name="member" /> is defined on.</param>
		/// <returns>A one-element array that has a wrapped object that contains the member information and <paramref name="obj" />.</returns>
		protected static MemberInfo[] WrapMembers(MemberInfo member, object obj)
		{
			return new MemberInfo[1] { WrapMember(member, obj) };
		}

		/// <summary>Creates an array of wrapped objects that contain the specified members together with the specified object, caching the results in the specified data storage.</summary>
		/// <param name="members">The members to wrap.</param>
		/// <param name="obj">The object that <paramref name="members" /> are defined on.</param>
		/// <param name="cache">Temporary data storage for the wrapped objects.</param>
		/// <returns>An array of wrapped objects, each of which contains member information and a copy of <paramref name="obj" />.</returns>
		protected static MemberInfo[] WrapMembers(MemberInfo[] members, object obj, SimpleHashtable cache)
		{
			if (members == null)
			{
				return null;
			}
			int num = members.Length;
			if (num == 0)
			{
				return members;
			}
			MemberInfo[] array = new MemberInfo[num];
			for (int i = 0; i < num; i++)
			{
				MemberInfo memberInfo = (MemberInfo)cache[members[i]];
				if (null == memberInfo)
				{
					memberInfo = WrapMember(members[i], obj);
					cache[members[i]] = memberInfo;
				}
				array[i] = memberInfo;
			}
			return array;
		}

		internal static MemberInfo WrapMember(MemberInfo member, object obj)
		{
			switch (member.MemberType)
			{
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				if (fieldInfo.IsStatic || fieldInfo.IsLiteral)
				{
					return fieldInfo;
				}
				if (!(fieldInfo is JSWrappedField))
				{
					return new JSWrappedField(fieldInfo, obj);
				}
				return fieldInfo;
			}
			case MemberTypes.Method:
			{
				MethodInfo methodInfo = (MethodInfo)member;
				if (methodInfo.IsStatic)
				{
					return methodInfo;
				}
				if (!(methodInfo is JSWrappedMethod))
				{
					return new JSWrappedMethod(methodInfo, obj);
				}
				return methodInfo;
			}
			case MemberTypes.Property:
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				if (propertyInfo is JSWrappedProperty)
				{
					return propertyInfo;
				}
				MethodInfo getMethod = JSProperty.GetGetMethod(propertyInfo, nonPublic: true);
				MethodInfo setMethod = JSProperty.GetSetMethod(propertyInfo, nonPublic: true);
				if ((getMethod == null || getMethod.IsStatic) && (setMethod == null || setMethod.IsStatic))
				{
					return propertyInfo;
				}
				return new JSWrappedProperty(propertyInfo, obj);
			}
			default:
				return member;
			}
		}
	}
	internal class ScriptObjectPropertyEnumerator : IEnumerator
	{
		private ArrayList enumerators;

		private ArrayList objects;

		private int index;

		private SimpleHashtable visited_names;

		public virtual object Current
		{
			get
			{
				object current = ((IEnumerator)enumerators[index]).Current;
				if (current is MemberInfo)
				{
					return ((MemberInfo)current).Name;
				}
				return current.ToString();
			}
		}

		internal ScriptObjectPropertyEnumerator(ScriptObject obj)
		{
			obj.GetPropertyEnumerator(enumerators = new ArrayList(), objects = new ArrayList());
			index = 0;
			visited_names = new SimpleHashtable(16u);
		}

		public virtual bool MoveNext()
		{
			if (index >= enumerators.Count)
			{
				return false;
			}
			IEnumerator enumerator = (IEnumerator)enumerators[index];
			if (!enumerator.MoveNext())
			{
				index++;
				return MoveNext();
			}
			object current = enumerator.Current;
			FieldInfo fieldInfo = current as FieldInfo;
			string text;
			if (!(fieldInfo != null))
			{
				text = ((current is string) ? ((string)current) : ((!(current is MemberInfo)) ? current.ToString() : ((MemberInfo)current).Name));
			}
			else
			{
				JSPrototypeField jSPrototypeField = current as JSPrototypeField;
				if (jSPrototypeField != null && jSPrototypeField.value is Missing)
				{
					return MoveNext();
				}
				text = fieldInfo.Name;
				object value = fieldInfo.GetValue(objects[index]);
				if (value is Missing)
				{
					return MoveNext();
				}
			}
			if (visited_names[text] != null)
			{
				return MoveNext();
			}
			visited_names[text] = text;
			return true;
		}

		public virtual void Reset()
		{
			index = 0;
			foreach (IEnumerator enumerator2 in enumerators)
			{
				enumerator2.Reset();
			}
			visited_names = new SimpleHashtable(16u);
		}
	}
	/// <summary>Represents a stream of data. This class sends its data to either a <see cref="T:Microsoft.JScript.COMCharStream" /> or a <see cref="T:System.Console" /> stream.</summary>
	public class ScriptStream
	{
		/// <summary>Stores a reference to either the standard console <see cref="P:System.Console.Out" /> stream or a custom <see cref="T:Microsoft.JScript.COMCharStream" />.</summary>
		public static TextWriter Out = Console.Out;

		/// <summary>Stores a reference to either the standard console <see cref="P:System.Console.Error" /> stream or a custom <see cref="T:Microsoft.JScript.COMCharStream" />.</summary>
		public static TextWriter Error = Console.Error;

		/// <summary>Writes a string that describes the current contents of the call stack. The string is written to the <see cref="F:Microsoft.JScript.ScriptStream.Out" /> stream.</summary>
		public static void PrintStackTrace()
		{
			try
			{
				throw new Exception();
			}
			catch (Exception e)
			{
				PrintStackTrace(e);
			}
		}

		/// <summary>Writes a string that describes the contents of the call stack at the time the specified exception was thrown. The string is written to the <see cref="F:Microsoft.JScript.ScriptStream.Out" /> stream.</summary>
		/// <param name="e">The exception that was thrown.</param>
		public static void PrintStackTrace(Exception e)
		{
			Out.WriteLine(e.StackTrace);
			Out.Flush();
		}

		/// <summary>Writes the specified string to the stream. The string is written to the <see cref="F:Microsoft.JScript.ScriptStream.Out" /> stream.</summary>
		/// <param name="str">The string to write to the stream.</param>
		public static void Write(string str)
		{
			Out.Write(str);
		}

		/// <summary>Writes the specified string to the stream, followed by the line terminator. The string is written to the <see cref="F:Microsoft.JScript.ScriptStream.Out" /> stream.</summary>
		/// <param name="str">The string to write to the stream.</param>
		public static void WriteLine(string str)
		{
			Out.WriteLine(str);
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.ScriptStream" /> class.</summary>
		public ScriptStream()
		{
		}
	}
	internal sealed class HashtableEntry
	{
		internal object key;

		internal object value;

		internal uint hashCode;

		internal HashtableEntry next;

		internal HashtableEntry(object key, object value, uint hashCode, HashtableEntry next)
		{
			this.key = key;
			this.value = value;
			this.hashCode = hashCode;
			this.next = next;
		}
	}
	/// <summary>A hash table for the internal storage of items.</summary>
	public sealed class SimpleHashtable
	{
		private HashtableEntry[] table;

		internal int count;

		private uint threshold;

		/// <summary>Gets or sets the item that has the specified key.</summary>
		/// <param name="key">The key of the item to get or set.</param>
		/// <returns>The value of the item that has the specified <paramref name="key" />.</returns>
		public object this[object key]
		{
			get
			{
				return GetHashtableEntry(key, (uint)key.GetHashCode())?.value;
			}
			set
			{
				uint hashCode = (uint)key.GetHashCode();
				HashtableEntry hashtableEntry = GetHashtableEntry(key, hashCode);
				if (hashtableEntry != null)
				{
					hashtableEntry.value = value;
					return;
				}
				if (++count >= threshold)
				{
					Rehash();
				}
				int num = (int)(hashCode % (uint)table.Length);
				table[num] = new HashtableEntry(key, value, hashCode, table[num]);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.SimpleHashtable" /> class, using the specified threshold.</summary>
		/// <param name="threshold">The number of items at which the hash table must be resized.</param>
		public SimpleHashtable(uint threshold)
		{
			if (threshold < 8)
			{
				threshold = 8u;
			}
			table = new HashtableEntry[threshold * 2 - 1];
			count = 0;
			this.threshold = threshold;
		}

		/// <summary>Gets an enumerator for the hash table.</summary>
		/// <returns>An enumerator for the hash table.</returns>
		public IDictionaryEnumerator GetEnumerator()
		{
			return new SimpleHashtableEnumerator(table);
		}

		private HashtableEntry GetHashtableEntry(object key, uint hashCode)
		{
			int num = (int)(hashCode % (uint)table.Length);
			HashtableEntry hashtableEntry = table[num];
			if (hashtableEntry == null)
			{
				return null;
			}
			if (hashtableEntry.key == key)
			{
				return hashtableEntry;
			}
			HashtableEntry hashtableEntry2 = hashtableEntry;
			for (HashtableEntry next = hashtableEntry.next; next != null; next = next.next)
			{
				if (next.key == key)
				{
					return next;
				}
				hashtableEntry2 = next;
			}
			if (hashtableEntry.hashCode == hashCode && hashtableEntry.key.Equals(key))
			{
				hashtableEntry.key = key;
				return hashtableEntry;
			}
			hashtableEntry2 = hashtableEntry;
			for (HashtableEntry next = hashtableEntry.next; next != null; next = next.next)
			{
				if (next.hashCode == hashCode && next.key.Equals(key))
				{
					next.key = key;
					return next;
				}
				hashtableEntry2 = next;
			}
			return null;
		}

		internal object IgnoreCaseGet(string name)
		{
			uint num = 0u;
			for (uint num2 = (uint)table.Length; num < num2; num++)
			{
				for (HashtableEntry hashtableEntry = table[num]; hashtableEntry != null; hashtableEntry = hashtableEntry.next)
				{
					if (string.Compare((string)hashtableEntry.key, name, StringComparison.OrdinalIgnoreCase) == 0)
					{
						return hashtableEntry.value;
					}
				}
			}
			return null;
		}

		private void Rehash()
		{
			HashtableEntry[] array = table;
			uint num = (threshold = (uint)(array.Length + 1));
			uint num2 = num * 2 - 1;
			HashtableEntry[] array2 = (table = new HashtableEntry[num2]);
			uint num3 = num - 1;
			while (num3-- != 0)
			{
				HashtableEntry hashtableEntry = array[num3];
				while (hashtableEntry != null)
				{
					HashtableEntry hashtableEntry2 = hashtableEntry;
					hashtableEntry = hashtableEntry.next;
					int num4 = (int)(hashtableEntry2.hashCode % num2);
					hashtableEntry2.next = array2[num4];
					array2[num4] = hashtableEntry2;
				}
			}
		}

		/// <summary>Removes the item with the specified key from the hash table.</summary>
		/// <param name="key">The key of the item to remove.</param>
		public void Remove(object key)
		{
			uint hashCode = (uint)key.GetHashCode();
			int num = (int)(hashCode % (uint)table.Length);
			HashtableEntry hashtableEntry = table[num];
			count--;
			while (hashtableEntry != null && hashtableEntry.hashCode == hashCode && (hashtableEntry.key == key || hashtableEntry.key.Equals(key)))
			{
				hashtableEntry = hashtableEntry.next;
			}
			table[num] = hashtableEntry;
			while (hashtableEntry != null)
			{
				HashtableEntry next = hashtableEntry.next;
				while (next != null && next.hashCode == hashCode && (next.key == key || next.key.Equals(key)))
				{
					next = next.next;
				}
				hashtableEntry.next = next;
				hashtableEntry = next;
			}
		}
	}
	internal sealed class SimpleHashtableEnumerator : IDictionaryEnumerator, IEnumerator
	{
		private HashtableEntry[] table;

		private int count;

		private int index;

		private HashtableEntry currentEntry;

		public object Current => Key;

		public DictionaryEntry Entry => new DictionaryEntry(Key, Value);

		public object Key => currentEntry.key;

		public object Value => currentEntry.value;

		internal SimpleHashtableEnumerator(HashtableEntry[] table)
		{
			this.table = table;
			count = table.Length;
			index = -1;
			currentEntry = null;
		}

		public bool MoveNext()
		{
			HashtableEntry[] array = table;
			if (currentEntry != null)
			{
				currentEntry = currentEntry.next;
				if (currentEntry != null)
				{
					return true;
				}
			}
			int i = ++index;
			for (int num = count; i < num; i++)
			{
				if (array[i] != null)
				{
					index = i;
					currentEntry = array[i];
					return true;
				}
			}
			return false;
		}

		public void Reset()
		{
			index = -1;
			currentEntry = null;
		}
	}
	internal sealed class Stack
	{
		private object[] elements;

		private int top;

		internal Stack()
		{
			elements = new object[32];
			top = -1;
		}

		internal void GuardedPush(object item)
		{
			if (top > 500)
			{
				throw new JScriptException(JSError.OutOfStack);
			}
			if (++top >= elements.Length)
			{
				object[] target = new object[elements.Length + 32];
				ArrayObject.Copy(elements, target, elements.Length);
				elements = target;
			}
			elements[top] = item;
		}

		internal void Push(object item)
		{
			if (++top >= elements.Length)
			{
				object[] target = new object[elements.Length + 32];
				ArrayObject.Copy(elements, target, elements.Length);
				elements = target;
			}
			elements[top] = item;
		}

		internal object Pop()
		{
			object result = elements[top];
			elements[top--] = null;
			return result;
		}

		internal ScriptObject Peek()
		{
			if (top < 0)
			{
				return null;
			}
			return (ScriptObject)elements[top];
		}

		internal object Peek(int i)
		{
			return elements[top - i];
		}

		internal int Size()
		{
			return top + 1;
		}

		internal void TrimToSize(int i)
		{
			top = i - 1;
		}
	}
	/// <summary>Represents a stack frame for executing code. This class contains methods for resolving scope. It belongs to the compilation and run-time state category.</summary>
	public sealed class StackFrame : ScriptObject, IActivationObject
	{
		internal ArgumentsObject caller_arguments;

		private JSLocalField[] fields;

		/// <summary>Stores the local variables for this stack frame.</summary>
		public object[] localVars;

		private FunctionScope nestedFunctionScope;

		internal object thisObject;

		/// <summary>Stores a reference to the caller of the current stack frame.</summary>
		public object closureInstance;

		internal StackFrame(ScriptObject parent, JSLocalField[] fields, object[] local_vars, object thisObject)
			: base(parent)
		{
			caller_arguments = null;
			this.fields = fields;
			localVars = local_vars;
			nestedFunctionScope = null;
			this.thisObject = thisObject;
			if (parent is StackFrame)
			{
				closureInstance = ((StackFrame)parent).closureInstance;
			}
			else if (parent is JSObject)
			{
				closureInstance = parent;
			}
			else
			{
				closureInstance = null;
			}
		}

		internal JSVariableField AddNewField(string name, object value, FieldAttributes attributeFlags)
		{
			AllocateFunctionScope();
			return nestedFunctionScope.AddNewField(name, value, attributeFlags);
		}

		private void AllocateFunctionScope()
		{
			if (nestedFunctionScope != null)
			{
				return;
			}
			nestedFunctionScope = new FunctionScope(parent);
			if (fields != null)
			{
				int i = 0;
				for (int num = fields.Length; i < num; i++)
				{
					nestedFunctionScope.AddOuterScopeField(fields[i].Name, fields[i]);
				}
			}
		}

		/// <summary>Gets the current default scope, which will be either the contained object of a <see langword="with" /> statement scope, or the global scope.</summary>
		/// <returns>The current default scope.</returns>
		public object GetDefaultThisObject()
		{
			ScriptObject scriptObject = GetParent();
			if (scriptObject is IActivationObject activationObject)
			{
				return activationObject.GetDefaultThisObject();
			}
			return scriptObject;
		}

		/// <summary>Gets a field that has the specified name by searching the scope hierarchy. This method searches only the scope that is specified by the lexical level.</summary>
		/// <param name="name">The name of the field to search for.</param>
		/// <param name="lexLevel">The lexical level to search.</param>
		/// <returns>null in all cases.</returns>
		public FieldInfo GetField(string name, int lexLevel)
		{
			return null;
		}

		/// <summary>Gets the global scope by searching the scope hierarchy until it finds a scope that includes static variables, for example, a module scope.</summary>
		/// <returns>The global scope.</returns>
		public GlobalScope GetGlobalScope()
		{
			return ((IActivationObject)GetParent()).GetGlobalScope();
		}

		/// <summary>Gets the local declaration of a field that has the specified name. This method is used at compile time for error checking.</summary>
		/// <param name="name">The name of the field.</param>
		/// <returns>The local declaration of the field.</returns>
		FieldInfo IActivationObject.GetLocalField(string name)
		{
			AllocateFunctionScope();
			return nestedFunctionScope.GetLocalField(name);
		}

		/// <summary>Retrieves an array of <see cref="T:System.Reflection.MemberInfo" /> objects that correspond to all members that match a specified name.</summary>
		/// <param name="name">The member name to search for.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that match the <paramref name="name" /> argument.</returns>
		public override MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
		{
			AllocateFunctionScope();
			return nestedFunctionScope.GetMember(name, bindingAttr);
		}

		/// <summary>Retrieves an array of <see cref="T:System.Reflection.MemberInfo" /> objects that correspond to all members of the current object.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all members of the current object.</returns>
		public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
		{
			AllocateFunctionScope();
			return nestedFunctionScope.GetMembers(bindingAttr);
		}

		internal override void GetPropertyEnumerator(ArrayList enums, ArrayList objects)
		{
			throw new JScriptException(JSError.InternalError);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object GetMemberValue(string name)
		{
			AllocateFunctionScope();
			return nestedFunctionScope.GetMemberValue(name);
		}

		/// <summary>Gets the value of the specified member by searching the scope hierarchy. This method searches only the scope that is specified by the lexical level.</summary>
		/// <param name="name">The name of the member to search for.</param>
		/// <param name="lexlevel">The lexical level to search.</param>
		/// <returns>The value of the member <paramref name="name" />.</returns>
		[DebuggerStepThrough]
		[DebuggerHidden]
		public object GetMemberValue(string name, int lexlevel)
		{
			if (lexlevel <= 0)
			{
				return Missing.Value;
			}
			if (nestedFunctionScope != null)
			{
				return nestedFunctionScope.GetMemberValue(name, lexlevel);
			}
			return ((IActivationObject)parent).GetMemberValue(name, lexlevel - 1);
		}

		/// <summary>Creates a new <see cref="T:Microsoft.JScript.StackFrame" /> object for a static method and pushes it onto the global scope stack.</summary>
		/// <param name="thisclass">The class that contains the static method.</param>
		/// <param name="fields">The local variables for the stack frame.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		public static void PushStackFrameForStaticMethod(RuntimeTypeHandle thisclass, JSLocalField[] fields, VsaEngine engine)
		{
			PushStackFrameForMethod(Type.GetTypeFromHandle(thisclass), fields, engine);
		}

		/// <summary>Creates a new <see cref="T:Microsoft.JScript.StackFrame" /> object for a method and pushes it onto the global scope stack.</summary>
		/// <param name="thisob">The object that contains the method.</param>
		/// <param name="fields">The local variables for the stack frame.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		public static void PushStackFrameForMethod(object thisob, JSLocalField[] fields, VsaEngine engine)
		{
			Globals globals = engine.Globals;
			IActivationObject activationObject = (IActivationObject)globals.ScopeStack.Peek();
			string @namespace = thisob.GetType().Namespace;
			WithObject withObject = null;
			if (@namespace != null && @namespace.Length > 0)
			{
				withObject = new WithObject(activationObject.GetGlobalScope(), new WrappedNamespace(@namespace, engine));
				withObject.isKnownAtCompileTime = true;
				withObject = new WithObject(withObject, thisob);
			}
			else
			{
				withObject = new WithObject(activationObject.GetGlobalScope(), thisob);
			}
			withObject.isKnownAtCompileTime = true;
			StackFrame stackFrame = new StackFrame(withObject, fields, new object[fields.Length], thisob);
			stackFrame.closureInstance = thisob;
			globals.ScopeStack.GuardedPush(stackFrame);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override void SetMemberValue(string name, object value)
		{
			AllocateFunctionScope();
			nestedFunctionScope.SetMemberValue(name, value, this);
		}
	}
	internal sealed class StaticInitializer : AST
	{
		private FunctionObject func;

		private Completion completion;

		internal StaticInitializer(Context context, Block body, FunctionScope own_scope)
			: base(context)
		{
			func = new FunctionObject(null, new ParameterDeclaration[0], null, body, own_scope, base.Globals.ScopeStack.Peek(), context, MethodAttributes.Private | MethodAttributes.Static);
			func.isMethod = true;
			func.hasArgumentsObject = false;
			completion = new Completion();
		}

		internal override object Evaluate()
		{
			func.Call(new object[0], ((IActivationObject)base.Globals.ScopeStack.Peek()).GetGlobalScope());
			return completion;
		}

		internal override AST PartiallyEvaluate()
		{
			func.PartiallyEvaluate();
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			func.TranslateBodyToIL(il, base.compilerGlobals);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			throw new JScriptException(JSError.InternalError, context);
		}
	}
	/// <summary>Performs comparison operations. This class belongs to the abstract syntax tree category.</summary>
	public class StrictEquality : BinaryOp
	{
		internal StrictEquality(Context context, AST operand1, AST operand2, JSToken operatorTok)
			: base(context, operand1, operand2, operatorTok)
		{
		}

		internal override object Evaluate()
		{
			bool flag = JScriptStrictEquals(operand1.Evaluate(), operand2.Evaluate(), VsaEngine.executeForJSEE);
			if (operatorTok == JSToken.StrictEqual)
			{
				return flag;
			}
			return !flag;
		}

		/// <summary>Performs a comparison operation.</summary>
		/// <param name="v1">The first operand.</param>
		/// <param name="v2">The second operand.</param>
		/// <returns>The result of the operation.</returns>
		public static bool JScriptStrictEquals(object v1, object v2)
		{
			return JScriptStrictEquals(v1, v2, checkForDebuggerObjects: false);
		}

		internal static bool JScriptStrictEquals(object v1, object v2, bool checkForDebuggerObjects)
		{
			IConvertible iConvertible = Convert.GetIConvertible(v1);
			IConvertible iConvertible2 = Convert.GetIConvertible(v2);
			TypeCode typeCode = Convert.GetTypeCode(v1, iConvertible);
			TypeCode typeCode2 = Convert.GetTypeCode(v2, iConvertible2);
			return JScriptStrictEquals(v1, v2, iConvertible, iConvertible2, typeCode, typeCode2, checkForDebuggerObjects);
		}

		internal static bool JScriptStrictEquals(object v1, object v2, IConvertible ic1, IConvertible ic2, TypeCode t1, TypeCode t2, bool checkForDebuggerObjects)
		{
			switch (t1)
			{
			case TypeCode.Empty:
				return t2 == TypeCode.Empty;
			case TypeCode.Object:
				if (v1 == v2)
				{
					return true;
				}
				if (v1 is Missing || v1 is System.Reflection.Missing)
				{
					v1 = null;
				}
				if (v1 == v2)
				{
					return true;
				}
				if (v2 is Missing || v2 is System.Reflection.Missing)
				{
					v2 = null;
				}
				if (checkForDebuggerObjects && v1 is IDebuggerObject debuggerObject && v2 is IDebuggerObject o)
				{
					return debuggerObject.IsEqual(o);
				}
				return v1 == v2;
			case TypeCode.DBNull:
				return t2 == TypeCode.DBNull;
			case TypeCode.Boolean:
				if (t2 == TypeCode.Boolean)
				{
					return ic1.ToBoolean(null) == ic2.ToBoolean(null);
				}
				return false;
			case TypeCode.Char:
			{
				char c = ic1.ToChar(null);
				switch (t2)
				{
				case TypeCode.Char:
					return c == ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return c == ic2.ToInt64(null);
				case TypeCode.UInt64:
					return c == ic2.ToUInt64(null);
				case TypeCode.Single:
				case TypeCode.Double:
					return (double)(int)c == ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (decimal)(int)c == ic2.ToDecimal(null);
				case TypeCode.String:
				{
					string text2 = ic2.ToString(null);
					if (text2.Length == 1)
					{
						return c == text2[0];
					}
					return false;
				}
				default:
					return false;
				}
			}
			case TypeCode.SByte:
			{
				sbyte b2 = ic1.ToSByte(null);
				switch (t2)
				{
				case TypeCode.Char:
					return b2 == ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return b2 == ic2.ToInt64(null);
				case TypeCode.UInt64:
					if (b2 >= 0)
					{
						return (ulong)b2 == ic2.ToUInt64(null);
					}
					return false;
				case TypeCode.Single:
					return (float)b2 == ic2.ToSingle(null);
				case TypeCode.Double:
					return (double)b2 == ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (decimal)b2 == ic2.ToDecimal(null);
				default:
					return false;
				}
			}
			case TypeCode.Byte:
			{
				byte b = ic1.ToByte(null);
				switch (t2)
				{
				case TypeCode.Char:
					return b == ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return b == ic2.ToInt64(null);
				case TypeCode.UInt64:
					return b == ic2.ToUInt64(null);
				case TypeCode.Single:
					return (float)(int)b == ic2.ToSingle(null);
				case TypeCode.Double:
					return (double)(int)b == ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (decimal)b == ic2.ToDecimal(null);
				default:
					return false;
				}
			}
			case TypeCode.Int16:
			{
				short num9 = ic1.ToInt16(null);
				switch (t2)
				{
				case TypeCode.Char:
					return num9 == ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return num9 == ic2.ToInt64(null);
				case TypeCode.UInt64:
					if (num9 >= 0)
					{
						return (ulong)num9 == ic2.ToUInt64(null);
					}
					return false;
				case TypeCode.Single:
					return (float)num9 == ic2.ToSingle(null);
				case TypeCode.Double:
					return (double)num9 == ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (decimal)num9 == ic2.ToDecimal(null);
				default:
					return false;
				}
			}
			case TypeCode.UInt16:
			{
				ushort num8 = ic1.ToUInt16(null);
				switch (t2)
				{
				case TypeCode.Char:
					return num8 == ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return num8 == ic2.ToInt64(null);
				case TypeCode.UInt64:
					return num8 == ic2.ToUInt64(null);
				case TypeCode.Single:
					return (float)(int)num8 == ic2.ToSingle(null);
				case TypeCode.Double:
					return (double)(int)num8 == ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (decimal)num8 == ic2.ToDecimal(null);
				default:
					return false;
				}
			}
			case TypeCode.Int32:
			{
				int num7 = ic1.ToInt32(null);
				switch (t2)
				{
				case TypeCode.Char:
					return num7 == ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return num7 == ic2.ToInt64(null);
				case TypeCode.UInt64:
					if (num7 >= 0)
					{
						return (ulong)num7 == ic2.ToUInt64(null);
					}
					return false;
				case TypeCode.Single:
					return (float)num7 == ic2.ToSingle(null);
				case TypeCode.Double:
					return (double)num7 == ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (decimal)num7 == ic2.ToDecimal(null);
				default:
					return false;
				}
			}
			case TypeCode.UInt32:
			{
				uint num6 = ic1.ToUInt32(null);
				switch (t2)
				{
				case TypeCode.Char:
					return num6 == ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return num6 == ic2.ToInt64(null);
				case TypeCode.UInt64:
					return num6 == ic2.ToUInt64(null);
				case TypeCode.Single:
					return (float)num6 == ic2.ToSingle(null);
				case TypeCode.Double:
					return (double)num6 == ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (decimal)num6 == ic2.ToDecimal(null);
				default:
					return false;
				}
			}
			case TypeCode.Int64:
			{
				long num5 = ic1.ToInt64(null);
				switch (t2)
				{
				case TypeCode.Char:
					return num5 == ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return num5 == ic2.ToInt64(null);
				case TypeCode.UInt64:
					if (num5 >= 0)
					{
						return num5 == (long)ic2.ToUInt64(null);
					}
					return false;
				case TypeCode.Single:
					return (float)num5 == ic2.ToSingle(null);
				case TypeCode.Double:
					return (double)num5 == ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (decimal)num5 == ic2.ToDecimal(null);
				default:
					return false;
				}
			}
			case TypeCode.UInt64:
			{
				ulong num4 = ic1.ToUInt64(null);
				switch (t2)
				{
				case TypeCode.Char:
					return num4 == ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				{
					long num5 = ic2.ToInt64(null);
					if (num5 >= 0)
					{
						return num4 == (ulong)num5;
					}
					return false;
				}
				case TypeCode.UInt64:
					return num4 == ic2.ToUInt64(null);
				case TypeCode.Single:
					return (float)num4 == ic2.ToSingle(null);
				case TypeCode.Double:
					return (double)num4 == ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (decimal)num4 == ic2.ToDecimal(null);
				default:
					return false;
				}
			}
			case TypeCode.Single:
			{
				float num3 = ic1.ToSingle(null);
				switch (t2)
				{
				case TypeCode.Char:
					return num3 == (float)(int)ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return num3 == (float)ic2.ToInt64(null);
				case TypeCode.UInt64:
					return num3 == (float)ic2.ToUInt64(null);
				case TypeCode.Single:
					return num3 == ic2.ToSingle(null);
				case TypeCode.Double:
					return num3 == ic2.ToSingle(null);
				case TypeCode.Decimal:
					return (decimal)num3 == ic2.ToDecimal(null);
				default:
					return false;
				}
			}
			case TypeCode.Double:
			{
				double num2 = ic1.ToDouble(null);
				switch (t2)
				{
				case TypeCode.Char:
					return num2 == (double)(int)ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return num2 == (double)ic2.ToInt64(null);
				case TypeCode.UInt64:
					return num2 == (double)ic2.ToUInt64(null);
				case TypeCode.Single:
					return (float)num2 == ic2.ToSingle(null);
				case TypeCode.Double:
					return num2 == ic2.ToDouble(null);
				case TypeCode.Decimal:
					return (decimal)num2 == ic2.ToDecimal(null);
				default:
					return false;
				}
			}
			case TypeCode.Decimal:
			{
				decimal num = ic1.ToDecimal(null);
				switch (t2)
				{
				case TypeCode.Char:
					return num == (decimal)(int)ic2.ToChar(null);
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
					return num == (decimal)ic2.ToInt64(null);
				case TypeCode.UInt64:
					return num == (decimal)ic2.ToUInt64(null);
				case TypeCode.Single:
					return num == (decimal)ic2.ToSingle(null);
				case TypeCode.Double:
					return num == (decimal)ic2.ToDouble(null);
				case TypeCode.Decimal:
					return num == ic2.ToDecimal(null);
				default:
					return false;
				}
			}
			case TypeCode.DateTime:
				if (t2 == TypeCode.DateTime)
				{
					return ic1.ToDateTime(null) == ic2.ToDateTime(null);
				}
				return false;
			case TypeCode.String:
				switch (t2)
				{
				case TypeCode.Char:
				{
					string text = ic1.ToString(null);
					if (text.Length == 1)
					{
						return text[0] == ic2.ToChar(null);
					}
					return false;
				}
				case TypeCode.String:
					if (v1 != v2)
					{
						return ic1.ToString(null).Equals(ic2.ToString(null));
					}
					return true;
				default:
					return false;
				}
			default:
				return false;
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return Typeob.Boolean;
		}

		internal override void TranslateToConditionalBranch(ILGenerator il, bool branchIfTrue, Label label, bool shortForm)
		{
			Type type = Convert.ToType(operand1.InferType(null));
			Type type2 = Convert.ToType(operand2.InferType(null));
			if (operand1 is ConstantWrapper && operand1.Evaluate() == null)
			{
				type = Typeob.Empty;
			}
			if (operand2 is ConstantWrapper && operand2.Evaluate() == null)
			{
				type2 = Typeob.Empty;
			}
			if (type != type2 && type.IsPrimitive && type2.IsPrimitive)
			{
				if (type == Typeob.Single)
				{
					type2 = type;
				}
				else if (type2 == Typeob.Single)
				{
					type = type2;
				}
				else if (Convert.IsPromotableTo(type2, type))
				{
					type2 = type;
				}
				else if (Convert.IsPromotableTo(type, type2))
				{
					type = type2;
				}
			}
			bool flag = true;
			if (type == type2 && type != Typeob.Object)
			{
				Type rtype = type;
				if (!type.IsPrimitive)
				{
					rtype = Typeob.Object;
				}
				operand1.TranslateToIL(il, rtype);
				operand2.TranslateToIL(il, rtype);
				if (type == Typeob.String)
				{
					il.Emit(OpCodes.Call, CompilerGlobals.stringEqualsMethod);
				}
				else if (!type.IsPrimitive)
				{
					il.Emit(OpCodes.Callvirt, CompilerGlobals.equalsMethod);
				}
				else
				{
					flag = false;
				}
			}
			else if (type == Typeob.Empty)
			{
				operand2.TranslateToIL(il, Typeob.Object);
				branchIfTrue = !branchIfTrue;
			}
			else if (type2 == Typeob.Empty)
			{
				operand1.TranslateToIL(il, Typeob.Object);
				branchIfTrue = !branchIfTrue;
			}
			else
			{
				operand1.TranslateToIL(il, Typeob.Object);
				operand2.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.jScriptStrictEqualsMethod);
			}
			if (branchIfTrue)
			{
				if (operatorTok == JSToken.StrictEqual)
				{
					if (flag)
					{
						il.Emit(shortForm ? OpCodes.Brtrue_S : OpCodes.Brtrue, label);
					}
					else
					{
						il.Emit(shortForm ? OpCodes.Beq_S : OpCodes.Beq, label);
					}
				}
				else if (flag)
				{
					il.Emit(shortForm ? OpCodes.Brfalse_S : OpCodes.Brfalse, label);
				}
				else
				{
					il.Emit(shortForm ? OpCodes.Bne_Un_S : OpCodes.Bne_Un, label);
				}
			}
			else if (operatorTok == JSToken.StrictEqual)
			{
				if (flag)
				{
					il.Emit(shortForm ? OpCodes.Brfalse_S : OpCodes.Brfalse, label);
				}
				else
				{
					il.Emit(shortForm ? OpCodes.Bne_Un_S : OpCodes.Bne_Un, label);
				}
			}
			else if (flag)
			{
				il.Emit(shortForm ? OpCodes.Brtrue_S : OpCodes.Brtrue, label);
			}
			else
			{
				il.Emit(shortForm ? OpCodes.Beq_S : OpCodes.Beq, label);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Label label = il.DefineLabel();
			Label label2 = il.DefineLabel();
			TranslateToConditionalBranch(il, branchIfTrue: true, label, shortForm: true);
			il.Emit(OpCodes.Ldc_I4_0);
			il.Emit(OpCodes.Br_S, label2);
			il.MarkLabel(label);
			il.Emit(OpCodes.Ldc_I4_1);
			il.MarkLabel(label2);
			Convert.Emit(this, il, Typeob.Boolean, rtype);
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public class StringConstructor : ScriptFunction
	{
		internal static readonly StringConstructor ob = new StringConstructor();

		private StringPrototype originalPrototype;

		internal StringConstructor()
			: base(FunctionPrototype.ob, "String", 1)
		{
			originalPrototype = StringPrototype.ob;
			StringPrototype._constructor = this;
			proto = StringPrototype.ob;
		}

		internal StringConstructor(FunctionPrototype parent, LenientStringPrototype prototypeProp)
			: base(parent, "String", 1)
		{
			originalPrototype = prototypeProp;
			prototypeProp.constructor = this;
			proto = prototypeProp;
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			if (args.Length == 0)
			{
				return "";
			}
			return Convert.ToString(args[0]);
		}

		internal StringObject Construct()
		{
			return new StringObject(originalPrototype, "", implicitWrapper: false);
		}

		internal override object Construct(object[] args)
		{
			return CreateInstance(args);
		}

		internal StringObject ConstructImplicitWrapper(string arg)
		{
			return new StringObject(originalPrototype, arg, implicitWrapper: true);
		}

		internal StringObject ConstructWrapper(string arg)
		{
			return new StringObject(originalPrototype, arg, implicitWrapper: false);
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>An instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new StringObject CreateInstance(params object[] args)
		{
			return new StringObject(originalPrototype, (args.Length == 0) ? "" : Convert.ToString(args[0]), implicitWrapper: false);
		}

		/// <summary>Converts the specified object to a string.</summary>
		/// <param name="arg">The object to convert to a string.</param>
		/// <returns>A string representation of <paramref name="arg" />.</returns>
		public string Invoke(object arg)
		{
			return Convert.ToString(arg);
		}

		/// <summary>Converts each element of the specified array to a character and concatenates them.</summary>
		/// <param name="args">The elements to convert to a string.</param>
		/// <returns>A string representation of <paramref name="arg" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs, JSBuiltin.String_fromCharCode)]
		public static string fromCharCode(params object[] args)
		{
			StringBuilder stringBuilder = new StringBuilder(args.Length);
			for (int i = 0; i < args.Length; i++)
			{
				stringBuilder.Append(Convert.ToChar(args[i]));
			}
			return stringBuilder.ToString();
		}
	}
	/// <summary>Represents a string object. This class belongs to the built-in object model category.</summary>
	public class StringObject : JSObject
	{
		internal string value;

		private bool implicitWrapper;

		/// <summary>Gets the number of characters in the string.</summary>
		/// <returns>The number of characters in the string.</returns>
		public int length => value.Length;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.StringObject" /> class.</summary>
		/// <param name="prototype">The parent of the object.</param>
		/// <param name="value">The underlying value that the class represents.</param>
		protected StringObject(ScriptObject prototype, string value)
			: base(prototype)
		{
			this.value = value;
			noExpando = false;
			implicitWrapper = false;
		}

		internal StringObject(ScriptObject prototype, string value, bool implicitWrapper)
			: base(prototype, typeof(StringObject))
		{
			this.value = value;
			noExpando = implicitWrapper;
			this.implicitWrapper = implicitWrapper;
		}

		internal override string GetClassName()
		{
			return "String";
		}

		/// <summary>Determines whether this string and the specified string have the same value.</summary>
		/// <param name="ob">The string to compare.</param>
		/// <returns>
		///   <see langword="true" /> if this string and <paramref name="ob" /> have the same value; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object ob)
		{
			if (ob is StringObject)
			{
				ob = ((StringObject)ob).value;
			}
			return value.Equals(ob);
		}

		internal override object GetDefaultValue(PreferredType preferred_type)
		{
			if (GetParent() is LenientStringPrototype)
			{
				return base.GetDefaultValue(preferred_type);
			}
			switch (preferred_type)
			{
			case PreferredType.String:
				if (!noExpando)
				{
					object obj2 = base.NameTable["toString"];
					if (obj2 != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return value;
			case PreferredType.LocaleString:
				return base.GetDefaultValue(preferred_type);
			default:
				if (!noExpando)
				{
					object obj = base.NameTable["valueOf"];
					if (obj == null && preferred_type == PreferredType.Either)
					{
						obj = base.NameTable["toString"];
					}
					if (obj != null)
					{
						return base.GetDefaultValue(preferred_type);
					}
				}
				return value;
			}
		}

		/// <summary>Returns the hash code for this string.</summary>
		/// <returns>A hash code for this string.</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}

		/// <summary>Returns <see cref="T:System.String" /> or <see cref="T:Microsoft.JScript.StringObject" />.</summary>
		/// <returns>
		///   <see cref="T:System.String" /> or <see cref="T:Microsoft.JScript.StringObject" />.</returns>
		public new Type GetType()
		{
			if (!implicitWrapper)
			{
				return Typeob.StringObject;
			}
			return Typeob.String;
		}

		internal override object GetValueAtIndex(uint index)
		{
			if (implicitWrapper && index < value.Length)
			{
				return value[(int)index];
			}
			return base.GetValueAtIndex(index);
		}
	}
	/// <summary>Provides static methods and properties for <see cref="T:Microsoft.JScript.StringObject" /> objects. All methods of this class are called by passing in a reference to the object that is requesting access to the method. This class belongs to the built-in object model category.</summary>
	public class StringPrototype : StringObject
	{
		internal static readonly StringPrototype ob = new StringPrototype(FunctionPrototype.ob, ObjectPrototype.ob);

		internal static StringConstructor _constructor;

		/// <summary>Gets a reference to a prototype-based object that is using this prototype.</summary>
		/// <returns>A reference to a prototype-based object.</returns>
		public static StringConstructor constructor => _constructor;

		internal StringPrototype(FunctionPrototype funcprot, ObjectPrototype parent)
			: base(parent, "")
		{
			noExpando = true;
		}

		/// <summary>Converts the specified object to text enclosed in anchor tags, and gives the anchor element the specified name attribute.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="anchorName">The name attribute of the anchor element.</param>
		/// <returns>A string in the form <c>"&lt;A NAME=""+</c><paramref name="anchorName" /><c>+""&gt;"+</c><paramref name="thisob" /><c>+"&lt;/A&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_anchor)]
		public static string anchor(object thisob, object anchorName)
		{
			string text = Convert.ToString(thisob);
			string text2 = Convert.ToString(anchorName);
			return "<A NAME=\"" + text2 + "\">" + text + "</A>";
		}

		/// <summary>Converts the specified object to text enclosed in bigger text markup tags.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string in the form <c>"&lt;BIG&gt;"+</c><paramref name="thisob" /><c>+"&lt;/BIG&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_big)]
		public static string big(object thisob)
		{
			return "<BIG>" + Convert.ToString(thisob) + "</BIG>";
		}

		/// <summary>Converts the specified object to text enclosed in blink markup tags.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string in the form <c>"&lt;BLINK&gt;"+</c><paramref name="thisob" /><c>+"&lt;/BLINK&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_blink)]
		public static string blink(object thisob)
		{
			return "<BLINK>" + Convert.ToString(thisob) + "</BLINK>";
		}

		/// <summary>Converts the specified object to text enclosed in bold text markup tags.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string in the form <c>"&lt;B&gt;"+</c><paramref name="thisob" /><c>+"&lt;/B&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_bold)]
		public static string bold(object thisob)
		{
			return "<B>" + Convert.ToString(thisob) + "</B>";
		}

		/// <summary>Returns the character at the specified position in the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="pos">The position of the character to return.</param>
		/// <returns>The character at <paramref name="pos" />, if there is one.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_charAt)]
		public static string charAt(object thisob, double pos)
		{
			string text = Convert.ToString(thisob);
			double num = Convert.ToInteger(pos);
			if (num < 0.0 || !(num < (double)text.Length))
			{
				return "";
			}
			return text.Substring((int)num, 1);
		}

		/// <summary>Returns the ASCII code of the character at the specified position in the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="pos">The position of the character whose code you want to return.</param>
		/// <returns>The code of the character at <paramref name="pos" />, if there is one.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_charCodeAt)]
		public static object charCodeAt(object thisob, double pos)
		{
			string text = Convert.ToString(thisob);
			double num = Convert.ToInteger(pos);
			if (num < 0.0 || !(num < (double)text.Length))
			{
				return double.NaN;
			}
			return (int)text[(int)num];
		}

		/// <summary>Appends the specified arguments to the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="args">The arguments to append to <paramref name="thisob" />.</param>
		/// <returns>A string representation of <paramref name="thisob" />, with <paramref name="args" /> appended.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasVarArgs, JSBuiltin.String_concat)]
		public static string concat(object thisob, params object[] args)
		{
			StringBuilder stringBuilder = new StringBuilder(Convert.ToString(thisob));
			for (int i = 0; i < args.Length; i++)
			{
				stringBuilder.Append(Convert.ToString(args[i]));
			}
			return stringBuilder.ToString();
		}

		/// <summary>Converts the specified object to text enclosed in fixed-width text markup tags.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string in the form <c>"&lt;TT&gt;"+</c><paramref name="thisob" /><c>+"&lt;/TT&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_fixed)]
		public static string @fixed(object thisob)
		{
			return "<TT>" + Convert.ToString(thisob) + "</TT>";
		}

		/// <summary>Converts the specified object to text enclosed in font tags, and gives the element the specified color attribute.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="colorName">The color attribute of the font element.</param>
		/// <returns>A string in the form <c>"&lt;FONT COLOR=""+</c><paramref name="colorName" /><c>+""&gt;"+</c><paramref name="thisob" /><c>+"&lt;/FONT&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_fontcolor)]
		public static string fontcolor(object thisob, object colorName)
		{
			string text = Convert.ToString(thisob);
			string text2 = Convert.ToString(thisob);
			return "<FONT COLOR=\"" + text2 + "\">" + text + "</FONT>";
		}

		/// <summary>Converts the specified object to text enclosed in font tags, and gives the element the specified size attribute.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="fontSize">The size attribute of the font element.</param>
		/// <returns>A string in the form <c>"&lt;FONT SIZE=""+</c><paramref name="fontSize" /><c>+""&gt;"+</c><paramref name="thisob" /><c>+"&lt;/FONT&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_fontsize)]
		public static string fontsize(object thisob, object fontSize)
		{
			string text = Convert.ToString(thisob);
			string text2 = Convert.ToString(fontSize);
			return "<FONT SIZE=\"" + text2 + "\">" + text + "</FONT>";
		}

		/// <summary>Searches for the first occurrence of the specified string in the specified object, starting from the specified character position.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="searchString">The string to search for.</param>
		/// <param name="position">The position at which to start the search.</param>
		/// <returns>The position of the first occurrence of <paramref name="searchString" />, if it is found.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_indexOf)]
		public static int indexOf(object thisob, object searchString, double position)
		{
			string text = Convert.ToString(thisob);
			string text2 = Convert.ToString(searchString);
			double num = Convert.ToInteger(position);
			int num2 = text.Length;
			if (num < 0.0)
			{
				num = 0.0;
			}
			if (num >= (double)num2)
			{
				if (text2.Length != 0)
				{
					return -1;
				}
				return 0;
			}
			return text.IndexOf(text2, (int)num);
		}

		/// <summary>Converts the specified object to text enclosed in italic text markup tags.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string in the form <c>"&lt;I&gt;"+</c><paramref name="thisob" /><c>+"&lt;/I&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_italics)]
		public static string italics(object thisob)
		{
			return "<I>" + Convert.ToString(thisob) + "</I>";
		}

		/// <summary>Searches for the last occurrence of the specified string in the specified object, starting from the specified character position.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="searchString">The string to search for.</param>
		/// <param name="position">The position at which to start the search.</param>
		/// <returns>The position of the last occurrence of <paramref name="searchString" />, if it is found.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_lastIndexOf)]
		public static int lastIndexOf(object thisob, object searchString, double position)
		{
			string text = Convert.ToString(thisob);
			string text2 = Convert.ToString(searchString);
			int num = text.Length;
			int num2 = ((position != position || position > (double)num) ? num : ((int)position));
			if (num2 < 0)
			{
				num2 = 0;
			}
			if (num2 >= num)
			{
				num2 = num;
			}
			int num3 = text2.Length;
			if (num3 == 0)
			{
				return num2;
			}
			int num4 = num2 - 1 + num3;
			if (num4 >= num)
			{
				num4 = num - 1;
			}
			if (num4 < 0)
			{
				return -1;
			}
			return text.LastIndexOf(text2, num4);
		}

		/// <summary>Converts the specified object to text enclosed in anchor tags, and gives the anchor element the link target attribute that is specified.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="linkRef">The target attribute of the anchor element.</param>
		/// <returns>A string in the form <c>"&lt;A HREF=""+</c><paramref name="linkRef" /><c>+""&gt;"+</c><paramref name="thisob" /><c>+"&lt;/A&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_link)]
		public static string link(object thisob, object linkRef)
		{
			string text = Convert.ToString(thisob);
			string text2 = Convert.ToString(linkRef);
			return "<A HREF=\"" + text2 + "\">" + text + "</A>";
		}

		/// <summary>Compares the two specified strings and returns an integer that indicates the lexical relationship between them.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="thatob">The string to compare to <paramref name="thisob" />.</param>
		/// <returns>A negative value when <paramref name="thisob" /> is less than <paramref name="thatob" />; zero when <paramref name="thisob" /> equals <paramref name="thatob" />; a positive value when <paramref name="thisob" /> is greater than <paramref name="thatob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_localeCompare)]
		public static int localeCompare(object thisob, object thatob)
		{
			return string.Compare(Convert.ToString(thisob), Convert.ToString(thatob), StringComparison.CurrentCulture);
		}

		/// <summary>Runs a search for the specified regular expression pattern on the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <param name="regExp">The regular expression pattern to search for.</param>
		/// <returns>The result of the search for the regular expression pattern.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasEngine, JSBuiltin.String_match)]
		public static object match(object thisob, VsaEngine engine, object regExp)
		{
			string input = Convert.ToString(thisob);
			RegExpObject regExpObject = ToRegExpObject(regExp, engine);
			Match match;
			if (!regExpObject.globalInt)
			{
				match = regExpObject.regex.Match(input);
				if (!match.Success)
				{
					regExpObject.lastIndexInt = 0;
					return DBNull.Value;
				}
				if (regExpObject.regExpConst != null)
				{
					regExpObject.lastIndexInt = regExpObject.regExpConst.UpdateConstructor(regExpObject.regex, match, input);
					return new RegExpMatch(regExpObject.regExpConst.arrayPrototype, regExpObject.regex, match, input);
				}
				return new RegExpMatch(engine.Globals.globalObject.originalRegExp.arrayPrototype, regExpObject.regex, match, input);
			}
			MatchCollection matchCollection = regExpObject.regex.Matches(input);
			if (matchCollection.Count == 0)
			{
				regExpObject.lastIndexInt = 0;
				return DBNull.Value;
			}
			match = matchCollection[matchCollection.Count - 1];
			regExpObject.lastIndexInt = regExpObject.regExpConst.UpdateConstructor(regExpObject.regex, match, input);
			return new RegExpMatch(regExpObject.regExpConst.arrayPrototype, regExpObject.regex, matchCollection, input);
		}

		/// <summary>Runs a search for the specified regular expression pattern on the first specified object, and replaces any matches with the third specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="regExp">The regular expression pattern to search for.</param>
		/// <param name="replacement">The replacement for any matches.</param>
		/// <returns>The new string, after the replacement is made.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_replace)]
		public static string replace(object thisob, object regExp, object replacement)
		{
			string thisob2 = Convert.ToString(thisob);
			if (regExp is RegExpObject regExpObject)
			{
				return ReplaceWithRegExp(thisob2, regExpObject, replacement);
			}
			if (regExp is Regex regex)
			{
				return ReplaceWithRegExp(thisob2, new RegExpObject(regex), replacement);
			}
			return ReplaceWithString(thisob2, Convert.ToString(regExp), Convert.ToString(replacement));
		}

		private static string ReplaceWithRegExp(string thisob, RegExpObject regExpObject, object replacement)
		{
			RegExpReplace regExpReplace = ((replacement is ScriptFunction) ? ((RegExpReplace)new ReplaceUsingFunction(regExpObject.regex, (ScriptFunction)replacement, thisob)) : ((RegExpReplace)new ReplaceWithString(Convert.ToString(replacement))));
			MatchEvaluator evaluator = regExpReplace.Evaluate;
			string result = (regExpObject.globalInt ? regExpObject.regex.Replace(thisob, evaluator) : regExpObject.regex.Replace(thisob, evaluator, 1));
			regExpObject.lastIndexInt = ((regExpReplace.lastMatch != null) ? regExpObject.regExpConst.UpdateConstructor(regExpObject.regex, regExpReplace.lastMatch, thisob) : 0);
			return result;
		}

		private static string ReplaceWithString(string thisob, string searchString, string replaceString)
		{
			int num = thisob.IndexOf(searchString);
			if (num < 0)
			{
				return thisob;
			}
			StringBuilder stringBuilder = new StringBuilder(thisob.Substring(0, num));
			stringBuilder.Append(replaceString);
			stringBuilder.Append(thisob.Substring(num + searchString.Length));
			return stringBuilder.ToString();
		}

		/// <summary>Runs a search for the specified regular expression pattern on the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <param name="regExp">The regular expression pattern to search for.</param>
		/// <returns>If the search is successful, the index of the match; otherwise, -1.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasEngine, JSBuiltin.String_search)]
		public static int search(object thisob, VsaEngine engine, object regExp)
		{
			string input = Convert.ToString(thisob);
			RegExpObject regExpObject = ToRegExpObject(regExp, engine);
			Match match = regExpObject.regex.Match(input);
			if (!match.Success)
			{
				regExpObject.lastIndexInt = 0;
				return -1;
			}
			regExpObject.lastIndexInt = regExpObject.regExpConst.UpdateConstructor(regExpObject.regex, match, input);
			return match.Index;
		}

		/// <summary>Creates a new string that contains the specified consecutive characters from the specified string.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="start">The first consecutive character to get.</param>
		/// <param name="end">The last consecutive character to get.</param>
		/// <returns>A new string that contains the consecutive characters between <paramref name="start" /> and <paramref name="end" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_slice)]
		public static string slice(object thisob, double start, object end)
		{
			string text = Convert.ToString(thisob);
			int num = text.Length;
			double num2 = Convert.ToInteger(start);
			double num3 = ((end == null || end is Missing) ? ((double)num) : Convert.ToInteger(end));
			if (num2 < 0.0)
			{
				num2 = (double)num + num2;
				if (num2 < 0.0)
				{
					num2 = 0.0;
				}
			}
			else if (num2 > (double)num)
			{
				num2 = num;
			}
			if (num3 < 0.0)
			{
				num3 = (double)num + num3;
				if (num3 < 0.0)
				{
					num3 = 0.0;
				}
			}
			else if (num3 > (double)num)
			{
				num3 = num;
			}
			int num4 = (int)(num3 - num2);
			if (num4 <= 0)
			{
				return "";
			}
			return text.Substring((int)num2, num4);
		}

		/// <summary>Converts the specified object to text enclosed in smaller text markup tags.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string in the form <c>"&lt;SMALL&gt;"+</c><paramref name="thisob" /><c>+"&lt;/SMALL&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_small)]
		public static string small(object thisob)
		{
			return "<SMALL>" + Convert.ToString(thisob) + "</SMALL>";
		}

		/// <summary>Returns an array that contains the substrings in the specified object that are delimited by the specified characters. The number of substrings in the array is constrained by the specified limit.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <param name="separator">The characters that delimit the substrings in <paramref name="thisob" />.</param>
		/// <param name="limit">The maximum number of substrings to return.</param>
		/// <returns>An array that contains the substrings in <paramref name="thisob" /> that are delimited by <paramref name="separator" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasEngine, JSBuiltin.String_split)]
		public static ArrayObject split(object thisob, VsaEngine engine, object separator, object limit)
		{
			string thisob2 = Convert.ToString(thisob);
			uint num = uint.MaxValue;
			if (limit != null && !(limit is Missing) && limit != DBNull.Value)
			{
				double num2 = Convert.ToInteger(limit);
				if (num2 >= 0.0 && num2 < 4294967295.0)
				{
					num = (uint)num2;
				}
			}
			if (num == 0)
			{
				return engine.GetOriginalArrayConstructor().Construct();
			}
			if (separator == null || separator is Missing)
			{
				ArrayObject arrayObject = engine.GetOriginalArrayConstructor().Construct();
				arrayObject.SetValueAtIndex(0u, thisob);
				return arrayObject;
			}
			if (separator is RegExpObject regExpObject)
			{
				return SplitWithRegExp(thisob2, engine, regExpObject, num);
			}
			if (separator is Regex regex)
			{
				return SplitWithRegExp(thisob2, engine, new RegExpObject(regex), num);
			}
			return SplitWithString(thisob2, engine, Convert.ToString(separator), num);
		}

		private static ArrayObject SplitWithRegExp(string thisob, VsaEngine engine, RegExpObject regExpObject, uint limit)
		{
			ArrayObject arrayObject = engine.GetOriginalArrayConstructor().Construct();
			Match match = regExpObject.regex.Match(thisob);
			if (!match.Success)
			{
				arrayObject.SetValueAtIndex(0u, thisob);
				regExpObject.lastIndexInt = 0;
				return arrayObject;
			}
			int num = 0;
			uint num2 = 0u;
			Match match2;
			do
			{
				int num3 = match.Index - num;
				if (num3 > 0)
				{
					arrayObject.SetValueAtIndex(num2++, thisob.Substring(num, num3));
					if (limit != 0 && num2 >= limit)
					{
						regExpObject.lastIndexInt = regExpObject.regExpConst.UpdateConstructor(regExpObject.regex, match, thisob);
						return arrayObject;
					}
				}
				num = match.Index + match.Length;
				match2 = match;
				match = match.NextMatch();
			}
			while (match.Success);
			if (num < thisob.Length)
			{
				arrayObject.SetValueAtIndex(num2, thisob.Substring(num));
			}
			regExpObject.lastIndexInt = regExpObject.regExpConst.UpdateConstructor(regExpObject.regex, match2, thisob);
			return arrayObject;
		}

		private static ArrayObject SplitWithString(string thisob, VsaEngine engine, string separator, uint limit)
		{
			ArrayObject arrayObject = engine.GetOriginalArrayConstructor().Construct();
			if (separator.Length == 0)
			{
				if (limit > thisob.Length)
				{
					limit = (uint)thisob.Length;
				}
				for (int i = 0; i < limit; i++)
				{
					arrayObject.SetValueAtIndex((uint)i, thisob[i].ToString());
				}
			}
			else
			{
				int num = 0;
				uint num2 = 0u;
				int num3;
				while ((num3 = thisob.IndexOf(separator, num)) >= 0)
				{
					arrayObject.SetValueAtIndex(num2++, thisob.Substring(num, num3 - num));
					if (num2 >= limit)
					{
						return arrayObject;
					}
					num = num3 + separator.Length;
				}
				if (num2 == 0)
				{
					arrayObject.SetValueAtIndex(0u, thisob);
				}
				else
				{
					arrayObject.SetValueAtIndex(num2, thisob.Substring(num));
				}
			}
			return arrayObject;
		}

		/// <summary>Converts the specified object to text enclosed in strikethrough markup tags.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string in the form <c>"&lt;STRIKE&gt;"+</c><paramref name="thisob" /><c>+"&lt;/STRIKE&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_strike)]
		public static string strike(object thisob)
		{
			return "<STRIKE>" + Convert.ToString(thisob) + "</STRIKE>";
		}

		/// <summary>Converts the specified object to text enclosed in subscript markup tags.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string in the form <c>"&lt;SUB&gt;"+</c><paramref name="thisob" /><c>+"&lt;/SUB&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_sub)]
		public static string sub(object thisob)
		{
			return "<SUB>" + Convert.ToString(thisob) + "</SUB>";
		}

		/// <summary>Creates a new string that contains the specified number of consecutive characters from the specified string, starting from the specified character position. Use <see cref="M:Microsoft.JScript.StringPrototype.substring(System.Object,System.Double,System.Object)" /> instead, if you can.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="start">The first consecutive character to get.</param>
		/// <param name="count">The number of characters to get.</param>
		/// <returns>A new string that contains <paramref name="count" /> consecutive characters, starting at <paramref name="start" />.</returns>
		[NotRecommended("substr")]
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_substr)]
		public static string substr(object thisob, double start, object count)
		{
			string text = thisob as string;
			if (text == null)
			{
				text = Convert.ToString(thisob);
			}
			int num = text.Length;
			double num2 = Convert.ToInteger(start);
			if (num2 < 0.0)
			{
				num2 += (double)num;
			}
			if (num2 < 0.0)
			{
				num2 = 0.0;
			}
			else if (num2 > (double)num)
			{
				num2 = num;
			}
			int num3 = (int)((count is int) ? ((int)count) : ((count == null || count is Missing) ? (num - (int)Runtime.DoubleToInt64(num2)) : Runtime.DoubleToInt64(Convert.ToInteger(count))));
			if (num2 + (double)num3 > (double)num)
			{
				num3 = num - (int)num2;
			}
			if (num3 <= 0)
			{
				return "";
			}
			return text.Substring((int)num2, num3);
		}

		/// <summary>Creates a new string that contains the specified consecutive characters from the specified string.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="start">The first consecutive character to get.</param>
		/// <param name="end">The last consecutive character to get.</param>
		/// <returns>A new string that contains the consecutive characters between <paramref name="start" /> and <paramref name="end" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_substring)]
		public static string substring(object thisob, double start, object end)
		{
			string text = thisob as string;
			if (text == null)
			{
				text = Convert.ToString(thisob);
			}
			int num = text.Length;
			double num2 = Convert.ToInteger(start);
			if (num2 < 0.0)
			{
				num2 = 0.0;
			}
			else if (num2 > (double)num)
			{
				num2 = num;
			}
			double num3 = ((end == null || end is Missing) ? ((double)num) : Convert.ToInteger(end));
			if (num3 < 0.0)
			{
				num3 = 0.0;
			}
			else if (num3 > (double)num)
			{
				num3 = num;
			}
			if (num2 > num3)
			{
				double num4 = num2;
				num2 = num3;
				num3 = num4;
			}
			return text.Substring((int)num2, (int)(num3 - num2));
		}

		/// <summary>Converts the specified object to text enclosed in superscript markup tags.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string in the form <c>"&lt;SUP&gt;"+</c><paramref name="thisob" /><c>+"&lt;/SUP&gt;"</c>.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_sup)]
		public static string sup(object thisob)
		{
			return "<SUP>" + Convert.ToString(thisob) + "</SUP>";
		}

		/// <summary>Returns a copy of the specified string converted to lowercase, based on the casing rules of <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A lowercase string.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_toLocaleLowerCase)]
		public static string toLocaleLowerCase(object thisob)
		{
			return Convert.ToString(thisob).ToLower(CultureInfo.CurrentUICulture);
		}

		/// <summary>Returns a copy of the specified string converted to uppercase, based on the casing rules of <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>An uppercase string.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_toLocaleUpperCase)]
		public static string toLocaleUpperCase(object thisob)
		{
			return Convert.ToString(thisob).ToUpperInvariant();
		}

		/// <summary>Returns a copy of the specified string converted to lowercase, based on the casing rules of <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A lowercase string.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_toLowerCase)]
		public static string toLowerCase(object thisob)
		{
			return Convert.ToString(thisob).ToLowerInvariant();
		}

		private static RegExpObject ToRegExpObject(object regExp, VsaEngine engine)
		{
			if (regExp == null || regExp is Missing)
			{
				return (RegExpObject)engine.GetOriginalRegExpConstructor().Construct("", ignoreCase: false, global: false, multiline: false);
			}
			if (regExp is RegExpObject result)
			{
				return result;
			}
			if (regExp is Regex regex)
			{
				return new RegExpObject(regex);
			}
			return (RegExpObject)engine.GetOriginalRegExpConstructor().Construct(Convert.ToString(regExp), ignoreCase: false, global: false, multiline: false);
		}

		/// <summary>Creates a string representation of the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>A string representation of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_toString)]
		public static string toString(object thisob)
		{
			if (thisob is StringObject stringObject)
			{
				return stringObject.value;
			}
			if (thisob is ConcatString concatString)
			{
				return concatString.ToString();
			}
			IConvertible iConvertible = Convert.GetIConvertible(thisob);
			if (Convert.GetTypeCode(thisob, iConvertible) == TypeCode.String)
			{
				return iConvertible.ToString(null);
			}
			throw new JScriptException(JSError.StringExpected);
		}

		/// <summary>Returns a copy of the specified string converted to uppercase, based on the casing rules of <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>An uppercase string.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_toUpperCase)]
		public static string toUpperCase(object thisob)
		{
			return Convert.ToString(thisob).ToUpperInvariant();
		}

		/// <summary>Returns the value of the specified object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The value of <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.String_valueOf)]
		public static object valueOf(object thisob)
		{
			return toString(thisob);
		}
	}
	/// <summary>Stores members from base classes and interfaces.</summary>
	public sealed class SuperTypeMembersSorter
	{
		private SimpleHashtable members;

		private ArrayList names;

		private int count;

		internal SuperTypeMembersSorter()
		{
			members = new SimpleHashtable(64u);
			names = new ArrayList();
			count = 0;
		}

		internal void Add(MemberInfo[] members)
		{
			foreach (MemberInfo member in members)
			{
				Add(member);
			}
		}

		internal void Add(MemberInfo member)
		{
			count++;
			string name = member.Name;
			object obj = members[name];
			if (obj == null)
			{
				members[name] = member;
				names.Add(name);
			}
			else if (obj is MemberInfo)
			{
				ArrayList arrayList = new ArrayList(8);
				arrayList.Add(obj);
				arrayList.Add(member);
				members[name] = arrayList;
			}
			else
			{
				((ArrayList)obj).Add(member);
			}
		}

		internal object[] GetMembers()
		{
			object[] array = new object[count];
			int num = 0;
			foreach (object name in names)
			{
				object obj = members[name];
				if (obj is MemberInfo)
				{
					array[num++] = obj;
					continue;
				}
				foreach (object item in (ArrayList)obj)
				{
					array[num++] = item;
				}
			}
			return array;
		}
	}
	internal sealed class Switch : AST
	{
		private AST expression;

		private ASTList cases;

		private int default_case;

		private Completion completion;

		internal Switch(Context context, AST expression, ASTList cases)
			: base(context)
		{
			this.expression = expression;
			this.cases = cases;
			default_case = -1;
			int i = 0;
			for (int count = this.cases.count; i < count; i++)
			{
				if (((SwitchCase)this.cases[i]).IsDefault())
				{
					default_case = i;
					break;
				}
			}
			completion = new Completion();
		}

		internal override object Evaluate()
		{
			this.completion.Continue = 0;
			this.completion.Exit = 0;
			this.completion.value = null;
			object obj = expression.Evaluate();
			Completion completion = null;
			int count = cases.count;
			int i;
			for (i = 0; i < count; i++)
			{
				if (i != default_case)
				{
					completion = ((SwitchCase)cases[i]).Evaluate(obj);
					if (completion != null)
					{
						break;
					}
				}
			}
			if (completion == null)
			{
				if (default_case < 0)
				{
					return this.completion;
				}
				i = default_case;
				completion = (Completion)((SwitchCase)cases[i]).Evaluate();
			}
			while (true)
			{
				if (completion.value != null)
				{
					this.completion.value = completion.value;
				}
				if (completion.Continue > 0)
				{
					this.completion.Continue = completion.Continue - 1;
					break;
				}
				if (completion.Exit > 0)
				{
					this.completion.Exit = completion.Exit - 1;
					break;
				}
				if (completion.Return)
				{
					return completion;
				}
				if (i >= count - 1)
				{
					return this.completion;
				}
				completion = (Completion)((SwitchCase)cases[++i]).Evaluate();
			}
			return this.completion;
		}

		internal override AST PartiallyEvaluate()
		{
			expression = expression.PartiallyEvaluate();
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is FunctionScope)
			{
				FunctionScope functionScope = (FunctionScope)scriptObject;
				BitArray definedFlags = functionScope.DefinedFlags;
				int i = 0;
				for (int count = cases.count; i < count; i++)
				{
					cases[i] = cases[i].PartiallyEvaluate();
					functionScope.DefinedFlags = definedFlags;
				}
			}
			else
			{
				int j = 0;
				for (int count2 = cases.count; j < count2; j++)
				{
					cases[j] = cases[j].PartiallyEvaluate();
				}
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Type type = Convert.ToType(expression.InferType(null));
			expression.context.EmitLineInfo(il);
			expression.TranslateToIL(il, type);
			LocalBuilder local = il.DeclareLocal(type);
			il.Emit(OpCodes.Stloc, local);
			int count = cases.count;
			Label[] array = new Label[cases.count];
			for (int i = 0; i < count; i++)
			{
				array[i] = il.DefineLabel();
				if (i != default_case)
				{
					il.Emit(OpCodes.Ldloc, local);
					((SwitchCase)cases[i]).TranslateToConditionalBranch(il, type, branchIfTrue: true, array[i], shortForm: false);
				}
			}
			Label label = il.DefineLabel();
			if (default_case >= 0)
			{
				il.Emit(OpCodes.Br, array[default_case]);
			}
			else
			{
				il.Emit(OpCodes.Br, label);
			}
			base.compilerGlobals.BreakLabelStack.Push(label);
			base.compilerGlobals.ContinueLabelStack.Push(label);
			for (int j = 0; j < count; j++)
			{
				il.MarkLabel(array[j]);
				cases[j].TranslateToIL(il, Typeob.Void);
			}
			il.MarkLabel(label);
			base.compilerGlobals.BreakLabelStack.Pop();
			base.compilerGlobals.ContinueLabelStack.Pop();
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			expression.TranslateToILInitializer(il);
			int i = 0;
			for (int count = cases.count; i < count; i++)
			{
				cases[i].TranslateToILInitializer(il);
			}
		}

		internal override Context GetFirstExecutableContext()
		{
			return expression.context;
		}
	}
	internal sealed class SwitchCase : AST
	{
		private AST case_value;

		private AST statements;

		private Completion completion;

		internal SwitchCase(Context context, AST statements)
			: this(context, null, statements)
		{
		}

		internal SwitchCase(Context context, AST case_value, AST statements)
			: base(context)
		{
			this.case_value = case_value;
			this.statements = statements;
			completion = new Completion();
		}

		internal override object Evaluate()
		{
			return statements.Evaluate();
		}

		internal Completion Evaluate(object expression)
		{
			if (StrictEquality.JScriptStrictEquals(case_value.Evaluate(), expression))
			{
				return (Completion)statements.Evaluate();
			}
			return null;
		}

		internal bool IsDefault()
		{
			return case_value == null;
		}

		internal override AST PartiallyEvaluate()
		{
			if (case_value != null)
			{
				case_value = case_value.PartiallyEvaluate();
			}
			statements = statements.PartiallyEvaluate();
			return this;
		}

		internal void TranslateToConditionalBranch(ILGenerator il, Type etype, bool branchIfTrue, Label label, bool shortForm)
		{
			Type type = etype;
			Type type2 = Convert.ToType(case_value.InferType(null));
			if (type != type2 && type.IsPrimitive && type2.IsPrimitive)
			{
				if (type == Typeob.Single && type2 == Typeob.Double)
				{
					type2 = Typeob.Single;
				}
				else if (Convert.IsPromotableTo(type2, type))
				{
					type2 = type;
				}
				else if (Convert.IsPromotableTo(type, type2))
				{
					type = type2;
				}
			}
			bool flag = true;
			if (type == type2 && type != Typeob.Object)
			{
				Convert.Emit(this, il, etype, type);
				if (!type.IsPrimitive && type.IsValueType)
				{
					il.Emit(OpCodes.Box, type);
				}
				case_value.context.EmitLineInfo(il);
				case_value.TranslateToIL(il, type);
				if (type == Typeob.String)
				{
					il.Emit(OpCodes.Call, CompilerGlobals.stringEqualsMethod);
				}
				else if (!type.IsPrimitive)
				{
					if (type.IsValueType)
					{
						il.Emit(OpCodes.Box, type);
					}
					il.Emit(OpCodes.Callvirt, CompilerGlobals.equalsMethod);
				}
				else
				{
					flag = false;
				}
			}
			else
			{
				Convert.Emit(this, il, etype, Typeob.Object);
				case_value.context.EmitLineInfo(il);
				case_value.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.jScriptStrictEqualsMethod);
			}
			if (branchIfTrue)
			{
				if (flag)
				{
					il.Emit(shortForm ? OpCodes.Brtrue_S : OpCodes.Brtrue, label);
				}
				else
				{
					il.Emit(shortForm ? OpCodes.Beq_S : OpCodes.Beq, label);
				}
			}
			else if (flag)
			{
				il.Emit(shortForm ? OpCodes.Brfalse_S : OpCodes.Brfalse, label);
			}
			else
			{
				il.Emit(shortForm ? OpCodes.Bne_Un_S : OpCodes.Bne_Un, label);
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			statements.TranslateToIL(il, Typeob.Void);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			if (case_value != null)
			{
				case_value.TranslateToILInitializer(il);
			}
			statements.TranslateToILInitializer(il);
		}
	}
	/// <summary>Represents a syntax error. For example, a syntax error can occur when you omit a semicolon.</summary>
	public sealed class SyntaxErrorObject : ErrorObject
	{
		internal SyntaxErrorObject(ErrorPrototype parent, object[] args)
			: base(parent, args)
		{
		}

		internal SyntaxErrorObject(ErrorPrototype parent, object e)
			: base(parent, e)
		{
		}
	}
	internal sealed class ThisLiteral : AST
	{
		internal bool isSuper;

		private MethodInfo method;

		internal ThisLiteral(Context context, bool isSuper)
			: base(context)
		{
			this.isSuper = isSuper;
			method = null;
		}

		internal override void CheckIfOKToUseInSuperConstructorCall()
		{
			context.HandleError(JSError.NotAllowedInSuperConstructorCall);
		}

		internal override object Evaluate()
		{
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject || scriptObject is BlockScope)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is StackFrame)
			{
				return ((StackFrame)scriptObject).thisObject;
			}
			return ((GlobalScope)scriptObject).thisObject;
		}

		internal override IReflect InferType(JSField inference_target)
		{
			if (method != null)
			{
				ParameterInfo[] parameters = method.GetParameters();
				if (parameters == null || parameters.Length == 0)
				{
					return method.ReturnType;
				}
				return parameters[0].ParameterType;
			}
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is GlobalScope)
			{
				return scriptObject;
			}
			if (scriptObject is FunctionScope && ((FunctionScope)scriptObject).isMethod)
			{
				ClassScope classScope = (ClassScope)((FunctionScope)scriptObject).owner.enclosing_scope;
				if (isSuper)
				{
					return classScope.GetSuperType();
				}
				return classScope;
			}
			return Typeob.Object;
		}

		internal override AST PartiallyEvaluate()
		{
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			bool flag = false;
			if (scriptObject is FunctionScope)
			{
				flag = ((FunctionScope)scriptObject).isStatic && ((FunctionScope)scriptObject).isMethod;
			}
			else if (scriptObject is StackFrame)
			{
				flag = ((StackFrame)scriptObject).thisObject is Type;
			}
			if (flag)
			{
				context.HandleError(JSError.NotAccessible);
				return new Lookup("this", context).PartiallyEvaluate();
			}
			return this;
		}

		internal override AST PartiallyEvaluateAsReference()
		{
			context.HandleError(JSError.CantAssignThis);
			return new Lookup("this", context).PartiallyEvaluateAsReference();
		}

		internal void ResolveAssignmentToDefaultIndexedProperty(ASTList args, IReflect[] argIRs, AST rhvalue)
		{
			IReflect reflect = InferType(null);
			Type t = ((reflect is Type) ? ((Type)reflect) : null);
			if (reflect is ClassScope)
			{
				t = ((ClassScope)reflect).GetBakedSuperType();
			}
			MemberInfo[] defaultMembers = JSBinder.GetDefaultMembers(t);
			if (defaultMembers != null && defaultMembers.Length != 0)
			{
				try
				{
					PropertyInfo propertyInfo = JSBinder.SelectProperty(defaultMembers, argIRs);
					if (propertyInfo != null)
					{
						method = JSProperty.GetSetMethod(propertyInfo, nonPublic: true);
						if (method == null)
						{
							context.HandleError(JSError.AssignmentToReadOnly, treatAsError: true);
						}
						if (!Binding.CheckParameters(propertyInfo.GetIndexParameters(), argIRs, args, context, 0, defaultIsUndefined: false, reportError: true))
						{
							method = null;
						}
						return;
					}
				}
				catch (AmbiguousMatchException)
				{
					context.HandleError(JSError.AmbiguousMatch);
					return;
				}
			}
			string message = ((reflect is ClassScope) ? ((ClassScope)reflect).GetName() : ((Type)reflect).Name);
			context.HandleError(JSError.NotIndexable, message);
		}

		internal override void ResolveCall(ASTList args, IReflect[] argIRs, bool constructor, bool brackets)
		{
			if (constructor || !brackets)
			{
				if (isSuper)
				{
					context.HandleError(JSError.IllegalUseOfSuper);
				}
				else
				{
					context.HandleError(JSError.IllegalUseOfThis);
				}
				return;
			}
			IReflect reflect = InferType(null);
			Type t = ((reflect is Type) ? ((Type)reflect) : null);
			if (reflect is ClassScope)
			{
				t = ((ClassScope)reflect).GetBakedSuperType();
			}
			MemberInfo[] defaultMembers = JSBinder.GetDefaultMembers(t);
			if (defaultMembers != null && defaultMembers.Length != 0)
			{
				try
				{
					method = JSBinder.SelectMethod(defaultMembers, argIRs);
					if (method != null)
					{
						if (!Binding.CheckParameters(method.GetParameters(), argIRs, args, context, 0, defaultIsUndefined: false, reportError: true))
						{
							method = null;
						}
						return;
					}
				}
				catch (AmbiguousMatchException)
				{
					context.HandleError(JSError.AmbiguousMatch);
					return;
				}
			}
			string message = ((reflect is ClassScope) ? ((ClassScope)reflect).GetName() : ((Type)reflect).Name);
			context.HandleError(JSError.NotIndexable, message);
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (rtype == Typeob.Void)
			{
				return;
			}
			IReflect reflect = InferType(null);
			if (reflect is GlobalScope)
			{
				EmitILToLoadEngine(il);
				if (rtype == Typeob.LenientGlobalObject)
				{
					il.Emit(OpCodes.Call, CompilerGlobals.getLenientGlobalObjectMethod);
					return;
				}
				il.Emit(OpCodes.Call, CompilerGlobals.scriptObjectStackTopMethod);
				il.Emit(OpCodes.Castclass, Typeob.IActivationObject);
				il.Emit(OpCodes.Callvirt, CompilerGlobals.getDefaultThisObjectMethod);
			}
			else
			{
				il.Emit(OpCodes.Ldarg_0);
				Convert.Emit(this, il, Convert.ToType(InferType(null)), rtype);
			}
		}

		internal override void TranslateToILCall(ILGenerator il, Type rtype, ASTList argList, bool construct, bool brackets)
		{
			MethodInfo methodInfo = method;
			if (methodInfo != null)
			{
				Type reflectedType = methodInfo.ReflectedType;
				if (!methodInfo.IsStatic)
				{
					method = null;
					TranslateToIL(il, reflectedType);
					method = methodInfo;
				}
				ParameterInfo[] parameters = methodInfo.GetParameters();
				Binding.PlaceArgumentsOnStack(il, parameters, argList, 0, 0, Binding.ReflectionMissingCW);
				if (methodInfo.IsVirtual && !methodInfo.IsFinal && (!reflectedType.IsSealed || !reflectedType.IsValueType))
				{
					il.Emit(OpCodes.Callvirt, methodInfo);
				}
				else
				{
					il.Emit(OpCodes.Call, methodInfo);
				}
				Convert.Emit(this, il, methodInfo.ReturnType, rtype);
			}
			else
			{
				base.TranslateToILCall(il, rtype, argList, construct, brackets);
			}
		}

		internal override void TranslateToILPreSet(ILGenerator il, ASTList argList)
		{
			MethodInfo methodInfo = method;
			if (methodInfo != null)
			{
				Type reflectedType = methodInfo.ReflectedType;
				if (!methodInfo.IsStatic)
				{
					TranslateToIL(il, reflectedType);
				}
				Binding.PlaceArgumentsOnStack(il, methodInfo.GetParameters(), argList, 0, 1, Binding.ReflectionMissingCW);
			}
			else
			{
				base.TranslateToILPreSet(il, argList);
			}
		}

		internal override void TranslateToILSet(ILGenerator il, AST rhvalue)
		{
			MethodInfo methodInfo = method;
			if (methodInfo != null)
			{
				rhvalue?.TranslateToIL(il, methodInfo.GetParameters()[0].ParameterType);
				Type reflectedType = methodInfo.ReflectedType;
				if (methodInfo.IsVirtual && !methodInfo.IsFinal && (!reflectedType.IsSealed || !reflectedType.IsValueType))
				{
					il.Emit(OpCodes.Callvirt, methodInfo);
				}
				else
				{
					il.Emit(OpCodes.Call, methodInfo);
				}
				if (methodInfo.ReturnType != Typeob.Void)
				{
					il.Emit(OpCodes.Pop);
				}
			}
			else
			{
				base.TranslateToILSet(il, rhvalue);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
		}
	}
	/// <summary>Throws an exception. This class belongs to the abstract syntax tree category.</summary>
	public sealed class Throw : AST
	{
		private AST operand;

		internal Throw(Context context, AST operand)
			: base(context)
		{
			this.operand = operand;
		}

		internal override object Evaluate()
		{
			if (operand == null)
			{
				ScriptObject scriptObject = base.Engine.ScriptObjectStackTop();
				while (scriptObject != null)
				{
					if (scriptObject is BlockScope blockScope && blockScope.catchHanderScope)
					{
						throw (Exception)blockScope.GetFields(BindingFlags.Static | BindingFlags.Public)[0].GetValue(null);
					}
				}
			}
			throw JScriptThrow(operand.Evaluate());
		}

		internal override bool HasReturn()
		{
			return true;
		}

		/// <summary>Returns the specified object as an exception, converting if it has to.</summary>
		/// <param name="value">The exception to throw.</param>
		/// <returns>An exception that represents <paramref name="value" />.</returns>
		public static Exception JScriptThrow(object value)
		{
			if (value is Exception)
			{
				return (Exception)value;
			}
			if (value is ErrorObject && ((ErrorObject)value).exception is Exception)
			{
				return (Exception)((ErrorObject)value).exception;
			}
			return new JScriptException(value, null);
		}

		internal override AST PartiallyEvaluate()
		{
			if (operand == null)
			{
				BlockScope blockScope = null;
				for (ScriptObject scriptObject = base.Engine.ScriptObjectStackTop(); scriptObject != null; scriptObject = scriptObject.GetParent())
				{
					if (!(scriptObject is WithObject))
					{
						blockScope = scriptObject as BlockScope;
						if (blockScope == null || blockScope.catchHanderScope)
						{
							break;
						}
					}
				}
				if (blockScope == null)
				{
					context.HandleError(JSError.BadThrow);
					operand = new ConstantWrapper(null, context);
				}
			}
			else
			{
				operand = operand.PartiallyEvaluate();
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			context.EmitLineInfo(il);
			if (operand == null)
			{
				il.Emit(OpCodes.Rethrow);
				return;
			}
			IReflect reflect = operand.InferType(null);
			if (reflect is Type && Typeob.Exception.IsAssignableFrom((Type)reflect))
			{
				operand.TranslateToIL(il, (Type)reflect);
			}
			else
			{
				operand.TranslateToIL(il, Typeob.Object);
				il.Emit(OpCodes.Call, CompilerGlobals.jScriptThrowMethod);
			}
			il.Emit(OpCodes.Throw);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			if (operand != null)
			{
				operand.TranslateToILInitializer(il);
			}
		}
	}
	/// <summary>Identifies blocks of code to run in error handling scopes. This class belongs to the abstract syntax tree category.</summary>
	public sealed class Try : AST
	{
		private AST body;

		private TypeExpression type;

		private AST handler;

		private AST finally_block;

		private BlockScope handler_scope;

		private FieldInfo field;

		private string fieldName;

		private bool finallyHasControlFlowOutOfIt;

		private Context tryEndContext;

		internal Try(Context context, AST body, AST identifier, TypeExpression type, AST handler, AST finally_block, bool finallyHasControlFlowOutOfIt, Context tryEndContext)
			: base(context)
		{
			this.body = body;
			this.type = type;
			this.handler = handler;
			this.finally_block = finally_block;
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			handler_scope = null;
			field = null;
			if (identifier != null)
			{
				fieldName = identifier.ToString();
				field = scriptObject.GetField(fieldName, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
				if (field != null)
				{
					if (type == null && field is JSVariableField && field.IsStatic && ((JSVariableField)field).type == null && !field.IsLiteral && !field.IsInitOnly)
					{
						return;
					}
					if (((IActivationObject)scriptObject).GetLocalField(fieldName) != null)
					{
						identifier.context.HandleError(JSError.DuplicateName, treatAsError: false);
					}
				}
				handler_scope = new BlockScope(scriptObject);
				handler_scope.catchHanderScope = true;
				((JSVariableField)(field = handler_scope.AddNewField(identifier.ToString(), Missing.Value, FieldAttributes.Public))).originalContext = identifier.context;
				if (identifier.context.document.debugOn && field is JSLocalField)
				{
					handler_scope.AddFieldForLocalScopeDebugInfo((JSLocalField)field);
				}
			}
			this.finallyHasControlFlowOutOfIt = finallyHasControlFlowOutOfIt;
			this.tryEndContext = tryEndContext;
		}

		internal override object Evaluate()
		{
			int i = base.Globals.ScopeStack.Size();
			int i2 = base.Globals.CallContextStack.Size();
			Completion completion = null;
			Completion completion2 = null;
			try
			{
				object obj = null;
				try
				{
					completion = (Completion)body.Evaluate();
				}
				catch (Exception ex)
				{
					if (handler == null)
					{
						throw;
					}
					obj = ex;
					if (this.type != null)
					{
						Type type = this.type.ToType();
						if (Typeob.Exception.IsAssignableFrom(type))
						{
							if (!type.IsInstanceOfType(ex))
							{
								throw;
							}
						}
						else if (!type.IsInstanceOfType(obj = JScriptExceptionValue(ex, base.Engine)))
						{
							throw;
						}
					}
					else
					{
						obj = JScriptExceptionValue(ex, base.Engine);
					}
				}
				if (obj != null)
				{
					base.Globals.ScopeStack.TrimToSize(i);
					base.Globals.CallContextStack.TrimToSize(i2);
					if (handler_scope != null)
					{
						handler_scope.SetParent(base.Globals.ScopeStack.Peek());
						base.Globals.ScopeStack.Push(handler_scope);
					}
					if (field != null)
					{
						field.SetValue(base.Globals.ScopeStack.Peek(), obj);
					}
					completion = (Completion)handler.Evaluate();
				}
			}
			finally
			{
				base.Globals.ScopeStack.TrimToSize(i);
				base.Globals.CallContextStack.TrimToSize(i2);
				if (finally_block != null)
				{
					completion2 = (Completion)finally_block.Evaluate();
				}
			}
			if (completion == null || (completion2 != null && (completion2.Exit > 0 || completion2.Continue > 0 || completion2.Return)))
			{
				completion = completion2;
			}
			else if (completion2 != null && completion2.value is Missing)
			{
				completion.value = completion2.value;
			}
			Completion completion3 = new Completion();
			completion3.Continue = completion.Continue - 1;
			completion3.Exit = completion.Exit - 1;
			completion3.Return = completion.Return;
			completion3.value = completion.value;
			return completion3;
		}

		internal override Context GetFirstExecutableContext()
		{
			return body.GetFirstExecutableContext();
		}

		/// <summary>Returns the specified object as an exception, converting it to a specific <see cref="T:Microsoft.JScript.JScriptException" /> if it can.</summary>
		/// <param name="e">The object that represents the exception.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>The exception <paramref name="e" />, converted to a specific <see cref="T:Microsoft.JScript.JScriptException" /> if that is possible.</returns>
		public static object JScriptExceptionValue(object e, VsaEngine engine)
		{
			if (engine == null)
			{
				engine = new VsaEngine(fast: true);
				engine.InitVsaEngine("JS7://Microsoft.JScript.Vsa.VsaEngine", new DefaultVsaSite());
			}
			ErrorConstructor originalError = engine.Globals.globalObject.originalError;
			if (e is JScriptException)
			{
				object value = ((JScriptException)e).value;
				if (value is Exception || value is Missing || (((JScriptException)e).Number & 0xFFFF) != 5022)
				{
					return originalError.Construct((Exception)e);
				}
				return value;
			}
			if (e is StackOverflowException)
			{
				return originalError.Construct(new JScriptException(JSError.OutOfStack));
			}
			if (e is OutOfMemoryException)
			{
				return originalError.Construct(new JScriptException(JSError.OutOfMemory));
			}
			return originalError.Construct(e);
		}

		internal override AST PartiallyEvaluate()
		{
			if (type != null)
			{
				type.PartiallyEvaluate();
				((JSVariableField)field).type = type;
			}
			else if (field is JSLocalField)
			{
				((JSLocalField)field).SetInferredType(Typeob.Object, null);
			}
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			FunctionScope functionScope = null;
			BitArray definedFlags = null;
			if (scriptObject is FunctionScope)
			{
				functionScope = (FunctionScope)scriptObject;
				definedFlags = functionScope.DefinedFlags;
			}
			body = body.PartiallyEvaluate();
			if (handler != null)
			{
				if (handler_scope != null)
				{
					base.Globals.ScopeStack.Push(handler_scope);
				}
				if (field is JSLocalField)
				{
					((JSLocalField)field).isDefined = true;
				}
				handler = handler.PartiallyEvaluate();
				if (handler_scope != null)
				{
					base.Globals.ScopeStack.Pop();
				}
			}
			if (finally_block != null)
			{
				finally_block = finally_block.PartiallyEvaluate();
			}
			if (functionScope != null)
			{
				functionScope.DefinedFlags = definedFlags;
			}
			return this;
		}

		/// <summary>Creates a new <see cref="T:Microsoft.JScript.BlockScope" /> object for the <see langword="try" /> block and pushes it onto the global scope stack.</summary>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <param name="id">The name of the scope of the <see langword="try" /> block.</param>
		/// <param name="scopeId">The ID of the scope of the <see langword="try" /> block.</param>
		public static void PushHandlerScope(VsaEngine engine, string id, int scopeId)
		{
			engine.PushScriptObject(new BlockScope(engine.ScriptObjectStackTop(), id, scopeId));
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			bool insideProtectedRegion = base.compilerGlobals.InsideProtectedRegion;
			base.compilerGlobals.InsideProtectedRegion = true;
			base.compilerGlobals.BreakLabelStack.Push(base.compilerGlobals.BreakLabelStack.Peek(0));
			base.compilerGlobals.ContinueLabelStack.Push(base.compilerGlobals.ContinueLabelStack.Peek(0));
			il.BeginExceptionBlock();
			if (finally_block != null)
			{
				if (finallyHasControlFlowOutOfIt)
				{
					il.BeginExceptionBlock();
				}
				if (handler != null)
				{
					il.BeginExceptionBlock();
				}
			}
			body.TranslateToIL(il, Typeob.Void);
			if (tryEndContext != null)
			{
				tryEndContext.EmitLineInfo(il);
			}
			if (handler != null)
			{
				if (this.type == null)
				{
					il.BeginCatchBlock(Typeob.Exception);
					handler.context.EmitLineInfo(il);
					EmitILToLoadEngine(il);
					il.Emit(OpCodes.Call, CompilerGlobals.jScriptExceptionValueMethod);
				}
				else
				{
					Type type = this.type.ToType();
					if (Typeob.Exception.IsAssignableFrom(type))
					{
						il.BeginCatchBlock(type);
						handler.context.EmitLineInfo(il);
					}
					else
					{
						il.BeginExceptFilterBlock();
						handler.context.EmitLineInfo(il);
						EmitILToLoadEngine(il);
						il.Emit(OpCodes.Call, CompilerGlobals.jScriptExceptionValueMethod);
						il.Emit(OpCodes.Isinst, type);
						il.Emit(OpCodes.Ldnull);
						il.Emit(OpCodes.Cgt_Un);
						il.BeginCatchBlock(null);
						EmitILToLoadEngine(il);
						il.Emit(OpCodes.Call, CompilerGlobals.jScriptExceptionValueMethod);
						Convert.Emit(this, il, Typeob.Object, type);
					}
				}
				object obj = ((field is JSVariableField) ? ((JSVariableField)field).GetMetaData() : field);
				if (obj is LocalBuilder)
				{
					il.Emit(OpCodes.Stloc, (LocalBuilder)obj);
				}
				else if (obj is FieldInfo)
				{
					il.Emit(OpCodes.Stsfld, (FieldInfo)obj);
				}
				else
				{
					Convert.EmitLdarg(il, (short)obj);
				}
				if (handler_scope != null)
				{
					if (!handler_scope.isKnownAtCompileTime)
					{
						EmitILToLoadEngine(il);
						il.Emit(OpCodes.Ldstr, fieldName);
						ConstantWrapper.TranslateToILInt(il, handler_scope.scopeId);
						il.Emit(OpCodes.Call, Typeob.Try.GetMethod("PushHandlerScope"));
						base.Globals.ScopeStack.Push(handler_scope);
						il.BeginExceptionBlock();
					}
					il.BeginScope();
					if (context.document.debugOn)
					{
						handler_scope.EmitLocalInfoForFields(il);
					}
				}
				handler.TranslateToIL(il, Typeob.Void);
				if (handler_scope != null)
				{
					il.EndScope();
					if (!handler_scope.isKnownAtCompileTime)
					{
						il.BeginFinallyBlock();
						EmitILToLoadEngine(il);
						il.Emit(OpCodes.Call, CompilerGlobals.popScriptObjectMethod);
						il.Emit(OpCodes.Pop);
						base.Globals.ScopeStack.Pop();
						il.EndExceptionBlock();
					}
				}
				il.EndExceptionBlock();
			}
			if (finally_block != null)
			{
				bool insideFinally = base.compilerGlobals.InsideFinally;
				int finallyStackTop = base.compilerGlobals.FinallyStackTop;
				base.compilerGlobals.InsideFinally = true;
				base.compilerGlobals.FinallyStackTop = base.compilerGlobals.BreakLabelStack.Size();
				il.BeginFinallyBlock();
				finally_block.TranslateToIL(il, Typeob.Void);
				il.EndExceptionBlock();
				base.compilerGlobals.InsideFinally = insideFinally;
				base.compilerGlobals.FinallyStackTop = finallyStackTop;
				if (finallyHasControlFlowOutOfIt)
				{
					il.BeginCatchBlock(Typeob.BreakOutOfFinally);
					il.Emit(OpCodes.Ldfld, Typeob.BreakOutOfFinally.GetField("target"));
					int num = base.compilerGlobals.BreakLabelStack.Size() - 1;
					int num2 = num;
					while (num > 0)
					{
						il.Emit(OpCodes.Dup);
						ConstantWrapper.TranslateToILInt(il, num);
						Label label = il.DefineLabel();
						il.Emit(OpCodes.Blt_S, label);
						il.Emit(OpCodes.Pop);
						if (insideFinally && num < finallyStackTop)
						{
							il.Emit(OpCodes.Rethrow);
						}
						else
						{
							il.Emit(OpCodes.Leave, (Label)base.compilerGlobals.BreakLabelStack.Peek(num2 - num));
						}
						il.MarkLabel(label);
						num--;
					}
					il.Emit(OpCodes.Pop);
					il.BeginCatchBlock(Typeob.ContinueOutOfFinally);
					il.Emit(OpCodes.Ldfld, Typeob.ContinueOutOfFinally.GetField("target"));
					int num3 = base.compilerGlobals.ContinueLabelStack.Size() - 1;
					int num4 = num3;
					while (num3 > 0)
					{
						il.Emit(OpCodes.Dup);
						ConstantWrapper.TranslateToILInt(il, num3);
						Label label2 = il.DefineLabel();
						il.Emit(OpCodes.Blt_S, label2);
						il.Emit(OpCodes.Pop);
						if (insideFinally && num3 < finallyStackTop)
						{
							il.Emit(OpCodes.Rethrow);
						}
						else
						{
							il.Emit(OpCodes.Leave, (Label)base.compilerGlobals.ContinueLabelStack.Peek(num4 - num3));
						}
						il.MarkLabel(label2);
						num3--;
					}
					il.Emit(OpCodes.Pop);
					ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
					while (scriptObject != null && !(scriptObject is FunctionScope))
					{
						scriptObject = scriptObject.GetParent();
					}
					if (scriptObject != null && !insideFinally)
					{
						il.BeginCatchBlock(Typeob.ReturnOutOfFinally);
						il.Emit(OpCodes.Pop);
						il.Emit(OpCodes.Leave, ((FunctionScope)scriptObject).owner.returnLabel);
					}
					il.EndExceptionBlock();
				}
			}
			base.compilerGlobals.InsideProtectedRegion = insideProtectedRegion;
			base.compilerGlobals.BreakLabelStack.Pop();
			base.compilerGlobals.ContinueLabelStack.Pop();
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			body.TranslateToILInitializer(il);
			if (handler != null)
			{
				handler.TranslateToILInitializer(il);
			}
			if (finally_block != null)
			{
				finally_block.TranslateToILInitializer(il);
			}
		}
	}
	/// <summary>Represents a reflectable reference to the <see cref="T:System.Array" /> class. This class stores the element type of a typed array, but this class does not store data.</summary>
	public sealed class TypedArray : IReflect
	{
		internal IReflect elementType;

		internal int rank;

		/// <summary>Gets the type of the <see cref="T:Microsoft.JScript.TypedArray" /> object.</summary>
		/// <returns>The type of the <see cref="T:Microsoft.JScript.TypedArray" /> object.</returns>
		public Type UnderlyingSystemType => GetType();

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.TypedArray" /> class.</summary>
		/// <param name="elementType">The element type of a typed array.</param>
		/// <param name="rank">The rank (number of dimensions) of the array.</param>
		public TypedArray(IReflect elementType, int rank)
		{
			this.elementType = elementType;
			this.rank = rank;
		}

		/// <summary>Determines whether the specified typed array has the same element type and rank as the current typed array.</summary>
		/// <param name="obj">The typed array to compare with the current typed array.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> has the same element type and rank as the current typed array; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (obj is TypedArray)
			{
				return ToString().Equals(obj.ToString());
			}
			Type type = obj as Type;
			if (type == null)
			{
				return false;
			}
			if (!type.IsArray)
			{
				return false;
			}
			if (type.GetArrayRank() != rank)
			{
				return false;
			}
			return elementType.Equals(type.GetElementType());
		}

		/// <summary>Gets a field of the <see cref="T:System.Array" /> class type that has the specified name.</summary>
		/// <param name="name">The name of the field to get.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>A field that has the specified name, if one is found; otherwise, null.</returns>
		public FieldInfo GetField(string name, BindingFlags bindingAttr)
		{
			return Typeob.Array.GetField(name, bindingAttr);
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.FieldInfo" /> objects that correspond to all fields of the <see cref="T:System.Array" /> class type.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all fields of the <see cref="T:System.Array" /> class type.</returns>
		public FieldInfo[] GetFields(BindingFlags bindingAttr)
		{
			return Typeob.Array.GetFields(bindingAttr);
		}

		/// <summary>Serves as a hash function for the element type of the typed array.</summary>
		/// <returns>A hash code for the current object.</returns>
		public override int GetHashCode()
		{
			return ToString().GetHashCode();
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.MemberInfo" /> objects that correspond to all members of the <see cref="T:System.Array" /> class type that match a specified name.</summary>
		/// <param name="name">The name of the member to search for.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that match the <paramref name="name" /> argument.</returns>
		public MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
		{
			return Typeob.Array.GetMember(name, bindingAttr);
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.MemberInfo" /> objects that correspond to all members of the <see cref="T:System.Array" /> class type.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all members of the <see cref="T:System.Array" /> class type.</returns>
		public MemberInfo[] GetMembers(BindingFlags bindingAttr)
		{
			return Typeob.Array.GetMembers(bindingAttr);
		}

		/// <summary>Gets a method of the <see cref="T:System.Array" /> class type that has the specified name.</summary>
		/// <param name="name">The name of the method to get.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>A method that has the specified name, if one is found; otherwise, null.</returns>
		public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
		{
			return Typeob.Array.GetMethod(name, bindingAttr);
		}

		/// <summary>Gets a method of the <see cref="T:System.Array" /> class type that has the specified name by using the specified selection criteria.</summary>
		/// <param name="name">The name of the method to get.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <param name="binder">An object that performs type conversion from actual argument type to formal argument type.</param>
		/// <param name="types">The parameter types that are used to locate a matching method.</param>
		/// <param name="modifiers">An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified.</param>
		/// <returns>A method that has the specified name, if one is found; otherwise, null.</returns>
		public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
		{
			return Typeob.Array.GetMethod(name, bindingAttr, binder, types, modifiers);
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.MethodInfo" /> objects that correspond to all methods of the <see cref="T:System.Array" /> class type.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all methods of the <see cref="T:System.Array" /> class type.</returns>
		public MethodInfo[] GetMethods(BindingFlags bindingAttr)
		{
			return Typeob.Array.GetMethods(bindingAttr);
		}

		/// <summary>Gets a property of the <see cref="T:System.Array" /> class type that has the specified name.</summary>
		/// <param name="name">The name of the property to get.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>A property that has the specified name, if one is found; otherwise, null.</returns>
		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
		{
			return Typeob.Array.GetProperty(name, bindingAttr);
		}

		/// <summary>Gets a property of the <see cref="T:System.Array" /> class type that has the specified name by using the specified selection criteria.</summary>
		/// <param name="name">The name of the property to get.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <param name="binder">An object that performs type conversion from actual argument type to formal argument type.</param>
		/// <param name="returnType">The type of the return value that the property must have.</param>
		/// <param name="types">The index types of the property being searched for. Used for index properties, such as the indexer for a class.</param>
		/// <param name="modifiers">An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified.</param>
		/// <returns>A property that has the specified name, if one is found; otherwise, null.</returns>
		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
		{
			return Typeob.Array.GetProperty(name, bindingAttr, binder, returnType, types, modifiers);
		}

		/// <summary>Gets an array of <see cref="T:System.Reflection.PropertyInfo" /> objects that correspond to all properties of the <see cref="T:System.Array" /> class type.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <returns>An array of objects that contains all properties of the <see cref="T:System.Array" /> class type.</returns>
		public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
		{
			return Typeob.Array.GetProperties(bindingAttr);
		}

		/// <summary>Invokes the specified member of the element type or the <see cref="T:System.Array" /> class type.</summary>
		/// <param name="name">The name of the member to invoke.</param>
		/// <param name="flags">A bitwise combination of the enumeration values that specifies how the search for members is conducted by reflection.</param>
		/// <param name="binder">An object that performs type conversion from actual argument type to formal argument type.</param>
		/// <param name="target">The object on which to invoke the member. This must be the current script object.</param>
		/// <param name="args">An array of objects that contains the number, order, and type of the parameters of the member to be invoked. This is an empty array if there are no parameters.</param>
		/// <param name="modifiers">An array that has the same length as the <paramref name="args" /> parameter. It represents the invoked member's argument attributes in the metadata.</param>
		/// <param name="locale">Provides information about a specific culture or locale. Used to format numbers, dates, and strings correctly.</param>
		/// <param name="namedParameters">An array of parameters.</param>
		/// <returns>The return value of the call to the member.</returns>
		public object InvokeMember(string name, BindingFlags flags, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo locale, string[] namedParameters)
		{
			if ((flags & BindingFlags.CreateInstance) == 0)
			{
				return LateBinding.CallValue(elementType, args, construct: true, brackets: true, null, null, binder, locale, namedParameters);
			}
			return Typeob.Array.InvokeMember(name, flags, binder, target, args, modifiers, locale, namedParameters);
		}

		internal static string ToRankString(int rank)
		{
			switch (rank)
			{
			case 1:
				return "[]";
			case 2:
				return "[,]";
			case 3:
				return "[,,]";
			default:
			{
				StringBuilder stringBuilder = new StringBuilder(rank + 1);
				stringBuilder.Append('[');
				for (int i = 1; i < rank; i++)
				{
					stringBuilder.Append(',');
				}
				stringBuilder.Append(']');
				return stringBuilder.ToString();
			}
			}
		}

		/// <summary>Returns a string that contains the element type of the typed array and the rank information.</summary>
		/// <returns>A string that contains the element type of the typed array and the rank information.</returns>
		public override string ToString()
		{
			Type type = elementType as Type;
			if (type != null)
			{
				return type.FullName + ToRankString(rank);
			}
			if (elementType is ClassScope classScope)
			{
				return classScope.GetFullName() + ToRankString(rank);
			}
			if (elementType is TypedArray typedArray)
			{
				return typedArray.ToString() + ToRankString(rank);
			}
			return Convert.ToType(elementType).FullName + ToRankString(rank);
		}

		internal Type ToType()
		{
			Type type = Convert.ToType(elementType);
			return Convert.ToType(ToRankString(rank), type);
		}
	}
	/// <summary>Represents a type error. For example, a type error can occur when you pass an object of one type to a method that expects an object of another type.</summary>
	public sealed class TypeErrorObject : ErrorObject
	{
		internal TypeErrorObject(ErrorPrototype parent, object[] args)
			: base(parent, args)
		{
		}

		internal TypeErrorObject(ErrorPrototype parent, object e)
			: base(parent, e)
		{
		}
	}
	internal sealed class TypeExpression : AST
	{
		internal AST expression;

		internal bool isArray;

		internal int rank;

		private bool recursive;

		private IReflect cachedIR;

		internal TypeExpression(AST expression)
			: base(expression.context)
		{
			this.expression = expression;
			isArray = false;
			rank = 0;
			recursive = false;
			cachedIR = null;
			if (expression is Lookup)
			{
				string typeName = expression.ToString();
				object predefinedType = Globals.TypeRefs.GetPredefinedType(typeName);
				if (predefinedType != null)
				{
					this.expression = new ConstantWrapper(predefinedType, expression.context);
				}
			}
		}

		internal override object Evaluate()
		{
			return ToIReflect();
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return ToIReflect();
		}

		internal bool IsCLSCompliant()
		{
			object type = expression.Evaluate();
			return TypeIsCLSCompliant(type);
		}

		internal override AST PartiallyEvaluate()
		{
			if (recursive)
			{
				if (expression is ConstantWrapper)
				{
					return this;
				}
				expression = new ConstantWrapper(Typeob.Object, context);
				return this;
			}
			if (expression is Member member)
			{
				object obj = member.EvaluateAsType();
				if (obj != null)
				{
					expression = new ConstantWrapper(obj, member.context);
					return this;
				}
			}
			recursive = true;
			expression = expression.PartiallyEvaluate();
			recursive = false;
			if (expression is TypeExpression)
			{
				return this;
			}
			Type type = null;
			if (expression is ConstantWrapper)
			{
				object obj2 = expression.Evaluate();
				if (obj2 == null)
				{
					expression.context.HandleError(JSError.NeedType);
					expression = new ConstantWrapper(Typeob.Object, context);
					return this;
				}
				type = Globals.TypeRefs.ToReferenceContext(obj2.GetType());
				Binding.WarnIfObsolete(obj2 as Type, expression.context);
			}
			else
			{
				if (!expression.OkToUseAsType())
				{
					expression.context.HandleError(JSError.NeedCompileTimeConstant);
					expression = new ConstantWrapper(Typeob.Object, expression.context);
					return this;
				}
				type = Globals.TypeRefs.ToReferenceContext(expression.Evaluate().GetType());
			}
			if (type == null || (type != Typeob.ClassScope && type != Typeob.TypedArray && !Typeob.Type.IsAssignableFrom(type)))
			{
				expression.context.HandleError(JSError.NeedType);
				expression = new ConstantWrapper(Typeob.Object, expression.context);
			}
			return this;
		}

		internal IReflect ToIReflect()
		{
			if (!(expression is ConstantWrapper))
			{
				PartiallyEvaluate();
			}
			IReflect reflect = cachedIR;
			if (reflect != null)
			{
				return reflect;
			}
			object obj = expression.Evaluate();
			reflect = ((!(obj is ClassScope) && !(obj is TypedArray) && context != null) ? Convert.ToIReflect((Type)obj, base.Engine) : ((IReflect)obj));
			if (isArray)
			{
				return cachedIR = new TypedArray(reflect, rank);
			}
			return cachedIR = reflect;
		}

		internal Type ToType()
		{
			if (!(expression is ConstantWrapper))
			{
				PartiallyEvaluate();
			}
			object obj = expression.Evaluate();
			Type type = null;
			type = ((obj is ClassScope) ? ((ClassScope)obj).GetTypeBuilderOrEnumBuilder() : ((!(obj is TypedArray)) ? Globals.TypeRefs.ToReferenceContext((Type)obj) : Convert.ToType((TypedArray)obj)));
			if (isArray)
			{
				return Convert.ToType(TypedArray.ToRankString(rank), type);
			}
			return type;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			expression.TranslateToIL(il, rtype);
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			expression.TranslateToILInitializer(il);
		}

		internal static bool TypeIsCLSCompliant(object type)
		{
			if (type is ClassScope)
			{
				return ((ClassScope)type).IsCLSCompliant();
			}
			if (type is TypedArray)
			{
				object elementType = ((TypedArray)type).elementType;
				if (elementType is TypedArray || (elementType is Type && ((Type)elementType).IsArray))
				{
					return false;
				}
				return TypeIsCLSCompliant(elementType);
			}
			Type type2 = (Type)type;
			if (type2.IsPrimitive)
			{
				if (type2 == Typeob.Boolean || type2 == Typeob.Byte || type2 == Typeob.Char || type2 == Typeob.Double || type2 == Typeob.Int16 || type2 == Typeob.Int32 || type2 == Typeob.Int64 || type2 == Typeob.Single)
				{
					return true;
				}
				return false;
			}
			if (type2.IsArray)
			{
				Type elementType2 = type2.GetElementType();
				if (elementType2.IsArray)
				{
					return false;
				}
				return TypeIsCLSCompliant(type2);
			}
			object[] customAttributes = CustomAttribute.GetCustomAttributes(type2, typeof(CLSCompliantAttribute), inherit: false);
			if (customAttributes.Length != 0)
			{
				return ((CLSCompliantAttribute)customAttributes[0]).IsCompliant;
			}
			Module module = type2.Module;
			customAttributes = CustomAttribute.GetCustomAttributes(module, typeof(CLSCompliantAttribute), inherit: false);
			if (customAttributes.Length != 0)
			{
				return ((CLSCompliantAttribute)customAttributes[0]).IsCompliant;
			}
			Assembly assembly = module.Assembly;
			customAttributes = CustomAttribute.GetCustomAttributes(assembly, typeof(CLSCompliantAttribute), inherit: false);
			if (customAttributes.Length != 0)
			{
				return ((CLSCompliantAttribute)customAttributes[0]).IsCompliant;
			}
			return false;
		}
	}
	internal static class Typeob
	{
		internal static Type ArgumentsObject => Microsoft.JScript.Globals.TypeRefs.ArgumentsObject;

		internal static Type ArrayConstructor => Microsoft.JScript.Globals.TypeRefs.ArrayConstructor;

		internal static Type ArrayObject => Microsoft.JScript.Globals.TypeRefs.ArrayObject;

		internal static Type ArrayWrapper => Microsoft.JScript.Globals.TypeRefs.ArrayWrapper;

		internal static Type BaseVsaStartup => Microsoft.JScript.Globals.TypeRefs.BaseVsaStartup;

		internal static Type Binding => Microsoft.JScript.Globals.TypeRefs.Binding;

		internal static Type BitwiseBinary => Microsoft.JScript.Globals.TypeRefs.BitwiseBinary;

		internal static Type BooleanObject => Microsoft.JScript.Globals.TypeRefs.BooleanObject;

		internal static Type BreakOutOfFinally => Microsoft.JScript.Globals.TypeRefs.BreakOutOfFinally;

		internal static Type BuiltinFunction => Microsoft.JScript.Globals.TypeRefs.BuiltinFunction;

		internal static Type ClassScope => Microsoft.JScript.Globals.TypeRefs.ClassScope;

		internal static Type Closure => Microsoft.JScript.Globals.TypeRefs.Closure;

		internal static Type ContinueOutOfFinally => Microsoft.JScript.Globals.TypeRefs.ContinueOutOfFinally;

		internal static Type Convert => Microsoft.JScript.Globals.TypeRefs.Convert;

		internal static Type DateObject => Microsoft.JScript.Globals.TypeRefs.DateObject;

		internal static Type Empty => Microsoft.JScript.Globals.TypeRefs.Empty;

		internal static Type EnumeratorObject => Microsoft.JScript.Globals.TypeRefs.EnumeratorObject;

		internal static Type Equality => Microsoft.JScript.Globals.TypeRefs.Equality;

		internal static Type ErrorObject => Microsoft.JScript.Globals.TypeRefs.ErrorObject;

		internal static Type Eval => Microsoft.JScript.Globals.TypeRefs.Eval;

		internal static Type EvalErrorObject => Microsoft.JScript.Globals.TypeRefs.EvalErrorObject;

		internal static Type Expando => Microsoft.JScript.Globals.TypeRefs.Expando;

		internal static Type FieldAccessor => Microsoft.JScript.Globals.TypeRefs.FieldAccessor;

		internal static Type ForIn => Microsoft.JScript.Globals.TypeRefs.ForIn;

		internal static Type FunctionDeclaration => Microsoft.JScript.Globals.TypeRefs.FunctionDeclaration;

		internal static Type FunctionExpression => Microsoft.JScript.Globals.TypeRefs.FunctionExpression;

		internal static Type FunctionObject => Microsoft.JScript.Globals.TypeRefs.FunctionObject;

		internal static Type FunctionWrapper => Microsoft.JScript.Globals.TypeRefs.FunctionWrapper;

		internal static Type GlobalObject => Microsoft.JScript.Globals.TypeRefs.GlobalObject;

		internal static Type GlobalScope => Microsoft.JScript.Globals.TypeRefs.GlobalScope;

		internal static Type Globals => Microsoft.JScript.Globals.TypeRefs.Globals;

		internal static Type Hide => Microsoft.JScript.Globals.TypeRefs.Hide;

		internal static Type IActivationObject => Microsoft.JScript.Globals.TypeRefs.IActivationObject;

		internal static Type INeedEngine => Microsoft.JScript.Globals.TypeRefs.INeedEngine;

		internal static Type Import => Microsoft.JScript.Globals.TypeRefs.Import;

		internal static Type In => Microsoft.JScript.Globals.TypeRefs.In;

		internal static Type Instanceof => Microsoft.JScript.Globals.TypeRefs.Instanceof;

		internal static Type JSError => Microsoft.JScript.Globals.TypeRefs.JSError;

		internal static Type JSFunctionAttribute => Microsoft.JScript.Globals.TypeRefs.JSFunctionAttribute;

		internal static Type JSFunctionAttributeEnum => Microsoft.JScript.Globals.TypeRefs.JSFunctionAttributeEnum;

		internal static Type JSLocalField => Microsoft.JScript.Globals.TypeRefs.JSLocalField;

		internal static Type JSObject => Microsoft.JScript.Globals.TypeRefs.JSObject;

		internal static Type JScriptException => Microsoft.JScript.Globals.TypeRefs.JScriptException;

		internal static Type LateBinding => Microsoft.JScript.Globals.TypeRefs.LateBinding;

		internal static Type LenientGlobalObject => Microsoft.JScript.Globals.TypeRefs.LenientGlobalObject;

		internal static Type MathObject => Microsoft.JScript.Globals.TypeRefs.MathObject;

		internal static Type MethodInvoker => Microsoft.JScript.Globals.TypeRefs.MethodInvoker;

		internal static Type Missing => Microsoft.JScript.Globals.TypeRefs.Missing;

		internal static Type Namespace => Microsoft.JScript.Globals.TypeRefs.Namespace;

		internal static Type NotRecommended => Microsoft.JScript.Globals.TypeRefs.NotRecommended;

		internal static Type NumberObject => Microsoft.JScript.Globals.TypeRefs.NumberObject;

		internal static Type NumericBinary => Microsoft.JScript.Globals.TypeRefs.NumericBinary;

		internal static Type NumericUnary => Microsoft.JScript.Globals.TypeRefs.NumericUnary;

		internal static Type ObjectConstructor => Microsoft.JScript.Globals.TypeRefs.ObjectConstructor;

		internal static Type Override => Microsoft.JScript.Globals.TypeRefs.Override;

		internal static Type Package => Microsoft.JScript.Globals.TypeRefs.Package;

		internal static Type Plus => Microsoft.JScript.Globals.TypeRefs.Plus;

		internal static Type PostOrPrefixOperator => Microsoft.JScript.Globals.TypeRefs.PostOrPrefixOperator;

		internal static Type RangeErrorObject => Microsoft.JScript.Globals.TypeRefs.RangeErrorObject;

		internal static Type ReferenceAttribute => Microsoft.JScript.Globals.TypeRefs.ReferenceAttribute;

		internal static Type ReferenceErrorObject => Microsoft.JScript.Globals.TypeRefs.ReferenceErrorObject;

		internal static Type RegExpConstructor => Microsoft.JScript.Globals.TypeRefs.RegExpConstructor;

		internal static Type RegExpObject => Microsoft.JScript.Globals.TypeRefs.RegExpObject;

		internal static Type Relational => Microsoft.JScript.Globals.TypeRefs.Relational;

		internal static Type ReturnOutOfFinally => Microsoft.JScript.Globals.TypeRefs.ReturnOutOfFinally;

		internal static Type Runtime => Microsoft.JScript.Globals.TypeRefs.Runtime;

		internal static Type ScriptFunction => Microsoft.JScript.Globals.TypeRefs.ScriptFunction;

		internal static Type ScriptObject => Microsoft.JScript.Globals.TypeRefs.ScriptObject;

		internal static Type ScriptStream => Microsoft.JScript.Globals.TypeRefs.ScriptStream;

		internal static Type SimpleHashtable => Microsoft.JScript.Globals.TypeRefs.SimpleHashtable;

		internal static Type StackFrame => Microsoft.JScript.Globals.TypeRefs.StackFrame;

		internal static Type StrictEquality => Microsoft.JScript.Globals.TypeRefs.StrictEquality;

		internal static Type StringObject => Microsoft.JScript.Globals.TypeRefs.StringObject;

		internal static Type SyntaxErrorObject => Microsoft.JScript.Globals.TypeRefs.SyntaxErrorObject;

		internal static Type Throw => Microsoft.JScript.Globals.TypeRefs.Throw;

		internal static Type Try => Microsoft.JScript.Globals.TypeRefs.Try;

		internal static Type TypedArray => Microsoft.JScript.Globals.TypeRefs.TypedArray;

		internal static Type TypeErrorObject => Microsoft.JScript.Globals.TypeRefs.TypeErrorObject;

		internal static Type Typeof => Microsoft.JScript.Globals.TypeRefs.Typeof;

		internal static Type URIErrorObject => Microsoft.JScript.Globals.TypeRefs.URIErrorObject;

		internal static Type VBArrayObject => Microsoft.JScript.Globals.TypeRefs.VBArrayObject;

		internal static Type With => Microsoft.JScript.Globals.TypeRefs.With;

		internal static Type VsaEngine => Microsoft.JScript.Globals.TypeRefs.VsaEngine;

		internal static Type Array => Microsoft.JScript.Globals.TypeRefs.Array;

		internal static Type Attribute => Microsoft.JScript.Globals.TypeRefs.Attribute;

		internal static Type AttributeUsageAttribute => Microsoft.JScript.Globals.TypeRefs.AttributeUsageAttribute;

		internal static Type Byte => Microsoft.JScript.Globals.TypeRefs.Byte;

		internal static Type Boolean => Microsoft.JScript.Globals.TypeRefs.Boolean;

		internal static Type Char => Microsoft.JScript.Globals.TypeRefs.Char;

		internal static Type CLSCompliantAttribute => Microsoft.JScript.Globals.TypeRefs.CLSCompliantAttribute;

		internal static Type ContextStaticAttribute => Microsoft.JScript.Globals.TypeRefs.ContextStaticAttribute;

		internal static Type DateTime => Microsoft.JScript.Globals.TypeRefs.DateTime;

		internal static Type Null => Microsoft.JScript.Globals.TypeRefs.DBNull;

		internal static Type Delegate => Microsoft.JScript.Globals.TypeRefs.Delegate;

		internal static Type Decimal => Microsoft.JScript.Globals.TypeRefs.Decimal;

		internal static Type Double => Microsoft.JScript.Globals.TypeRefs.Double;

		internal static Type Enum => Microsoft.JScript.Globals.TypeRefs.Enum;

		internal static Type Exception => Microsoft.JScript.Globals.TypeRefs.Exception;

		internal static Type IConvertible => Microsoft.JScript.Globals.TypeRefs.IConvertible;

		internal static Type IntPtr => Microsoft.JScript.Globals.TypeRefs.IntPtr;

		internal static Type Int16 => Microsoft.JScript.Globals.TypeRefs.Int16;

		internal static Type Int32 => Microsoft.JScript.Globals.TypeRefs.Int32;

		internal static Type Int64 => Microsoft.JScript.Globals.TypeRefs.Int64;

		internal static Type Object => Microsoft.JScript.Globals.TypeRefs.Object;

		internal static Type ObsoleteAttribute => Microsoft.JScript.Globals.TypeRefs.ObsoleteAttribute;

		internal static Type ParamArrayAttribute => Microsoft.JScript.Globals.TypeRefs.ParamArrayAttribute;

		internal static Type RuntimeTypeHandle => Microsoft.JScript.Globals.TypeRefs.RuntimeTypeHandle;

		internal static Type SByte => Microsoft.JScript.Globals.TypeRefs.SByte;

		internal static Type Single => Microsoft.JScript.Globals.TypeRefs.Single;

		internal static Type STAThreadAttribute => Microsoft.JScript.Globals.TypeRefs.STAThreadAttribute;

		internal static Type String => Microsoft.JScript.Globals.TypeRefs.String;

		internal static Type Type => Microsoft.JScript.Globals.TypeRefs.Type;

		internal static Type TypeCode => Microsoft.JScript.Globals.TypeRefs.TypeCode;

		internal static Type UIntPtr => Microsoft.JScript.Globals.TypeRefs.UIntPtr;

		internal static Type UInt16 => Microsoft.JScript.Globals.TypeRefs.UInt16;

		internal static Type UInt32 => Microsoft.JScript.Globals.TypeRefs.UInt32;

		internal static Type UInt64 => Microsoft.JScript.Globals.TypeRefs.UInt64;

		internal static Type ValueType => Microsoft.JScript.Globals.TypeRefs.ValueType;

		internal static Type Void => Microsoft.JScript.Globals.TypeRefs.Void;

		internal static Type IEnumerable => Microsoft.JScript.Globals.TypeRefs.IEnumerable;

		internal static Type IEnumerator => Microsoft.JScript.Globals.TypeRefs.IEnumerator;

		internal static Type IList => Microsoft.JScript.Globals.TypeRefs.IList;

		internal static Type Debugger => Microsoft.JScript.Globals.TypeRefs.Debugger;

		internal static Type DebuggableAttribute => Microsoft.JScript.Globals.TypeRefs.DebuggableAttribute;

		internal static Type DebuggerHiddenAttribute => Microsoft.JScript.Globals.TypeRefs.DebuggerHiddenAttribute;

		internal static Type DebuggerStepThroughAttribute => Microsoft.JScript.Globals.TypeRefs.DebuggerStepThroughAttribute;

		internal static Type DefaultMemberAttribute => Microsoft.JScript.Globals.TypeRefs.DefaultMemberAttribute;

		internal static Type EventInfo => Microsoft.JScript.Globals.TypeRefs.EventInfo;

		internal static Type FieldInfo => Microsoft.JScript.Globals.TypeRefs.FieldInfo;

		internal static Type CompilerGlobalScopeAttribute => Microsoft.JScript.Globals.TypeRefs.CompilerGlobalScopeAttribute;

		internal static Type RequiredAttributeAttribute => Microsoft.JScript.Globals.TypeRefs.RequiredAttributeAttribute;

		internal static Type CoClassAttribute => Microsoft.JScript.Globals.TypeRefs.CoClassAttribute;

		internal static Type IExpando => Microsoft.JScript.Globals.TypeRefs.IExpando;

		internal static Type CodeAccessSecurityAttribute => Microsoft.JScript.Globals.TypeRefs.CodeAccessSecurityAttribute;

		internal static Type AllowPartiallyTrustedCallersAttribute => Microsoft.JScript.Globals.TypeRefs.AllowPartiallyTrustedCallersAttribute;

		internal static Type ArrayOfObject => Microsoft.JScript.Globals.TypeRefs.ArrayOfObject;

		internal static Type ArrayOfString => Microsoft.JScript.Globals.TypeRefs.ArrayOfString;

		internal static Type SystemConvert => Microsoft.JScript.Globals.TypeRefs.SystemConvert;

		internal static Type ReflectionMissing => Microsoft.JScript.Globals.TypeRefs.ReflectionMissing;
	}
	/// <summary>Determines the data types of objects. This class belongs to the abstract syntax tree category.</summary>
	public sealed class Typeof : UnaryOp
	{
		internal Typeof(Context context, AST operand)
			: base(context, operand)
		{
		}

		internal override object Evaluate()
		{
			try
			{
				return JScriptTypeof(operand.Evaluate(), VsaEngine.executeForJSEE);
			}
			catch (JScriptException ex)
			{
				if ((ex.Number & 0xFFFF) == 5009)
				{
					return "undefined";
				}
				throw ex;
			}
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return Typeob.String;
		}

		/// <summary>Determines the data type of the specified object.</summary>
		/// <param name="value">The object to determine the type of.</param>
		/// <returns>The type of <paramref name="value" />.</returns>
		public static string JScriptTypeof(object value)
		{
			return JScriptTypeof(value, checkForDebuggerObject: false);
		}

		internal static string JScriptTypeof(object value, bool checkForDebuggerObject)
		{
			switch (Convert.GetTypeCode(value))
			{
			case TypeCode.Empty:
				return "undefined";
			case TypeCode.DBNull:
				return "object";
			case TypeCode.Object:
				if (value is Missing || value is System.Reflection.Missing)
				{
					return "undefined";
				}
				if (checkForDebuggerObject && value is IDebuggerObject debuggerObject)
				{
					if (!debuggerObject.IsScriptFunction())
					{
						return "object";
					}
					return "function";
				}
				if (!(value is ScriptFunction))
				{
					return "object";
				}
				return "function";
			case TypeCode.Boolean:
				return "boolean";
			case TypeCode.Char:
			case TypeCode.String:
				return "string";
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.Decimal:
				return "number";
			case TypeCode.DateTime:
				return "date";
			default:
				return "unknown";
			}
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (operand is Binding)
			{
				((Binding)operand).TranslateToIL(il, Typeob.Object, calledFromDelete: true);
			}
			else
			{
				operand.TranslateToIL(il, Typeob.Object);
			}
			il.Emit(OpCodes.Call, CompilerGlobals.jScriptTypeofMethod);
			Convert.Emit(this, il, Typeob.String, rtype);
		}
	}
	/// <summary>Provides an implementation of <see cref="M:Microsoft.JScript.TypeReflector.GetMember(System.String,System.Reflection.BindingFlags)" /> that is faster than <see cref="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />.</summary>
	public sealed class TypeReflector : ScriptObject
	{
		private MemberInfo[] defaultMembers;

		private SimpleHashtable staticMembers;

		private SimpleHashtable instanceMembers;

		private MemberInfo[][] memberInfos;

		private ArrayList memberLookupTable;

		internal Type type;

		private object implementsIReflect;

		private object is__ComObject;

		internal uint hashCode;

		internal TypeReflector next;

		private static MemberInfo[] EmptyMembers = new MemberInfo[0];

		private static TRHashtable Table = new TRHashtable();

		internal TypeReflector(Type type)
			: base(null)
		{
			defaultMembers = null;
			ArrayList arrayList = new ArrayList(512);
			int num = 0;
			SimpleHashtable simpleHashtable = new SimpleHashtable(256u);
			MemberInfo[] members = type.GetMembers(BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			foreach (MemberInfo memberInfo in members)
			{
				string name = memberInfo.Name;
				object obj = simpleHashtable[name];
				if (obj == null)
				{
					simpleHashtable[name] = num++;
					arrayList.Add(memberInfo);
					continue;
				}
				int index = (int)obj;
				obj = arrayList[index];
				MemberInfo memberInfo2 = obj as MemberInfo;
				if (memberInfo2 != null)
				{
					MemberInfoList memberInfoList = new MemberInfoList();
					memberInfoList.Add(memberInfo2);
					memberInfoList.Add(memberInfo);
					arrayList[index] = memberInfoList;
				}
				else
				{
					((MemberInfoList)obj).Add(memberInfo);
				}
			}
			staticMembers = simpleHashtable;
			SimpleHashtable simpleHashtable2 = new SimpleHashtable(256u);
			MemberInfo[] members2 = type.GetMembers(BindingFlags.Instance | BindingFlags.Public);
			foreach (MemberInfo memberInfo3 in members2)
			{
				string name2 = memberInfo3.Name;
				object obj2 = simpleHashtable2[name2];
				if (obj2 == null)
				{
					simpleHashtable2[name2] = num++;
					arrayList.Add(memberInfo3);
					continue;
				}
				int index2 = (int)obj2;
				obj2 = arrayList[index2];
				MemberInfo memberInfo4 = obj2 as MemberInfo;
				if (memberInfo4 != null)
				{
					MemberInfoList memberInfoList2 = new MemberInfoList();
					memberInfoList2.Add(memberInfo4);
					memberInfoList2.Add(memberInfo3);
					arrayList[index2] = memberInfoList2;
				}
				else
				{
					((MemberInfoList)obj2).Add(memberInfo3);
				}
			}
			instanceMembers = simpleHashtable2;
			memberLookupTable = arrayList;
			memberInfos = new MemberInfo[num][];
			this.type = type;
			implementsIReflect = null;
			is__ComObject = null;
			hashCode = (uint)type.GetHashCode();
			next = null;
		}

		internal MemberInfo[] GetDefaultMembers()
		{
			MemberInfo[] array = defaultMembers;
			if (array == null)
			{
				array = JSBinder.GetDefaultMembers(type);
				if (array == null)
				{
					array = new MemberInfo[0];
				}
				WrapMembers(defaultMembers = array);
			}
			return array;
		}

		/// <summary>Searches for the specified member, using the specified binding constraints.</summary>
		/// <param name="name">The name of the member to search for.</param>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specify the way in which the search for members and types is conducted by the reflection operation.</param>
		/// <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects that represents the public members that have the specified name, if found; otherwise, an empty array.</returns>
		public override MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
		{
			bool flag = (bindingAttr & BindingFlags.Instance) != 0;
			SimpleHashtable simpleHashtable = (flag ? instanceMembers : staticMembers);
			object obj = simpleHashtable[name];
			if (obj == null)
			{
				if ((bindingAttr & BindingFlags.IgnoreCase) != 0)
				{
					obj = simpleHashtable.IgnoreCaseGet(name);
				}
				if (obj == null)
				{
					if (flag && (bindingAttr & BindingFlags.Static) != 0)
					{
						return GetMember(name, bindingAttr & ~BindingFlags.Instance);
					}
					return EmptyMembers;
				}
			}
			int num = (int)obj;
			MemberInfo[] array = memberInfos[num];
			if (array == null)
			{
				return GetNewMemberArray(name, num);
			}
			return array;
		}

		private MemberInfo[] GetNewMemberArray(string name, int index)
		{
			MemberInfo[] array = null;
			object obj = memberLookupTable[index];
			if (obj == null)
			{
				return memberInfos[index];
			}
			MemberInfo memberInfo = obj as MemberInfo;
			array = ((!(memberInfo != null)) ? ((MemberInfoList)obj).ToArray() : new MemberInfo[1] { memberInfo });
			memberInfos[index] = array;
			memberLookupTable[index] = null;
			WrapMembers(array);
			return array;
		}

		/// <summary>Throws a <see cref="T:Microsoft.JScript.JScriptException" /> exception in all cases.</summary>
		/// <param name="bindingAttr">A bitwise combination of the enumeration values that specify the way in which the search for members and types is conducted by the reflection operation.</param>
		/// <returns>Throws a <see cref="T:Microsoft.JScript.JScriptException" /> exception in all cases.</returns>
		public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
		{
			throw new JScriptException(JSError.InternalError);
		}

		internal static TypeReflector GetTypeReflectorFor(Type type)
		{
			TypeReflector typeReflector = Table[type];
			if (typeReflector != null)
			{
				return typeReflector;
			}
			typeReflector = new TypeReflector(type);
			lock (Table)
			{
				TypeReflector typeReflector2 = Table[type];
				if (typeReflector2 != null)
				{
					return typeReflector2;
				}
				Table[type] = typeReflector;
				return typeReflector;
			}
		}

		internal bool ImplementsIReflect()
		{
			object obj = implementsIReflect;
			if (obj != null)
			{
				return (bool)obj;
			}
			bool flag = typeof(IReflect).IsAssignableFrom(type);
			implementsIReflect = flag;
			return flag;
		}

		internal bool Is__ComObject()
		{
			object obj = is__ComObject;
			if (obj != null)
			{
				return (bool)obj;
			}
			bool flag = type.ToString() == "System.__ComObject";
			is__ComObject = flag;
			return flag;
		}

		private static void WrapMembers(MemberInfo[] members)
		{
			int i = 0;
			for (int num = members.Length; i < num; i++)
			{
				MemberInfo memberInfo = members[i];
				switch (memberInfo.MemberType)
				{
				case MemberTypes.Field:
					members[i] = new JSFieldInfo((FieldInfo)memberInfo);
					break;
				case MemberTypes.Method:
					members[i] = new JSMethodInfo((MethodInfo)memberInfo);
					break;
				case MemberTypes.Property:
					members[i] = new JSPropertyInfo((PropertyInfo)memberInfo);
					break;
				}
			}
		}
	}
	internal sealed class TRHashtable
	{
		private TypeReflector[] table;

		private int count;

		private int threshold;

		internal TypeReflector this[Type type]
		{
			get
			{
				uint hashCode = (uint)type.GetHashCode();
				int num = (int)(hashCode % (uint)table.Length);
				for (TypeReflector typeReflector = table[num]; typeReflector != null; typeReflector = typeReflector.next)
				{
					if (typeReflector.type == type)
					{
						return typeReflector;
					}
				}
				return null;
			}
			set
			{
				if (++count >= threshold)
				{
					Rehash();
				}
				int num = (int)(value.hashCode % (uint)table.Length);
				value.next = table[num];
				table[num] = value;
			}
		}

		internal TRHashtable()
		{
			table = new TypeReflector[511];
			count = 0;
			threshold = 256;
		}

		private void Rehash()
		{
			TypeReflector[] array = table;
			int num = (threshold = array.Length + 1);
			int num2 = num * 2 - 1;
			TypeReflector[] array2 = (table = new TypeReflector[num2]);
			int num3 = num - 1;
			while (num3-- > 0)
			{
				TypeReflector typeReflector = array[num3];
				while (typeReflector != null)
				{
					TypeReflector typeReflector2 = typeReflector;
					typeReflector = typeReflector.next;
					int num4 = (int)(typeReflector2.hashCode % (uint)num2);
					typeReflector2.next = array2[num4];
					array2[num4] = typeReflector2;
				}
			}
		}
	}
	internal sealed class TypeReferences
	{
		private enum TypeReference
		{
			ArgumentsObject,
			ArrayConstructor,
			ArrayObject,
			ArrayWrapper,
			Binding,
			BitwiseBinary,
			BooleanObject,
			BreakOutOfFinally,
			BuiltinFunction,
			ClassScope,
			Closure,
			ContinueOutOfFinally,
			Convert,
			DateObject,
			Empty,
			EnumeratorObject,
			Equality,
			ErrorObject,
			Eval,
			EvalErrorObject,
			Expando,
			FieldAccessor,
			ForIn,
			FunctionDeclaration,
			FunctionExpression,
			FunctionObject,
			FunctionWrapper,
			GlobalObject,
			GlobalScope,
			Globals,
			Hide,
			IActivationObject,
			INeedEngine,
			Import,
			In,
			Instanceof,
			JSError,
			JSFunctionAttribute,
			JSFunctionAttributeEnum,
			JSLocalField,
			JSObject,
			JScriptException,
			LateBinding,
			LenientGlobalObject,
			MathObject,
			MethodInvoker,
			Missing,
			Namespace,
			NotRecommended,
			NumberObject,
			NumericBinary,
			NumericUnary,
			ObjectConstructor,
			Override,
			Package,
			Plus,
			PostOrPrefixOperator,
			RangeErrorObject,
			ReferenceAttribute,
			ReferenceErrorObject,
			RegExpConstructor,
			RegExpObject,
			Relational,
			ReturnOutOfFinally,
			Runtime,
			ScriptFunction,
			ScriptObject,
			ScriptStream,
			SimpleHashtable,
			StackFrame,
			StrictEquality,
			StringObject,
			SyntaxErrorObject,
			Throw,
			Try,
			TypedArray,
			TypeErrorObject,
			Typeof,
			URIErrorObject,
			VBArrayObject,
			With,
			BaseVsaStartup,
			VsaEngine
		}

		private static readonly SimpleHashtable _predefinedTypeTable;

		private Type[] _typeTable;

		private Module _jscriptReferenceModule;

		private const int TypeReferenceStartOfSpecialCases = 81;

		private const int TypeReferenceArrayLength = 83;

		private Module JScriptReferenceModule => _jscriptReferenceModule;

		internal Type ArgumentsObject => GetTypeReference(TypeReference.ArgumentsObject);

		internal Type ArrayConstructor => GetTypeReference(TypeReference.ArrayConstructor);

		internal Type ArrayObject => GetTypeReference(TypeReference.ArrayObject);

		internal Type ArrayWrapper => GetTypeReference(TypeReference.ArrayWrapper);

		internal Type BaseVsaStartup => GetTypeReference(TypeReference.BaseVsaStartup);

		internal Type Binding => GetTypeReference(TypeReference.Binding);

		internal Type BitwiseBinary => GetTypeReference(TypeReference.BitwiseBinary);

		internal Type BooleanObject => GetTypeReference(TypeReference.BooleanObject);

		internal Type BreakOutOfFinally => GetTypeReference(TypeReference.BreakOutOfFinally);

		internal Type BuiltinFunction => GetTypeReference(TypeReference.BuiltinFunction);

		internal Type ClassScope => GetTypeReference(TypeReference.ClassScope);

		internal Type Closure => GetTypeReference(TypeReference.Closure);

		internal Type ContinueOutOfFinally => GetTypeReference(TypeReference.ContinueOutOfFinally);

		internal Type Convert => GetTypeReference(TypeReference.Convert);

		internal Type DateObject => GetTypeReference(TypeReference.DateObject);

		internal Type Empty => GetTypeReference(TypeReference.Empty);

		internal Type EnumeratorObject => GetTypeReference(TypeReference.EnumeratorObject);

		internal Type Equality => GetTypeReference(TypeReference.Equality);

		internal Type ErrorObject => GetTypeReference(TypeReference.ErrorObject);

		internal Type Eval => GetTypeReference(TypeReference.Eval);

		internal Type EvalErrorObject => GetTypeReference(TypeReference.EvalErrorObject);

		internal Type Expando => GetTypeReference(TypeReference.Expando);

		internal Type FieldAccessor => GetTypeReference(TypeReference.FieldAccessor);

		internal Type ForIn => GetTypeReference(TypeReference.ForIn);

		internal Type FunctionDeclaration => GetTypeReference(TypeReference.FunctionDeclaration);

		internal Type FunctionExpression => GetTypeReference(TypeReference.FunctionExpression);

		internal Type FunctionObject => GetTypeReference(TypeReference.FunctionObject);

		internal Type FunctionWrapper => GetTypeReference(TypeReference.FunctionWrapper);

		internal Type GlobalObject => GetTypeReference(TypeReference.GlobalObject);

		internal Type GlobalScope => GetTypeReference(TypeReference.GlobalScope);

		internal Type Globals => GetTypeReference(TypeReference.Globals);

		internal Type Hide => GetTypeReference(TypeReference.Hide);

		internal Type IActivationObject => GetTypeReference(TypeReference.IActivationObject);

		internal Type INeedEngine => GetTypeReference(TypeReference.INeedEngine);

		internal Type Import => GetTypeReference(TypeReference.Import);

		internal Type In => GetTypeReference(TypeReference.In);

		internal Type Instanceof => GetTypeReference(TypeReference.Instanceof);

		internal Type JSError => GetTypeReference(TypeReference.JSError);

		internal Type JSFunctionAttribute => GetTypeReference(TypeReference.JSFunctionAttribute);

		internal Type JSFunctionAttributeEnum => GetTypeReference(TypeReference.JSFunctionAttributeEnum);

		internal Type JSLocalField => GetTypeReference(TypeReference.JSLocalField);

		internal Type JSObject => GetTypeReference(TypeReference.JSObject);

		internal Type JScriptException => GetTypeReference(TypeReference.JScriptException);

		internal Type LateBinding => GetTypeReference(TypeReference.LateBinding);

		internal Type LenientGlobalObject => GetTypeReference(TypeReference.LenientGlobalObject);

		internal Type MathObject => GetTypeReference(TypeReference.MathObject);

		internal Type MethodInvoker => GetTypeReference(TypeReference.MethodInvoker);

		internal Type Missing => GetTypeReference(TypeReference.Missing);

		internal Type Namespace => GetTypeReference(TypeReference.Namespace);

		internal Type NotRecommended => GetTypeReference(TypeReference.NotRecommended);

		internal Type NumberObject => GetTypeReference(TypeReference.NumberObject);

		internal Type NumericBinary => GetTypeReference(TypeReference.NumericBinary);

		internal Type NumericUnary => GetTypeReference(TypeReference.NumericUnary);

		internal Type ObjectConstructor => GetTypeReference(TypeReference.ObjectConstructor);

		internal Type Override => GetTypeReference(TypeReference.Override);

		internal Type Package => GetTypeReference(TypeReference.Package);

		internal Type Plus => GetTypeReference(TypeReference.Plus);

		internal Type PostOrPrefixOperator => GetTypeReference(TypeReference.PostOrPrefixOperator);

		internal Type RangeErrorObject => GetTypeReference(TypeReference.RangeErrorObject);

		internal Type ReferenceAttribute => GetTypeReference(TypeReference.ReferenceAttribute);

		internal Type ReferenceErrorObject => GetTypeReference(TypeReference.ReferenceErrorObject);

		internal Type RegExpConstructor => GetTypeReference(TypeReference.RegExpConstructor);

		internal Type RegExpObject => GetTypeReference(TypeReference.RegExpObject);

		internal Type Relational => GetTypeReference(TypeReference.Relational);

		internal Type ReturnOutOfFinally => GetTypeReference(TypeReference.ReturnOutOfFinally);

		internal Type Runtime => GetTypeReference(TypeReference.Runtime);

		internal Type ScriptFunction => GetTypeReference(TypeReference.ScriptFunction);

		internal Type ScriptObject => GetTypeReference(TypeReference.ScriptObject);

		internal Type ScriptStream => GetTypeReference(TypeReference.ScriptStream);

		internal Type SimpleHashtable => GetTypeReference(TypeReference.SimpleHashtable);

		internal Type StackFrame => GetTypeReference(TypeReference.StackFrame);

		internal Type StrictEquality => GetTypeReference(TypeReference.StrictEquality);

		internal Type StringObject => GetTypeReference(TypeReference.StringObject);

		internal Type SyntaxErrorObject => GetTypeReference(TypeReference.SyntaxErrorObject);

		internal Type Throw => GetTypeReference(TypeReference.Throw);

		internal Type Try => GetTypeReference(TypeReference.Try);

		internal Type TypedArray => GetTypeReference(TypeReference.TypedArray);

		internal Type TypeErrorObject => GetTypeReference(TypeReference.TypeErrorObject);

		internal Type Typeof => GetTypeReference(TypeReference.Typeof);

		internal Type URIErrorObject => GetTypeReference(TypeReference.URIErrorObject);

		internal Type VBArrayObject => GetTypeReference(TypeReference.VBArrayObject);

		internal Type With => GetTypeReference(TypeReference.With);

		internal Type VsaEngine => GetTypeReference(TypeReference.VsaEngine);

		internal Type Array => typeof(Array);

		internal Type Attribute => typeof(Attribute);

		internal Type AttributeUsageAttribute => typeof(AttributeUsageAttribute);

		internal Type Byte => typeof(byte);

		internal Type Boolean => typeof(bool);

		internal Type Char => typeof(char);

		internal Type CLSCompliantAttribute => typeof(CLSCompliantAttribute);

		internal Type ContextStaticAttribute => typeof(ContextStaticAttribute);

		internal Type DateTime => typeof(DateTime);

		internal Type DBNull => typeof(DBNull);

		internal Type Delegate => typeof(Delegate);

		internal Type Decimal => typeof(decimal);

		internal Type Double => typeof(double);

		internal Type Enum => typeof(Enum);

		internal Type Exception => typeof(Exception);

		internal Type IConvertible => typeof(IConvertible);

		internal Type IntPtr => typeof(IntPtr);

		internal Type Int16 => typeof(short);

		internal Type Int32 => typeof(int);

		internal Type Int64 => typeof(long);

		internal Type Object => typeof(object);

		internal Type ObsoleteAttribute => typeof(ObsoleteAttribute);

		internal Type ParamArrayAttribute => typeof(ParamArrayAttribute);

		internal Type RuntimeTypeHandle => typeof(RuntimeTypeHandle);

		internal Type SByte => typeof(sbyte);

		internal Type Single => typeof(float);

		internal Type STAThreadAttribute => typeof(STAThreadAttribute);

		internal Type String => typeof(string);

		internal Type Type => typeof(Type);

		internal Type TypeCode => typeof(TypeCode);

		internal Type UIntPtr => typeof(UIntPtr);

		internal Type UInt16 => typeof(ushort);

		internal Type UInt32 => typeof(uint);

		internal Type UInt64 => typeof(ulong);

		internal Type ValueType => typeof(ValueType);

		internal Type Void => typeof(void);

		internal Type IEnumerable => typeof(IEnumerable);

		internal Type IEnumerator => typeof(IEnumerator);

		internal Type IList => typeof(IList);

		internal Type Debugger => typeof(Debugger);

		internal Type DebuggableAttribute => typeof(DebuggableAttribute);

		internal Type DebuggerHiddenAttribute => typeof(DebuggerHiddenAttribute);

		internal Type DebuggerStepThroughAttribute => typeof(DebuggerStepThroughAttribute);

		internal Type DefaultMemberAttribute => typeof(DefaultMemberAttribute);

		internal Type EventInfo => typeof(EventInfo);

		internal Type FieldInfo => typeof(FieldInfo);

		internal Type CompilerGlobalScopeAttribute => typeof(CompilerGlobalScopeAttribute);

		internal Type RequiredAttributeAttribute => typeof(RequiredAttributeAttribute);

		internal Type CoClassAttribute => typeof(CoClassAttribute);

		internal Type IExpando => typeof(IExpando);

		internal Type CodeAccessSecurityAttribute => typeof(CodeAccessSecurityAttribute);

		internal Type AllowPartiallyTrustedCallersAttribute => typeof(AllowPartiallyTrustedCallersAttribute);

		internal Type ArrayOfObject => typeof(object[]);

		internal Type ArrayOfString => typeof(string[]);

		internal Type SystemConvert => typeof(System.Convert);

		internal Type ReflectionMissing => typeof(System.Reflection.Missing);

		internal MethodInfo constructArrayMethod => ArrayConstructor.GetMethod("ConstructArray");

		internal MethodInfo isMissingMethod => Binding.GetMethod("IsMissing");

		internal ConstructorInfo bitwiseBinaryConstructor => BitwiseBinary.GetConstructor(new Type[1] { Int32 });

		internal MethodInfo evaluateBitwiseBinaryMethod => BitwiseBinary.GetMethod("EvaluateBitwiseBinary");

		internal ConstructorInfo breakOutOfFinallyConstructor => BreakOutOfFinally.GetConstructor(new Type[1] { Int32 });

		internal ConstructorInfo closureConstructor => Closure.GetConstructor(new Type[1] { FunctionObject });

		internal ConstructorInfo continueOutOfFinallyConstructor => ContinueOutOfFinally.GetConstructor(new Type[1] { Int32 });

		internal MethodInfo checkIfDoubleIsIntegerMethod => Convert.GetMethod("CheckIfDoubleIsInteger");

		internal MethodInfo checkIfSingleIsIntegerMethod => Convert.GetMethod("CheckIfSingleIsInteger");

		internal MethodInfo coerce2Method => Convert.GetMethod("Coerce2");

		internal MethodInfo coerceTMethod => Convert.GetMethod("CoerceT");

		internal MethodInfo throwTypeMismatch => Convert.GetMethod("ThrowTypeMismatch");

		internal MethodInfo doubleToBooleanMethod => Convert.GetMethod("ToBoolean", new Type[1] { Double });

		internal MethodInfo toBooleanMethod => Convert.GetMethod("ToBoolean", new Type[2] { Object, Boolean });

		internal MethodInfo toForInObjectMethod => Convert.GetMethod("ToForInObject", new Type[2] { Object, VsaEngine });

		internal MethodInfo toInt32Method => Convert.GetMethod("ToInt32", new Type[1] { Object });

		internal MethodInfo toNativeArrayMethod => Convert.GetMethod("ToNativeArray");

		internal MethodInfo toNumberMethod => Convert.GetMethod("ToNumber", new Type[1] { Object });

		internal MethodInfo toObjectMethod => Convert.GetMethod("ToObject", new Type[2] { Object, VsaEngine });

		internal MethodInfo toObject2Method => Convert.GetMethod("ToObject2", new Type[2] { Object, VsaEngine });

		internal MethodInfo doubleToStringMethod => Convert.GetMethod("ToString", new Type[1] { Double });

		internal MethodInfo toStringMethod => Convert.GetMethod("ToString", new Type[2] { Object, Boolean });

		internal FieldInfo undefinedField => Empty.GetField("Value");

		internal ConstructorInfo equalityConstructor => Equality.GetConstructor(new Type[1] { Int32 });

		internal MethodInfo evaluateEqualityMethod => Equality.GetMethod("EvaluateEquality", new Type[2] { Object, Object });

		internal MethodInfo jScriptEqualsMethod => Equality.GetMethod("JScriptEquals");

		internal MethodInfo jScriptEvaluateMethod1 => Eval.GetMethod("JScriptEvaluate", new Type[2] { Object, VsaEngine });

		internal MethodInfo jScriptEvaluateMethod2 => Eval.GetMethod("JScriptEvaluate", new Type[3] { Object, Object, VsaEngine });

		internal MethodInfo jScriptGetEnumeratorMethod => ForIn.GetMethod("JScriptGetEnumerator");

		internal MethodInfo jScriptFunctionDeclarationMethod => FunctionDeclaration.GetMethod("JScriptFunctionDeclaration");

		internal MethodInfo jScriptFunctionExpressionMethod => FunctionExpression.GetMethod("JScriptFunctionExpression");

		internal FieldInfo contextEngineField => Globals.GetField("contextEngine");

		internal MethodInfo fastConstructArrayLiteralMethod => Globals.GetMethod("ConstructArrayLiteral");

		internal ConstructorInfo globalScopeConstructor => GlobalScope.GetConstructor(new Type[2] { GlobalScope, VsaEngine });

		internal MethodInfo getDefaultThisObjectMethod => IActivationObject.GetMethod("GetDefaultThisObject");

		internal MethodInfo getFieldMethod => IActivationObject.GetMethod("GetField", new Type[2] { String, Int32 });

		internal MethodInfo getGlobalScopeMethod => IActivationObject.GetMethod("GetGlobalScope");

		internal MethodInfo getMemberValueMethod => IActivationObject.GetMethod("GetMemberValue", new Type[2] { String, Int32 });

		internal MethodInfo jScriptImportMethod => Import.GetMethod("JScriptImport");

		internal MethodInfo jScriptInMethod => In.GetMethod("JScriptIn");

		internal MethodInfo getEngineMethod => INeedEngine.GetMethod("GetEngine");

		internal MethodInfo setEngineMethod => INeedEngine.GetMethod("SetEngine");

		internal MethodInfo jScriptInstanceofMethod => Instanceof.GetMethod("JScriptInstanceof");

		internal ConstructorInfo scriptExceptionConstructor => JScriptException.GetConstructor(new Type[1] { JSError });

		internal ConstructorInfo jsFunctionAttributeConstructor => JSFunctionAttribute.GetConstructor(new Type[1] { JSFunctionAttributeEnum });

		internal ConstructorInfo jsLocalFieldConstructor => JSLocalField.GetConstructor(new Type[3] { String, RuntimeTypeHandle, Int32 });

		internal MethodInfo setMemberValue2Method => JSObject.GetMethod("SetMemberValue2", new Type[2] { String, Object });

		internal ConstructorInfo lateBindingConstructor2 => LateBinding.GetConstructor(new Type[2] { String, Object });

		internal ConstructorInfo lateBindingConstructor => LateBinding.GetConstructor(new Type[1] { String });

		internal FieldInfo objectField => LateBinding.GetField("obj");

		internal MethodInfo callMethod => LateBinding.GetMethod("Call", new Type[4] { ArrayOfObject, Boolean, Boolean, VsaEngine });

		internal MethodInfo callValueMethod => LateBinding.GetMethod("CallValue", new Type[6] { Object, Object, ArrayOfObject, Boolean, Boolean, VsaEngine });

		internal MethodInfo callValue2Method => LateBinding.GetMethod("CallValue2", new Type[6] { Object, Object, ArrayOfObject, Boolean, Boolean, VsaEngine });

		internal MethodInfo deleteMethod => LateBinding.GetMethod("Delete");

		internal MethodInfo deleteMemberMethod => LateBinding.GetMethod("DeleteMember");

		internal MethodInfo getNonMissingValueMethod => LateBinding.GetMethod("GetNonMissingValue");

		internal MethodInfo getValue2Method => LateBinding.GetMethod("GetValue2");

		internal MethodInfo setIndexedPropertyValueStaticMethod => LateBinding.GetMethod("SetIndexedPropertyValueStatic");

		internal MethodInfo setValueMethod => LateBinding.GetMethod("SetValue");

		internal FieldInfo missingField => Missing.GetField("Value");

		internal MethodInfo getNamespaceMethod => Namespace.GetMethod("GetNamespace");

		internal ConstructorInfo numericBinaryConstructor => NumericBinary.GetConstructor(new Type[1] { Int32 });

		internal MethodInfo numericbinaryDoOpMethod => NumericBinary.GetMethod("DoOp");

		internal MethodInfo evaluateNumericBinaryMethod => NumericBinary.GetMethod("EvaluateNumericBinary");

		internal ConstructorInfo numericUnaryConstructor => NumericUnary.GetConstructor(new Type[1] { Int32 });

		internal MethodInfo evaluateUnaryMethod => NumericUnary.GetMethod("EvaluateUnary");

		internal MethodInfo constructObjectMethod => ObjectConstructor.GetMethod("ConstructObject");

		internal MethodInfo jScriptPackageMethod => Package.GetMethod("JScriptPackage");

		internal ConstructorInfo plusConstructor => Plus.GetConstructor(new Type[0]);

		internal MethodInfo plusDoOpMethod => Plus.GetMethod("DoOp");

		internal MethodInfo evaluatePlusMethod => Plus.GetMethod("EvaluatePlus");

		internal ConstructorInfo postOrPrefixConstructor => PostOrPrefixOperator.GetConstructor(new Type[1] { Int32 });

		internal MethodInfo evaluatePostOrPrefixOperatorMethod => PostOrPrefixOperator.GetMethod("EvaluatePostOrPrefix");

		internal ConstructorInfo referenceAttributeConstructor => ReferenceAttribute.GetConstructor(new Type[1] { String });

		internal MethodInfo regExpConstructMethod => RegExpConstructor.GetMethod("Construct", new Type[4] { String, Boolean, Boolean, Boolean });

		internal ConstructorInfo relationalConstructor => Relational.GetConstructor(new Type[1] { Int32 });

		internal MethodInfo evaluateRelationalMethod => Relational.GetMethod("EvaluateRelational");

		internal MethodInfo jScriptCompareMethod => Relational.GetMethod("JScriptCompare");

		internal ConstructorInfo returnOutOfFinallyConstructor => ReturnOutOfFinally.GetConstructor(new Type[0]);

		internal MethodInfo doubleToInt64 => Runtime.GetMethod("DoubleToInt64");

		internal MethodInfo uncheckedDecimalToInt64Method => Runtime.GetMethod("UncheckedDecimalToInt64");

		internal FieldInfo engineField => ScriptObject.GetField("engine");

		internal MethodInfo getParentMethod => ScriptObject.GetMethod("GetParent");

		internal MethodInfo writeMethod => ScriptStream.GetMethod("Write");

		internal MethodInfo writeLineMethod => ScriptStream.GetMethod("WriteLine");

		internal ConstructorInfo hashtableCtor => SimpleHashtable.GetConstructor(new Type[1] { UInt32 });

		internal MethodInfo hashtableGetItem => SimpleHashtable.GetMethod("get_Item", new Type[1] { Object });

		internal MethodInfo hashTableGetEnumerator => SimpleHashtable.GetMethod("GetEnumerator", Type.EmptyTypes);

		internal MethodInfo hashtableRemove => SimpleHashtable.GetMethod("Remove", new Type[1] { Object });

		internal MethodInfo hashtableSetItem => SimpleHashtable.GetMethod("set_Item", new Type[2] { Object, Object });

		internal FieldInfo closureInstanceField => StackFrame.GetField("closureInstance");

		internal FieldInfo localVarsField => StackFrame.GetField("localVars");

		internal MethodInfo pushStackFrameForMethod => StackFrame.GetMethod("PushStackFrameForMethod");

		internal MethodInfo pushStackFrameForStaticMethod => StackFrame.GetMethod("PushStackFrameForStaticMethod");

		internal MethodInfo jScriptStrictEqualsMethod => StrictEquality.GetMethod("JScriptStrictEquals", new Type[2] { Object, Object });

		internal MethodInfo jScriptThrowMethod => Throw.GetMethod("JScriptThrow");

		internal MethodInfo jScriptExceptionValueMethod => Try.GetMethod("JScriptExceptionValue");

		internal MethodInfo jScriptTypeofMethod => Typeof.GetMethod("JScriptTypeof");

		internal ConstructorInfo vsaEngineConstructor => VsaEngine.GetConstructor(new Type[0]);

		internal MethodInfo createVsaEngine => VsaEngine.GetMethod("CreateEngine", new Type[0]);

		internal MethodInfo createVsaEngineWithType => VsaEngine.GetMethod("CreateEngineWithType", new Type[1] { RuntimeTypeHandle });

		internal MethodInfo getOriginalArrayConstructorMethod => VsaEngine.GetMethod("GetOriginalArrayConstructor");

		internal MethodInfo getOriginalObjectConstructorMethod => VsaEngine.GetMethod("GetOriginalObjectConstructor");

		internal MethodInfo getOriginalRegExpConstructorMethod => VsaEngine.GetMethod("GetOriginalRegExpConstructor");

		internal MethodInfo popScriptObjectMethod => VsaEngine.GetMethod("PopScriptObject");

		internal MethodInfo pushScriptObjectMethod => VsaEngine.GetMethod("PushScriptObject");

		internal MethodInfo scriptObjectStackTopMethod => VsaEngine.GetMethod("ScriptObjectStackTop");

		internal MethodInfo getLenientGlobalObjectMethod => VsaEngine.GetProperty("LenientGlobalObject").GetGetMethod();

		internal MethodInfo jScriptWithMethod => With.GetMethod("JScriptWith");

		internal ConstructorInfo clsCompliantAttributeCtor => CLSCompliantAttribute.GetConstructor(new Type[1] { Boolean });

		internal MethodInfo getEnumeratorMethod => IEnumerable.GetMethod("GetEnumerator", Type.EmptyTypes);

		internal MethodInfo moveNextMethod => IEnumerator.GetMethod("MoveNext", Type.EmptyTypes);

		internal MethodInfo getCurrentMethod => IEnumerator.GetProperty("Current", Type.EmptyTypes).GetGetMethod();

		internal ConstructorInfo contextStaticAttributeCtor => ContextStaticAttribute.GetConstructor(new Type[0]);

		internal MethodInfo changeTypeMethod => SystemConvert.GetMethod("ChangeType", new Type[2] { Object, TypeCode });

		internal MethodInfo convertCharToStringMethod => SystemConvert.GetMethod("ToString", new Type[1] { Char });

		internal ConstructorInfo dateTimeConstructor => DateTime.GetConstructor(new Type[1] { Int64 });

		internal MethodInfo dateTimeToStringMethod => DateTime.GetMethod("ToString", new Type[0]);

		internal MethodInfo dateTimeToInt64Method => DateTime.GetProperty("Ticks").GetGetMethod();

		internal ConstructorInfo decimalConstructor => Decimal.GetConstructor(new Type[5] { Int32, Int32, Int32, Boolean, Byte });

		internal FieldInfo decimalZeroField => Decimal.GetField("Zero");

		internal MethodInfo decimalCompare => Decimal.GetMethod("Compare", new Type[2] { Decimal, Decimal });

		internal MethodInfo doubleToDecimalMethod => Decimal.GetMethod("op_Explicit", new Type[1] { Double });

		internal MethodInfo int32ToDecimalMethod => Decimal.GetMethod("op_Implicit", new Type[1] { Int32 });

		internal MethodInfo int64ToDecimalMethod => Decimal.GetMethod("op_Implicit", new Type[1] { Int64 });

		internal MethodInfo uint32ToDecimalMethod => Decimal.GetMethod("op_Implicit", new Type[1] { UInt32 });

		internal MethodInfo uint64ToDecimalMethod => Decimal.GetMethod("op_Implicit", new Type[1] { UInt64 });

		internal MethodInfo decimalToDoubleMethod => Decimal.GetMethod("ToDouble", new Type[1] { Decimal });

		internal MethodInfo decimalToInt32Method => Decimal.GetMethod("ToInt32", new Type[1] { Decimal });

		internal MethodInfo decimalToInt64Method => Decimal.GetMethod("ToInt64", new Type[1] { Decimal });

		internal MethodInfo decimalToStringMethod => Decimal.GetMethod("ToString", new Type[0]);

		internal MethodInfo decimalToUInt32Method => Decimal.GetMethod("ToUInt32", new Type[1] { Decimal });

		internal MethodInfo decimalToUInt64Method => Decimal.GetMethod("ToUInt64", new Type[1] { Decimal });

		internal MethodInfo debugBreak => Debugger.GetMethod("Break", new Type[0]);

		internal ConstructorInfo debuggerHiddenAttributeCtor => DebuggerHiddenAttribute.GetConstructor(new Type[0]);

		internal ConstructorInfo debuggerStepThroughAttributeCtor => DebuggerStepThroughAttribute.GetConstructor(new Type[0]);

		internal MethodInfo int32ToStringMethod => Int32.GetMethod("ToString", new Type[0]);

		internal MethodInfo int64ToStringMethod => Int64.GetMethod("ToString", new Type[0]);

		internal MethodInfo equalsMethod => Object.GetMethod("Equals", new Type[1] { Object });

		internal ConstructorInfo defaultMemberAttributeCtor => DefaultMemberAttribute.GetConstructor(new Type[1] { String });

		internal MethodInfo getFieldValueMethod => FieldInfo.GetMethod("GetValue", new Type[1] { Object });

		internal MethodInfo setFieldValueMethod => FieldInfo.GetMethod("SetValue", new Type[2] { Object, Object });

		internal FieldInfo systemReflectionMissingField => ReflectionMissing.GetField("Value");

		internal ConstructorInfo compilerGlobalScopeAttributeCtor => CompilerGlobalScopeAttribute.GetConstructor(new Type[0]);

		internal MethodInfo stringConcatArrMethod => String.GetMethod("Concat", new Type[1] { ArrayOfString });

		internal MethodInfo stringConcat4Method => String.GetMethod("Concat", new Type[4] { String, String, String, String });

		internal MethodInfo stringConcat3Method => String.GetMethod("Concat", new Type[3] { String, String, String });

		internal MethodInfo stringConcat2Method => String.GetMethod("Concat", new Type[2] { String, String });

		internal MethodInfo stringEqualsMethod => String.GetMethod("Equals", new Type[2] { String, String });

		internal MethodInfo stringLengthMethod => String.GetProperty("Length").GetGetMethod();

		internal MethodInfo getMethodMethod => Type.GetMethod("GetMethod", new Type[1] { String });

		internal MethodInfo getTypeMethod => Type.GetMethod("GetType", new Type[1] { String });

		internal MethodInfo getTypeFromHandleMethod => Type.GetMethod("GetTypeFromHandle", new Type[1] { RuntimeTypeHandle });

		internal MethodInfo uint32ToStringMethod => UInt32.GetMethod("ToString", new Type[0]);

		internal MethodInfo uint64ToStringMethod => UInt64.GetMethod("ToString", new Type[0]);

		internal TypeReferences(Module jscriptReferenceModule)
		{
			_jscriptReferenceModule = jscriptReferenceModule;
			_typeTable = new Type[83];
		}

		internal Type GetPredefinedType(string typeName)
		{
			object obj = _predefinedTypeTable[typeName];
			Type type = obj as Type;
			if (type == null && obj is TypeReference)
			{
				type = GetTypeReference((TypeReference)obj);
			}
			return type;
		}

		static TypeReferences()
		{
			_predefinedTypeTable = new SimpleHashtable(34u);
			_predefinedTypeTable["boolean"] = typeof(bool);
			_predefinedTypeTable["byte"] = typeof(byte);
			_predefinedTypeTable["char"] = typeof(char);
			_predefinedTypeTable["decimal"] = typeof(decimal);
			_predefinedTypeTable["double"] = typeof(double);
			_predefinedTypeTable["float"] = typeof(float);
			_predefinedTypeTable["int"] = typeof(int);
			_predefinedTypeTable["long"] = typeof(long);
			_predefinedTypeTable["sbyte"] = typeof(sbyte);
			_predefinedTypeTable["short"] = typeof(short);
			_predefinedTypeTable["void"] = typeof(void);
			_predefinedTypeTable["uint"] = typeof(uint);
			_predefinedTypeTable["ulong"] = typeof(ulong);
			_predefinedTypeTable["ushort"] = typeof(ushort);
			_predefinedTypeTable["ActiveXObject"] = typeof(object);
			_predefinedTypeTable["Boolean"] = typeof(bool);
			_predefinedTypeTable["Number"] = typeof(double);
			_predefinedTypeTable["Object"] = typeof(object);
			_predefinedTypeTable["String"] = typeof(string);
			_predefinedTypeTable["Type"] = typeof(Type);
			_predefinedTypeTable["Array"] = TypeReference.ArrayObject;
			_predefinedTypeTable["Date"] = TypeReference.DateObject;
			_predefinedTypeTable["Enumerator"] = TypeReference.EnumeratorObject;
			_predefinedTypeTable["Error"] = TypeReference.ErrorObject;
			_predefinedTypeTable["EvalError"] = TypeReference.EvalErrorObject;
			_predefinedTypeTable["Function"] = TypeReference.ScriptFunction;
			_predefinedTypeTable["RangeError"] = TypeReference.RangeErrorObject;
			_predefinedTypeTable["ReferenceError"] = TypeReference.ReferenceErrorObject;
			_predefinedTypeTable["RegExp"] = TypeReference.RegExpObject;
			_predefinedTypeTable["SyntaxError"] = TypeReference.SyntaxErrorObject;
			_predefinedTypeTable["TypeError"] = TypeReference.TypeErrorObject;
			_predefinedTypeTable["URIError"] = TypeReference.URIErrorObject;
			_predefinedTypeTable["VBArray"] = TypeReference.VBArrayObject;
		}

		private Type GetTypeReference(TypeReference typeRef)
		{
			Type type = _typeTable[(int)typeRef];
			if (null == type)
			{
				string text = "Microsoft.JScript.";
				switch (typeRef)
				{
				case TypeReference.BaseVsaStartup:
					text = "Microsoft.JScript.Vsa.";
					break;
				case TypeReference.VsaEngine:
					text = "Microsoft.JScript.Vsa.";
					break;
				}
				type = JScriptReferenceModule.GetType(text + System.Enum.GetName(typeof(TypeReference), (int)typeRef));
				_typeTable[(int)typeRef] = type;
			}
			return type;
		}

		internal Type ToReferenceContext(Type type)
		{
			if (InReferenceContext(type))
			{
				return type;
			}
			if (type.IsArray)
			{
				return Microsoft.JScript.Convert.ToType(Microsoft.JScript.TypedArray.ToRankString(type.GetArrayRank()), ToReferenceContext(type.GetElementType()));
			}
			return JScriptReferenceModule.ResolveType(type.MetadataToken, null, null);
		}

		internal IReflect ToReferenceContext(IReflect ireflect)
		{
			if (ireflect is Type)
			{
				return ToReferenceContext((Type)ireflect);
			}
			return ireflect;
		}

		internal MethodInfo ToReferenceContext(MethodInfo method)
		{
			if (method is JSMethod)
			{
				method = ((JSMethod)method).GetMethodInfo(null);
			}
			else if (method is JSMethodInfo)
			{
				method = ((JSMethodInfo)method).method;
			}
			return (MethodInfo)MapMemberInfoToReferenceContext(method);
		}

		internal PropertyInfo ToReferenceContext(PropertyInfo property)
		{
			return (PropertyInfo)MapMemberInfoToReferenceContext(property);
		}

		internal FieldInfo ToReferenceContext(FieldInfo field)
		{
			return (FieldInfo)MapMemberInfoToReferenceContext(field);
		}

		internal ConstructorInfo ToReferenceContext(ConstructorInfo constructor)
		{
			return (ConstructorInfo)MapMemberInfoToReferenceContext(constructor);
		}

		private MemberInfo MapMemberInfoToReferenceContext(MemberInfo member)
		{
			if (InReferenceContext(member.DeclaringType))
			{
				return member;
			}
			return JScriptReferenceModule.ResolveMember(member.MetadataToken);
		}

		internal bool InReferenceContext(Type type)
		{
			if (type == null)
			{
				return true;
			}
			Assembly assembly = type.Assembly;
			if (!assembly.ReflectionOnly && !(assembly != typeof(TypeReferences).Assembly))
			{
				return !JScriptReferenceModule.Assembly.ReflectionOnly;
			}
			return true;
		}

		internal bool InReferenceContext(MemberInfo member)
		{
			if (member == null)
			{
				return true;
			}
			if (member is JSMethod)
			{
				member = ((JSMethod)member).GetMethodInfo(null);
			}
			else if (member is JSMethodInfo)
			{
				member = ((JSMethodInfo)member).method;
			}
			return InReferenceContext(member.DeclaringType);
		}

		internal bool InReferenceContext(IReflect ireflect)
		{
			if (ireflect == null)
			{
				return true;
			}
			if (ireflect is Type)
			{
				return InReferenceContext((Type)ireflect);
			}
			return true;
		}

		internal static Type ToExecutionContext(Type type)
		{
			if (InExecutionContext(type))
			{
				return type;
			}
			return typeof(TypeReferences).Module.ResolveType(type.MetadataToken, null, null);
		}

		internal static IReflect ToExecutionContext(IReflect ireflect)
		{
			if (ireflect is Type)
			{
				return ToExecutionContext((Type)ireflect);
			}
			return ireflect;
		}

		internal static MethodInfo ToExecutionContext(MethodInfo method)
		{
			if (method is JSMethod)
			{
				method = ((JSMethod)method).GetMethodInfo(null);
			}
			else if (method is JSMethodInfo)
			{
				method = ((JSMethodInfo)method).method;
			}
			return (MethodInfo)MapMemberInfoToExecutionContext(method);
		}

		internal static PropertyInfo ToExecutionContext(PropertyInfo property)
		{
			return (PropertyInfo)MapMemberInfoToExecutionContext(property);
		}

		internal static FieldInfo ToExecutionContext(FieldInfo field)
		{
			return (FieldInfo)MapMemberInfoToExecutionContext(field);
		}

		internal static ConstructorInfo ToExecutionContext(ConstructorInfo constructor)
		{
			return (ConstructorInfo)MapMemberInfoToExecutionContext(constructor);
		}

		private static MemberInfo MapMemberInfoToExecutionContext(MemberInfo member)
		{
			if (InExecutionContext(member.DeclaringType))
			{
				return member;
			}
			return typeof(TypeReferences).Module.ResolveMember(member.MetadataToken);
		}

		internal static bool InExecutionContext(Type type)
		{
			if (type == null)
			{
				return true;
			}
			Assembly assembly = type.Assembly;
			if (assembly.ReflectionOnly)
			{
				return assembly.Location != typeof(TypeReferences).Assembly.Location;
			}
			return true;
		}

		internal static object GetDefaultParameterValue(ParameterInfo parameter)
		{
			if (parameter.GetType().Assembly == typeof(TypeReferences).Assembly || !parameter.Member.DeclaringType.Assembly.ReflectionOnly)
			{
				return parameter.DefaultValue;
			}
			return parameter.RawDefaultValue;
		}

		internal static object GetConstantValue(FieldInfo field)
		{
			if (field.GetType().Assembly == typeof(TypeReferences).Assembly || !field.DeclaringType.Assembly.ReflectionOnly)
			{
				return field.GetValue(null);
			}
			Type fieldType = field.FieldType;
			object rawConstantValue = field.GetRawConstantValue();
			if (fieldType.IsEnum)
			{
				return MetadataEnumValue.GetEnumValue(fieldType, rawConstantValue);
			}
			return rawConstantValue;
		}
	}
	/// <summary>Represents the base class for classes that perform operations on single operands, such as <see cref="T:Microsoft.JScript.Typeof" /> and <see cref="T:Microsoft.JScript.PostOrPrefixOperator" />. This class belongs to the abstract syntax tree category.</summary>
	public abstract class UnaryOp : AST
	{
		/// <summary>Represents the operand.</summary>
		protected AST operand;

		internal UnaryOp(Context context, AST operand)
			: base(context)
		{
			this.operand = operand;
		}

		internal override void CheckIfOKToUseInSuperConstructorCall()
		{
			operand.CheckIfOKToUseInSuperConstructorCall();
		}

		internal override AST PartiallyEvaluate()
		{
			operand = operand.PartiallyEvaluate();
			if (operand is ConstantWrapper)
			{
				try
				{
					return new ConstantWrapper(Evaluate(), context);
				}
				catch (JScriptException ex)
				{
					context.HandleError((JSError)(ex.ErrorNumber & 0xFFFF));
					return this;
				}
				catch
				{
					context.HandleError(JSError.TypeMismatch);
					return this;
				}
			}
			return this;
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			operand.TranslateToILInitializer(il);
		}
	}
	/// <summary>Represents a Uniform Resource Identifier (URI) error. For example, a URI error can occur when you try to encode or decode a URI.</summary>
	public sealed class URIErrorObject : ErrorObject
	{
		internal URIErrorObject(ErrorPrototype parent, object[] args)
			: base(parent, args)
		{
		}

		internal URIErrorObject(ErrorPrototype parent, object e)
			: base(parent, e)
		{
		}
	}
	internal sealed class VariableDeclaration : AST
	{
		internal Lookup identifier;

		private TypeExpression type;

		internal AST initializer;

		internal JSVariableField field;

		private Completion completion;

		internal VariableDeclaration(Context context, Lookup identifier, TypeExpression type, AST initializer, FieldAttributes attributes, CustomAttributeList customAttributes)
			: base(context)
		{
			if (initializer != null)
			{
				base.context.UpdateWith(initializer.context);
			}
			else if (type != null)
			{
				base.context.UpdateWith(type.context);
			}
			this.identifier = identifier;
			this.type = type;
			this.initializer = initializer;
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			string text = this.identifier.ToString();
			if (scriptObject is ClassScope)
			{
				if (text == ((ClassScope)scriptObject).name)
				{
					identifier.context.HandleError(JSError.CannotUseNameOfClass);
					text += " var";
				}
			}
			else if (attributes != 0)
			{
				base.context.HandleError(JSError.NotInsideClass);
				attributes = FieldAttributes.Public;
			}
			else
			{
				attributes |= FieldAttributes.Public;
			}
			FieldInfo localField = ((IActivationObject)scriptObject).GetLocalField(text);
			if (localField != null)
			{
				if (localField.IsLiteral || scriptObject is ClassScope || type != null)
				{
					identifier.context.HandleError(JSError.DuplicateName, treatAsError: true);
				}
				this.type = (type = null);
			}
			if (scriptObject is ActivationObject)
			{
				if (localField == null || localField is JSVariableField)
				{
					field = ((ActivationObject)scriptObject).AddFieldOrUseExistingField(this.identifier.ToString(), Missing.Value, attributes);
				}
				else
				{
					field = ((ActivationObject)scriptObject).AddNewField(this.identifier.ToString(), null, attributes);
				}
			}
			else
			{
				field = ((StackFrame)scriptObject).AddNewField(this.identifier.ToString(), null, attributes | FieldAttributes.Static);
			}
			field.type = type;
			field.customAttributes = customAttributes;
			field.originalContext = context;
			if (field is JSLocalField)
			{
				((JSLocalField)field).debugOn = this.identifier.context.document.debugOn;
			}
			completion = new Completion();
		}

		internal override object Evaluate()
		{
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			object value = null;
			if (initializer != null)
			{
				value = initializer.Evaluate();
			}
			if (type != null)
			{
				value = Convert.Coerce(value, type);
			}
			else
			{
				while (scriptObject is BlockScope)
				{
					scriptObject = scriptObject.GetParent();
				}
				if (scriptObject is WithObject)
				{
					identifier.SetWithValue((WithObject)scriptObject, value);
				}
				while (scriptObject is WithObject || scriptObject is BlockScope)
				{
					scriptObject = scriptObject.GetParent();
				}
				if (initializer == null && !(field.value is Missing))
				{
					completion.value = field.value;
					return completion;
				}
			}
			field.SetValue(scriptObject, completion.value = value);
			return completion;
		}

		internal override AST PartiallyEvaluate()
		{
			AST aST = (identifier = (Lookup)identifier.PartiallyEvaluateAsReference());
			if (type != null)
			{
				field.type = (type = (TypeExpression)type.PartiallyEvaluate());
			}
			else if (initializer == null && !(field is JSLocalField) && field.value is Missing)
			{
				aST.context.HandleError(JSError.VariableLeftUninitialized);
				field.type = (type = new TypeExpression(new ConstantWrapper(Typeob.Object, aST.context)));
			}
			if (initializer != null)
			{
				if (field.IsStatic)
				{
					ScriptObject scriptObject = base.Engine.ScriptObjectStackTop();
					ClassScope classScope = null;
					while (scriptObject != null && (classScope = scriptObject as ClassScope) == null)
					{
						scriptObject = scriptObject.GetParent();
					}
					if (classScope != null)
					{
						classScope.inStaticInitializerCode = true;
					}
					initializer = initializer.PartiallyEvaluate();
					if (classScope != null)
					{
						classScope.inStaticInitializerCode = false;
					}
				}
				else
				{
					initializer = initializer.PartiallyEvaluate();
				}
				aST.SetPartialValue(initializer);
			}
			if (field != null && field.customAttributes != null)
			{
				field.customAttributes.PartiallyEvaluate();
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			if (initializer != null)
			{
				if (context.document.debugOn && initializer.context != null)
				{
					context.EmitLineInfo(il);
				}
				Lookup lookup = identifier;
				lookup.TranslateToILPreSet(il, doBoth: true);
				lookup.TranslateToILSet(il, doBoth: true, initializer);
			}
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			if (type != null)
			{
				type.TranslateToILInitializer(il);
			}
			if (initializer != null)
			{
				initializer.TranslateToILInitializer(il);
			}
		}

		internal override Context GetFirstExecutableContext()
		{
			if (initializer == null)
			{
				return null;
			}
			return context;
		}
	}
	/// <summary>Represents a prototype-based object that is defined by a constructor function. This class belongs to the built-in object model category.</summary>
	public sealed class VBArrayConstructor : ScriptFunction
	{
		internal static readonly VBArrayConstructor ob = new VBArrayConstructor();

		private VBArrayPrototype originalPrototype;

		internal VBArrayConstructor()
			: base(FunctionPrototype.ob, "VBArray", 1)
		{
			originalPrototype = VBArrayPrototype.ob;
			VBArrayPrototype._constructor = this;
			proto = VBArrayPrototype.ob;
		}

		internal VBArrayConstructor(LenientFunctionPrototype parent, LenientVBArrayPrototype prototypeProp)
			: base(parent, "VBArray", 1)
		{
			originalPrototype = prototypeProp;
			prototypeProp.constructor = this;
			proto = prototypeProp;
			noExpando = false;
		}

		internal override object Call(object[] args, object thisob)
		{
			return null;
		}

		internal override object Construct(object[] args)
		{
			return CreateInstance(args);
		}

		internal VBArrayObject Construct()
		{
			return new VBArrayObject(originalPrototype, null);
		}

		/// <summary>Creates an instance of the prototype-based object, passing in the specified arguments.</summary>
		/// <param name="args">The arguments to pass to the constructor.</param>
		/// <returns>An instance of the object.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasVarArgs)]
		public new object CreateInstance(params object[] args)
		{
			if (args.Length < 1 || !typeof(Array).IsAssignableFrom(args[0].GetType()))
			{
				throw new JScriptException(JSError.VBArrayExpected);
			}
			return new VBArrayObject(originalPrototype, (Array)args[0]);
		}
	}
	/// <summary>Represents a VBArray object. This class belongs to the built-in object model category.</summary>
	public class VBArrayObject : JSObject
	{
		private Array array;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.VBArrayObject" /> class.</summary>
		/// <param name="parent">The parent of the object.</param>
		/// <param name="array">The underlying array that the class represents.</param>
		public VBArrayObject(VBArrayPrototype parent, Array array)
			: base(parent)
		{
			this.array = array;
			noExpando = false;
		}

		internal virtual int dimensions()
		{
			return array.Rank;
		}

		internal virtual object getItem(object[] args)
		{
			if (args == null || args.Length == 0)
			{
				throw new JScriptException(JSError.TooFewParameters);
			}
			if (args.Length == 1)
			{
				return this.array.GetValue(Convert.ToInt32(args[0]));
			}
			if (args.Length == 2)
			{
				return this.array.GetValue(Convert.ToInt32(args[0]), Convert.ToInt32(args[1]));
			}
			if (args.Length == 3)
			{
				return this.array.GetValue(Convert.ToInt32(args[0]), Convert.ToInt32(args[1]), Convert.ToInt32(args[2]));
			}
			int num = args.Length;
			int[] array = new int[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = Convert.ToInt32(args[i]);
			}
			return this.array.GetValue(array);
		}

		internal virtual int lbound(object dimension)
		{
			int dimension2 = Convert.ToInt32(dimension);
			return array.GetLowerBound(dimension2);
		}

		internal virtual ArrayObject toArray(VsaEngine engine)
		{
			IList list = array;
			ArrayObject arrayObject = engine.GetOriginalArrayConstructor().Construct();
			uint num = 0u;
			int count = list.Count;
			IEnumerator enumerator = list.GetEnumerator();
			arrayObject.length = count;
			while (enumerator.MoveNext())
			{
				arrayObject.SetValueAtIndex(num++, enumerator.Current);
			}
			return arrayObject;
		}

		internal virtual int ubound(object dimension)
		{
			int dimension2 = Convert.ToInt32(dimension);
			return array.GetUpperBound(dimension2);
		}
	}
	/// <summary>Provides static methods and properties for <see cref="T:Microsoft.JScript.VBArrayObject" /> objects. All methods of this class are called by passing in a reference to the object that is requesting access to the method. This class belongs to the built-in object model category.</summary>
	public class VBArrayPrototype : JSObject
	{
		internal static readonly VBArrayPrototype ob = new VBArrayPrototype(FunctionPrototype.ob, ObjectPrototype.ob);

		internal static VBArrayConstructor _constructor;

		/// <summary>Gets a reference to a prototype-based object that is using this prototype.</summary>
		/// <returns>A reference to a prototype-based object.</returns>
		public static VBArrayConstructor constructor => _constructor;

		internal VBArrayPrototype(FunctionPrototype funcprot, ObjectPrototype parent)
			: base(parent)
		{
		}

		/// <summary>Determines the number of dimensions in the specified array.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <returns>The number of dimensions in <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.VBArray_dimensions)]
		public static int dimensions(object thisob)
		{
			if (thisob is VBArrayObject)
			{
				return ((VBArrayObject)thisob).dimensions();
			}
			throw new JScriptException(JSError.VBArrayExpected);
		}

		/// <summary>Gets the value at the specified position in the specified array.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="args">An array that represents the indexes of each dimension that specifies the position of the element to get.</param>
		/// <returns>The value at the specified position in <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasVarArgs, JSBuiltin.VBArray_getItem)]
		public static object getItem(object thisob, params object[] args)
		{
			if (thisob is VBArrayObject)
			{
				return ((VBArrayObject)thisob).getItem(args);
			}
			throw new JScriptException(JSError.VBArrayExpected);
		}

		/// <summary>Gets the lower bound of the specified dimension in the specified array.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dimension">The dimension whose lower bound is determined.</param>
		/// <returns>The lower bound of <paramref name="dimension" /> in <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.VBArray_lbound)]
		public static int lbound(object thisob, object dimension)
		{
			if (thisob is VBArrayObject)
			{
				return ((VBArrayObject)thisob).lbound(dimension);
			}
			throw new JScriptException(JSError.VBArrayExpected);
		}

		/// <summary>Converts a <see cref="T:Microsoft.JScript.VBArrayObject" /> object to an <see cref="T:Microsoft.JScript.ArrayObject" /> object.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>
		///   <paramref name="thisob" /> expressed as an <see cref="T:Microsoft.JScript.ArrayObject" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject | JSFunctionAttributeEnum.HasEngine, JSBuiltin.VBArray_toArray)]
		public static ArrayObject toArray(object thisob, VsaEngine engine)
		{
			if (thisob is VBArrayObject)
			{
				return ((VBArrayObject)thisob).toArray(engine);
			}
			throw new JScriptException(JSError.VBArrayExpected);
		}

		/// <summary>Gets the upper bound of the specified dimension in the specified array.</summary>
		/// <param name="thisob">The object that this method is acting upon.</param>
		/// <param name="dimension">The dimension whose upper bound is determined.</param>
		/// <returns>The upper bound of <paramref name="dimension" /> in <paramref name="thisob" />.</returns>
		[JSFunction(JSFunctionAttributeEnum.HasThisObject, JSBuiltin.VBArray_ubound)]
		public static int ubound(object thisob, object dimension)
		{
			if (thisob is VBArrayObject)
			{
				return ((VBArrayObject)thisob).ubound(dimension);
			}
			throw new JScriptException(JSError.VBArrayExpected);
		}
	}
	/// <summary>Indicates that a method or field overrides a method or field in a base class.</summary>
	[AttributeUsage(AttributeTargets.Method | AttributeTargets.Field)]
	public class Override : Attribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Override" /> class.</summary>
		public Override()
		{
		}
	}
	/// <summary>Indicates that a method or field hides a method or field in a base class.</summary>
	[AttributeUsage(AttributeTargets.Method | AttributeTargets.Field)]
	public class Hide : Attribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Hide" /> attribute class.</summary>
		public Hide()
		{
		}
	}
	internal sealed class VoidOp : UnaryOp
	{
		internal VoidOp(Context context, AST operand)
			: base(context, operand)
		{
		}

		internal override object Evaluate()
		{
			operand.Evaluate();
			return null;
		}

		internal override IReflect InferType(JSField inference_target)
		{
			return Typeob.Empty;
		}

		internal override AST PartiallyEvaluate()
		{
			return new ConstantWrapper(null, context);
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			operand.TranslateToIL(il, Typeob.Object);
			if (rtype != Typeob.Void)
			{
				il.Emit(OpCodes.Ldsfld, CompilerGlobals.undefinedField);
				Convert.Emit(this, il, Typeob.Object, rtype);
			}
			else
			{
				il.Emit(OpCodes.Pop);
			}
		}
	}
	/// <summary>Defines extra functionality that is needed by an IActiveScript host. Implemented by the <see cref="T:Microsoft.JScript.Vsa.VsaEngine" /> engine.</summary>
	[Guid("BFF6C97F-0705-4394-88B8-A03A4B8B4CD7")]
	[ComVisible(true)]
	public interface IEngine2
	{
		/// <summary>When implemented in a class, gets the compiled assembly that is produced by the compilation step.</summary>
		/// <returns>The compiled assembly.</returns>
		Assembly GetAssembly();

		/// <summary>When implemented in a class, runs the compiled code in the specified application domain. This is not implemented in JScript because managed engines do not support running code in user-provided application domains.</summary>
		/// <param name="domain">The application domain in which to run the compiled code.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void Run(AppDomain domain);

		/// <summary>When implemented in a class, triggers compilation of all the state currently in the engine. All references, code items, host items, and resources are run through the compiler.</summary>
		/// <returns>
		///   <see langword="true" /> if the compilation was successful, otherwise, <see langword="false" />.</returns>
		bool CompileEmpty();

		/// <summary>When implemented in a class, runs the compiled code in the current <see cref="T:System.AppDomain" />.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void RunEmpty();

		/// <summary>When implemented in a class, directs the engine to unhook event sources from event handlers. This is not implemented in JScript.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void DisconnectEvents();

		/// <summary>When implemented in a class, communicates to the engine that it can connect any registered event sources that have events to any global event handlers. This is not implemented in JScript.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void ConnectEvents();

		/// <summary>When implemented in a class, specifies the name of an item that is marked as an event source, so that the <see cref="M:Microsoft.JScript.IEngine2.ConnectEvents" /> method can determine which events to connect. This is not implemented in JScript.</summary>
		/// <param name="name">The name of an added item that provides events.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void RegisterEventSource(string name);

		/// <summary>When implemented in a class, calls <see cref="M:System.Threading.Thread.Abort" /> on the thread that is running the script code.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void Interrupt();

		/// <summary>When implemented in a class, initializes the <see cref="T:Microsoft.JScript.Vsa.VsaEngine" />.</summary>
		/// <param name="rootMoniker">The root moniker of the script engine. For more information, see <see cref="P:Microsoft.JScript.Vsa.IJSVsaEngine.RootMoniker" />.</param>
		/// <param name="site">The host-implemented <see cref="T:Microsoft.JScript.Vsa.IJSVsaSite" /> object that is used by the script engine to communicate with the host. For more information, see <see cref="P:Microsoft.JScript.Vsa.IJSVsaEngine.Site" />.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void InitVsaEngine(string rootMoniker, IJSVsaSite site);

		/// <summary>When implemented in a class, gets the global scope object.</summary>
		/// <returns>The global scope object.</returns>
		IVsaScriptScope GetGlobalScope();

		/// <summary>When implemented in a class, gets the code module from the compiled assembly.</summary>
		/// <returns>The code module from the compiled assembly.</returns>
		Module GetModule();

		/// <summary>When implemented in a class, creates a new identical engine that runs in a new application domain, with the same compiled state and named items. This is not implemented in JScript.</summary>
		/// <param name="domain">The application domain in which to create the new engine.</param>
		/// <returns>The new engine.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		IJSVsaEngine Clone(AppDomain domain);

		/// <summary>When implemented in a class, this method is called by the debugger when it has to reset the engine to a clean state before evaluating a new expression. The method resets the added items and the global scope back to their original state.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void Restart();
	}
	/// <summary>Defines methods that are used by the <see cref="T:Microsoft.JScript.Vsa.VsaEngine" /> for name resolution. Provides extra functionality that is needed by an IActiveScript host.</summary>
	[Guid("BFF6C980-0705-4394-88B8-A03A4B8B4CD7")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[ComVisible(true)]
	public interface ISite2
	{
		/// <summary>When implemented in a class, gets the parent object hierarchy for the specified object.</summary>
		/// <param name="obj">An <see cref="T:System.Reflection.IReflect" /> object to get the parent hierarchy of.</param>
		/// <returns>An array that contains the parent objects of <paramref name="obj" />.</returns>
		object[] GetParentChain(object obj);
	}
	/// <summary>Defines methods that set the <see langword="this" /> value that is associated with the global scope. Used by the <see cref="T:Microsoft.JScript.Vsa.VsaEngine" />.</summary>
	[Guid("59447635-3E26-4873-BF26-05F173B80F5E")]
	[ComVisible(true)]
	public interface IDebugScriptScope
	{
		/// <summary>When implemented in a class, sets the <see langword="this" /> value that is associated with the global scope.</summary>
		/// <param name="thisValue">The value that is used as the <see langword="this" /> object for the global scope.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void SetThisValue([MarshalAs(UnmanagedType.Interface)] object thisValue);
	}
	/// <summary>Defines methods that evaluate expressions and parse strings. This interface is typically implemented by an object that represents a code block, and it is typically called by a debugger. This interface provides extra functionality that is needed by an IActiveScript host.</summary>
	[Guid("6DFE759A-CB8B-4ca0-A973-1D04E0BF0B53")]
	[ComVisible(true)]
	public interface IDebugVsaScriptCodeItem
	{
		/// <summary>When implemented in a class, evaluates the block, expression, or statement represented by the code item and returns the value. It is typically called by a debugger that needs to evaluate an expression (in a Watch window, for example). For expressions, the value is the result of the expression. For blocks and statements, the resulting expression is the last expression calculated by the block or statement.</summary>
		/// <returns>A value that represents the evaluation of the statement, expression, or block.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		[return: MarshalAs(UnmanagedType.Interface)]
		object Evaluate();

		/// <summary>When implemented in a class, parses strings and returns the parsed-out information. This method is typically called by a debugger that needs to parse information about a breakpoint that is represented as a <see langword="string" />. The debugger might have a breakpoint typed in by the user in the form functionname-arguments-ILoffset. A named breakpoint string can have a complex format, for example, <c>F.B(C.D[], int, arg : double ) : C.Abc + 123.</c> The parameter list is optional, as is the IL offset.</summary>
		/// <param name="input">A well-formed named breakpoint string giving a function, optional argument list, and optional IL offset.</param>
		/// <param name="functionName">Out parameter returning the name of the function parsed out of the input string, or the empty string if the input string is not well formed.</param>
		/// <param name="nargs">Out parameter returning the number of arguments in the optional argument list. Returns zero if there is no arguments list or if the string is not well formed.</param>
		/// <param name="arguments">Out parameter returning a space-separated list of the names of the types of all the arguments in the arguments list, or an empty string if the arguments list was missing or the input string was not well formed.</param>
		/// <param name="returnType">Out parameter returning a string containing the return type of the function named in the input, or the empty string if the return type was missing or the input string was not well formed.</param>
		/// <param name="offset">Unsigned long integer giving the IL offset from the input string, or zero if there was no IL offset or the string was not well formed.</param>
		/// <returns>
		///   <see langword="true" /> if the named breakpoint is successfully parsed; otherwise, <see langword="false" />.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		bool ParseNamedBreakPoint(string input, out string functionName, out int nargs, out string arguments, out string returnType, out ulong offset);
	}
	/// <summary>Extends the <see cref="T:Microsoft.JScript.Vsa.JSVsaItemType" /> enumeration. Provides extra functionality that is needed by an IActiveScript host.</summary>
	[Guid("581AD3D9-2BAA-3770-B92B-38607E1B463A")]
	[ComVisible(true)]
	public enum VSAITEMTYPE2
	{
		/// <summary>Specifies none. This is the default value.</summary>
		None = 0,
		/// <summary>Specifies a host object.</summary>
		HOSTOBJECT = 16,
		/// <summary>Specifies the scope.</summary>
		HOSTSCOPE = 17,
		/// <summary>Specifies both the scope and the object.</summary>
		HOSTSCOPEANDOBJECT = 18,
		/// <summary>Specifies the script scope.</summary>
		SCRIPTSCOPE = 19,
		/// <summary>Specifies a script block. This applies to an <see cref="T:Microsoft.JScript.IVsaScriptCodeItem" />.</summary>
		SCRIPTBLOCK = 20,
		/// <summary>Specifies a single statement. This applies to an <see cref="T:Microsoft.JScript.IVsaScriptCodeItem" />.</summary>
		STATEMENT = 21,
		/// <summary>Specifies an expression. This applies to an <see cref="T:Microsoft.JScript.IVsaScriptCodeItem" />.</summary>
		EXPRESSION = 22
	}
	/// <summary>Defines methods for resolving scope. The global scope object of the <see cref="T:Microsoft.JScript.Vsa.VsaEngine" /> implements this interface.</summary>
	[Guid("ED4BAE22-2F3C-419a-B487-CF869E716B95")]
	[ComVisible(true)]
	public interface IVsaScriptScope : IJSVsaItem
	{
		/// <summary>When implemented in a class, gets a reference to the parent object.</summary>
		/// <returns>The parent scope.</returns>
		IVsaScriptScope Parent { get; }

		/// <summary>When implemented in a class, adds an item to the scope.</summary>
		/// <param name="itemName">The name of the item.</param>
		/// <param name="type">One of the enumeration values. Specifies the type of the item to add.</param>
		/// <returns>The new item, if it is successfully added.</returns>
		IJSVsaItem AddItem(string itemName, JSVsaItemType type);

		/// <summary>When implemented in a class, gets the item from the scope that is designated by the specified name.</summary>
		/// <param name="itemName">The name of the item to get.</param>
		/// <returns>The item that is named <paramref name="itemName" />.</returns>
		IJSVsaItem GetItem(string itemName);

		/// <summary>When implemented in a class, removes the item that is designated by the specified name from the scope.</summary>
		/// <param name="itemName">The name of the item to remove.</param>
		void RemoveItem(string itemName);

		/// <summary>When implemented in a class, removes the specified <see cref="T:Microsoft.JScript.Vsa.IJSVsaItem" /> object from the scope.</summary>
		/// <param name="item">The item to remove.</param>
		void RemoveItem(IJSVsaItem item);

		/// <summary>When implemented in a class, gets the number of items in the scope.</summary>
		/// <returns>The number of items in the scope.</returns>
		int GetItemCount();

		/// <summary>When implemented in a class, gets the item from the scope that is designated by the specified index value.</summary>
		/// <param name="index">The index of the item to get.</param>
		/// <returns>The item at <paramref name="index" />.</returns>
		IJSVsaItem GetItemAtIndex(int index);

		/// <summary>When implemented in a class, removes the item that is designated by the specified index value from the scope.</summary>
		/// <param name="index">The index of the item to remove.</param>
		void RemoveItemAtIndex(int index);

		/// <summary>When implemented in a class, gets a reference to the global scope.</summary>
		/// <returns>A reference to the global scope.</returns>
		object GetObject();

		/// <summary>When implemented in a class, adds an item to the scope. The <see cref="T:Microsoft.JScript.Vsa.VsaEngine" /> must be running to use this method.</summary>
		/// <param name="itemName">The name of the item.</param>
		/// <param name="type">One of the enumeration values. Specifies the type of the item to add.</param>
		/// <returns>The new item, if it is successfully added.</returns>
		IJSVsaItem CreateDynamicItem(string itemName, JSVsaItemType type);
	}
	/// <summary>Defines extra functionality that is needed by an IActiveScript host.</summary>
	[Guid("E0C0FFE8-7eea-4ee5-b7e4-0080c7eb0b74")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[ComVisible(true)]
	public interface IVsaScriptCodeItem : IJSVsaCodeItem, IJSVsaItem
	{
		/// <summary>When implemented in a class, gets or sets the line number where this code starts.</summary>
		/// <returns>The line number where this code starts.</returns>
		int StartLine { get; set; }

		/// <summary>When implemented in a class, gets or sets the column number in the line where this code starts.</summary>
		/// <returns>The column number where this code starts.</returns>
		int StartColumn { get; set; }

		/// <summary>When implemented in a class, compiles and runs this code.</summary>
		/// <returns>The return value from running the code, if there is any; otherwise, null.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		object Execute();
	}
	/// <summary>Defines extra functionality that is needed by an active script host.</summary>
	[Guid("D1A19408-BB6B-43eb-BB6F-E7CF6AF047D7")]
	[ComVisible(true)]
	public interface IDefineEvent
	{
		/// <summary>Used by an active script host to define an event.</summary>
		/// <param name="code">The code that contains the event.</param>
		/// <param name="startLine">The line number where the code starts.</param>
		/// <returns>The event, if it was successfully added.</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		object AddEvent(string code, int startLine);
	}
	/// <summary>Defines properties to obtain information about errors. This interface provides extra functionality that is needed by an IActiveScript host.</summary>
	[Guid("DC3691BC-F188-4b67-8338-326671E0F3F6")]
	[ComVisible(true)]
	public interface IVsaFullErrorInfo : IJSVsaError
	{
		/// <summary>When implemented in a class, gets the end line of the code in which an error occurred.</summary>
		/// <returns>The end line of the code in which an error occurred.</returns>
		int EndLine { get; }
	}
	internal sealed class VsaHostObject : VsaItem, IJSVsaGlobalItem, IJSVsaItem
	{
		private object hostObject;

		internal bool exposeMembers;

		internal bool isVisible;

		private bool exposed;

		private bool compiled;

		private VsaScriptScope scope;

		private FieldInfo field;

		private string typeString;

		public bool ExposeMembers
		{
			get
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				return exposeMembers;
			}
			set
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				exposeMembers = value;
			}
		}

		internal FieldInfo Field
		{
			get
			{
				JSVariableField jSVariableField = field as JSVariableField;
				if (jSVariableField != null)
				{
					return (FieldInfo)jSVariableField.GetMetaData();
				}
				return field;
			}
		}

		private VsaScriptScope Scope
		{
			get
			{
				if (scope == null)
				{
					scope = (VsaScriptScope)engine.GetGlobalScope();
				}
				return scope;
			}
		}

		public string TypeString
		{
			get
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				return typeString;
			}
			set
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				typeString = value;
				isDirty = true;
				engine.IsDirty = true;
			}
		}

		internal VsaHostObject(VsaEngine engine, string itemName, JSVsaItemType type)
			: this(engine, itemName, type, null)
		{
		}

		internal VsaHostObject(VsaEngine engine, string itemName, JSVsaItemType type, VsaScriptScope scope)
			: base(engine, itemName, type, JSVsaItemFlag.None)
		{
			hostObject = null;
			exposeMembers = false;
			isVisible = false;
			exposed = false;
			compiled = false;
			this.scope = scope;
			field = null;
			typeString = "System.Object";
		}

		public object GetObject()
		{
			if (engine == null)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			if (hostObject == null)
			{
				if (engine.Site == null)
				{
					throw new JSVsaException(JSVsaError.SiteNotSet);
				}
				hostObject = engine.Site.GetGlobalInstance(name);
			}
			return hostObject;
		}

		private void AddNamedItemNamespace()
		{
			GlobalScope globalScope = (GlobalScope)Scope.GetObject();
			if (globalScope.isComponentScope)
			{
				globalScope = (GlobalScope)globalScope.GetParent();
			}
			ScriptObject parent = globalScope.GetParent();
			VsaNamedItemScope vsaNamedItemScope = new VsaNamedItemScope(GetObject(), parent, engine);
			globalScope.SetParent(vsaNamedItemScope);
			vsaNamedItemScope.SetParent(parent);
		}

		private void RemoveNamedItemNamespace()
		{
			ScriptObject scriptObject = (ScriptObject)Scope.GetObject();
			for (ScriptObject parent = scriptObject.GetParent(); parent != null; parent = parent.GetParent())
			{
				if (parent is VsaNamedItemScope && ((VsaNamedItemScope)parent).namedItem == hostObject)
				{
					scriptObject.SetParent(parent.GetParent());
					break;
				}
				scriptObject = parent;
			}
		}

		internal override void Remove()
		{
			base.Remove();
			if (exposed)
			{
				if (exposeMembers)
				{
					RemoveNamedItemNamespace();
				}
				if (isVisible)
				{
					((ScriptObject)Scope.GetObject()).DeleteMember(name);
				}
				hostObject = null;
				exposed = false;
			}
		}

		internal override void CheckForErrors()
		{
			Compile();
		}

		internal override void Compile()
		{
			if (!compiled && isVisible)
			{
				ActivationObject activationObject = (ActivationObject)Scope.GetObject();
				JSVariableField jSVariableField = activationObject.AddFieldOrUseExistingField(name, null, FieldAttributes.Public | FieldAttributes.Static);
				Type type = engine.GetType(typeString);
				if (type != null)
				{
					jSVariableField.type = new TypeExpression(new ConstantWrapper(type, null));
				}
				field = jSVariableField;
			}
		}

		internal override void Run()
		{
			if (!exposed)
			{
				if (isVisible)
				{
					ActivationObject activationObject = (ActivationObject)Scope.GetObject();
					field = activationObject.AddFieldOrUseExistingField(name, GetObject(), FieldAttributes.Public | FieldAttributes.Static);
				}
				if (exposeMembers)
				{
					AddNamedItemNamespace();
				}
				exposed = true;
			}
		}

		internal void ReRun(GlobalScope scope)
		{
			if (field is JSGlobalField)
			{
				((JSGlobalField)field).ILField = scope.GetField(name, BindingFlags.Static | BindingFlags.Public);
				field.SetValue(scope, GetObject());
				field = null;
			}
		}

		internal override void Reset()
		{
			base.Reset();
			hostObject = null;
			exposed = false;
			compiled = false;
			scope = null;
		}

		internal override void Close()
		{
			Remove();
			base.Close();
			hostObject = null;
			scope = null;
		}
	}
	/// <summary>Represents items added to the .NET script engine. This includes code items, reference items, and global items.</summary>
	public abstract class VsaItem : IJSVsaItem
	{
		/// <summary>Specifies the name of the item.</summary>
		protected string name;

		internal string codebase;

		internal VsaEngine engine;

		/// <summary>Specifies the type of the item as <see cref="F:Microsoft.JScript.Vsa.JSVsaItemType.Code" />, <see cref="F:Microsoft.JScript.Vsa.JSVsaItemType.Reference" />, or <see cref="F:Microsoft.JScript.Vsa.JSVsaItemType.AppGlobal" />.</summary>
		protected JSVsaItemType type;

		/// <summary>Specifies the type of the item as <see cref="F:Microsoft.JScript.Vsa.JSVsaItemFlag.Class" />, <see cref="F:Microsoft.JScript.Vsa.JSVsaItemFlag.Module" />, or <see cref="F:Microsoft.JScript.Vsa.JSVsaItemFlag.None" />.</summary>
		protected JSVsaItemFlag flag;

		/// <summary>Specifies whether the current in-memory representation of the item differs from the persisted representation.</summary>
		protected bool isDirty;

		/// <summary>Gets or sets a value that indicates whether the current in-memory representation of the item differs from the persisted representation.</summary>
		/// <returns>
		///   <see langword="true" /> if the in-memory representation differs from the persisted representation; otherwise, <see langword="false" />.</returns>
		public virtual bool IsDirty
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				return isDirty;
			}
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				isDirty = value;
			}
		}

		/// <summary>Gets or sets the name of the item.</summary>
		/// <returns>The string literal name of the item.</returns>
		public virtual string Name
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				return name;
			}
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				if (name == value)
				{
					return;
				}
				if (!engine.IsValidIdentifier(value))
				{
					throw new JSVsaException(JSVsaError.ItemNameInvalid);
				}
				foreach (IJSVsaItem item in engine.Items)
				{
					if (item.Name.Equals(value))
					{
						throw new JSVsaException(JSVsaError.ItemNameInUse);
					}
				}
				name = value;
				isDirty = true;
				engine.IsDirty = true;
			}
		}

		/// <summary>Gets the type of the item.</summary>
		/// <returns>One of the enumeration values. The value indicates the type of the item.</returns>
		public JSVsaItemType ItemType
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				return type;
			}
		}

		internal VsaItem(VsaEngine engine, string itemName, JSVsaItemType type, JSVsaItemFlag flag)
		{
			this.engine = engine;
			this.type = type;
			name = itemName;
			this.flag = flag;
			codebase = null;
			isDirty = true;
		}

		internal virtual void CheckForErrors()
		{
		}

		internal virtual void Close()
		{
			engine = null;
		}

		internal virtual void Compile()
		{
		}

		internal virtual Type GetCompiledType()
		{
			return null;
		}

		/// <summary>Gets the codebase option.</summary>
		/// <param name="name">The string literal "codebase".</param>
		/// <returns>The value of the codebase option.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual object GetOption(string name)
		{
			if (engine == null)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			if (string.Compare(name, "codebase", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return codebase;
			}
			throw new JSVsaException(JSVsaError.OptionNotSupported);
		}

		internal virtual void Remove()
		{
			engine = null;
		}

		internal virtual void Reset()
		{
		}

		internal virtual void Run()
		{
		}

		/// <summary>Sets the codebase option.</summary>
		/// <param name="name">The string literal "codebase".</param>
		/// <param name="value">The new value for the option.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void SetOption(string name, object value)
		{
			if (engine == null)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			if (string.Compare(name, "codebase", StringComparison.OrdinalIgnoreCase) == 0)
			{
				codebase = (string)value;
				isDirty = true;
				engine.IsDirty = true;
				return;
			}
			throw new JSVsaException(JSVsaError.OptionNotSupported);
		}
	}
	/// <summary>Represents a collection of <see cref="T:Microsoft.JScript.Vsa.IJSVsaItem" /> objects that can be addressed either by name or by index.</summary>
	public sealed class VsaItems : IJSVsaItems, IEnumerable
	{
		private ArrayList items;

		private bool isClosed;

		private VsaEngine engine;

		internal int staticCodeBlockCount;

		/// <summary>Gets the item from the collection that is designated by the specified index value.</summary>
		/// <param name="index">The index of the item to get.</param>
		/// <returns>The item at <paramref name="index" />.</returns>
		public IJSVsaItem this[int index]
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (isClosed)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				if (index < 0 || index >= items.Count)
				{
					throw new JSVsaException(JSVsaError.ItemNotFound);
				}
				return (IJSVsaItem)items[index];
			}
		}

		/// <summary>Gets the item from the collection that is designated by the specified name.</summary>
		/// <param name="itemName">The name of the item to get.</param>
		/// <returns>The item that is named <paramref name="itemName" />.</returns>
		public IJSVsaItem this[string itemName]
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (isClosed)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				if (itemName != null)
				{
					int i = 0;
					for (int count = items.Count; i < count; i++)
					{
						IJSVsaItem iJSVsaItem = (IJSVsaItem)items[i];
						if (iJSVsaItem.Name.Equals(itemName))
						{
							return iJSVsaItem;
						}
					}
				}
				throw new JSVsaException(JSVsaError.ItemNotFound);
			}
		}

		/// <summary>Gets the number of items in the collection.</summary>
		/// <returns>The number of items in the collection.</returns>
		public int Count
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (isClosed)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				if (items != null)
				{
					return items.Count;
				}
				return 0;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.VsaItems" /> class.</summary>
		/// <param name="engine">A reference to the scripting engine.</param>
		public VsaItems(VsaEngine engine)
		{
			this.engine = engine;
			staticCodeBlockCount = 0;
			items = new ArrayList(10);
		}

		/// <summary>Disconnects each item in the collection from the scripting engine.</summary>
		public void Close()
		{
			if (isClosed)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			TryObtainLock();
			try
			{
				isClosed = true;
				foreach (object item in items)
				{
					((VsaItem)item).Close();
				}
				items = null;
			}
			finally
			{
				ReleaseLock();
				engine = null;
			}
		}

		/// <summary>Creates a new item and adds it to the collection.</summary>
		/// <param name="name">The name of the new item.</param>
		/// <param name="itemType">One of the enumeration values. The value specifies the type of the new item as <see cref="F:Microsoft.JScript.Vsa.JSVsaItemType.Code" />, <see cref="F:Microsoft.JScript.Vsa.JSVsaItemType.Reference" />, or <see cref="F:Microsoft.JScript.Vsa.JSVsaItemType.AppGlobal" />.</param>
		/// <param name="itemFlag">One of the enumeration values. The value specifies the initial content of a <see cref="F:Microsoft.JScript.Vsa.JSVsaItemType.Code" /> item as <see cref="F:Microsoft.JScript.Vsa.JSVsaItemFlag.Class" />, <see cref="F:Microsoft.JScript.Vsa.JSVsaItemFlag.Module" />, or <see cref="F:Microsoft.JScript.Vsa.JSVsaItemFlag.None" />.</param>
		/// <returns>The newly created item.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public IJSVsaItem CreateItem(string name, JSVsaItemType itemType, JSVsaItemFlag itemFlag)
		{
			if (isClosed)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			if (engine.IsRunning)
			{
				throw new JSVsaException(JSVsaError.EngineRunning);
			}
			TryObtainLock();
			try
			{
				if (itemType != 0 && !engine.IsValidIdentifier(name))
				{
					throw new JSVsaException(JSVsaError.ItemNameInvalid);
				}
				foreach (object item in items)
				{
					if (((VsaItem)item).Name.Equals(name))
					{
						throw new JSVsaException(JSVsaError.ItemNameInUse);
					}
				}
				IJSVsaItem iJSVsaItem = null;
				switch (itemType)
				{
				case JSVsaItemType.Reference:
					if (itemFlag != 0)
					{
						throw new JSVsaException(JSVsaError.ItemFlagNotSupported);
					}
					iJSVsaItem = new VsaReference(engine, name);
					break;
				case JSVsaItemType.AppGlobal:
					if (itemFlag != 0)
					{
						throw new JSVsaException(JSVsaError.ItemFlagNotSupported);
					}
					iJSVsaItem = new VsaHostObject(engine, name, JSVsaItemType.AppGlobal);
					((VsaHostObject)iJSVsaItem).isVisible = true;
					break;
				case JSVsaItemType.Code:
					if (itemFlag == JSVsaItemFlag.Class)
					{
						throw new JSVsaException(JSVsaError.ItemFlagNotSupported);
					}
					iJSVsaItem = new VsaStaticCode(engine, name, itemFlag);
					staticCodeBlockCount++;
					break;
				}
				if (iJSVsaItem != null)
				{
					items.Add(iJSVsaItem);
					engine.IsDirty = true;
					return iJSVsaItem;
				}
				throw new JSVsaException(JSVsaError.ItemTypeNotSupported);
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Gets an enumerator that iterates over the collection.</summary>
		/// <returns>An enumerator that iterates over the collection.</returns>
		public IEnumerator GetEnumerator()
		{
			if (isClosed)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			return items.GetEnumerator();
		}

		/// <summary>Removes the item that is designated by the specified name from the collection.</summary>
		/// <param name="itemName">The name of the item to remove.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void Remove(string itemName)
		{
			if (isClosed)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			TryObtainLock();
			try
			{
				if (itemName == null)
				{
					throw new ArgumentNullException("itemName");
				}
				int i = 0;
				for (int count = items.Count; i < count; i++)
				{
					IJSVsaItem iJSVsaItem = (IJSVsaItem)items[i];
					if (iJSVsaItem.Name.Equals(itemName))
					{
						((VsaItem)iJSVsaItem).Remove();
						items.RemoveAt(i);
						engine.IsDirty = true;
						if (iJSVsaItem is VsaStaticCode)
						{
							staticCodeBlockCount--;
						}
						return;
					}
				}
				throw new JSVsaException(JSVsaError.ItemNotFound);
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Removes the item that is designated by the specified index value from the collection.</summary>
		/// <param name="itemIndex">The index of the item to remove.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void Remove(int itemIndex)
		{
			if (isClosed)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			TryObtainLock();
			try
			{
				if (0 <= itemIndex && itemIndex < items.Count)
				{
					VsaItem vsaItem = (VsaItem)items[itemIndex];
					vsaItem.Remove();
					items.RemoveAt(itemIndex);
					if (vsaItem is VsaStaticCode)
					{
						staticCodeBlockCount--;
					}
					return;
				}
				throw new JSVsaException(JSVsaError.ItemNotFound);
			}
			finally
			{
				ReleaseLock();
			}
		}

		private void TryObtainLock()
		{
			engine.TryObtainLock();
		}

		private void ReleaseLock()
		{
			engine.ReleaseLock();
		}
	}
	internal sealed class VsaNamedItemScope : ScriptObject, IActivationObject
	{
		internal object namedItem;

		private SimpleHashtable namedItemWrappedMemberCache;

		private IReflect reflectObj;

		private bool recursive;

		internal VsaNamedItemScope(object hostObject, ScriptObject parent, VsaEngine engine)
			: base(parent)
		{
			namedItem = hostObject;
			if ((reflectObj = hostObject as IReflect) == null)
			{
				reflectObj = Globals.TypeRefs.ToReferenceContext(hostObject.GetType());
			}
			recursive = false;
			base.engine = engine;
		}

		private static MemberInfo[] GetAndWrapMember(IReflect reflect, object namedItem, string name, BindingFlags bindingAttr)
		{
			PropertyInfo property = reflect.GetProperty(name, bindingAttr);
			if (property != null)
			{
				MethodInfo getMethod = JSProperty.GetGetMethod(property, nonPublic: false);
				MethodInfo setMethod = JSProperty.GetSetMethod(property, nonPublic: false);
				if ((getMethod != null && !getMethod.IsStatic) || (setMethod != null && !setMethod.IsStatic))
				{
					MethodInfo method = reflect.GetMethod(name, bindingAttr);
					if (method != null && !method.IsStatic)
					{
						return new MemberInfo[1]
						{
							new JSWrappedPropertyAndMethod(property, method, namedItem)
						};
					}
				}
			}
			MemberInfo[] member = reflect.GetMember(name, bindingAttr);
			if (member != null && member.Length != 0)
			{
				return ScriptObject.WrapMembers(member, namedItem);
			}
			return null;
		}

		public object GetDefaultThisObject()
		{
			return ((IActivationObject)GetParent()).GetDefaultThisObject();
		}

		public FieldInfo GetField(string name, int lexLevel)
		{
			throw new JScriptException(JSError.InternalError);
		}

		public GlobalScope GetGlobalScope()
		{
			return ((IActivationObject)GetParent()).GetGlobalScope();
		}

		FieldInfo IActivationObject.GetLocalField(string name)
		{
			return null;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		public object GetMemberValue(string name, int lexlevel)
		{
			if (lexlevel <= 0)
			{
				return Missing.Value;
			}
			object memberValue = LateBinding.GetMemberValue(namedItem, name);
			if (!(memberValue is Missing))
			{
				return memberValue;
			}
			return ((IActivationObject)parent).GetMemberValue(name, lexlevel - 1);
		}

		public override MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
		{
			MemberInfo[] array = null;
			if (!recursive && reflectObj != null)
			{
				recursive = true;
				try
				{
					if (!reflectObj.GetType().IsCOMObject || !(engine.Site is ISite2 site))
					{
						array = ScriptObject.WrapMembers(reflectObj.GetMember(name, bindingAttr), namedItem);
					}
					else if ((array = GetAndWrapMember(reflectObj, namedItem, name, bindingAttr)) == null)
					{
						object[] parentChain = site.GetParentChain(reflectObj);
						if (parentChain != null)
						{
							int num = parentChain.Length;
							for (int i = 0; i < num; i++)
							{
								if (parentChain[i] is IReflect reflect && (array = GetAndWrapMember(reflect, reflect, name, bindingAttr)) != null)
								{
									break;
								}
							}
						}
					}
				}
				finally
				{
					recursive = false;
				}
			}
			if (array != null)
			{
				return array;
			}
			return new MemberInfo[0];
		}

		public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
		{
			MemberInfo[] result = null;
			if (!recursive)
			{
				recursive = true;
				try
				{
					result = reflectObj.GetMembers(bindingAttr);
					if (result != null)
					{
						if (result.Length != 0)
						{
							SimpleHashtable simpleHashtable = namedItemWrappedMemberCache;
							if (simpleHashtable == null)
							{
								simpleHashtable = (namedItemWrappedMemberCache = new SimpleHashtable(16u));
							}
							return ScriptObject.WrapMembers(result, namedItem, simpleHashtable);
						}
						return null;
					}
					return result;
				}
				finally
				{
					recursive = false;
				}
			}
			return result;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object GetMemberValue(string name)
		{
			object value = Missing.Value;
			if (!recursive)
			{
				recursive = true;
				try
				{
					FieldInfo field = reflectObj.GetField(name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy);
					if (field == null)
					{
						PropertyInfo property = reflectObj.GetProperty(name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy);
						if (property != null)
						{
							value = JSProperty.GetValue(property, namedItem, null);
						}
					}
					else
					{
						value = field.GetValue(namedItem);
					}
					if (value is Missing)
					{
						if (parent != null)
						{
							return parent.GetMemberValue(name);
						}
						return value;
					}
					return value;
				}
				finally
				{
					recursive = false;
				}
			}
			return value;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override void SetMemberValue(string name, object value)
		{
			bool flag = false;
			if (recursive)
			{
				return;
			}
			recursive = true;
			try
			{
				FieldInfo field = reflectObj.GetField(name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy);
				if (field == null)
				{
					PropertyInfo property = reflectObj.GetProperty(name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy);
					if (property != null)
					{
						JSProperty.SetValue(property, namedItem, value, null);
						flag = true;
					}
				}
				else
				{
					field.SetValue(namedItem, value);
					flag = true;
				}
				if (!flag && parent != null)
				{
					parent.SetMemberValue(name, value);
				}
			}
			finally
			{
				recursive = false;
			}
		}
	}
	internal class VsaReference : VsaItem, IJSVsaReferenceItem, IJSVsaItem
	{
		private string assemblyName;

		private Assembly assembly;

		private bool loadFailed;

		public string AssemblyName
		{
			get
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				return assemblyName;
			}
			set
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				assemblyName = value;
				isDirty = true;
				engine.IsDirty = true;
			}
		}

		internal Assembly Assembly
		{
			get
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				return assembly;
			}
		}

		internal VsaReference(VsaEngine engine, string itemName)
			: base(engine, itemName, JSVsaItemType.Reference, JSVsaItemFlag.None)
		{
			assemblyName = itemName;
			assembly = null;
			loadFailed = false;
		}

		internal Type GetType(string typeName)
		{
			if (assembly == null)
			{
				if (!loadFailed)
				{
					try
					{
						Load();
					}
					catch
					{
						loadFailed = true;
					}
				}
				if (assembly == null)
				{
					return null;
				}
			}
			Type type = assembly.GetType(typeName, throwOnError: false);
			if (type != null && (!type.IsPublic || CustomAttribute.IsDefined(type, typeof(RequiredAttributeAttribute), inherit: true)))
			{
				type = null;
			}
			return type;
		}

		internal override void Compile()
		{
			Compile(throwOnFileNotFound: true);
		}

		internal bool Compile(bool throwOnFileNotFound)
		{
			try
			{
				string fileName = Path.GetFileName(assemblyName);
				string strA = fileName + ".dll";
				if (string.Compare(fileName, "mscorlib.dll", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(strA, "mscorlib.dll", StringComparison.OrdinalIgnoreCase) == 0)
				{
					assembly = typeof(object).Assembly;
				}
				if (string.Compare(fileName, "microsoft.jscript.dll", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(strA, "microsoft.jscript.dll", StringComparison.OrdinalIgnoreCase) == 0)
				{
					assembly = engine.JScriptModule.Assembly;
				}
				else if (engine.ReferenceLoaderAPI != LoaderAPI.ReflectionOnlyLoadFrom && (string.Compare(fileName, "system.dll", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(strA, "system.dll", StringComparison.OrdinalIgnoreCase) == 0))
				{
					assembly = typeof(Regex).Module.Assembly;
				}
				if (assembly == null)
				{
					string text = engine.FindAssembly(assemblyName);
					if (text == null)
					{
						strA = assemblyName + ".dll";
						bool flag = false;
						foreach (object item in engine.Items)
						{
							if (item is VsaReference && string.Compare(((VsaReference)item).AssemblyName, strA, StringComparison.OrdinalIgnoreCase) == 0)
							{
								flag = true;
								break;
							}
						}
						if (!flag)
						{
							text = engine.FindAssembly(strA);
							if (text != null)
							{
								assemblyName = strA;
							}
						}
					}
					if (text == null)
					{
						if (throwOnFileNotFound)
						{
							throw new JSVsaException(JSVsaError.AssemblyExpected, assemblyName, new FileNotFoundException());
						}
						return false;
					}
					switch (engine.ReferenceLoaderAPI)
					{
					case LoaderAPI.LoadFrom:
						assembly = Assembly.LoadFrom(text);
						break;
					case LoaderAPI.LoadFile:
						assembly = Assembly.LoadFile(text);
						break;
					case LoaderAPI.ReflectionOnlyLoadFrom:
						assembly = Assembly.ReflectionOnlyLoadFrom(text);
						break;
					}
					CheckCompatibility();
				}
			}
			catch (JSVsaException)
			{
				throw;
			}
			catch (BadImageFormatException innerException)
			{
				throw new JSVsaException(JSVsaError.AssemblyExpected, assemblyName, innerException);
			}
			catch (FileNotFoundException innerException2)
			{
				if (throwOnFileNotFound)
				{
					throw new JSVsaException(JSVsaError.AssemblyExpected, assemblyName, innerException2);
				}
				return false;
			}
			catch (FileLoadException innerException3)
			{
				throw new JSVsaException(JSVsaError.AssemblyExpected, assemblyName, innerException3);
			}
			catch (ArgumentException innerException4)
			{
				throw new JSVsaException(JSVsaError.AssemblyExpected, assemblyName, innerException4);
			}
			catch (Exception ex2)
			{
				throw new JSVsaException(JSVsaError.InternalCompilerError, ex2.ToString(), ex2);
			}
			if (assembly == null)
			{
				if (throwOnFileNotFound)
				{
					throw new JSVsaException(JSVsaError.AssemblyExpected, assemblyName);
				}
				return false;
			}
			return true;
		}

		private void Load()
		{
			try
			{
				if (string.Compare(assemblyName, "mscorlib", StringComparison.OrdinalIgnoreCase) == 0)
				{
					assembly = typeof(object).Module.Assembly;
				}
				else if (string.Compare(assemblyName, "Microsoft.JScript", StringComparison.OrdinalIgnoreCase) == 0)
				{
					assembly = typeof(VsaEngine).Module.Assembly;
				}
				else if (string.Compare(assemblyName, "System", StringComparison.OrdinalIgnoreCase) == 0)
				{
					assembly = typeof(Regex).Module.Assembly;
				}
				else
				{
					assembly = Assembly.Load(assemblyName);
				}
			}
			catch (BadImageFormatException innerException)
			{
				throw new JSVsaException(JSVsaError.AssemblyExpected, assemblyName, innerException);
			}
			catch (FileNotFoundException innerException2)
			{
				throw new JSVsaException(JSVsaError.AssemblyExpected, assemblyName, innerException2);
			}
			catch (ArgumentException innerException3)
			{
				throw new JSVsaException(JSVsaError.AssemblyExpected, assemblyName, innerException3);
			}
			catch (Exception ex)
			{
				throw new JSVsaException(JSVsaError.InternalCompilerError, ex.ToString(), ex);
			}
			if (assembly == null)
			{
				throw new JSVsaException(JSVsaError.AssemblyExpected, assemblyName);
			}
		}

		private void CheckCompatibility()
		{
			assembly.ManifestModule.GetPEKind(out var peKind, out var machine);
			if (machine != ImageFileMachine.I386 || PortableExecutableKinds.ILOnly != (peKind & (PortableExecutableKinds.ILOnly | PortableExecutableKinds.Required32Bit)))
			{
				PortableExecutableKinds pEKindFlags = engine.PEKindFlags;
				ImageFileMachine pEMachineArchitecture = engine.PEMachineArchitecture;
				if ((pEMachineArchitecture != ImageFileMachine.I386 || PortableExecutableKinds.ILOnly != (pEKindFlags & (PortableExecutableKinds.ILOnly | PortableExecutableKinds.Required32Bit))) && machine != pEMachineArchitecture)
				{
					JScriptException ex = new JScriptException(JSError.IncompatibleAssemblyReference);
					ex.value = assemblyName;
					engine.OnCompilerError(ex);
				}
			}
		}
	}
	internal class VsaScriptCode : VsaItem, IVsaScriptCodeItem, IJSVsaCodeItem, IJSVsaItem, IDebugVsaScriptCodeItem
	{
		private Context codeContext;

		private ScriptBlock binaryCode;

		internal bool executed;

		private VsaScriptScope scope;

		private Type compiledBlock;

		private bool compileToIL;

		private bool optimize;

		public CodeObject CodeDOM
		{
			get
			{
				throw new JSVsaException(JSVsaError.CodeDOMNotAvailable);
			}
		}

		public override string Name
		{
			set
			{
				name = value;
				if (codebase == null)
				{
					string rootMoniker = engine.RootMoniker;
					codeContext.document.documentName = rootMoniker + (rootMoniker.EndsWith("/", StringComparison.Ordinal) ? "" : "/") + name;
				}
			}
		}

		public IVsaScriptScope Scope => scope;

		public object SourceContext
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public string SourceText
		{
			get
			{
				return codeContext.source_string;
			}
			set
			{
				codeContext.SetSourceContext(codeContext.document, (value == null) ? "" : value);
				executed = false;
				binaryCode = null;
			}
		}

		public int StartColumn
		{
			get
			{
				return codeContext.document.startCol;
			}
			set
			{
				codeContext.document.startCol = value;
			}
		}

		public int StartLine
		{
			get
			{
				return codeContext.document.startLine;
			}
			set
			{
				codeContext.document.startLine = value;
			}
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		internal VsaScriptCode(VsaEngine engine, string itemName, JSVsaItemType type, IVsaScriptScope scope)
			: base(engine, itemName, type, JSVsaItemFlag.None)
		{
			binaryCode = null;
			executed = false;
			this.scope = (VsaScriptScope)scope;
			codeContext = new Context(new DocumentContext(this), null);
			compiledBlock = null;
			compileToIL = true;
			optimize = true;
		}

		internal override void Close()
		{
			base.Close();
			binaryCode = null;
			scope = null;
			codeContext = null;
			compiledBlock = null;
		}

		internal override void Compile()
		{
			if (binaryCode == null)
			{
				JSParser jSParser = new JSParser(codeContext);
				if (base.ItemType == (JSVsaItemType)22)
				{
					binaryCode = jSParser.ParseExpressionItem();
				}
				else
				{
					binaryCode = jSParser.Parse();
				}
				if (optimize && !jSParser.HasAborted)
				{
					binaryCode.ProcessAssemblyAttributeLists();
					binaryCode.PartiallyEvaluate();
				}
				if (engine.HasErrors && !engine.alwaysGenerateIL)
				{
					throw new EndOfFile();
				}
				if (compileToIL)
				{
					compiledBlock = binaryCode.TranslateToILClass(engine.CompilerGlobals).CreateType();
				}
			}
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual object Execute()
		{
			if (!engine.IsRunning)
			{
				throw new JSVsaException(JSVsaError.EngineNotRunning);
			}
			engine.Globals.ScopeStack.Push((ScriptObject)scope.GetObject());
			try
			{
				Compile();
				return RunCode();
			}
			finally
			{
				engine.Globals.ScopeStack.Pop();
			}
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual object Evaluate()
		{
			return Execute();
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual bool ParseNamedBreakPoint(string input, out string functionName, out int nargs, out string arguments, out string returnType, out ulong offset)
		{
			functionName = "";
			nargs = 0;
			arguments = "";
			returnType = "";
			offset = 0uL;
			JSParser jSParser = new JSParser(codeContext);
			string[] array = jSParser.ParseNamedBreakpoint(out nargs);
			if (array == null || array.Length != 4)
			{
				return false;
			}
			if (array[0] != null)
			{
				functionName = array[0];
			}
			if (array[1] != null)
			{
				arguments = array[1];
			}
			if (array[2] != null)
			{
				returnType = array[2];
			}
			if (array[3] != null)
			{
				offset = ((IConvertible)Convert.LiteralToNumber(array[3])).ToUInt64(null);
			}
			return true;
		}

		internal override Type GetCompiledType()
		{
			return compiledBlock;
		}

		public override object GetOption(string name)
		{
			if (string.Compare(name, "il", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return compileToIL;
			}
			if (string.Compare(name, "optimize", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return optimize;
			}
			return base.GetOption(name);
		}

		internal override void Reset()
		{
			binaryCode = null;
			compiledBlock = null;
			executed = false;
			codeContext = new Context(new DocumentContext(this), codeContext.source_string);
		}

		internal override void Run()
		{
			if (!executed)
			{
				RunCode();
			}
		}

		private object RunCode()
		{
			if (binaryCode != null)
			{
				object obj = null;
				if (null != compiledBlock)
				{
					GlobalScope obj2 = (GlobalScope)Activator.CreateInstance(compiledBlock, scope.GetObject());
					scope.ReRun(obj2);
					MethodInfo method = compiledBlock.GetMethod("Global Code");
					try
					{
						System.Runtime.Remoting.Messaging.CallContext.SetData("JScript:" + compiledBlock.Assembly.FullName, engine);
						obj = method.Invoke(obj2, null);
					}
					catch (TargetInvocationException ex)
					{
						throw ex.InnerException;
					}
				}
				else
				{
					obj = binaryCode.Evaluate();
				}
				executed = true;
				return obj;
			}
			return null;
		}

		public override void SetOption(string name, object value)
		{
			if (string.Compare(name, "il", StringComparison.OrdinalIgnoreCase) == 0)
			{
				compileToIL = (bool)value;
				if (compileToIL)
				{
					optimize = true;
				}
			}
			else if (string.Compare(name, "optimize", StringComparison.OrdinalIgnoreCase) == 0)
			{
				optimize = (bool)value;
				if (!optimize)
				{
					compileToIL = false;
				}
			}
			else if (string.Compare(name, "codebase", StringComparison.OrdinalIgnoreCase) == 0)
			{
				codebase = (string)value;
				codeContext.document.documentName = codebase;
			}
			else
			{
				base.SetOption(name, value);
			}
		}

		public void AddEventSource(string EventSourceName, string EventSourceType)
		{
		}

		public void RemoveEventSource(string EventSourceName)
		{
		}

		public void AppendSourceText(string SourceCode)
		{
			if (SourceCode != null && SourceCode.Length != 0)
			{
				codeContext.SetSourceContext(codeContext.document, codeContext.source_string + SourceCode);
				executed = false;
				binaryCode = null;
			}
		}
	}
	internal class VsaScriptScope : VsaItem, IVsaScriptScope, IJSVsaItem, IDebugScriptScope
	{
		private VsaScriptScope parent;

		private GlobalScope scope;

		private ArrayList items;

		private bool isCompiled;

		private bool isClosed;

		public IVsaScriptScope Parent => parent;

		internal VsaScriptScope(VsaEngine engine, string itemName, VsaScriptScope parent)
			: base(engine, itemName, (JSVsaItemType)19, JSVsaItemFlag.None)
		{
			this.parent = parent;
			scope = null;
			items = new ArrayList(8);
			isCompiled = false;
			isClosed = false;
		}

		public virtual object GetObject()
		{
			if (scope == null)
			{
				if (parent != null)
				{
					scope = new GlobalScope((GlobalScope)parent.GetObject(), engine, isComponentScope: false);
				}
				else
				{
					scope = new GlobalScope(null, engine);
				}
			}
			return scope;
		}

		public virtual IJSVsaItem AddItem(string itemName, JSVsaItemType type)
		{
			VsaItem vsaItem = null;
			if (isClosed)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			if (GetItem(itemName) != null)
			{
				throw new JSVsaException(JSVsaError.ItemNameInUse);
			}
			switch (type)
			{
			case (JSVsaItemType)20:
				vsaItem = new VsaScriptCode(engine, itemName, type, this);
				break;
			case (JSVsaItemType)22:
				if (!engine.IsRunning)
				{
					throw new JSVsaException(JSVsaError.EngineNotRunning);
				}
				vsaItem = new VsaScriptCode(engine, itemName, type, this);
				break;
			case (JSVsaItemType)21:
				if (!engine.IsRunning)
				{
					throw new JSVsaException(JSVsaError.EngineNotRunning);
				}
				vsaItem = new VsaScriptCode(engine, itemName, type, this);
				break;
			case (JSVsaItemType)16:
			case (JSVsaItemType)17:
			case (JSVsaItemType)18:
				vsaItem = new VsaHostObject(engine, itemName, type, this);
				if (type == (JSVsaItemType)17 || type == (JSVsaItemType)18)
				{
					((VsaHostObject)vsaItem).exposeMembers = true;
				}
				if (type == (JSVsaItemType)16 || type == (JSVsaItemType)18)
				{
					((VsaHostObject)vsaItem).isVisible = true;
				}
				if (engine.IsRunning)
				{
					((VsaHostObject)vsaItem).Compile();
					((VsaHostObject)vsaItem).Run();
				}
				break;
			case (JSVsaItemType)19:
				vsaItem = new VsaScriptScope(engine, itemName, this);
				break;
			}
			if (vsaItem != null)
			{
				items.Add(vsaItem);
				return vsaItem;
			}
			throw new JSVsaException(JSVsaError.ItemTypeNotSupported);
		}

		public virtual IJSVsaItem GetItem(string itemName)
		{
			int i = 0;
			for (int count = items.Count; i < count; i++)
			{
				VsaItem vsaItem = (VsaItem)items[i];
				if ((vsaItem.Name == null && itemName == null) || (vsaItem.Name != null && vsaItem.Name.Equals(itemName)))
				{
					return (IJSVsaItem)items[i];
				}
			}
			return null;
		}

		public virtual void RemoveItem(string itemName)
		{
			int i = 0;
			for (int count = items.Count; i < count; i++)
			{
				VsaItem vsaItem = (VsaItem)items[i];
				if ((vsaItem.Name == null && itemName == null) || (vsaItem.Name != null && vsaItem.Name.Equals(itemName)))
				{
					vsaItem.Remove();
					items.Remove(i);
					return;
				}
			}
			throw new JSVsaException(JSVsaError.ItemNotFound);
		}

		public virtual void RemoveItem(IJSVsaItem item)
		{
			int i = 0;
			for (int count = items.Count; i < count; i++)
			{
				VsaItem vsaItem = (VsaItem)items[i];
				if (vsaItem == item)
				{
					vsaItem.Remove();
					items.Remove(i);
					return;
				}
			}
			throw new JSVsaException(JSVsaError.ItemNotFound);
		}

		public virtual int GetItemCount()
		{
			return items.Count;
		}

		public virtual IJSVsaItem GetItemAtIndex(int index)
		{
			if (index < items.Count)
			{
				return (IJSVsaItem)items[index];
			}
			throw new JSVsaException(JSVsaError.ItemNotFound);
		}

		public virtual void RemoveItemAtIndex(int index)
		{
			if (index < items.Count)
			{
				((VsaItem)items[index]).Remove();
				items.Remove(index);
				return;
			}
			throw new JSVsaException(JSVsaError.ItemNotFound);
		}

		public virtual IJSVsaItem CreateDynamicItem(string itemName, JSVsaItemType type)
		{
			if (engine.IsRunning)
			{
				return AddItem(itemName, type);
			}
			throw new JSVsaException(JSVsaError.EngineNotRunning);
		}

		internal override void CheckForErrors()
		{
			if (items.Count == 0)
			{
				return;
			}
			try
			{
				engine.Globals.ScopeStack.Push((ScriptObject)GetObject());
				foreach (object item in items)
				{
					((VsaItem)item).CheckForErrors();
				}
			}
			finally
			{
				engine.Globals.ScopeStack.Pop();
			}
		}

		internal override void Compile()
		{
			if (items.Count == 0 || isCompiled)
			{
				return;
			}
			isCompiled = true;
			try
			{
				engine.Globals.ScopeStack.Push((ScriptObject)GetObject());
				try
				{
					foreach (object item in items)
					{
						((VsaItem)item).Compile();
					}
				}
				finally
				{
					engine.Globals.ScopeStack.Pop();
				}
			}
			catch
			{
				isCompiled = false;
				throw;
			}
		}

		internal override void Reset()
		{
			foreach (object item in items)
			{
				((VsaItem)item).Reset();
			}
		}

		internal void ReRun(GlobalScope scope)
		{
			foreach (object item in items)
			{
				if (item is VsaHostObject)
				{
					((VsaHostObject)item).ReRun(scope);
				}
			}
			if (parent != null)
			{
				parent.ReRun(scope);
			}
		}

		internal override void Run()
		{
			if (items.Count == 0)
			{
				return;
			}
			try
			{
				engine.Globals.ScopeStack.Push((ScriptObject)GetObject());
				foreach (object item in items)
				{
					((VsaItem)item).Run();
				}
			}
			finally
			{
				engine.Globals.ScopeStack.Pop();
			}
		}

		internal override void Close()
		{
			foreach (object item in items)
			{
				((VsaItem)item).Close();
			}
			items = null;
			parent = null;
			scope = null;
			isClosed = true;
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void SetThisValue(object thisValue)
		{
			if (scope != null)
			{
				scope.thisObject = thisValue;
			}
		}
	}
	internal class VsaStaticCode : VsaItem, IJSVsaCodeItem, IJSVsaItem
	{
		internal Context codeContext;

		private Type compiledClass;

		private ScriptBlock block;

		public CodeObject CodeDOM
		{
			get
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				throw new JSVsaException(JSVsaError.CodeDOMNotAvailable);
			}
		}

		public override string Name
		{
			set
			{
				base.Name = value;
				if (codebase == null)
				{
					string rootMoniker = engine.RootMoniker;
					codeContext.document.documentName = rootMoniker + (rootMoniker.EndsWith("/", StringComparison.Ordinal) ? "" : "/") + name;
				}
			}
		}

		public object SourceContext
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public string SourceText
		{
			get
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				return codeContext.source_string;
			}
			set
			{
				if (engine == null)
				{
					throw new JSVsaException(JSVsaError.EngineClosed);
				}
				codeContext.SetSourceContext(codeContext.document, (value == null) ? "" : value);
				compiledClass = null;
				isDirty = true;
				engine.IsDirty = true;
			}
		}

		internal VsaStaticCode(VsaEngine engine, string itemName, JSVsaItemFlag flag)
			: base(engine, itemName, JSVsaItemType.Code, flag)
		{
			compiledClass = null;
			codeContext = new Context(new DocumentContext(this), "");
		}

		public void AddEventSource(string eventSourceName, string eventSourceType)
		{
			if (engine == null)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			throw new NotSupportedException();
		}

		public void AppendSourceText(string SourceCode)
		{
			if (engine == null)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			if (SourceCode != null && SourceCode.Length != 0)
			{
				codeContext.SetSourceContext(codeContext.document, codeContext.source_string + SourceCode);
				compiledClass = null;
				isDirty = true;
				engine.IsDirty = true;
			}
		}

		internal override void CheckForErrors()
		{
			if (compiledClass == null)
			{
				JSParser jSParser = new JSParser(codeContext);
				AST aST = jSParser.Parse();
			}
		}

		internal override void Close()
		{
			base.Close();
			codeContext = null;
			compiledClass = null;
		}

		internal override Type GetCompiledType()
		{
			TypeBuilder typeBuilder = compiledClass as TypeBuilder;
			if (typeBuilder != null)
			{
				compiledClass = typeBuilder.CreateType();
			}
			return compiledClass;
		}

		internal void Parse()
		{
			if (block != null || !(compiledClass == null))
			{
				return;
			}
			GlobalScope globalScope = (GlobalScope)engine.GetGlobalScope().GetObject();
			globalScope.evilScript = !globalScope.fast || engine.GetStaticCodeBlockCount() > 1;
			engine.Globals.ScopeStack.Push(globalScope);
			try
			{
				JSParser jSParser = new JSParser(codeContext);
				block = jSParser.Parse();
				if (jSParser.HasAborted)
				{
					block = null;
				}
			}
			finally
			{
				engine.Globals.ScopeStack.Pop();
			}
		}

		internal void ProcessAssemblyAttributeLists()
		{
			if (block != null)
			{
				block.ProcessAssemblyAttributeLists();
			}
		}

		internal void PartiallyEvaluate()
		{
			if (block == null || !(compiledClass == null))
			{
				return;
			}
			GlobalScope item = (GlobalScope)engine.GetGlobalScope().GetObject();
			engine.Globals.ScopeStack.Push(item);
			try
			{
				block.PartiallyEvaluate();
				if (engine.HasErrors && !engine.alwaysGenerateIL)
				{
					throw new EndOfFile();
				}
			}
			finally
			{
				engine.Globals.ScopeStack.Pop();
			}
		}

		internal override void Remove()
		{
			if (engine == null)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			base.Remove();
		}

		public void RemoveEventSource(string eventSourceName)
		{
			if (engine == null)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			throw new NotSupportedException();
		}

		internal override void Reset()
		{
			compiledClass = null;
			block = null;
			codeContext = new Context(new DocumentContext(this), codeContext.source_string);
		}

		internal override void Run()
		{
			if (!(compiledClass != null))
			{
				return;
			}
			GlobalScope globalScope = (GlobalScope)Activator.CreateInstance(GetCompiledType(), engine.GetGlobalScope().GetObject());
			engine.Globals.ScopeStack.Push(globalScope);
			try
			{
				MethodInfo method = compiledClass.GetMethod("Global Code");
				try
				{
					method.Invoke(globalScope, null);
				}
				catch (TargetInvocationException ex)
				{
					throw ex.InnerException;
				}
			}
			finally
			{
				engine.Globals.ScopeStack.Pop();
			}
		}

		public override void SetOption(string name, object value)
		{
			if (engine == null)
			{
				throw new JSVsaException(JSVsaError.EngineClosed);
			}
			if (string.Compare(name, "codebase", StringComparison.OrdinalIgnoreCase) == 0)
			{
				codebase = (string)value;
				codeContext.document.documentName = codebase;
				isDirty = true;
				engine.IsDirty = true;
				return;
			}
			throw new JSVsaException(JSVsaError.OptionNotSupported);
		}

		internal void TranslateToIL()
		{
			if (block != null && compiledClass == null)
			{
				GlobalScope item = (GlobalScope)engine.GetGlobalScope().GetObject();
				engine.Globals.ScopeStack.Push(item);
				try
				{
					compiledClass = block.TranslateToILClass(engine.CompilerGlobals, pushScope: false);
				}
				finally
				{
					engine.Globals.ScopeStack.Pop();
				}
			}
		}
	}
	internal sealed class While : AST
	{
		private AST condition;

		private AST body;

		private Completion completion;

		internal While(Context context, AST condition, AST body)
			: base(context)
		{
			this.condition = condition;
			this.body = body;
			completion = new Completion();
		}

		internal override object Evaluate()
		{
			this.completion.Continue = 0;
			this.completion.Exit = 0;
			this.completion.value = null;
			while (Convert.ToBoolean(condition.Evaluate()))
			{
				Completion completion = (Completion)body.Evaluate();
				if (completion.value != null)
				{
					this.completion.value = completion.value;
				}
				if (completion.Continue > 1)
				{
					this.completion.Continue = completion.Continue - 1;
					break;
				}
				if (completion.Exit > 0)
				{
					this.completion.Exit = completion.Exit - 1;
					break;
				}
				if (completion.Return)
				{
					return completion;
				}
			}
			return this.completion;
		}

		internal override AST PartiallyEvaluate()
		{
			condition = condition.PartiallyEvaluate();
			IReflect reflect = condition.InferType(null);
			if (reflect is FunctionPrototype || reflect == Typeob.ScriptFunction)
			{
				context.HandleError(JSError.SuspectLoopCondition);
			}
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			while (scriptObject is WithObject)
			{
				scriptObject = scriptObject.GetParent();
			}
			if (scriptObject is FunctionScope)
			{
				FunctionScope functionScope = (FunctionScope)scriptObject;
				BitArray definedFlags = functionScope.DefinedFlags;
				body = body.PartiallyEvaluate();
				functionScope.DefinedFlags = definedFlags;
			}
			else
			{
				body = body.PartiallyEvaluate();
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			Label label = il.DefineLabel();
			Label label2 = il.DefineLabel();
			Label label3 = il.DefineLabel();
			base.compilerGlobals.BreakLabelStack.Push(label2);
			base.compilerGlobals.ContinueLabelStack.Push(label);
			il.Emit(OpCodes.Br, label);
			il.MarkLabel(label3);
			body.TranslateToIL(il, Typeob.Void);
			il.MarkLabel(label);
			context.EmitLineInfo(il);
			condition.TranslateToConditionalBranch(il, branchIfTrue: true, label3, shortForm: false);
			il.MarkLabel(label2);
			base.compilerGlobals.BreakLabelStack.Pop();
			base.compilerGlobals.ContinueLabelStack.Pop();
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			condition.TranslateToILInitializer(il);
			body.TranslateToILInitializer(il);
		}
	}
	/// <summary>Represents the <see langword="with" /> statement. This class belongs to the abstract syntax tree category.</summary>
	public sealed class With : AST
	{
		private AST obj;

		private AST block;

		private Completion completion;

		private FunctionScope enclosing_function;

		internal With(Context context, AST obj, AST block)
			: base(context)
		{
			this.obj = obj;
			this.block = block;
			completion = new Completion();
			ScriptObject scriptObject = base.Globals.ScopeStack.Peek();
			if (scriptObject is FunctionScope)
			{
				enclosing_function = (FunctionScope)scriptObject;
			}
			else
			{
				enclosing_function = null;
			}
		}

		internal override object Evaluate()
		{
			try
			{
				JScriptWith(obj.Evaluate(), base.Engine);
			}
			catch (JScriptException ex)
			{
				ex.context = obj.context;
				throw ex;
			}
			Completion completion = null;
			try
			{
				completion = (Completion)block.Evaluate();
			}
			finally
			{
				base.Globals.ScopeStack.Pop();
			}
			if (completion.Continue > 1)
			{
				this.completion.Continue = completion.Continue - 1;
			}
			else
			{
				this.completion.Continue = 0;
			}
			if (completion.Exit > 0)
			{
				this.completion.Exit = completion.Exit - 1;
			}
			else
			{
				this.completion.Exit = 0;
			}
			if (completion.Return)
			{
				return completion;
			}
			return this.completion;
		}

		/// <summary>Establishes the default object for a <see langword="with" /> statement block by adding it to the scope stack.</summary>
		/// <param name="withOb">The default object.</param>
		/// <param name="engine">A reference to the scripting engine.</param>
		/// <returns>
		///   <paramref name="withOb" /> converted to an object.</returns>
		public static object JScriptWith(object withOb, VsaEngine engine)
		{
			object obj = Convert.ToObject(withOb, engine);
			if (obj == null)
			{
				throw new JScriptException(JSError.ObjectExpected);
			}
			Globals globals = engine.Globals;
			globals.ScopeStack.GuardedPush(new WithObject(globals.ScopeStack.Peek(), obj));
			return obj;
		}

		internal override AST PartiallyEvaluate()
		{
			this.obj = this.obj.PartiallyEvaluate();
			WithObject withObject;
			if (this.obj is ConstantWrapper)
			{
				object obj = Convert.ToObject(this.obj.Evaluate(), base.Engine);
				withObject = new WithObject(base.Globals.ScopeStack.Peek(), obj);
				if (obj is JSObject && ((JSObject)obj).noExpando)
				{
					withObject.isKnownAtCompileTime = true;
				}
			}
			else
			{
				withObject = new WithObject(base.Globals.ScopeStack.Peek(), new JSObject(null, checkSubType: false));
			}
			base.Globals.ScopeStack.Push(withObject);
			try
			{
				block = block.PartiallyEvaluate();
			}
			finally
			{
				base.Globals.ScopeStack.Pop();
			}
			return this;
		}

		internal override void TranslateToIL(ILGenerator il, Type rtype)
		{
			context.EmitLineInfo(il);
			base.Globals.ScopeStack.Push(new WithObject(base.Globals.ScopeStack.Peek(), new JSObject(null, checkSubType: false)));
			bool insideProtectedRegion = base.compilerGlobals.InsideProtectedRegion;
			base.compilerGlobals.InsideProtectedRegion = true;
			Label label = il.DefineLabel();
			base.compilerGlobals.BreakLabelStack.Push(label);
			base.compilerGlobals.ContinueLabelStack.Push(label);
			obj.TranslateToIL(il, Typeob.Object);
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.jScriptWithMethod);
			LocalBuilder localBuilder = null;
			if (context.document.debugOn)
			{
				il.BeginScope();
				localBuilder = il.DeclareLocal(Typeob.Object);
				localBuilder.SetLocalSymInfo("with()");
				il.Emit(OpCodes.Stloc, localBuilder);
			}
			else
			{
				il.Emit(OpCodes.Pop);
			}
			il.BeginExceptionBlock();
			block.TranslateToILInitializer(il);
			block.TranslateToIL(il, Typeob.Void);
			il.BeginFinallyBlock();
			if (context.document.debugOn)
			{
				il.Emit(OpCodes.Ldnull);
				il.Emit(OpCodes.Stloc, localBuilder);
			}
			EmitILToLoadEngine(il);
			il.Emit(OpCodes.Call, CompilerGlobals.popScriptObjectMethod);
			il.Emit(OpCodes.Pop);
			il.EndExceptionBlock();
			if (context.document.debugOn)
			{
				il.EndScope();
			}
			il.MarkLabel(label);
			base.compilerGlobals.BreakLabelStack.Pop();
			base.compilerGlobals.ContinueLabelStack.Pop();
			base.compilerGlobals.InsideProtectedRegion = insideProtectedRegion;
			base.Globals.ScopeStack.Pop();
		}

		internal override void TranslateToILInitializer(ILGenerator il)
		{
			obj.TranslateToILInitializer(il);
		}
	}
	internal sealed class WithObject : ScriptObject, IActivationObject
	{
		internal object contained_object;

		internal bool isKnownAtCompileTime;

		private bool isSuperType;

		internal WithObject(ScriptObject parent, object contained_object)
			: this(parent, contained_object, isSuperType: false)
		{
		}

		internal WithObject(ScriptObject parent, object contained_object, bool isSuperType)
			: base(parent)
		{
			this.contained_object = contained_object;
			isKnownAtCompileTime = contained_object is Type || (contained_object is ClassScope && ((ClassScope)contained_object).noExpando) || (contained_object is JSObject && ((JSObject)contained_object).noExpando);
			this.isSuperType = isSuperType;
		}

		public object GetDefaultThisObject()
		{
			return contained_object;
		}

		public FieldInfo GetField(string name, int lexLevel)
		{
			if (lexLevel <= 0)
			{
				return null;
			}
			IReflect reflect = ((!(contained_object is IReflect)) ? Globals.TypeRefs.ToReferenceContext(contained_object.GetType()) : ((IReflect)contained_object));
			FieldInfo field = reflect.GetField(name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			if (field != null)
			{
				return new JSWrappedField(field, contained_object);
			}
			PropertyInfo property = reflect.GetProperty(name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
			if (property != null)
			{
				return new JSPropertyField(property, contained_object);
			}
			if (parent != null && lexLevel > 1)
			{
				field = ((IActivationObject)parent).GetField(name, lexLevel - 1);
				if (field != null)
				{
					return new JSWrappedField(field, parent);
				}
			}
			return null;
		}

		public GlobalScope GetGlobalScope()
		{
			return ((IActivationObject)GetParent()).GetGlobalScope();
		}

		FieldInfo IActivationObject.GetLocalField(string name)
		{
			return null;
		}

		public override MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
		{
			return GetMember(name, bindingAttr, forceInstanceLookup: true);
		}

		internal MemberInfo[] GetMember(string name, BindingFlags bindingAttr, bool forceInstanceLookup)
		{
			Type type = null;
			BindingFlags bindingFlags = bindingAttr;
			if (forceInstanceLookup && isSuperType && (bindingAttr & BindingFlags.FlattenHierarchy) == 0)
			{
				bindingFlags |= BindingFlags.Instance;
			}
			object value = contained_object;
			MemberInfo[] member;
			while (true)
			{
				IReflect reflect;
				if (value is IReflect)
				{
					reflect = (IReflect)value;
					if (value is Type && !isSuperType)
					{
						bindingFlags &= ~BindingFlags.Instance;
					}
				}
				else
				{
					reflect = (type = Globals.TypeRefs.ToReferenceContext(value.GetType()));
				}
				member = reflect.GetMember(name, bindingFlags & ~BindingFlags.DeclaredOnly);
				if (member.Length != 0)
				{
					return ScriptObject.WrapMembers(member, value);
				}
				if (value is Type && !isSuperType)
				{
					member = Typeob.Type.GetMember(name, BindingFlags.Instance | BindingFlags.Public);
				}
				if (member.Length != 0)
				{
					return ScriptObject.WrapMembers(member, value);
				}
				if (!(type != null) || !type.IsNestedPublic)
				{
					break;
				}
				try
				{
					new ReflectionPermission(ReflectionPermissionFlag.TypeInformation | ReflectionPermissionFlag.MemberAccess).Assert();
					FieldInfo field = type.GetField("outer class instance", BindingFlags.Instance | BindingFlags.NonPublic);
					if (field != null)
					{
						value = field.GetValue(value);
						continue;
					}
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				break;
			}
			if (member.Length != 0)
			{
				return ScriptObject.WrapMembers(member, value);
			}
			return new MemberInfo[0];
		}

		public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
		{
			return ((IReflect)contained_object).GetMembers(bindingAttr);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override object GetMemberValue(string name)
		{
			object memberValue = LateBinding.GetMemberValue2(contained_object, name);
			if (!(memberValue is Missing))
			{
				return memberValue;
			}
			if (parent != null)
			{
				return parent.GetMemberValue(name);
			}
			return Missing.Value;
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		public object GetMemberValue(string name, int lexlevel)
		{
			if (lexlevel <= 0)
			{
				return Missing.Value;
			}
			object memberValue = LateBinding.GetMemberValue2(contained_object, name);
			if (memberValue != Missing.Value)
			{
				return memberValue;
			}
			return ((IActivationObject)parent).GetMemberValue(name, lexlevel - 1);
		}

		[DebuggerStepThrough]
		[DebuggerHidden]
		internal override void SetMemberValue(string name, object value)
		{
			if (LateBinding.GetMemberValue2(contained_object, name) is Missing)
			{
				parent.SetMemberValue(name, value);
			}
			else
			{
				LateBinding.SetMemberValue(contained_object, name, value);
			}
		}
	}
	internal sealed class WrappedNamespace : ActivationObject
	{
		internal string name;

		internal WrappedNamespace(string name, VsaEngine engine)
			: this(name, engine, AddReferences: true)
		{
		}

		internal WrappedNamespace(string name, VsaEngine engine, bool AddReferences)
			: base(null)
		{
			this.name = name;
			base.engine = engine;
			isKnownAtCompileTime = true;
			if (name.Length > 0 && AddReferences)
			{
				engine.TryToAddImplicitAssemblyReference(name);
			}
		}

		public override MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
		{
			FieldInfo fieldInfo = (FieldInfo)name_table[name];
			if (fieldInfo != null)
			{
				return new MemberInfo[1] { fieldInfo };
			}
			FieldAttributes fieldAttributes = FieldAttributes.Literal;
			string text = ((this.name == null || this.name.Length == 0) ? name : (this.name + "." + name));
			object obj = null;
			if (this.name != null && this.name.Length > 0)
			{
				obj = engine.GetClass(text);
			}
			if (obj == null)
			{
				obj = engine.GetType(text);
				if (obj != null && !((Type)obj).IsPublic)
				{
					if ((bindingAttr & BindingFlags.NonPublic) == 0)
					{
						obj = null;
					}
					else
					{
						fieldAttributes |= FieldAttributes.Private;
					}
				}
			}
			else if ((((ClassScope)obj).owner.attributes & TypeAttributes.Public) == 0)
			{
				if ((bindingAttr & BindingFlags.NonPublic) == 0)
				{
					obj = null;
				}
				else
				{
					fieldAttributes |= FieldAttributes.Private;
				}
			}
			if (obj == null)
			{
				if (parent != null && (bindingAttr & BindingFlags.DeclaredOnly) == 0)
				{
					return parent.GetMember(name, bindingAttr);
				}
				return new MemberInfo[0];
			}
			JSGlobalField jSGlobalField = (JSGlobalField)CreateField(name, fieldAttributes, obj);
			if (engine.doFast)
			{
				jSGlobalField.type = new TypeExpression(new ConstantWrapper(Typeob.Type, null));
			}
			name_table[name] = jSGlobalField;
			field_table.Add(jSGlobalField);
			return new MemberInfo[1] { jSGlobalField };
		}

		public override string ToString()
		{
			return name;
		}
	}
}
namespace Microsoft.JScript.Vsa
{
	/// <summary>Implements <see cref="T:Microsoft.JScript.Vsa.IJSVsaEngine" /> interface.</summary>
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[Guid("F8932A50-9127-48B6-B115-2BFDC627CEE3")]
	[ComVisible(true)]
	public abstract class BaseVsaEngine : IJSVsaEngine
	{
		/// <summary>Provides enumeration for the <see cref="T:Microsoft.JScript.Vsa.BaseVsaEngine" /> class.</summary>
		[Flags]
		protected enum Pre
		{
			/// <summary>No engine is set.</summary>
			None = 0,
			/// <summary>The engine is not closed.</summary>
			EngineNotClosed = 1,
			/// <summary>The debug features are switched on.</summary>
			SupportForDebug = 2,
			/// <summary>The engine is compiled.</summary>
			EngineCompiled = 4,
			/// <summary>The engine is running.</summary>
			EngineRunning = 8,
			/// <summary>The engine is not running.</summary>
			EngineNotRunning = 0x10,
			/// <summary>The root moniker is set.</summary>
			RootMonikerSet = 0x20,
			/// <summary>The root moniker is not set.</summary>
			RootMonikerNotSet = 0x40,
			/// <summary>The root namespace is set.</summary>
			RootNamespaceSet = 0x80,
			/// <summary>The site is set.</summary>
			SiteSet = 0x100,
			/// <summary>The site is not set.</summary>
			SiteNotSet = 0x200,
			/// <summary>The engine is initialized.</summary>
			EngineInitialised = 0x400,
			/// <summary>The engine is not initialized.</summary>
			EngineNotInitialised = 0x800
		}

		/// <summary>Gets or sets the application path.</summary>
		protected string applicationPath;

		/// <summary>Gets or sets the loaded assembly.</summary>
		protected Assembly loadedAssembly;

		/// <summary>Gets or sets the compiled root namespace.</summary>
		protected string compiledRootNamespace;

		/// <summary>Gets or sets the engine site</summary>
		protected IJSVsaSite engineSite;

		/// <summary>Gets or sets a value that indicates whether debug information is generated.</summary>
		protected bool genDebugInfo;

		/// <summary>Gets or sets a value that indicates whether there is a compiled state.</summary>
		protected bool haveCompiledState;

		/// <summary>Gets or sets a value that indicates whether the compilation failed.</summary>
		protected bool failedCompilation;

		/// <summary>Gets or sets a value that indicates whether the engine is closed.</summary>
		protected bool isClosed;

		/// <summary>Gets or sets a value that indicates whether the engine is compiled.</summary>
		protected bool isEngineCompiled;

		/// <summary>Gets or sets a value that indicates whether debug information is supported.</summary>
		protected bool isDebugInfoSupported;

		/// <summary>Gets or sets a value that indicates whether the current in-memory representation of the item differs from the persisted representation.</summary>
		protected bool isEngineDirty;

		/// <summary>Gets or sets a value that indicates whether the engine is initialized.</summary>
		protected bool isEngineInitialized;

		/// <summary>Gets or sets a value that indicates whether the engine is running.</summary>
		protected bool isEngineRunning;

		/// <summary>Gets or sets the collection of IVsaItem objects.</summary>
		protected IJSVsaItems vsaItems;

		/// <summary>Gets or sets the script language.</summary>
		protected string scriptLanguage;

		/// <summary>Gets or sets the error locale.</summary>
		protected int errorLocale;

		/// <summary>Gets or sets the name table.</summary>
		protected static Hashtable nameTable = new Hashtable(10);

		/// <summary>Gets or sets the engine name.</summary>
		protected string engineName;

		/// <summary>Gets or sets the engine moniker.</summary>
		protected string engineMoniker;

		/// <summary>Gets or sets the root namespace.</summary>
		protected string rootNamespace;

		/// <summary>Gets or sets the startup class.</summary>
		protected Type startupClass;

		/// <summary>Gets or sets the startup instance.</summary>
		protected BaseVsaStartup startupInstance;

		/// <summary>Gets or sets the assembly version.</summary>
		protected string assemblyVersion;

		/// <summary>Gets or sets the execution evidence.</summary>
		protected Evidence executionEvidence;

		/// <summary>Gets or sets the application domain.</summary>
		/// <returns>The application domain.</returns>
		public _AppDomain AppDomain
		{
			get
			{
				Preconditions(Pre.EngineNotClosed);
				throw new NotSupportedException();
			}
			set
			{
				Preconditions(Pre.EngineNotClosed);
				throw new JSVsaException(JSVsaError.AppDomainCannotBeSet);
			}
		}

		/// <summary>Provides evidence for the purpose of validating the current object's identity.</summary>
		/// <returns>A reference to an Evidence object.</returns>
		public Evidence Evidence
		{
			[SecurityPermission(SecurityAction.Demand, ControlEvidence = true)]
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return executionEvidence;
			}
			[SecurityPermission(SecurityAction.Demand, ControlEvidence = true)]
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineNotRunning | Pre.EngineInitialised);
				executionEvidence = value;
			}
		}

		/// <summary>Gets or sets the application base.</summary>
		/// <returns>The application base.</returns>
		public string ApplicationBase
		{
			get
			{
				Preconditions(Pre.EngineNotClosed);
				throw new NotSupportedException();
			}
			set
			{
				Preconditions(Pre.EngineNotClosed);
				throw new JSVsaException(JSVsaError.ApplicationBaseCannotBeSet);
			}
		}

		/// <summary>Gets a reference to the running assembly generated by Run method.</summary>
		/// <returns>Reference to the currently running assembly.</returns>
		public Assembly Assembly
		{
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineRunning);
				return loadedAssembly;
			}
		}

		/// <summary>Sets or gets a Boolean value that signifies whether the script engine produces debug information when the Compile method is called.</summary>
		/// <returns>
		///   <see langword="true" /> to produce debug information; otherwise, <see langword="false" />.</returns>
		public bool GenerateDebugInfo
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return genDebugInfo;
			}
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set
			{
				TryObtainLock();
				try
				{
					Preconditions(Pre.EngineNotClosed | Pre.SupportForDebug | Pre.EngineNotRunning | Pre.EngineInitialised);
					if (genDebugInfo != value)
					{
						genDebugInfo = value;
						isEngineDirty = true;
						isEngineCompiled = false;
					}
				}
				finally
				{
					ReleaseLock();
				}
			}
		}

		/// <summary>Gets or sets a value that indicates whether the source is compiled.</summary>
		/// <returns>
		///   <see langword="true" /> if the source is compiled; otherwise, <see langword="false" />.</returns>
		public bool IsCompiled
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return isEngineCompiled;
			}
		}

		/// <summary>Gets or sets a value that indicates whether the current in-memory representation of the item differs from the persisted representation.</summary>
		/// <returns>
		///   <see langword="true" /> if the in-memory representation differs from the persisted representation; otherwise, <see langword="false" />.</returns>
		public bool IsDirty
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return isEngineDirty;
			}
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set
			{
				TryObtainLock();
				try
				{
					Preconditions(Pre.EngineNotClosed);
					isEngineDirty = value;
					if (isEngineDirty)
					{
						isEngineCompiled = false;
					}
				}
				finally
				{
					ReleaseLock();
				}
			}
		}

		/// <summary>Gets a Boolean value that reports whether the engine is currently in run mode.</summary>
		/// <returns>
		///   <see langword="true" /> if the engine is in run mode; otherwise, <see langword="false" />.</returns>
		public bool IsRunning
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return isEngineRunning;
			}
		}

		/// <summary>Gets the collection of IJSVsaItem objects, which represent all items added to the engine.</summary>
		/// <returns>The collection of items.</returns>
		public IJSVsaItems Items
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return vsaItems;
			}
		}

		/// <summary>Gets the name of the programming language supported by the engine.</summary>
		/// <returns>The name of the programming language.</returns>
		public string Language
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return scriptLanguage;
			}
		}

		/// <summary>Gets or sets the geographical locale and language in which to report exception messages.</summary>
		/// <returns>An integer value representing the locale in which exception messages are to be reported.</returns>
		public int LCID
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return errorLocale;
			}
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set
			{
				TryObtainLock();
				try
				{
					Preconditions(Pre.EngineNotClosed | Pre.EngineNotRunning | Pre.EngineInitialised);
					try
					{
						CultureInfo cultureInfo = new CultureInfo(value);
					}
					catch (ArgumentException)
					{
						throw Error(JSVsaError.LCIDNotSupported);
					}
					errorLocale = value;
					isEngineDirty = true;
				}
				finally
				{
					ReleaseLock();
				}
			}
		}

		/// <summary>Sets or gets the display name of the engine.</summary>
		/// <returns>The name of the engine.</returns>
		public string Name
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return engineName;
			}
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set
			{
				TryObtainLock();
				try
				{
					Preconditions(Pre.EngineNotClosed | Pre.EngineNotRunning | Pre.EngineInitialised);
					if (engineName == value)
					{
						return;
					}
					lock (nameTable)
					{
						if (nameTable[value] != null)
						{
							throw Error(JSVsaError.EngineNameInUse);
						}
						nameTable[value] = new object();
						if (engineName != null && engineName.Length > 0)
						{
							nameTable[engineName] = null;
						}
					}
					engineName = value;
					isEngineDirty = true;
					isEngineCompiled = false;
				}
				finally
				{
					ReleaseLock();
				}
			}
		}

		/// <summary>Sets or gets a script engine's root moniker.</summary>
		/// <returns>The root moniker of the engine.</returns>
		public string RootMoniker
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed);
				return engineMoniker;
			}
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set
			{
				TryObtainLock();
				try
				{
					Preconditions(Pre.EngineNotClosed | Pre.RootMonikerNotSet);
					ValidateRootMoniker(value);
					engineMoniker = value;
				}
				finally
				{
					ReleaseLock();
				}
			}
		}

		/// <summary>Sets or gets the root namespace used by the engine.</summary>
		/// <returns>The namespace of the engine.</returns>
		public string RootNamespace
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return rootNamespace;
			}
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set
			{
				TryObtainLock();
				try
				{
					Preconditions(Pre.EngineNotClosed | Pre.EngineNotRunning | Pre.EngineInitialised);
					if (!IsValidNamespaceName(value))
					{
						throw Error(JSVsaError.RootNamespaceInvalid);
					}
					rootNamespace = value;
					isEngineDirty = true;
					isEngineCompiled = false;
				}
				finally
				{
					ReleaseLock();
				}
			}
		}

		/// <summary>Sets or gets the host-implemented IJSVsaSite object that is used by the engine to communicate with the host.</summary>
		/// <returns>The host-implemented object.</returns>
		public IJSVsaSite Site
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.RootMonikerSet);
				return engineSite;
			}
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set
			{
				TryObtainLock();
				try
				{
					Preconditions(Pre.EngineNotClosed | Pre.RootMonikerSet | Pre.SiteNotSet);
					if (value == null)
					{
						throw Error(JSVsaError.SiteInvalid);
					}
					engineSite = value;
				}
				finally
				{
					ReleaseLock();
				}
			}
		}

		/// <summary>Gets the current version of the language compiler supported by the engine, in the form <c>Major.Minor.Revision.Build</c>.</summary>
		/// <returns>The current version.</returns>
		public string Version
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return assemblyVersion;
			}
		}

		internal BaseVsaEngine(string language, string version, bool supportDebug)
		{
			applicationPath = "";
			compiledRootNamespace = null;
			genDebugInfo = false;
			haveCompiledState = false;
			failedCompilation = false;
			isClosed = false;
			isEngineCompiled = false;
			isEngineDirty = false;
			isEngineInitialized = false;
			isEngineRunning = false;
			vsaItems = null;
			engineSite = null;
			errorLocale = CultureInfo.CurrentUICulture.LCID;
			engineName = "";
			rootNamespace = "";
			engineMoniker = "";
			scriptLanguage = language;
			assemblyVersion = version;
			isDebugInfoSupported = supportDebug;
			executionEvidence = null;
		}

		/// <summary>Returns an error.</summary>
		/// <param name="vsaErrorNumber">The error number to be returned.</param>
		/// <returns>An exception with the specified error number.</returns>
		protected JSVsaException Error(JSVsaError vsaErrorNumber)
		{
			return new JSVsaException(vsaErrorNumber);
		}

		internal void TryObtainLock()
		{
			if (!Monitor.TryEnter(this))
			{
				throw new JSVsaException(JSVsaError.EngineBusy);
			}
		}

		internal void ReleaseLock()
		{
			Monitor.Exit(this);
		}

		private bool IsCondition(Pre flag, Pre test)
		{
			return (flag & test) != 0;
		}

		/// <summary>Sets the precondition flags.</summary>
		/// <param name="flags">The flags to set.</param>
		protected void Preconditions(Pre flags)
		{
			if (isClosed)
			{
				throw Error(JSVsaError.EngineClosed);
			}
			if (flags != Pre.EngineNotClosed)
			{
				if (IsCondition(flags, Pre.SupportForDebug) && !isDebugInfoSupported)
				{
					throw Error(JSVsaError.DebugInfoNotSupported);
				}
				if (IsCondition(flags, Pre.EngineCompiled) && !haveCompiledState)
				{
					throw Error(JSVsaError.EngineNotCompiled);
				}
				if (IsCondition(flags, Pre.EngineRunning) && !isEngineRunning)
				{
					throw Error(JSVsaError.EngineNotRunning);
				}
				if (IsCondition(flags, Pre.EngineNotRunning) && isEngineRunning)
				{
					throw Error(JSVsaError.EngineRunning);
				}
				if (IsCondition(flags, Pre.RootMonikerSet) && engineMoniker == "")
				{
					throw Error(JSVsaError.RootMonikerNotSet);
				}
				if (IsCondition(flags, Pre.RootMonikerNotSet) && engineMoniker != "")
				{
					throw Error(JSVsaError.RootMonikerAlreadySet);
				}
				if (IsCondition(flags, Pre.RootNamespaceSet) && rootNamespace == "")
				{
					throw Error(JSVsaError.RootNamespaceNotSet);
				}
				if (IsCondition(flags, Pre.SiteSet) && engineSite == null)
				{
					throw Error(JSVsaError.SiteNotSet);
				}
				if (IsCondition(flags, Pre.SiteNotSet) && engineSite != null)
				{
					throw Error(JSVsaError.SiteAlreadySet);
				}
				if (IsCondition(flags, Pre.EngineInitialised) && !isEngineInitialized)
				{
					throw Error(JSVsaError.EngineNotInitialized);
				}
				if (IsCondition(flags, Pre.EngineNotInitialised) && isEngineInitialized)
				{
					throw Error(JSVsaError.EngineInitialized);
				}
			}
		}

		/// <summary>Closes the engine.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void Close()
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed);
				if (isEngineRunning)
				{
					Reset();
				}
				lock (nameTable)
				{
					if (engineName != null && engineName.Length > 0)
					{
						nameTable[engineName] = null;
					}
				}
				DoClose();
				isClosed = true;
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Causes the engine to compile the existing source state.</summary>
		/// <returns>
		///   <see langword="true" /> on successful compilation; otherwise, <see langword="false" />.</returns>
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual bool Compile()
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineNotRunning | Pre.RootNamespaceSet | Pre.EngineInitialised);
				bool flag = false;
				int num = 0;
				int count = vsaItems.Count;
				while (!flag && num < count)
				{
					IJSVsaItem iJSVsaItem = vsaItems[num];
					flag = vsaItems[num].ItemType == JSVsaItemType.Code;
					num++;
				}
				if (!flag)
				{
					throw Error(JSVsaError.EngineClosed);
				}
				try
				{
					ResetCompiledState();
					isEngineCompiled = DoCompile();
				}
				catch (JSVsaException)
				{
					throw;
				}
				catch (Exception ex2)
				{
					throw new JSVsaException(JSVsaError.InternalCompilerError, ex2.ToString(), ex2);
				}
				if (isEngineCompiled)
				{
					haveCompiledState = true;
					failedCompilation = false;
					compiledRootNamespace = rootNamespace;
				}
				return isEngineCompiled;
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Gets implementation-specific options for the engine.</summary>
		/// <param name="name">The name of the option to get.</param>
		/// <returns>The value of the option.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual object GetOption(string name)
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineInitialised);
				return GetCustomOption(name);
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Provides a notification that the initialization phase is complete.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void InitNew()
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed | Pre.RootMonikerSet | Pre.SiteSet | Pre.EngineNotInitialised);
				isEngineInitialized = true;
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Loads the compiled state.</summary>
		/// <returns>The compiled state.</returns>
		protected virtual Assembly LoadCompiledState()
		{
			DoSaveCompiledState(out var pe, out var debugInfo);
			return Assembly.Load(pe, debugInfo, executionEvidence);
		}

		/// <summary>Directs the engine to load source items from their point of persistence, as specified by the host-provided object.</summary>
		/// <param name="site">The site from which the specified source items is loaded.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void LoadSourceState(IJSVsaPersistSite site)
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed | Pre.RootMonikerSet | Pre.SiteSet | Pre.EngineNotInitialised);
				isEngineInitialized = true;
				try
				{
					DoLoadSourceState(site);
				}
				catch
				{
					isEngineInitialized = false;
					throw;
				}
				isEngineDirty = false;
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Removes the engine from the running state and disconnects automatically bound event handlers.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void Reset()
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineRunning);
				try
				{
					startupInstance.Shutdown();
				}
				catch (Exception ex)
				{
					throw new JSVsaException(JSVsaError.EngineCannotReset, ex.ToString(), ex);
				}
				isEngineRunning = false;
				loadedAssembly = null;
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Invalidates the cached assembly for the engine, as specified by its root moniker.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void RevokeCache()
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineNotRunning | Pre.RootMonikerSet);
				try
				{
					System.AppDomain.CurrentDomain.SetData(engineMoniker, null);
				}
				catch (Exception ex)
				{
					throw new JSVsaException(JSVsaError.RevokeFailed, ex.ToString(), ex);
				}
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Initiates execution of compiled code in the engine and binds all event handlers</summary>
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void Run()
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineNotRunning | Pre.RootMonikerSet | Pre.RootNamespaceSet | Pre.SiteSet);
				AppDomain currentDomain = System.AppDomain.CurrentDomain;
				if (haveCompiledState)
				{
					if (rootNamespace != compiledRootNamespace)
					{
						throw new JSVsaException(JSVsaError.RootNamespaceInvalid);
					}
					loadedAssembly = LoadCompiledState();
					currentDomain.SetData(engineMoniker, loadedAssembly);
				}
				else
				{
					if (failedCompilation)
					{
						throw new JSVsaException(JSVsaError.EngineNotCompiled);
					}
					startupClass = null;
					loadedAssembly = currentDomain.GetData(engineMoniker) as Assembly;
					if (loadedAssembly == null)
					{
						string name = engineMoniker + "/" + currentDomain.GetHashCode().ToString(CultureInfo.InvariantCulture);
						Mutex mutex = new Mutex(initiallyOwned: false, name);
						if (mutex.WaitOne())
						{
							try
							{
								loadedAssembly = currentDomain.GetData(engineMoniker) as Assembly;
								if (loadedAssembly == null)
								{
									engineSite.GetCompiledState(out var pe, out var debugInfo);
									if (pe == null)
									{
										throw new JSVsaException(JSVsaError.GetCompiledStateFailed);
									}
									loadedAssembly = Assembly.Load(pe, debugInfo, executionEvidence);
									currentDomain.SetData(engineMoniker, loadedAssembly);
								}
							}
							finally
							{
								mutex.ReleaseMutex();
								mutex.Close();
							}
						}
					}
				}
				try
				{
					if (startupClass == null)
					{
						startupClass = loadedAssembly.GetType(rootNamespace + "._Startup", throwOnError: true);
					}
				}
				catch (Exception ex)
				{
					throw new JSVsaException(JSVsaError.BadAssembly, ex.ToString(), ex);
				}
				try
				{
					startupInstance = (BaseVsaStartup)Activator.CreateInstance(startupClass);
					isEngineRunning = true;
					startupInstance.SetSite(engineSite);
					startupInstance.Startup();
				}
				catch (Exception ex2)
				{
					throw new JSVsaException(JSVsaError.UnknownError, ex2.ToString(), ex2);
				}
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Sets implementation-specific options for the engine.</summary>
		/// <param name="name">The name of the option to set.</param>
		/// <param name="value">The value for the option being set.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void SetOption(string name, object value)
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineNotRunning | Pre.EngineInitialised);
				SetCustomOption(name, value);
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Saves the compiled state of the engine; optionally, it also saves debugging information.</summary>
		/// <param name="pe">The compiled state of the script engine.</param>
		/// <param name="debugInfo">Specifies debugging information contained in the .PDB file corresponding to the PE (portable executable).</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void SaveCompiledState(out byte[] pe, out byte[] debugInfo)
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineCompiled | Pre.EngineNotRunning | Pre.EngineInitialised);
				DoSaveCompiledState(out pe, out debugInfo);
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Directs the engine to persist its source state.</summary>
		/// <param name="site">The site to which source state is saved.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void SaveSourceState(IJSVsaPersistSite site)
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed | Pre.EngineNotRunning | Pre.EngineInitialised);
				if (site == null)
				{
					throw Error(JSVsaError.SiteInvalid);
				}
				try
				{
					DoSaveSourceState(site);
				}
				catch (Exception ex)
				{
					throw new JSVsaException(JSVsaError.SaveElementFailed, ex.ToString(), ex);
				}
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>Validates the root moniker.</summary>
		/// <param name="rootMoniker">The root moniker to validate.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		protected virtual void ValidateRootMoniker(string rootMoniker)
		{
			if (rootMoniker == null)
			{
				throw new JSVsaException(JSVsaError.RootMonikerInvalid);
			}
			Uri uri = null;
			try
			{
				uri = new Uri(rootMoniker);
			}
			catch (UriFormatException)
			{
				throw new JSVsaException(JSVsaError.RootMonikerInvalid);
			}
			string scheme = uri.Scheme;
			if (scheme.Length == 0)
			{
				throw new JSVsaException(JSVsaError.RootMonikerProtocolInvalid);
			}
			string[] array = new string[18]
			{
				"file", "ftp", "gopher", "http", "https", "javascript", "mailto", "microsoft", "news", "res",
				"smtp", "socks", "vbscript", "xlang", "xml", "xpath", "xsd", "xsl"
			};
			try
			{
				RegistryPermission registryPermission = new RegistryPermission(RegistryPermissionAccess.Read, "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\PROTOCOLS\\Handler");
				registryPermission.Assert();
				RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Classes\\PROTOCOLS\\Handler");
				array = registryKey.GetSubKeyNames();
			}
			catch
			{
			}
			string[] array2 = array;
			foreach (string strA in array2)
			{
				if (string.Compare(strA, scheme, StringComparison.OrdinalIgnoreCase) == 0)
				{
					throw new JSVsaException(JSVsaError.RootMonikerProtocolInvalid);
				}
			}
		}

		/// <summary>Closes the engine.</summary>
		protected abstract void DoClose();

		/// <summary>Causes the script engine to compile the existing source state.</summary>
		/// <returns>
		///   <see langword="true" /> on successful compilation; otherwise, <see langword="false" />.</returns>
		protected abstract bool DoCompile();

		/// <summary>Directs the engine to load source items.</summary>
		/// <param name="site">The site from which the specified source items are loaded.</param>
		protected abstract void DoLoadSourceState(IJSVsaPersistSite site);

		/// <summary>Saves the compiled state of the script engine; optionally, it also saves debugging information.</summary>
		/// <param name="pe">The compiled state of the engine.</param>
		/// <param name="debugInfo">Specifies debugging information contained in the .PDB file.</param>
		protected abstract void DoSaveCompiledState(out byte[] pe, out byte[] debugInfo);

		/// <summary>Directs the script engine to persist its source state to the specified object.</summary>
		/// <param name="site">The site to which source state is saved.</param>
		protected abstract void DoSaveSourceState(IJSVsaPersistSite site);

		/// <summary>Gets implementation-specific options for the engine.</summary>
		/// <param name="name">The name of the option to get.</param>
		/// <returns>The value of the option.</returns>
		protected abstract object GetCustomOption(string name);

		/// <summary>Checks whether the supplied namespace is valid for the engine.</summary>
		/// <param name="name">A string value provided as identifier.</param>
		/// <returns>
		///   <see langword="true" /> if the namespace is valid; otherwise, it returns <see langword="false" />.</returns>
		protected abstract bool IsValidNamespaceName(string name);

		/// <summary>Checks whether the supplied identifier is valid for the engine.</summary>
		/// <param name="ident">A string value provided as identifier.</param>
		/// <returns>
		///   <see langword="true" /> if the identifier is valid; otherwise, it returns <see langword="false" />.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public abstract bool IsValidIdentifier(string ident);

		/// <summary>Resets the compiled state.</summary>
		protected abstract void ResetCompiledState();

		/// <summary>Sets implementation-specific options for the engine.</summary>
		/// <param name="name">The name of the option to set.</param>
		/// <param name="value">The value for the option being set.</param>
		protected abstract void SetCustomOption(string name, object value);
	}
	/// <summary>Enables communication between the host and the script engine.</summary>
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	public class BaseVsaSite : IJSVsaSite
	{
		/// <summary>An assembly for this site.</summary>
		/// <returns>An assembly for this site.</returns>
		public virtual byte[] Assembly
		{
			get
			{
				throw new JSVsaException(JSVsaError.GetCompiledStateFailed);
			}
		}

		/// <summary>Debug information for this site.</summary>
		/// <returns>Debug information for this site.</returns>
		public virtual byte[] DebugInfo => null;

		/// <summary>Sets an assembly and debug info for this site.</summary>
		/// <param name="pe">An assembly to be set.</param>
		/// <param name="debugInfo">Debug info object to be set.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void GetCompiledState(out byte[] pe, out byte[] debugInfo)
		{
			pe = Assembly;
			debugInfo = DebugInfo;
		}

		/// <summary>Gets a reference to an event source previously added to a script engine using the <see cref="M:Microsoft.JScript.Vsa.IJSVsaCodeItem.AddEventSource(System.String,System.String)" /> method.</summary>
		/// <param name="itemName">The specified item name.</param>
		/// <param name="eventSourceName">The specified event source name.</param>
		/// <returns>The event source to the engine.</returns>
		public virtual object GetEventSourceInstance(string itemName, string eventSourceName)
		{
			throw new JSVsaException(JSVsaError.CallbackUnexpected);
		}

		/// <summary>Gets a reference to a global item, such as the host-provided application object.</summary>
		/// <param name="name">Gets a reference to a global item, such as the host-provided application object.</param>
		/// <returns>A reference to the global object.</returns>
		public virtual object GetGlobalInstance(string name)
		{
			throw new JSVsaException(JSVsaError.CallbackUnexpected);
		}

		/// <summary>Notifies the host about events generated by the script engine.</summary>
		/// <param name="notify">Notifies the host about events generated by the script engine.</param>
		/// <param name="optional">Notifies the host about events generated by the engine.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual void Notify(string notify, object optional)
		{
			throw new JSVsaException(JSVsaError.CallbackUnexpected);
		}

		/// <summary>Notifies the host about how to respond to compiler errors encountered by the script engine.</summary>
		/// <param name="error">The <see cref="T:Microsoft.JScript.Vsa.IJSVsaError" /> object representing the offending error.</param>
		/// <returns>
		///   <see langword="true" /> if the compiler is directed to continue reporting further errors to the <see cref="T:Microsoft.JScript.Vsa.IJSVsaSite" /> object; <see langword="false" /> if the compiler is directed to stop reporting further errors to the <see langword="IVsaSite" /> object.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public virtual bool OnCompilerError(IJSVsaError error)
		{
			return false;
		}

		/// <summary>Creates a new site.</summary>
		public BaseVsaSite()
		{
		}
	}
	/// <summary>Used to start and reset base VSA engine.</summary>
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	public abstract class BaseVsaStartup
	{
		/// <summary>The VSA site for this engine.</summary>
		protected IJSVsaSite site;

		/// <summary>Sets a VSA site for this engine.</summary>
		/// <param name="site">A VSA site for this engine.</param>
		public void SetSite(IJSVsaSite site)
		{
			this.site = site;
		}

		/// <summary>Used to perform operations at engine startup.</summary>
		public abstract void Startup();

		/// <summary>Used to perform operations at engine shut down.</summary>
		public abstract void Shutdown();

		/// <summary>Creates a new object of this class.</summary>
		protected BaseVsaStartup()
		{
		}
	}
	internal static class VsaObsolete
	{
		internal const string Description = "Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.";
	}
	/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	public class ResInfo
	{
		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public string filename;

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public string fullpath;

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public string name;

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public bool isPublic;

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public bool isLinked;

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="filename" />
		/// <param name="name" />
		/// <param name="isPublic" />
		/// <param name="isLinked" />
		public ResInfo(string filename, string name, bool isPublic, bool isLinked)
		{
			this.filename = filename;
			fullpath = Path.GetFullPath(filename);
			this.name = name;
			this.isPublic = isPublic;
			this.isLinked = isLinked;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="resinfo" />
		/// <param name="isLinked" />
		public ResInfo(string resinfo, bool isLinked)
		{
			string[] array = resinfo.Split(',');
			int num = array.Length;
			filename = array[0];
			name = Path.GetFileName(filename);
			isPublic = true;
			this.isLinked = isLinked;
			if (num == 2)
			{
				name = array[1];
			}
			else if (num > 2)
			{
				bool flag = false;
				if (string.Compare(array[num - 1], "public", StringComparison.OrdinalIgnoreCase) == 0)
				{
					flag = true;
				}
				else if (string.Compare(array[num - 1], "private", StringComparison.OrdinalIgnoreCase) == 0)
				{
					isPublic = false;
					flag = true;
				}
				name = array[num - ((!flag) ? 1 : 2)];
				filename = string.Join(",", array, 0, num - ((!flag) ? 1 : 2));
			}
			fullpath = Path.GetFullPath(filename);
		}
	}
	/// <summary>Represents the type of the item.</summary>
	[Guid("97453226-34DD-4379-B658-005DF8F84EA1")]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public enum JSVsaItemType
	{
		/// <summary>Used to add a reference to an external .NET assembly, which can then be referenced from code. This type is used to create an IJSVsaReferenceItem object</summary>
		Reference,
		/// <summary>Used to add a global object to the .NET script engine. This type is used to create an IJSVsaGlobalItem object.</summary>
		AppGlobal,
		/// <summary>Used to create a code item for storing source code for the .NET script engine.</summary>
		Code
	}
	/// <summary>Identifies the type of code item as Class, Module, or None.</summary>
	[Guid("55BB0B6C-7629-4824-97FF-78A6928E92A7")]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public enum JSVsaItemFlag
	{
		/// <summary>Used when the code item is a class.</summary>
		None,
		/// <summary>Used when the code item is a module.</summary>
		Module,
		/// <summary>Used when the code item is generic or when the item type does not accept flags. In such cases, no special flags are required to create the item.</summary>
		Class
	}
	/// <summary>Defines the methods and properties that a script engine must support and provides programmatic access to the script engine.</summary>
	[Guid("8FA2C97B-47E4-4A31-A7F5-FF39D1195CD9")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public interface IJSVsaEngine
	{
		/// <summary>Sets or gets the host-implemented IJSVsaSite object that is used by the script engine to communicate with the host.</summary>
		/// <returns>The host-implemented object.</returns>
		IJSVsaSite Site
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}

		/// <summary>Sets or gets the display name of the script engine.</summary>
		/// <returns>The name of the engine.</returns>
		string Name
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}

		/// <summary>Sets or gets a script engine's root moniker.</summary>
		/// <returns>The root moniker of the engine.</returns>
		string RootMoniker
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}

		/// <summary>Sets or gets the root namespace used by the script engine.</summary>
		/// <returns>The namespace of the engine.</returns>
		string RootNamespace
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}

		/// <summary>Gets or sets the geographical locale and language in which to report exception messages.</summary>
		/// <returns>An integer value representing the locale in which exception messages are to be reported.</returns>
		int LCID
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}

		/// <summary>Sets or gets a Boolean value that signifies whether the script engine produces debug information when the Compile method is called.</summary>
		/// <returns>
		///   <see langword="true" /> to produce debug information; otherwise, <see langword="false" />.</returns>
		bool GenerateDebugInfo
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}

		/// <summary>Provides evidence for the purpose of validating the current object's identity.</summary>
		/// <returns>A reference to an Evidence object.</returns>
		Evidence Evidence
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}

		/// <summary>Gets the collection of IJSVsaItem objects, which represent all items added to the script engine.</summary>
		/// <returns>The collection of items.</returns>
		IJSVsaItems Items
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets or sets a value that indicates whether the current in-memory representation of the item differs from the persisted representation.</summary>
		/// <returns>
		///   <see langword="true" /> if the in-memory representation differs from the persisted representation; otherwise, <see langword="false" />.</returns>
		bool IsDirty
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets the name of the programming language supported by the script engine.</summary>
		/// <returns>The name of the programming language.</returns>
		string Language
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets the current version of the language compiler supported by the script engine, in the form <c>Major.Minor.Revision.Build</c>.</summary>
		/// <returns>The current version.</returns>
		string Version
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets a Boolean value that reports whether the script engine is currently in run mode.</summary>
		/// <returns>
		///   <see langword="true" /> if the engine is in run mode; otherwise, <see langword="false" />.</returns>
		bool IsRunning
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets or sets a value that indicates whether the source is compiled.</summary>
		/// <returns>
		///   <see langword="true" /> if the source is compiled; otherwise, <see langword="false" />.</returns>
		bool IsCompiled
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets a reference to the running assembly generated by Run method.</summary>
		/// <returns>Reference to the currently running assembly.</returns>
		Assembly Assembly { get; }

		/// <summary>Gets implementation-specific options for the engine.</summary>
		/// <param name="name">The name of the option to get.</param>
		/// <returns>The value of the option.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		object GetOption(string name);

		/// <summary>Sets implementation-specific options for a script engine.</summary>
		/// <param name="name">The name of the option to set.</param>
		/// <param name="value">The value for the option being set.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void SetOption(string name, object value);

		/// <summary>Causes the engine to compile the existing source state.</summary>
		/// <returns>
		///   <see langword="true" /> on successful compilation; otherwise, <see langword="false" />.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		bool Compile();

		/// <summary>Initiates execution of compiled code in the script engine and binds all event handlers.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void Run();

		/// <summary>Removes the script engine from the running state and disconnects automatically bound event handlers.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void Reset();

		/// <summary>Closes the engine.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void Close();

		/// <summary>Invalidates the cached assembly for the engine, as specified by its root moniker.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void RevokeCache();

		/// <summary>Directs the script engine to persist its source state.</summary>
		/// <param name="site">The site to which source state is saved.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void SaveSourceState(IJSVsaPersistSite site);

		/// <summary>Directs the engine to load source items from their point of persistence, as specified by the host-provided object.</summary>
		/// <param name="site">The site from which the specified source items is loaded.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void LoadSourceState(IJSVsaPersistSite site);

		/// <summary>Saves the compiled state of the script engine; optionally, it also saves debugging information.</summary>
		/// <param name="pe">The compiled state of the script engine.</param>
		/// <param name="pdb">Specifies debugging information contained in the .PDB file corresponding to the PE (portable executable).</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void SaveCompiledState(out byte[] pe, out byte[] pdb);

		/// <summary>Provides a notification that the initialization phase is complete.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void InitNew();

		/// <summary>Checks whether the supplied identifier is valid for the engine.</summary>
		/// <param name="identifier">A string value provided as identifier.</param>
		/// <returns>
		///   <see langword="true" /> if the identifier is valid; otherwise, it returns <see langword="false" />.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		bool IsValidIdentifier(string identifier);
	}
	/// <summary>Enables communication between the host and the script engine. This interface is implemented by the host.</summary>
	[Guid("605A62B5-3BA8-49E0-A056-0A6A7A5846A3")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public interface IJSVsaSite
	{
		/// <summary>Gets the compiled state of a script engine, and, optionally, associated debugging information.</summary>
		/// <param name="pe">The compiled state of the engine; an assembly in byte form.</param>
		/// <param name="debugInfo">The debugging information for the assembly, or a null reference if such information does not exist or is not available.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void GetCompiledState(out byte[] pe, out byte[] debugInfo);

		/// <summary>Notifies the host about how to respond to compiler errors encountered by the script engine.</summary>
		/// <param name="error">The <see cref="T:Microsoft.JScript.Vsa.IJSVsaError" /> object representing the offending error.</param>
		/// <returns>
		///   <see langword="true" /> if the compiler is directed to continue reporting further errors to the <see cref="T:Microsoft.JScript.Vsa.IJSVsaSite" /> object; <see langword="false" /> if the compiler is directed to stop reporting further errors to the <see langword="IVsaSite" /> object.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		bool OnCompilerError(IJSVsaError error);

		/// <summary>Gets a reference to a global item, such as the host-provided application object.</summary>
		/// <param name="name">Gets a reference to a global item, such as the host-provided application object.</param>
		/// <returns>A reference to the global object.</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		object GetGlobalInstance(string name);

		/// <summary>Gets a reference to an event source previously added to a script engine using the <see cref="M:Microsoft.JScript.Vsa.IJSVsaCodeItem.AddEventSource(System.String,System.String)" /> method.</summary>
		/// <param name="itemName">The specified item name.</param>
		/// <param name="eventSourceName">The specified event source name.</param>
		/// <returns>The event source to the engine.</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		object GetEventSourceInstance(string itemName, string eventSourceName);

		/// <summary>Notifies the host about events generated by the .NET script engine.</summary>
		/// <param name="notify">Notifies the host about events generated by the .NET script engine.</param>
		/// <param name="info">Notifies the host about events generated by the .NET script engine.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void Notify(string notify, object info);
	}
	/// <summary>Manages project persistence and stores and retrieves code and other items using save and load operations implemented by the host.</summary>
	[Guid("F901A1FF-8EBA-4C38-B6E0-E7E52606D325")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public interface IJSVsaPersistSite
	{
		/// <summary>Saves an arbitrary source string with a given name parameter, which can then be used in a call to the <see cref="M:Microsoft.JScript.Vsa.IJSVsaPersistSite.LoadElement(System.String)" /> method to reload the string.</summary>
		/// <param name="name">A name to associate with the specified source item. This can be a null reference when saving the Project file.</param>
		/// <param name="source">The source string for the item.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void SaveElement(string name, string source);

		/// <summary>Gets the source string previously saved using the <see cref="M:Microsoft.JScript.Vsa.IJSVsaPersistSite.SaveElement(System.String,System.String)" /> method.</summary>
		/// <param name="name">The name of the code item to be loaded. This can be a null reference when loading the Project file.</param>
		/// <returns>The contents of the source-code element associated with the name parameter.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		string LoadElement(string name);
	}
	/// <summary>Provides access to compilation errors encountered during execution.</summary>
	[Guid("425EA439-6417-4F3E-BCC9-1AFAC79E3F66")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public interface IJSVsaError
	{
		/// <summary>Gets the line number on which an error occurs.</summary>
		/// <returns>The line number on which the error has occurred.</returns>
		int Line
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Sets the severity of the error.</summary>
		/// <returns>An integer (0-4) that represents the error severity.</returns>
		int Severity
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets a brief description of the error, in some instances returning a reference to the token in the source code that is causing the error.</summary>
		/// <returns>A string literal description of the error.</returns>
		string Description
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets the text of the source code from the line that caused the error.</summary>
		/// <returns>The string literal source code from the line that caused the error.</returns>
		string LineText
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets a reference to the <see cref="T:Microsoft.JScript.Vsa.IJSVsaItem" /> object that generated the error.</summary>
		/// <returns>A reference to the object that generated the error.</returns>
		IJSVsaItem SourceItem
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets the ending column number for the source text that caused the error, if available.</summary>
		/// <returns>The ending column number for the source text that caused the error, if available.</returns>
		int EndColumn
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets the starting column number for the source text that caused the error, if available.</summary>
		/// <returns>The starting column number for the source text that caused the error, if available.</returns>
		int StartColumn
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets a number that uniquely identifies the error.</summary>
		/// <returns>The number that uniquely identifies the error.</returns>
		int Number
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets the fully qualified name of the source item that contained the error, in a format recognizable by the script engine.</summary>
		/// <returns>The fully qualified name of the source item that contained the error.</returns>
		string SourceMoniker
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}
	}
	/// <summary>Defines an interface for all items added to the .NET script engine, including code items, reference items, and global items. It defines generic properties and methods that apply to all item types recognized by the engine.</summary>
	[Guid("1F2377AC-8A09-417B-89DC-D146769F0B45")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public interface IJSVsaItem
	{
		/// <summary>Sets or gets the name of the item.</summary>
		/// <returns>The string literal name of the item.</returns>
		string Name
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}

		/// <summary>Gets the specified object's type, as determined by the <see cref="M:Microsoft.JScript.Vsa.IJSVsaItems.CreateItem(System.String,Microsoft.JScript.Vsa.JSVsaItemType,Microsoft.JScript.Vsa.JSVsaItemFlag)" /> method.</summary>
		/// <returns>A type as enumerated by the <see cref="T:Microsoft.JScript.Vsa.JSVsaItemType" /> enumeration.</returns>
		JSVsaItemType ItemType
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Returns a value indicating whether the current in-memory representation of the item differs from the persisted representation.</summary>
		/// <returns>
		///   <see langword="true" /> if the item is dirty, and thus requires saving; <see langword="false" /> if the item is not dirty.</returns>
		bool IsDirty
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets implementation-specific options for a script engine.</summary>
		/// <param name="name">The name of the option to retrieve.</param>
		/// <returns>The value of the specified option.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		object GetOption(string name);

		/// <summary>Sets implementation-specific options for a script engine.</summary>
		/// <param name="name">The name of the option to set.</param>
		/// <param name="value">A new value for the option.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void SetOption(string name, object value);
	}
	/// <summary>Defines an interface for a collection of <see cref="T:Microsoft.JScript.Vsa.IJSVsaItem" /> objects, which can be addressed either by name or by index.</summary>
	[Guid("172341E0-9B0D-43E6-9EFF-75E030A46461")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public interface IJSVsaItems : IEnumerable
	{
		/// <summary>Gets the number of items in the specified collection.</summary>
		/// <returns>The number of items in the collection.</returns>
		int Count
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets an item from the collection by its name.</summary>
		/// <param name="name">The name of the item to retrieve from the collection.</param>
		/// <returns>The item specified by name.</returns>
		IJSVsaItem this[string name]
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Gets an item from the collection by its index value.</summary>
		/// <param name="index">A 0-based index of the retrievable items.</param>
		/// <returns>The item at the specified index.</returns>
		IJSVsaItem this[int index]
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Creates a new instance of one of the <see cref="T:Microsoft.JScript.Vsa.IJSVsaItem" /> types, as defined in the <see cref="T:Microsoft.JScript.Vsa.JSVsaItemType" /> enumeration.</summary>
		/// <param name="name">The name to associate with the new item.  
		///  In cases where the item is a reference item type, the name parameter must be exactly the same as the name of the referenced assembly, as set with the <see cref="P:Microsoft.JScript.Vsa.IJSVsaReferenceItem.AssemblyName" /> property. In JScript, however, if you do not specify an AssemblyName, JScript will use the ItemName as the name of the assembly.</param>
		/// <param name="itemType">The type of item created, as defined in the <see cref="T:Microsoft.JScript.Vsa.JSVsaItemType" /> enumeration.</param>
		/// <param name="itemFlag">The optional flag to specify the initial content of a Code item.</param>
		/// <returns>A reference to the <see cref="T:Microsoft.JScript.Vsa.IJSVsaItem" /> object created.</returns>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		IJSVsaItem CreateItem(string name, JSVsaItemType itemType, JSVsaItemFlag itemFlag);

		/// <summary>Removes an item from the collection, as specified by its name.</summary>
		/// <param name="name">The name of the item to be removed from the collection.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void Remove(string name);

		/// <summary>Removes an item from the collection, as specified by its index value.</summary>
		/// <param name="index">The index value of the item to be removed.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void Remove(int index);
	}
	/// <summary>Describes a reference added to the script engine.</summary>
	[Guid("8EFD265B-677A-4B09-A471-E086787AA727")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public interface IJSVsaReferenceItem : IJSVsaItem
	{
		/// <summary>Gets or sets the name of the referenced assembly.</summary>
		/// <returns>The string literal name of the referenced assembly.</returns>
		string AssemblyName
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}
	}
	/// <summary>Represents a code item to be compiled by the script engine.</summary>
	[Guid("528BBC87-CCDC-4F07-B29C-9B10575DEB2F")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public interface IJSVsaCodeItem : IJSVsaItem
	{
		/// <summary>Sets or gets the text of a specified code item, including auto-generated code, if any.</summary>
		/// <returns>The source text of the code item.</returns>
		string SourceText
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}

		/// <summary>Gets the code document object model (CodeDOM) represented in the code item.</summary>
		/// <returns>The CodeDOM for the code item.</returns>
		CodeObject CodeDOM
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
		}

		/// <summary>Appends specified text to the end of the code item.</summary>
		/// <param name="text">The text to be appended to the code item.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void AppendSourceText(string text);

		/// <summary>Adds an event source to the code item. The code item uses the event source to hook up an event to the named event source by calling the IVsaSite.GetEventSourceInstance method, which is implemented by the host.</summary>
		/// <param name="eventSourceName">A programmatic name of the event source.</param>
		/// <param name="eventSourceType">The type name of the event source.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void AddEventSource(string eventSourceName, string eventSourceType);

		/// <summary>Removes the specified event source from the code item.</summary>
		/// <param name="eventSourceName">The programmatic name of the event source to be removed.</param>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		void RemoveEventSource(string eventSourceName);
	}
	/// <summary>Describes global objects added to the script engine.</summary>
	[Guid("15B2CCE5-D1EA-4EB9-9E06-8729C72D631B")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public interface IJSVsaGlobalItem : IJSVsaItem
	{
		/// <summary>Gets or sets the type of the global item.</summary>
		/// <returns>The item type of the global item.</returns>
		string TypeString
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}

		/// <summary>Sets a value indicating whether the members of the global object should be made available to the script engine. [Not presently supported.]</summary>
		/// <returns>Returns TRUE if public members of the global object are available to the script engine without qualification, as if they are part of the global namespace. Returns FALSE if a member of the global object must be qualified with the object's name.</returns>
		bool ExposeMembers
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get;
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			set;
		}
	}
	/// <summary>Defines the set of exceptions that can be thrown by a .NET script engine.</summary>
	[Guid("7607D148-3AA5-4CC6-AED5-D4DB0ECBD992")]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	public enum JSVsaError
	{
		/// <summary>Value: 0x80133000</summary>
		AppDomainCannotBeSet = -2146226176,
		/// <summary>Value: 0x80133001</summary>
		AppDomainInvalid = -2146226175,
		/// <summary>Value: 0x80133002</summary>
		ApplicationBaseCannotBeSet = -2146226174,
		/// <summary>Value: 0x80133003</summary>
		ApplicationBaseInvalid = -2146226173,
		/// <summary>Value: 0x80133004</summary>
		AssemblyExpected = -2146226172,
		/// <summary>Value: 0x80133005</summary>
		AssemblyNameInvalid = -2146226171,
		/// <summary>Value: 0x80133006</summary>
		BadAssembly = -2146226170,
		/// <summary>Value: 0x80133007</summary>
		CachedAssemblyInvalid = -2146226169,
		/// <summary>Value: 0x80133008</summary>
		CallbackUnexpected = -2146226168,
		/// <summary>Value: 0x80133009</summary>
		CodeDOMNotAvailable = -2146226167,
		/// <summary>Value: 0x8013300A</summary>
		CompiledStateNotFound = -2146226166,
		/// <summary>Value: 0x8013300B</summary>
		DebugInfoNotSupported = -2146226165,
		/// <summary>Value: 0x8013300C</summary>
		ElementNameInvalid = -2146226164,
		/// <summary>Value: 0x8013300D</summary>
		ElementNotFound = -2146226163,
		/// <summary>Value: 0x8013300E</summary>
		EngineBusy = -2146226162,
		/// <summary>Value: 0x8013300F</summary>
		EngineCannotClose = -2146226161,
		/// <summary>Value: 0x80133010</summary>
		EngineCannotReset = -2146226160,
		/// <summary>Value: 0x80133011</summary>
		EngineClosed = -2146226159,
		/// <summary>Value: 0x80133012</summary>
		EngineEmpty = -2146226159,
		/// <summary>Value: 0x80133013</summary>
		EngineInitialized = -2146226157,
		/// <summary>Value: 0x80133014</summary>
		EngineNameInUse = -2146226156,
		/// <summary>Value: 0x80133015</summary>
		EngineNotCompiled = -2146226155,
		/// <summary>Value: 0x80133016</summary>
		EngineNotInitialized = -2146226154,
		/// <summary>Value: 0x80133017</summary>
		EngineNotRunning = -2146226153,
		/// <summary>Value: 0x80133018</summary>
		EngineRunning = -2146226152,
		/// <summary>Value: 0x80133019</summary>
		EventSourceInvalid = -2146226151,
		/// <summary>Value: 0x8013301A</summary>
		EventSourceNameInUse = -2146226150,
		/// <summary>Value: 0x8013301B</summary>
		EventSourceNameInvalid = -2146226149,
		/// <summary>Value: 0x8013301C</summary>
		EventSourceNotFound = -2146226148,
		/// <summary>Value: 0x8013301D</summary>
		EventSourceTypeInvalid = -2146226147,
		/// <summary>Value: 0x8013301E</summary>
		GetCompiledStateFailed = -2146226146,
		/// <summary>Value: 0x8013301F</summary>
		GlobalInstanceInvalid = -2146226145,
		/// <summary>Value: 0x80133020</summary>
		GlobalInstanceTypeInvalid = -2146226144,
		/// <summary>Value: 0x80133021</summary>
		InternalCompilerError = -2146226143,
		/// <summary>Value: 0x80133022</summary>
		ItemCannotBeRemoved = -2146226142,
		/// <summary>Value: 0x80133023</summary>
		ItemFlagNotSupported = -2146226141,
		/// <summary>Value: 0x80133024</summary>
		ItemNameInUse = -2146226140,
		/// <summary>Value: 0x80133025</summary>
		ItemNameInvalid = -2146226139,
		/// <summary>Value: 0x80133026</summary>
		ItemNotFound = -2146226138,
		/// <summary>Value: 0x80133027</summary>
		ItemTypeNotSupported = -2146226137,
		/// <summary>Value: 0x80133028</summary>
		LCIDNotSupported = -2146226136,
		/// <summary>Value: 0x80133029</summary>
		LoadElementFailed = -2146226135,
		/// <summary>Value: 0x8013302A</summary>
		NotificationInvalid = -2146226134,
		/// <summary>Value: 0x8013302B</summary>
		OptionInvalid = -2146226133,
		/// <summary>Value: 0x8013302C</summary>
		OptionNotSupported = -2146226132,
		/// <summary>Value: 0x8013302D</summary>
		RevokeFailed = -2146226131,
		/// <summary>Value: 0x8013302E</summary>
		RootMonikerAlreadySet = -2146226130,
		/// <summary>Value: 0x8013302F</summary>
		RootMonikerInUse = -2146226129,
		/// <summary>Value: 0x80133030</summary>
		RootMonikerInvalid = -2146226128,
		/// <summary>Value: 0x80133031</summary>
		RootMonikerNotSet = -2146226127,
		/// <summary>Value: 0x80133032</summary>
		RootMonikerProtocolInvalid = -2146226126,
		/// <summary>Value: 0x80133033</summary>
		RootNamespaceInvalid = -2146226125,
		/// <summary>Value: 0x80133034</summary>
		RootNamespaceNotSet = -2146226124,
		/// <summary>Value: 0x80133035</summary>
		SaveCompiledStateFailed = -2146226123,
		/// <summary>Value: 0x80133036</summary>
		SaveElementFailed = -2146226122,
		/// <summary>Value: 0x80133037</summary>
		SiteAlreadySet = -2146226121,
		/// <summary>Value: 0x80133038</summary>
		SiteInvalid = -2146226120,
		/// <summary>Value: 0x80133039</summary>
		SiteNotSet = -2146226119,
		/// <summary>Value: 0x8013303A</summary>
		SourceItemNotAvailable = -2146226118,
		/// <summary>Value: 0x8013303B</summary>
		SourceMonikerNotAvailable = -2146226117,
		/// <summary>Value: 0x8013303C</summary>
		URLInvalid = -2146226116,
		/// <summary>Value: 0x8013303D</summary>
		BrowserNotExist = -2146226115,
		/// <summary>Value: 0x8013303E</summary>
		DebuggeeNotStarted = -2146226114,
		/// <summary>Value: 0x8013303F</summary>
		EngineNameInvalid = -2146226113,
		/// <summary>Value: 0x80133040</summary>
		EngineNotExist = -2146226112,
		/// <summary>Value: 0x80133041</summary>
		FileFormatUnsupported = -2146226111,
		/// <summary>Value: 0x80133042</summary>
		FileTypeUnknown = -2146226110,
		/// <summary>Value: 0x80133043</summary>
		ItemCannotBeRenamed = -2146226109,
		/// <summary>Value: 0x80133044</summary>
		MissingSource = -2146226108,
		/// <summary>Value: 0x80133045</summary>
		NotInitCompleted = -2146226107,
		/// <summary>Value: 0x80133046</summary>
		NameTooLong = -2146226106,
		/// <summary>Value: 0x80133047</summary>
		ProcNameInUse = -2146226105,
		/// <summary>Value: 0x80133048</summary>
		ProcNameInvalid = -2146226104,
		/// <summary>Value: 0x80133049</summary>
		VsaServerDown = -2146226103,
		/// <summary>Value: 0x8013304A</summary>
		MissingPdb = -2146226102,
		/// <summary>Value: 0x8013304B</summary>
		NotClientSideAndNoUrl = -2146226101,
		/// <summary>Value: 0x8013304C</summary>
		CannotAttachToWebServer = -2146226100,
		/// <summary>Value: 0x8013303F</summary>
		EngineNameNotSet = -2146226099,
		/// <summary>Value: 0x801330FF</summary>
		UnknownError = -2146225921
	}
	/// <summary>This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
	[Serializable]
	[Guid("064C47AC-C9DF-4FCD-9009-E9299D620018")]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	[ComVisible(true)]
	[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
	public sealed class JSVsaException : ExternalException
	{
		/// <summary>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
		/// <returns>A <see cref="T:Microsoft.JScript.Vsa.JSVsaError" /> value that describes the reason for the exception.</returns>
		public new JSVsaError ErrorCode => (JSVsaError)base.HResult;

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Vsa.JSVsaException" /> class with a system-supplied message that describes the error. This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
		public JSVsaException()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Vsa.JSVsaException" /> class with a specified message that describes the error. This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		public JSVsaException(string message)
			: base(message)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Vsa.JSVsaException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception. This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		/// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException" /> parameter is not <see langword="null" />, the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</param>
		public JSVsaException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Vsa.JSVsaException" /> class with serialized data. This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
		/// <param name="info">The object that holds the serialized object data.</param>
		/// <param name="context">The contextual information about the source or destination.</param>
		public JSVsaException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			base.HResult = (int)info.GetValue("VsaException_HResult", typeof(int));
			HelpLink = (string)info.GetValue("VsaException_HelpLink", typeof(string));
			Source = (string)info.GetValue("VsaException_Source", typeof(string));
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.JScript.Vsa.JSVsaException" /> class with serialized data. This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
		/// <param name="info">The object that holds the serialized object data.</param>
		/// <param name="context">The contextual information about the source or destination.</param>
		[SecurityCritical]
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("VsaException_HResult", base.HResult);
			info.AddValue("VsaException_HelpLink", HelpLink);
			info.AddValue("VsaException_Source", Source);
		}

		/// <summary>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
		/// <returns>A string representation of the current exception.</returns>
		public override string ToString()
		{
			if (Message != null && "" != Message)
			{
				return "Microsoft.JScript.Vsa.JSVsaException: " + Enum.GetName(((JSVsaError)base.HResult).GetType(), (JSVsaError)base.HResult) + " (0x" + string.Format(CultureInfo.InvariantCulture, "{0,8:X}", new object[1] { base.HResult }) + "): " + Message;
			}
			return "Microsoft.JScript.Vsa.JSVsaException: " + Enum.GetName(((JSVsaError)base.HResult).GetType(), (JSVsaError)base.HResult) + " (0x" + string.Format(CultureInfo.InvariantCulture, "{0,8:X}", new object[1] { base.HResult }) + ").";
		}

		/// <summary>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
		/// <param name="error">A <see cref="T:Microsoft.JScript.Vsa.JSVsaError" /> value that describes the reason for the exception.</param>
		public JSVsaException(JSVsaError error)
			: base(string.Empty, (int)error)
		{
		}

		/// <summary>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
		/// <param name="error">A <see cref="T:Microsoft.JScript.Vsa.JSVsaError" /> value that describes the reason for the exception.</param>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		public JSVsaException(JSVsaError error, string message)
			: base(message, (int)error)
		{
		}

		/// <summary>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
		/// <param name="error">A <see cref="T:Microsoft.JScript.Vsa.JSVsaError" /> value that describes the reason for the exception.</param>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		/// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException" /> parameter is not <see langword="null" />, the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</param>
		public JSVsaException(JSVsaError error, string message, Exception innerException)
			: base(message, innerException)
		{
			base.HResult = (int)error;
		}
	}
	internal enum LoaderAPI
	{
		LoadFrom,
		LoadFile,
		ReflectionOnlyLoadFrom
	}
	/// <summary>Implements <see cref="T:Microsoft.JScript.Vsa.IJSVsaEngine" /> interface.</summary>
	[Guid("B71E484D-93ED-4b56-BFB9-CEED5134822B")]
	[ComVisible(true)]
	[Obsolete("Use of this type is not recommended because it is being deprecated in Visual Studio 2005; there will be no replacement for this feature. Please see the ICodeCompiler documentation for additional help.")]
	public sealed class VsaEngine : BaseVsaEngine, IEngine2, IRedirectOutput
	{
		internal bool alwaysGenerateIL;

		private bool autoRef;

		private Hashtable Defines;

		internal bool doCRS;

		internal bool doFast;

		internal bool doPrint;

		internal bool doSaveAfterCompile;

		private bool doWarnAsError;

		private int nWarningLevel;

		internal bool genStartupClass;

		internal bool isCLSCompliant;

		internal bool versionSafe;

		private string PEFileName;

		internal PEFileKinds PEFileKind;

		internal PortableExecutableKinds PEKindFlags;

		internal ImageFileMachine PEMachineArchitecture;

		internal LoaderAPI ReferenceLoaderAPI;

		private Version versionInfo;

		private CultureInfo errorCultureInfo;

		internal static bool executeForJSEE = false;

		private string libpath;

		private string[] libpathList;

		private bool isCompilerSet;

		internal VsaScriptScope globalScope;

		private ArrayList packages;

		private ArrayList scopes;

		private ArrayList implicitAssemblies;

		private SimpleHashtable implicitAssemblyCache;

		private string win32resource;

		private ICollection managedResources;

		private string debugDirectory;

		private string tempDirectory;

		private RNGCryptoServiceProvider randomNumberGenerator;

		private byte[] rawPE;

		private byte[] rawPDB;

		internal int classCounter;

		private SimpleHashtable cachedTypeLookups;

		internal Thread runningThread;

		private CompilerGlobals compilerGlobals;

		private Globals globals;

		private int numberOfErrors;

		private string runtimeDirectory;

		private static readonly Version CurrentProjectVersion = new Version("1.0");

		private Hashtable typenameTable;

		private static string engineVersion = GetVersionString();

		private Assembly runtimeAssembly;

		private static Hashtable assemblyReferencesTable = null;

		private static Module reflectionOnlyVsaModule = null;

		private static Module reflectionOnlyJScriptModule = null;

		private static TypeReferences _reflectionOnlyTypeRefs;

		private static volatile VsaEngine exeEngine;

		internal Module VsaModule
		{
			get
			{
				if (ReferenceLoaderAPI != LoaderAPI.ReflectionOnlyLoadFrom)
				{
					return typeof(IJSVsaEngine).Module;
				}
				EnsureReflectionOnlyModulesLoaded();
				return reflectionOnlyVsaModule;
			}
		}

		internal Module JScriptModule
		{
			get
			{
				if (ReferenceLoaderAPI != LoaderAPI.ReflectionOnlyLoadFrom)
				{
					return typeof(VsaEngine).Module;
				}
				EnsureReflectionOnlyModulesLoaded();
				return reflectionOnlyJScriptModule;
			}
		}

		internal CompilerGlobals CompilerGlobals
		{
			get
			{
				if (compilerGlobals == null)
				{
					compilerGlobals = new CompilerGlobals(this, base.Name, PEFileName, PEFileKind, doSaveAfterCompile || genStartupClass, !doSaveAfterCompile || genStartupClass, genDebugInfo, isCLSCompliant, versionInfo, globals);
				}
				return compilerGlobals;
			}
		}

		private TypeReferences TypeRefs
		{
			get
			{
				TypeReferences typeReferences;
				if (LoaderAPI.ReflectionOnlyLoadFrom == ReferenceLoaderAPI)
				{
					typeReferences = _reflectionOnlyTypeRefs;
					if (typeReferences == null)
					{
						typeReferences = (_reflectionOnlyTypeRefs = new TypeReferences(JScriptModule));
					}
				}
				else
				{
					typeReferences = Runtime.TypeRefs;
				}
				return typeReferences;
			}
		}

		internal CultureInfo ErrorCultureInfo
		{
			get
			{
				if (errorCultureInfo == null || errorCultureInfo.LCID != errorLocale)
				{
					errorCultureInfo = new CultureInfo(errorLocale);
				}
				return errorCultureInfo;
			}
		}

		internal Globals Globals
		{
			get
			{
				if (globals == null)
				{
					globals = new Globals(doFast, this);
				}
				return globals;
			}
		}

		internal bool HasErrors => numberOfErrors != 0;

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public LenientGlobalObject LenientGlobalObject => (LenientGlobalObject)Globals.globalObject;

		internal ArrayList Scopes
		{
			get
			{
				if (scopes == null)
				{
					scopes = new ArrayList(8);
				}
				return scopes;
			}
		}

		internal string RuntimeDirectory
		{
			get
			{
				if (runtimeDirectory == null)
				{
					string fullyQualifiedName = typeof(object).Module.FullyQualifiedName;
					runtimeDirectory = Path.GetDirectoryName(fullyQualifiedName);
				}
				return runtimeDirectory;
			}
		}

		internal string[] LibpathList
		{
			get
			{
				if (libpathList == null)
				{
					if (libpath == null)
					{
						libpathList = new string[1] { typeof(object).Module.Assembly.Location };
					}
					else
					{
						libpathList = libpath.Split(Path.PathSeparator);
					}
				}
				return libpathList;
			}
		}

		private static string GetVersionString()
		{
			return 14 + "." + 0.ToString(CultureInfo.InvariantCulture).PadLeft(2, '0') + "." + 0.ToString(CultureInfo.InvariantCulture) + "." + 9037.ToString(CultureInfo.InvariantCulture).PadLeft(4, '0');
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public VsaEngine()
			: this(fast: true)
		{
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="fast" />
		public VsaEngine(bool fast)
			: base("JScript", engineVersion, supportDebug: true)
		{
			alwaysGenerateIL = false;
			autoRef = false;
			doCRS = false;
			doFast = fast;
			genDebugInfo = false;
			genStartupClass = true;
			doPrint = false;
			doWarnAsError = false;
			nWarningLevel = 4;
			isCLSCompliant = false;
			versionSafe = false;
			PEFileName = null;
			PEFileKind = PEFileKinds.Dll;
			PEKindFlags = PortableExecutableKinds.ILOnly;
			PEMachineArchitecture = ImageFileMachine.I386;
			ReferenceLoaderAPI = LoaderAPI.LoadFrom;
			errorCultureInfo = null;
			libpath = null;
			libpathList = null;
			globalScope = null;
			vsaItems = new VsaItems(this);
			packages = null;
			scopes = null;
			classCounter = 0;
			implicitAssemblies = null;
			implicitAssemblyCache = null;
			cachedTypeLookups = null;
			isEngineRunning = false;
			isEngineCompiled = false;
			isCompilerSet = false;
			isClosed = false;
			runningThread = null;
			compilerGlobals = null;
			globals = null;
			runtimeDirectory = null;
			Globals.contextEngine = this;
			runtimeAssembly = null;
			typenameTable = null;
		}

		private VsaEngine(Assembly runtimeAssembly)
			: this(fast: true)
		{
			this.runtimeAssembly = runtimeAssembly;
		}

		internal void EnsureReflectionOnlyModulesLoaded()
		{
			if (reflectionOnlyVsaModule == null)
			{
				reflectionOnlyVsaModule = Assembly.ReflectionOnlyLoadFrom(typeof(IJSVsaEngine).Assembly.Location).GetModule("Microsoft.JScript.Vsa.dll");
				reflectionOnlyJScriptModule = Assembly.ReflectionOnlyLoadFrom(typeof(VsaEngine).Assembly.Location).GetModule("Microsoft.JScript.dll");
			}
		}

		private void AddChildAndValue(XmlDocument doc, XmlElement parent, string name, string value)
		{
			XmlElement xmlElement = doc.CreateElement(name);
			CreateAttribute(doc, xmlElement, "Value", value);
			parent.AppendChild(xmlElement);
		}

		internal void AddPackage(PackageScope pscope)
		{
			if (packages == null)
			{
				packages = new ArrayList(8);
			}
			IEnumerator enumerator = packages.GetEnumerator();
			while (enumerator.MoveNext())
			{
				PackageScope packageScope = (PackageScope)enumerator.Current;
				if (packageScope.name.Equals(pscope.name))
				{
					packageScope.owner.MergeWith(pscope.owner);
					return;
				}
			}
			packages.Add(pscope);
		}

		internal void CheckForErrors()
		{
			if (!isClosed && !isEngineCompiled)
			{
				SetUpCompilerEnvironment();
				Globals.ScopeStack.Push(GetGlobalScope().GetObject());
				try
				{
					foreach (object vsaItem in vsaItems)
					{
						if (vsaItem is VsaReference)
						{
							((VsaReference)vsaItem).Compile();
						}
					}
					if (vsaItems.Count > 0)
					{
						SetEnclosingContext(new WrappedNamespace("", this));
					}
					foreach (object vsaItem2 in vsaItems)
					{
						if (!(vsaItem2 is VsaReference))
						{
							((VsaItem)vsaItem2).CheckForErrors();
						}
					}
					if (globalScope != null)
					{
						globalScope.CheckForErrors();
					}
				}
				finally
				{
					Globals.ScopeStack.Pop();
				}
			}
			globalScope = null;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="domain" />
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public IJSVsaEngine Clone(AppDomain domain)
		{
			throw new NotImplementedException();
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public bool CompileEmpty()
		{
			TryObtainLock();
			try
			{
				return DoCompile();
			}
			finally
			{
				ReleaseLock();
			}
		}

		private void CreateAttribute(XmlDocument doc, XmlElement elem, string name, string value)
		{
			XmlAttribute attributeNode = doc.CreateAttribute(name);
			elem.SetAttributeNode(attributeNode);
			elem.SetAttribute(name, value);
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void ConnectEvents()
		{
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="fast" />
		/// <param name="assemblyNames" />
		public static GlobalScope CreateEngineAndGetGlobalScope(bool fast, string[] assemblyNames)
		{
			VsaEngine vsaEngine = new VsaEngine(fast);
			vsaEngine.InitVsaEngine("JScript.Vsa.VsaEngine://Microsoft.JScript.VsaEngine.Vsa", new DefaultVsaSite());
			vsaEngine.doPrint = true;
			vsaEngine.SetEnclosingContext(new WrappedNamespace("", vsaEngine));
			foreach (string text in assemblyNames)
			{
				VsaReference vsaReference = (VsaReference)vsaEngine.vsaItems.CreateItem(text, JSVsaItemType.Reference, JSVsaItemFlag.None);
				vsaReference.AssemblyName = text;
			}
			exeEngine = vsaEngine;
			GlobalScope globalScope = (GlobalScope)vsaEngine.GetGlobalScope().GetObject();
			globalScope.globalObject = vsaEngine.Globals.globalObject;
			return globalScope;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="fast" />
		/// <param name="assemblyNames" />
		/// <param name="callingTypeHandle" />
		public static GlobalScope CreateEngineAndGetGlobalScopeWithType(bool fast, string[] assemblyNames, RuntimeTypeHandle callingTypeHandle)
		{
			return CreateEngineAndGetGlobalScopeWithTypeAndRootNamespace(fast, assemblyNames, callingTypeHandle, null);
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="fast" />
		/// <param name="assemblyNames" />
		/// <param name="callingTypeHandle" />
		/// <param name="rootNamespace" />
		/// <returns>Returns <see cref="T:Microsoft.JScript.GlobalScope" />.</returns>
		public static GlobalScope CreateEngineAndGetGlobalScopeWithTypeAndRootNamespace(bool fast, string[] assemblyNames, RuntimeTypeHandle callingTypeHandle, string rootNamespace)
		{
			VsaEngine vsaEngine = new VsaEngine(fast);
			vsaEngine.InitVsaEngine("JScript.Vsa.VsaEngine://Microsoft.JScript.VsaEngine.Vsa", new DefaultVsaSite());
			vsaEngine.doPrint = true;
			vsaEngine.SetEnclosingContext(new WrappedNamespace("", vsaEngine));
			if (rootNamespace != null)
			{
				vsaEngine.SetEnclosingContext(new WrappedNamespace(rootNamespace, vsaEngine));
			}
			foreach (string text in assemblyNames)
			{
				VsaReference vsaReference = (VsaReference)vsaEngine.vsaItems.CreateItem(text, JSVsaItemType.Reference, JSVsaItemFlag.None);
				vsaReference.AssemblyName = text;
			}
			Type typeFromHandle = Type.GetTypeFromHandle(callingTypeHandle);
			Assembly assembly = typeFromHandle.Assembly;
			System.Runtime.Remoting.Messaging.CallContext.SetData("JScript:" + assembly.FullName, vsaEngine);
			GlobalScope globalScope = (GlobalScope)vsaEngine.GetGlobalScope().GetObject();
			globalScope.globalObject = vsaEngine.Globals.globalObject;
			return globalScope;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public static VsaEngine CreateEngine()
		{
			if (exeEngine == null)
			{
				VsaEngine vsaEngine = new VsaEngine(fast: true);
				vsaEngine.InitVsaEngine("JScript.Vsa.VsaEngine://Microsoft.JScript.VsaEngine.Vsa", new DefaultVsaSite());
				exeEngine = vsaEngine;
			}
			return exeEngine;
		}

		internal static VsaEngine CreateEngineForDebugger()
		{
			VsaEngine vsaEngine = new VsaEngine(fast: true);
			vsaEngine.InitVsaEngine("JScript.Vsa.VsaEngine://Microsoft.JScript.VsaEngine.Vsa", new DefaultVsaSite());
			GlobalScope globalScope = (GlobalScope)vsaEngine.GetGlobalScope().GetObject();
			globalScope.globalObject = vsaEngine.Globals.globalObject;
			return vsaEngine;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="callingTypeHandle" />
		public static VsaEngine CreateEngineWithType(RuntimeTypeHandle callingTypeHandle)
		{
			Type typeFromHandle = Type.GetTypeFromHandle(callingTypeHandle);
			Assembly assembly = typeFromHandle.Assembly;
			object data = System.Runtime.Remoting.Messaging.CallContext.GetData("JScript:" + assembly.FullName);
			if (data != null && data is VsaEngine result)
			{
				return result;
			}
			VsaEngine vsaEngine = new VsaEngine(assembly);
			vsaEngine.InitVsaEngine("JScript.Vsa.VsaEngine://Microsoft.JScript.VsaEngine.Vsa", new DefaultVsaSite());
			GlobalScope globalScope = (GlobalScope)vsaEngine.GetGlobalScope().GetObject();
			globalScope.globalObject = vsaEngine.Globals.globalObject;
			int num = 0;
			Type type = null;
			do
			{
				string name = "JScript " + num.ToString(CultureInfo.InvariantCulture);
				type = assembly.GetType(name, throwOnError: false);
				if (type != null)
				{
					vsaEngine.SetEnclosingContext(new WrappedNamespace("", vsaEngine));
					ConstructorInfo constructor = type.GetConstructor(new Type[1] { typeof(GlobalScope) });
					MethodInfo method = type.GetMethod("Global Code");
					try
					{
						object obj = constructor.Invoke(new object[1] { globalScope });
						method.Invoke(obj, new object[0]);
					}
					catch (SecurityException)
					{
						break;
					}
				}
				num++;
			}
			while (type != null);
			if (data == null)
			{
				System.Runtime.Remoting.Messaging.CallContext.SetData("JScript:" + assembly.FullName, vsaEngine);
			}
			return vsaEngine;
		}

		private void AddReferences()
		{
			if (assemblyReferencesTable == null)
			{
				Hashtable table = new Hashtable();
				assemblyReferencesTable = Hashtable.Synchronized(table);
			}
			if (assemblyReferencesTable[runtimeAssembly.FullName] is string[] array)
			{
				for (int i = 0; i < array.Length; i++)
				{
					VsaReference vsaReference = (VsaReference)vsaItems.CreateItem(array[i], JSVsaItemType.Reference, JSVsaItemFlag.None);
					vsaReference.AssemblyName = array[i];
				}
				return;
			}
			object[] customAttributes = CustomAttribute.GetCustomAttributes(runtimeAssembly, typeof(ReferenceAttribute), inherit: false);
			string[] array2 = new string[customAttributes.Length];
			for (int j = 0; j < customAttributes.Length; j++)
			{
				string reference = ((ReferenceAttribute)customAttributes[j]).reference;
				VsaReference vsaReference2 = (VsaReference)vsaItems.CreateItem(reference, JSVsaItemType.Reference, JSVsaItemFlag.None);
				vsaReference2.AssemblyName = reference;
				array2[j] = reference;
			}
			assemblyReferencesTable[runtimeAssembly.FullName] = array2;
		}

		private void EmitReferences()
		{
			SimpleHashtable simpleHashtable = new SimpleHashtable((uint)(vsaItems.Count + ((implicitAssemblies != null) ? implicitAssemblies.Count : 0)));
			foreach (object vsaItem in vsaItems)
			{
				if (vsaItem is VsaReference)
				{
					string fullName = ((VsaReference)vsaItem).Assembly.GetName().FullName;
					if (simpleHashtable[fullName] == null)
					{
						CustomAttributeBuilder customAttribute = new CustomAttributeBuilder(CompilerGlobals.referenceAttributeConstructor, new object[1] { fullName });
						CompilerGlobals.assemblyBuilder.SetCustomAttribute(customAttribute);
						simpleHashtable[fullName] = vsaItem;
					}
				}
			}
			if (implicitAssemblies == null)
			{
				return;
			}
			foreach (object implicitAssembly in implicitAssemblies)
			{
				Assembly assembly = implicitAssembly as Assembly;
				if (assembly != null)
				{
					string fullName2 = assembly.GetName().FullName;
					if (simpleHashtable[fullName2] == null)
					{
						CustomAttributeBuilder customAttribute2 = new CustomAttributeBuilder(CompilerGlobals.referenceAttributeConstructor, new object[1] { fullName2 });
						CompilerGlobals.assemblyBuilder.SetCustomAttribute(customAttribute2);
						simpleHashtable[fullName2] = implicitAssembly;
					}
				}
			}
		}

		private void CreateMain()
		{
			TypeBuilder typeBuilder = CompilerGlobals.module.DefineType("JScript Main", TypeAttributes.Public);
			MethodBuilder methodBuilder = typeBuilder.DefineMethod("Main", MethodAttributes.Public | MethodAttributes.Static, Typeob.Void, new Type[1] { Typeob.ArrayOfString });
			methodBuilder.SetCustomAttribute(Typeob.STAThreadAttribute.GetConstructor(Type.EmptyTypes), new byte[0]);
			ILGenerator iLGenerator = methodBuilder.GetILGenerator();
			CreateEntryPointIL(iLGenerator, null);
			typeBuilder.CreateType();
			CompilerGlobals.assemblyBuilder.SetEntryPoint(methodBuilder, PEFileKind);
		}

		private void CreateStartupClass()
		{
			TypeBuilder typeBuilder = CompilerGlobals.module.DefineType(rootNamespace + "._Startup", TypeAttributes.Public, Typeob.BaseVsaStartup);
			FieldInfo field = Typeob.BaseVsaStartup.GetField("site", BindingFlags.Instance | BindingFlags.NonPublic);
			MethodBuilder methodBuilder = typeBuilder.DefineMethod("Startup", MethodAttributes.Public | MethodAttributes.Virtual, Typeob.Void, Type.EmptyTypes);
			CreateEntryPointIL(methodBuilder.GetILGenerator(), field, typeBuilder);
			MethodBuilder methodBuilder2 = typeBuilder.DefineMethod("Shutdown", MethodAttributes.Public | MethodAttributes.Virtual, Typeob.Void, Type.EmptyTypes);
			CreateShutdownIL(methodBuilder2.GetILGenerator());
			typeBuilder.CreateType();
		}

		private void CreateEntryPointIL(ILGenerator il, FieldInfo site)
		{
			CreateEntryPointIL(il, site, null);
		}

		private void CreateEntryPointIL(ILGenerator il, FieldInfo site, TypeBuilder startupClass)
		{
			LocalBuilder local = il.DeclareLocal(Typeob.GlobalScope);
			if (doFast)
			{
				il.Emit(OpCodes.Ldc_I4_1);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4_0);
			}
			SimpleHashtable simpleHashtable = new SimpleHashtable((uint)vsaItems.Count);
			ArrayList arrayList = new ArrayList();
			foreach (object vsaItem in vsaItems)
			{
				if (vsaItem is VsaReference)
				{
					string fullName = ((VsaReference)vsaItem).Assembly.GetName().FullName;
					if (simpleHashtable[fullName] == null)
					{
						arrayList.Add(fullName);
						simpleHashtable[fullName] = vsaItem;
					}
				}
			}
			if (implicitAssemblies != null)
			{
				foreach (object implicitAssembly in implicitAssemblies)
				{
					Assembly assembly = implicitAssembly as Assembly;
					if (assembly != null)
					{
						string fullName2 = assembly.GetName().FullName;
						if (simpleHashtable[fullName2] == null)
						{
							arrayList.Add(fullName2);
							simpleHashtable[fullName2] = implicitAssembly;
						}
					}
				}
			}
			ConstantWrapper.TranslateToILInt(il, arrayList.Count);
			il.Emit(OpCodes.Newarr, Typeob.String);
			int num = 0;
			foreach (string item in arrayList)
			{
				il.Emit(OpCodes.Dup);
				ConstantWrapper.TranslateToILInt(il, num++);
				il.Emit(OpCodes.Ldstr, item);
				il.Emit(OpCodes.Stelem_Ref);
			}
			if (startupClass != null)
			{
				il.Emit(OpCodes.Ldtoken, startupClass);
				if (rootNamespace != null)
				{
					il.Emit(OpCodes.Ldstr, rootNamespace);
				}
				else
				{
					il.Emit(OpCodes.Ldnull);
				}
				MethodInfo method = Typeob.VsaEngine.GetMethod("CreateEngineAndGetGlobalScopeWithTypeAndRootNamespace");
				il.Emit(OpCodes.Call, method);
			}
			else
			{
				MethodInfo method2 = Typeob.VsaEngine.GetMethod("CreateEngineAndGetGlobalScope");
				il.Emit(OpCodes.Call, method2);
			}
			il.Emit(OpCodes.Stloc, local);
			if (site != null)
			{
				CreateHostCallbackIL(il, site);
			}
			bool flag = genDebugInfo;
			bool flag2 = false;
			foreach (object vsaItem2 in vsaItems)
			{
				Type compiledType = ((VsaItem)vsaItem2).GetCompiledType();
				if (null != compiledType)
				{
					ConstructorInfo constructor = compiledType.GetConstructor(new Type[1] { Typeob.GlobalScope });
					MethodInfo method3 = compiledType.GetMethod("Global Code");
					if (flag)
					{
						CompilerGlobals.module.SetUserEntryPoint(method3);
						flag = false;
					}
					il.Emit(OpCodes.Ldloc, local);
					il.Emit(OpCodes.Newobj, constructor);
					if (!flag2 && vsaItem2 is VsaStaticCode)
					{
						LocalBuilder local2 = il.DeclareLocal(compiledType);
						il.Emit(OpCodes.Stloc, local2);
						il.Emit(OpCodes.Ldloc, local);
						il.Emit(OpCodes.Ldfld, CompilerGlobals.engineField);
						il.Emit(OpCodes.Ldloc, local2);
						il.Emit(OpCodes.Call, CompilerGlobals.pushScriptObjectMethod);
						il.Emit(OpCodes.Ldloc, local2);
						flag2 = true;
					}
					il.Emit(OpCodes.Call, method3);
					il.Emit(OpCodes.Pop);
				}
			}
			if (flag2)
			{
				il.Emit(OpCodes.Ldloc, local);
				il.Emit(OpCodes.Ldfld, CompilerGlobals.engineField);
				il.Emit(OpCodes.Call, CompilerGlobals.popScriptObjectMethod);
				il.Emit(OpCodes.Pop);
			}
			il.Emit(OpCodes.Ret);
		}

		private void CreateHostCallbackIL(ILGenerator il, FieldInfo site)
		{
			MethodInfo method = site.FieldType.GetMethod("GetGlobalInstance");
			MethodInfo method2 = site.FieldType.GetMethod("GetEventSourceInstance");
			foreach (object vsaItem in vsaItems)
			{
				if (vsaItem is VsaHostObject)
				{
					VsaHostObject vsaHostObject = (VsaHostObject)vsaItem;
					il.Emit(OpCodes.Ldarg_0);
					il.Emit(OpCodes.Ldfld, site);
					il.Emit(OpCodes.Ldstr, vsaHostObject.Name);
					il.Emit(OpCodes.Callvirt, method);
					Type fieldType = vsaHostObject.Field.FieldType;
					il.Emit(OpCodes.Ldtoken, fieldType);
					il.Emit(OpCodes.Call, CompilerGlobals.getTypeFromHandleMethod);
					ConstantWrapper.TranslateToILInt(il, 0);
					il.Emit(OpCodes.Call, CompilerGlobals.coerceTMethod);
					if (fieldType.IsValueType)
					{
						Convert.EmitUnbox(il, fieldType, Type.GetTypeCode(fieldType));
					}
					else
					{
						il.Emit(OpCodes.Castclass, fieldType);
					}
					il.Emit(OpCodes.Stsfld, vsaHostObject.Field);
				}
			}
		}

		private void CreateShutdownIL(ILGenerator il)
		{
			foreach (object vsaItem in vsaItems)
			{
				if (vsaItem is VsaHostObject)
				{
					il.Emit(OpCodes.Ldnull);
					il.Emit(OpCodes.Stsfld, ((VsaHostObject)vsaItem).Field);
				}
			}
			il.Emit(OpCodes.Ret);
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void DisconnectEvents()
		{
		}

		protected override void DoClose()
		{
			((VsaItems)vsaItems).Close();
			if (globalScope != null)
			{
				globalScope.Close();
			}
			vsaItems = null;
			engineSite = null;
			globalScope = null;
			runningThread = null;
			compilerGlobals = null;
			globals = null;
			ScriptStream.Out = Console.Out;
			ScriptStream.Error = Console.Error;
			rawPE = null;
			rawPDB = null;
			isClosed = true;
			if (tempDirectory != null && Directory.Exists(tempDirectory))
			{
				Directory.Delete(tempDirectory);
			}
		}

		protected override bool DoCompile()
		{
			if (!isClosed && !isEngineCompiled)
			{
				SetUpCompilerEnvironment();
				if (PEFileName == null)
				{
					PEFileName = GenerateRandomPEFileName();
				}
				SaveSourceForDebugging();
				numberOfErrors = 0;
				isEngineCompiled = true;
				Globals.ScopeStack.Push(GetGlobalScope().GetObject());
				try
				{
					foreach (object vsaItem in vsaItems)
					{
						if (vsaItem is VsaReference)
						{
							((VsaReference)vsaItem).Compile();
						}
					}
					if (vsaItems.Count > 0)
					{
						SetEnclosingContext(new WrappedNamespace("", this));
					}
					foreach (object vsaItem2 in vsaItems)
					{
						if (vsaItem2 is VsaHostObject)
						{
							((VsaHostObject)vsaItem2).Compile();
						}
					}
					foreach (object vsaItem3 in vsaItems)
					{
						if (vsaItem3 is VsaStaticCode)
						{
							((VsaStaticCode)vsaItem3).Parse();
						}
					}
					foreach (object vsaItem4 in vsaItems)
					{
						if (vsaItem4 is VsaStaticCode)
						{
							((VsaStaticCode)vsaItem4).ProcessAssemblyAttributeLists();
						}
					}
					foreach (object vsaItem5 in vsaItems)
					{
						if (vsaItem5 is VsaStaticCode)
						{
							((VsaStaticCode)vsaItem5).PartiallyEvaluate();
						}
					}
					foreach (object vsaItem6 in vsaItems)
					{
						if (vsaItem6 is VsaStaticCode)
						{
							((VsaStaticCode)vsaItem6).TranslateToIL();
						}
					}
					foreach (object vsaItem7 in vsaItems)
					{
						if (vsaItem7 is VsaStaticCode)
						{
							((VsaStaticCode)vsaItem7).GetCompiledType();
						}
					}
					if (globalScope != null)
					{
						globalScope.Compile();
					}
				}
				catch (JScriptException se)
				{
					OnCompilerError(se);
				}
				catch (FileLoadException ex2)
				{
					JScriptException ex = new JScriptException(JSError.ImplicitlyReferencedAssemblyNotFound);
					ex.value = ex2.FileName;
					OnCompilerError(ex);
					isEngineCompiled = false;
				}
				catch (EndOfFile)
				{
				}
				catch
				{
					isEngineCompiled = false;
					throw;
				}
				finally
				{
					Globals.ScopeStack.Pop();
				}
				if (isEngineCompiled)
				{
					isEngineCompiled = numberOfErrors == 0 || alwaysGenerateIL;
				}
			}
			if (win32resource != null)
			{
				CompilerGlobals.assemblyBuilder.DefineUnmanagedResource(win32resource);
			}
			else if (compilerGlobals != null)
			{
				compilerGlobals.assemblyBuilder.DefineVersionInfoResource();
			}
			if (managedResources != null)
			{
				foreach (ResInfo managedResource in managedResources)
				{
					if (managedResource.isLinked)
					{
						CompilerGlobals.assemblyBuilder.AddResourceFile(managedResource.name, Path.GetFileName(managedResource.filename), managedResource.isPublic ? ResourceAttributes.Public : ResourceAttributes.Private);
						continue;
					}
					try
					{
						using ResourceReader resourceReader = new ResourceReader(managedResource.filename);
						IResourceWriter resourceWriter = CompilerGlobals.module.DefineResource(managedResource.name, managedResource.filename, managedResource.isPublic ? ResourceAttributes.Public : ResourceAttributes.Private);
						foreach (DictionaryEntry item in resourceReader)
						{
							resourceWriter.AddResource((string)item.Key, item.Value);
						}
					}
					catch (ArgumentException)
					{
						JScriptException ex3 = new JScriptException(JSError.InvalidResource);
						ex3.value = managedResource.filename;
						OnCompilerError(ex3);
						isEngineCompiled = false;
						return false;
					}
				}
			}
			if (isEngineCompiled)
			{
				EmitReferences();
			}
			if (isEngineCompiled)
			{
				if (doSaveAfterCompile)
				{
					if (PEFileKind != PEFileKinds.Dll)
					{
						CreateMain();
					}
					try
					{
						compilerGlobals.assemblyBuilder.Save(Path.GetFileName(PEFileName), PEKindFlags, PEMachineArchitecture);
					}
					catch (Exception ex5)
					{
						throw new JSVsaException(JSVsaError.SaveCompiledStateFailed, ex5.Message, ex5);
					}
				}
				else if (genStartupClass)
				{
					CreateStartupClass();
				}
			}
			return isEngineCompiled;
		}

		private string GenerateRandomPEFileName()
		{
			if (randomNumberGenerator == null)
			{
				randomNumberGenerator = new RNGCryptoServiceProvider();
			}
			byte[] array = new byte[6];
			randomNumberGenerator.GetBytes(array);
			string text = System.Convert.ToBase64String(array);
			text = text.Replace('/', '-');
			text = text.Replace('+', '_');
			if (tempDirectory == null)
			{
				tempDirectory = Path.GetTempPath() + text;
			}
			string text2 = text + ((PEFileKind == PEFileKinds.Dll) ? ".dll" : ".exe");
			return tempDirectory + Path.DirectorySeparatorChar + text2;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public Assembly GetAssembly()
		{
			TryObtainLock();
			try
			{
				if (PEFileName != null)
				{
					return Assembly.LoadFrom(PEFileName);
				}
				return compilerGlobals.assemblyBuilder;
			}
			finally
			{
				ReleaseLock();
			}
		}

		internal ClassScope GetClass(string className)
		{
			if (packages != null)
			{
				int i = 0;
				for (int count = packages.Count; i < count; i++)
				{
					PackageScope packageScope = (PackageScope)packages[i];
					object memberValue = packageScope.GetMemberValue(className, 1);
					if (!(memberValue is Missing))
					{
						return (ClassScope)memberValue;
					}
				}
			}
			return null;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="itemName" />
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public IJSVsaItem GetItem(string itemName)
		{
			return vsaItems[itemName];
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="index" />
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public IJSVsaItem GetItemAtIndex(int index)
		{
			return vsaItems[index];
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public int GetItemCount()
		{
			return vsaItems.Count;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public IVsaScriptScope GetGlobalScope()
		{
			if (this.globalScope == null)
			{
				this.globalScope = new VsaScriptScope(this, "Global", null);
				GlobalScope globalScope = (GlobalScope)this.globalScope.GetObject();
				globalScope.globalObject = Globals.globalObject;
				globalScope.fast = doFast;
				globalScope.isKnownAtCompileTime = doFast;
			}
			return this.globalScope;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public GlobalScope GetMainScope()
		{
			ScriptObject scriptObject = ScriptObjectStackTop();
			while (scriptObject != null && !(scriptObject is GlobalScope))
			{
				scriptObject = scriptObject.GetParent();
			}
			return (GlobalScope)scriptObject;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public Module GetModule()
		{
			if (PEFileName != null)
			{
				Assembly assembly = GetAssembly();
				Module[] modules = assembly.GetModules();
				return modules[0];
			}
			return CompilerGlobals.module;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public ArrayConstructor GetOriginalArrayConstructor()
		{
			return Globals.globalObject.originalArray;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public ObjectConstructor GetOriginalObjectConstructor()
		{
			return Globals.globalObject.originalObject;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public RegExpConstructor GetOriginalRegExpConstructor()
		{
			return Globals.globalObject.originalRegExp;
		}

		protected override object GetCustomOption(string name)
		{
			if (string.Compare(name, "CLSCompliant", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return isCLSCompliant;
			}
			if (string.Compare(name, "fast", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return doFast;
			}
			if (string.Compare(name, "output", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return PEFileName;
			}
			if (string.Compare(name, "PEFileKind", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return PEFileKind;
			}
			if (string.Compare(name, "PortableExecutableKind", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return PEKindFlags;
			}
			if (string.Compare(name, "ImageFileMachine", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return PEMachineArchitecture;
			}
			if (string.Compare(name, "ReferenceLoaderAPI", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return ReferenceLoaderAPI switch
				{
					LoaderAPI.LoadFrom => "LoadFrom", 
					LoaderAPI.LoadFile => "LoadFile", 
					LoaderAPI.ReflectionOnlyLoadFrom => "ReflectionOnlyLoadFrom", 
					_ => throw new JSVsaException(JSVsaError.OptionNotSupported), 
				};
			}
			if (string.Compare(name, "print", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return doPrint;
			}
			if (string.Compare(name, "UseContextRelativeStatics", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return doCRS;
			}
			if (string.Compare(name, "optimize", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return null;
			}
			if (string.Compare(name, "define", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return null;
			}
			if (string.Compare(name, "defines", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return Defines;
			}
			if (string.Compare(name, "ee", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return executeForJSEE;
			}
			if (string.Compare(name, "version", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return versionInfo;
			}
			if (string.Compare(name, "VersionSafe", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return versionSafe;
			}
			if (string.Compare(name, "warnaserror", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return doWarnAsError;
			}
			if (string.Compare(name, "WarningLevel", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return nWarningLevel;
			}
			if (string.Compare(name, "win32resource", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return win32resource;
			}
			if (string.Compare(name, "managedResources", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return managedResources;
			}
			if (string.Compare(name, "alwaysGenerateIL", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return alwaysGenerateIL;
			}
			if (string.Compare(name, "DebugDirectory", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return debugDirectory;
			}
			if (string.Compare(name, "AutoRef", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return autoRef;
			}
			throw new JSVsaException(JSVsaError.OptionNotSupported);
		}

		internal int GetStaticCodeBlockCount()
		{
			return ((VsaItems)vsaItems).staticCodeBlockCount;
		}

		internal Type GetType(string typeName)
		{
			if (cachedTypeLookups == null)
			{
				cachedTypeLookups = new SimpleHashtable(1000u);
			}
			object obj = cachedTypeLookups[typeName];
			if (obj == null)
			{
				int i = 0;
				for (int count = Scopes.Count; i < count; i++)
				{
					GlobalScope globalScope = (GlobalScope)scopes[i];
					Type type = Globals.TypeRefs.ToReferenceContext(globalScope.GetType()).Assembly.GetType(typeName, throwOnError: false);
					if (type != null)
					{
						cachedTypeLookups[typeName] = type;
						return type;
					}
				}
				if (runtimeAssembly != null)
				{
					AddReferences();
					runtimeAssembly = null;
				}
				int j = 0;
				for (int count2 = vsaItems.Count; j < count2; j++)
				{
					object obj2 = vsaItems[j];
					if (obj2 is VsaReference)
					{
						Type type2 = ((VsaReference)obj2).GetType(typeName);
						if (type2 != null)
						{
							cachedTypeLookups[typeName] = type2;
							return type2;
						}
					}
				}
				if (implicitAssemblies == null)
				{
					cachedTypeLookups[typeName] = false;
					return null;
				}
				int k = 0;
				for (int count3 = implicitAssemblies.Count; k < count3; k++)
				{
					Assembly assembly = (Assembly)implicitAssemblies[k];
					Type type3 = assembly.GetType(typeName, throwOnError: false);
					if (type3 != null)
					{
						if (type3.IsPublic && !CustomAttribute.IsDefined(type3, typeof(RequiredAttributeAttribute), inherit: true))
						{
							cachedTypeLookups[typeName] = type3;
							return type3;
						}
						type3 = null;
					}
				}
				cachedTypeLookups[typeName] = false;
				return null;
			}
			return obj as Type;
		}

		private JSScanner GetScannerInstance(string name)
		{
			char[] anyOf = new char[21]
			{
				'\t', '\n', '\v', '\f', '\r', ' ', '\u00a0', '\u2000', '\u2001', '\u2002',
				'\u2003', '\u2004', '\u2005', '\u2006', '\u2007', '\u2008', '\u2009', '\u200a', '\u200b', '\u3000',
				'\ufeff'
			};
			if (name == null || name.IndexOfAny(anyOf) > -1)
			{
				return null;
			}
			VsaItem sourceItem = new VsaStaticCode(this, "itemName", JSVsaItemFlag.None);
			Context context = new Context(new DocumentContext(sourceItem), name);
			context.errorReported = -1;
			JSScanner jSScanner = new JSScanner();
			jSScanner.SetSource(context);
			return jSScanner;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="rootMoniker" />
		/// <param name="site" />
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void InitVsaEngine(string rootMoniker, IJSVsaSite site)
		{
			genStartupClass = false;
			engineMoniker = rootMoniker;
			engineSite = site;
			isEngineInitialized = true;
			rootNamespace = "JScript.DefaultNamespace";
			isEngineDirty = true;
			isEngineCompiled = false;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void Interrupt()
		{
			if (runningThread != null)
			{
				runningThread.Abort();
				runningThread = null;
			}
		}

		protected override bool IsValidNamespaceName(string name)
		{
			JSScanner scannerInstance = GetScannerInstance(name);
			if (scannerInstance == null)
			{
				return false;
			}
			while (true)
			{
				if (scannerInstance.PeekToken() != JSToken.Identifier)
				{
					return false;
				}
				scannerInstance.GetNextToken();
				if (scannerInstance.PeekToken() == JSToken.EndOfFile)
				{
					break;
				}
				if (scannerInstance.PeekToken() != JSToken.AccessField)
				{
					return false;
				}
				scannerInstance.GetNextToken();
			}
			return true;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="ident" />
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public override bool IsValidIdentifier(string ident)
		{
			JSScanner scannerInstance = GetScannerInstance(ident);
			if (scannerInstance == null)
			{
				return false;
			}
			if (scannerInstance.PeekToken() != JSToken.Identifier)
			{
				return false;
			}
			scannerInstance.GetNextToken();
			if (scannerInstance.PeekToken() != 0)
			{
				return false;
			}
			return true;
		}

		protected override Assembly LoadCompiledState()
		{
			if (!genDebugInfo)
			{
				Evidence compilationEvidence = CompilerGlobals.compilationEvidence;
				Evidence evidence = executionEvidence;
				if ((compilationEvidence == null && evidence == null) || (compilationEvidence != null && compilationEvidence.Equals(evidence)))
				{
					return compilerGlobals.assemblyBuilder;
				}
			}
			DoSaveCompiledState(out var pe, out var debugInfo);
			return Assembly.Load(pe, debugInfo, executionEvidence);
		}

		protected override void DoLoadSourceState(IJSVsaPersistSite site)
		{
			string xml = site.LoadElement(null);
			try
			{
				XmlDocument xmlDocument = new XmlDocument();
				xmlDocument.LoadXml(xml);
				XmlElement documentElement = xmlDocument.DocumentElement;
				if (LoadProjectVersion(documentElement) == CurrentProjectVersion)
				{
					LoadVsaEngineState(documentElement);
					isEngineDirty = false;
				}
			}
			catch (Exception ex)
			{
				throw new JSVsaException(JSVsaError.UnknownError, ex.ToString(), ex);
			}
		}

		private Version LoadProjectVersion(XmlElement root)
		{
			return new Version(root["ProjectVersion"].GetAttribute("Version"));
		}

		private void LoadVsaEngineState(XmlElement parent)
		{
			XmlElement xmlElement = parent["VsaEngine"];
			applicationPath = xmlElement.GetAttribute("ApplicationBase");
			genDebugInfo = bool.Parse(xmlElement.GetAttribute("GenerateDebugInfo"));
			scriptLanguage = xmlElement.GetAttribute("Language");
			base.LCID = int.Parse(xmlElement.GetAttribute("LCID"), CultureInfo.InvariantCulture);
			base.Name = xmlElement.GetAttribute("Name");
			rootNamespace = xmlElement.GetAttribute("RootNamespace");
			assemblyVersion = xmlElement.GetAttribute("Version");
			LoadCustomOptions(xmlElement);
			LoadVsaItems(xmlElement);
		}

		private void LoadCustomOptions(XmlElement parent)
		{
			XmlElement xmlElement = parent["Options"];
			doFast = bool.Parse(xmlElement.GetAttribute("fast"));
			doPrint = bool.Parse(xmlElement.GetAttribute("print"));
			doCRS = bool.Parse(xmlElement.GetAttribute("UseContextRelativeStatics"));
			versionSafe = bool.Parse(xmlElement.GetAttribute("VersionSafe"));
			libpath = xmlElement.GetAttribute("libpath");
			doWarnAsError = bool.Parse(xmlElement.GetAttribute("warnaserror"));
			nWarningLevel = int.Parse(xmlElement.GetAttribute("WarningLevel"), CultureInfo.InvariantCulture);
			if (xmlElement.HasAttribute("win32resource"))
			{
				win32resource = xmlElement.GetAttribute("win32resource");
			}
			LoadUserDefines(xmlElement);
			LoadManagedResources(xmlElement);
		}

		private void LoadUserDefines(XmlElement parent)
		{
			XmlElement xmlElement = parent["Defines"];
			XmlNodeList childNodes = xmlElement.ChildNodes;
			foreach (XmlElement item in childNodes)
			{
				Defines[item.Name] = item.GetAttribute("Value");
			}
		}

		private void LoadManagedResources(XmlElement parent)
		{
			XmlElement xmlElement = parent["ManagedResources"];
			XmlNodeList childNodes = xmlElement.ChildNodes;
			if (childNodes.Count <= 0)
			{
				return;
			}
			managedResources = new ArrayList(childNodes.Count);
			foreach (XmlElement item in childNodes)
			{
				string attribute = item.GetAttribute("Name");
				string attribute2 = item.GetAttribute("FileName");
				bool isPublic = bool.Parse(item.GetAttribute("Public"));
				bool isLinked = bool.Parse(item.GetAttribute("Linked"));
				((ArrayList)managedResources).Add(new ResInfo(attribute2, attribute, isPublic, isLinked));
			}
		}

		private void LoadVsaItems(XmlElement parent)
		{
			XmlNodeList childNodes = parent["VsaItems"].ChildNodes;
			string strB = JSVsaItemType.Reference.ToString();
			string strB2 = JSVsaItemType.AppGlobal.ToString();
			string strB3 = JSVsaItemType.Code.ToString();
			foreach (XmlElement item in childNodes)
			{
				string attribute = item.GetAttribute("Name");
				string attribute2 = item.GetAttribute("ItemType");
				IJSVsaItem iJSVsaItem;
				if (string.Compare(attribute2, strB, StringComparison.OrdinalIgnoreCase) == 0)
				{
					iJSVsaItem = vsaItems.CreateItem(attribute, JSVsaItemType.Reference, JSVsaItemFlag.None);
					((IJSVsaReferenceItem)iJSVsaItem).AssemblyName = item.GetAttribute("AssemblyName");
				}
				else if (string.Compare(attribute2, strB2, StringComparison.OrdinalIgnoreCase) == 0)
				{
					iJSVsaItem = vsaItems.CreateItem(attribute, JSVsaItemType.AppGlobal, JSVsaItemFlag.None);
					((IJSVsaGlobalItem)iJSVsaItem).ExposeMembers = bool.Parse(item.GetAttribute("ExposeMembers"));
					((IJSVsaGlobalItem)iJSVsaItem).TypeString = item.GetAttribute("TypeString");
				}
				else
				{
					if (string.Compare(attribute2, strB3, StringComparison.OrdinalIgnoreCase) != 0)
					{
						throw new JSVsaException(JSVsaError.LoadElementFailed);
					}
					iJSVsaItem = vsaItems.CreateItem(attribute, JSVsaItemType.Code, JSVsaItemFlag.None);
					XmlCDataSection xmlCDataSection = (XmlCDataSection)item.FirstChild;
					string sourceText = xmlCDataSection.Value.Replace(" >", ">");
					((IJSVsaCodeItem)iJSVsaItem).SourceText = sourceText;
				}
				XmlNodeList childNodes2 = item["Options"].ChildNodes;
				foreach (XmlElement item2 in childNodes2)
				{
					iJSVsaItem.SetOption(item2.Name, item2.GetAttribute("Value"));
				}
				((VsaItem)iJSVsaItem).IsDirty = false;
			}
		}

		internal bool OnCompilerError(JScriptException se)
		{
			if (se.Severity == 0 || (doWarnAsError && se.Severity <= nWarningLevel))
			{
				numberOfErrors++;
			}
			bool flag = engineSite.OnCompilerError(se);
			if (!flag)
			{
				isEngineCompiled = false;
			}
			return flag;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public ScriptObject PopScriptObject()
		{
			return (ScriptObject)Globals.ScopeStack.Pop();
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="obj" />
		public void PushScriptObject(ScriptObject obj)
		{
			Globals.ScopeStack.Push(obj);
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="name" />
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void RegisterEventSource(string name)
		{
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public override void Reset()
		{
			if (genStartupClass)
			{
				base.Reset();
			}
			else
			{
				ResetCompiledState();
			}
		}

		protected override void ResetCompiledState()
		{
			if (globalScope != null)
			{
				globalScope.Reset();
				globalScope = null;
			}
			classCounter = 0;
			haveCompiledState = false;
			failedCompilation = true;
			compiledRootNamespace = null;
			startupClass = null;
			compilerGlobals = null;
			globals = null;
			foreach (object vsaItem in vsaItems)
			{
				((VsaItem)vsaItem).Reset();
			}
			implicitAssemblies = null;
			implicitAssemblyCache = null;
			cachedTypeLookups = null;
			isEngineCompiled = false;
			isEngineRunning = false;
			isCompilerSet = false;
			packages = null;
			if (!doSaveAfterCompile)
			{
				PEFileName = null;
			}
			rawPE = null;
			rawPDB = null;
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void Restart()
		{
			TryObtainLock();
			try
			{
				((VsaItems)vsaItems).Close();
				if (globalScope != null)
				{
					globalScope.Close();
				}
				globalScope = null;
				vsaItems = new VsaItems(this);
				isEngineRunning = false;
				isEngineCompiled = false;
				isCompilerSet = false;
				isClosed = false;
				runningThread = null;
				globals = null;
			}
			finally
			{
				ReleaseLock();
			}
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void RunEmpty()
		{
			TryObtainLock();
			try
			{
				Preconditions(Pre.EngineNotClosed | Pre.RootMonikerSet | Pre.SiteSet);
				isEngineRunning = true;
				runningThread = Thread.CurrentThread;
				if (globalScope != null)
				{
					globalScope.Run();
				}
				foreach (object vsaItem in vsaItems)
				{
					((VsaItem)vsaItem).Run();
				}
			}
			finally
			{
				runningThread = null;
				ReleaseLock();
			}
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="domain" />
		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public void Run(AppDomain domain)
		{
			throw new NotImplementedException();
		}

		protected override void DoSaveCompiledState(out byte[] pe, out byte[] pdb)
		{
			pe = null;
			pdb = null;
			if (rawPE == null)
			{
				try
				{
					if (!Directory.Exists(tempDirectory))
					{
						Directory.CreateDirectory(tempDirectory);
					}
					compilerGlobals.assemblyBuilder.Save(Path.GetFileName(PEFileName), PEKindFlags, PEMachineArchitecture);
					string path = Path.ChangeExtension(PEFileName, ".pdb");
					try
					{
						FileStream fileStream = new FileStream(PEFileName, FileMode.Open, FileAccess.Read, FileShare.Read);
						try
						{
							rawPE = new byte[(int)fileStream.Length];
							fileStream.Read(rawPE, 0, rawPE.Length);
						}
						finally
						{
							fileStream.Close();
						}
						if (File.Exists(path))
						{
							fileStream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read);
							try
							{
								rawPDB = new byte[(int)fileStream.Length];
								fileStream.Read(rawPDB, 0, rawPDB.Length);
							}
							finally
							{
								fileStream.Close();
							}
						}
					}
					finally
					{
						File.Delete(PEFileName);
						if (File.Exists(path))
						{
							File.Delete(path);
						}
					}
				}
				catch (Exception ex)
				{
					throw new JSVsaException(JSVsaError.SaveCompiledStateFailed, ex.ToString(), ex);
				}
			}
			pe = rawPE;
			pdb = rawPDB;
		}

		protected override void DoSaveSourceState(IJSVsaPersistSite site)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.LoadXml("<project></project>");
			XmlElement documentElement = xmlDocument.DocumentElement;
			SaveProjectVersion(xmlDocument, documentElement);
			SaveVsaEngineState(xmlDocument, documentElement);
			site.SaveElement(null, xmlDocument.OuterXml);
			SaveSourceForDebugging();
			isEngineDirty = false;
		}

		private void SaveSourceForDebugging()
		{
			if (!base.GenerateDebugInfo || debugDirectory == null || !isEngineDirty)
			{
				return;
			}
			foreach (VsaItem vsaItem in vsaItems)
			{
				if (!(vsaItem is VsaStaticCode))
				{
					continue;
				}
				string text = debugDirectory + vsaItem.Name + ".js";
				try
				{
					using FileStream stream = new FileStream(text, FileMode.Create, FileAccess.Write);
					using (StreamWriter streamWriter = new StreamWriter(stream))
					{
						streamWriter.Write(((VsaStaticCode)vsaItem).SourceText);
					}
					vsaItem.SetOption("codebase", text);
				}
				catch
				{
				}
			}
		}

		private void SaveProjectVersion(XmlDocument project, XmlElement root)
		{
			XmlElement xmlElement = project.CreateElement("ProjectVersion");
			CreateAttribute(project, xmlElement, "Version", CurrentProjectVersion.ToString());
			root.AppendChild(xmlElement);
		}

		private void SaveVsaEngineState(XmlDocument project, XmlElement parent)
		{
			XmlElement xmlElement = project.CreateElement("VsaEngine");
			CreateAttribute(project, xmlElement, "ApplicationBase", applicationPath);
			CreateAttribute(project, xmlElement, "GenerateDebugInfo", genDebugInfo.ToString());
			CreateAttribute(project, xmlElement, "Language", scriptLanguage);
			CreateAttribute(project, xmlElement, "LCID", errorLocale.ToString(CultureInfo.InvariantCulture));
			CreateAttribute(project, xmlElement, "Name", engineName);
			CreateAttribute(project, xmlElement, "RootNamespace", rootNamespace);
			CreateAttribute(project, xmlElement, "Version", assemblyVersion);
			SaveCustomOptions(project, xmlElement);
			SaveVsaItems(project, xmlElement);
			parent.AppendChild(xmlElement);
		}

		private void SaveCustomOptions(XmlDocument project, XmlElement parent)
		{
			XmlElement xmlElement = project.CreateElement("Options");
			CreateAttribute(project, xmlElement, "fast", doFast.ToString());
			CreateAttribute(project, xmlElement, "print", doPrint.ToString());
			CreateAttribute(project, xmlElement, "UseContextRelativeStatics", doCRS.ToString());
			CreateAttribute(project, xmlElement, "VersionSafe", versionSafe.ToString());
			CreateAttribute(project, xmlElement, "libpath", libpath);
			CreateAttribute(project, xmlElement, "warnaserror", doWarnAsError.ToString());
			CreateAttribute(project, xmlElement, "WarningLevel", nWarningLevel.ToString(CultureInfo.InvariantCulture));
			if (win32resource != null)
			{
				CreateAttribute(project, xmlElement, "win32resource", win32resource);
			}
			SaveUserDefines(project, xmlElement);
			SaveManagedResources(project, xmlElement);
			parent.AppendChild(xmlElement);
		}

		private void SaveUserDefines(XmlDocument project, XmlElement parent)
		{
			XmlElement xmlElement = project.CreateElement("Defines");
			if (Defines != null)
			{
				foreach (string key in Defines.Keys)
				{
					AddChildAndValue(project, xmlElement, key, (string)Defines[key]);
				}
			}
			parent.AppendChild(xmlElement);
		}

		private void SaveManagedResources(XmlDocument project, XmlElement parent)
		{
			XmlElement xmlElement = project.CreateElement("ManagedResources");
			if (managedResources != null)
			{
				foreach (ResInfo managedResource in managedResources)
				{
					XmlElement xmlElement2 = project.CreateElement(managedResource.name);
					CreateAttribute(project, xmlElement2, "File", managedResource.filename);
					CreateAttribute(project, xmlElement2, "Public", managedResource.isPublic.ToString());
					CreateAttribute(project, xmlElement2, "Linked", managedResource.isLinked.ToString());
					xmlElement.AppendChild(xmlElement2);
				}
			}
			parent.AppendChild(xmlElement);
		}

		private void SaveVsaItems(XmlDocument project, XmlElement parent)
		{
			XmlElement xmlElement = project.CreateElement("VsaItems");
			foreach (IJSVsaItem vsaItem in vsaItems)
			{
				XmlElement xmlElement2 = project.CreateElement("IJSVsaItem");
				CreateAttribute(project, xmlElement2, "Name", vsaItem.Name);
				CreateAttribute(project, xmlElement2, "ItemType", vsaItem.ItemType.ToString(CultureInfo.InvariantCulture));
				XmlElement xmlElement3 = project.CreateElement("Options");
				if (vsaItem is VsaHostObject)
				{
					CreateAttribute(project, xmlElement2, "TypeString", ((VsaHostObject)vsaItem).TypeString);
					CreateAttribute(project, xmlElement2, "ExposeMembers", ((VsaHostObject)vsaItem).ExposeMembers.ToString(CultureInfo.InvariantCulture));
				}
				else if (vsaItem is VsaReference)
				{
					CreateAttribute(project, xmlElement2, "AssemblyName", ((VsaReference)vsaItem).AssemblyName);
				}
				else
				{
					if (!(vsaItem is VsaStaticCode))
					{
						throw new JSVsaException(JSVsaError.SaveElementFailed);
					}
					string data = ((VsaStaticCode)vsaItem).SourceText.Replace(">", " >");
					XmlCDataSection newChild = project.CreateCDataSection(data);
					xmlElement2.AppendChild(newChild);
					string text = (string)vsaItem.GetOption("codebase");
					if (text != null)
					{
						AddChildAndValue(project, xmlElement3, "codebase", text);
					}
				}
				((VsaItem)vsaItem).IsDirty = false;
				xmlElement2.AppendChild(xmlElement3);
				xmlElement.AppendChild(xmlElement2);
			}
			parent.AppendChild(xmlElement);
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		public ScriptObject ScriptObjectStackTop()
		{
			return Globals.ScopeStack.Peek();
		}

		internal void SetEnclosingContext(ScriptObject ob)
		{
			ScriptObject scriptObject = Globals.ScopeStack.Peek();
			while (scriptObject.GetParent() != null)
			{
				scriptObject = scriptObject.GetParent();
			}
			scriptObject.SetParent(ob);
		}

		/// <summary>This class, member, or property is internal to the script engine and should not be called from your code.</summary>
		/// <param name="output" />
		public void SetOutputStream(IMessageReceiver output)
		{
			COMCharStream stream = new COMCharStream(output);
			StreamWriter streamWriter = new StreamWriter(stream, Encoding.Default);
			streamWriter.AutoFlush = true;
			ScriptStream.Out = streamWriter;
			ScriptStream.Error = streamWriter;
		}

		protected override void SetCustomOption(string name, object value)
		{
			try
			{
				if (string.Compare(name, "CLSCompliant", StringComparison.OrdinalIgnoreCase) == 0)
				{
					isCLSCompliant = (bool)value;
				}
				else if (string.Compare(name, "fast", StringComparison.OrdinalIgnoreCase) == 0)
				{
					doFast = (bool)value;
				}
				else if (string.Compare(name, "output", StringComparison.OrdinalIgnoreCase) == 0)
				{
					if (value is string)
					{
						PEFileName = (string)value;
						doSaveAfterCompile = true;
					}
				}
				else if (string.Compare(name, "PEFileKind", StringComparison.OrdinalIgnoreCase) == 0)
				{
					PEFileKind = (PEFileKinds)value;
				}
				else if (string.Compare(name, "PortableExecutableKind", StringComparison.OrdinalIgnoreCase) == 0)
				{
					PEKindFlags = (PortableExecutableKinds)value;
				}
				else if (string.Compare(name, "ImageFileMachine", StringComparison.OrdinalIgnoreCase) == 0)
				{
					PEMachineArchitecture = (ImageFileMachine)value;
				}
				else if (string.Compare(name, "ReferenceLoaderAPI", StringComparison.OrdinalIgnoreCase) == 0)
				{
					string strA = (string)value;
					if (string.Compare(strA, "LoadFrom", StringComparison.OrdinalIgnoreCase) == 0)
					{
						ReferenceLoaderAPI = LoaderAPI.LoadFrom;
						return;
					}
					if (string.Compare(strA, "LoadFile", StringComparison.OrdinalIgnoreCase) == 0)
					{
						ReferenceLoaderAPI = LoaderAPI.LoadFile;
						return;
					}
					if (string.Compare(strA, "ReflectionOnlyLoadFrom", StringComparison.OrdinalIgnoreCase) != 0)
					{
						throw new JSVsaException(JSVsaError.OptionInvalid);
					}
					ReferenceLoaderAPI = LoaderAPI.ReflectionOnlyLoadFrom;
				}
				else if (string.Compare(name, "print", StringComparison.OrdinalIgnoreCase) == 0)
				{
					doPrint = (bool)value;
				}
				else if (string.Compare(name, "UseContextRelativeStatics", StringComparison.OrdinalIgnoreCase) == 0)
				{
					doCRS = (bool)value;
				}
				else
				{
					if (string.Compare(name, "optimize", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(name, "define", StringComparison.OrdinalIgnoreCase) == 0)
					{
						return;
					}
					if (string.Compare(name, "defines", StringComparison.OrdinalIgnoreCase) == 0)
					{
						Defines = (Hashtable)value;
					}
					else if (string.Compare(name, "ee", StringComparison.OrdinalIgnoreCase) == 0)
					{
						executeForJSEE = (bool)value;
					}
					else if (string.Compare(name, "version", StringComparison.OrdinalIgnoreCase) == 0)
					{
						versionInfo = (Version)value;
					}
					else if (string.Compare(name, "VersionSafe", StringComparison.OrdinalIgnoreCase) == 0)
					{
						versionSafe = (bool)value;
					}
					else if (string.Compare(name, "libpath", StringComparison.OrdinalIgnoreCase) == 0)
					{
						libpath = (string)value;
					}
					else if (string.Compare(name, "warnaserror", StringComparison.OrdinalIgnoreCase) == 0)
					{
						doWarnAsError = (bool)value;
					}
					else if (string.Compare(name, "WarningLevel", StringComparison.OrdinalIgnoreCase) == 0)
					{
						nWarningLevel = (int)value;
					}
					else if (string.Compare(name, "win32resource", StringComparison.OrdinalIgnoreCase) == 0)
					{
						win32resource = (string)value;
					}
					else if (string.Compare(name, "managedResources", StringComparison.OrdinalIgnoreCase) == 0)
					{
						managedResources = (ICollection)value;
					}
					else if (string.Compare(name, "alwaysGenerateIL", StringComparison.OrdinalIgnoreCase) == 0)
					{
						alwaysGenerateIL = (bool)value;
					}
					else if (string.Compare(name, "DebugDirectory", StringComparison.OrdinalIgnoreCase) == 0)
					{
						if (value == null)
						{
							debugDirectory = null;
							return;
						}
						if (!(value is string text))
						{
							throw new JSVsaException(JSVsaError.OptionInvalid);
						}
						string fullPath;
						try
						{
							fullPath = Path.GetFullPath(text + Path.DirectorySeparatorChar);
							if (!Directory.Exists(fullPath))
							{
								Directory.CreateDirectory(fullPath);
							}
						}
						catch (Exception innerException)
						{
							throw new JSVsaException(JSVsaError.OptionInvalid, "", innerException);
						}
						debugDirectory = fullPath;
					}
					else
					{
						if (string.Compare(name, "AutoRef", StringComparison.OrdinalIgnoreCase) != 0)
						{
							throw new JSVsaException(JSVsaError.OptionNotSupported);
						}
						autoRef = (bool)value;
					}
				}
			}
			catch (JSVsaException)
			{
				throw;
			}
			catch
			{
				throw new JSVsaException(JSVsaError.OptionInvalid);
			}
		}

		internal void SetUpCompilerEnvironment()
		{
			if (!isCompilerSet)
			{
				Globals.TypeRefs = TypeRefs;
				globals = Globals;
				isCompilerSet = true;
			}
		}

		internal void TryToAddImplicitAssemblyReference(string name)
		{
			if (!autoRef)
			{
				return;
			}
			SimpleHashtable simpleHashtable = implicitAssemblyCache;
			string text;
			if (implicitAssemblyCache == null)
			{
				implicitAssemblyCache = new SimpleHashtable(50u);
				implicitAssemblyCache[Path.GetFileNameWithoutExtension(PEFileName).ToLowerInvariant()] = true;
				foreach (object vsaItem in vsaItems)
				{
					if (vsaItem is VsaReference vsaReference && vsaReference.AssemblyName != null)
					{
						text = Path.GetFileName(vsaReference.AssemblyName).ToLowerInvariant();
						if (text.EndsWith(".dll", StringComparison.Ordinal))
						{
							text = text.Substring(0, text.Length - 4);
						}
						implicitAssemblyCache[text] = true;
					}
				}
				implicitAssemblyCache = implicitAssemblyCache;
			}
			text = name.ToLowerInvariant();
			if (implicitAssemblyCache[text] != null)
			{
				return;
			}
			implicitAssemblyCache[text] = true;
			try
			{
				VsaReference vsaReference2 = new VsaReference(this, name + ".dll");
				if (vsaReference2.Compile(throwOnFileNotFound: false))
				{
					ArrayList arrayList = implicitAssemblies;
					if (arrayList == null)
					{
						arrayList = (implicitAssemblies = new ArrayList());
					}
					arrayList.Add(vsaReference2.Assembly);
				}
			}
			catch (JSVsaException)
			{
			}
		}

		internal string FindAssembly(string name)
		{
			string text = name;
			if (Path.GetFileName(name) == name)
			{
				if (File.Exists(name))
				{
					text = Directory.GetCurrentDirectory() + Path.DirectorySeparatorChar + name;
				}
				else
				{
					string text2 = RuntimeDirectory + Path.DirectorySeparatorChar + name;
					if (File.Exists(text2))
					{
						text = text2;
					}
					else
					{
						string[] array = LibpathList;
						string[] array2 = array;
						foreach (string text3 in array2)
						{
							if (text3.Length > 0)
							{
								text2 = text3 + Path.DirectorySeparatorChar + name;
								if (File.Exists(text2))
								{
									text = text2;
									break;
								}
							}
						}
					}
				}
			}
			if (!File.Exists(text))
			{
				return null;
			}
			return text;
		}

		protected override void ValidateRootMoniker(string rootMoniker)
		{
			if (genStartupClass)
			{
				base.ValidateRootMoniker(rootMoniker);
			}
			else if (rootMoniker == null || rootMoniker.Length == 0)
			{
				throw new JSVsaException(JSVsaError.RootMonikerInvalid);
			}
		}

		internal static bool CheckIdentifierForCLSCompliance(string name)
		{
			if (name[0] == '_')
			{
				return false;
			}
			for (int i = 0; i < name.Length; i++)
			{
				if (name[i] == '$')
				{
					return false;
				}
			}
			return true;
		}

		internal void CheckTypeNameForCLSCompliance(string name, string fullname, Context context)
		{
			if (!isCLSCompliant)
			{
				return;
			}
			if (name[0] == '_')
			{
				context.HandleError(JSError.NonCLSCompliantType);
				return;
			}
			if (!CheckIdentifierForCLSCompliance(fullname))
			{
				context.HandleError(JSError.NonCLSCompliantType);
				return;
			}
			if (typenameTable == null)
			{
				typenameTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
			}
			if (typenameTable[fullname] == null)
			{
				typenameTable[fullname] = fullname;
			}
			else
			{
				context.HandleError(JSError.NonCLSCompliantType);
			}
		}
	}
	internal class DefaultVsaSite : BaseVsaSite
	{
		public override bool OnCompilerError(IJSVsaError error)
		{
			throw (JScriptException)error;
		}
	}
}
